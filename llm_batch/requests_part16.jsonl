{"custom_id": "requests#2a9ae4b367fc06eeb1c3c24d1c9f741396dd7576", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 1565 | Contributors (this commit): 16 | Commits (past 90d): 80 | Contributors (cumulative): 16 | DMM Complexity: None\n\nDIFF:\n@@ -236,7 +236,7 @@ class Request(object):\n                 parsed_url = urlparse(url)\n                 if not parsed_url.netloc:\n                     parsed_url = list(parsed_url)\n-                    parsed_url[2] = urllib.quote(urllib.unquote(parsed_url[2]))\n+                    parsed_url[2] = urllib.quote(parsed_url[2], safe=\"%/:=&?~#+!$,;'@()*[]\")\n                     url = urljoin(r.url, str(urlunparse(parsed_url)))\n \n                 # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n@@ -290,7 +290,7 @@ class Request(object):\n         netloc = netloc.encode('idna')\n         if isinstance(path, unicode):\n             path = path.encode('utf-8')\n-        path = urllib.quote(urllib.unquote(path))\n+        path = urllib.quote(path, safe=\"%/:=&?~#+!$,;'@()*[]\")\n         self.url = str(urlunparse([ scheme, netloc, path, params, query, fragment ]))\n \n         if self._enc_params:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#7127bcda974303a1df19fbff22cccfe22fb8aac7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 71 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 8 | Complexity Δ (Sum/Max): 8/8 | Churn Δ: 71 | Churn Cumulative: 71 | Contributors (this commit): 1 | Commits (past 90d): 1 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -0,0 +1,71 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+import unittest\n+import mock\n+import sys\n+import os\n+sys.path.append(os.getcwd())\n+\n+try:\n+    import omnijson as json\n+except ImportError:\n+    import json\n+\n+import requests\n+from requests.models import Response\n+\n+class RequestsAPIUnitTests(unittest.TestCase):\n+    \"\"\"Requests API unit test cases.\"\"\"\n+\n+    def setUp(self):\n+        pass\n+\n+\n+    def tearDown(self):\n+        \"\"\"Teardown.\"\"\"\n+        pass\n+\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_get(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.get('http://google.com')\n+        mock_request.assert_called_once_with('get', 'http://google.com',\n+                                             allow_redirects= True)\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_head(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.head('http://google.com')\n+        mock_request.assert_called_once_with('head', 'http://google.com',\n+                                             allow_redirects= True)\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_post(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.post('http://google.com', {})\n+        mock_request.assert_called_once_with('post', 'http://google.com',\n+                                              data= {})\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_put(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.put('http://google.com', {})\n+        mock_request.assert_called_once_with('put', 'http://google.com',\n+                                             data= {})\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_patch(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.patch('http://google.com', {})\n+        mock_request.assert_called_once_with('patch', 'http://google.com',\n+                                             data= {})\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_delete(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.delete('http://google.com')\n+        mock_request.assert_called_once_with('delete', 'http://google.com')\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f996313aabec649cab6b7a2b90763beab70aee3b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 0 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 0 | Churn Cumulative: 0 | Contributors (this commit): 1 | Commits (past 90d): 1 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#14081bed46399cac578182d48464b954e0fcdc17", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 39 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 39 | Churn Cumulative: 110 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -26,6 +26,45 @@ class RequestsAPIUnitTests(unittest.TestCase):\n         pass\n \n \n+    @mock.patch('requests.api.dispatch_hook')\n+    @mock.patch('requests.api.Request')\n+    @mock.patch('requests.api.cookiejar_from_dict')\n+    def test_request(self, mock_cjar, mock_request, mock_hook):\n+        args = dict(\n+                    method = None,\n+                    url = None,\n+                    data = None,\n+                    params = None,\n+                    headers = None,\n+                    cookiejar = None,\n+                    files = None,\n+                    auth = None,\n+                    timeout = 1,\n+                    allow_redirects = None,\n+                    proxies = None,\n+                   )\n+        hooks = {'args': args, 'pre_request': mock_request,\n+                 'post_request': mock_request, 'response': 'response'}\n+        sideeffect = lambda x,y,z: hooks[x]\n+        mock_cjar.return_value = None\n+        mock_request.send = mock.Mock(return_value={})\n+        mock_request.response = \"response\"\n+        mock_hook.side_effect = sideeffect\n+\n+        r = requests.request('get','http://google.com')\n+\n+\n+        mock_cjar.assert_called_once_with({})\n+        mock_hook.assert_called__with('args', None, args)\n+        mock_request.assert_called_once_with(**args)\n+        mock_hook.assert_called__with('pre_request', None, mock_request)\n+        mock_request.send.assert_called_once_with()\n+        mock_hook.assert_called__with('post_request', None, mock_request)\n+        mock_hook.assert_called__with('response', None, mock_request)\n+        self.assertEqual(r, \"response\")\n+\n+\n+\n     @mock.patch('requests.api.request')\n     def test_http_get(self, mock_request):\n         mock_request.return_value = Response()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#cb2e87210c0af4217aa9a1159a08c5634cd85ab2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 16 | Churn Cumulative: 126 | Contributors (this commit): 1 | Commits (past 90d): 3 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -72,6 +72,22 @@ class RequestsAPIUnitTests(unittest.TestCase):\n         mock_request.assert_called_once_with('get', 'http://google.com',\n                                              allow_redirects= True)\n \n+    @mock.patch('requests.api.request')\n+    def test_http_get_with_kwargs(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.get('http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+        mock_request.assert_called_once_with('get', 'http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+\n     @mock.patch('requests.api.request')\n     def test_http_head(self, mock_request):\n         mock_request.return_value = Response()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#5c5c13a28f48770d826cdebfb7bd62dffd15c117", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 15 | Churn Cumulative: 141 | Contributors (this commit): 1 | Commits (past 90d): 4 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -96,6 +96,21 @@ class RequestsAPIUnitTests(unittest.TestCase):\n                                              allow_redirects= True)\n \n     @mock.patch('requests.api.request')\n+    def test_http_head_with_kwargs(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.head('http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+        mock_request.assert_called_once_with('head', 'http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+\n     def test_http_post(self, mock_request):\n         mock_request.return_value = Response()\n         requests.post('http://google.com', {})\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#29f7a5bcfa0c4b95df66218c78ac8d219af48563", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 17 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 17 | Churn Cumulative: 158 | Contributors (this commit): 1 | Commits (past 90d): 5 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -111,6 +111,7 @@ class RequestsAPIUnitTests(unittest.TestCase):\n                      allow_redirects=False,\n                      proxies=\"proxies\", hooks=\"hooks\")\n \n+    @mock.patch('requests.api.request')\n     def test_http_post(self, mock_request):\n         mock_request.return_value = Response()\n         requests.post('http://google.com', {})\n@@ -118,6 +119,22 @@ class RequestsAPIUnitTests(unittest.TestCase):\n                                               data= {})\n \n     @mock.patch('requests.api.request')\n+    def test_http_post_with_kwargs(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.post('http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+        mock_request.assert_called_once_with('post', 'http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+\n+\n     def test_http_put(self, mock_request):\n         mock_request.return_value = Response()\n         requests.put('http://google.com', {})\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#42c45df84d64b04da4702a94d7fa42d01501b218", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 17 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 17 | Churn Cumulative: 175 | Contributors (this commit): 1 | Commits (past 90d): 6 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -135,6 +135,7 @@ class RequestsAPIUnitTests(unittest.TestCase):\n                      proxies=\"proxies\", hooks=\"hooks\")\n \n \n+    @mock.patch('requests.api.request')\n     def test_http_put(self, mock_request):\n         mock_request.return_value = Response()\n         requests.put('http://google.com', {})\n@@ -142,6 +143,22 @@ class RequestsAPIUnitTests(unittest.TestCase):\n                                              data= {})\n \n     @mock.patch('requests.api.request')\n+    def test_http_put_with_kwargs(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.put('http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+        mock_request.assert_called_once_with('put', 'http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+\n+\n     def test_http_patch(self, mock_request):\n         mock_request.return_value = Response()\n         requests.patch('http://google.com', {})\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#1d1927bb2b957658212ef89eb3cefdcc0a942033", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 16 | Churn Cumulative: 191 | Contributors (this commit): 1 | Commits (past 90d): 7 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -159,6 +159,7 @@ class RequestsAPIUnitTests(unittest.TestCase):\n                      proxies=\"proxies\", hooks=\"hooks\")\n \n \n+    @mock.patch('requests.api.request')\n     def test_http_patch(self, mock_request):\n         mock_request.return_value = Response()\n         requests.patch('http://google.com', {})\n@@ -166,6 +167,21 @@ class RequestsAPIUnitTests(unittest.TestCase):\n                                              data= {})\n \n     @mock.patch('requests.api.request')\n+    def test_http_patch_with_kwargs(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.patch('http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+        mock_request.assert_called_once_with('patch', 'http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+\n     def test_http_delete(self, mock_request):\n         mock_request.return_value = Response()\n         requests.delete('http://google.com')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#1481e9ae6a3ef8f507b944840c98aea0f3f23920", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 18 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 18 | Churn Cumulative: 209 | Contributors (this commit): 1 | Commits (past 90d): 8 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -182,10 +182,28 @@ class RequestsAPIUnitTests(unittest.TestCase):\n                      allow_redirects=False,\n                      proxies=\"proxies\", hooks=\"hooks\")\n \n+    @mock.patch('requests.api.request')\n     def test_http_delete(self, mock_request):\n         mock_request.return_value = Response()\n         requests.delete('http://google.com')\n         mock_request.assert_called_once_with('delete', 'http://google.com')\n \n+    @mock.patch('requests.api.request')\n+    def test_http_delete_with_kwargs(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.delete('http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+        mock_request.assert_called_once_with('delete', 'http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+\n+\n if __name__ == '__main__':\n     unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#84434fddee4b1423240e66de5b5c7c0ecaf6615d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 727 | Lines Deleted: 0 | Files Changed: 5 | Hunks: 4 | Methods Changed: 23 | Complexity Δ (Sum/Max): 79/63 | Churn Δ: 727 | Churn Cumulative: 727 | Contributors (this commit): 1 | Commits (past 90d): 5 | Contributors (cumulative): 5 | DMM Complexity: 0.6064516129032258\n\nDIFF:\n@@ -0,0 +1,22 @@\n+\"\"\"\n+urllib3 - Thread-safe connection pooling and re-using.\n+\"\"\"\n+\n+from connectionpool import (\n+    connection_from_url,\n+    get_host,\n+    HTTPConnectionPool,\n+    HTTPSConnectionPool,\n+    make_headers)\n+# Possible exceptions\n+from connectionpool import (\n+    HTTPError,\n+    MaxRetryError,\n+    SSLError,\n+    TimeoutError)\n+from filepost import encode_multipart_formdata\n+\n+\n+__author__ = \"Andrey Petrov (andrey.petrov@shazow.net)\"\n+__license__ = \"MIT\"\n+__version__ = \"$Rev$\"\n\n@@ -0,0 +1,544 @@\n+import gzip\n+import zlib\n+import logging\n+import socket\n+\n+\n+from urllib import urlencode\n+from httplib import HTTPConnection, HTTPSConnection, HTTPException\n+from Queue import Queue, Empty, Full\n+from select import select\n+from socket import error as SocketError, timeout as SocketTimeout\n+\n+\n+try:\n+    import ssl\n+    BaseSSLError = ssl.SSLError\n+except ImportError, e:\n+    ssl = None\n+    BaseSSLError = None\n+\n+try:\n+    from cStringIO import StringIO\n+except ImportError, e:\n+    from StringIO import StringIO\n+\n+\n+from filepost import encode_multipart_formdata\n+\n+\n+log = logging.getLogger(__name__)\n+\n+\n+## Exceptions\n+\n+class HTTPError(Exception):\n+    \"Base exception used by this module.\"\n+    pass\n+\n+\n+class SSLError(Exception):\n+    \"Raised when SSL certificate fails in an HTTPS connection.\"\n+    pass\n+\n+\n+class MaxRetryError(HTTPError):\n+    \"Raised when the maximum number of retries is exceeded.\"\n+    pass\n+\n+\n+class TimeoutError(HTTPError):\n+    \"Raised when a socket timeout occurs.\"\n+    pass\n+\n+\n+class HostChangedError(HTTPError):\n+    \"Raised when an existing pool gets a request for a foreign host.\"\n+    pass\n+\n+\n+## Response objects\n+\n+class HTTPResponse(object):\n+    \"\"\"\n+    HTTP Response container.\n+\n+    Similar to httplib's HTTPResponse but the data is pre-loaded.\n+    \"\"\"\n+\n+    def __init__(self, data='', headers=None, status=0, version=0, reason=None,\n+                 strict=0):\n+        self.data = data\n+        self.headers = headers or {}\n+        self.status = status\n+        self.version = version\n+        self.reason = reason\n+        self.strict = strict\n+\n+    @staticmethod\n+    def from_httplib(r):\n+        \"\"\"\n+        Given an httplib.HTTPResponse instance, return a corresponding\n+        urllib3.HTTPResponse object.\n+\n+        NOTE: This method will perform r.read() which will have side effects\n+        on the original http.HTTPResponse object.\n+        \"\"\"\n+        tmp_data = r.read()\n+        try:\n+            if r.getheader('content-encoding') == 'gzip':\n+                log.debug(\"Received response with content-encoding: gzip, \"\n+                          \"decompressing with gzip.\")\n+\n+                gzipper = gzip.GzipFile(fileobj=StringIO(tmp_data))\n+                data = gzipper.read()\n+            elif r.getheader('content-encoding') == 'deflate':\n+                log.debug(\"Received response with content-encoding: deflate, \"\n+                          \"decompressing with zlib.\")\n+                try:\n+                    data = zlib.decompress(tmp_data)\n+                except zlib.error, e:\n+                    data = zlib.decompress(tmp_data, -zlib.MAX_WBITS)\n+            else:\n+                data = tmp_data\n+\n+        except IOError:\n+            raise HTTPError(\"Received response with content-encoding: %s, \"\n+                            \"but failed to decompress it.\" %\n+                            (r.getheader('content-encoding')))\n+\n+        return HTTPResponse(data=data,\n+                    headers=dict(r.getheaders()),\n+                    status=r.status,\n+                    version=r.version,\n+                    reason=r.reason,\n+                    strict=r.strict)\n+\n+    # Backwards-compatibility methods for httplib.HTTPResponse\n+    def getheaders(self):\n+        return self.headers\n+\n+    def getheader(self, name, default=None):\n+        return self.headers.get(name, default)\n+\n+\n+## Connection objects\n+\n+class VerifiedHTTPSConnection(HTTPSConnection):\n+    \"\"\"\n+    Based on httplib.HTTPSConnection but wraps the socket with\n+    SSL certification.\n+    \"\"\"\n+\n+    def set_cert(self, key_file=None, cert_file=None, cert_reqs='CERT_NONE',\n+                 ca_certs=None):\n+        ssl_req_scheme = {\n+            'CERT_NONE': ssl.CERT_NONE,\n+            'CERT_OPTIONAL': ssl.CERT_OPTIONAL,\n+            'CERT_REQUIRED': ssl.CERT_REQUIRED\n+        }\n+\n+        self.key_file = key_file\n+        self.cert_file = cert_file\n+        self.cert_reqs = ssl_req_scheme.get(cert_reqs) or ssl.CERT_NONE\n+        self.ca_certs = ca_certs\n+\n+    def connect(self):\n+        # Add certificate verification\n+        sock = socket.create_connection((self.host, self.port), self.timeout)\n+\n+        # Wrap socket using verification with the root certs in\n+        # trusted_root_certs\n+        self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file,\n+                                    cert_reqs=self.cert_reqs,\n+                                    ca_certs=self.ca_certs)\n+\n+\n+## Pool objects\n+\n+class HTTPConnectionPool(object):\n+    \"\"\"\n+    Thread-safe connection pool for one host.\n+\n+    host\n+        Host used for this HTTP Connection (e.g. \"localhost\"), passed into\n+        httplib.HTTPConnection()\n+\n+    port\n+        Port used for this HTTP Connection (None is equivalent to 80), passed\n+        into httplib.HTTPConnection()\n+\n+    strict\n+        Causes BadStatusLine to be raised if the status line can't be parsed\n+        as a valid HTTP/1.0 or 1.1 status line, passed into\n+        httplib.HTTPConnection()\n+\n+    timeout\n+        Socket timeout for each individual connection, can be a float. None\n+        disables timeout.\n+\n+    maxsize\n+        Number of connections to save that can be reused. More than 1 is useful\n+        in multithreaded situations. If ``block`` is set to false, more\n+        connections will be created but they will not be saved once they've\n+        been used.\n+\n+    block\n+        If set to True, no more than ``maxsize`` connections will be used at\n+        a time. When no free connections are available, the call will block\n+        until a connection has been released. This is a useful side effect for\n+        particular multithreaded situations where one does not want to use more\n+        than maxsize connections per host to prevent flooding.\n+\n+    headers\n+        Headers to include with all requests, unless other headers are given\n+        explicitly.\n+    \"\"\"\n+\n+    scheme = 'http'\n+\n+    def __init__(self, host, port=None, strict=False, timeout=None, maxsize=1,\n+                 block=False, headers=None):\n+        self.host = host\n+        self.port = port\n+        self.strict = strict\n+        self.timeout = timeout\n+        self.pool = Queue(maxsize)\n+        self.block = block\n+        self.headers = headers or {}\n+\n+        # Fill the queue up so that doing get() on it will block properly\n+        [self.pool.put(None) for i in xrange(maxsize)]\n+\n+        self.num_connections = 0\n+        self.num_requests = 0\n+\n+    def _new_conn(self):\n+        \"\"\"\n+        Return a fresh HTTPConnection.\n+        \"\"\"\n+        self.num_connections += 1\n+        log.info(\"Starting new HTTP connection (%d): %s\" %\n+                 (self.num_connections, self.host))\n+        return HTTPConnection(host=self.host, port=self.port)\n+\n+    def _get_conn(self, timeout=None):\n+        \"\"\"\n+        Get a connection. Will return a pooled connection if one is available.\n+        Otherwise, a fresh connection is returned.\n+        \"\"\"\n+        conn = None\n+        try:\n+            conn = self.pool.get(block=self.block, timeout=timeout)\n+\n+            # If this is a persistent connection, check if it got disconnected\n+            if conn and conn.sock and select([conn.sock], [], [], 0.0)[0]:\n+                # Either data is buffered (bad), or the connection is dropped.\n+                log.warning(\"Connection pool detected dropped \"\n+                            \"connection, resetting: %s\" % self.host)\n+                conn.close()\n+\n+        except Empty, e:\n+            pass  # Oh well, we'll create a new connection then\n+\n+        return conn or self._new_conn()\n+\n+    def _put_conn(self, conn):\n+        \"\"\"\n+        Put a connection back into the pool.\n+        If the pool is already full, the connection is discarded because we\n+        exceeded maxsize. If connections are discarded frequently, then maxsize\n+        should be increased.\n+        \"\"\"\n+        try:\n+            self.pool.put(conn, block=False)\n+        except Full, e:\n+            # This should never happen if self.block == True\n+            log.warning(\"HttpConnectionPool is full, discarding connection: %s\"\n+                        % self.host)\n+\n+    def is_same_host(self, url):\n+        return (url.startswith('/') or\n+                get_host(url) == (self.scheme, self.host, self.port))\n+\n+    def urlopen(self, method, url, body=None, headers=None, retries=3,\n+                redirect=True, assert_same_host=True):\n+        \"\"\"\n+        Get a connection from the pool and perform an HTTP request.\n+\n+        method\n+            HTTP request method (such as GET, POST, PUT, etc.)\n+\n+        body\n+            Data to send in the request body (useful for creating\n+            POST requests, see HTTPConnectionPool.post_url for\n+            more convenience).\n+\n+        headers\n+            Dictionary of custom headers to send, such as User-Agent,\n+            If-None-Match, etc. If None, pool headers are used. If provided,\n+            these headers completely replace any pool-specific headers.\n+\n+        retries\n+            Number of retries to allow before raising\n+            a MaxRetryError exception.\n+\n+        redirect\n+            Automatically handle redirects (status codes 301, 302, 303, 307),\n+            each redirect counts as a retry.\n+\n+        assert_same_host\n+            If True, will make sure that the host of the pool requests is\n+            consistent else will raise HostChangedError. When False, you can\n+            use the pool on an HTTP proxy and request foreign hosts.\n+        \"\"\"\n+        if headers == None:\n+            headers = self.headers\n+\n+        if retries < 0:\n+            raise MaxRetryError(\"Max retries exceeded for url: %s\" % url)\n+\n+        # Check host\n+        if assert_same_host and not self.is_same_host(url):\n+            host = \"%s://%s\" % (self.scheme, self.host)\n+            if self.port:\n+                host = \"%s:%d\" % (host, self.port)\n+\n+            raise HostChangedError(\"Connection pool with host '%s' tried to \"\n+                                   \"open a foreign host: %s\" % (host, url))\n+\n+        try:\n+            # Request a connection from the queue\n+            conn = self._get_conn()\n+\n+            # Make the request\n+            self.num_requests += 1\n+            conn.request(method, url, body=body, headers=headers)\n+            conn.sock.settimeout(self.timeout)\n+            httplib_response = conn.getresponse()\n+            log.debug(\"\\\"%s %s %s\\\" %s %s\" %\n+                      (method, url, conn._http_vsn_str,\n+                       httplib_response.status, httplib_response.length))\n+\n+            # from_httplib will perform httplib_response.read() which will have\n+            # the side effect of letting us use this connection for another\n+            # request.\n+            response = HTTPResponse.from_httplib(httplib_response)\n+\n+            # Put the connection back to be reused\n+            self._put_conn(conn)\n+\n+        except (SocketTimeout, Empty), e:\n+            # Timed out either by socket or queue\n+            raise TimeoutError(\"Request timed out after %f seconds\" %\n+                               self.timeout)\n+\n+        except (BaseSSLError), e:\n+            # SSL certificate error\n+            raise SSLError(e)\n+\n+        except (HTTPException, SocketError), e:\n+            log.warn(\"Retrying (%d attempts remain) after connection \"\n+                     \"broken by '%r': %s\" % (retries, e, url))\n+            return self.urlopen(method, url, body, headers, retries - 1,\n+                                redirect, assert_same_host)  # Try again\n+\n+        # Handle redirection\n+        if (redirect and\n+            response.status in [301, 302, 303, 307] and\n+            'location' in response.headers):  # Redirect, retry\n+            log.info(\"Redirecting %s -> %s\" %\n+                     (url, response.headers.get('location')))\n+            return self.urlopen(method, response.headers.get('location'), body,\n+                                headers, retries - 1, redirect,\n+                                assert_same_host)\n+\n+        return response\n+\n+    def get_url(self, url, fields=None, headers=None, retries=3,\n+                redirect=True):\n+        \"\"\"\n+        Wrapper for performing GET with urlopen (see urlopen for more details).\n+\n+        Supports an optional ``fields`` dictionary parameter key/value strings.\n+        If provided, they will be added to the url.\n+        \"\"\"\n+        if fields:\n+            url += '?' + urlencode(fields)\n+        return self.urlopen('GET', url, headers=headers, retries=retries,\n+                            redirect=redirect)\n+\n+    def post_url(self, url, fields=None, headers=None, retries=3,\n+                 redirect=True, encode_multipart=True):\n+        \"\"\"\n+        Wrapper for performing POST with urlopen (see urlopen\n+        for more details).\n+\n+        Supports an optional ``fields`` parameter of key/value strings AND\n+        key/filetuple. A filetuple is a (filename, data) tuple. For example:\n+\n+        fields = {\n+            'foo': 'bar',\n+            'foofile': ('foofile.txt', 'contents of foofile'),\n+        }\n+\n+        If encode_multipart=True (default), then\n+        ``urllib3.filepost.encode_multipart_formdata`` is used to encode the\n+        payload with the appropriate content type. Otherwise\n+        ``urllib.urlencode`` is used with 'application/x-www-form-urlencoded'\n+        content type.\n+\n+        Multipart encoding must be used when posting files, and it's reasonably\n+        safe to use it other times too. It may break request signing, such as\n+        OAuth.\n+\n+        NOTE: If ``headers`` are supplied, the 'Content-Type' value will be\n+        overwritten because it depends on the dynamic random boundary string\n+        which is used to compose the body of the request.\n+        \"\"\"\n+        if encode_multipart:\n+            body, content_type = encode_multipart_formdata(fields or {})\n+        else:\n+            body, content_type = (\n+                urlencode(fields or {}),\n+                'application/x-www-form-urlencoded')\n+\n+        headers = headers or {}\n+        headers.update({'Content-Type': content_type})\n+\n+        return self.urlopen('POST', url, body, headers=headers,\n+                            retries=retries, redirect=redirect)\n+\n+\n+class HTTPSConnectionPool(HTTPConnectionPool):\n+    \"\"\"\n+    Same as HTTPConnectionPool, but HTTPS.\n+    \"\"\"\n+\n+    scheme = 'https'\n+\n+    def __init__(self, host, port=None, strict=False, timeout=None, maxsize=1,\n+                 block=False, headers=None, key_file=None,\n+                 cert_file=None, cert_reqs='CERT_NONE', ca_certs=None):\n+        self.host = host\n+        self.port = port\n+        self.strict = strict\n+        self.timeout = timeout\n+        self.pool = Queue(maxsize)\n+        self.block = block\n+        self.headers = headers or {}\n+\n+        self.key_file = key_file\n+        self.cert_file = cert_file\n+        self.cert_reqs = cert_reqs\n+        self.ca_certs = ca_certs\n+\n+        # Fill the queue up so that doing get() on it will block properly\n+        [self.pool.put(None) for i in xrange(maxsize)]\n+\n+        self.num_connections = 0\n+        self.num_requests = 0\n+\n+    def _new_conn(self):\n+        \"\"\"\n+        Return a fresh HTTPSConnection.\n+        \"\"\"\n+        self.num_connections += 1\n+        log.info(\"Starting new HTTPS connection (%d): %s\"\n+                 % (self.num_connections, self.host))\n+\n+        if not ssl:\n+            return HTTPSConnection(host=self.host, port=self.port)\n+\n+        connection = VerifiedHTTPSConnection(host=self.host, port=self.port)\n+        connection.set_cert(key_file=self.key_file, cert_file=self.cert_file,\n+                            cert_reqs=self.cert_reqs, ca_certs=self.ca_certs)\n+        return connection\n+\n+\n+## Helpers\n+\n+def make_headers(keep_alive=None, accept_encoding=None, user_agent=None,\n+                 basic_auth=None):\n+    \"\"\"\n+    Shortcuts for generating request headers.\n+\n+    keep_alive\n+        If true, adds 'connection: keep-alive' header.\n+\n+    accept_encoding\n+        Can be a boolean, list, or string.\n+        True translates to 'gzip,deflate'.\n+        List will get joined by comma.\n+        String will be used as provided.\n+\n+    user_agent\n+        String representing the user-agent you want, such as\n+        \"python-urllib3/0.6\"\n+\n+    basic_auth\n+        Colon-separated username:password string for 'authorization: basic ...'\n+        auth header.\n+    \"\"\"\n+    headers = {}\n+    if accept_encoding:\n+        if isinstance(accept_encoding, str):\n+            pass\n+        elif isinstance(accept_encoding, list):\n+            accept_encoding = ','.join(accept_encoding)\n+        else:\n+            accept_encoding = 'gzip,deflate'\n+        headers['accept-encoding'] = accept_encoding\n+\n+    if user_agent:\n+        headers['user-agent'] = user_agent\n+\n+    if keep_alive:\n+        headers['connection'] = 'keep-alive'\n+\n+    if basic_auth:\n+        headers['authorization'] = 'Basic ' + \\\n+            basic_auth.encode('base64').strip()\n+\n+    return headers\n+\n+\n+def get_host(url):\n+    \"\"\"\n+    Given a url, return its scheme, host and port (None if it's not there).\n+\n+    For example:\n+    >>> get_host('http://google.com/mail/')\n+    http, google.com, None\n+    >>> get_host('google.com:80')\n+    http, google.com, 80\n+    \"\"\"\n+    # This code is actually similar to urlparse.urlsplit, but much\n+    # simplified for our needs.\n+    port = None\n+    scheme = 'http'\n+    if '//' in url:\n+        scheme, url = url.split('://', 1)\n+    if '/' in url:\n+        url, path = url.split('/', 1)\n+    if ':' in url:\n+        url, port = url.split(':', 1)\n+        port = int(port)\n+    return scheme, url, port\n+\n+\n+def connection_from_url(url, **kw):\n+    \"\"\"\n+    Given a url, return an HTTP(S)ConnectionPool instance of its host.\n+\n+    This is a shortcut for not having to determine the host of the url\n+    before creating an HTTP(S)ConnectionPool instance.\n+\n+    Passes on whatever kw arguments to the constructor of\n+    HTTP(S)ConnectionPool. (e.g. timeout, maxsize, block)\n+    \"\"\"\n+    scheme, host, port = get_host(url)\n+    if scheme == 'https':\n+        return HTTPSConnectionPool(host, port=port, **kw)\n+    else:\n+        return HTTPConnectionPool(host, port=port, **kw)\n\n\n@@ -0,0 +1,111 @@\n+\"\"\"\n+NTLM authenticating pool, contributed by erikcederstran\n+\n+Issue #10, see: http://code.google.com/p/urllib3/issues/detail?id=10\n+\"\"\"\n+\n+import httplib\n+from logging import getLogger\n+from ntlm import ntlm\n+\n+from urllib3 import HTTPSConnectionPool\n+\n+\n+log = getLogger(__name__)\n+\n+\n+class NTLMConnectionPool(HTTPSConnectionPool):\n+    \"\"\"\n+    Implements an NTLM authentication version of an urllib3 connection pool\n+    \"\"\"\n+\n+    scheme = 'https'\n+\n+    def __init__(self, user, pw, authurl, *args, **kwargs):\n+        \"\"\"\n+        authurl is a random URL on the server that is protected by NTLM.\n+        user is the Windows user, probably in the DOMAIN\\username format.\n+        pw is the password for the user.\n+        \"\"\"\n+        super(NTLMConnectionPool, self).__init__(*args, **kwargs)\n+        self.authurl = authurl\n+        self.rawuser = user\n+        user_parts = user.split('\\\\', 1)\n+        self.domain = user_parts[0].upper()\n+        self.user = user_parts[1]\n+        self.pw = pw\n+\n+    def _new_conn(self):\n+        # Performs the NTLM handshake that secures the connection. The socket\n+        # must be kept open while requests are performed.\n+        self.num_connections += 1\n+        log.debug('Starting NTLM HTTPS connection no. %d: https://%s%s' %\n+                  (self.num_connections, self.host, self.authurl))\n+\n+        headers = {}\n+        headers['Connection'] = 'Keep-Alive'\n+        req_header = 'Authorization'\n+        resp_header = 'www-authenticate'\n+\n+        conn = httplib.HTTPSConnection(host=self.host, port=self.port)\n+\n+        # Send negotiation message\n+        headers[req_header] = (\n+            'NTLM %s' % ntlm.create_NTLM_NEGOTIATE_MESSAGE(self.rawuser))\n+        log.debug('Request headers: %s' % headers)\n+        conn.request('GET', self.authurl, None, headers)\n+        res = conn.getresponse()\n+        reshdr = dict(res.getheaders())\n+        log.debug('Response status: %s %s' % (res.status, res.reason))\n+        log.debug('Response headers: %s' % reshdr)\n+        log.debug('Response data: %s [...]' % res.read(100))\n+\n+        # Remove the reference to the socket, so that it can not be closed by\n+        # the response object (we want to keep the socket open)\n+        res.fp = None\n+\n+        # Server should respond with a challenge message\n+        auth_header_values = reshdr[resp_header].split(', ')\n+        auth_header_value = None\n+        for s in auth_header_values:\n+            if s[:5] == 'NTLM ':\n+                auth_header_value = s[5:]\n+        if auth_header_value is None:\n+            raise Exception('Unexpected %s response header: %s' %\n+                            (resp_header, reshdr[resp_header]))\n+\n+        # Send authentication message\n+        ServerChallenge, NegotiateFlags = \\\n+            ntlm.parse_NTLM_CHALLENGE_MESSAGE(auth_header_value)\n+        auth_msg = ntlm.create_NTLM_AUTHENTICATE_MESSAGE(ServerChallenge,\n+                                                         self.user,\n+                                                         self.domain,\n+                                                         self.pw,\n+                                                         NegotiateFlags)\n+        headers[req_header] = 'NTLM %s' % auth_msg\n+        log.debug('Request headers: %s' % headers)\n+        conn.request('GET', self.authurl, None, headers)\n+        res = conn.getresponse()\n+        log.debug('Response status: %s %s' % (res.status, res.reason))\n+        log.debug('Response headers: %s' % dict(res.getheaders()))\n+        log.debug('Response data: %s [...]' % res.read()[:100])\n+        if res.status != 200:\n+            if res.status == 401:\n+                raise Exception('Server rejected request: wrong '\n+                                'username or password')\n+            raise Exception('Wrong server response: %s %s' %\n+                            (res.status, res.reason))\n+\n+        res.fp = None\n+        log.debug('Connection established')\n+        return conn\n+\n+    def urlopen(self, method, url, body=None, headers=None, retries=3,\n+                redirect=True, assert_same_host=True):\n+        if headers is None:\n+            headers = {}\n+        headers['Connection'] = 'Keep-Alive'\n+        return super(NTLMConnectionPool, self).urlopen(method, url, body,\n+                                                       headers, retries,\n+                                                       redirect,\n+                                                       assert_same_host)\n\n@@ -0,0 +1,50 @@\n+import codecs\n+import mimetools\n+import mimetypes\n+try:\n+    from cStringIO import StringIO\n+except:\n+    from StringIO import StringIO\n+\n+\n+writer = codecs.lookup('utf-8')[3]\n+\n+\n+def get_content_type(filename):\n+    return mimetypes.guess_type(filename)[0] or 'application/octet-stream'\n+\n+\n+def encode_multipart_formdata(fields):\n+    body = StringIO()\n+    BOUNDARY = mimetools.choose_boundary()\n+\n+    for fieldname, value in fields.iteritems():\n+        body.write('--%s\\r\\n' % (BOUNDARY))\n+\n+        if isinstance(value, tuple):\n+            filename, data = value\n+            writer(body).write('Content-Disposition: form-data; name=\"%s\"; '\n+                               'filename=\"%s\"\\r\\n' % (fieldname, filename))\n+            body.write('Content-Type: %s\\r\\n\\r\\n' %\n+                       (get_content_type(filename)))\n+        else:\n+            data = value\n+            writer(body).write('Content-Disposition: form-data; name=\"%s\"\\r\\n'\n+                               % (fieldname))\n+            body.write('Content-Type: text/plain\\r\\n\\r\\n')\n+\n+        if isinstance(data, int):\n+            data = str(data)  # Backwards compatibility\n+\n+        if isinstance(data, unicode):\n+            writer(body).write(data)\n+        else:\n+            body.write(data)\n+\n+        body.write('\\r\\n')\n+\n+    body.write('--%s--\\r\\n' % (BOUNDARY))\n+\n+    content_type = 'multipart/form-data; boundary=%s' % BOUNDARY\n+\n+    return body.getvalue(), content_type\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#608c61dcd97961fee57d2f3de710229539bb16c4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 647 | Files Changed: 3 | Hunks: 3 | Methods Changed: 28 | Complexity Δ (Sum/Max): -102/0 | Churn Δ: 647 | Churn Cumulative: 1312 | Contributors (this commit): 2 | Commits (past 90d): 3 | Contributors (cumulative): 4 | DMM Complexity: 0.5513698630136986\n\nDIFF:\n@@ -1,34 +0,0 @@\n-# Copyright (c) 2010 Chris AtLee\n-# \n-# Permission is hereby granted, free of charge, to any person obtaining a copy\n-# of this software and associated documentation files (the \"Software\"), to deal\n-# in the Software without restriction, including without limitation the rights\n-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n-# copies of the Software, and to permit persons to whom the Software is\n-# furnished to do so, subject to the following conditions:\n-# \n-# The above copyright notice and this permission notice shall be included in\n-# all copies or substantial portions of the Software.\n-# \n-# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-# THE SOFTWARE.\n-\"\"\"poster module\n-\n-Support for streaming HTTP uploads, and multipart/form-data encoding\n-\n-```poster.version``` is a 3-tuple of integers representing the version number.\n-New releases of poster will always have a version number that compares greater\n-than an older version of poster.\n-New in version 0.6.\"\"\"\n-\n-from __future__ import absolute_import\n-\n-from . import streaminghttp\n-from . import encode\n-\n-version = (0, 8, 0) # Thanks JP!\n\n@@ -1,414 +0,0 @@\n-\"\"\"multipart/form-data encoding module\n-\n-This module provides functions that faciliate encoding name/value pairs\n-as multipart/form-data suitable for a HTTP POST or PUT request.\n-\n-multipart/form-data is the standard way to upload files over HTTP\"\"\"\n-\n-__all__ = ['gen_boundary', 'encode_and_quote', 'MultipartParam',\n-        'encode_string', 'encode_file_header', 'get_body_size', 'get_headers',\n-        'multipart_encode']\n-\n-try:\n-    import uuid\n-    def gen_boundary():\n-        \"\"\"Returns a random string to use as the boundary for a message\"\"\"\n-        return uuid.uuid4().hex\n-except ImportError:\n-    import random, sha\n-    def gen_boundary():\n-        \"\"\"Returns a random string to use as the boundary for a message\"\"\"\n-        bits = random.getrandbits(160)\n-        return sha.new(str(bits)).hexdigest()\n-\n-import urllib, re, os, mimetypes\n-try:\n-    from email.header import Header\n-except ImportError:\n-    # Python 2.4\n-    from email.Header import Header\n-\n-def encode_and_quote(data):\n-    \"\"\"If ``data`` is unicode, return urllib.quote_plus(data.encode(\"utf-8\"))\n-    otherwise return urllib.quote_plus(data)\"\"\"\n-    if data is None:\n-        return None\n-\n-    if isinstance(data, unicode):\n-        data = data.encode(\"utf-8\")\n-    return urllib.quote_plus(data)\n-\n-def _strify(s):\n-    \"\"\"If s is a unicode string, encode it to UTF-8 and return the results,\n-    otherwise return str(s), or None if s is None\"\"\"\n-    if s is None:\n-        return None\n-    if isinstance(s, unicode):\n-        return s.encode(\"utf-8\")\n-    return str(s)\n-\n-class MultipartParam(object):\n-    \"\"\"Represents a single parameter in a multipart/form-data request\n-\n-    ``name`` is the name of this parameter.\n-\n-    If ``value`` is set, it must be a string or unicode object to use as the\n-    data for this parameter.\n-\n-    If ``filename`` is set, it is what to say that this parameter's filename\n-    is.  Note that this does not have to be the actual filename any local file.\n-\n-    If ``filetype`` is set, it is used as the Content-Type for this parameter.\n-    If unset it defaults to \"text/plain; charset=utf8\"\n-\n-    If ``filesize`` is set, it specifies the length of the file ``fileobj``\n-\n-    If ``fileobj`` is set, it must be a file-like object that supports\n-    .read().\n-\n-    Both ``value`` and ``fileobj`` must not be set, doing so will\n-    raise a ValueError assertion.\n-\n-    If ``fileobj`` is set, and ``filesize`` is not specified, then\n-    the file's size will be determined first by stat'ing ``fileobj``'s\n-    file descriptor, and if that fails, by seeking to the end of the file,\n-    recording the current position as the size, and then by seeking back to the\n-    beginning of the file.\n-\n-    ``cb`` is a callable which will be called from iter_encode with (self,\n-    current, total), representing the current parameter, current amount\n-    transferred, and the total size.\n-    \"\"\"\n-    def __init__(self, name, value=None, filename=None, filetype=None,\n-                        filesize=None, fileobj=None, cb=None):\n-        self.name = Header(name).encode()\n-        self.value = _strify(value)\n-        if filename is None:\n-            self.filename = None\n-        else:\n-            if isinstance(filename, unicode):\n-                # Encode with XML entities\n-                self.filename = filename.encode(\"ascii\", \"xmlcharrefreplace\")\n-            else:\n-                self.filename = str(filename)\n-            self.filename = self.filename.encode(\"string_escape\").\\\n-                    replace('\"', '\\\\\"')\n-        self.filetype = _strify(filetype)\n-\n-        self.filesize = filesize\n-        self.fileobj = fileobj\n-        self.cb = cb\n-\n-        if self.value is not None and self.fileobj is not None:\n-            raise ValueError(\"Only one of value or fileobj may be specified\")\n-\n-        if fileobj is not None and filesize is None:\n-            # Try and determine the file size\n-            try:\n-                self.filesize = os.fstat(fileobj.fileno()).st_size\n-            except (OSError, AttributeError):\n-                try:\n-                    fileobj.seek(0, 2)\n-                    self.filesize = fileobj.tell()\n-                    fileobj.seek(0)\n-                except:\n-                    raise ValueError(\"Could not determine filesize\")\n-\n-    def __cmp__(self, other):\n-        attrs = ['name', 'value', 'filename', 'filetype', 'filesize', 'fileobj']\n-        myattrs = [getattr(self, a) for a in attrs]\n-        oattrs = [getattr(other, a) for a in attrs]\n-        return cmp(myattrs, oattrs)\n-\n-    def reset(self):\n-        if self.fileobj is not None:\n-            self.fileobj.seek(0)\n-        elif self.value is None:\n-            raise ValueError(\"Don't know how to reset this parameter\")\n-\n-    @classmethod\n-    def from_file(cls, paramname, filename):\n-        \"\"\"Returns a new MultipartParam object constructed from the local\n-        file at ``filename``.\n-\n-        ``filesize`` is determined by os.path.getsize(``filename``)\n-\n-        ``filetype`` is determined by mimetypes.guess_type(``filename``)[0]\n-\n-        ``filename`` is set to os.path.basename(``filename``)\n-        \"\"\"\n-\n-        return cls(paramname, filename=os.path.basename(filename),\n-                filetype=mimetypes.guess_type(filename)[0],\n-                filesize=os.path.getsize(filename),\n-                fileobj=open(filename, \"rb\"))\n-\n-    @classmethod\n-    def from_params(cls, params):\n-        \"\"\"Returns a list of MultipartParam objects from a sequence of\n-        name, value pairs, MultipartParam instances,\n-        or from a mapping of names to values\n-\n-        The values may be strings or file objects, or MultipartParam objects.\n-        MultipartParam object names must match the given names in the\n-        name,value pairs or mapping, if applicable.\"\"\"\n-        if hasattr(params, 'items'):\n-            params = params.items()\n-\n-        retval = []\n-        for item in params:\n-            if isinstance(item, cls):\n-                retval.append(item)\n-                continue\n-            name, value = item\n-            if isinstance(value, cls):\n-                assert value.name == name\n-                retval.append(value)\n-                continue\n-            if hasattr(value, 'read'):\n-                # Looks like a file object\n-                filename = getattr(value, 'name', None)\n-                if filename is not None:\n-                    filetype = mimetypes.guess_type(filename)[0]\n-                else:\n-                    filetype = None\n-\n-                retval.append(cls(name=name, filename=filename,\n-                    filetype=filetype, fileobj=value))\n-            else:\n-                retval.append(cls(name, value))\n-        return retval\n-\n-    def encode_hdr(self, boundary):\n-        \"\"\"Returns the header of the encoding of this parameter\"\"\"\n-        boundary = encode_and_quote(boundary)\n-\n-        headers = [\"--%s\" % boundary]\n-\n-        if self.filename:\n-            disposition = 'form-data; name=\"%s\"; filename=\"%s\"' % (self.name,\n-                    self.filename)\n-        else:\n-            disposition = 'form-data; name=\"%s\"' % self.name\n-\n-        headers.append(\"Content-Disposition: %s\" % disposition)\n-\n-        if self.filetype:\n-            filetype = self.filetype\n-        else:\n-            filetype = \"text/plain; charset=utf-8\"\n-\n-        headers.append(\"Content-Type: %s\" % filetype)\n-\n-        headers.append(\"\")\n-        headers.append(\"\")\n-\n-        return \"\\r\\n\".join(headers)\n-\n-    def encode(self, boundary):\n-        \"\"\"Returns the string encoding of this parameter\"\"\"\n-        if self.value is None:\n-            value = self.fileobj.read()\n-        else:\n-            value = self.value\n-\n-        if re.search(\"^--%s$\" % re.escape(boundary), value, re.M):\n-            raise ValueError(\"boundary found in encoded string\")\n-\n-        return \"%s%s\\r\\n\" % (self.encode_hdr(boundary), value)\n-\n-    def iter_encode(self, boundary, blocksize=4096):\n-        \"\"\"Yields the encoding of this parameter\n-        If self.fileobj is set, then blocks of ``blocksize`` bytes are read and\n-        yielded.\"\"\"\n-        total = self.get_size(boundary)\n-        current = 0\n-        if self.value is not None:\n-            block = self.encode(boundary)\n-            current += len(block)\n-            yield block\n-            if self.cb:\n-                self.cb(self, current, total)\n-        else:\n-            block = self.encode_hdr(boundary)\n-            current += len(block)\n-            yield block\n-            if self.cb:\n-                self.cb(self, current, total)\n-            last_block = \"\"\n-            encoded_boundary = \"--%s\" % encode_and_quote(boundary)\n-            boundary_exp = re.compile(\"^%s$\" % re.escape(encoded_boundary),\n-                    re.M)\n-            while True:\n-                block = self.fileobj.read(blocksize)\n-                if not block:\n-                    current += 2\n-                    yield \"\\r\\n\"\n-                    if self.cb:\n-                        self.cb(self, current, total)\n-                    break\n-                last_block += block\n-                if boundary_exp.search(last_block):\n-                    raise ValueError(\"boundary found in file data\")\n-                last_block = last_block[-len(encoded_boundary)-2:]\n-                current += len(block)\n-                yield block\n-                if self.cb:\n-                    self.cb(self, current, total)\n-\n-    def get_size(self, boundary):\n-        \"\"\"Returns the size in bytes that this param will be when encoded\n-        with the given boundary.\"\"\"\n-        if self.filesize is not None:\n-            valuesize = self.filesize\n-        else:\n-            valuesize = len(self.value)\n-\n-        return len(self.encode_hdr(boundary)) + 2 + valuesize\n-\n-def encode_string(boundary, name, value):\n-    \"\"\"Returns ``name`` and ``value`` encoded as a multipart/form-data\n-    variable.  ``boundary`` is the boundary string used throughout\n-    a single request to separate variables.\"\"\"\n-\n-    return MultipartParam(name, value).encode(boundary)\n-\n-def encode_file_header(boundary, paramname, filesize, filename=None,\n-        filetype=None):\n-    \"\"\"Returns the leading data for a multipart/form-data field that contains\n-    file data.\n-\n-    ``boundary`` is the boundary string used throughout a single request to\n-    separate variables.\n-\n-    ``paramname`` is the name of the variable in this request.\n-\n-    ``filesize`` is the size of the file data.\n-\n-    ``filename`` if specified is the filename to give to this field.  This\n-    field is only useful to the server for determining the original filename.\n-\n-    ``filetype`` if specified is the MIME type of this file.\n-\n-    The actual file data should be sent after this header has been sent.\n-    \"\"\"\n-\n-    return MultipartParam(paramname, filesize=filesize, filename=filename,\n-            filetype=filetype).encode_hdr(boundary)\n-\n-def get_body_size(params, boundary):\n-    \"\"\"Returns the number of bytes that the multipart/form-data encoding\n-    of ``params`` will be.\"\"\"\n-    size = sum(p.get_size(boundary) for p in MultipartParam.from_params(params))\n-    return size + len(boundary) + 6\n-\n-def get_headers(params, boundary):\n-    \"\"\"Returns a dictionary with Content-Type and Content-Length headers\n-    for the multipart/form-data encoding of ``params``.\"\"\"\n-    headers = {}\n-    boundary = urllib.quote_plus(boundary)\n-    headers['Content-Type'] = \"multipart/form-data; boundary=%s\" % boundary\n-    headers['Content-Length'] = str(get_body_size(params, boundary))\n-    return headers\n-\n-class multipart_yielder:\n-    def __init__(self, params, boundary, cb):\n-        self.params = params\n-        self.boundary = boundary\n-        self.cb = cb\n-\n-        self.i = 0\n-        self.p = None\n-        self.param_iter = None\n-        self.current = 0\n-        self.total = get_body_size(params, boundary)\n-\n-    def __iter__(self):\n-        return self\n-\n-    def next(self):\n-        \"\"\"generator function to yield multipart/form-data representation\n-        of parameters\"\"\"\n-        if self.param_iter is not None:\n-            try:\n-                block = self.param_iter.next()\n-                self.current += len(block)\n-                if self.cb:\n-                    self.cb(self.p, self.current, self.total)\n-                return block\n-            except StopIteration:\n-                self.p = None\n-                self.param_iter = None\n-\n-        if self.i is None:\n-            raise StopIteration\n-        elif self.i >= len(self.params):\n-            self.param_iter = None\n-            self.p = None\n-            self.i = None\n-            block = \"--%s--\\r\\n\" % self.boundary\n-            self.current += len(block)\n-            if self.cb:\n-                self.cb(self.p, self.current, self.total)\n-            return block\n-\n-        self.p = self.params[self.i]\n-        self.param_iter = self.p.iter_encode(self.boundary)\n-        self.i += 1\n-        return self.next()\n-\n-    def reset(self):\n-        self.i = 0\n-        self.current = 0\n-        for param in self.params:\n-            param.reset()\n-\n-def multipart_encode(params, boundary=None, cb=None):\n-    \"\"\"Encode ``params`` as multipart/form-data.\n-\n-    ``params`` should be a sequence of (name, value) pairs or MultipartParam\n-    objects, or a mapping of names to values.\n-    Values are either strings parameter values, or file-like objects to use as\n-    the parameter value.  The file-like objects must support .read() and either\n-    .fileno() or both .seek() and .tell().\n-\n-    If ``boundary`` is set, then it as used as the MIME boundary.  Otherwise\n-    a randomly generated boundary will be used.  In either case, if the\n-    boundary string appears in the parameter values a ValueError will be\n-    raised.\n-\n-    If ``cb`` is set, it should be a callback which will get called as blocks\n-    of data are encoded.  It will be called with (param, current, total),\n-    indicating the current parameter being encoded, the current amount encoded,\n-    and the total amount to encode.\n-\n-    Returns a tuple of `datagen`, `headers`, where `datagen` is a\n-    generator that will yield blocks of data that make up the encoded\n-    parameters, and `headers` is a dictionary with the assoicated\n-    Content-Type and Content-Length headers.\n-\n-    Examples:\n-\n-    >>> datagen, headers = multipart_encode( [(\"key\", \"value1\"), (\"key\", \"value2\")] )\n-    >>> s = \"\".join(datagen)\n-    >>> assert \"value2\" in s and \"value1\" in s\n-\n-    >>> p = MultipartParam(\"key\", \"value2\")\n-    >>> datagen, headers = multipart_encode( [(\"key\", \"value1\"), p] )\n-    >>> s = \"\".join(datagen)\n-    >>> assert \"value2\" in s and \"value1\" in s\n-\n-    >>> datagen, headers = multipart_encode( {\"key\": \"value1\"} )\n-    >>> s = \"\".join(datagen)\n-    >>> assert \"value2\" not in s and \"value1\" in s\n-\n-    \"\"\"\n-    if boundary is None:\n-        boundary = gen_boundary()\n-    else:\n-        boundary = urllib.quote_plus(boundary)\n-\n-    headers = get_headers(params, boundary)\n-    params = MultipartParam.from_params(params)\n-\n-    return multipart_yielder(params, boundary, cb), headers\n\n@@ -1,199 +0,0 @@\n-\"\"\"Streaming HTTP uploads module.\n-\n-This module extends the standard httplib and urllib2 objects so that\n-iterable objects can be used in the body of HTTP requests.\n-\n-In most cases all one should have to do is call :func:`register_openers()`\n-to register the new streaming http handlers which will take priority over\n-the default handlers, and then you can use iterable objects in the body\n-of HTTP requests.\n-\n-**N.B.** You must specify a Content-Length header if using an iterable object\n-since there is no way to determine in advance the total size that will be\n-yielded, and there is no way to reset an interator.\n-\n-Example usage:\n-\n->>> from StringIO import StringIO\n->>> import urllib2, poster.streaminghttp\n-\n->>> opener = poster.streaminghttp.register_openers()\n-\n->>> s = \"Test file data\"\n->>> f = StringIO(s)\n-\n->>> req = urllib2.Request(\"http://localhost:5000\", f,\n-...                       {'Content-Length': str(len(s))})\n-\"\"\"\n-\n-import httplib, urllib2, socket\n-from httplib import NotConnected\n-\n-__all__ = ['StreamingHTTPConnection', 'StreamingHTTPRedirectHandler',\n-        'StreamingHTTPHandler', 'register_openers']\n-\n-if hasattr(httplib, 'HTTPS'):\n-    __all__.extend(['StreamingHTTPSHandler', 'StreamingHTTPSConnection'])\n-\n-class _StreamingHTTPMixin:\n-    \"\"\"Mixin class for HTTP and HTTPS connections that implements a streaming\n-    send method.\"\"\"\n-    def send(self, value):\n-        \"\"\"Send ``value`` to the server.\n-\n-        ``value`` can be a string object, a file-like object that supports\n-        a .read() method, or an iterable object that supports a .next()\n-        method.\n-        \"\"\"\n-        # Based on python 2.6's httplib.HTTPConnection.send()\n-        if self.sock is None:\n-            if self.auto_open:\n-                self.connect()\n-            else:\n-                raise NotConnected()\n-\n-        # send the data to the server. if we get a broken pipe, then close\n-        # the socket. we want to reconnect when somebody tries to send again.\n-        #\n-        # NOTE: we DO propagate the error, though, because we cannot simply\n-        #       ignore the error... the caller will know if they can retry.\n-        if self.debuglevel > 0:\n-            print \"send:\", repr(value)\n-        try:\n-            blocksize = 8192\n-            if hasattr(value, 'read') :\n-                if hasattr(value, 'seek'):\n-                    value.seek(0)\n-                if self.debuglevel > 0:\n-                    print \"sendIng a read()able\"\n-                data = value.read(blocksize)\n-                while data:\n-                    self.sock.sendall(data)\n-                    data = value.read(blocksize)\n-            elif hasattr(value, 'next'):\n-                if hasattr(value, 'reset'):\n-                    value.reset()\n-                if self.debuglevel > 0:\n-                    print \"sendIng an iterable\"\n-                for data in value:\n-                    self.sock.sendall(data)\n-            else:\n-                self.sock.sendall(value)\n-        except socket.error, v:\n-            if v[0] == 32:      # Broken pipe\n-                self.close()\n-            raise\n-\n-class StreamingHTTPConnection(_StreamingHTTPMixin, httplib.HTTPConnection):\n-    \"\"\"Subclass of `httplib.HTTPConnection` that overrides the `send()` method\n-    to support iterable body objects\"\"\"\n-\n-class StreamingHTTPRedirectHandler(urllib2.HTTPRedirectHandler):\n-    \"\"\"Subclass of `urllib2.HTTPRedirectHandler` that overrides the\n-    `redirect_request` method to properly handle redirected POST requests\n-\n-    This class is required because python 2.5's HTTPRedirectHandler does\n-    not remove the Content-Type or Content-Length headers when requesting\n-    the new resource, but the body of the original request is not preserved.\n-    \"\"\"\n-\n-    handler_order = urllib2.HTTPRedirectHandler.handler_order - 1\n-\n-    # From python2.6 urllib2's HTTPRedirectHandler\n-    def redirect_request(self, req, fp, code, msg, headers, newurl):\n-        \"\"\"Return a Request or None in response to a redirect.\n-\n-        This is called by the http_error_30x methods when a\n-        redirection response is received.  If a redirection should\n-        take place, return a new Request to allow http_error_30x to\n-        perform the redirect.  Otherwise, raise HTTPError if no-one\n-        else should try to handle this url.  Return None if you can't\n-        but another Handler might.\n-        \"\"\"\n-        m = req.get_method()\n-        if (code in (301, 302, 303, 307) and m in (\"GET\", \"HEAD\")\n-            or code in (301, 302, 303) and m == \"POST\"):\n-            # Strictly (according to RFC 2616), 301 or 302 in response\n-            # to a POST MUST NOT cause a redirection without confirmation\n-            # from the user (of urllib2, in this case).  In practice,\n-            # essentially all clients do redirect in this case, so we\n-            # do the same.\n-            # be conciliant with URIs containing a space\n-            newurl = newurl.replace(' ', '%20')\n-            newheaders = dict((k, v) for k, v in req.headers.items()\n-                              if k.lower() not in (\n-                                  \"content-length\", \"content-type\")\n-                             )\n-            return urllib2.Request(newurl,\n-                           headers=newheaders,\n-                           origin_req_host=req.get_origin_req_host(),\n-                           unverifiable=True)\n-        else:\n-            raise urllib2.HTTPError(req.get_full_url(), code, msg, headers, fp)\n-\n-class StreamingHTTPHandler(urllib2.HTTPHandler):\n-    \"\"\"Subclass of `urllib2.HTTPHandler` that uses\n-    StreamingHTTPConnection as its http connection class.\"\"\"\n-\n-    handler_order = urllib2.HTTPHandler.handler_order - 1\n-\n-    def http_open(self, req):\n-        \"\"\"Open a StreamingHTTPConnection for the given request\"\"\"\n-        return self.do_open(StreamingHTTPConnection, req)\n-\n-    def http_request(self, req):\n-        \"\"\"Handle a HTTP request.  Make sure that Content-Length is specified\n-        if we're using an interable value\"\"\"\n-        # Make sure that if we're using an iterable object as the request\n-        # body, that we've also specified Content-Length\n-        if req.has_data():\n-            data = req.get_data()\n-            if hasattr(data, 'read') or hasattr(data, 'next'):\n-                if not req.has_header('Content-length'):\n-                    raise ValueError(\n-                            \"No Content-Length specified for iterable body\")\n-        return urllib2.HTTPHandler.do_request_(self, req)\n-\n-if hasattr(httplib, 'HTTPS'):\n-    class StreamingHTTPSConnection(_StreamingHTTPMixin,\n-            httplib.HTTPSConnection):\n-        \"\"\"Subclass of `httplib.HTTSConnection` that overrides the `send()`\n-        method to support iterable body objects\"\"\"\n-\n-    class StreamingHTTPSHandler(urllib2.HTTPSHandler):\n-        \"\"\"Subclass of `urllib2.HTTPSHandler` that uses\n-        StreamingHTTPSConnection as its http connection class.\"\"\"\n-\n-        handler_order = urllib2.HTTPSHandler.handler_order - 1\n-\n-        def https_open(self, req):\n-            return self.do_open(StreamingHTTPSConnection, req)\n-\n-        def https_request(self, req):\n-            # Make sure that if we're using an iterable object as the request\n-            # body, that we've also specified Content-Length\n-            if req.has_data():\n-                data = req.get_data()\n-                if hasattr(data, 'read') or hasattr(data, 'next'):\n-                    if not req.has_header('Content-length'):\n-                        raise ValueError(\n-                                \"No Content-Length specified for iterable body\")\n-            return urllib2.HTTPSHandler.do_request_(self, req)\n-\n-\n-def get_handlers():\n-    handlers = [StreamingHTTPHandler, StreamingHTTPRedirectHandler]\n-    if hasattr(httplib, \"HTTPS\"):\n-        handlers.append(StreamingHTTPSHandler)\n-    return handlers\n-    \n-def register_openers():\n-    \"\"\"Register the streaming http handlers in the global urllib2 default\n-    opener object.\n-\n-    Returns the created OpenerDirector object.\"\"\"\n-    opener = urllib2.build_opener(*get_handlers())\n-\n-    urllib2.install_opener(opener)\n-\n-    return opener\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
