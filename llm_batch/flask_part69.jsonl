{"custom_id": "flask#8f3563cf79024056987864ad4229f03e6c1aec99", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 4769 | Contributors (this commit): 84 | Commits (past 90d): 22 | Contributors (cumulative): 84 | DMM Complexity: None\n\nDIFF:\n@@ -1585,7 +1585,7 @@ class Flask(_PackageBoundObject):\n         # when generating the response message. Set an informative\n         # description for key errors in debug mode or when trapping errors.\n         if (\n-            self.debug or self.config['TRAP_BAD_REQUEST_ERRORS']\n+            (self.debug or self.config['TRAP_BAD_REQUEST_ERRORS'])\n             and isinstance(e, BadRequestKeyError)\n             # only set it if it's still the default description\n             and e.description is BadRequestKeyError.description\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#859d9a9d5c3da114132ec9f0e515e1fa8030f68f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 20 | Lines Deleted: 18 | Files Changed: 2 | Hunks: 7 | Methods Changed: 3 | Complexity Δ (Sum/Max): 2/1 | Churn Δ: 38 | Churn Cumulative: 7127 | Contributors (this commit): 95 | Commits (past 90d): 40 | Contributors (cumulative): 107 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1166,7 +1166,9 @@ class Flask(_PackageBoundObject):\n \n     @setupmethod\n     def errorhandler(self, code_or_exception):\n-        \"\"\"A decorator that is used to register a function given an\n+        \"\"\"Register a function to handle errors by code or exception class.\n+\n+        A decorator that is used to register a function given an\n         error code.  Example::\n \n             @app.errorhandler(404)\n@@ -1179,21 +1181,6 @@ class Flask(_PackageBoundObject):\n             def special_exception_handler(error):\n                 return 'Database connection failed', 500\n \n-        You can also register a function as error handler without using\n-        the :meth:`errorhandler` decorator.  The following example is\n-        equivalent to the one above::\n-\n-            def page_not_found(error):\n-                return 'This page does not exist', 404\n-            app.error_handler_spec[None][404] = page_not_found\n-\n-        Setting error handlers via assignments to :attr:`error_handler_spec`\n-        however is discouraged as it requires fiddling with nested dictionaries\n-        and the special case for arbitrary exception types.\n-\n-        The first ``None`` refers to the active blueprint.  If the error\n-        handler should be application wide ``None`` shall be used.\n-\n         .. versionadded:: 0.7\n             Use :meth:`register_error_handler` instead of modifying\n             :attr:`error_handler_spec` directly, for application wide error\n@@ -1212,6 +1199,7 @@ class Flask(_PackageBoundObject):\n             return f\n         return decorator\n \n+    @setupmethod\n     def register_error_handler(self, code_or_exception, f):\n         \"\"\"Alternative error attach function to the :meth:`errorhandler`\n         decorator that is more straightforward to use for non decorator\n@@ -1231,10 +1219,17 @@ class Flask(_PackageBoundObject):\n         if isinstance(code_or_exception, HTTPException):  # old broken behavior\n             raise ValueError(\n                 'Tried to register a handler for an exception instance {0!r}.'\n-                'Handlers can only be registered for exception classes or HTTP error codes.'\n-                .format(code_or_exception))\n+                ' Handlers can only be registered for exception classes or'\n+                ' HTTP error codes.'.format(code_or_exception)\n+            )\n \n+        try:\n             exc_class, code = self._get_exc_class_and_code(code_or_exception)\n+        except KeyError:\n+            raise KeyError(\n+                \"'{0}' is not a recognized HTTP error code. Use a subclass of\"\n+                \" HTTPException with that code instead.\".format(code_or_exception)\n+            )\n \n         handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})\n         handlers[exc_class] = f\n\n@@ -870,6 +870,13 @@ def test_error_handling(app, client):\n     assert b'forbidden' == rv.data\n \n \n+def test_error_handler_unknown_code(app):\n+    with pytest.raises(KeyError) as exc_info:\n+        app.register_error_handler(999, lambda e: ('999', 999))\n+\n+    assert 'Use a subclass' in exc_info.value.args[0]\n+\n+\n def test_error_handling_processing(app, client):\n     app.config['LOGGER_HANDLER_POLICY'] = 'never'\n     app.testing = False\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#5e1ced3c055f7eb567bf7266c98de3d44ceea1b4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 195 | Lines Deleted: 137 | Files Changed: 3 | Hunks: 9 | Methods Changed: 23 | Complexity Δ (Sum/Max): 69/46 | Churn Δ: 332 | Churn Cumulative: 1355 | Contributors (this commit): 19 | Commits (past 90d): 10 | Contributors (cumulative): 21 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,18 +1,9 @@\n # -*- coding: utf-8 -*-\n-\"\"\"\n-    flask.json\n-    ~~~~~~~~~~\n-\n-    Implementation helpers for the JSON support in Flask.\n-\n-    :copyright: (c) 2015 by Armin Ronacher.\n-    :license: BSD, see LICENSE for more details.\n-\"\"\"\n import io\n import uuid\n from datetime import date\n-from .globals import current_app, request\n-from ._compat import text_type, PY2\n+from flask.globals import current_app, request\n+from flask._compat import text_type, PY2\n \n from werkzeug.http import http_date\n from jinja2 import Markup\n\n@@ -0,0 +1,188 @@\n+from base64 import b64decode, b64encode\n+from datetime import datetime\n+from uuid import UUID\n+\n+from jinja2 import Markup\n+from werkzeug.http import http_date, parse_date\n+\n+from flask._compat import iteritems, text_type\n+from flask.json import dumps, loads\n+\n+\n+class JSONTag(object):\n+    __slots__ = ()\n+    key = None\n+\n+    def check(self, serializer, value):\n+        raise NotImplementedError\n+\n+    def to_json(self, serializer, value):\n+        raise NotImplementedError\n+\n+    def to_python(self, serializer, value):\n+        raise NotImplementedError\n+\n+    def tag(self, serializer, value):\n+        return {self.key: self.to_json(serializer, value)}\n+\n+\n+class TagDict(JSONTag):\n+    __slots__ = ()\n+    key = ' di'\n+\n+    def check(self, serializer, value):\n+        return isinstance(value, dict)\n+\n+    def to_json(self, serializer, value, key=None):\n+        if key is not None:\n+            return {key + '__': serializer._tag(value[key])}\n+\n+        return dict((k, serializer._tag(v)) for k, v in iteritems(value))\n+\n+    def to_python(self, serializer, value):\n+        key = next(iter(value))\n+        return {key[:-2]: value[key]}\n+\n+    def tag(self, serializer, value):\n+        if len(value) == 1:\n+            key = next(iter(value))\n+\n+            if key in serializer._tags:\n+                return {self.key: self.to_json(serializer, value, key=key)}\n+\n+        return self.to_json(serializer, value)\n+\n+\n+class TagTuple(JSONTag):\n+    __slots__ = ()\n+    key = ' t'\n+\n+    def check(self, serializer, value):\n+        return isinstance(value, tuple)\n+\n+    def to_json(self, serializer, value):\n+        return [serializer._tag(item) for item in value]\n+\n+    def to_python(self, serializer, value):\n+        return tuple(value)\n+\n+\n+class PassList(JSONTag):\n+    __slots__ = ()\n+\n+    def check(self, serializer, value):\n+        return isinstance(value, list)\n+\n+    def to_json(self, serializer, value):\n+        return [serializer._tag(item) for item in value]\n+\n+    tag = to_json\n+\n+\n+class TagBytes(JSONTag):\n+    __slots__ = ()\n+    key = ' b'\n+\n+    def check(self, serializer, value):\n+        return isinstance(value, bytes)\n+\n+    def to_json(self, serializer, value):\n+        return b64encode(value).decode('ascii')\n+\n+    def to_python(self, serializer, value):\n+        return b64decode(value)\n+\n+\n+class TagMarkup(JSONTag):\n+    __slots__ = ()\n+    key = ' m'\n+\n+    def check(self, serializer, value):\n+        return callable(getattr(value, '__html__', None))\n+\n+    def to_json(self, serializer, value):\n+        return text_type(value.__html__())\n+\n+    def to_python(self, serializer, value):\n+        return Markup(value)\n+\n+\n+class TagUUID(JSONTag):\n+    __slots__ = ()\n+    key = ' u'\n+\n+    def check(self, serializer, value):\n+        return isinstance(value, UUID)\n+\n+    def to_json(self, serializer, value):\n+        return value.hex\n+\n+    def to_python(self, serializer, value):\n+        return UUID(value)\n+\n+\n+class TagDateTime(JSONTag):\n+    __slots__ = ()\n+    key = ' d'\n+\n+    def check(self, serializer, value):\n+        return isinstance(value, datetime)\n+\n+    def to_json(self, serializer, value):\n+        return http_date(value)\n+\n+    def to_python(self, serializer, value):\n+        return parse_date(value)\n+\n+\n+class TaggedJSONSerializer(object):\n+    __slots__ = ('_tags', '_order')\n+    _default_tags = [\n+        TagDict(), TagTuple(), PassList(), TagBytes(), TagMarkup(), TagUUID(),\n+        TagDateTime(),\n+    ]\n+\n+    def __init__(self):\n+        self._tags = {}\n+        self._order = []\n+\n+        for tag in self._default_tags:\n+            self.register(tag)\n+\n+    def register(self, tag, force=False, index=-1):\n+        key = tag.key\n+\n+        if key is not None:\n+            if not force and key in self._tags:\n+                raise KeyError(\"Tag '{0}' is already registered.\".format(key))\n+\n+            self._tags[key] = tag\n+\n+        if index == -1:\n+            self._order.append(tag)\n+        else:\n+            self._order.insert(index, tag)\n+\n+    def _tag(self, value):\n+        for tag in self._order:\n+            if tag.check(self, value):\n+                return tag.tag(self, value)\n+\n+        return value\n+\n+    def _untag(self, value):\n+        if len(value) != 1:\n+            return value\n+\n+        key = next(iter(value))\n+\n+        if key not in self._tags:\n+            return value\n+\n+        return self._tags[key].to_python(self, value[key])\n+\n+    def dumps(self, value):\n+        return dumps(self._tag(value), separators=(',', ':'))\n+\n+    def loads(self, value):\n+        return loads(value, object_hook=self._untag)\n\n@@ -9,18 +9,14 @@\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n import hashlib\n-import uuid\n import warnings\n-from base64 import b64decode, b64encode\n from datetime import datetime\n \n from itsdangerous import BadSignature, URLSafeTimedSerializer\n from werkzeug.datastructures import CallbackDict\n-from werkzeug.http import http_date, parse_date\n \n-from . import Markup, json\n-from ._compat import iteritems, text_type\n-from .helpers import is_ip, total_seconds\n+from flask.helpers import is_ip, total_seconds\n+from flask.json.tag import TaggedJSONSerializer\n \n \n class SessionMixin(object):\n@@ -57,126 +53,6 @@ class SessionMixin(object):\n     #: from being served the same cache.\n     accessed = True\n \n-class TaggedJSONSerializer(object):\n-    \"\"\"A customized JSON serializer that supports a few extra types that\n-    we take for granted when serializing (tuples, markup objects, datetime).\n-    \"\"\"\n-\n-    def __init__(self):\n-        self.conversions = [\n-            {\n-                'check': lambda value: self._is_dict_with_used_key(value),\n-                'tag': lambda value: self._tag_dict_used_with_key(value),\n-                'untag': lambda value: self._untag_dict_used_with_key(value),\n-                'key': ' di',\n-            },\n-            {\n-                'check': lambda value: isinstance(value, tuple),\n-                'tag': lambda value: [self._tag(x) for x in value],\n-                'untag': lambda value: tuple(value),\n-                'key': ' t',\n-            },\n-            {\n-                'check': lambda value: isinstance(value, uuid.UUID),\n-                'tag': lambda value: value.hex,\n-                'untag': lambda value: uuid.UUID(value),\n-                'key': ' u',\n-            },\n-            {\n-                'check': lambda value: isinstance(value, bytes),\n-                'tag': lambda value: b64encode(value).decode('ascii'),\n-                'untag': lambda value: b64decode(value),\n-                'key': ' b',\n-            },\n-            {\n-                'check': lambda value: callable(getattr(value, '__html__',\n-                                                        None)),\n-                'tag': lambda value: text_type(value.__html__()),\n-                'untag': lambda value: Markup(value),\n-                'key': ' m',\n-            },\n-            {\n-                'check': lambda value: isinstance(value, list),\n-                'tag': lambda value: [self._tag(x) for x in value],\n-            },\n-            {\n-                'check': lambda value: isinstance(value, datetime),\n-                'tag': lambda value: http_date(value),\n-                'untag': lambda value: parse_date(value),\n-                'key': ' d',\n-            },\n-            {\n-                'check': lambda value: isinstance(value, dict),\n-                'tag': lambda value: dict((k, self._tag(v)) for k, v in\n-                                          iteritems(value)),\n-            },\n-            {\n-                'check': lambda value: isinstance(value, str),\n-                'tag': lambda value: self._tag_string(value),\n-            }\n-        ]\n-\n-    @property\n-    def keys(self):\n-        return [c['key'] for c in self.conversions if c.get('key')]\n-\n-    def _get_conversion_untag(self, key):\n-        return next(\n-            (c['untag'] for c in self.conversions if c.get('key') == key),\n-            lambda v: None\n-        )\n-\n-    def _is_dict_with_used_key(self, v):\n-        return isinstance(v, dict) and len(v) == 1 and list(v)[0] in self.keys\n-\n-    def _was_dict_with_used_key(self, k):\n-        return k.endswith('__') and k[:-2] in self.keys\n-\n-    def _tag_string(self, value):\n-        try:\n-            return text_type(value)\n-        except UnicodeError:\n-            from flask.debughelpers import UnexpectedUnicodeError\n-            raise UnexpectedUnicodeError(u'A byte string with '\n-                u'non-ASCII data was passed to the session system '\n-                u'which can only store unicode strings.  Consider '\n-                u'base64 encoding your string (String was %r)' % value)\n-\n-    def _tag_dict_used_with_key(self, value):\n-        k, v = next(iteritems(value))\n-        return {'%s__' % k: v}\n-\n-    def _tag(self, value):\n-        for tag_ops in self.conversions:\n-            if tag_ops['check'](value):\n-                tag = tag_ops.get('key')\n-                if tag:\n-                    return {tag: tag_ops['tag'](value)}\n-                return tag_ops['tag'](value)\n-        return value\n-\n-    def _untag_dict_used_with_key(self, the_value):\n-        k, v = next(iteritems(the_value))\n-        if self._was_dict_with_used_key(k):\n-            return {k[:-2]: self._untag(v)}\n-\n-    def _untag(self, obj):\n-        if len(obj) != 1:\n-            return obj\n-        the_key, the_value = next(iteritems(obj))\n-        untag = self._get_conversion_untag(the_key)\n-        new_value = untag(the_value)\n-        return new_value if new_value else obj\n-\n-    def dumps(self, value):\n-        return json.dumps(self._tag(value), separators=(',', ':'))\n-\n-    def loads(self, value):\n-        return json.loads(value, object_hook=self._untag)\n-\n-\n-session_json_serializer = TaggedJSONSerializer()\n-\n \n class SecureCookieSession(CallbackDict, SessionMixin):\n     \"\"\"Base class for sessions based on signed cookies.\"\"\"\n@@ -404,6 +280,9 @@ class SessionInterface(object):\n         raise NotImplementedError()\n \n \n+session_json_serializer = TaggedJSONSerializer()\n+\n+\n class SecureCookieSessionInterface(SessionInterface):\n     \"\"\"The default session interface that stores sessions in signed cookies\n     through the :mod:`itsdangerous` module.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ca176cb903f9566be07e359791e364ce2fe0b1bc", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 133 | Lines Deleted: 68 | Files Changed: 1 | Hunks: 51 | Methods Changed: 18 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 201 | Churn Cumulative: 389 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -10,179 +10,244 @@ from flask.json import dumps, loads\n \n \n class JSONTag(object):\n-    __slots__ = ()\n+    \"\"\"Base class for defining type tags for :class:`TaggedJSONSerializer`.\"\"\"\n+\n+    __slots__ = ('serializer',)\n     key = None\n+    \"\"\"The tag to mark the serialized object with. If ``None``, this tag is\n+    only used as an intermediate step during tagging.\"\"\"\n+\n+    def __init__(self, serializer):\n+        \"\"\"Create a tagger for the given serializer.\"\"\"\n+\n+        self.serializer = serializer\n+\n+    def check(self, value):\n+        \"\"\"Check if the given value should be tagged by this tag.\"\"\"\n \n-    def check(self, serializer, value):\n         raise NotImplementedError\n \n-    def to_json(self, serializer, value):\n+    def to_json(self, value):\n+        \"\"\"Convert the Python object to an object that is a valid JSON type.\n+        The tag will be added later.\"\"\"\n+\n         raise NotImplementedError\n \n-    def to_python(self, serializer, value):\n+    def to_python(self, value):\n+        \"\"\"Convert the JSON representation back to the correct type. The tag\n+        will already be removed.\"\"\"\n+\n         raise NotImplementedError\n \n-    def tag(self, serializer, value):\n-        return {self.key: self.to_json(serializer, value)}\n+    def tag(self, value):\n+        \"\"\"Convert the value to a valid JSON type and add the tag structure\n+        around it.\"\"\"\n+\n+        return {self.key: self.to_json(value)}\n \n \n class TagDict(JSONTag):\n-    __slots__ = ()\n+    \"\"\"Tag for 1-item dicts whose only key matches a registered tag.\n+\n+    Internally, the dict key is suffixed with `__`, and the suffix is removed\n+    when deserializing.\n+    \"\"\"\n+\n+    __slots__ = ('serializer',)\n     key = ' di'\n \n-    def check(self, serializer, value):\n-        return isinstance(value, dict)\n+    def check(self, value):\n+        return (\n+            isinstance(value, dict)\n+            and len(value) == 1\n+            and next(iter(value)) in self.serializer.tags\n+        )\n \n-    def to_json(self, serializer, value, key=None):\n-        if key is not None:\n-            return {key + '__': serializer._tag(value[key])}\n+    def to_json(self, value):\n+        key = next(iter(value))\n+        return {key + '__': self.serializer.tag(value[key])}\n \n-        return dict((k, serializer._tag(v)) for k, v in iteritems(value))\n-\n-    def to_python(self, serializer, value):\n+    def to_python(self, value):\n         key = next(iter(value))\n         return {key[:-2]: value[key]}\n \n-    def tag(self, serializer, value):\n-        if len(value) == 1:\n-            key = next(iter(value))\n \n-            if key in serializer._tags:\n-                return {self.key: self.to_json(serializer, value, key=key)}\n+class PassDict(JSONTag):\n+    __slots__ = ('serializer',)\n \n-        return self.to_json(serializer, value)\n+    def check(self, value):\n+        return isinstance(value, dict)\n+\n+    def to_json(self, value):\n+        # JSON objects may only have string keys, so don't bother tagging the\n+        # key here.\n+        return dict((k, self.serializer.tag(v)) for k, v in iteritems(value))\n+\n+    tag = to_json\n \n \n class TagTuple(JSONTag):\n-    __slots__ = ()\n+    __slots__ = ('serializer',)\n     key = ' t'\n \n-    def check(self, serializer, value):\n+    def check(self, value):\n         return isinstance(value, tuple)\n \n-    def to_json(self, serializer, value):\n-        return [serializer._tag(item) for item in value]\n+    def to_json(self, value):\n+        return [self.serializer.tag(item) for item in value]\n \n-    def to_python(self, serializer, value):\n+    def to_python(self, value):\n         return tuple(value)\n \n \n class PassList(JSONTag):\n-    __slots__ = ()\n+    __slots__ = ('serializer',)\n \n-    def check(self, serializer, value):\n+    def check(self, value):\n         return isinstance(value, list)\n \n-    def to_json(self, serializer, value):\n-        return [serializer._tag(item) for item in value]\n+    def to_json(self, value):\n+        return [self.serializer.tag(item) for item in value]\n \n     tag = to_json\n \n \n class TagBytes(JSONTag):\n-    __slots__ = ()\n+    __slots__ = ('serializer',)\n     key = ' b'\n \n-    def check(self, serializer, value):\n+    def check(self, value):\n         return isinstance(value, bytes)\n \n-    def to_json(self, serializer, value):\n+    def to_json(self, value):\n         return b64encode(value).decode('ascii')\n \n-    def to_python(self, serializer, value):\n+    def to_python(self, value):\n         return b64decode(value)\n \n \n class TagMarkup(JSONTag):\n-    __slots__ = ()\n+    \"\"\"Serialize anything matching the :class:`~markupsafe.Markup` API by\n+    having a ``__html__`` method to the result of that method. Always\n+    deserializes to an instance of :class:`~markupsafe.Markup`.\"\"\"\n+\n+    __slots__ = ('serializer',)\n     key = ' m'\n \n-    def check(self, serializer, value):\n+    def check(self, value):\n         return callable(getattr(value, '__html__', None))\n \n-    def to_json(self, serializer, value):\n+    def to_json(self, value):\n         return text_type(value.__html__())\n \n-    def to_python(self, serializer, value):\n+    def to_python(self, value):\n         return Markup(value)\n \n \n class TagUUID(JSONTag):\n-    __slots__ = ()\n+    __slots__ = ('serializer',)\n     key = ' u'\n \n-    def check(self, serializer, value):\n+    def check(self, value):\n         return isinstance(value, UUID)\n \n-    def to_json(self, serializer, value):\n+    def to_json(self, value):\n         return value.hex\n \n-    def to_python(self, serializer, value):\n+    def to_python(self, value):\n         return UUID(value)\n \n \n class TagDateTime(JSONTag):\n-    __slots__ = ()\n+    __slots__ = ('serializer',)\n     key = ' d'\n \n-    def check(self, serializer, value):\n+    def check(self, value):\n         return isinstance(value, datetime)\n \n-    def to_json(self, serializer, value):\n+    def to_json(self, value):\n         return http_date(value)\n \n-    def to_python(self, serializer, value):\n+    def to_python(self, value):\n         return parse_date(value)\n \n \n class TaggedJSONSerializer(object):\n-    __slots__ = ('_tags', '_order')\n-    _default_tags = [\n-        TagDict(), TagTuple(), PassList(), TagBytes(), TagMarkup(), TagUUID(),\n-        TagDateTime(),\n+    \"\"\"Serializer that uses a tag system to compactly represent objects that\n+    are not JSON types. Passed as the intermediate serializer to\n+    :class:`itsdangerous.Serializer`.\"\"\"\n+\n+    __slots__ = ('tags', 'order')\n+    default_tags = [\n+        TagDict, PassDict, TagTuple, PassList, TagBytes, TagMarkup, TagUUID,\n+        TagDateTime,\n     ]\n+    \"\"\"Tag classes to bind when creating the serializer. Other tags can be\n+    added later using :meth:`~register`.\"\"\"\n \n     def __init__(self):\n-        self._tags = {}\n-        self._order = []\n+        self.tags = {}\n+        self.order = []\n \n-        for tag in self._default_tags:\n-            self.register(tag)\n+        for cls in self.default_tags:\n+            self.register(cls)\n \n-    def register(self, tag, force=False, index=-1):\n+    def register(self, tag_class, force=False, index=-1):\n+        \"\"\"Register a new tag with this serializer.\n+\n+        :param tag_class: tag class to register. Will be instantiated with this\n+            serializer instance.\n+        :param force: overwrite an existing tag. If false (default), a\n+            :exc:`KeyError` is raised.\n+        :param index: index to insert the new tag in the tag order. Useful when\n+            the new tag is a special case of an existing tag. If -1 (default),\n+            the tag is appended to the end of the order.\n+\n+        :raise KeyError: if the tag key is already registered and ``force`` is\n+            not true.\n+        \"\"\"\n+\n+        tag = tag_class(self)\n         key = tag.key\n \n         if key is not None:\n-            if not force and key in self._tags:\n+            if not force and key in self.tags:\n                 raise KeyError(\"Tag '{0}' is already registered.\".format(key))\n \n-            self._tags[key] = tag\n+            self.tags[key] = tag\n \n         if index == -1:\n-            self._order.append(tag)\n+            self.order.append(tag)\n         else:\n-            self._order.insert(index, tag)\n+            self.order.insert(index, tag)\n \n-    def _tag(self, value):\n-        for tag in self._order:\n-            if tag.check(self, value):\n-                return tag.tag(self, value)\n+    def tag(self, value):\n+        \"\"\"Convert a value to a tagged representation if necessary.\"\"\"\n+\n+        for tag in self.order:\n+            if tag.check(value):\n+                return tag.tag(value)\n \n         return value\n \n-    def _untag(self, value):\n+    def untag(self, value):\n+        \"\"\"Convert a tagged representation back to the original type.\"\"\"\n+\n         if len(value) != 1:\n             return value\n \n         key = next(iter(value))\n \n-        if key not in self._tags:\n+        if key not in self.tags:\n             return value\n \n-        return self._tags[key].to_python(self, value[key])\n+        return self.tags[key].to_python(value[key])\n \n     def dumps(self, value):\n-        return dumps(self._tag(value), separators=(',', ':'))\n+        \"\"\"Tag the value and dump it to a compact JSON string.\"\"\"\n+\n+        return dumps(self.tag(value), separators=(',', ':'))\n \n     def loads(self, value):\n-        return loads(value, object_hook=self._untag)\n+        \"\"\"Load data from a JSON string and deserialized any tagged objects.\"\"\"\n+        return loads(value, object_hook=self.untag)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#bbd15d53ad129a2ef984fdf4dca1d93f2d913803", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 19 | Lines Deleted: 16 | Files Changed: 1 | Hunks: 16 | Methods Changed: 8 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 35 | Churn Cumulative: 424 | Contributors (this commit): 1 | Commits (past 90d): 3 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -13,36 +13,32 @@ class JSONTag(object):\n     \"\"\"Base class for defining type tags for :class:`TaggedJSONSerializer`.\"\"\"\n \n     __slots__ = ('serializer',)\n+\n+    #: The tag to mark the serialized object with. If ``None``, this tag is\n+    #: only used as an intermediate step during tagging.\n     key = None\n-    \"\"\"The tag to mark the serialized object with. If ``None``, this tag is\n-    only used as an intermediate step during tagging.\"\"\"\n \n     def __init__(self, serializer):\n         \"\"\"Create a tagger for the given serializer.\"\"\"\n-\n         self.serializer = serializer\n \n     def check(self, value):\n         \"\"\"Check if the given value should be tagged by this tag.\"\"\"\n-\n         raise NotImplementedError\n \n     def to_json(self, value):\n         \"\"\"Convert the Python object to an object that is a valid JSON type.\n         The tag will be added later.\"\"\"\n-\n         raise NotImplementedError\n \n     def to_python(self, value):\n         \"\"\"Convert the JSON representation back to the correct type. The tag\n         will already be removed.\"\"\"\n-\n         raise NotImplementedError\n \n     def tag(self, value):\n         \"\"\"Convert the value to a valid JSON type and add the tag structure\n         around it.\"\"\"\n-\n         return {self.key: self.to_json(value)}\n \n \n@@ -127,9 +123,9 @@ class TagBytes(JSONTag):\n \n \n class TagMarkup(JSONTag):\n-    \"\"\"Serialize anything matching the :class:`~markupsafe.Markup` API by\n+    \"\"\"Serialize anything matching the :class:`~flask.Markup` API by\n     having a ``__html__`` method to the result of that method. Always\n-    deserializes to an instance of :class:`~markupsafe.Markup`.\"\"\"\n+    deserializes to an instance of :class:`~flask.Markup`.\"\"\"\n \n     __slots__ = ('serializer',)\n     key = ' m'\n@@ -175,15 +171,26 @@ class TagDateTime(JSONTag):\n class TaggedJSONSerializer(object):\n     \"\"\"Serializer that uses a tag system to compactly represent objects that\n     are not JSON types. Passed as the intermediate serializer to\n-    :class:`itsdangerous.Serializer`.\"\"\"\n+    :class:`itsdangerous.Serializer`.\n+\n+    The following extra types are supported:\n+\n+    * :class:`dict`\n+    * :class:`tuple`\n+    * :class:`bytes`\n+    * :class:`~flask.Markup`\n+    * :class:`~uuid.UUID`\n+    * :class:`~datetime.datetime`\n+    \"\"\"\n \n     __slots__ = ('tags', 'order')\n+\n+    #: Tag classes to bind when creating the serializer. Other tags can be\n+    #: added later using :meth:`~register`.\n     default_tags = [\n         TagDict, PassDict, TagTuple, PassList, TagBytes, TagMarkup, TagUUID,\n         TagDateTime,\n     ]\n-    \"\"\"Tag classes to bind when creating the serializer. Other tags can be\n-    added later using :meth:`~register`.\"\"\"\n \n     def __init__(self):\n         self.tags = {}\n@@ -206,7 +213,6 @@ class TaggedJSONSerializer(object):\n         :raise KeyError: if the tag key is already registered and ``force`` is\n             not true.\n         \"\"\"\n-\n         tag = tag_class(self)\n         key = tag.key\n \n@@ -223,7 +229,6 @@ class TaggedJSONSerializer(object):\n \n     def tag(self, value):\n         \"\"\"Convert a value to a tagged representation if necessary.\"\"\"\n-\n         for tag in self.order:\n             if tag.check(value):\n                 return tag.tag(value)\n@@ -232,7 +237,6 @@ class TaggedJSONSerializer(object):\n \n     def untag(self, value):\n         \"\"\"Convert a tagged representation back to the original type.\"\"\"\n-\n         if len(value) != 1:\n             return value\n \n@@ -245,7 +249,6 @@ class TaggedJSONSerializer(object):\n \n     def dumps(self, value):\n         \"\"\"Tag the value and dump it to a compact JSON string.\"\"\"\n-\n         return dumps(self.tag(value), separators=(',', ':'))\n \n     def loads(self, value):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#9bee2500dde2976befd7e88de5d403a26d7ad675", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 49 | Lines Deleted: 8 | Files Changed: 1 | Hunks: 9 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 57 | Churn Cumulative: 481 | Contributors (this commit): 1 | Commits (past 90d): 4 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -1,3 +1,44 @@\n+\"\"\"\n+Tagged JSON\n+~~~~~~~~~~~\n+\n+A compact representation for lossless serialization of non-standard JSON types.\n+:class:`~flask.sessions.SecureCookieSessionInterface` uses this to serialize\n+the session data, but it may be useful in other places. It can be extended to\n+support other types.\n+\n+.. autoclass:: TaggedJSONSerializer\n+    :members:\n+\n+.. autoclass:: JSONTag\n+    :members:\n+\n+Let's seen an example that adds support for :class:`~collections.OrderedDict`.\n+Dicts don't have an order in Python or JSON, so to handle this we will dump\n+the items as a list of ``[key, value]`` pairs. Subclass :class:`JSONTag` and\n+give it the new key ``' od'`` to identify the type. The session serializer\n+processes dicts first, so insert the new tag at the front of the order since\n+``OrderedDict`` must be processed before ``dict``. ::\n+\n+    from flask.json.tag import JSONTag\n+\n+    class TagOrderedDict(JSONTag):\n+        __slots__ = ('serializer',)\n+        key = ' od'\n+\n+        def check(self, value):\n+            return isinstance(value, OrderedDict)\n+\n+        def to_json(self, value):\n+            return [[k, self.serializer.tag(v)] for k, v in iteritems(value)]\n+\n+        def to_python(self, value):\n+            return OrderedDict(value)\n+\n+    app.session_interface.serializer.register(TagOrderedDict, 0)\n+\n+\"\"\"\n+\n from base64 import b64decode, b64encode\n from datetime import datetime\n from uuid import UUID\n@@ -49,7 +90,7 @@ class TagDict(JSONTag):\n     when deserializing.\n     \"\"\"\n \n-    __slots__ = ('serializer',)\n+    __slots__ = ()\n     key = ' di'\n \n     def check(self, value):\n@@ -69,7 +110,7 @@ class TagDict(JSONTag):\n \n \n class PassDict(JSONTag):\n-    __slots__ = ('serializer',)\n+    __slots__ = ()\n \n     def check(self, value):\n         return isinstance(value, dict)\n@@ -83,7 +124,7 @@ class PassDict(JSONTag):\n \n \n class TagTuple(JSONTag):\n-    __slots__ = ('serializer',)\n+    __slots__ = ()\n     key = ' t'\n \n     def check(self, value):\n@@ -97,7 +138,7 @@ class TagTuple(JSONTag):\n \n \n class PassList(JSONTag):\n-    __slots__ = ('serializer',)\n+    __slots__ = ()\n \n     def check(self, value):\n         return isinstance(value, list)\n@@ -109,7 +150,7 @@ class PassList(JSONTag):\n \n \n class TagBytes(JSONTag):\n-    __slots__ = ('serializer',)\n+    __slots__ = ()\n     key = ' b'\n \n     def check(self, value):\n@@ -127,7 +168,7 @@ class TagMarkup(JSONTag):\n     having a ``__html__`` method to the result of that method. Always\n     deserializes to an instance of :class:`~flask.Markup`.\"\"\"\n \n-    __slots__ = ('serializer',)\n+    __slots__ = ()\n     key = ' m'\n \n     def check(self, value):\n@@ -141,7 +182,7 @@ class TagMarkup(JSONTag):\n \n \n class TagUUID(JSONTag):\n-    __slots__ = ('serializer',)\n+    __slots__ = ()\n     key = ' u'\n \n     def check(self, value):\n@@ -155,7 +196,7 @@ class TagUUID(JSONTag):\n \n \n class TagDateTime(JSONTag):\n-    __slots__ = ('serializer',)\n+    __slots__ = ()\n     key = ' d'\n \n     def check(self, value):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#daf85d3725516a17e474b143d6d67b95140db285", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 11 | Churn Cumulative: 938 | Contributors (this commit): 23 | Commits (past 90d): 1 | Contributors (cumulative): 23 | DMM Complexity: None\n\nDIFF:\n@@ -97,7 +97,7 @@ class Request(RequestBase):\n \n     @property\n     def json(self):\n-        \"\"\"If the mimetype is :mimetype:`application/json` this will contain the\n+        \"\"\"If self.is_json would return true, this will contain the\n         parsed JSON data.  Otherwise this will be ``None``.\n \n         The :meth:`get_json` method should be used instead.\n@@ -124,11 +124,10 @@ class Request(RequestBase):\n \n     def get_json(self, force=False, silent=False, cache=True):\n         \"\"\"Parses the incoming JSON request data and returns it.  By default\n-        this function will return ``None`` if the mimetype is not\n-        :mimetype:`application/json` but this can be overridden by the\n-        ``force`` parameter. If parsing fails the\n-        :meth:`on_json_loading_failed` method on the request object will be\n-        invoked.\n+        this function will return ``None`` if self.is_json would return false,\n+        but this can be overridden by the ``force`` parameter. If parsing\n+        fails, the :meth:`on_json_loading_failed` method on the request object\n+        will be invoked.\n \n         :param force: if set to ``True`` the mimetype is ignored.\n         :param silent: if set to ``True`` this method will fail silently\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#fd8b95952c3891c402b18d1d35c6a2d263b8c6fb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 86 | Lines Deleted: 24 | Files Changed: 2 | Hunks: 5 | Methods Changed: 11 | Complexity Δ (Sum/Max): 7/8 | Churn Δ: 110 | Churn Cumulative: 2437 | Contributors (this commit): 23 | Commits (past 90d): 19 | Contributors (cumulative): 24 | DMM Complexity: 1.0\n\nDIFF:\n@@ -435,34 +435,31 @@ def test_session_special_types(app, client):\n     now = datetime.utcnow().replace(microsecond=0)\n     the_uuid = uuid.uuid4()\n \n-    @app.after_request\n-    def modify_session(response):\n-        flask.session['m'] = flask.Markup('Hello!')\n-        flask.session['u'] = the_uuid\n-        flask.session['dt'] = now\n-        flask.session['b'] = b'\\xff'\n-        flask.session['t'] = (1, 2, 3)\n-        flask.session['spacefirst'] = {' t': 'not-a-tuple'}\n-        flask.session['withunderscores'] = {' t__': 'not-a-tuple'}\n-        flask.session['notadict'] = {' di': 'not-a-dict'}\n-        return response\n-\n     @app.route('/')\n     def dump_session_contents():\n-        return pickle.dumps(dict(flask.session))\n+        flask.session['t'] = (1, 2, 3)\n+        flask.session['b'] = b'\\xff'\n+        flask.session['m'] = flask.Markup('<html>')\n+        flask.session['u'] = the_uuid\n+        flask.session['d'] = now\n+        flask.session['t_tag'] = {' t': 'not-a-tuple'}\n+        flask.session['di_t_tag'] = {' t__': 'not-a-tuple'}\n+        flask.session['di_tag'] = {' di': 'not-a-dict'}\n+        return '', 204\n \n+    with client:\n         client.get('/')\n-    rv = pickle.loads(client.get('/').data)\n-    assert rv['m'] == flask.Markup('Hello!')\n-    assert type(rv['m']) == flask.Markup\n-    assert rv['dt'] == now\n-    assert rv['u'] == the_uuid\n-    assert rv['b'] == b'\\xff'\n-    assert type(rv['b']) == bytes\n-    assert rv['t'] == (1, 2, 3)\n-    assert rv['spacefirst'] == {' t': 'not-a-tuple'}\n-    assert rv['withunderscores'] == {' t__': 'not-a-tuple'}\n-    assert rv['notadict'] == {' di': 'not-a-dict'}\n+        s = flask.session\n+        assert s['t'] == (1, 2, 3)\n+        assert type(s['b']) == bytes\n+        assert s['b'] == b'\\xff'\n+        assert type(s['m']) == flask.Markup\n+        assert s['m'] == flask.Markup('<html>')\n+        assert s['u'] == the_uuid\n+        assert s['d'] == now\n+        assert s['t_tag'] == {' t': 'not-a-tuple'}\n+        assert s['di_t_tag'] == {' t__': 'not-a-tuple'}\n+        assert s['di_tag'] == {' di': 'not-a-dict'}\n \n \n def test_session_cookie_setting(app):\n\n@@ -0,0 +1,65 @@\n+from datetime import datetime\n+from uuid import uuid4\n+\n+import pytest\n+\n+from flask import Markup\n+from flask.json.tag import TaggedJSONSerializer, JSONTag\n+\n+\n+@pytest.mark.parametrize(\"data\", (\n+    {' t': (1, 2, 3)},\n+    {' t__': b'a'},\n+    {' di': ' di'},\n+    {'x': (1, 2, 3), 'y': 4},\n+    (1, 2, 3),\n+    [(1, 2, 3)],\n+    b'\\xff',\n+    Markup('<html>'),\n+    uuid4(),\n+    datetime.utcnow().replace(microsecond=0),\n+))\n+def test_dump_load_unchanged(data):\n+    s = TaggedJSONSerializer()\n+    assert s.loads(s.dumps(data)) == data\n+\n+\n+def test_duplicate_tag():\n+    class TagDict(JSONTag):\n+        key = ' d'\n+\n+    s = TaggedJSONSerializer()\n+    pytest.raises(KeyError, s.register, TagDict)\n+    s.register(TagDict, force=True, index=0)\n+    assert isinstance(s.tags[' d'], TagDict)\n+    assert isinstance(s.order[0], TagDict)\n+\n+\n+def test_custom_tag():\n+    class Foo(object):\n+        def __init__(self, data):\n+            self.data = data\n+\n+    class TagFoo(JSONTag):\n+        __slots__ = ()\n+        key = ' f'\n+\n+        def check(self, value):\n+            return isinstance(value, Foo)\n+\n+        def to_json(self, value):\n+            return self.serializer.tag(value.data)\n+\n+        def to_python(self, value):\n+            return Foo(value)\n+\n+    s = TaggedJSONSerializer()\n+    s.register(TagFoo)\n+    assert s.loads(s.dumps(Foo('bar'))).data == 'bar'\n+\n+\n+def test_tag_interface():\n+    t = JSONTag(None)\n+    pytest.raises(NotImplementedError, t.check, None)\n+    pytest.raises(NotImplementedError, t.to_json, None)\n+    pytest.raises(NotImplementedError, t.to_python, None)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#217d5f9bc063ef8a605002648035c3e03c103a5f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 8 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 14 | Churn Cumulative: 952 | Contributors (this commit): 24 | Commits (past 90d): 2 | Contributors (cumulative): 24 | DMM Complexity: None\n\nDIFF:\n@@ -97,8 +97,9 @@ class Request(RequestBase):\n \n     @property\n     def json(self):\n-        \"\"\"If self.is_json would return true, this will contain the\n-        parsed JSON data.  Otherwise this will be ``None``.\n+        \"\"\"If the request has a JSON mimetype like :mimetype:`application/json`\n+        (see :meth:`is_json`), this will contain the parsed JSON data.\n+        Otherwise this will be ``None``.\n \n         The :meth:`get_json` method should be used instead.\n         \"\"\"\n@@ -124,10 +125,11 @@ class Request(RequestBase):\n \n     def get_json(self, force=False, silent=False, cache=True):\n         \"\"\"Parses the incoming JSON request data and returns it. By default\n-        this function will return ``None`` if self.is_json would return false,\n-        but this can be overridden by the ``force`` parameter. If parsing\n-        fails, the :meth:`on_json_loading_failed` method on the request object\n-        will be invoked.\n+        this function will return ``None`` if the request does not use a JSON\n+        mimetype like :mimetype:`application/json`. See :meth:`is_json`. This\n+        can be overridden by the ``force`` parameter. If parsing fails,\n+        the :meth:`on_json_loading_failed` method on the request object will be\n+        invoked.\n \n         :param force: if set to ``True`` the mimetype is ignored.\n         :param silent: if set to ``True`` this method will fail silently\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#5978a0f55f8ffd723d552645d70ac92e4e1148e4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 14 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 3 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 14 | Churn Cumulative: 1535 | Contributors (this commit): 23 | Commits (past 90d): 18 | Contributors (cumulative): 23 | DMM Complexity: 1.0\n\nDIFF:\n@@ -861,6 +861,20 @@ class TestStreaming(object):\n         assert rv.data == b'Hello World!'\n         assert called == [42]\n \n+    def test_stream_keeps_session(self, app, client):\n+        @app.route('/')\n+        def index():\n+            flask.session['test'] = 'flask'\n+\n+            @flask.stream_with_context\n+            def gen():\n+                yield flask.session['test']\n+\n+            return flask.Response(gen())\n+\n+        rv = client.get('/')\n+        assert rv.data == b'flask'\n+\n \n class TestSafeJoin(object):\n     def test_safe_join(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#6637e201743225f8fc840d3b7cfcdae67f2895ef", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 8 | Lines Deleted: 5 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 13 | Churn Cumulative: 677 | Contributors (this commit): 15 | Commits (past 90d): 2 | Contributors (cumulative): 15 | DMM Complexity: 0.0\n\nDIFF:\n@@ -325,12 +325,15 @@ class RequestContext(object):\n \n         _request_ctx_stack.push(self)\n \n-        # Open the session at the moment that the request context is\n-        # available. This allows a custom open_session method to use the\n-        # request context (e.g. code that access database information\n-        # stored on `g` instead of the appcontext).\n+        # Open the session at the moment that the request context is available.\n+        # This allows a custom open_session method to use the request context.\n+        # Only open a new session if this is the first time the request was\n+        # pushed, otherwise stream_with_context loses the session.\n+        if self.session is None:\n             session_interface = self.app.session_interface\n-        self.session = session_interface.open_session(self.app, self.request)\n+            self.session = session_interface.open_session(\n+                self.app, self.request\n+            )\n \n             if self.session is None:\n                 self.session = session_interface.make_null_session(self.app)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#e97253e4c1a0380f0b70108e8f984b0d9b87ac11", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 70 | Lines Deleted: 63 | Files Changed: 3 | Hunks: 37 | Methods Changed: 11 | Complexity Δ (Sum/Max): 6/6 | Churn Δ: 133 | Churn Cumulative: 1843 | Contributors (this commit): 33 | Commits (past 90d): 9 | Contributors (cumulative): 45 | DMM Complexity: 0.75\n\nDIFF:\n@@ -23,7 +23,7 @@ except ImportError:\n \n \n def make_test_environ_builder(\n-    app, path='/', base_url=None, subdomain=None, url_scheme=None, json=None,\n+    app, path='/', base_url=None, subdomain=None, url_scheme=None,\n     *args, **kwargs\n ):\n     \"\"\"Creates a new test builder with some application defaults thrown in.\"\"\"\n@@ -54,12 +54,14 @@ def make_test_environ_builder(\n             path += sep + url.query\n \n     if 'json' in kwargs:\n-        if 'data' in kwargs:\n-            raise ValueError('Client cannot provide both `json` and `data`')\n+        assert 'data' not in kwargs, (\n+            \"Client cannot provide both 'json' and 'data'.\"\n+        )\n \n+        # push a context so flask.json can use app's json attributes\n+        with app.app_context():\n             kwargs['data'] = json_dumps(kwargs.pop('json'))\n \n-        # Only set Content-Type when not explicitly provided\n         if 'content_type' not in kwargs:\n             kwargs['content_type'] = 'application/json'\n \n\n@@ -8,111 +8,106 @@\n     :copyright: (c) 2015 by Armin Ronacher.\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n+from warnings import warn\n \n-from werkzeug.wrappers import Request as RequestBase, Response as ResponseBase\n from werkzeug.exceptions import BadRequest\n+from werkzeug.wrappers import Request as RequestBase, Response as ResponseBase\n \n-from . import json\n-from .globals import _app_ctx_stack\n+from flask import json\n+from flask.globals import current_app\n \n \n class JSONMixin(object):\n     \"\"\"Common mixin for both request and response objects to provide JSON\n     parsing capabilities.\n \n-    .. versionadded:: 0.12\n+    .. versionadded:: 1.0\n     \"\"\"\n \n+    _cached_json = Ellipsis\n+\n     @property\n     def is_json(self):\n-        \"\"\"Indicates if this request/response is in JSON format or not.  By\n-        default it is considered to include JSON data if the mimetype is\n+        \"\"\"Check if the mimetype indicates JSON data, either\n         :mimetype:`application/json` or :mimetype:`application/*+json`.\n \n-        .. versionadded:: 1.0\n+        .. versionadded:: 0.11\n         \"\"\"\n         mt = self.mimetype\n-        if mt == 'application/json':\n-            return True\n-        if mt.startswith('application/') and mt.endswith('+json'):\n-            return True\n-        return False\n+        return (\n+            mt == 'application/json'\n+            or (mt.startswith('application/')) and mt.endswith('+json')\n+        )\n \n     @property\n     def json(self):\n-        \"\"\"If this request/response is in JSON format then this property will\n-        contain the parsed JSON data.  Otherwise it will be ``None``.\n+        \"\"\"This will contain the parsed JSON data if the mimetype indicates\n+        JSON (:mimetype:`application/json`, see :meth:`is_json`), otherwise it\n+        will be ``None``.\n \n-        The :meth:`get_json` method should be used instead.\n+        .. deprecated:: 1.0\n+            Use :meth:`get_json` instead.\n         \"\"\"\n-        from warnings import warn\n         warn(DeprecationWarning(\n-            'json is deprecated.  Use get_json() instead.'), stacklevel=2)\n+            \"'json' is deprecated. Use 'get_json()' instead.\"\n+        ), stacklevel=2)\n         return self.get_json()\n \n     def _get_data_for_json(self, cache):\n-        getter = getattr(self, 'get_data', None)\n-        if getter is not None:\n-            return getter(cache=cache)\n-        return self.data\n+        return self.get_data(cache=cache)\n \n     def get_json(self, force=False, silent=False, cache=True):\n-        \"\"\"Parses the JSON request/response data and returns it.  By default\n-        this function will return ``None`` if the mimetype is not\n-        :mimetype:`application/json` but this can be overridden by the\n-        ``force`` parameter. If parsing fails the\n-        :meth:`on_json_loading_failed` method on the request object will be\n-        invoked.\n+        \"\"\"Parse and return the data as JSON. If the mimetype does not indicate\n+        JSON (:mimetype:`application/json`, see :meth:`is_json`), this returns\n+        ``None`` unless ``force`` is true. If parsing fails,\n+        :meth:`on_json_loading_failed` is called and its return value is used\n+        as the return value.\n \n-        :param force: if set to ``True`` the mimetype is ignored.\n-        :param silent: if set to ``True`` this method will fail silently\n-                       and return ``None``.\n-        :param cache: if set to ``True`` the parsed JSON data is remembered\n-                      on the object.\n+        :param force: Ignore the mimetype and always try to parse JSON.\n+        :param silent: Silence parsing errors and return ``None`` instead.\n+        :param cache: Store the parsed JSON to return for subsequent calls.\n         \"\"\"\n-        try:\n-            return getattr(self, '_cached_json')\n-        except AttributeError:\n-            pass\n+        if cache and self._cached_json is not Ellipsis:\n+            return self._cached_json\n \n         if not (force or self.is_json):\n             return None\n \n-        # We accept MIME charset header against the specification as certain\n-        # clients have been using this in the past.  For responses, we assume\n-        # that if the response charset was set explicitly then the data had\n-        # been encoded correctly as well.\n+        # We accept MIME charset against the specification as certain clients\n+        # have used this in the past. For responses, we assume that if the\n+        # charset is set then the data has been encoded correctly as well.\n         charset = self.mimetype_params.get('charset')\n+\n         try:\n-            data = self._get_data_for_json(cache)\n-            if charset is not None:\n+            data = self._get_data_for_json(cache=cache)\n             rv = json.loads(data, encoding=charset)\n-            else:\n-                rv = json.loads(data)\n         except ValueError as e:\n             if silent:\n                 rv = None\n             else:\n                 rv = self.on_json_loading_failed(e)\n+\n         if cache:\n             self._cached_json = rv\n+\n         return rv\n \n     def on_json_loading_failed(self, e):\n-        \"\"\"Called if decoding of the JSON data failed.  The return value of\n-        this method is used by :meth:`get_json` when an error occurred.  The\n-        default implementation just raises a :class:`BadRequest` exception.\n+        \"\"\"Called if :meth:`get_json` parsing fails and isn't silenced. If\n+        this method returns a value, it is used as the return value for\n+        :meth:`get_json`. The default implementation raises a\n+        :class:`BadRequest` exception.\n \n         .. versionchanged:: 0.10\n-           Removed buggy previous behavior of generating a random JSON\n-           response.  If you want that behavior back you can trivially\n-           add it by subclassing.\n+           Raise a :exc:`BadRequest` error instead of returning an error\n+           message as JSON. If you want that behavior you can add it by\n+           subclassing.\n \n         .. versionadded:: 0.8\n         \"\"\"\n-        ctx = _app_ctx_stack.top\n-        if ctx is not None and ctx.app.debug:\n+        if current_app is not None and current_app.debug:\n             raise BadRequest('Failed to decode JSON object: {0}'.format(e))\n+\n         raise BadRequest()\n \n \n@@ -153,9 +148,8 @@ class Request(RequestBase, JSONMixin):\n     @property\n     def max_content_length(self):\n         \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\"\n-        ctx = _app_ctx_stack.top\n-        if ctx is not None:\n-            return ctx.app.config['MAX_CONTENT_LENGTH']\n+        if current_app:\n+            return current_app.config['MAX_CONTENT_LENGTH']\n \n     @property\n     def endpoint(self):\n@@ -191,9 +185,12 @@ class Request(RequestBase, JSONMixin):\n \n         # In debug mode we're replacing the files multidict with an ad-hoc\n         # subclass that raises a different error for key errors.\n-        ctx = _app_ctx_stack.top\n-        if ctx is not None and ctx.app.debug and \\\n-           self.mimetype != 'multipart/form-data' and not self.files:\n+        if (\n+            current_app\n+            and current_app.debug\n+            and self.mimetype != 'multipart/form-data'\n+            and not self.files\n+        ):\n             from .debughelpers import attach_enctype_error_multidict\n             attach_enctype_error_multidict(self)\n \n@@ -206,5 +203,13 @@ class Response(ResponseBase, JSONMixin):\n \n     If you want to replace the response object used you can subclass this and\n     set :attr:`~flask.Flask.response_class` to your subclass.\n+\n+    .. versionchanged:: 1.0\n+        JSON support is added to the response, like the request. This is useful\n+        when testing to get the test client response data as JSON.\n     \"\"\"\n+\n     default_mimetype = 'text/html'\n+\n+    def _get_data_for_json(self, cache):\n+        return self.get_data()\n\n@@ -267,7 +267,7 @@ def test_full_url_request(app, client):\n def test_json_request_and_response(app, client):\n     @app.route('/echo', methods=['POST'])\n     def echo():\n-        return jsonify(flask.request.json)\n+        return jsonify(flask.request.get_json())\n \n     with client:\n         json_data = {'drink': {'gin': 1, 'tonic': True}, 'price': 10}\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
