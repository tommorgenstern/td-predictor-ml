{"custom_id": "flask#ff034e42cfb665dc9123c95e51ad3d1455322bd5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 3 | Complexity Δ (Sum/Max): -3/0 | Churn Δ: 6 | Churn Cumulative: 353 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -53,6 +53,9 @@ def find_best_app(module):\n \n \n def prepare_exec_for_file(filename):\n+    \"\"\"Given a filename this will try to calculate the python path, add it\n+    to the search path and return the actual module name that is expected.\n+    \"\"\"\n     module = []\n \n     # Chop off file extensions or package markers\n@@ -187,8 +190,7 @@ class FlaskClickGroup(click.Group):\n     def __init__(self, help=None):\n         def set_app_id(ctx, value):\n             if value is not None:\n-                if os.path.isfile(value) or os.sep in value or \\\n-                   os.altsep is not None and os.altsep in value:\n+                if os.path.isfile(value):\n                     value = prepare_exec_for_file(value)\n             ctx.obj.app_import_path = value\n         def set_debug(ctx, value):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#bacdd076bd544ca82d05111e3a427e98e4d4c996", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 2 | Churn Cumulative: 355 | Contributors (this commit): 1 | Commits (past 90d): 3 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -192,6 +192,8 @@ class FlaskClickGroup(click.Group):\n             if value is not None:\n                 if os.path.isfile(value):\n                     value = prepare_exec_for_file(value)\n+                elif '.' not in sys.path:\n+                    sys.path.insert(0, '.')\n             ctx.obj.app_import_path = value\n         def set_debug(ctx, value):\n             ctx.obj.debug = value\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#a3a5075a942a321ccf67c7511822e62dc1d5858f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 10 | Churn Cumulative: 247 | Contributors (this commit): 4 | Commits (past 90d): 2 | Contributors (cumulative): 4 | DMM Complexity: None\n\nDIFF:\n@@ -37,13 +37,14 @@ def connect_db():\n     return rv\n \n \n-def init_db():\n+@app.cli.command()\n+def initdb():\n     \"\"\"Creates the database tables.\"\"\"\n-    with app.app_context():\n     db = get_db()\n     with app.open_resource('schema.sql', mode='r') as f:\n         db.cursor().executescript(f.read())\n     db.commit()\n+    print('Initialized the database.')\n \n \n def get_db():\n@@ -102,8 +103,3 @@ def logout():\n     session.pop('logged_in', None)\n     flash('You were logged out')\n     return redirect(url_for('show_entries'))\n-\n-\n-if __name__ == '__main__':\n-    init_db()\n-    app.run()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ed9e458850a548ceb6027bf25a657f26595656ff", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 357 | Contributors (this commit): 2 | Commits (past 90d): 4 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -99,7 +99,7 @@ def locate_app(app_id, debug=None):\n \n \n class DispatchingApp(object):\n-    \"\"\"Special applicationt that dispatches to a flask application which\n+    \"\"\"Special application that dispatches to a flask application which\n     is imported by name on first request.  This is safer than importing\n     the application upfront because it means that we can forward all\n     errors for import problems into the browser as error.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#a3ad5405a68f312f077e8d6271e694f6925c0864", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 362 | Contributors (this commit): 2 | Commits (past 90d): 5 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -63,6 +63,11 @@ def prepare_exec_for_file(filename):\n         filename = filename[:-3]\n     elif os.path.split(filename)[1] == '__init__.py':\n         filename = os.path.dirname(filename)\n+    else:\n+        raise NoAppException('The file provided (%s) does exist but is not a '\n+                             'valid Python file.  This means that it cannot '\n+                             'be used as application.  Please change the '\n+                             'extension to .py' % filename)\n     filename = os.path.realpath(filename)\n \n     dirpath = filename\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#9ab59871007c12fad03f43ac08f889e4c080e64d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 19 | Files Changed: 4 | Hunks: 6 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 21 | Churn Cumulative: 531 | Contributors (this commit): 7 | Commits (past 90d): 4 | Contributors (cumulative): 11 | DMM Complexity: 0.0\n\nDIFF:\n@@ -5,7 +5,3 @@ app = Flask(__name__)\n app.register_blueprint(simple_page)\n # Blueprint can be registered many times\n app.register_blueprint(simple_page, url_prefix='/pages')\n-\n-\n-if __name__ == '__main__':\n-    app.run(debug=True)\n\\ No newline at end of file\n\n@@ -23,7 +23,3 @@ def add_numbers():\n @app.route('/')\n def index():\n     return render_template('index.html')\n-\n-\n-if __name__ == '__main__':\n-    app.run()\n\n@@ -49,9 +49,9 @@ def close_database(exception):\n         top.sqlite_db.close()\n \n \n-def init_db():\n+@app.cli.command()\n+def initdb():\n     \"\"\"Creates the database tables.\"\"\"\n-    with app.app_context():\n     db = get_db()\n     with app.open_resource('schema.sql', mode='r') as f:\n         db.cursor().executescript(f.read())\n@@ -248,8 +248,3 @@ def logout():\n # add some filters to jinja\n app.jinja_env.filters['datetimeformat'] = format_datetime\n app.jinja_env.filters['gravatar'] = gravatar_url\n-\n-\n-if __name__ == '__main__':\n-    init_db()\n-    app.run()\n\n@@ -53,7 +53,3 @@ def logout_handler():\n     \"\"\"\n     session.clear()\n     return 'OK'\n-\n-\n-if __name__ == '__main__':\n-    app.run()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#e059bf311c6a75150275b434c53544f7528749bc", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 12 | Churn Cumulative: 374 | Contributors (this commit): 2 | Commits (past 90d): 6 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -139,9 +139,9 @@ class ScriptInfo(object):\n     to click.\n     \"\"\"\n \n-    def __init__(self):\n-        self.app_import_path = None\n-        self.debug = None\n+    def __init__(self, app_import_path=None, debug=None):\n+        self.app_import_path = app_import_path\n+        self.debug = debug\n         self._loaded_app = None\n \n     def get_app_import_path(self):\n@@ -187,7 +187,7 @@ def without_appcontext(f):\n     return f\n \n \n-class FlaskClickGroup(click.Group):\n+class FlaskGroup(click.Group):\n     \"\"\"Special subclass of the a regular click group that supports\n     loading more commands from the configured Flask app.\n     \"\"\"\n@@ -244,7 +244,7 @@ class FlaskClickGroup(click.Group):\n                 self, ctx, cmd, cmd_name, args)\n \n \n-cli = FlaskClickGroup(help='''\\\n+cli = FlaskGroup(help='''\\\n This shell command acts as general utility script for Flask applications.\n \n It loads the application configured (either through the FLASK_APP environment\n@@ -346,7 +346,7 @@ def main(as_module=False):\n         # the reloader can properly operate.\n         sys.argv = ['-m', this_module] + sys.argv[1:]\n     else:\n-        name = 'flask'\n+        name = None\n \n     cli.main(args=args, prog_name=name, obj=ScriptInfo(),\n              auto_envvar_prefix='FLASK')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#d2d8e66130f8aabf8e0e4b80a42352f8ef93c347", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 21 | Lines Deleted: 8 | Files Changed: 5 | Hunks: 8 | Methods Changed: 11 | Complexity Δ (Sum/Max): 2/1 | Churn Δ: 29 | Churn Cumulative: 1400 | Contributors (this commit): 8 | Commits (past 90d): 14 | Contributors (cumulative): 18 | DMM Complexity: 1.0\n\nDIFF:\n@@ -37,13 +37,18 @@ def connect_db():\n     return rv\n \n \n-@app.cli.command()\n-def initdb():\n-    \"\"\"Creates the database tables.\"\"\"\n+def init_db():\n+    \"\"\"Initializes the database.\"\"\"\n     db = get_db()\n     with app.open_resource('schema.sql', mode='r') as f:\n         db.cursor().executescript(f.read())\n     db.commit()\n+\n+\n+@app.cli.command('initdb')\n+def initdb_command():\n+    \"\"\"Creates the database tables.\"\"\"\n+    init_db()\n     print('Initialized the database.')\n \n \n\n@@ -21,6 +21,7 @@ class FlaskrTestCase(unittest.TestCase):\n         self.db_fd, flaskr.app.config['DATABASE'] = tempfile.mkstemp()\n         flaskr.app.config['TESTING'] = True\n         self.app = flaskr.app.test_client()\n+        with flaskr.app.app_context():\n             flaskr.init_db()\n \n     def tearDown(self):\n\n@@ -49,15 +49,21 @@ def close_database(exception):\n         top.sqlite_db.close()\n \n \n-@app.cli.command()\n-def initdb():\n-    \"\"\"Creates the database tables.\"\"\"\n+def init_db():\n+    \"\"\"Initializes the database.\"\"\"\n     db = get_db()\n     with app.open_resource('schema.sql', mode='r') as f:\n         db.cursor().executescript(f.read())\n     db.commit()\n \n \n+@app.cli.command('initdb')\n+def initdb_command():\n+    \"\"\"Creates the database tables.\"\"\"\n+    init_db()\n+    print('Initialized the database.')\n+\n+\n def query_db(query, args=(), one=False):\n     \"\"\"Queries the database and returns a list of dictionaries.\"\"\"\n     cur = get_db().execute(query, args)\n\n@@ -20,6 +20,7 @@ class MiniTwitTestCase(unittest.TestCase):\n         \"\"\"Before each test, set up a blank database\"\"\"\n         self.db_fd, minitwit.app.config['DATABASE'] = tempfile.mkstemp()\n         self.app = minitwit.app.test_client()\n+        with minitwit.app.app_context():\n             minitwit.init_db()\n \n     def tearDown(self):\n\n@@ -199,9 +199,9 @@ class FlaskGroup(click.Group):\n                     value = prepare_exec_for_file(value)\n                 elif '.' not in sys.path:\n                     sys.path.insert(0, '.')\n-            ctx.obj.app_import_path = value\n+            ctx.ensure_object(ScriptInfo).app_import_path = value\n         def set_debug(ctx, value):\n-            ctx.obj.debug = value\n+            ctx.ensure_object(ScriptInfo).debug = value\n \n         click.Group.__init__(self, help=help, params=[\n             click.Option(['-a', '--app'],\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#4532e89efe9ef1161d4cdbd12687dac0c19c49b7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 42 | Lines Deleted: 16 | Files Changed: 1 | Hunks: 14 | Methods Changed: 12 | Complexity Δ (Sum/Max): 8/8 | Churn Δ: 58 | Churn Cumulative: 436 | Contributors (this commit): 2 | Commits (past 90d): 8 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -110,38 +110,44 @@ class DispatchingApp(object):\n     errors for import problems into the browser as error.\n     \"\"\"\n \n-    def __init__(self, app_id, debug=None, use_eager_loading=False):\n-        self.app_id = app_id\n-        self.app = None\n-        self.debug = debug\n+    def __init__(self, loader, use_eager_loading=False):\n+        self.loader = loader\n+        self._app = None\n         self._lock = Lock()\n         if use_eager_loading:\n             self._load_unlocked()\n \n     def _load_unlocked(self):\n-        self.app = rv = locate_app(self.app_id, self.debug)\n+        self._app = rv = self.loader()\n         return rv\n \n     def __call__(self, environ, start_response):\n-        if self.app is not None:\n-            return self.app(environ, start_response)\n+        if self._app is not None:\n+            return self._app(environ, start_response)\n         with self._lock:\n-            if self.app is not None:\n-                rv = self.app\n+            if self._app is not None:\n+                rv = self._app\n             else:\n                 rv = self._load_unlocked()\n             return rv(environ, start_response)\n \n \n+def _no_such_app():\n+    raise NoAppException('Could not locate Flask application. '\n+                         'You did not provide FLASK_APP or the '\n+                         '--app parameter.')\n+\n+\n class ScriptInfo(object):\n     \"\"\"Help object to deal with Flask applications.  This is usually not\n     necessary to interface with as it's used internally in the dispatching\n     to click.\n     \"\"\"\n \n-    def __init__(self, app_import_path=None, debug=None):\n+    def __init__(self, app_import_path=None, debug=None, load_callback=None):\n         self.app_import_path = app_import_path\n         self.debug = debug\n+        self.load_callback = load_callback\n         self._loaded_app = None\n \n     def get_app_import_path(self):\n@@ -150,18 +156,33 @@ class ScriptInfo(object):\n         \"\"\"\n         if self.app_import_path is not None:\n             return self.app_import_path\n-        raise NoAppException('Could not locate application. '\n-                             'You did not provide FLASK_APP or the '\n-                             '--app parameter.')\n+        _no_such_app()\n \n     def load_app(self):\n         \"\"\"Loads the app (if not yet loaded) and returns it.\"\"\"\n         if self._loaded_app is not None:\n             return self._loaded_app\n+        if self.load_callback is not None:\n+            rv = self.load_callback()\n+        else:\n             rv = locate_app(self.get_app_import_path(), self.debug)\n         self._loaded_app = rv\n         return rv\n \n+    def make_wsgi_app(self, use_eager_loading=False):\n+        \"\"\"Returns a WSGI app that loads the actual application at a\n+        later stage.\n+        \"\"\"\n+        if self.app_import_path is not None:\n+            def loader():\n+                return locate_app(self.app_import_path, self.debug)\n+        else:\n+            if self.load_callback is None:\n+                _no_such_app()\n+            def loader():\n+                return self.load_callback()\n+        return DispatchingApp(loader, use_eager_loading=use_eager_loading)\n+\n     @contextmanager\n     def conditional_context(self, with_context=True):\n         \"\"\"Creates an application context or not, depending on the\n@@ -281,7 +302,6 @@ def run_command(info, host, port, reload, debugger, eager_loading,\n                 with_threads):\n     \"\"\"Runs a local development server for the Flask application.\"\"\"\n     from werkzeug.serving import run_simple\n-    app_id = info.get_app_import_path()\n     if reload is None:\n         reload = info.debug\n     if debugger is None:\n@@ -289,14 +309,20 @@ def run_command(info, host, port, reload, debugger, eager_loading,\n     if eager_loading is None:\n         eager_loading = not reload\n \n+    app = info.make_wsgi_app(use_eager_loading=eager_loading)\n+\n     # Extra startup messages.  This depends a but on Werkzeug internals to\n     # not double execute when the reloader kicks in.\n     if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n-        print(' * Serving Flask app \"%s\"' % app_id)\n+        # If we have an import path we can print it out now which can help\n+        # people understand what's being served.  If we do not have an\n+        # import path because the app was loaded through a callback then\n+        # we won't print anything.\n+        if info.app_import_path is not None:\n+            print(' * Serving Flask app \"%s\"' % info.app_import_path)\n         if info.debug is not None:\n             print(' * Forcing debug %s' % (info.debug and 'on' or 'off'))\n \n-    app = DispatchingApp(app_id, info.debug, eager_loading)\n     run_simple(host, port, app, use_reloader=reload,\n                use_debugger=debugger, threaded=with_threads)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ed7b4ccac1b646aa725007db7fd3ec2d359beaf4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 35 | Lines Deleted: 32 | Files Changed: 1 | Hunks: 2 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 67 | Churn Cumulative: 503 | Contributors (this commit): 2 | Commits (past 90d): 9 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -208,7 +208,41 @@ def without_appcontext(f):\n     return f\n \n \n-class FlaskGroup(click.Group):\n+class ContextGroupMixin(object):\n+\n+    def get_command(self, ctx, name):\n+        info = ctx.find_object(ScriptInfo)\n+        # Find the command in the application first, if we can find it.\n+        # If the app is not available, we just ignore this silently.\n+        try:\n+            rv = info.load_app().cli.get_command(ctx, name)\n+            if rv is not None:\n+                return rv\n+        except NoAppException:\n+            pass\n+        return super(ContextGroupMixin, self).get_command(ctx, name)\n+\n+    def list_commands(self, ctx):\n+        # The commands available is the list of both the application (if\n+        # available) plus the builtin commands.\n+        rv = set(super(ContextGroupMixin, self).list_commands(ctx))\n+        info = ctx.find_object(ScriptInfo)\n+        try:\n+            rv.update(info.load_app().cli.list_commands(ctx))\n+        except NoAppException:\n+            pass\n+        return sorted(rv)\n+\n+    def invoke_subcommand(self, ctx, cmd, cmd_name, args):\n+        with_context = cmd.callback is None or \\\n+           not getattr(cmd.callback, '__flask_without_appcontext__', False)\n+\n+        with ctx.find_object(ScriptInfo).conditional_context(with_context):\n+            return super(ContextGroupMixin, self).invoke_subcommand(\n+                ctx, cmd, cmd_name, args)\n+\n+\n+class FlaskGroup(ContextGroupMixin, click.Group):\n     \"\"\"Special subclass of the a regular click group that supports\n     loading more commands from the configured Flask app.\n     \"\"\"\n@@ -233,37 +267,6 @@ class FlaskGroup(click.Group):\n                          default=None, callback=set_debug)\n         ])\n \n-    def get_command(self, ctx, name):\n-        info = ctx.find_object(ScriptInfo)\n-        # Find the command in the application first, if we can find it.\n-        # If the app is not available, we just ignore this silently.\n-        try:\n-            rv = info.load_app().cli.get_command(ctx, name)\n-            if rv is not None:\n-                return rv\n-        except NoAppException:\n-            pass\n-        return click.Group.get_command(self, ctx, name)\n-\n-    def list_commands(self, ctx):\n-        # The commands available is the list of both the application (if\n-        # available) plus the builtin commands.\n-        rv = set(click.Group.list_commands(self, ctx))\n-        info = ctx.find_object(ScriptInfo)\n-        try:\n-            rv.update(info.load_app().cli.list_commands(ctx))\n-        except NoAppException:\n-            pass\n-        return sorted(rv)\n-\n-    def invoke_subcommand(self, ctx, cmd, cmd_name, args):\n-        with_context = cmd.callback is None or \\\n-           not getattr(cmd.callback, '__flask_without_appcontext__', False)\n-\n-        with ctx.find_object(ScriptInfo).conditional_context(with_context):\n-            return click.Group.invoke_subcommand(\n-                self, ctx, cmd, cmd_name, args)\n-\n \n cli = FlaskGroup(help='''\\\n This shell command acts as general utility script for Flask applications.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#81576c236a4dde33aeed13c84abed0ad2e796c2f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 116 | Lines Deleted: 74 | Files Changed: 1 | Hunks: 22 | Methods Changed: 21 | Complexity Δ (Sum/Max): 5/5 | Churn Δ: 190 | Churn Cumulative: 693 | Contributors (this commit): 2 | Commits (past 90d): 10 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -144,57 +144,62 @@ class ScriptInfo(object):\n     to click.\n     \"\"\"\n \n-    def __init__(self, app_import_path=None, debug=None, load_callback=None):\n+    def __init__(self, app_import_path=None, debug=None, create_app=None):\n         self.app_import_path = app_import_path\n         self.debug = debug\n-        self.load_callback = load_callback\n+        self.create_app = create_app\n         self._loaded_app = None\n \n-    def get_app_import_path(self):\n-        \"\"\"Return the actual application import path or fails if it is\n-        not yet set.\n-        \"\"\"\n-        if self.app_import_path is not None:\n-            return self.app_import_path\n-        _no_such_app()\n-\n     def load_app(self):\n-        \"\"\"Loads the app (if not yet loaded) and returns it.\"\"\"\n+        \"\"\"Loads the Flask app (if not yet loaded) and returns it.\"\"\"\n         if self._loaded_app is not None:\n             return self._loaded_app\n-        if self.load_callback is not None:\n-            rv = self.load_callback()\n+        if self.create_app is not None:\n+            rv = self.create_app(self)\n         else:\n-            rv = locate_app(self.get_app_import_path(), self.debug)\n+            if self.app_import_path is None:\n+                _no_such_app()\n+            rv = locate_app(self.app_import_path, self.debug)\n         self._loaded_app = rv\n         return rv\n \n     def make_wsgi_app(self, use_eager_loading=False):\n-        \"\"\"Returns a WSGI app that loads the actual application at a\n-        later stage.\n+        \"\"\"Returns a WSGI app that loads the actual application at a later\n+        stage (on first request).  This has the advantage over\n+        :meth:`load_app` that if used with a WSGI server, it will allow\n+        the server to intercept errors later during request handling\n+        instead of dying a horrible death.\n+\n+        If eager loading is disabled the loading will happen immediately.\n         \"\"\"\n         if self.app_import_path is not None:\n             def loader():\n                 return locate_app(self.app_import_path, self.debug)\n         else:\n-            if self.load_callback is None:\n+            if self.create_app is None:\n                 _no_such_app()\n             def loader():\n-                return self.load_callback()\n+                return self.create_app(self)\n         return DispatchingApp(loader, use_eager_loading=use_eager_loading)\n \n     @contextmanager\n     def conditional_context(self, with_context=True):\n-        \"\"\"Creates an application context or not, depending on the\n-        given parameter but always works as context manager.\n+        \"\"\"Creates an application context or not, depending on the given\n+        parameter but always works as context manager.  This is just a\n+        shortcut for a common operation.\n         \"\"\"\n         if with_context:\n-            with self.load_app().app_context() as ctx:\n+            with self.load_app(self).app_context() as ctx:\n                 yield ctx\n         else:\n             yield None\n \n \n+#: A special decorator that informs a click callback to be passed the\n+#: script info object as first argument.  This is normally not useful\n+#: unless you implement very special commands like the run command which\n+#: does not want the application to be loaded yet.  This can be combined\n+#: with the :func:`without_appcontext` decorator.\n pass_script_info = click.make_pass_decorator(ScriptInfo)\n \n \n@@ -208,10 +213,56 @@ def without_appcontext(f):\n     return f\n \n \n-class ContextGroupMixin(object):\n+class FlaskGroup(click.Group):\n+    \"\"\"Special subclass of the a regular click group that supports\n+    loading more commands from the configured Flask app.  Normally a\n+    developer does not have to interface with this class but there are\n+    some very advanced usecases for which it makes sense to create an\n+    instance of this.\n+\n+    :param add_default_options: if this is True the app and debug option\n+                                is automatically added.\n+    \"\"\"\n+\n+    def __init__(self, add_default_options=True,\n+                 add_default_commands=True,\n+                 create_app=None, **extra):\n+        click.Group.__init__(self, **extra)\n+        self.create_app = create_app\n+        if add_default_options:\n+            self.add_app_option()\n+            self.add_debug_option()\n+        if add_default_commands:\n+            self.add_command(run_command)\n+            self.add_command(shell_command)\n+\n+    def add_app_option(self):\n+        \"\"\"Adds an option to the default command that defines an import\n+        path that points to an application.\n+        \"\"\"\n+        def set_app_id(ctx, value):\n+            if value is not None:\n+                if os.path.isfile(value):\n+                    value = prepare_exec_for_file(value)\n+                elif '.' not in sys.path:\n+                    sys.path.insert(0, '.')\n+            ctx.ensure_object(ScriptInfo).app_import_path = value\n+\n+        self.params.append(click.Option(['-a', '--app'],\n+            help='The application to run',\n+            callback=set_app_id, is_eager=True))\n+\n+    def add_debug_option(self):\n+        \"\"\"Adds an option that controls the debug flag.\"\"\"\n+        def set_debug(ctx, value):\n+            ctx.ensure_object(ScriptInfo).debug = value\n+\n+        self.params.append(click.Option(['--debug/--no-debug'],\n+            help='Enable or disable debug mode.',\n+            default=None, callback=set_debug))\n \n     def get_command(self, ctx, name):\n-        info = ctx.find_object(ScriptInfo)\n+        info = ctx.ensure_object(ScriptInfo)\n         # Find the command in the application first, if we can find it.\n         # If the app is not available, we just ignore this silently.\n         try:\n@@ -220,13 +271,13 @@ class ContextGroupMixin(object):\n                 return rv\n         except NoAppException:\n             pass\n-        return super(ContextGroupMixin, self).get_command(ctx, name)\n+        return click.Group.get_command(self, ctx, name)\n \n     def list_commands(self, ctx):\n         # The commands available is the list of both the application (if\n         # available) plus the builtin commands.\n-        rv = set(super(ContextGroupMixin, self).list_commands(ctx))\n-        info = ctx.find_object(ScriptInfo)\n+        rv = set(click.Group.list_commands(self, ctx))\n+        info = ctx.ensure_object(ScriptInfo)\n         try:\n             rv.update(info.load_app().cli.list_commands(ctx))\n         except NoAppException:\n@@ -238,52 +289,19 @@ class ContextGroupMixin(object):\n            not getattr(cmd.callback, '__flask_without_appcontext__', False)\n \n         with ctx.find_object(ScriptInfo).conditional_context(with_context):\n-            return super(ContextGroupMixin, self).invoke_subcommand(\n-                ctx, cmd, cmd_name, args)\n+            return click.Group.invoke_subcommand(\n+                self, ctx, cmd, cmd_name, args)\n+\n+    def main(self, *args, **kwargs):\n+        obj = kwargs.get('obj')\n+        if obj is None:\n+            obj = ScriptInfo(create_app=self.create_app)\n+        kwargs['obj'] = obj\n+        kwargs.setdefault('auto_envvar_prefix', 'FLASK')\n+        return click.Group.main(self, *args, **kwargs)\n \n \n-class FlaskGroup(ContextGroupMixin, click.Group):\n-    \"\"\"Special subclass of the a regular click group that supports\n-    loading more commands from the configured Flask app.\n-    \"\"\"\n-\n-    def __init__(self, help=None):\n-        def set_app_id(ctx, value):\n-            if value is not None:\n-                if os.path.isfile(value):\n-                    value = prepare_exec_for_file(value)\n-                elif '.' not in sys.path:\n-                    sys.path.insert(0, '.')\n-            ctx.ensure_object(ScriptInfo).app_import_path = value\n-        def set_debug(ctx, value):\n-            ctx.ensure_object(ScriptInfo).debug = value\n-\n-        click.Group.__init__(self, help=help, params=[\n-            click.Option(['-a', '--app'],\n-                         help='The application to run',\n-                         callback=set_app_id, is_eager=True),\n-            click.Option(['--debug/--no-debug'],\n-                         help='Enable or disable debug mode.',\n-                         default=None, callback=set_debug)\n-        ])\n-\n-\n-cli = FlaskGroup(help='''\\\n-This shell command acts as general utility script for Flask applications.\n-\n-It loads the application configured (either through the FLASK_APP environment\n-variable or the --app parameter) and then provides commands either provided\n-by the application or Flask itself.\n-\n-The most useful commands are the \"run\" and \"shell\" command.\n-\n-Example usage:\n-\n-  flask --app=hello --debug run\n-''')\n-\n-\n-@cli.command('run', short_help='Runs a development server.')\n+@click.command('run', short_help='Runs a development server.')\n @click.option('--host', '-h', default='127.0.0.1',\n               help='The interface to bind to.')\n @click.option('--port', '-p', default=5000,\n@@ -303,7 +321,17 @@ Example usage:\n @pass_script_info\n def run_command(info, host, port, reload, debugger, eager_loading,\n                 with_threads):\n-    \"\"\"Runs a local development server for the Flask application.\"\"\"\n+    \"\"\"Runs a local development server for the Flask application.\n+\n+    This local server is recommended for development purposes only but it\n+    can also be used for simple intranet deployments.  By default it will\n+    not support any sort of concurrency at all to simplify debugging.  This\n+    can be changed with the --with-threads option which will enable basic\n+    multithreading.\n+\n+    The reloader and debugger are by default enabled if the debug flag of\n+    Flask is enabled and disabled otherwise.\n+    \"\"\"\n     from werkzeug.serving import run_simple\n     if reload is None:\n         reload = info.debug\n@@ -330,7 +358,7 @@ def run_command(info, host, port, reload, debugger, eager_loading,\n                use_debugger=debugger, threaded=with_threads)\n \n \n-@cli.command('shell', short_help='Runs a shell in the app context.')\n+@click.command('shell', short_help='Runs a shell in the app context.')\n def shell_command():\n     \"\"\"Runs an interactive Python shell in the context of a given\n     Flask application.  The application will populate the default\n@@ -360,6 +388,21 @@ def make_default_cli(app):\n     return click.Group()\n \n \n+cli = FlaskGroup(help='''\\\n+This shell command acts as general utility script for Flask applications.\n+\n+It loads the application configured (either through the FLASK_APP environment\n+variable or the --app parameter) and then provides commands either provided\n+by the application or Flask itself.\n+\n+The most useful commands are the \"run\" and \"shell\" command.\n+\n+Example usage:\n+\n+  flask --app=hello --debug run\n+''')\n+\n+\n def main(as_module=False):\n     this_module = __package__ + '.cli'\n     args = sys.argv[1:]\n@@ -377,8 +420,7 @@ def main(as_module=False):\n     else:\n         name = None\n \n-    cli.main(args=args, prog_name=name, obj=ScriptInfo(),\n-             auto_envvar_prefix='FLASK')\n+    cli.main(args=args, prog_name=name)\n \n \n if __name__ == '__main__':\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#44b0aeb048c1019e3cdd42fd2bdf9c2c8ffb7429", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): -5/0 | Churn Δ: 2 | Churn Cumulative: 695 | Contributors (this commit): 3 | Commits (past 90d): 11 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -290,7 +290,7 @@ Example usage:\n               help='The port to bind to.')\n @click.option('--reload/--no-reload', default=None,\n               help='Enable or disable the reloader.  By default the reloader '\n-              'is active is debug is enabled.')\n+              'is active if debug is enabled.')\n @click.option('--debugger/--no-debugger', default=None,\n               help='Enable or disable the debugger.  By default the debugger '\n               'is active if debug is enabled.')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#3569fc24415f8bac7b269ec041bd1f6bc23038ce", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 98 | Lines Deleted: 70 | Files Changed: 2 | Hunks: 22 | Methods Changed: 19 | Complexity Δ (Sum/Max): 6/6 | Churn Δ: 168 | Churn Cumulative: 1142 | Contributors (this commit): 14 | Commits (past 90d): 15 | Contributors (cumulative): 15 | DMM Complexity: 0.0\n\nDIFF:\n@@ -81,7 +81,7 @@ def prepare_exec_for_file(filename):\n     return '.'.join(module[::-1])\n \n \n-def locate_app(app_id, debug=None):\n+def locate_app(app_id):\n     \"\"\"Attempts to locate the application.\"\"\"\n     if ':' in app_id:\n         module, app_obj = app_id.split(':', 1)\n@@ -98,8 +98,7 @@ def locate_app(app_id, debug=None):\n         if app is None:\n             raise RuntimeError('Failed to find application in module \"%s\"'\n                                % module)\n-    if debug is not None:\n-        app.debug = debug\n+\n     return app\n \n \n@@ -145,13 +144,24 @@ class ScriptInfo(object):\n     \"\"\"\n \n     def __init__(self, app_import_path=None, debug=None, create_app=None):\n+        #: The application import path\n         self.app_import_path = app_import_path\n+        #: The debug flag.  If this is not None, the application will\n+        #: automatically have it's debug flag overridden with this value.\n         self.debug = debug\n+        #: Optionally a function that is passed the script info to create\n+        #: the instance of the application.\n         self.create_app = create_app\n+        #: A dictionary with arbitrary data that can be associated with\n+        #: this script info.\n+        self.data = {}\n         self._loaded_app = None\n \n     def load_app(self):\n-        \"\"\"Loads the Flask app (if not yet loaded) and returns it.\"\"\"\n+        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n+        this multiple times will just result in the already loaded app to\n+        be returned.\n+        \"\"\"\n         if self._loaded_app is not None:\n             return self._loaded_app\n         if self.create_app is not None:\n@@ -159,29 +169,12 @@ class ScriptInfo(object):\n         else:\n             if self.app_import_path is None:\n                 _no_such_app()\n-            rv = locate_app(self.app_import_path, self.debug)\n+            rv = locate_app(self.app_import_path)\n+        if self.debug is not None:\n+            rv.debug = self.debug\n         self._loaded_app = rv\n         return rv\n \n-    def make_wsgi_app(self, use_eager_loading=False):\n-        \"\"\"Returns a WSGI app that loads the actual application at a later\n-        stage (on first request).  This has the advantage over\n-        :meth:`load_app` that if used with a WSGI server, it will allow\n-        the server to intercept errors later during request handling\n-        instead of dying a horrible death.\n-\n-        If eager loading is disabled the loading will happen immediately.\n-        \"\"\"\n-        if self.app_import_path is not None:\n-            def loader():\n-                return locate_app(self.app_import_path, self.debug)\n-        else:\n-            if self.create_app is None:\n-                _no_such_app()\n-            def loader():\n-                return self.create_app(self)\n-        return DispatchingApp(loader, use_eager_loading=use_eager_loading)\n-\n     @contextmanager\n     def conditional_context(self, with_context=True):\n         \"\"\"Creates an application context or not, depending on the given\n@@ -189,17 +182,12 @@ class ScriptInfo(object):\n         shortcut for a common operation.\n         \"\"\"\n         if with_context:\n-            with self.load_app(self).app_context() as ctx:\n+            with self.load_app().app_context() as ctx:\n                 yield ctx\n         else:\n             yield None\n \n \n-#: A special decorator that informs a click callback to be passed the\n-#: script info object as first argument.  This is normally not useful\n-#: unless you implement very special commands like the run command which\n-#: does not want the application to be loaded yet.  This can be combined\n-#: with the :func:`without_appcontext` decorator.\n pass_script_info = click.make_pass_decorator(ScriptInfo)\n \n \n@@ -213,34 +201,11 @@ def without_appcontext(f):\n     return f\n \n \n-class FlaskGroup(click.Group):\n-    \"\"\"Special subclass of the a regular click group that supports\n-    loading more commands from the configured Flask app.  Normally a\n-    developer does not have to interface with this class but there are\n-    some very advanced usecases for which it makes sense to create an\n-    instance of this.\n+def set_debug_value(ctx, value):\n+    ctx.ensure_object(ScriptInfo).debug = value\n \n-    :param add_default_options: if this is True the app and debug option\n-                                is automatically added.\n-    \"\"\"\n \n-    def __init__(self, add_default_options=True,\n-                 add_default_commands=True,\n-                 create_app=None, **extra):\n-        click.Group.__init__(self, **extra)\n-        self.create_app = create_app\n-        if add_default_options:\n-            self.add_app_option()\n-            self.add_debug_option()\n-        if add_default_commands:\n-            self.add_command(run_command)\n-            self.add_command(shell_command)\n-\n-    def add_app_option(self):\n-        \"\"\"Adds an option to the default command that defines an import\n-        path that points to an application.\n-        \"\"\"\n-        def set_app_id(ctx, value):\n+def set_app_value(ctx, value):\n     if value is not None:\n         if os.path.isfile(value):\n             value = prepare_exec_for_file(value)\n@@ -248,18 +213,52 @@ class FlaskGroup(click.Group):\n             sys.path.insert(0, '.')\n     ctx.ensure_object(ScriptInfo).app_import_path = value\n \n-        self.params.append(click.Option(['-a', '--app'],\n-            help='The application to run',\n-            callback=set_app_id, is_eager=True))\n \n-    def add_debug_option(self):\n-        \"\"\"Adds an option that controls the debug flag.\"\"\"\n-        def set_debug(ctx, value):\n-            ctx.ensure_object(ScriptInfo).debug = value\n-\n-        self.params.append(click.Option(['--debug/--no-debug'],\n+debug_option = click.Option(['--debug/--no-debug'],\n     help='Enable or disable debug mode.',\n-            default=None, callback=set_debug))\n+    default=None, callback=set_debug_value)\n+\n+\n+app_option = click.Option(['-a', '--app'],\n+    help='The application to run',\n+    callback=set_app_value, is_eager=True)\n+\n+\n+class FlaskGroup(click.Group):\n+    \"\"\"Special subclass of the a regular click group that supports loading\n+    more commands from the configured Flask app.  Normally a developer\n+    does not have to interface with this class but there are some very\n+    advanced usecases for which it makes sense to create an instance of\n+    this.\n+\n+    For information as of why this is useful see :ref:`custom-scripts`.\n+\n+    :param add_default_commands: if this is True then the default run and\n+                                 shell commands wil be added.\n+    :param add_app_option: adds the default ``--app`` option.  This gets\n+                           automatically disabled if a `create_app`\n+                           callback is defined.\n+    :param add_debug_option: adds the default ``--debug`` option.\n+    :param create_app: an optional callback that is passed the script info\n+                       and returns the loaded app.\n+    \"\"\"\n+\n+    def __init__(self, add_default_commands=True, add_app_option=None,\n+                 add_debug_option=True, create_app=None, **extra):\n+        params = list(extra.pop('params', None) or ())\n+        if add_app_option is None:\n+            add_app_option = create_app is None\n+        if add_app_option:\n+            params.append(app_option)\n+        if add_debug_option:\n+            params.append(debug_option)\n+\n+        click.Group.__init__(self, params=params, **extra)\n+        self.create_app = create_app\n+\n+        if add_default_commands:\n+            self.add_command(run_command)\n+            self.add_command(shell_command)\n \n     def get_command(self, ctx, name):\n         info = ctx.ensure_object(ScriptInfo)\n@@ -301,6 +300,33 @@ class FlaskGroup(click.Group):\n         return click.Group.main(self, *args, **kwargs)\n \n \n+def script_info_option(*args, **kwargs):\n+    \"\"\"This decorator works exactly like :func:`click.option` but is eager\n+    by default and stores the value in the :attr:`ScriptInfo.data`.  This\n+    is useful to further customize an application factory in very complex\n+    situations.\n+\n+    :param script_info_key: this is a mandatory keyword argument which\n+                            defines under which data key the value should\n+                            be stored.\n+    \"\"\"\n+    try:\n+        key = kwargs.pop('script_info_key')\n+    except LookupError:\n+        raise TypeError('script_info_key not provided.')\n+\n+    real_callback = kwargs.get('callback')\n+    def callback(ctx, value):\n+        if real_callback is not None:\n+            value = real_callback(ctx, value)\n+        ctx.ensure_object(ScriptInfo).data[key] = value\n+        return value\n+\n+    kwargs['callback'] = callback\n+    kwargs.setdefault('is_eager', True)\n+    return click.option(*args, **kwargs)\n+\n+\n @click.command('run', short_help='Runs a development server.')\n @click.option('--host', '-h', default='127.0.0.1',\n               help='The interface to bind to.')\n@@ -340,7 +366,7 @@ def run_command(info, host, port, reload, debugger, eager_loading,\n     if eager_loading is None:\n         eager_loading = not reload\n \n-    app = info.make_wsgi_app(use_eager_loading=eager_loading)\n+    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n \n     # Extra startup messages.  This depends a but on Werkzeug internals to\n     # not double execute when the reloader kicks in.\n@@ -388,7 +414,9 @@ def make_default_cli(app):\n     return click.Group()\n \n \n-cli = FlaskGroup(help='''\\\n+@click.group(cls=FlaskGroup)\n+def cli(**params):\n+    \"\"\"\n     This shell command acts as general utility script for Flask applications.\n \n     It loads the application configured (either through the FLASK_APP environment\n@@ -400,7 +428,7 @@ The most useful commands are the \"run\" and \"shell\" command.\n     Example usage:\n \n       flask --app=hello --debug run\n-''')\n+    \"\"\"\n \n \n def main(as_module=False):\n\n@@ -96,7 +96,7 @@ setup(\n         'Werkzeug>=0.7',\n         'Jinja2>=2.4',\n         'itsdangerous>=0.21',\n-        'click',\n+        'click>=0.6',\n     ],\n     classifiers=[\n         'Development Status :: 4 - Beta',\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#2639a23b8875abb6c1dd2889728920cce5d09632", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 285 | Contributors (this commit): 12 | Commits (past 90d): 4 | Contributors (cumulative): 12 | DMM Complexity: None\n\nDIFF:\n@@ -8,6 +8,8 @@ intentions. And before you ask: It's BSD licensed!\n Flask is Fun\n ````````````\n \n+Save in a hello.py:\n+\n .. code:: python\n \n     from flask import Flask\n@@ -23,6 +25,8 @@ Flask is Fun\n And Easy to Setup\n `````````````````\n \n+And run it:\n+\n .. code:: bash\n \n     $ pip install Flask\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#1b77a3fb11a0819114804e4f88233b2dc215b653", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 20 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 23 | Churn Cumulative: 91 | Contributors (this commit): 3 | Commits (past 90d): 1 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -14,24 +14,41 @@ from functools import partial\n from werkzeug.local import LocalStack, LocalProxy\n \n \n+_request_ctx_err_msg = '''\\\n+Working outside of request context.\n+\n+This typically means that you attempted to use functionality that needed\n+an active HTTP request.  Consult the documentation on testing for\n+information about how to avoid this problem.\\\n+'''\n+_app_ctx_err_msg = '''\\\n+Working outside of application context.\n+\n+This typically means that you attempted to use functionality that needed\n+to interface with the current application object in a way.  To solve\n+this set up an application context with app.app_context().  See the\n+documentation for more information.\\\n+'''\n+\n+\n def _lookup_req_object(name):\n     top = _request_ctx_stack.top\n     if top is None:\n-        raise RuntimeError('working outside of request context')\n+        raise RuntimeError(_request_ctx_err_msg)\n     return getattr(top, name)\n \n \n def _lookup_app_object(name):\n     top = _app_ctx_stack.top\n     if top is None:\n-        raise RuntimeError('working outside of application context')\n+        raise RuntimeError(_app_ctx_err_msg)\n     return getattr(top, name)\n \n \n def _find_app():\n     top = _app_ctx_stack.top\n     if top is None:\n-        raise RuntimeError('working outside of application context')\n+        raise RuntimeError(_app_ctx_err_msg)\n     return top.app\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#fa6eded6f572dd4bc23b030f025156cdd1e63305", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 20 | Churn Cumulative: 881 | Contributors (this commit): 3 | Commits (past 90d): 13 | Contributors (cumulative): 3 | DMM Complexity: 1.0\n\nDIFF:\n@@ -261,16 +261,24 @@ class FlaskGroup(click.Group):\n             self.add_command(shell_command)\n \n     def get_command(self, ctx, name):\n+        # We load built-in commands first as these should always be the\n+        # same no matter what the app does.  If the app does want to\n+        # override this it needs to make a custom instance of this group\n+        # and not attach the default commands.\n+        #\n+        # This also means that the script stays functional in case the\n+        # application completely fails.\n+        rv = click.Group.get_command(self, ctx, name)\n+        if rv is not None:\n+            return rv\n+\n         info = ctx.ensure_object(ScriptInfo)\n-        # Find the command in the application first, if we can find it.\n-        # If the app is not available, we just ignore this silently.\n         try:\n             rv = info.load_app().cli.get_command(ctx, name)\n             if rv is not None:\n                 return rv\n         except NoAppException:\n             pass\n-        return click.Group.get_command(self, ctx, name)\n \n     def list_commands(self, ctx):\n         # The commands available is the list of both the application (if\n@@ -279,7 +287,11 @@ class FlaskGroup(click.Group):\n         info = ctx.ensure_object(ScriptInfo)\n         try:\n             rv.update(info.load_app().cli.list_commands(ctx))\n-        except NoAppException:\n+        except Exception:\n+            # Here we intentionally swallow all exceptions as we don't\n+            # want the help page to break if the app does not exist.\n+            # If someone attempts to use the command we try to create\n+            # the app again and this will give us the error.\n             pass\n         return sorted(rv)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
