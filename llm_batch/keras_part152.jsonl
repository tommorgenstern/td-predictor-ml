{"custom_id": "keras#3fe89b4f7b393696039dd61d4aea3f648e2c809e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 60 | Lines Deleted: 66 | Files Changed: 3 | Hunks: 46 | Methods Changed: 18 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 126 | Churn Cumulative: 19853 | Contributors (this commit): 94 | Commits (past 90d): 108 | Contributors (cumulative): 148 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1699,7 +1699,7 @@ def asymmetric_temporal_padding(x, left_pad=1, right_pad=1):\n     return tf.pad(x, pattern)\n \n \n-def spatial_2d_padding(x, padding=(1, 1), data_format='default'):\n+def spatial_2d_padding(x, padding=(1, 1), data_format=None):\n     \"\"\"Pads the 2nd and 3rd dimensions of a 4D tensor\n     with \"padding[0]\" and \"padding[1]\" (resp.) zeros left and right.\n \n@@ -1709,7 +1709,7 @@ def spatial_2d_padding(x, padding=(1, 1), data_format='default'):\n     # Raises\n         ValueError: if `data_format` is neither `channels_last` or `channels_first`.\n     \"\"\"\n-    if data_format == 'default':\n+    if data_format is None:\n         data_format = image_data_format()\n     if data_format not in {'channels_first', 'channels_last'}:\n         raise ValueError('Unknown data_format ' + str(data_format))\n@@ -1726,7 +1726,7 @@ def spatial_2d_padding(x, padding=(1, 1), data_format='default'):\n \n def asymmetric_spatial_2d_padding(x, top_pad=1, bottom_pad=1,\n                                   left_pad=1, right_pad=1,\n-                                  data_format='default'):\n+                                  data_format=None):\n     \"\"\"Pad the rows and columns of a 4D tensor\n     with \"top_pad\", \"bottom_pad\", \"left_pad\", \"right_pad\" (resp.) zeros\n     rows on top, bottom; cols on left, right.\n@@ -1737,7 +1737,7 @@ def asymmetric_spatial_2d_padding(x, top_pad=1, bottom_pad=1,\n     # Raises\n         ValueError: if `data_format` is neither `channels_last` or `channels_first`.\n     \"\"\"\n-    if data_format == 'default':\n+    if data_format is None:\n         data_format = image_data_format()\n     if data_format not in {'channels_first', 'channels_last'}:\n         raise ValueError('Unknown data_format ' + str(data_format))\n@@ -1755,7 +1755,7 @@ def asymmetric_spatial_2d_padding(x, top_pad=1, bottom_pad=1,\n     return tf.pad(x, pattern)\n \n \n-def spatial_3d_padding(x, padding=(1, 1, 1), data_format='default'):\n+def spatial_3d_padding(x, padding=((1, 1), (1, 1), (1, 1)), data_format=None):\n     \"\"\"Pads 5D tensor with zeros for the depth, height, width dimension with\n     \"padding[0]\", \"padding[1]\" and \"padding[2]\" (resp.) zeros left and right\n \n@@ -1769,7 +1769,7 @@ def spatial_3d_padding(x, padding=(1, 1, 1), data_format='default'):\n         ValueError: if `data_format` is neither `channels_last` or `channels_first`.\n \n     \"\"\"\n-    if data_format == 'default':\n+    if data_format is None:\n         data_format = image_data_format()\n     if data_format not in {'channels_first', 'channels_last'}:\n         raise ValueError('Unknown data_format ' + str(data_format))\n@@ -1778,16 +1778,16 @@ def spatial_3d_padding(x, padding=(1, 1, 1), data_format='default'):\n         pattern = [\n             [0, 0],\n             [0, 0],\n-            [padding[0], padding[0]],\n-            [padding[1], padding[1]],\n-            [padding[2], padding[2]]\n+            [padding[0][0], padding[0][1]],\n+            [padding[1][0], padding[1][1]],\n+            [padding[2][0], padding[2][1]]\n         ]\n     else:\n         pattern = [\n             [0, 0],\n-            [padding[0], padding[0]],\n-            [padding[1], padding[1]],\n-            [padding[2], padding[2]],\n+            [padding[0][0], padding[0][1]],\n+            [padding[1][0], padding[1][1]],\n+            [padding[2][0], padding[2][1]],\n             [0, 0]\n         ]\n     return tf.pad(x, pattern)\n@@ -2719,19 +2719,19 @@ def conv2d(x, kernel, strides=(1, 1), padding='valid',\n     if data_format not in {'channels_first', 'channels_last'}:\n         raise ValueError('Unknown data_format ' + str(data_format))\n \n+    # With 4d inputs, tf.nn.convolution only supports\n+    # data_format NHWC, so we transpose the inputs\n+    # in case we are in data_format channels_first.\n+    x = _preprocess_conv2d_input(x, data_format)\n     padding = _preprocess_padding(padding)\n-    if data_format == 'channels_last':\n-        tf_data_format = 'NHWC'\n-    else:\n-        tf_data_format = 'NCHW'\n     x = tf.nn.convolution(\n         input=x,\n         filter=kernel,\n         dilation_rate=dilation_rate,\n         strides=strides,\n         padding=padding,\n-        data_format=tf_data_format)\n-    return x\n+        data_format='NHWC')\n+    return _postprocess_conv2d_output(x, data_format)\n \n \n def conv2d_transpose(x, kernel, output_shape, strides=(1, 1),\n@@ -2761,8 +2761,6 @@ def conv2d_transpose(x, kernel, output_shape, strides=(1, 1),\n \n     x = _preprocess_conv2d_input(x, data_format)\n     output_shape = _preprocess_deconv_output_shape(x, output_shape, data_format)\n-    kernel = _preprocess_conv2d_kernel(kernel, data_format)\n-    kernel = tf.transpose(kernel, (0, 1, 3, 2))\n     padding = _preprocess_padding(padding)\n     strides = (1,) + strides + (1,)\n \n@@ -2789,10 +2787,6 @@ def separable_conv2d(x, depthwise_kernel, pointwise_kernel, strides=(1, 1),\n         raise ValueError('Unknown data_format ' + str(data_format))\n \n     x = _preprocess_conv2d_input(x, data_format)\n-    depthwise_kernel = _preprocess_conv2d_kernel(depthwise_kernel,\n-                                                 data_format)\n-    pointwise_kernel = _preprocess_conv2d_kernel(pointwise_kernel,\n-                                                 data_format)\n     padding = _preprocess_padding(padding)\n     strides = (1,) + strides + (1,)\n \n@@ -2829,7 +2823,7 @@ def conv3d(x, kernel, strides=(1, 1, 1), padding='valid',\n         raise ValueError('Unknown data_format ' + str(data_format))\n \n     # With 5d inputs, tf.nn.convolution only supports\n-    # data_format NCHW, so we transpose the inputs\n+    # data_format NDHWC, so we transpose the inputs\n     # in case we are in data_format channels_first.\n     x = _preprocess_conv3d_input(x, data_format)\n     padding = _preprocess_padding(padding)\n\n@@ -802,12 +802,12 @@ def asymmetric_temporal_padding(x, left_pad=1, right_pad=1):\n     return T.set_subtensor(output[:, left_pad:x.shape[1] + left_pad, :], x)\n \n \n-def spatial_2d_padding(x, padding=(1, 1), data_format='default'):\n+def spatial_2d_padding(x, padding=(1, 1), data_format=None):\n     \"\"\"Pad the 2nd and 3rd dimensions of a 4D tensor\n     with \"padding[0]\" and \"padding[1]\" (resp.) zeros left and right.\n     \"\"\"\n     # TODO: `keras_shape` inference.\n-    if data_format == 'default':\n+    if data_format is None:\n         data_format = image_data_format()\n     if data_format not in {'channels_first', 'channels_last'}:\n         raise ValueError('Unknown data_format ' + str(data_format))\n@@ -841,12 +841,12 @@ def spatial_2d_padding(x, padding=(1, 1), data_format='default'):\n \n def asymmetric_spatial_2d_padding(x, top_pad=1, bottom_pad=1,\n                                   left_pad=1, right_pad=1,\n-                                  data_format='default'):\n+                                  data_format=None):\n     \"\"\"Pad the rows and columns of a 4D tensor\n     with \"top_pad\", \"bottom_pad\", \"left_pad\", \"right_pad\" (resp.) zeros\n     rows on top, bottom; cols on left, right.\n     \"\"\"\n-    if data_format == 'default':\n+    if data_format is None:\n         data_format = image_data_format()\n     if data_format not in {'channels_first', 'channels_last'}:\n         raise ValueError('Unknown data_format ' + str(data_format))\n@@ -879,11 +879,11 @@ def asymmetric_spatial_2d_padding(x, top_pad=1, bottom_pad=1,\n     return T.set_subtensor(output[indices], x)\n \n \n-def spatial_3d_padding(x, padding=(1, 1, 1), data_format='default'):\n+def spatial_3d_padding(x, padding=(1, 1, 1), data_format=None):\n     \"\"\"Pad the 2nd, 3rd and 4th dimensions of a 5D tensor\n     with \"padding[0]\", \"padding[1]\" and \"padding[2]\" (resp.) zeros left and right.\n     \"\"\"\n-    if data_format == 'default':\n+    if data_format is None:\n         data_format = image_data_format()\n     if data_format not in {'channels_first', 'channels_last'}:\n         raise ValueError('Unknown data_format ' + str(data_format))\n\n@@ -745,17 +745,15 @@ class Conv2DTranspose(Conv2D):\n                                              self.padding)\n         if self.data_format == 'channels_first':\n             output_shape = (batch_size, self.filters, out_height, out_width)\n-            strides = (1, 1, stride_h, stride_w)\n         else:\n             output_shape = (batch_size, out_height, out_width, self.filters)\n-            strides = (1, stride_h, stride_w, 1)\n \n         output_shape_tensor = K.stack(output_shape)\n         outputs = K.conv2d_transpose(\n             inputs,\n             self.kernel,\n             output_shape_tensor,\n-            strides,\n+            self.strides,\n             padding=self.padding,\n             data_format=self.data_format)\n \n@@ -770,7 +768,7 @@ class Conv2DTranspose(Conv2D):\n         return outputs\n \n     def get_output_shape_for(self, input_shape):\n-        output_shape = copy.copy(input_shape)\n+        output_shape = list(input_shape)\n         if self.data_format == 'channels_first':\n             c_axis, h_axis, w_axis = 1, 2, 3\n         else:\n@@ -785,12 +783,11 @@ class Conv2DTranspose(Conv2D):\n             output_shape[h_axis], stride_h, kernel_h, self.padding)\n         output_shape[w_axis] = conv_utils.deconv_length(\n             output_shape[w_axis], stride_w, kernel_w, self.padding)\n-        return output_shape\n+        return tuple(output_shape)\n \n     def get_config(self):\n         config = super(Conv2DTranspose, self).get_config()\n-        config.pop('rank')\n-        config.pop('dilate_rate')\n+        config.pop('dilation_rate')\n         return config\n \n \n@@ -890,7 +887,7 @@ class SeparableConv2D(Conv2D):\n                  kernel_size,\n                  strides=(1, 1),\n                  padding='valid',\n-                 data_format='channels_last',\n+                 data_format=None,\n                  dilation_rate=(1, 1),\n                  depth_multiplier=1,\n                  activation=None,\n@@ -920,12 +917,12 @@ class SeparableConv2D(Conv2D):\n             bias_constraint=bias_constraint,\n             **kwargs)\n         self.depth_multiplier = depth_multiplier\n-        self.depthwise_initializer = depthwise_initializer\n-        self.pointwise_initializer = pointwise_initializer\n-        self.depthwise_regularizer = depthwise_regularizer\n-        self.pointwise_constraint = pointwise_constraint\n-        self.depthwise_constraint = depthwise_constraint\n-        self.pointwise_constraint = pointwise_constraint\n+        self.depthwise_initializer = initializers.get(depthwise_initializer)\n+        self.pointwise_initializer = initializers.get(pointwise_initializer)\n+        self.depthwise_regularizer = regularizers.get(depthwise_regularizer)\n+        self.pointwise_regularizer = regularizers.get(pointwise_constraint)\n+        self.depthwise_constraint = constraints.get(depthwise_constraint)\n+        self.pointwise_constraint = constraints.get(pointwise_constraint)\n \n     def build(self, input_shape):\n         if len(input_shape) < 4:\n@@ -978,7 +975,7 @@ class SeparableConv2D(Conv2D):\n             data_format=self.data_format,\n             strides=self.strides,\n             padding=self.padding,\n-            rate=self.dilation_rate)\n+            dilation_rate=self.dilation_rate)\n \n         if self.bias:\n             outputs = K.bias_add(\n@@ -998,11 +995,11 @@ class SeparableConv2D(Conv2D):\n             rows = input_shape[1]\n             cols = input_shape[2]\n \n-        rows = conv_utils.conv_output_length(rows, self.nb_row,\n+        rows = conv_utils.conv_output_length(rows, self.kernel_size[0],\n                                              self.padding,\n                                              self.strides[0],\n                                              dilation=self.dilation_rate[0])\n-        cols = conv_utils.conv_output_length(cols, self.nb_col,\n+        cols = conv_utils.conv_output_length(cols, self.kernel_size[1],\n                                              self.padding,\n                                              self.strides[1],\n                                              dilation=self.dilation_rate[1])\n@@ -1050,7 +1047,7 @@ class UpSampling1D(Layer):\n         size = self.size * input_shape[1] if input_shape[1] is not None else None\n         return (input_shape[0], size, input_shape[2])\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         output = K.repeat_elements(x, self.size, axis=1)\n         return output\n \n@@ -1067,7 +1064,8 @@ class UpSampling2D(Layer):\n     by size[0] and size[1] respectively.\n \n     # Arguments\n-        size: int, or tuple of 2 integers. The upsampling factors for rows and columns.\n+        size: int, or tuple of 2 integers.\n+            The upsampling factors for rows and columns.\n         data_format: 'channels_first' or 'channels_last'.\n             In 'channels_first' mode, the channels dimension (the depth)\n             is at index 1, in 'channels_last' mode is it at index 3.\n@@ -1090,10 +1088,10 @@ class UpSampling2D(Layer):\n             `(batch, channels, upsampled_rows, upsampled_cols)`\n     \"\"\"\n \n-    def __init__(self, size=(2, 2), data_format='default', **kwargs):\n+    def __init__(self, size=(2, 2), data_format=None, **kwargs):\n         super(UpSampling2D, self).__init__(**kwargs)\n         self.data_format = conv_utils.normalize_data_format(data_format)\n-        self.data_format = data_format\n+        self.size = conv_utils.normalize_tuple(size, 2, 'size')\n         self.input_spec = [InputSpec(ndim=4)]\n \n     def get_output_shape_for(self, input_shape):\n@@ -1112,7 +1110,7 @@ class UpSampling2D(Layer):\n                     height,\n                     input_shape[3])\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         return K.resize_images(x, self.size[0], self.size[1],\n                                self.data_format)\n \n@@ -1155,6 +1153,7 @@ class UpSampling3D(Layer):\n \n     def __init__(self, size=(2, 2, 2), data_format=None, **kwargs):\n         self.data_format = conv_utils.normalize_data_format(data_format)\n+        self.size = conv_utils.normalize_tuple(size, 3, 'size')\n         self.input_spec = [InputSpec(ndim=5)]\n         super(UpSampling3D, self).__init__(**kwargs)\n \n@@ -1180,7 +1179,7 @@ class UpSampling3D(Layer):\n         else:\n             raise ValueError('Invalid data_format:', self.data_format)\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         return K.resize_volumes(x, self.size[0], self.size[1], self.size[2],\n                                 self.data_format)\n \n@@ -1222,8 +1221,9 @@ class ZeroPadding1D(Layer):\n                 length,\n                 input_shape[2])\n \n-    def call(self, x, mask=None):\n-        return K.asymmetric_temporal_padding(x, left_pad=self.left_pad, right_pad=self.right_pad)\n+    def call(self, x):\n+        return K.asymmetric_temporal_padding(\n+            x, left_pad=self.left_pad, right_pad=self.right_pad)\n \n     def get_config(self):\n         config = {'padding': self.padding}\n@@ -1278,7 +1278,7 @@ class ZeroPadding2D(Layer):\n         self.data_format = conv_utils.normalize_data_format(data_format)\n         if isinstance(padding, int):\n             self.padding = ((padding, padding), (padding, padding))\n-        if hasattr(padding, '__len__'):\n+        elif hasattr(padding, '__len__'):\n             if len(padding) != 2:\n                 raise ValueError('TODO')\n             height_padding = conv_utils.normalize_tuple(padding[0], 2,\n@@ -1313,12 +1313,12 @@ class ZeroPadding2D(Layer):\n         else:\n             raise ValueError('Invalid data_format:', self.data_format)\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         return K.asymmetric_spatial_2d_padding(x,\n-                                               top_pad=self.top_pad,\n-                                               bottom_pad=self.bottom_pad,\n-                                               left_pad=self.left_pad,\n-                                               right_pad=self.right_pad,\n+                                               top_pad=self.padding[0][0],\n+                                               bottom_pad=self.padding[0][1],\n+                                               left_pad=self.padding[1][0],\n+                                               right_pad=self.padding[1][1],\n                                                data_format=self.data_format)\n \n     def get_config(self):\n@@ -1368,7 +1368,7 @@ class ZeroPadding3D(Layer):\n         self.data_format = conv_utils.normalize_data_format(data_format)\n         if isinstance(padding, int):\n             self.padding = ((padding, padding), (padding, padding), (padding, padding))\n-        if hasattr(padding, '__len__'):\n+        elif hasattr(padding, '__len__'):\n             if len(padding) != 3:\n                 raise ValueError('TODO')\n             dim1_padding = conv_utils.normalize_tuple(padding[0], 2,\n@@ -1411,7 +1411,7 @@ class ZeroPadding3D(Layer):\n         else:\n             raise ValueError('Invalid data_format:', self.data_format)\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         return K.spatial_3d_padding(x, padding=self.padding,\n                                     data_format=self.data_format)\n \n@@ -1527,7 +1527,7 @@ class Cropping2D(Layer):\n         self.data_format = conv_utils.normalize_data_format(data_format)\n         if isinstance(cropping, int):\n             self.cropping = ((cropping, cropping), (cropping, cropping))\n-        if hasattr(cropping, '__len__'):\n+        elif hasattr(cropping, '__len__'):\n             if len(cropping) != 2:\n                 raise ValueError('TODO')\n             height_cropping = conv_utils.normalize_tuple(\n@@ -1652,7 +1652,7 @@ class Cropping3D(Layer):\n             self.cropping = ((cropping, cropping),\n                              (cropping, cropping),\n                              (cropping, cropping))\n-        if hasattr(cropping, '__len__'):\n+        elif hasattr(cropping, '__len__'):\n             if len(cropping) != 3:\n                 raise ValueError('TODO')\n             dim1_cropping = conv_utils.normalize_tuple(cropping[0], 2,\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#6710396acaf62b40ba01fadd9d488d6641995d83", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 300 | Lines Deleted: 226 | Files Changed: 2 | Hunks: 114 | Methods Changed: 12 | Complexity Δ (Sum/Max): -3/0 | Churn Δ: 526 | Churn Cumulative: 10723 | Contributors (this commit): 37 | Commits (past 90d): 28 | Contributors (cumulative): 39 | DMM Complexity: 0.0\n\nDIFF:\n@@ -365,7 +365,8 @@ class Conv2D(_Conv):\n             The ordering of the dimensions in the inputs.\n             `channels_last` corresponds to inputs with shape\n             `(batch, width, height, channels)` while `channels_first`\n-            corresponds to inputs with shape `(batch, channels, width, height)`.\n+            corresponds to inputs with shape\n+            `(batch, channels, width, height)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n@@ -612,7 +613,8 @@ class Conv2DTranspose(Conv2D):\n             The ordering of the dimensions in the inputs.\n             `channels_last` corresponds to inputs with shape\n             `(batch, width, height, channels)` while `channels_first`\n-            corresponds to inputs with shape `(batch, channels, width, height)`.\n+            corresponds to inputs with shape\n+            `(batch, channels, width, height)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n@@ -824,7 +826,8 @@ class SeparableConv2D(Conv2D):\n             The ordering of the dimensions in the inputs.\n             `channels_last` corresponds to inputs with shape\n             `(batch, width, height, channels)` while `channels_first`\n-            corresponds to inputs with shape `(batch, channels, width, height)`.\n+            corresponds to inputs with shape\n+            `(batch, channels, width, height)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n@@ -1066,9 +1069,13 @@ class UpSampling2D(Layer):\n     # Arguments\n         size: int, or tuple of 2 integers.\n             The upsampling factors for rows and columns.\n-        data_format: 'channels_first' or 'channels_last'.\n-            In 'channels_first' mode, the channels dimension (the depth)\n-            is at index 1, in 'channels_last' mode is it at index 3.\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, width, height, channels)` while `channels_first`\n+            corresponds to inputs with shape\n+            `(batch, channels, width, height)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n@@ -1129,9 +1136,13 @@ class UpSampling3D(Layer):\n     # Arguments\n         size: int, or tuple of 3 integers.\n             The upsampling factors for dim1, dim2 and dim3.\n-        data_format: 'channels_first' or 'channels_last'.\n-            In 'channels_first' mode, the channels dimension (the depth)\n-            is at index 1, in 'channels_last' mode is it at index 4.\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n+            while `channels_first` corresponds to inputs with shape\n+            `(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n@@ -1248,9 +1259,13 @@ class ZeroPadding2D(Layer):\n             - If tuple of 2 tuples of 2 ints:\n                 interpreted as\n                 `((top_pad, bottom_pad), (left_pad, right_pad))`\n-        data_format: 'channels_first' or 'channels_last'.\n-            In 'channels_first' mode, the channels dimension (the depth)\n-            is at index 1, in 'channels_last' mode is it at index 3.\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, width, height, channels)` while `channels_first`\n+            corresponds to inputs with shape\n+            `(batch, channels, width, height)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n@@ -1341,9 +1356,13 @@ class ZeroPadding3D(Layer):\n             - If tuple of 2 tuples of 2 ints:\n                 interpreted as\n                 `((left_dim1_pad, right_dim1_pad), (left_dim2_pad, right_dim2_pad), (left_dim3_pad, right_dim3_pad))`\n-        data_format: 'channels_first' or 'channels_last'.\n-            In 'channels_first' mode, the channels dimension (the depth)\n-            is at index 1, in 'channels_last' mode is it at index 4.\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n+            while `channels_first` corresponds to inputs with shape\n+            `(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n@@ -1486,9 +1505,13 @@ class Cropping2D(Layer):\n             - If tuple of 2 tuples of 2 ints:\n                 interpreted as\n                 `((top_crop, bottom_crop), (left_crop, right_crop))`\n-        data_format: 'channels_first' or 'channels_last'.\n-            In 'channels_first' mode, the channels dimension (the depth)\n-            is at index 1, in 'channels_last' mode is it at index 3.\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, width, height, channels)` while `channels_first`\n+            corresponds to inputs with shape\n+            `(batch, channels, width, height)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n@@ -1622,9 +1645,13 @@ class Cropping3D(Layer):\n             - If tuple of 2 tuples of 2 ints:\n                 interpreted as\n                 `((left_dim1_crop, right_dim1_crop), (left_dim2_crop, right_dim2_crop), (left_dim3_crop, right_dim3_crop))`\n-        data_format: 'channels_first' or 'channels_last'.\n-            In 'channels_first' mode, the channels dimension (the depth)\n-            is at index 1, in 'channels_last' mode is it at index 4.\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n+            while `channels_first` corresponds to inputs with shape\n+            `(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n\n@@ -4,48 +4,44 @@ from __future__ import absolute_import\n from .. import backend as K\n from ..engine import Layer\n from ..engine import InputSpec\n-from ..utils.conv_utils import conv_output_length\n+from ..utils import conv_utils\n \n \n class _Pooling1D(Layer):\n     \"\"\"Abstract class for different pooling 1D layers.\n     \"\"\"\n \n-    def __init__(self, pool_length=2, stride=None,\n-                 border_mode='valid', **kwargs):\n+    def __init__(self, pool_size=2, strides=None,\n+                 padding='valid', **kwargs):\n         super(_Pooling1D, self).__init__(**kwargs)\n-        if stride is None:\n-            stride = pool_length\n-        self.pool_length = pool_length\n-        self.stride = stride\n-        self.st = (self.stride, 1)\n-        self.pool_size = (pool_length, 1)\n-        if border_mode not in {'valid', 'same'}:\n-            raise ValueError('`border_mode` must be in {valid, same}.')\n-        self.border_mode = border_mode\n+        if strides is None:\n+            strides = pool_size\n+        self.pool_size = conv_utils.normalize_tuple(pool_size, 1, 'pool_size')\n+        self.strides = conv_utils.normalize_tuple(strides, 1, 'strides')\n+        self.padding = conv_utils.normalize_padding(padding)\n         self.input_spec = [InputSpec(ndim=3)]\n \n     def get_output_shape_for(self, input_shape):\n-        length = conv_output_length(input_shape[1], self.pool_length,\n-                                    self.border_mode, self.stride)\n+        length = conv_utils.conv_output_length(input_shape[1], self.pool_size,\n+                                               self.padding, self.strides)\n         return (input_shape[0], length, input_shape[2])\n \n     def _pooling_function(self, inputs, pool_size, strides,\n-                          border_mode, data_format):\n+                          padding, data_format):\n         raise NotImplementedError\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         x = K.expand_dims(x, 2)   # add dummy last dimension\n         output = self._pooling_function(inputs=x, pool_size=self.pool_size,\n                                         strides=self.st,\n-                                        border_mode=self.border_mode,\n+                                        padding=self.padding,\n                                         data_format='channels_last')\n         return K.squeeze(output, 2)  # remove dummy last dimension\n \n     def get_config(self):\n-        config = {'stride': self.stride,\n-                  'pool_length': self.pool_length,\n-                  'border_mode': self.border_mode}\n+        config = {'strides': self.strides,\n+                  'pool_size': self.pool_size,\n+                  'padding': self.padding}\n         base_config = super(_Pooling1D, self).get_config()\n         return dict(list(base_config.items()) + list(config.items()))\n \n@@ -53,29 +49,29 @@ class _Pooling1D(Layer):\n class MaxPooling1D(_Pooling1D):\n     \"\"\"Max pooling operation for temporal data.\n \n+    # Arguments\n+        pool_size: Integer, size of the max pooling windows.\n+        strides: Integer, or None. Factor by which to downscale.\n+            E.g. 2 will halve the input.\n+            If None, it will default to `pool_size`.\n+        padding: One of `\"valid\"` or `\"same\"` (case-insensitive).\n+\n     # Input shape\n-        3D tensor with shape: `(samples, steps, features)`.\n+        3D tensor with shape: `(batch_size, steps, features)`.\n \n     # Output shape\n-        3D tensor with shape: `(samples, downsampled_steps, features)`.\n-\n-    # Arguments\n-        pool_length: size of the region to which max pooling is applied\n-        stride: integer, or None. factor by which to downscale.\n-            2 will halve the input.\n-            If None, it will default to `pool_length`.\n-        border_mode: 'valid' or 'same'.\n+        3D tensor with shape: `(batch_size, downsampled_steps, features)`.\n     \"\"\"\n \n-    def __init__(self, pool_length=2, stride=None,\n-                 border_mode='valid', **kwargs):\n-        super(MaxPooling1D, self).__init__(pool_length, stride,\n-                                           border_mode, **kwargs)\n+    def __init__(self, pool_size=2, strides=None,\n+                 padding='valid', **kwargs):\n+        super(MaxPooling1D, self).__init__(pool_size, strides,\n+                                           padding, **kwargs)\n \n     def _pooling_function(self, inputs, pool_size, strides,\n-                          border_mode, data_format):\n+                          padding, data_format):\n         output = K.pool2d(inputs, pool_size, strides,\n-                          border_mode, data_format, pool_mode='max')\n+                          padding, data_format, pool_mode='max')\n         return output\n \n \n@@ -83,27 +79,28 @@ class AveragePooling1D(_Pooling1D):\n     \"\"\"Average pooling for temporal data.\n \n     # Arguments\n-        pool_length: factor by which to downscale. 2 will halve the input.\n-        stride: integer, or None. Stride value.\n-            If None, it will default to `pool_length`.\n-        border_mode: 'valid' or 'same'.\n+        pool_size: Integer, size of the max pooling windows.\n+        strides: Integer, or None. Factor by which to downscale.\n+            E.g. 2 will halve the input.\n+            If None, it will default to `pool_size`.\n+        padding: One of `\"valid\"` or `\"same\"` (case-insensitive).\n \n     # Input shape\n-        3D tensor with shape: `(samples, steps, features)`.\n+        3D tensor with shape: `(batch_size, steps, features)`.\n \n     # Output shape\n-        3D tensor with shape: `(samples, downsampled_steps, features)`.\n+        3D tensor with shape: `(batch_size, downsampled_steps, features)`.\n     \"\"\"\n \n-    def __init__(self, pool_length=2, stride=None,\n-                 border_mode='valid', **kwargs):\n-        super(AveragePooling1D, self).__init__(pool_length, stride,\n-                                               border_mode, **kwargs)\n+    def __init__(self, pool_size=2, strides=None,\n+                 padding='valid', **kwargs):\n+        super(AveragePooling1D, self).__init__(pool_size, strides,\n+                                               padding, **kwargs)\n \n     def _pooling_function(self, inputs, pool_size, strides,\n-                          border_mode, data_format):\n+                          padding, data_format):\n         output = K.pool2d(inputs, pool_size, strides,\n-                          border_mode, data_format, pool_mode='avg')\n+                          padding, data_format, pool_mode='avg')\n         return output\n \n \n@@ -111,21 +108,16 @@ class _Pooling2D(Layer):\n     \"\"\"Abstract class for different pooling 2D layers.\n     \"\"\"\n \n-    def __init__(self, pool_size=(2, 2), strides=None, border_mode='valid',\n-                 data_format='default', **kwargs):\n+    def __init__(self, pool_size=(2, 2), strides=None, padding='valid',\n+                 data_format=None, **kwargs):\n         super(_Pooling2D, self).__init__(**kwargs)\n-        if data_format == 'default':\n-            data_format = K.image_data_format()\n-        self.pool_size = tuple(pool_size)\n+        data_format = conv_utils.normalize_data_format(data_format)\n         if strides is None:\n-            strides = self.pool_size\n-        self.strides = tuple(strides)\n-        if border_mode not in {'valid', 'same'}:\n-            raise ValueError('`border_mode` must be in {valid, same}.')\n-        self.border_mode = border_mode\n-        if data_format not in {'channels_last', 'channels_first'}:\n-            raise ValueError('`data_format` must be in {\"channels_last\", \"channels_first\"}.')\n-        self.data_format = data_format\n+            strides = pool_size\n+        self.pool_size = conv_utils.normalize_tuple(pool_size, 2, 'pool_size')\n+        self.strides = conv_utils.normalize_tuple(pool_size, 2, 'strides')\n+        self.padding = conv_utils.normalize_padding(padding)\n+        self.data_format = conv_utils.normalize_data_format(data_format)\n         self.input_spec = [InputSpec(ndim=4)]\n \n     def get_output_shape_for(self, input_shape):\n@@ -135,34 +127,30 @@ class _Pooling2D(Layer):\n         elif self.data_format == 'channels_last':\n             rows = input_shape[1]\n             cols = input_shape[2]\n-        else:\n-            raise ValueError('Invalid data_format:', self.data_format)\n-\n-        rows = conv_output_length(rows, self.pool_size[0],\n-                                  self.border_mode, self.strides[0])\n-        cols = conv_output_length(cols, self.pool_size[1],\n-                                  self.border_mode, self.strides[1])\n-\n+        rows = conv_utils.conv_output_length(rows, self.pool_size[0],\n+                                             self.padding, self.strides[0])\n+        cols = conv_utils.conv_output_length(cols, self.pool_size[1],\n+                                             self.padding, self.strides[1])\n         if self.data_format == 'channels_first':\n             return (input_shape[0], input_shape[1], rows, cols)\n         elif self.data_format == 'channels_last':\n             return (input_shape[0], rows, cols, input_shape[3])\n \n     def _pooling_function(self, inputs, pool_size, strides,\n-                          border_mode, data_format):\n+                          padding, data_format):\n         raise NotImplementedError\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         output = self._pooling_function(inputs=x,\n                                         pool_size=self.pool_size,\n                                         strides=self.strides,\n-                                        border_mode=self.border_mode,\n+                                        padding=self.padding,\n                                         data_format=self.data_format)\n         return output\n \n     def get_config(self):\n         config = {'pool_size': self.pool_size,\n-                  'border_mode': self.border_mode,\n+                  'padding': self.padding,\n                   'strides': self.strides,\n                   'data_format': self.data_format}\n         base_config = super(_Pooling2D, self).get_config()\n@@ -173,40 +161,52 @@ class MaxPooling2D(_Pooling2D):\n     \"\"\"Max pooling operation for spatial data.\n \n     # Arguments\n-        pool_size: tuple of 2 integers,\n+        pool_size: integer or tuple of 2 integers,\n             factors by which to downscale (vertical, horizontal).\n-            (2, 2) will halve the image in each dimension.\n-        strides: tuple of 2 integers, or None. Strides values.\n+            (2, 2) will halve the input in both spatial dimension.\n+            If only one integer is specified, the same window length\n+            will be used for both dimensions.\n+        strides: Integer, tuple of 2 integers, or None.\n+            Strides values.\n             If None, it will default to `pool_size`.\n-        border_mode: 'valid' or 'same'.\n-        data_format: 'channels_first' or 'channels_last'. In 'channels_first' mode, the channels dimension\n-            (the depth) is at index 1, in 'channels_last' mode is it at index 3.\n+        padding: One of `\"valid\"` or `\"same\"` (case-insensitive).\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, width, height, channels)` while `channels_first`\n+            corresponds to inputs with shape\n+            `(batch, channels, width, height)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n \n     # Input shape\n+        - If `data_format='channels_last'`:\n             4D tensor with shape:\n-        `(samples, channels, rows, cols)` if data_format='channels_first'\n-        or 4D tensor with shape:\n-        `(samples, rows, cols, channels)` if data_format='channels_last'.\n+            `(batch_size, rows, cols, channels)`\n+        - If `data_format='channels_first'`:\n+            4D tensor with shape:\n+            `(batch_size, channels, rows, cols)`\n \n     # Output shape\n+        - If `data_format='channels_last'`:\n             4D tensor with shape:\n-        `(nb_samples, channels, pooled_rows, pooled_cols)` if data_format='channels_first'\n-        or 4D tensor with shape:\n-        `(samples, pooled_rows, pooled_cols, channels)` if data_format='channels_last'.\n+            `(batch_size, pooled_rows, pooled_cols, channels)`\n+        - If `data_format='channels_first'`:\n+            4D tensor with shape:\n+            `(batch_size, channels, pooled_rows, pooled_cols)`\n     \"\"\"\n \n-    def __init__(self, pool_size=(2, 2), strides=None, border_mode='valid',\n-                 data_format='default', **kwargs):\n-        super(MaxPooling2D, self).__init__(pool_size, strides, border_mode,\n+    def __init__(self, pool_size=(2, 2), strides=None, padding='valid',\n+                 data_format=None, **kwargs):\n+        super(MaxPooling2D, self).__init__(pool_size, strides, padding,\n                                            data_format, **kwargs)\n \n     def _pooling_function(self, inputs, pool_size, strides,\n-                          border_mode, data_format):\n+                          padding, data_format):\n         output = K.pool2d(inputs, pool_size, strides,\n-                          border_mode, data_format,\n+                          padding, data_format,\n                           pool_mode='max')\n         return output\n \n@@ -215,40 +215,52 @@ class AveragePooling2D(_Pooling2D):\n     \"\"\"Average pooling operation for spatial data.\n \n     # Arguments\n-        pool_size: tuple of 2 integers,\n+        pool_size: integer or tuple of 2 integers,\n             factors by which to downscale (vertical, horizontal).\n-            (2, 2) will halve the image in each dimension.\n-        strides: tuple of 2 integers, or None. Strides values.\n+            (2, 2) will halve the input in both spatial dimension.\n+            If only one integer is specified, the same window length\n+            will be used for both dimensions.\n+        strides: Integer, tuple of 2 integers, or None.\n+            Strides values.\n             If None, it will default to `pool_size`.\n-        border_mode: 'valid' or 'same'.\n-        data_format: 'channels_first' or 'channels_last'. In 'channels_first' mode, the channels dimension\n-            (the depth) is at index 1, in 'channels_last' mode is it at index 3.\n+        padding: One of `\"valid\"` or `\"same\"` (case-insensitive).\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, width, height, channels)` while `channels_first`\n+            corresponds to inputs with shape\n+            `(batch, channels, width, height)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n \n     # Input shape\n+        - If `data_format='channels_last'`:\n             4D tensor with shape:\n-        `(samples, channels, rows, cols)` if data_format='channels_first'\n-        or 4D tensor with shape:\n-        `(samples, rows, cols, channels)` if data_format='channels_last'.\n+            `(batch_size, rows, cols, channels)`\n+        - If `data_format='channels_first'`:\n+            4D tensor with shape:\n+            `(batch_size, channels, rows, cols)`\n \n     # Output shape\n+        - If `data_format='channels_last'`:\n             4D tensor with shape:\n-        `(nb_samples, channels, pooled_rows, pooled_cols)` if data_format='channels_first'\n-        or 4D tensor with shape:\n-        `(samples, pooled_rows, pooled_cols, channels)` if data_format='channels_last'.\n+            `(batch_size, pooled_rows, pooled_cols, channels)`\n+        - If `data_format='channels_first'`:\n+            4D tensor with shape:\n+            `(batch_size, channels, pooled_rows, pooled_cols)`\n     \"\"\"\n \n-    def __init__(self, pool_size=(2, 2), strides=None, border_mode='valid',\n-                 data_format='default', **kwargs):\n-        super(AveragePooling2D, self).__init__(pool_size, strides, border_mode,\n+    def __init__(self, pool_size=(2, 2), strides=None, padding='valid',\n+                 data_format=None, **kwargs):\n+        super(AveragePooling2D, self).__init__(pool_size, strides, padding,\n                                                data_format, **kwargs)\n \n     def _pooling_function(self, inputs, pool_size, strides,\n-                          border_mode, data_format):\n+                          padding, data_format):\n         output = K.pool2d(inputs, pool_size, strides,\n-                          border_mode, data_format, pool_mode='avg')\n+                          padding, data_format, pool_mode='avg')\n         return output\n \n \n@@ -256,21 +268,15 @@ class _Pooling3D(Layer):\n     \"\"\"Abstract class for different pooling 3D layers.\n     \"\"\"\n \n-    def __init__(self, pool_size=(2, 2, 2), strides=None, border_mode='valid',\n-                 data_format='default', **kwargs):\n+    def __init__(self, pool_size=(2, 2, 2), strides=None, padding='valid',\n+                 data_format=None, **kwargs):\n         super(_Pooling3D, self).__init__(**kwargs)\n-        if data_format == 'default':\n-            data_format = K.image_data_format()\n-        self.pool_size = tuple(pool_size)\n         if strides is None:\n-            strides = self.pool_size\n-        self.strides = tuple(strides)\n-        if border_mode not in {'valid', 'same'}:\n-            raise ValueError('`border_mode` must be in {valid, same}.')\n-        self.border_mode = border_mode\n-        if data_format not in {'channels_last', 'channels_first'}:\n-            raise ValueError('`data_format` must be in {\"channels_last\", \"channels_first\"}.')\n-        self.data_format = data_format\n+            strides = pool_size\n+        self.pool_size = conv_utils.normalize_tuple(pool_size, 3, 'pool_size')\n+        self.strides = conv_utils.normalize_tuple(strides, 3, 'strides')\n+        self.padding = conv_utils.normalize_padding(padding)\n+        self.data_format = conv_utils.normalize_data_format(data_format)\n         self.input_spec = [InputSpec(ndim=5)]\n \n     def get_output_shape_for(self, input_shape):\n@@ -282,15 +288,12 @@ class _Pooling3D(Layer):\n             len_dim1 = input_shape[1]\n             len_dim2 = input_shape[2]\n             len_dim3 = input_shape[3]\n-        else:\n-            raise ValueError('Invalid data_format:', self.data_format)\n-\n-        len_dim1 = conv_output_length(len_dim1, self.pool_size[0],\n-                                      self.border_mode, self.strides[0])\n-        len_dim2 = conv_output_length(len_dim2, self.pool_size[1],\n-                                      self.border_mode, self.strides[1])\n-        len_dim3 = conv_output_length(len_dim3, self.pool_size[2],\n-                                      self.border_mode, self.strides[2])\n+        len_dim1 = conv_utils.conv_output_length(len_dim1, self.pool_size[0],\n+                                                 self.padding, self.strides[0])\n+        len_dim2 = conv_utils.conv_output_length(len_dim2, self.pool_size[1],\n+                                                 self.padding, self.strides[1])\n+        len_dim3 = conv_utils.conv_output_length(len_dim3, self.pool_size[2],\n+                                                 self.padding, self.strides[2])\n         if self.data_format == 'channels_first':\n             return (input_shape[0],\n                     input_shape[1],\n@@ -301,19 +304,19 @@ class _Pooling3D(Layer):\n                     input_shape[4])\n \n     def _pooling_function(self, inputs, pool_size, strides,\n-                          border_mode, data_format):\n+                          padding, data_format):\n         raise NotImplementedError\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         output = self._pooling_function(inputs=x, pool_size=self.pool_size,\n                                         strides=self.strides,\n-                                        border_mode=self.border_mode,\n+                                        padding=self.padding,\n                                         data_format=self.data_format)\n         return output\n \n     def get_config(self):\n         config = {'pool_size': self.pool_size,\n-                  'border_mode': self.border_mode,\n+                  'padding': self.padding,\n                   'strides': self.strides,\n                   'data_format': self.data_format}\n         base_config = super(_Pooling3D, self).get_config()\n@@ -328,35 +331,44 @@ class MaxPooling3D(_Pooling3D):\n             factors by which to downscale (dim1, dim2, dim3).\n             (2, 2, 2) will halve the size of the 3D input in each dimension.\n         strides: tuple of 3 integers, or None. Strides values.\n-        border_mode: 'valid' or 'same'.\n-        data_format: 'channels_first' or 'channels_last'. In 'channels_first' mode, the channels dimension\n-            (the depth) is at index 1, in 'channels_last' mode is it at index 4.\n+        padding: One of `\"valid\"` or `\"same\"` (case-insensitive).\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n+            while `channels_first` corresponds to inputs with shape\n+            `(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n \n     # Input shape\n+        - If `data_format='channels_last'`:\n             5D tensor with shape:\n-        `(samples, channels, len_pool_dim1, len_pool_dim2, len_pool_dim3)` if data_format='channels_first'\n-        or 5D tensor with shape:\n-        `(samples, len_pool_dim1, len_pool_dim2, len_pool_dim3, channels)` if data_format='channels_last'.\n+            `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n+        - If `data_format='channels_first'`:\n+            5D tensor with shape:\n+            `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`\n \n     # Output shape\n+        - If `data_format='channels_last'`:\n             5D tensor with shape:\n-        `(nb_samples, channels, pooled_dim1, pooled_dim2, pooled_dim3)` if data_format='channels_first'\n-        or 5D tensor with shape:\n-        `(samples, pooled_dim1, pooled_dim2, pooled_dim3, channels)` if data_format='channels_last'.\n+            `(batch_size, pooled_dim1, pooled_dim2, pooled_dim3, channels)`\n+        - If `data_format='channels_first'`:\n+            5D tensor with shape:\n+            `(batch_size, channels, pooled_dim1, pooled_dim2, pooled_dim3)`\n     \"\"\"\n \n-    def __init__(self, pool_size=(2, 2, 2), strides=None, border_mode='valid',\n-                 data_format='default', **kwargs):\n-        super(MaxPooling3D, self).__init__(pool_size, strides, border_mode,\n+    def __init__(self, pool_size=(2, 2, 2), strides=None, padding='valid',\n+                 data_format=None, **kwargs):\n+        super(MaxPooling3D, self).__init__(pool_size, strides, padding,\n                                            data_format, **kwargs)\n \n     def _pooling_function(self, inputs, pool_size, strides,\n-                          border_mode, data_format):\n+                          padding, data_format):\n         output = K.pool3d(inputs, pool_size, strides,\n-                          border_mode, data_format, pool_mode='max')\n+                          padding, data_format, pool_mode='max')\n         return output\n \n \n@@ -368,35 +380,44 @@ class AveragePooling3D(_Pooling3D):\n             factors by which to downscale (dim1, dim2, dim3).\n             (2, 2, 2) will halve the size of the 3D input in each dimension.\n         strides: tuple of 3 integers, or None. Strides values.\n-        border_mode: 'valid' or 'same'.\n-        data_format: 'channels_first' or 'channels_last'. In 'channels_first' mode, the channels dimension\n-            (the depth) is at index 1, in 'channels_last' mode is it at index 4.\n+        padding: One of `\"valid\"` or `\"same\"` (case-insensitive).\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n+            while `channels_first` corresponds to inputs with shape\n+            `(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n \n     # Input shape\n+        - If `data_format='channels_last'`:\n             5D tensor with shape:\n-        `(samples, channels, len_pool_dim1, len_pool_dim2, len_pool_dim3)` if data_format='channels_first'\n-        or 5D tensor with shape:\n-        `(samples, len_pool_dim1, len_pool_dim2, len_pool_dim3, channels)` if data_format='channels_last'.\n+            `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n+        - If `data_format='channels_first'`:\n+            5D tensor with shape:\n+            `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`\n \n     # Output shape\n+        - If `data_format='channels_last'`:\n             5D tensor with shape:\n-        `(nb_samples, channels, pooled_dim1, pooled_dim2, pooled_dim3)` if data_format='channels_first'\n-        or 5D tensor with shape:\n-        `(samples, pooled_dim1, pooled_dim2, pooled_dim3, channels)` if data_format='channels_last'.\n+            `(batch_size, pooled_dim1, pooled_dim2, pooled_dim3, channels)`\n+        - If `data_format='channels_first'`:\n+            5D tensor with shape:\n+            `(batch_size, channels, pooled_dim1, pooled_dim2, pooled_dim3)`\n     \"\"\"\n \n-    def __init__(self, pool_size=(2, 2, 2), strides=None, border_mode='valid',\n-                 data_format='default', **kwargs):\n-        super(AveragePooling3D, self).__init__(pool_size, strides, border_mode,\n+    def __init__(self, pool_size=(2, 2, 2), strides=None, padding='valid',\n+                 data_format=None, **kwargs):\n+        super(AveragePooling3D, self).__init__(pool_size, strides, padding,\n                                                data_format, **kwargs)\n \n     def _pooling_function(self, inputs, pool_size, strides,\n-                          border_mode, data_format):\n+                          padding, data_format):\n         output = K.pool3d(inputs, pool_size, strides,\n-                          border_mode, data_format,\n+                          padding, data_format,\n                           pool_mode='avg')\n         return output\n \n@@ -412,7 +433,7 @@ class _GlobalPooling1D(Layer):\n     def get_output_shape_for(self, input_shape):\n         return (input_shape[0], input_shape[2])\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         raise NotImplementedError\n \n \n@@ -420,13 +441,14 @@ class GlobalAveragePooling1D(_GlobalPooling1D):\n     \"\"\"Global average pooling operation for temporal data.\n \n     # Input shape\n-        3D tensor with shape: `(samples, steps, features)`.\n+        3D tensor with shape: `(batch_size, steps, features)`.\n \n     # Output shape\n-        2D tensor with shape: `(samples, features)`.\n+        2D tensor with shape:\n+        `(batch_size, channels)`\n     \"\"\"\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         return K.mean(x, axis=1)\n \n \n@@ -434,13 +456,14 @@ class GlobalMaxPooling1D(_GlobalPooling1D):\n     \"\"\"Global max pooling operation for temporal data.\n \n     # Input shape\n-        3D tensor with shape: `(samples, steps, features)`.\n+        3D tensor with shape: `(batch_size, steps, features)`.\n \n     # Output shape\n-        2D tensor with shape: `(samples, features)`.\n+        2D tensor with shape:\n+        `(batch_size, channels)`\n     \"\"\"\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         return K.max(x, axis=1)\n \n \n@@ -448,11 +471,9 @@ class _GlobalPooling2D(Layer):\n     \"\"\"Abstract class for different global pooling 2D layers.\n     \"\"\"\n \n-    def __init__(self, data_format='default', **kwargs):\n+    def __init__(self, data_format=None, **kwargs):\n         super(_GlobalPooling2D, self).__init__(**kwargs)\n-        if data_format == 'default':\n-            data_format = K.image_data_format()\n-        self.data_format = data_format\n+        self.data_format = conv_utils.normalize_data_format(data_format)\n         self.input_spec = [InputSpec(ndim=4)]\n \n     def get_output_shape_for(self, input_shape):\n@@ -461,7 +482,7 @@ class _GlobalPooling2D(Layer):\n         else:\n             return (input_shape[0], input_shape[1])\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         raise NotImplementedError\n \n     def get_config(self):\n@@ -474,24 +495,31 @@ class GlobalAveragePooling2D(_GlobalPooling2D):\n     \"\"\"Global average pooling operation for spatial data.\n \n     # Arguments\n-        data_format: 'channels_first' or 'channels_last'. In 'channels_first' mode, the channels dimension\n-            (the depth) is at index 1, in 'channels_last' mode is it at index 3.\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, width, height, channels)` while `channels_first`\n+            corresponds to inputs with shape\n+            `(batch, channels, width, height)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n \n     # Input shape\n+        - If `data_format='channels_last'`:\n             4D tensor with shape:\n-        `(samples, channels, rows, cols)` if data_format='channels_first'\n-        or 4D tensor with shape:\n-        `(samples, rows, cols, channels)` if data_format='channels_last'.\n+            `(batch_size, rows, cols, channels)`\n+        - If `data_format='channels_first'`:\n+            4D tensor with shape:\n+            `(batch_size, channels, rows, cols)`\n \n     # Output shape\n         2D tensor with shape:\n-        `(nb_samples, channels)`\n+        `(batch_size, channels)`\n     \"\"\"\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         if self.data_format == 'channels_last':\n             return K.mean(x, axis=[1, 2])\n         else:\n@@ -502,24 +530,31 @@ class GlobalMaxPooling2D(_GlobalPooling2D):\n     \"\"\"Global max pooling operation for spatial data.\n \n     # Arguments\n-        data_format: 'channels_first' or 'channels_last'. In 'channels_first' mode, the channels dimension\n-            (the depth) is at index 1, in 'channels_last' mode is it at index 3.\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, width, height, channels)` while `channels_first`\n+            corresponds to inputs with shape\n+            `(batch, channels, width, height)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n \n     # Input shape\n+        - If `data_format='channels_last'`:\n             4D tensor with shape:\n-        `(samples, channels, rows, cols)` if data_format='channels_first'\n-        or 4D tensor with shape:\n-        `(samples, rows, cols, channels)` if data_format='channels_last'.\n+            `(batch_size, rows, cols, channels)`\n+        - If `data_format='channels_first'`:\n+            4D tensor with shape:\n+            `(batch_size, channels, rows, cols)`\n \n     # Output shape\n         2D tensor with shape:\n-        `(nb_samples, channels)`\n+        `(batch_size, channels)`\n     \"\"\"\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         if self.data_format == 'channels_last':\n             return K.max(x, axis=[1, 2])\n         else:\n@@ -530,11 +565,9 @@ class _GlobalPooling3D(Layer):\n     \"\"\"Abstract class for different global pooling 3D layers.\n     \"\"\"\n \n-    def __init__(self, data_format='default', **kwargs):\n+    def __init__(self, data_format=None, **kwargs):\n         super(_GlobalPooling3D, self).__init__(**kwargs)\n-        if data_format == 'default':\n-            data_format = K.image_data_format()\n-        self.data_format = data_format\n+        self.data_format = conv_utils.normalize_data_format(data_format)\n         self.input_spec = [InputSpec(ndim=5)]\n \n     def get_output_shape_for(self, input_shape):\n@@ -543,7 +576,7 @@ class _GlobalPooling3D(Layer):\n         else:\n             return (input_shape[0], input_shape[1])\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         raise NotImplementedError\n \n     def get_config(self):\n@@ -556,24 +589,31 @@ class GlobalAveragePooling3D(_GlobalPooling3D):\n     \"\"\"Global Average pooling operation for 3D data.\n \n     # Arguments\n-        data_format: 'channels_first' or 'channels_last'. In 'channels_first' mode, the channels dimension\n-            (the depth) is at index 1, in 'channels_last' mode is it at index 4.\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n+            while `channels_first` corresponds to inputs with shape\n+            `(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n \n     # Input shape\n+        - If `data_format='channels_last'`:\n             5D tensor with shape:\n-        `(samples, channels, len_pool_dim1, len_pool_dim2, len_pool_dim3)` if data_format='channels_first'\n-        or 5D tensor with shape:\n-        `(samples, len_pool_dim1, len_pool_dim2, len_pool_dim3, channels)` if data_format='channels_last'.\n+            `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n+        - If `data_format='channels_first'`:\n+            5D tensor with shape:\n+            `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`\n \n     # Output shape\n         2D tensor with shape:\n-        `(nb_samples, channels)`\n+        `(batch_size, channels)`\n     \"\"\"\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         if self.data_format == 'channels_last':\n             return K.mean(x, axis=[1, 2, 3])\n         else:\n@@ -584,24 +624,31 @@ class GlobalMaxPooling3D(_GlobalPooling3D):\n     \"\"\"Global Max pooling operation for 3D data.\n \n     # Arguments\n-        data_format: 'channels_first' or 'channels_last'. In 'channels_first' mode, the channels dimension\n-            (the depth) is at index 1, in 'channels_last' mode is it at index 4.\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n+            while `channels_first` corresponds to inputs with shape\n+            `(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n \n     # Input shape\n+        - If `data_format='channels_last'`:\n             5D tensor with shape:\n-        `(samples, channels, len_pool_dim1, len_pool_dim2, len_pool_dim3)` if data_format='channels_first'\n-        or 5D tensor with shape:\n-        `(samples, len_pool_dim1, len_pool_dim2, len_pool_dim3, channels)` if data_format='channels_last'.\n+            `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n+        - If `data_format='channels_first'`:\n+            5D tensor with shape:\n+            `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`\n \n     # Output shape\n         2D tensor with shape:\n-        `(nb_samples, channels)`\n+        `(batch_size, channels)`\n     \"\"\"\n \n-    def call(self, x, mask=None):\n+    def call(self, x):\n         if self.data_format == 'channels_last':\n             return K.max(x, axis=[1, 2, 3])\n         else:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
