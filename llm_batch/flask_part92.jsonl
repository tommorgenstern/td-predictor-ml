{"custom_id": "flask#eb41e7e417cbf53d19517e356381423cfd256c2f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 4470 | Contributors (this commit): 43 | Commits (past 90d): 3 | Contributors (cumulative): 43 | DMM Complexity: None\n\nDIFF:\n@@ -1520,6 +1520,8 @@ def test_server_name_subdomain():\n     assert rv.data == b\"subdomain\"\n \n \n+@pytest.mark.filterwarnings(\"ignore::pytest.PytestUnraisableExceptionWarning\")\n+@pytest.mark.filterwarnings(\"ignore::pytest.PytestUnhandledThreadExceptionWarning\")\n def test_exception_propagation(app, client):\n     def apprunner(config_key):\n         @app.route(\"/\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#aff21fd8bc4d168caf481de87bb5447adccd18ad", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 16/16 | Churn Δ: 2 | Churn Cumulative: 448 | Contributors (this commit): 2 | Commits (past 90d): 1 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -237,7 +237,7 @@ def loads(s, app=None, **kwargs):\n     :param app: App instance to use to configure the JSON decoder.\n         Uses ``current_app`` if not given, and falls back to the default\n         encoder when not in an app context.\n-    :param kwargs: Extra arguments passed to :func:`json.dumps`.\n+    :param kwargs: Extra arguments passed to :func:`json.loads`.\n \n     .. versionchanged:: 1.0.3\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#2fab8a31ae2639b3eacdd3935d58203b09650f29", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): -16/0 | Churn Δ: 6 | Churn Cumulative: 454 | Contributors (this commit): 3 | Commits (past 90d): 2 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -103,7 +103,7 @@ def dumps(obj, app=None, **kwargs):\n     :param obj: Object to serialize to JSON.\n     :param app: Use this app's config instead of the active app context\n         or defaults.\n-    :param kwargs: Extra arguments passed to func:`json.dumps`.\n+    :param kwargs: Extra arguments passed to :func:`json.dumps`.\n \n     .. versionchanged:: 2.0\n         ``encoding`` is deprecated and will be removed in 2.1.\n@@ -139,7 +139,7 @@ def dump(obj, fp, app=None, **kwargs):\n     :param fp: File object to write JSON to.\n     :param app: Use this app's config instead of the active app context\n         or defaults.\n-    :param kwargs: Extra arguments passed to func:`json.dump`.\n+    :param kwargs: Extra arguments passed to :func:`json.dump`.\n \n     .. versionchanged:: 2.0\n         Writing to a binary file, and the ``encoding`` argument, is\n@@ -211,7 +211,7 @@ def load(fp, app=None, **kwargs):\n     :param fp: File object to read JSON from.\n     :param app: Use this app's config instead of the active app context\n         or defaults.\n-    :param kwargs: Extra arguments passed to func:`json.load`.\n+    :param kwargs: Extra arguments passed to :func:`json.load`.\n \n     .. versionchanged:: 2.0\n         ``encoding`` is deprecated and will be removed in 2.1. The file\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#fdba0d2526347786c05c15027e183a5ba4d81114", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 15 | Files Changed: 1 | Hunks: 6 | Methods Changed: 2 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 26 | Churn Cumulative: 50 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 1 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,23 +1,12 @@\n from werkzeug.exceptions import BadRequest\n from werkzeug.wrappers import Request as RequestBase\n from werkzeug.wrappers import Response as ResponseBase\n-from werkzeug.wrappers.json import JSONMixin as _JSONMixin\n \n from . import json\n from .globals import current_app\n \n \n-class JSONMixin(_JSONMixin):\n-    json_module = json\n-\n-    def on_json_loading_failed(self, e):\n-        if current_app and current_app.debug:\n-            raise BadRequest(f\"Failed to decode JSON object: {e}\")\n-\n-        raise BadRequest()\n-\n-\n-class Request(RequestBase, JSONMixin):\n+class Request(RequestBase):\n     \"\"\"The request object used by default in Flask.  Remembers the\n     matched endpoint and view arguments.\n \n@@ -30,6 +19,8 @@ class Request(RequestBase, JSONMixin):\n     specific ones.\n     \"\"\"\n \n+    json_module = json\n+\n     #: The internal URL rule that matched the request.  This can be\n     #: useful to inspect which methods are allowed for the URL from\n     #: a before/after handler (``request.url_rule.methods``) etc.\n@@ -89,8 +80,14 @@ class Request(RequestBase, JSONMixin):\n \n             attach_enctype_error_multidict(self)\n \n+    def on_json_loading_failed(self, e):\n+        if current_app and current_app.debug:\n+            raise BadRequest(f\"Failed to decode JSON object: {e}\")\n \n-class Response(JSONMixin, ResponseBase):\n+        raise BadRequest()\n+\n+\n+class Response(ResponseBase):\n     \"\"\"The response object that is used by default in Flask.  Works like the\n     response object from Werkzeug but is set to have an HTML mimetype by\n     default.  Quite often you don't have to create this object yourself because\n@@ -110,8 +107,7 @@ class Response(JSONMixin, ResponseBase):\n \n     default_mimetype = \"text/html\"\n \n-    def _get_data_for_json(self, cache):\n-        return self.get_data()\n+    json_module = json\n \n     @property\n     def max_cookie_size(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#1936ca8a2e1789efd6169a901a8b60ec62ceb578", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 3 | Files Changed: 3 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 1068 | Contributors (this commit): 10 | Commits (past 90d): 7 | Contributors (cumulative): 12 | DMM Complexity: None\n\nDIFF:\n@@ -16,7 +16,7 @@ from werkzeug.routing import Map\n from werkzeug.routing import RequestRedirect\n from werkzeug.routing import RoutingException\n from werkzeug.routing import Rule\n-from werkzeug.wrappers import BaseResponse\n+from werkzeug.wrappers import Response as BaseResponse\n \n from . import cli\n from . import json\n\n@@ -5,7 +5,7 @@ import werkzeug.test\n from click.testing import CliRunner\n from werkzeug.test import Client\n from werkzeug.urls import url_parse\n-from werkzeug.wrappers import BaseRequest\n+from werkzeug.wrappers import Request as BaseRequest\n \n from . import _request_ctx_stack\n from .cli import ScriptInfo\n\n@@ -113,7 +113,7 @@ class Response(ResponseBase):\n     def max_cookie_size(self):\n         \"\"\"Read-only view of the :data:`MAX_COOKIE_SIZE` config key.\n \n-        See :attr:`~werkzeug.wrappers.BaseResponse.max_cookie_size` in\n+        See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in\n         Werkzeug's docs.\n         \"\"\"\n         if current_app:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#14f56363a4992506f2b3670985fca4f0a29e5176", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 21 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 7 | Methods Changed: 3 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 24 | Churn Cumulative: 745 | Contributors (this commit): 7 | Commits (past 90d): 2 | Contributors (cumulative): 7 | DMM Complexity: 1.0\n\nDIFF:\n@@ -439,6 +439,8 @@ def get_flashed_messages(with_categories=False, category_filter=()):\n def _prepare_send_file_kwargs(\n     download_name=None,\n     attachment_filename=None,\n+    etag=None,\n+    add_etags=None,\n     max_age=None,\n     cache_timeout=None,\n     **kwargs,\n@@ -461,12 +463,22 @@ def _prepare_send_file_kwargs(\n         )\n         max_age = cache_timeout\n \n+    if add_etags is not None:\n+        warnings.warn(\n+            \"The 'add_etags' parameter has been renamed to 'etag'. The old name will be\"\n+            \" removed in Flask 2.1.\",\n+            DeprecationWarning,\n+            stacklevel=3,\n+        )\n+        etag = add_etags\n+\n     if max_age is None:\n         max_age = current_app.get_send_file_max_age\n \n     kwargs.update(\n         environ=request.environ,\n         download_name=download_name,\n+        etag=etag,\n         max_age=max_age,\n         use_x_sendfile=current_app.use_x_sendfile,\n         response_class=current_app.response_class,\n@@ -482,7 +494,8 @@ def send_file(\n     download_name=None,\n     attachment_filename=None,\n     conditional=True,\n-    add_etags=True,\n+    etag=True,\n+    add_etags=None,\n     last_modified=None,\n     max_age=None,\n     cache_timeout=None,\n@@ -518,8 +531,8 @@ def send_file(\n         the file. Defaults to the passed file name.\n     :param conditional: Enable conditional and range responses based on\n         request headers. Requires passing a file path and ``environ``.\n-    :param add_etags: Calculate an ETag for the file. Requires passing a\n-        file path.\n+    :param etag: Calculate an ETag for the file, which requires passing\n+        a file path. Can also be a string to use instead.\n     :param last_modified: The last modified time to send for the file,\n         in seconds. If not provided, it will try to detect it from the\n         file path.\n@@ -537,6 +550,10 @@ def send_file(\n         ``conditional`` is enabled and ``max_age`` is not set by\n         default.\n \n+    .. versionchanged:: 2.0.0\n+        ``etag`` replaces the ``add_etags`` parameter. It can be a\n+        string to use instead of generating one.\n+\n     .. versionchanged:: 2.0\n         Passing a file-like object that inherits from\n         :class:`~io.TextIOBase` will raise a :exc:`ValueError` rather\n@@ -593,6 +610,7 @@ def send_file(\n             download_name=download_name,\n             attachment_filename=attachment_filename,\n             conditional=conditional,\n+            etag=etag,\n             add_etags=add_etags,\n             last_modified=last_modified,\n             max_age=max_age,\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#eb42655c46f8a598f2e0ead624ba5a65a8a66e90", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 10 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 13 | Churn Cumulative: 895 | Contributors (this commit): 10 | Commits (past 90d): 3 | Contributors (cumulative): 10 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1386,18 +1386,11 @@ class Flask(Scaffold):\n \n         .. versionadded:: 0.7\n         \"\"\"\n-        if isinstance(e, BadRequestKeyError):\n-            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n+        if isinstance(e, BadRequestKeyError) and (\n+            self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n+        ):\n             e.show_exception = True\n \n-                # Werkzeug < 0.15 doesn't add the KeyError to the 400\n-                # message, add it in manually.\n-                # TODO: clean up once Werkzeug >= 0.15.5 is required\n-                if e.args[0] not in e.get_description():\n-                    e.description = f\"KeyError: {e.args[0]!r}\"\n-            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n-                e.args = ()\n-\n         if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n             return self.handle_http_exception(e)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#64206c13c2bff0220328845db0995f451cefd3b1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 900 | Contributors (this commit): 10 | Commits (past 90d): 4 | Contributors (cumulative): 10 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1447,10 +1447,7 @@ class Flask(Scaffold):\n             raise e\n \n         self.log_exception(exc_info)\n-        server_error = InternalServerError()\n-        # TODO: pass as param when Werkzeug>=1.0.0 is required\n-        # TODO: also remove note about this from docstring and docs\n-        server_error.original_exception = e\n+        server_error = InternalServerError(original_exception=e)\n         handler = self._find_error_handler(server_error)\n \n         if handler is not None:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#055cdc2625c0cdf8cea87524f5c6bcf07f7e5005", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 8 | Churn Cumulative: 385 | Contributors (this commit): 4 | Commits (past 90d): 2 | Contributors (cumulative): 5 | DMM Complexity: None\n\nDIFF:\n@@ -1,3 +1,3 @@\n from .cli import main\n \n-main(as_module=True)\n+main()\n\n@@ -953,10 +953,10 @@ debug mode.\n )\n \n \n-def main(as_module=False):\n+def main():\n     # TODO omit sys.argv once https://github.com/pallets/click/issues/536 is fixed\n-    cli.main(args=sys.argv[1:], prog_name=\"python -m flask\" if as_module else None)\n+    cli.main(args=sys.argv[1:])\n \n \n if __name__ == \"__main__\":\n-    main(as_module=True)\n+    main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#81ba6c24efea58dd00c093448fa2e529c0cda507", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 902 | Contributors (this commit): 10 | Commits (past 90d): 5 | Contributors (cumulative): 10 | DMM Complexity: None\n\nDIFF:\n@@ -278,7 +278,7 @@ class Flask(Scaffold):\n     #:     This is a ``dict`` instead of an ``ImmutableDict`` to allow\n     #:     easier configuration.\n     #:\n-    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n+    jinja_options = {}\n \n     #: Default configuration parameters.\n     default_config = ImmutableDict(\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#01621485fdad733b0886117d59bea1adac8d4fcc", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 25 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 3 | Methods Changed: 5 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 28 | Churn Cumulative: 124 | Contributors (this commit): 5 | Commits (past 90d): 2 | Contributors (cumulative): 6 | DMM Complexity: 1.0\n\nDIFF:\n@@ -361,6 +361,9 @@ class RequestContext:\n \n         _request_ctx_stack.push(self)\n \n+        if self.url_adapter is not None:\n+            self.match_request()\n+\n         # Open the session at the moment that the request context is available.\n         # This allows a custom open_session method to use the request context.\n         # Only open a new session if this is the first time the request was\n@@ -372,9 +375,6 @@ class RequestContext:\n             if self.session is None:\n                 self.session = session_interface.make_null_session(self.app)\n \n-        if self.url_adapter is not None:\n-            self.match_request()\n-\n     def pop(self, exc=_sentinel):\n         \"\"\"Pops the request context and unbinds it by doing that.  This will\n         also trigger the execution of functions registered by the\n\n@@ -0,0 +1,22 @@\n+import flask\n+from flask.sessions import SessionInterface\n+\n+\n+def test_open_session_endpoint_not_none():\n+    # Define a session interface that breaks if request.endpoint is None\n+    class MySessionInterface(SessionInterface):\n+        def save_session(self):\n+            pass\n+\n+        def open_session(self, _, request):\n+            assert request.endpoint is not None\n+\n+    def index():\n+        return \"Hello World!\"\n+\n+    # Confirm a 200 response, indicating that request.endpoint was NOT None\n+    app = flask.Flask(__name__)\n+    app.route(\"/\")(index)\n+    app.session_interface = MySessionInterface()\n+    response = app.test_client().open(\"/\")\n+    assert response.status_code == 200\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#b473e7c97c7c557e64fb84236c7d346b6ad16736", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 21 | Lines Deleted: 34 | Files Changed: 3 | Hunks: 10 | Methods Changed: 5 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 55 | Churn Cumulative: 1827 | Contributors (this commit): 12 | Commits (past 90d): 11 | Contributors (cumulative): 14 | DMM Complexity: 0.0\n\nDIFF:\n@@ -681,7 +681,7 @@ class Flask(Scaffold):\n             session=session,\n             g=g,\n         )\n-        rv.filters[\"tojson\"] = json.tojson_filter\n+        rv.policies[\"json.dumps_function\"] = json.dumps\n         return rv\n \n     def create_global_jinja_loader(self):\n\n@@ -5,7 +5,7 @@ import warnings\n from datetime import date\n from datetime import datetime\n \n-from markupsafe import Markup\n+from jinja2.utils import htmlsafe_json_dumps as _jinja_htmlsafe_dumps\n from werkzeug.http import http_date\n \n from ..globals import current_app\n@@ -234,30 +234,28 @@ def load(fp, app=None, **kwargs):\n     return _json.load(fp, **kwargs)\n \n \n-_htmlsafe_map = str.maketrans(\n-    {\"<\": \"\\\\u003c\", \">\": \"\\\\u003e\", \"&\": \"\\\\u0026\", \"'\": \"\\\\u0027\"}\n-)\n-\n-\n def htmlsafe_dumps(obj, **kwargs):\n-    \"\"\"Serialize an object to a string of JSON, replacing HTML-unsafe\n-    characters with Unicode escapes. Otherwise behaves the same as\n-    :func:`dumps`.\n+    \"\"\"Serialize an object to a string of JSON with :func:`dumps`, then\n+    replace HTML-unsafe characters with Unicode escapes and mark the\n+    result safe with :class:`~markupsafe.Markup`.\n \n-    This is available in templates as the ``|tojson`` filter, which will\n-    also mark the result with ``|safe``.\n+    This is available in templates as the ``|tojson`` filter.\n \n     The returned string is safe to render in HTML documents and\n     ``<script>`` tags. The exception is in HTML attributes that are\n     double quoted; either use single quotes or the ``|forceescape``\n     filter.\n \n+    .. versionchanged:: 2.0\n+        Uses :func:`jinja2.utils.htmlsafe_json_dumps`. The returned\n+        value is marked safe by wrapping in :class:`~markupsafe.Markup`.\n+\n     .. versionchanged:: 0.10\n         Single quotes are escaped, making this safe to use in HTML,\n         ``<script>`` tags, and single-quoted attributes without further\n         escaping.\n     \"\"\"\n-    return dumps(obj, **kwargs).translate(_htmlsafe_map)\n+    return _jinja_htmlsafe_dumps(obj, dumps=dumps, **kwargs)\n \n \n def htmlsafe_dump(obj, fp, **kwargs):\n@@ -335,7 +333,3 @@ def jsonify(*args, **kwargs):\n         f\"{dumps(data, indent=indent, separators=separators)}\\n\",\n         mimetype=current_app.config[\"JSONIFY_MIMETYPE\"],\n     )\n-\n-\n-def tojson_filter(obj, **kwargs):\n-    return Markup(htmlsafe_dumps(obj, **kwargs))\n\n@@ -204,24 +204,17 @@ def test_json_attr(app, client):\n     assert rv.data == b\"3\"\n \n \n-def test_template_escaping(app, req_ctx):\n-    render = flask.render_template_string\n-    rv = flask.json.htmlsafe_dumps(\"</script>\")\n-    assert rv == '\"\\\\u003c/script\\\\u003e\"'\n-    rv = render('{{ \"</script>\"|tojson }}')\n-    assert rv == '\"\\\\u003c/script\\\\u003e\"'\n-    rv = render('{{ \"<\\0/script>\"|tojson }}')\n-    assert rv == '\"\\\\u003c\\\\u0000/script\\\\u003e\"'\n-    rv = render('{{ \"<!--<script>\"|tojson }}')\n-    assert rv == '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"'\n-    rv = render('{{ \"&\"|tojson }}')\n-    assert rv == '\"\\\\u0026\"'\n-    rv = render('{{ \"\\'\"|tojson }}')\n-    assert rv == '\"\\\\u0027\"'\n-    rv = render(\n-        \"<a ng-data='{{ data|tojson }}'></a>\", data={\"x\": [\"foo\", \"bar\", \"baz'\"]}\n+def test_tojson_filter(app, req_ctx):\n+    # The tojson filter is tested in Jinja, this confirms that it's\n+    # using Flask's dumps.\n+    rv = flask.render_template_string(\n+        \"const data = {{ data|tojson }};\",\n+        data={\"name\": \"</script>\", \"time\": datetime.datetime(2021, 2, 1, 7, 15)},\n+    )\n+    assert rv == (\n+        'const data = {\"name\": \"\\\\u003c/script\\\\u003e\",'\n+        ' \"time\": \"Mon, 01 Feb 2021 07:15:00 GMT\"};'\n     )\n-    assert rv == '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'></a>'\n \n \n def test_json_customization(app, client):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#0ee1b0b5d9712b6cf2f22429db98549e1a0c8cb8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 54 | Files Changed: 1 | Hunks: 2 | Methods Changed: 5 | Complexity Δ (Sum/Max): -7/0 | Churn Δ: 54 | Churn Cumulative: 212 | Contributors (this commit): 7 | Commits (past 90d): 1 | Contributors (cumulative): 7 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,59 +1,5 @@\n-import gc\n-import platform\n-import threading\n-\n-import pytest\n-\n import flask\n \n-_gc_lock = threading.Lock()\n-\n-\n-class assert_no_leak:\n-    def __enter__(self):\n-        gc.disable()\n-        _gc_lock.acquire()\n-        loc = flask._request_ctx_stack._local\n-\n-        # Force Python to track this dictionary at all times.\n-        # This is necessary since Python only starts tracking\n-        # dicts if they contain mutable objects.  It's a horrible,\n-        # horrible hack but makes this kinda testable.\n-        loc.__storage__[\"FOOO\"] = [1, 2, 3]\n-\n-        gc.collect()\n-        self.old_objects = len(gc.get_objects())\n-\n-    def __exit__(self, exc_type, exc_value, tb):\n-        gc.collect()\n-        new_objects = len(gc.get_objects())\n-        if new_objects > self.old_objects:\n-            pytest.fail(\"Example code leaked\")\n-        _gc_lock.release()\n-        gc.enable()\n-\n-\n-@pytest.mark.skipif(platform.python_implementation() == \"PyPy\", reason=\"CPython only\")\n-def test_memory_consumption():\n-    app = flask.Flask(__name__)\n-\n-    @app.route(\"/\")\n-    def index():\n-        return flask.render_template(\"simple_template.html\", whiskey=42)\n-\n-    def fire():\n-        with app.test_client() as c:\n-            rv = c.get(\"/\")\n-            assert rv.status_code == 200\n-            assert rv.data == b\"<h1>42</h1>\"\n-\n-    # Trigger caches\n-    fire()\n-\n-    with assert_no_leak():\n-        for _x in range(10):\n-            fire()\n-\n \n def test_aborting(app):\n     class Foo(Exception):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#3cd615a1d6db7e319c27bca2499ab7390065f090", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 8 | Churn Cumulative: 1959 | Contributors (this commit): 16 | Commits (past 90d): 1 | Contributors (cumulative): 16 | DMM Complexity: None\n\nDIFF:\n@@ -38,11 +38,13 @@ html_theme = \"flask\"\n html_theme_options = {\"index_sidebar_logo\": False}\n html_context = {\n     \"project_links\": [\n-        ProjectLink(\"Donate to Pallets\", \"https://palletsprojects.com/donate\"),\n-        ProjectLink(\"Flask Website\", \"https://palletsprojects.com/p/flask/\"),\n-        ProjectLink(\"PyPI releases\", \"https://pypi.org/project/Flask/\"),\n+        ProjectLink(\"Donate\", \"https://palletsprojects.com/donate\"),\n+        ProjectLink(\"PyPI Releases\", \"https://pypi.org/project/Flask/\"),\n         ProjectLink(\"Source Code\", \"https://github.com/pallets/flask/\"),\n         ProjectLink(\"Issue Tracker\", \"https://github.com/pallets/flask/issues/\"),\n+        ProjectLink(\"Website\", \"https://palletsprojects.com/p/flask/\"),\n+        ProjectLink(\"Twitter\", \"https://twitter.com/PalletsTeam\"),\n+        ProjectLink(\"Chat\", \"https://discord.gg/pallets\"),\n     ]\n }\n html_sidebars = {\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#0c7cbe2d1186f53efcd0da0589a2eaf0382e4d39", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 3 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 854 | Contributors (this commit): 30 | Commits (past 90d): 1 | Contributors (cumulative): 30 | DMM Complexity: None\n\nDIFF:\n@@ -1,14 +1,8 @@\n-import re\n-\n from setuptools import setup\n \n-with open(\"src/flask/__init__.py\", encoding=\"utf8\") as f:\n-    version = re.search(r'__version__ = \"(.*?)\"', f.read()).group(1)\n-\n # Metadata goes in setup.cfg. These are here for GitHub's dependency graph.\n setup(\n     name=\"Flask\",\n-    version=version,\n     install_requires=[\n         \"Werkzeug>=0.15\",\n         \"Jinja2>=2.10.1\",\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#49b7341a491e01cd6a08238ca63bd46ae53a009f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 16 | Files Changed: 3 | Hunks: 8 | Methods Changed: 4 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 27 | Churn Cumulative: 1091 | Contributors (this commit): 6 | Commits (past 90d): 7 | Contributors (cumulative): 10 | DMM Complexity: 0.3333333333333333\n\nDIFF:\n@@ -3,7 +3,6 @@ import json as _json\n import uuid\n import warnings\n from datetime import date\n-from datetime import datetime\n \n from jinja2.utils import htmlsafe_json_dumps as _jinja_htmlsafe_dumps\n from werkzeug.http import http_date\n@@ -41,10 +40,8 @@ class JSONEncoder(_json.JSONEncoder):\n         overriding how basic types like ``str`` or ``list`` are\n         serialized, they are handled before this method.\n         \"\"\"\n-        if isinstance(o, datetime):\n-            return http_date(o.utctimetuple())\n         if isinstance(o, date):\n-            return http_date(o.timetuple())\n+            return http_date(o)\n         if isinstance(o, uuid.UUID):\n             return str(o)\n         if dataclasses and dataclasses.is_dataclass(o):\n\n@@ -129,19 +129,16 @@ def test_jsonify_arrays(app, client):\n         assert flask.json.loads(rv.data) == a_list\n \n \n-def test_jsonifytypes(app, client):\n-    \"\"\"Test jsonify with datetime.date and datetime.datetime types.\"\"\"\n-    test_dates = (\n-        datetime.datetime(1973, 3, 11, 6, 30, 45),\n-        datetime.date(1975, 1, 5),\n+@pytest.mark.parametrize(\n+    \"value\", [datetime.datetime(1973, 3, 11, 6, 30, 45), datetime.date(1975, 1, 5)]\n )\n+def test_jsonify_datetime(app, client, value):\n+    @app.route(\"/\")\n+    def index():\n+        return flask.jsonify(value=value)\n \n-    for i, d in enumerate(test_dates):\n-        url = f\"/datetest{i}\"\n-        app.add_url_rule(url, str(i), lambda val=d: flask.jsonify(x=val))\n-        rv = client.get(url)\n-        assert rv.mimetype == \"application/json\"\n-        assert flask.json.loads(rv.data)[\"x\"] == http_date(d.timetuple())\n+    r = client.get()\n+    assert r.json[\"value\"] == http_date(value)\n \n \n class FixedOffset(datetime.tzinfo):\n\n@@ -1,4 +1,5 @@\n from datetime import datetime\n+from datetime import timezone\n from uuid import uuid4\n \n import pytest\n@@ -20,7 +21,7 @@ from flask.json.tag import TaggedJSONSerializer\n         b\"\\xff\",\n         Markup(\"<html>\"),\n         uuid4(),\n-        datetime.utcnow().replace(microsecond=0),\n+        datetime.now(tz=timezone.utc).replace(microsecond=0),\n     ),\n )\n def test_dump_load_unchanged(data):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#705e52684a9063889c16a289695a2e4429df6887", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 58 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 2 | Methods Changed: 9 | Complexity Δ (Sum/Max): 10/7 | Churn Δ: 58 | Churn Cumulative: 4942 | Contributors (this commit): 44 | Commits (past 90d): 3 | Contributors (cumulative): 46 | DMM Complexity: 1.0\n\nDIFF:\n@@ -146,6 +146,47 @@ class Scaffold(_PackageBoundObject):\n     def _is_setup_finished(self):\n         raise NotImplementedError\n \n+    def _method_route(self, method, rule, options):\n+        if \"methods\" in options:\n+            raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n+\n+        return self.route(rule, methods=[method], **options)\n+\n+    def get(self, rule, **options):\n+        \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n+\n+        .. versionadded:: 2.0\n+        \"\"\"\n+        return self._method_route(\"GET\", rule, options)\n+\n+    def post(self, rule, **options):\n+        \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n+\n+        .. versionadded:: 2.0\n+        \"\"\"\n+        return self._method_route(\"POST\", rule, options)\n+\n+    def put(self, rule, **options):\n+        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n+\n+        .. versionadded:: 2.0\n+        \"\"\"\n+        return self._method_route(\"PUT\", rule, options)\n+\n+    def delete(self, rule, **options):\n+        \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n+\n+        .. versionadded:: 2.0\n+        \"\"\"\n+        return self._method_route(\"DELETE\", rule, options)\n+\n+    def patch(self, rule, **options):\n+        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n+\n+        .. versionadded:: 2.0\n+        \"\"\"\n+        return self._method_route(\"PATCH\", rule, options)\n+\n     def route(self, rule, **options):\n         \"\"\"A decorator that is used to register a view function for a\n         given URL rule.  This does the same thing as :meth:`add_url_rule`\n\n@@ -48,6 +48,23 @@ def test_options_on_multiple_rules(app, client):\n     assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"]\n \n \n+@pytest.mark.parametrize(\"method\", [\"get\", \"post\", \"put\", \"delete\", \"patch\"])\n+def test_method_route(app, client, method):\n+    method_route = getattr(app, method)\n+    client_method = getattr(client, method)\n+\n+    @method_route(\"/\")\n+    def hello():\n+        return \"Hello\"\n+\n+    assert client_method(\"/\").data == b\"Hello\"\n+\n+\n+def test_method_route_no_methods(app):\n+    with pytest.raises(TypeError):\n+        app.get(\"/\", methods=[\"GET\", \"POST\"])\n+\n+\n def test_provide_automatic_options_attr():\n     app = flask.Flask(__name__)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#fd62210f583e90764be6e8d9f295f37f33a65e48", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 23 | Lines Deleted: 21 | Files Changed: 3 | Hunks: 21 | Methods Changed: 13 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 44 | Churn Cumulative: 1614 | Contributors (this commit): 13 | Commits (past 90d): 9 | Contributors (cumulative): 19 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1292,7 +1292,7 @@ class Flask(Scaffold):\n             (request.blueprint, None),\n             (None, None),\n         ):\n-            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n+            handler_map = self.error_handler_spec[name][c]\n \n             if not handler_map:\n                 continue\n@@ -1753,10 +1753,10 @@ class Flask(Scaffold):\n \n         .. versionadded:: 0.7\n         \"\"\"\n-        funcs = self.url_default_functions.get(None, ())\n+        funcs = self.url_default_functions[None]\n         if \".\" in endpoint:\n             bp = endpoint.rsplit(\".\", 1)[0]\n-            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n+            funcs = chain(funcs, self.url_default_functions[bp])\n         for func in funcs:\n             func(endpoint, values)\n \n@@ -1794,13 +1794,13 @@ class Flask(Scaffold):\n \n         bp = _request_ctx_stack.top.request.blueprint\n \n-        funcs = self.url_value_preprocessors.get(None, ())\n+        funcs = self.url_value_preprocessors[None]\n         if bp is not None and bp in self.url_value_preprocessors:\n             funcs = chain(funcs, self.url_value_preprocessors[bp])\n         for func in funcs:\n             func(request.endpoint, request.view_args)\n \n-        funcs = self.before_request_funcs.get(None, ())\n+        funcs = self.before_request_funcs[None]\n         if bp is not None and bp in self.before_request_funcs:\n             funcs = chain(funcs, self.before_request_funcs[bp])\n         for func in funcs:\n@@ -1857,7 +1857,7 @@ class Flask(Scaffold):\n         \"\"\"\n         if exc is _sentinel:\n             exc = sys.exc_info()[1]\n-        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n+        funcs = reversed(self.teardown_request_funcs[None])\n         bp = _request_ctx_stack.top.request.blueprint\n         if bp is not None and bp in self.teardown_request_funcs:\n             funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n\n@@ -251,7 +251,7 @@ class Blueprint(Scaffold):\n             \"\"\"\n             for key, values in self_dict.items():\n                 key = self.name if key is None else f\"{self.name}.{key}\"\n-                app_dict.setdefault(key, []).extend(values)\n+                app_dict[key].extend(values)\n \n         def merge_dict_nested(self_dict, app_dict):\n             \"\"\"Merges self_dict into app_dict. Replaces None keys with self.name.\n\n@@ -1,3 +1,4 @@\n+from collections import defaultdict\n from functools import update_wrapper\n \n from werkzeug.exceptions import default_exceptions\n@@ -86,21 +87,21 @@ class Scaffold(_PackageBoundObject):\n         #:\n         #: To register an error handler, use the :meth:`errorhandler`\n         #: decorator.\n-        self.error_handler_spec = {}\n+        self.error_handler_spec = defaultdict(lambda: defaultdict(dict))\n \n         #: A dictionary with lists of functions that will be called at the\n         #: beginning of each request. The key of the dictionary is the name of\n         #: the blueprint this function is active for, or ``None`` for all\n         #: requests. To register a function, use the :meth:`before_request`\n         #: decorator.\n-        self.before_request_funcs = {}\n+        self.before_request_funcs = defaultdict(list)\n \n         #: A dictionary with lists of functions that should be called after\n         #: each request.  The key of the dictionary is the name of the blueprint\n         #: this function is active for, ``None`` for all requests.  This can for\n         #: example be used to close database connections. To register a function\n         #: here, use the :meth:`after_request` decorator.\n-        self.after_request_funcs = {}\n+        self.after_request_funcs = defaultdict(list)\n \n         #: A dictionary with lists of functions that are called after\n         #: each request, even if an exception has occurred. The key of the\n@@ -112,7 +113,7 @@ class Scaffold(_PackageBoundObject):\n         #: :meth:`teardown_request` decorator.\n         #:\n         #: .. versionadded:: 0.7\n-        self.teardown_request_funcs = {}\n+        self.teardown_request_funcs = defaultdict(list)\n \n         #: A dictionary with list of functions that are called without argument\n         #: to populate the template context.  The key of the dictionary is the\n@@ -120,7 +121,9 @@ class Scaffold(_PackageBoundObject):\n         #: requests.  Each returns a dictionary that the template context is\n         #: updated with.  To register a function here, use the\n         #: :meth:`context_processor` decorator.\n-        self.template_context_processors = {None: [_default_template_ctx_processor]}\n+        self.template_context_processors = defaultdict(\n+            list, {None: [_default_template_ctx_processor]}\n+        )\n \n         #: A dictionary with lists of functions that are called before the\n         #: :attr:`before_request_funcs` functions. The key of the dictionary is\n@@ -129,7 +132,7 @@ class Scaffold(_PackageBoundObject):\n         #: :meth:`url_value_preprocessor`.\n         #:\n         #: .. versionadded:: 0.7\n-        self.url_value_preprocessors = {}\n+        self.url_value_preprocessors = defaultdict(list)\n \n         #: A dictionary with lists of functions that can be used as URL value\n         #: preprocessors.  The key ``None`` here is used for application wide\n@@ -141,7 +144,7 @@ class Scaffold(_PackageBoundObject):\n         #: automatically again that were removed that way.\n         #:\n         #: .. versionadded:: 0.7\n-        self.url_default_functions = {}\n+        self.url_default_functions = defaultdict(list)\n \n     def _is_setup_finished(self):\n         raise NotImplementedError\n@@ -258,7 +261,7 @@ class Scaffold(_PackageBoundObject):\n         non-None value, the value is handled as if it was the return value from\n         the view, and further request handling is stopped.\n         \"\"\"\n-        self.before_request_funcs.setdefault(None, []).append(f)\n+        self.before_request_funcs[None].append(f)\n         return f\n \n     @setupmethod\n@@ -272,7 +275,7 @@ class Scaffold(_PackageBoundObject):\n         As of Flask 0.7 this function might not be executed at the end of the\n         request in case an unhandled exception occurred.\n         \"\"\"\n-        self.after_request_funcs.setdefault(None, []).append(f)\n+        self.after_request_funcs[None].append(f)\n         return f\n \n     @setupmethod\n@@ -311,7 +314,7 @@ class Scaffold(_PackageBoundObject):\n            debugger can still access it.  This behavior can be controlled\n            by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n         \"\"\"\n-        self.teardown_request_funcs.setdefault(None, []).append(f)\n+        self.teardown_request_funcs[None].append(f)\n         return f\n \n     @setupmethod\n@@ -334,7 +337,7 @@ class Scaffold(_PackageBoundObject):\n         The function is passed the endpoint name and values dict. The return\n         value is ignored.\n         \"\"\"\n-        self.url_value_preprocessors.setdefault(None, []).append(f)\n+        self.url_value_preprocessors[None].append(f)\n         return f\n \n     @setupmethod\n@@ -343,7 +346,7 @@ class Scaffold(_PackageBoundObject):\n         application.  It's called with the endpoint and values and should\n         update the values passed in place.\n         \"\"\"\n-        self.url_default_functions.setdefault(None, []).append(f)\n+        self.url_default_functions[None].append(f)\n         return f\n \n     @setupmethod\n@@ -416,8 +419,7 @@ class Scaffold(_PackageBoundObject):\n                 \" instead.\"\n             )\n \n-        handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})\n-        handlers[exc_class] = f\n+        self.error_handler_spec[key][code][exc_class] = f\n \n     @staticmethod\n     def _get_exc_class_and_code(exc_class_or_code):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#83d358d2c43c79b7d7fe5365e079447296c65eaf", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 11 | Churn Cumulative: 927 | Contributors (this commit): 11 | Commits (past 90d): 7 | Contributors (cumulative): 11 | DMM Complexity: 0.0\n\nDIFF:\n@@ -430,13 +430,13 @@ class Flask(Scaffold):\n         #: .. versionadded:: 0.11\n         self.shell_context_processors = []\n \n-        #: all the attached blueprints in a dictionary by name.  Blueprints\n-        #: can be attached multiple times so this dictionary does not tell\n-        #: you how often they got attached.\n+        #: Maps registered blueprint names to blueprint objects. The\n+        #: dict retains the order the blueprints were registered in.\n+        #: Blueprints can be registered multiple times, this dict does\n+        #: not track how often they were attached.\n         #:\n         #: .. versionadded:: 0.7\n         self.blueprints = {}\n-        self._blueprint_order = []\n \n         #: a place where extensions can store application specific state.  For\n         #: example this is where an extension could store database engines and\n@@ -997,7 +997,6 @@ class Flask(Scaffold):\n             )\n         else:\n             self.blueprints[blueprint.name] = blueprint\n-            self._blueprint_order.append(blueprint)\n             first_registration = True\n \n         blueprint.register(self, options, first_registration)\n@@ -1007,7 +1006,7 @@ class Flask(Scaffold):\n \n         .. versionadded:: 0.11\n         \"\"\"\n-        return iter(self._blueprint_order)\n+        return self.blueprints.values()\n \n     @setupmethod\n     def add_url_rule(\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#33145c36991c503aeb1e5870c27b720ec80d5079", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 8 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 5 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 12 | Churn Cumulative: 1962 | Contributors (this commit): 30 | Commits (past 90d): 3 | Contributors (cumulative): 32 | DMM Complexity: 1.0\n\nDIFF:\n@@ -619,6 +619,9 @@ def load_dotenv(path=None):\n         Returns ``False`` when python-dotenv is not installed, or when\n         the given path isn't a file.\n \n+    .. versionchanged:: 2.0\n+        When loading the env files, set the default encoding to UTF-8.\n+\n     .. versionadded:: 1.0\n     \"\"\"\n     if dotenv is None:\n@@ -636,7 +639,7 @@ def load_dotenv(path=None):\n     # else False\n     if path is not None:\n         if os.path.isfile(path):\n-            return dotenv.load_dotenv(path)\n+            return dotenv.load_dotenv(path, encoding=\"utf-8\")\n \n         return False\n \n@@ -651,7 +654,7 @@ def load_dotenv(path=None):\n         if new_dir is None:\n             new_dir = os.path.dirname(path)\n \n-        dotenv.load_dotenv(path)\n+        dotenv.load_dotenv(path, encoding=\"utf-8\")\n \n     return new_dir is not None  # at least one file was located and loaded\n \n\n@@ -505,7 +505,7 @@ need_dotenv = pytest.mark.skipif(dotenv is None, reason=\"dotenv is not installed\n @need_dotenv\n def test_load_dotenv(monkeypatch):\n     # can't use monkeypatch.delitem since the keys don't exist yet\n-    for item in (\"FOO\", \"BAR\", \"SPAM\"):\n+    for item in (\"FOO\", \"BAR\", \"SPAM\", \"HAM\"):\n         monkeypatch._setitem.append((os.environ, item, notset))\n \n     monkeypatch.setenv(\"EGGS\", \"3\")\n@@ -520,7 +520,8 @@ def test_load_dotenv(monkeypatch):\n     assert os.environ[\"SPAM\"] == \"1\"\n     # set manually, files don't overwrite\n     assert os.environ[\"EGGS\"] == \"3\"\n-\n+    # test env file encoding\n+    assert os.environ[\"HAM\"] == \"火腿\"\n     # Non existent file should not load\n     assert not load_dotenv(\"non-existent-file\")\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#9f7c602a84faa8371be4ece23e4405282d1283d2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 342 | Lines Deleted: 351 | Files Changed: 3 | Hunks: 23 | Methods Changed: 33 | Complexity Δ (Sum/Max): -1/46 | Churn Δ: 693 | Churn Cumulative: 2850 | Contributors (this commit): 16 | Commits (past 90d): 13 | Contributors (cumulative): 21 | DMM Complexity: 0.23076923076923078\n\nDIFF:\n@@ -29,7 +29,6 @@ from .globals import _request_ctx_stack\n from .globals import g\n from .globals import request\n from .globals import session\n-from .helpers import find_package\n from .helpers import get_debug_flag\n from .helpers import get_env\n from .helpers import get_flashed_messages\n@@ -40,6 +39,7 @@ from .json import jsonify\n from .logging import create_logger\n from .scaffold import _endpoint_from_view_func\n from .scaffold import _sentinel\n+from .scaffold import find_package\n from .scaffold import Scaffold\n from .scaffold import setupmethod\n from .sessions import SecureCookieSessionInterface\n@@ -2026,6 +2026,3 @@ class Flask(Scaffold):\n         WSGI application. This calls :meth:`wsgi_app` which can be\n         wrapped to applying middleware.\"\"\"\n         return self.wsgi_app(environ, start_response)\n-\n-    def __repr__(self):\n-        return f\"<{type(self).__name__} {self.name!r}>\"\n\n@@ -1,13 +1,10 @@\n import os\n-import pkgutil\n import socket\n-import sys\n import warnings\n from functools import update_wrapper\n from threading import RLock\n \n import werkzeug.utils\n-from jinja2 import FileSystemLoader\n from werkzeug.exceptions import NotFound\n from werkzeug.routing import BuildError\n from werkzeug.urls import url_quote\n@@ -677,157 +674,6 @@ def send_from_directory(directory, path, **kwargs):\n     )\n \n \n-def get_root_path(import_name):\n-    \"\"\"Returns the path to a package or cwd if that cannot be found.  This\n-    returns the path of a package or the folder that contains a module.\n-\n-    Not to be confused with the package path returned by :func:`find_package`.\n-    \"\"\"\n-    # Module already imported and has a file attribute.  Use that first.\n-    mod = sys.modules.get(import_name)\n-    if mod is not None and hasattr(mod, \"__file__\"):\n-        return os.path.dirname(os.path.abspath(mod.__file__))\n-\n-    # Next attempt: check the loader.\n-    loader = pkgutil.get_loader(import_name)\n-\n-    # Loader does not exist or we're referring to an unloaded main module\n-    # or a main module without path (interactive sessions), go with the\n-    # current working directory.\n-    if loader is None or import_name == \"__main__\":\n-        return os.getcwd()\n-\n-    if hasattr(loader, \"get_filename\"):\n-        filepath = loader.get_filename(import_name)\n-    else:\n-        # Fall back to imports.\n-        __import__(import_name)\n-        mod = sys.modules[import_name]\n-        filepath = getattr(mod, \"__file__\", None)\n-\n-        # If we don't have a filepath it might be because we are a\n-        # namespace package.  In this case we pick the root path from the\n-        # first module that is contained in our package.\n-        if filepath is None:\n-            raise RuntimeError(\n-                \"No root path can be found for the provided module\"\n-                f\" {import_name!r}. This can happen because the module\"\n-                \" came from an import hook that does not provide file\"\n-                \" name information or because it's a namespace package.\"\n-                \" In this case the root path needs to be explicitly\"\n-                \" provided.\"\n-            )\n-\n-    # filepath is import_name.py for a module, or __init__.py for a package.\n-    return os.path.dirname(os.path.abspath(filepath))\n-\n-\n-def _matching_loader_thinks_module_is_package(loader, mod_name):\n-    \"\"\"Given the loader that loaded a module and the module this function\n-    attempts to figure out if the given module is actually a package.\n-    \"\"\"\n-    cls = type(loader)\n-    # If the loader can tell us if something is a package, we can\n-    # directly ask the loader.\n-    if hasattr(loader, \"is_package\"):\n-        return loader.is_package(mod_name)\n-    # importlib's namespace loaders do not have this functionality but\n-    # all the modules it loads are packages, so we can take advantage of\n-    # this information.\n-    elif cls.__module__ == \"_frozen_importlib\" and cls.__name__ == \"NamespaceLoader\":\n-        return True\n-    # Otherwise we need to fail with an error that explains what went\n-    # wrong.\n-    raise AttributeError(\n-        f\"{cls.__name__}.is_package() method is missing but is required\"\n-        \" for PEP 302 import hooks.\"\n-    )\n-\n-\n-def _find_package_path(root_mod_name):\n-    \"\"\"Find the path where the module's root exists in\"\"\"\n-    import importlib.util\n-\n-    try:\n-        spec = importlib.util.find_spec(root_mod_name)\n-        if spec is None:\n-            raise ValueError(\"not found\")\n-    # ImportError: the machinery told us it does not exist\n-    # ValueError:\n-    #    - the module name was invalid\n-    #    - the module name is __main__\n-    #    - *we* raised `ValueError` due to `spec` being `None`\n-    except (ImportError, ValueError):\n-        pass  # handled below\n-    else:\n-        # namespace package\n-        if spec.origin in {\"namespace\", None}:\n-            return os.path.dirname(next(iter(spec.submodule_search_locations)))\n-        # a package (with __init__.py)\n-        elif spec.submodule_search_locations:\n-            return os.path.dirname(os.path.dirname(spec.origin))\n-        # just a normal module\n-        else:\n-            return os.path.dirname(spec.origin)\n-\n-    # we were unable to find the `package_path` using PEP 451 loaders\n-    loader = pkgutil.get_loader(root_mod_name)\n-    if loader is None or root_mod_name == \"__main__\":\n-        # import name is not found, or interactive/main module\n-        return os.getcwd()\n-    else:\n-        if hasattr(loader, \"get_filename\"):\n-            filename = loader.get_filename(root_mod_name)\n-        elif hasattr(loader, \"archive\"):\n-            # zipimporter's loader.archive points to the .egg or .zip\n-            # archive filename is dropped in call to dirname below.\n-            filename = loader.archive\n-        else:\n-            # At least one loader is missing both get_filename and archive:\n-            # Google App Engine's HardenedModulesHook\n-            #\n-            # Fall back to imports.\n-            __import__(root_mod_name)\n-            filename = sys.modules[root_mod_name].__file__\n-        package_path = os.path.abspath(os.path.dirname(filename))\n-\n-        # In case the root module is a package we need to chop of the\n-        # rightmost part. This needs to go through a helper function\n-        # because of namespace packages.\n-        if _matching_loader_thinks_module_is_package(loader, root_mod_name):\n-            package_path = os.path.dirname(package_path)\n-\n-    return package_path\n-\n-\n-def find_package(import_name):\n-    \"\"\"Finds a package and returns the prefix (or None if the package is\n-    not installed) as well as the folder that contains the package or\n-    module as a tuple.  The package path returned is the module that would\n-    have to be added to the pythonpath in order to make it possible to\n-    import the module.  The prefix is the path below which a UNIX like\n-    folder structure exists (lib, share etc.).\n-    \"\"\"\n-    root_mod_name, _, _ = import_name.partition(\".\")\n-    package_path = _find_package_path(root_mod_name)\n-    site_parent, site_folder = os.path.split(package_path)\n-    py_prefix = os.path.abspath(sys.prefix)\n-    if package_path.startswith(py_prefix):\n-        return py_prefix, package_path\n-    elif site_folder.lower() == \"site-packages\":\n-        parent, folder = os.path.split(site_parent)\n-        # Windows like installations\n-        if folder.lower() == \"lib\":\n-            base_dir = parent\n-        # UNIX like installations\n-        elif os.path.basename(parent).lower() == \"lib\":\n-            base_dir = os.path.dirname(parent)\n-        else:\n-            base_dir = site_parent\n-        return base_dir, package_path\n-    return None, package_path\n-\n-\n class locked_cached_property:\n     \"\"\"A decorator that converts a function into a lazy property.  The\n     function wrapped is called the first time to retrieve the result\n@@ -854,155 +700,6 @@ class locked_cached_property:\n             return value\n \n \n-class _PackageBoundObject:\n-    #: The name of the package or module that this app belongs to. Do not\n-    #: change this once it is set by the constructor.\n-    import_name = None\n-\n-    #: Location of the template files to be added to the template lookup.\n-    #: ``None`` if templates should not be added.\n-    template_folder = None\n-\n-    #: Absolute path to the package on the filesystem. Used to look up\n-    #: resources contained in the package.\n-    root_path = None\n-\n-    def __init__(self, import_name, template_folder=None, root_path=None):\n-        self.import_name = import_name\n-        self.template_folder = template_folder\n-\n-        if root_path is None:\n-            root_path = get_root_path(self.import_name)\n-\n-        self.root_path = root_path\n-        self._static_folder = None\n-        self._static_url_path = None\n-\n-        # circular import\n-        from .cli import AppGroup\n-\n-        #: The Click command group for registration of CLI commands\n-        #: on the application and associated blueprints. These commands\n-        #: are accessible via the :command:`flask` command once the\n-        #: application has been discovered and blueprints registered.\n-        self.cli = AppGroup()\n-\n-    @property\n-    def static_folder(self):\n-        \"\"\"The absolute path to the configured static folder.\"\"\"\n-        if self._static_folder is not None:\n-            return os.path.join(self.root_path, self._static_folder)\n-\n-    @static_folder.setter\n-    def static_folder(self, value):\n-        if value is not None:\n-            value = os.fspath(value).rstrip(r\"\\/\")\n-        self._static_folder = value\n-\n-    @property\n-    def static_url_path(self):\n-        \"\"\"The URL prefix that the static route will be accessible from.\n-\n-        If it was not configured during init, it is derived from\n-        :attr:`static_folder`.\n-        \"\"\"\n-        if self._static_url_path is not None:\n-            return self._static_url_path\n-\n-        if self.static_folder is not None:\n-            basename = os.path.basename(self.static_folder)\n-            return f\"/{basename}\".rstrip(\"/\")\n-\n-    @static_url_path.setter\n-    def static_url_path(self, value):\n-        if value is not None:\n-            value = value.rstrip(\"/\")\n-\n-        self._static_url_path = value\n-\n-    @property\n-    def has_static_folder(self):\n-        \"\"\"This is ``True`` if the package bound object's container has a\n-        folder for static files.\n-\n-        .. versionadded:: 0.5\n-        \"\"\"\n-        return self.static_folder is not None\n-\n-    @locked_cached_property\n-    def jinja_loader(self):\n-        \"\"\"The Jinja loader for this package bound object.\n-\n-        .. versionadded:: 0.5\n-        \"\"\"\n-        if self.template_folder is not None:\n-            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))\n-\n-    def get_send_file_max_age(self, filename):\n-        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n-        value for a given file path if it wasn't passed.\n-\n-        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n-        the configuration of :data:`~flask.current_app`. This defaults\n-        to ``None``, which tells the browser to use conditional requests\n-        instead of a timed cache, which is usually preferable.\n-\n-        .. versionchanged:: 2.0\n-            The default configuration is ``None`` instead of 12 hours.\n-\n-        .. versionadded:: 0.9\n-        \"\"\"\n-        value = current_app.send_file_max_age_default\n-\n-        if value is None:\n-            return None\n-\n-        return total_seconds(value)\n-\n-    def send_static_file(self, filename):\n-        \"\"\"Function used internally to send static files from the static\n-        folder to the browser.\n-\n-        .. versionadded:: 0.5\n-        \"\"\"\n-        if not self.has_static_folder:\n-            raise RuntimeError(\"No static folder for this object\")\n-\n-        # send_file only knows to call get_send_file_max_age on the app,\n-        # call it here so it works for blueprints too.\n-        max_age = self.get_send_file_max_age(filename)\n-        return send_from_directory(self.static_folder, filename, max_age=max_age)\n-\n-    def open_resource(self, resource, mode=\"rb\"):\n-        \"\"\"Opens a resource from the application's resource folder.  To see\n-        how this works, consider the following folder structure::\n-\n-            /myapplication.py\n-            /schema.sql\n-            /static\n-                /style.css\n-            /templates\n-                /layout.html\n-                /index.html\n-\n-        If you want to open the :file:`schema.sql` file you would do the\n-        following::\n-\n-            with app.open_resource('schema.sql') as f:\n-                contents = f.read()\n-                do_something_with(contents)\n-\n-        :param resource: the name of the resource.  To access resources within\n-                         subfolders use forward slashes as separator.\n-        :param mode: Open file in this mode. Only reading is supported,\n-            valid values are \"r\" (or \"rt\") and \"rb\".\n-        \"\"\"\n-        if mode not in {\"r\", \"rt\", \"rb\"}:\n-            raise ValueError(\"Resources can only be opened for reading\")\n-\n-        return open(os.path.join(self.root_path, resource), mode)\n-\n-\n def total_seconds(td):\n     \"\"\"Returns the total seconds from a timedelta object.\n \n\n@@ -1,10 +1,17 @@\n+import os\n+import pkgutil\n+import sys\n from collections import defaultdict\n from functools import update_wrapper\n \n+from jinja2 import FileSystemLoader\n from werkzeug.exceptions import default_exceptions\n from werkzeug.exceptions import HTTPException\n \n-from .helpers import _PackageBoundObject\n+from .cli import AppGroup\n+from .globals import current_app\n+from .helpers import locked_cached_property\n+from .helpers import send_from_directory\n from .templating import _default_template_ctx_processor\n \n # a singleton sentinel value for parameter defaults\n@@ -19,21 +26,28 @@ def setupmethod(f):\n     def wrapper_func(self, *args, **kwargs):\n         if self._is_setup_finished():\n             raise AssertionError(\n-                \"A setup function was called after the \"\n-                \"first request was handled.  This usually indicates a bug \"\n-                \"in the application where a module was not imported \"\n-                \"and decorators or other functionality was called too late.\\n\"\n-                \"To fix this make sure to import all your view modules, \"\n-                \"database models and everything related at a central place \"\n-                \"before the application starts serving requests.\"\n+                \"A setup function was called after the first request \"\n+                \"was handled. This usually indicates a bug in the\"\n+                \" application where a module was not imported and\"\n+                \" decorators or other functionality was called too\"\n+                \" late.\\nTo fix this make sure to import all your view\"\n+                \" modules, database models, and everything related at a\"\n+                \" central place before the application starts serving\"\n+                \" requests.\"\n             )\n         return f(self, *args, **kwargs)\n \n     return update_wrapper(wrapper_func, f)\n \n \n-class Scaffold(_PackageBoundObject):\n-    \"\"\"A common base for class Flask and class Blueprint.\"\"\"\n+class Scaffold:\n+    \"\"\"A common base for :class:`~flask.app.Flask` and\n+    :class:`~flask.blueprints.Blueprint`.\n+    \"\"\"\n+\n+    name: str\n+    _static_folder = None\n+    _static_url_path = None\n \n     #: Skeleton local JSON decoder class to use.\n     #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_encoder`.\n@@ -43,18 +57,6 @@ class Scaffold(_PackageBoundObject):\n     #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_decoder`.\n     json_decoder = None\n \n-    #: The name of the package or module that this app belongs to. Do not\n-    #: change this once it is set by the constructor.\n-    import_name = None\n-\n-    #: Location of the template files to be added to the template lookup.\n-    #: ``None`` if templates should not be added.\n-    template_folder = None\n-\n-    #: Absolute path to the package on the filesystem. Used to look up\n-    #: resources contained in the package.\n-    root_path = None\n-\n     def __init__(\n         self,\n         import_name,\n@@ -63,14 +65,31 @@ class Scaffold(_PackageBoundObject):\n         template_folder=None,\n         root_path=None,\n     ):\n-        super().__init__(\n-            import_name=import_name,\n-            template_folder=template_folder,\n-            root_path=root_path,\n-        )\n+        #: The name of the package or module that this object belongs\n+        #: to. Do not change this once it is set by the constructor.\n+        self.import_name = import_name\n+\n         self.static_folder = static_folder\n         self.static_url_path = static_url_path\n \n+        #: The path to the templates folder, relative to\n+        #: :attr:`root_path`, to add to the template loader. ``None`` if\n+        #: templates should not be added.\n+        self.template_folder = template_folder\n+\n+        if root_path is None:\n+            root_path = get_root_path(self.import_name)\n+\n+        #: Absolute path to the package on the filesystem. Used to look\n+        #: up resources contained in the package.\n+        self.root_path = root_path\n+\n+        #: The Click command group for registering CLI commands for this\n+        #: object. The commands are available from the ``flask`` command\n+        #: once the application has been discovered and blueprints have\n+        #: been registered.\n+        self.cli = AppGroup()\n+\n         #: A dictionary of all view functions registered.  The keys will\n         #: be function names which are also used to generate URLs and\n         #: the values are the function objects themselves.\n@@ -146,9 +165,127 @@ class Scaffold(_PackageBoundObject):\n         #: .. versionadded:: 0.7\n         self.url_default_functions = defaultdict(list)\n \n+    def __repr__(self):\n+        return f\"<{type(self).__name__} {self.name!r}>\"\n+\n     def _is_setup_finished(self):\n         raise NotImplementedError\n \n+    @property\n+    def static_folder(self):\n+        \"\"\"The absolute path to the configured static folder. ``None``\n+        if no static folder is set.\n+        \"\"\"\n+        if self._static_folder is not None:\n+            return os.path.join(self.root_path, self._static_folder)\n+\n+    @static_folder.setter\n+    def static_folder(self, value):\n+        if value is not None:\n+            value = os.fspath(value).rstrip(r\"\\/\")\n+\n+        self._static_folder = value\n+\n+    @property\n+    def has_static_folder(self):\n+        \"\"\"``True`` if :attr:`static_folder` is set.\n+\n+        .. versionadded:: 0.5\n+        \"\"\"\n+        return self.static_folder is not None\n+\n+    @property\n+    def static_url_path(self):\n+        \"\"\"The URL prefix that the static route will be accessible from.\n+\n+        If it was not configured during init, it is derived from\n+        :attr:`static_folder`.\n+        \"\"\"\n+        if self._static_url_path is not None:\n+            return self._static_url_path\n+\n+        if self.static_folder is not None:\n+            basename = os.path.basename(self.static_folder)\n+            return f\"/{basename}\".rstrip(\"/\")\n+\n+    @static_url_path.setter\n+    def static_url_path(self, value):\n+        if value is not None:\n+            value = value.rstrip(\"/\")\n+\n+        self._static_url_path = value\n+\n+    def get_send_file_max_age(self, filename):\n+        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n+        value for a given file path if it wasn't passed.\n+\n+        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n+        the configuration of :data:`~flask.current_app`. This defaults\n+        to ``None``, which tells the browser to use conditional requests\n+        instead of a timed cache, which is usually preferable.\n+\n+        .. versionchanged:: 2.0\n+            The default configuration is ``None`` instead of 12 hours.\n+\n+        .. versionadded:: 0.9\n+        \"\"\"\n+        value = current_app.send_file_max_age_default\n+\n+        if value is None:\n+            return None\n+\n+        return int(value.total_seconds())\n+\n+    def send_static_file(self, filename):\n+        \"\"\"The view function used to serve files from\n+        :attr:`static_folder`. A route is automatically registered for\n+        this view at :attr:`static_url_path` if :attr:`static_folder` is\n+        set.\n+\n+        .. versionadded:: 0.5\n+        \"\"\"\n+        if not self.has_static_folder:\n+            raise RuntimeError(\"'static_folder' must be set to serve static_files.\")\n+\n+        # send_file only knows to call get_send_file_max_age on the app,\n+        # call it here so it works for blueprints too.\n+        max_age = self.get_send_file_max_age(filename)\n+        return send_from_directory(self.static_folder, filename, max_age=max_age)\n+\n+    @locked_cached_property\n+    def jinja_loader(self):\n+        \"\"\"The Jinja loader for this object's templates. By default this\n+        is a class :class:`jinja2.loaders.FileSystemLoader` to\n+        :attr:`template_folder` if it is set.\n+\n+        .. versionadded:: 0.5\n+        \"\"\"\n+        if self.template_folder is not None:\n+            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))\n+\n+    def open_resource(self, resource, mode=\"rb\"):\n+        \"\"\"Open a resource file relative to :attr:`root_path` for\n+        reading.\n+\n+        For example, if the file ``schema.sql`` is next to the file\n+        ``app.py`` where the ``Flask`` app is defined, it can be opened\n+        with:\n+\n+        .. code-block:: python\n+\n+            with app.open_resource(\"schema.sql\") as f:\n+                conn.executescript(f.read())\n+\n+        :param resource: Path to the resource relative to\n+            :attr:`root_path`.\n+        :param mode: Open the file in this mode. Only reading is\n+            supported, valid values are \"r\" (or \"rt\") and \"rb\".\n+        \"\"\"\n+        if mode not in {\"r\", \"rt\", \"rb\"}:\n+            raise ValueError(\"Resources can only be opened for reading.\")\n+\n+        return open(os.path.join(self.root_path, resource), mode)\n+\n     def _method_route(self, method, rule, options):\n         if \"methods\" in options:\n             raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n@@ -193,26 +330,18 @@ class Scaffold(_PackageBoundObject):\n     def route(self, rule, **options):\n         \"\"\"A decorator that is used to register a view function for a\n         given URL rule. This does the same thing as :meth:`add_url_rule`\n-        but is intended for decorator usage::\n+        but is used as a decorator. See :meth:`add_url_rule` and\n+        :ref:`url-route-registrations` for more information.\n \n-            @app.route('/')\n+        .. code-block:: python\n+\n+            @app.route(\"/\")\n             def index():\n-                return 'Hello World'\n+                return \"Hello World\"\n \n-        For more information refer to :ref:`url-route-registrations`.\n-\n-        :param rule: the URL rule as string\n-        :param endpoint: the endpoint for the registered URL rule.  Flask\n-                         itself assumes the name of the view function as\n-                         endpoint\n-        :param options: the options to be forwarded to the underlying\n-                        :class:`~werkzeug.routing.Rule` object.  A change\n-                        to Werkzeug is handling of method options.  methods\n-                        is a list of methods this rule should be limited\n-                        to (``GET``, ``POST`` etc.).  By default a rule\n-                        just listens for ``GET`` (and implicitly ``HEAD``).\n-                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n-                        added and handled by the standard request handling.\n+        :param rule: The URL rule as a string.\n+        :param options: The options to be forwarded to the underlying\n+            :class:`~werkzeug.routing.Rule` object.\n         \"\"\"\n \n         def decorator(f):\n@@ -451,3 +580,171 @@ def _endpoint_from_view_func(view_func):\n     \"\"\"\n     assert view_func is not None, \"expected view func if endpoint is not provided.\"\n     return view_func.__name__\n+\n+\n+def get_root_path(import_name):\n+    \"\"\"Find the root path of a package, or the path that contains a\n+    module. If it cannot be found, returns the current working\n+    directory.\n+\n+    Not to be confused with the value returned by :func:`find_package`.\n+\n+    :meta private:\n+    \"\"\"\n+    # Module already imported and has a file attribute. Use that first.\n+    mod = sys.modules.get(import_name)\n+\n+    if mod is not None and hasattr(mod, \"__file__\"):\n+        return os.path.dirname(os.path.abspath(mod.__file__))\n+\n+    # Next attempt: check the loader.\n+    loader = pkgutil.get_loader(import_name)\n+\n+    # Loader does not exist or we're referring to an unloaded main\n+    # module or a main module without path (interactive sessions), go\n+    # with the current working directory.\n+    if loader is None or import_name == \"__main__\":\n+        return os.getcwd()\n+\n+    if hasattr(loader, \"get_filename\"):\n+        filepath = loader.get_filename(import_name)\n+    else:\n+        # Fall back to imports.\n+        __import__(import_name)\n+        mod = sys.modules[import_name]\n+        filepath = getattr(mod, \"__file__\", None)\n+\n+        # If we don't have a file path it might be because it is a\n+        # namespace package. In this case pick the root path from the\n+        # first module that is contained in the package.\n+        if filepath is None:\n+            raise RuntimeError(\n+                \"No root path can be found for the provided module\"\n+                f\" {import_name!r}. This can happen because the module\"\n+                \" came from an import hook that does not provide file\"\n+                \" name information or because it's a namespace package.\"\n+                \" In this case the root path needs to be explicitly\"\n+                \" provided.\"\n+            )\n+\n+    # filepath is import_name.py for a module, or __init__.py for a package.\n+    return os.path.dirname(os.path.abspath(filepath))\n+\n+\n+def _matching_loader_thinks_module_is_package(loader, mod_name):\n+    \"\"\"Attempt to figure out if the given name is a package or a module.\n+\n+    :param: loader: The loader that handled the name.\n+    :param mod_name: The name of the package or module.\n+    \"\"\"\n+    # Use loader.is_package if it's available.\n+    if hasattr(loader, \"is_package\"):\n+        return loader.is_package(mod_name)\n+\n+    cls = type(loader)\n+\n+    # NamespaceLoader doesn't implement is_package, but all names it\n+    # loads must be packages.\n+    if cls.__module__ == \"_frozen_importlib\" and cls.__name__ == \"NamespaceLoader\":\n+        return True\n+\n+    # Otherwise we need to fail with an error that explains what went\n+    # wrong.\n+    raise AttributeError(\n+        f\"'{cls.__name__}.is_package()' must be implemented for PEP 302\"\n+        f\" import hooks.\"\n+    )\n+\n+\n+def _find_package_path(root_mod_name):\n+    \"\"\"Find the path that contains the package or module.\"\"\"\n+    try:\n+        spec = importlib.util.find_spec(root_mod_name)\n+\n+        if spec is None:\n+            raise ValueError(\"not found\")\n+    # ImportError: the machinery told us it does not exist\n+    # ValueError:\n+    #    - the module name was invalid\n+    #    - the module name is __main__\n+    #    - *we* raised `ValueError` due to `spec` being `None`\n+    except (ImportError, ValueError):\n+        pass  # handled below\n+    else:\n+        # namespace package\n+        if spec.origin in {\"namespace\", None}:\n+            return os.path.dirname(next(iter(spec.submodule_search_locations)))\n+        # a package (with __init__.py)\n+        elif spec.submodule_search_locations:\n+            return os.path.dirname(os.path.dirname(spec.origin))\n+        # just a normal module\n+        else:\n+            return os.path.dirname(spec.origin)\n+\n+    # we were unable to find the `package_path` using PEP 451 loaders\n+    loader = pkgutil.get_loader(root_mod_name)\n+\n+    if loader is None or root_mod_name == \"__main__\":\n+        # import name is not found, or interactive/main module\n+        return os.getcwd()\n+\n+    if hasattr(loader, \"get_filename\"):\n+        filename = loader.get_filename(root_mod_name)\n+    elif hasattr(loader, \"archive\"):\n+        # zipimporter's loader.archive points to the .egg or .zip file.\n+        filename = loader.archive\n+    else:\n+        # At least one loader is missing both get_filename and archive:\n+        # Google App Engine's HardenedModulesHook, use __file__.\n+        filename = importlib.import_module(root_mod_name).__file__\n+\n+    package_path = os.path.abspath(os.path.dirname(filename))\n+\n+    # If the imported name is a package, filename is currently pointing\n+    # to the root of the package, need to get the current directory.\n+    if _matching_loader_thinks_module_is_package(loader, root_mod_name):\n+        package_path = os.path.dirname(package_path)\n+\n+    return package_path\n+\n+\n+def find_package(import_name):\n+    \"\"\"Find the prefix that a package is installed under, and the path\n+    that it would be imported from.\n+\n+    The prefix is the directory containing the standard directory\n+    hierarchy (lib, bin, etc.). If the package is not installed to the\n+    system (:attr:`sys.prefix`) or a virtualenv (``site-packages``),\n+    ``None`` is returned.\n+\n+    The path is the entry in :attr:`sys.path` that contains the package\n+    for import. If the package is not installed, it's assumed that the\n+    package was imported from the current working directory.\n+    \"\"\"\n+    root_mod_name, _, _ = import_name.partition(\".\")\n+    package_path = _find_package_path(root_mod_name)\n+    py_prefix = os.path.abspath(sys.prefix)\n+\n+    # installed to the system\n+    if package_path.startswith(py_prefix):\n+        return py_prefix, package_path\n+\n+    site_parent, site_folder = os.path.split(package_path)\n+\n+    # installed to a virtualenv\n+    if site_folder.lower() == \"site-packages\":\n+        parent, folder = os.path.split(site_parent)\n+\n+        # Windows (prefix/lib/site-packages)\n+        if folder.lower() == \"lib\":\n+            return parent, package_path\n+\n+        # Unix (prefix/lib/pythonX.Y/site-packages)\n+        if os.path.basename(parent).lower() == \"lib\":\n+            return os.path.dirname(parent), package_path\n+\n+        # something else (prefix/site-packages)\n+        return site_parent, package_path\n+\n+    # not installed\n+    return None, package_path\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
