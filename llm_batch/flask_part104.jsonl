{"custom_id": "flask#ab1fbef29a073fe5950ea2357f6a3a0d280eb506", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 411 | Contributors (this commit): 8 | Commits (past 90d): 1 | Contributors (cumulative): 8 | DMM Complexity: 1.0\n\nDIFF:\n@@ -18,6 +18,7 @@ def _standard_os_environ():\n     \"\"\"\n     mp = monkeypatch.MonkeyPatch()\n     out = (\n+        (os.environ, \"FLASK_ENV_FILE\", monkeypatch.notset),\n         (os.environ, \"FLASK_APP\", monkeypatch.notset),\n         (os.environ, \"FLASK_ENV\", monkeypatch.notset),\n         (os.environ, \"FLASK_DEBUG\", monkeypatch.notset),\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#c9e000b9cea2e117218d460874d86301fbb43c43", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 53 | Lines Deleted: 11 | Files Changed: 3 | Hunks: 13 | Methods Changed: 10 | Complexity Δ (Sum/Max): 6/3 | Churn Δ: 64 | Churn Cumulative: 2878 | Contributors (this commit): 39 | Commits (past 90d): 14 | Contributors (cumulative): 47 | DMM Complexity: 1.0\n\nDIFF:\n@@ -3,7 +3,6 @@ import sqlite3\n import click\n from flask import current_app\n from flask import g\n-from flask.cli import with_appcontext\n \n \n def get_db():\n@@ -39,7 +38,6 @@ def init_db():\n \n \n @click.command(\"init-db\")\n-@with_appcontext\n def init_db_command():\n     \"\"\"Clear existing data and create new tables.\"\"\"\n     init_db()\n\n@@ -410,14 +410,24 @@ pass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)\n \n def with_appcontext(f):\n     \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n-    script's application context.  If callbacks are registered directly\n-    to the ``app.cli`` object then they are wrapped with this function\n-    by default unless it's disabled.\n+    script's application context.\n+\n+    Custom commands (and their options) registered under ``app.cli`` or\n+    ``blueprint.cli`` will always have an app context available, this\n+    decorator is not required in that case.\n+\n+    .. versionchanged:: 2.2\n+        The app context is active for subcommands as well as the\n+        decorated callback. The app context is always available to\n+        ``app.cli`` command and parameter callbacks.\n     \"\"\"\n \n     @click.pass_context\n     def decorator(__ctx, *args, **kwargs):\n-        with __ctx.ensure_object(ScriptInfo).load_app().app_context():\n+        if not current_app:\n+            app = __ctx.ensure_object(ScriptInfo).load_app()\n+            __ctx.with_resource(app.app_context())\n+\n         return __ctx.invoke(f, *args, **kwargs)\n \n     return update_wrapper(decorator, f)\n@@ -587,6 +597,10 @@ class FlaskGroup(AppGroup):\n         Added the ``-A/--app``, ``-E/--env``, ``--debug/--no-debug``,\n         and ``-e/--env-file`` options.\n \n+    .. versionchanged:: 2.2\n+        An app context is pushed when running ``app.cli`` commands, so\n+        ``@with_appcontext`` is no longer required for those commands.\n+\n     .. versionchanged:: 1.0\n         If installed, python-dotenv will be used to load environment variables\n         from :file:`.env` and :file:`.flaskenv` files.\n@@ -660,9 +674,18 @@ class FlaskGroup(AppGroup):\n         # Look up commands provided by the app, showing an error and\n         # continuing if the app couldn't be loaded.\n         try:\n-            return info.load_app().cli.get_command(ctx, name)\n+            app = info.load_app()\n         except NoAppException as e:\n             click.secho(f\"Error: {e.format_message()}\\n\", err=True, fg=\"red\")\n+            return None\n+\n+        # Push an app context for the loaded app unless it is already\n+        # active somehow. This makes the context available to parameter\n+        # and command callbacks without needing @with_appcontext.\n+        if not current_app or current_app._get_current_object() is not app:\n+            ctx.with_resource(app.app_context())\n+\n+        return app.cli.get_command(ctx, name)\n \n     def list_commands(self, ctx):\n         self._load_plugin_commands()\n\n@@ -13,6 +13,7 @@ import pytest\n from _pytest.monkeypatch import notset\n from click.testing import CliRunner\n \n+from flask import _app_ctx_stack\n from flask import Blueprint\n from flask import current_app\n from flask import Flask\n@@ -310,6 +311,26 @@ def test_lazy_load_error(monkeypatch):\n             lazy._flush_bg_loading_exception()\n \n \n+def test_app_cli_has_app_context(app, runner):\n+    def _param_cb(ctx, param, value):\n+        # current_app should be available in parameter callbacks\n+        return bool(current_app)\n+\n+    @app.cli.command()\n+    @click.argument(\"value\", callback=_param_cb)\n+    def check(value):\n+        app = click.get_current_context().obj.load_app()\n+        # the loaded app should be the same as current_app\n+        same_app = current_app._get_current_object() is app\n+        # only one app context should be pushed\n+        stack_size = len(_app_ctx_stack._local.stack)\n+        return same_app, stack_size, value\n+\n+    cli = FlaskGroup(create_app=lambda: app)\n+    result = runner.invoke(cli, [\"check\", \"x\"], standalone_mode=False)\n+    assert result.return_value == (True, 1, True)\n+\n+\n def test_with_appcontext(runner):\n     @click.command()\n     @with_appcontext\n@@ -323,12 +344,12 @@ def test_with_appcontext(runner):\n     assert result.output == \"testapp\\n\"\n \n \n-def test_appgroup(runner):\n+def test_appgroup_app_context(runner):\n     @click.group(cls=AppGroup)\n     def cli():\n         pass\n \n-    @cli.command(with_appcontext=True)\n+    @cli.command()\n     def test():\n         click.echo(current_app.name)\n \n@@ -336,7 +357,7 @@ def test_appgroup(runner):\n     def subgroup():\n         pass\n \n-    @subgroup.command(with_appcontext=True)\n+    @subgroup.command()\n     def test2():\n         click.echo(current_app.name)\n \n@@ -351,7 +372,7 @@ def test_appgroup(runner):\n     assert result.output == \"testappgroup\\n\"\n \n \n-def test_flaskgroup(runner):\n+def test_flaskgroup_app_context(runner):\n     def create_app():\n         return Flask(\"flaskgroup\")\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ed42e9292811a95f2a68e06a9ae50cb5872216a3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 5 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 8 | Churn Cumulative: 4849 | Contributors (this commit): 49 | Commits (past 90d): 8 | Contributors (cumulative): 53 | DMM Complexity: None\n\nDIFF:\n@@ -3,6 +3,7 @@ import typing as t\n import warnings\n from collections.abc import MutableMapping\n from datetime import datetime\n+from datetime import timezone\n \n from itsdangerous import BadSignature\n from itsdangerous import URLSafeTimedSerializer\n@@ -277,7 +278,7 @@ class SessionInterface:\n         lifetime configured on the application.\n         \"\"\"\n         if session.permanent:\n-            return datetime.utcnow() + app.permanent_session_lifetime\n+            return datetime.now(timezone.utc) + app.permanent_session_lifetime\n         return None\n \n     def should_set_cookie(self, app: \"Flask\", session: SessionMixin) -> bool:\n\n@@ -5,6 +5,7 @@ import uuid\n import warnings\n import weakref\n from datetime import datetime\n+from datetime import timezone\n from platform import python_implementation\n from threading import Thread\n \n@@ -436,7 +437,7 @@ def test_session_expiration(app, client):\n     assert \"set-cookie\" in rv.headers\n     match = re.search(r\"(?i)\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n     expires = parse_date(match.group())\n-    expected = datetime.utcnow() + app.permanent_session_lifetime\n+    expected = datetime.now(timezone.utc) + app.permanent_session_lifetime\n     assert expires.year == expected.year\n     assert expires.month == expected.month\n     assert expires.day == expected.day\n@@ -466,7 +467,7 @@ def test_session_stored_last(app, client):\n \n \n def test_session_special_types(app, client):\n-    now = datetime.utcnow().replace(microsecond=0)\n+    now = datetime.now(timezone.utc).replace(microsecond=0)\n     the_uuid = uuid.uuid4()\n \n     @app.route(\"/\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#762382e436062183b1e1fa6f3bda594090a452e7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 46 | Lines Deleted: 2 | Files Changed: 4 | Hunks: 10 | Methods Changed: 7 | Complexity Δ (Sum/Max): 10/8 | Churn Δ: 48 | Churn Cumulative: 7086 | Contributors (this commit): 68 | Commits (past 90d): 33 | Contributors (cumulative): 80 | DMM Complexity: 0.6153846153846154\n\nDIFF:\n@@ -5,6 +5,7 @@ import os\n import sys\n import typing as t\n import weakref\n+from collections.abc import Iterator as _abc_Iterator\n from datetime import timedelta\n from itertools import chain\n from threading import Lock\n@@ -1843,6 +1844,10 @@ class Flask(Scaffold):\n             ``dict``\n                 A dictionary that will be jsonify'd before being returned.\n \n+            ``generator`` or ``iterator``\n+                A generator that returns ``str`` or ``bytes`` to be\n+                streamed as the response.\n+\n             ``tuple``\n                 Either ``(body, status, headers)``, ``(body, status)``, or\n                 ``(body, headers)``, where ``body`` is any of the other types\n@@ -1862,6 +1867,12 @@ class Flask(Scaffold):\n                 The function is called as a WSGI application. The result is\n                 used to create a response object.\n \n+        .. versionchanged:: 2.2\n+            A generator will be converted to a streaming response.\n+\n+        .. versionchanged:: 1.1\n+            A dict will be converted to a JSON response.\n+\n         .. versionchanged:: 0.9\n            Previously a tuple was interpreted as the arguments for the\n            response object.\n@@ -1900,7 +1911,7 @@ class Flask(Scaffold):\n \n         # make sure the body is an instance of the response class\n         if not isinstance(rv, self.response_class):\n-            if isinstance(rv, (str, bytes, bytearray)):\n+            if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, _abc_Iterator):\n                 # let the response class set the status and headers instead of\n                 # waiting to do it manually, so that the class can handle any\n                 # special logic\n\n@@ -6,7 +6,9 @@ if t.TYPE_CHECKING:  # pragma: no cover\n     from werkzeug.wrappers import Response  # noqa: F401\n \n # The possible types that are directly convertible or are a Response object.\n-ResponseValue = t.Union[\"Response\", str, bytes, t.Dict[str, t.Any]]\n+ResponseValue = t.Union[\n+    \"Response\", str, bytes, t.Dict[str, t.Any], t.Iterator[str], t.Iterator[bytes]\n+]\n \n # the possible types for an individual HTTP header\n # This should be a Union, but mypy doesn't pass unless it's a TypeVar.\n\n@@ -1276,6 +1276,11 @@ def test_make_response(app, req_ctx):\n     assert rv.data == b\"W00t\"\n     assert rv.mimetype == \"text/html\"\n \n+    rv = flask.make_response(c for c in \"Hello\")\n+    assert rv.status_code == 200\n+    assert rv.data == b\"Hello\"\n+    assert rv.mimetype == \"text/html\"\n+\n \n def test_make_response_with_response_instance(app, req_ctx):\n     rv = flask.make_response(flask.jsonify({\"msg\": \"W00t\"}), 400)\n\n@@ -1,9 +1,11 @@\n from __future__ import annotations\n \n+import typing as t\n from http import HTTPStatus\n \n from flask import Flask\n from flask import jsonify\n+from flask import stream_template\n from flask.templating import render_template\n from flask.views import View\n from flask.wrappers import Response\n@@ -26,6 +28,25 @@ def hello_json() -> Response:\n     return jsonify({\"response\": \"Hello, World!\"})\n \n \n+@app.route(\"/generator\")\n+def hello_generator() -> t.Generator[str, None, None]:\n+    def show() -> t.Generator[str, None, None]:\n+        for x in range(100):\n+            yield f\"data:{x}\\n\\n\"\n+\n+    return show()\n+\n+\n+@app.route(\"/generator-expression\")\n+def hello_generator_expression() -> t.Iterator[bytes]:\n+    return (f\"data:{x}\\n\\n\".encode() for x in range(100))\n+\n+\n+@app.route(\"/iterator\")\n+def hello_iterator() -> t.Iterator[str]:\n+    return iter([f\"data:{x}\\n\\n\" for x in range(100)])\n+\n+\n @app.route(\"/status\")\n @app.route(\"/status/<int:code>\")\n def tuple_status(code: int = 200) -> tuple[str, int]:\n@@ -48,6 +69,11 @@ def return_template(name: str | None = None) -> str:\n     return render_template(\"index.html\", name=name)\n \n \n+@app.route(\"/template\")\n+def return_template_stream() -> t.Iterator[str]:\n+    return stream_template(\"index.html\", name=\"Hello\")\n+\n+\n class RenderTemplateView(View):\n     def __init__(self: RenderTemplateView, template_name: str) -> None:\n         self.template_name = template_name\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#46433e9807a1c960d6b2bb0e125cf16a90167d97", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 67 | Lines Deleted: 2 | Files Changed: 3 | Hunks: 5 | Methods Changed: 7 | Complexity Δ (Sum/Max): 7/5 | Churn Δ: 69 | Churn Cumulative: 1307 | Contributors (this commit): 17 | Commits (past 90d): 13 | Contributors (cumulative): 21 | DMM Complexity: 1.0\n\nDIFF:\n@@ -41,5 +41,7 @@ from .signals import signals_available as signals_available\n from .signals import template_rendered as template_rendered\n from .templating import render_template as render_template\n from .templating import render_template_string as render_template_string\n+from .templating import stream_template as stream_template\n+from .templating import stream_template_string as stream_template_string\n \n __version__ = \"2.2.0.dev0\"\n\n@@ -7,6 +7,9 @@ from jinja2 import TemplateNotFound\n \n from .globals import _app_ctx_stack\n from .globals import _request_ctx_stack\n+from .globals import current_app\n+from .globals import request\n+from .helpers import stream_with_context\n from .signals import before_render_template\n from .signals import template_rendered\n \n@@ -122,8 +125,6 @@ class DispatchingJinjaLoader(BaseLoader):\n \n \n def _render(template: Template, context: dict, app: \"Flask\") -> str:\n-    \"\"\"Renders the template and fires the signal\"\"\"\n-\n     before_render_template.send(app, template=template, context=context)\n     rv = template.render(context)\n     template_rendered.send(app, template=template, context=context)\n@@ -164,3 +165,56 @@ def render_template_string(source: str, **context: t.Any) -> str:\n     ctx = _app_ctx_stack.top\n     ctx.app.update_template_context(context)\n     return _render(ctx.app.jinja_env.from_string(source), context, ctx.app)\n+\n+\n+def _stream(\n+    app: \"Flask\", template: Template, context: t.Dict[str, t.Any]\n+) -> t.Iterator[str]:\n+    app.update_template_context(context)\n+    before_render_template.send(app, template=template, context=context)\n+\n+    def generate() -> t.Iterator[str]:\n+        yield from template.generate(context)\n+        template_rendered.send(app, template=template, context=context)\n+\n+    rv = generate()\n+\n+    # If a request context is active, keep it while generating.\n+    if request:\n+        rv = stream_with_context(rv)\n+\n+    return rv\n+\n+\n+def stream_template(\n+    template_name_or_list: t.Union[str, Template, t.List[t.Union[str, Template]]],\n+    **context: t.Any\n+) -> t.Iterator[str]:\n+    \"\"\"Render a template by name with the given context as a stream.\n+    This returns an iterator of strings, which can be used as a\n+    streaming response from a view.\n+\n+    :param template_name_or_list: The name of the template to render. If\n+        a list is given, the first name to exist will be rendered.\n+    :param context: The variables to make available in the template.\n+\n+    .. versionadded:: 2.2\n+    \"\"\"\n+    app = current_app._get_current_object()  # type: ignore[attr-defined]\n+    template = app.jinja_env.get_or_select_template(template_name_or_list)\n+    return _stream(app, template, context)\n+\n+\n+def stream_template_string(source: str, **context: t.Any) -> t.Iterator[str]:\n+    \"\"\"Render a template from the given source string with the given\n+    context as a stream. This returns an iterator of strings, which can\n+    be used as a streaming response from a view.\n+\n+    :param source: The source code of the template to render.\n+    :param context: The variables to make available in the template.\n+\n+    .. versionadded:: 2.2\n+    \"\"\"\n+    app = current_app._get_current_object()  # type: ignore[attr-defined]\n+    template = app.jinja_env.from_string(source)\n+    return _stream(app, template, context)\n\n@@ -29,6 +29,15 @@ def test_original_win(app, client):\n     assert rv.data == b\"42\"\n \n \n+def test_simple_stream(app, client):\n+    @app.route(\"/\")\n+    def index():\n+        return flask.stream_template_string(\"{{ config }}\", config=42)\n+\n+    rv = client.get(\"/\")\n+    assert rv.data == b\"42\"\n+\n+\n def test_request_less_rendering(app, app_ctx):\n     app.config[\"WORLD_NAME\"] = \"Special World\"\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#5544d09477af3221d988ec18b086930c2d9e67cd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 7 | Files Changed: 3 | Hunks: 5 | Methods Changed: 4 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 16 | Churn Cumulative: 4977 | Contributors (this commit): 59 | Commits (past 90d): 29 | Contributors (cumulative): 68 | DMM Complexity: None\n\nDIFF:\n@@ -916,8 +916,8 @@ class Flask(Scaffold):\n         if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n             if not is_running_from_reloader():\n                 click.secho(\n-                    \" * Ignoring a call to 'app.run()', the server is\"\n-                    \" already being run with the 'flask run' command.\\n\"\n+                    \" * Ignoring a call to 'app.run()' that would block\"\n+                    \" the current 'flask' CLI command.\\n\"\n                     \"   Only call 'app.run()' in an 'if __name__ ==\"\n                     ' \"__main__\"\\' guard.',\n                     fg=\"red\",\n\n@@ -715,6 +715,11 @@ class FlaskGroup(AppGroup):\n         parent: click.Context | None = None,\n         **extra: t.Any,\n     ) -> click.Context:\n+        # Set a flag to tell app.run to become a no-op. If app.run was\n+        # not in a __name__ == __main__ guard, it would start the server\n+        # when importing, blocking whatever command is being called.\n+        os.environ[\"FLASK_RUN_FROM_CLI\"] = \"true\"\n+\n         # Attempt to load .env and .flask env files. The --env-file\n         # option can cause another file to be loaded.\n         if get_load_dotenv(self.load_dotenv):\n\n@@ -13,7 +13,6 @@ import pytest\n from _pytest.monkeypatch import notset\n from click.testing import CliRunner\n \n-from flask import _app_ctx_stack\n from flask import Blueprint\n from flask import current_app\n from flask import Flask\n@@ -322,13 +321,11 @@ def test_app_cli_has_app_context(app, runner):\n         app = click.get_current_context().obj.load_app()\n         # the loaded app should be the same as current_app\n         same_app = current_app._get_current_object() is app\n-        # only one app context should be pushed\n-        stack_size = len(_app_ctx_stack._local.stack)\n-        return same_app, stack_size, value\n+        return same_app, value\n \n     cli = FlaskGroup(create_app=lambda: app)\n     result = runner.invoke(cli, [\"check\", \"x\"], standalone_mode=False)\n-    assert result.return_value == (True, 1, True)\n+    assert result.return_value == (True, True)\n \n \n def test_with_appcontext(runner):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#84c722044ad03f7f5384f5314c8350b3a13d8dfa", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 64 | Lines Deleted: 188 | Files Changed: 7 | Hunks: 34 | Methods Changed: 30 | Complexity Δ (Sum/Max): -15/0 | Churn Δ: 252 | Churn Cumulative: 10628 | Contributors (this commit): 77 | Commits (past 90d): 40 | Contributors (cumulative): 117 | DMM Complexity: 0.0\n\nDIFF:\n@@ -331,7 +331,6 @@ class Flask(Scaffold):\n             \"DEBUG\": None,\n             \"TESTING\": False,\n             \"PROPAGATE_EXCEPTIONS\": None,\n-            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n             \"SECRET_KEY\": None,\n             \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n             \"USE_X_SENDFILE\": False,\n@@ -583,19 +582,6 @@ class Flask(Scaffold):\n             return rv\n         return self.testing or self.debug\n \n-    @property\n-    def preserve_context_on_exception(self) -> bool:\n-        \"\"\"Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION``\n-        configuration value in case it's set, otherwise a sensible default\n-        is returned.\n-\n-        .. versionadded:: 0.7\n-        \"\"\"\n-        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n-        if rv is not None:\n-            return rv\n-        return self.debug\n-\n     @locked_cached_property\n     def logger(self) -> logging.Logger:\n         \"\"\"A standard Python :class:`~logging.Logger` for the app, with\n@@ -2301,9 +2287,14 @@ class Flask(Scaffold):\n                 raise\n             return response(environ, start_response)\n         finally:\n-            if self.should_ignore_error(error):\n+            if \"werkzeug.debug.preserve_context\" in environ:\n+                environ[\"werkzeug.debug.preserve_context\"](_app_ctx_stack.top)\n+                environ[\"werkzeug.debug.preserve_context\"](_request_ctx_stack.top)\n+\n+            if error is not None and self.should_ignore_error(error):\n                 error = None\n-            ctx.auto_pop(error)\n+\n+            ctx.pop(error)\n \n     def __call__(self, environ: dict, start_response: t.Callable) -> t.Any:\n         \"\"\"The WSGI server calls the Flask application object as the\n\n@@ -289,20 +289,12 @@ class RequestContext:\n     functions registered on the application for teardown execution\n     (:meth:`~flask.Flask.teardown_request`).\n \n-    The request context is automatically popped at the end of the request\n-    for you.  In debug mode the request context is kept around if\n-    exceptions happen so that interactive debuggers have a chance to\n-    introspect the data.  With 0.4 this can also be forced for requests\n-    that did not fail and outside of ``DEBUG`` mode.  By setting\n-    ``'flask._preserve_context'`` to ``True`` on the WSGI environment the\n-    context will not pop itself at the end of the request.  This is used by\n-    the :meth:`~flask.Flask.test_client` for example to implement the\n-    deferred cleanup functionality.\n-\n-    You might find this helpful for unittests where you need the\n-    information from the context local around for a little longer.  Make\n-    sure to properly :meth:`~werkzeug.LocalStack.pop` the stack yourself in\n-    that situation, otherwise your unittests will leak memory.\n+    The request context is automatically popped at the end of the\n+    request. When using the interactive debugger, the context will be\n+    restored so ``request`` is still accessible. Similarly, the test\n+    client can preserve the context after the request ends. However,\n+    teardown functions may already have closed some resources such as\n+    database connections.\n     \"\"\"\n \n     def __init__(\n@@ -330,14 +322,6 @@ class RequestContext:\n         # one is created implicitly so for each level we add this information\n         self._implicit_app_ctx_stack: t.List[t.Optional[\"AppContext\"]] = []\n \n-        # indicator if the context was preserved.  Next time another context\n-        # is pushed the preserved context is popped.\n-        self.preserved = False\n-\n-        # remembers the exception for pop if there is one in case the context\n-        # preservation kicks in.\n-        self._preserved_exc = None\n-\n         # Functions that should be executed after the request on the response\n         # object.  These will be called before the regular \"after_request\"\n         # functions.\n@@ -400,19 +384,6 @@ class RequestContext:\n             self.request.routing_exception = e\n \n     def push(self) -> None:\n-        \"\"\"Binds the request context to the current context.\"\"\"\n-        # If an exception occurs in debug mode or if context preservation is\n-        # activated under exception situations exactly one context stays\n-        # on the stack.  The rationale is that you want to access that\n-        # information under debug situations.  However if someone forgets to\n-        # pop that context again we want to make sure that on the next push\n-        # it's invalidated, otherwise we run at risk that something leaks\n-        # memory.  This is usually only a problem in test suite since this\n-        # functionality is not active in production environments.\n-        top = _request_ctx_stack.top\n-        if top is not None and top.preserved:\n-            top.pop(top._preserved_exc)\n-\n         # Before we push the request context we have to ensure that there\n         # is an application context.\n         app_ctx = _app_ctx_stack.top\n@@ -454,8 +425,6 @@ class RequestContext:\n \n         try:\n             if not self._implicit_app_ctx_stack:\n-                self.preserved = False\n-                self._preserved_exc = None\n                 if exc is _sentinel:\n                     exc = sys.exc_info()[1]\n                 self.app.do_teardown_request(exc)\n@@ -481,12 +450,17 @@ class RequestContext:\n             ), f\"Popped wrong request context. ({rv!r} instead of {self!r})\"\n \n     def auto_pop(self, exc: t.Optional[BaseException]) -> None:\n-        if self.request.environ.get(\"flask._preserve_context\") or (\n-            exc is not None and self.app.preserve_context_on_exception\n-        ):\n-            self.preserved = True\n-            self._preserved_exc = exc  # type: ignore\n-        else:\n+        \"\"\"\n+        .. deprecated:: 2.2\n+            Will be removed in Flask 2.3.\n+        \"\"\"\n+        import warnings\n+\n+        warnings.warn(\n+            \"'ctx.auto_pop' is deprecated and will be removed in Flask 2.3.\",\n+            DeprecationWarning,\n+            stacklevel=2,\n+        )\n         self.pop(exc)\n \n     def __enter__(self) -> \"RequestContext\":\n@@ -499,12 +473,7 @@ class RequestContext:\n         exc_value: t.Optional[BaseException],\n         tb: t.Optional[TracebackType],\n     ) -> None:\n-        # do not pop the request stack if we are in debug mode and an\n-        # exception happened.  This will allow the debugger to still\n-        # access the request object in the interactive shell.  Furthermore\n-        # the context can be force kept alive for the test client.\n-        # See flask.testing for how this works.\n-        self.auto_pop(exc_value)\n+        self.pop(exc_value)\n \n     def __repr__(self) -> str:\n         return (\n\n@@ -600,13 +600,6 @@ class Scaffold:\n         be passed an error object.\n \n         The return values of teardown functions are ignored.\n-\n-        .. admonition:: Debug Note\n-\n-           In debug mode Flask will not tear down a request on an exception\n-           immediately.  Instead it will keep it alive so that the interactive\n-           debugger can still access it.  This behavior can be controlled\n-           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n         \"\"\"\n         self.teardown_request_funcs.setdefault(None, []).append(f)\n         return f\n\n@@ -1,5 +1,6 @@\n import typing as t\n from contextlib import contextmanager\n+from contextlib import ExitStack\n from copy import copy\n from types import TracebackType\n \n@@ -108,10 +109,12 @@ class FlaskClient(Client):\n     \"\"\"\n \n     application: \"Flask\"\n-    preserve_context = False\n \n     def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n         super().__init__(*args, **kwargs)\n+        self.preserve_context = False\n+        self._new_contexts: t.List[t.ContextManager[t.Any]] = []\n+        self._context_stack = ExitStack()\n         self.environ_base = {\n             \"REMOTE_ADDR\": \"127.0.0.1\",\n             \"HTTP_USER_AGENT\": f\"werkzeug/{werkzeug.__version__}\",\n@@ -173,11 +176,12 @@ class FlaskClient(Client):\n             self.cookie_jar.extract_wsgi(c.request.environ, headers)\n \n     def _copy_environ(self, other):\n-        return {\n-            **self.environ_base,\n-            **other,\n-            \"flask._preserve_context\": self.preserve_context,\n-        }\n+        out = {**self.environ_base, **other}\n+\n+        if self.preserve_context:\n+            out[\"werkzeug.debug.preserve_context\"] = self._new_contexts.append\n+\n+        return out\n \n     def _request_from_builder_args(self, args, kwargs):\n         kwargs[\"environ_base\"] = self._copy_environ(kwargs.get(\"environ_base\", {}))\n@@ -214,12 +218,24 @@ class FlaskClient(Client):\n             # request is None\n             request = self._request_from_builder_args(args, kwargs)\n \n-        return super().open(\n+        # Pop any previously preserved contexts. This prevents contexts\n+        # from being preserved across redirects or multiple requests\n+        # within a single block.\n+        self._context_stack.close()\n+\n+        response = super().open(\n             request,\n             buffered=buffered,\n             follow_redirects=follow_redirects,\n         )\n \n+        # Re-push contexts that were preserved during the request.\n+        while self._new_contexts:\n+            cm = self._new_contexts.pop()\n+            self._context_stack.enter_context(cm)\n+\n+        return response\n+\n     def __enter__(self) -> \"FlaskClient\":\n         if self.preserve_context:\n             raise RuntimeError(\"Cannot nest client invocations\")\n@@ -233,18 +249,7 @@ class FlaskClient(Client):\n         tb: t.Optional[TracebackType],\n     ) -> None:\n         self.preserve_context = False\n-\n-        # Normally the request context is preserved until the next\n-        # request in the same thread comes. When the client exits we\n-        # want to clean up earlier. Pop request contexts until the stack\n-        # is empty or a non-preserved one is found.\n-        while True:\n-            top = _request_ctx_stack.top\n-\n-            if top is not None and top.preserved:\n-                top.pop()\n-            else:\n-                break\n+        self._context_stack.close()\n \n \n class FlaskCliRunner(CliRunner):\n\n@@ -928,14 +928,9 @@ def test_baseexception_error_handling(app, client):\n     def broken_func():\n         raise KeyboardInterrupt()\n \n-    with client:\n     with pytest.raises(KeyboardInterrupt):\n         client.get(\"/\")\n \n-        ctx = flask._request_ctx_stack.top\n-        assert ctx.preserved\n-        assert type(ctx._preserved_exc) is KeyboardInterrupt\n-\n \n def test_before_request_and_routing_errors(app, client):\n     @app.before_request\n@@ -1769,57 +1764,6 @@ def test_route_decorator_custom_endpoint(app, client):\n     assert client.get(\"/bar/123\").data == b\"123\"\n \n \n-def test_preserve_only_once(app, client):\n-    app.debug = True\n-\n-    @app.route(\"/fail\")\n-    def fail_func():\n-        1 // 0\n-\n-    for _x in range(3):\n-        with pytest.raises(ZeroDivisionError):\n-            client.get(\"/fail\")\n-\n-    assert flask._request_ctx_stack.top is not None\n-    assert flask._app_ctx_stack.top is not None\n-    # implicit appctx disappears too\n-    flask._request_ctx_stack.top.pop()\n-    assert flask._request_ctx_stack.top is None\n-    assert flask._app_ctx_stack.top is None\n-\n-\n-def test_preserve_remembers_exception(app, client):\n-    app.debug = True\n-    errors = []\n-\n-    @app.route(\"/fail\")\n-    def fail_func():\n-        1 // 0\n-\n-    @app.route(\"/success\")\n-    def success_func():\n-        return \"Okay\"\n-\n-    @app.teardown_request\n-    def teardown_handler(exc):\n-        errors.append(exc)\n-\n-    # After this failure we did not yet call the teardown handler\n-    with pytest.raises(ZeroDivisionError):\n-        client.get(\"/fail\")\n-    assert errors == []\n-\n-    # But this request triggers it, and it's an error\n-    client.get(\"/success\")\n-    assert len(errors) == 2\n-    assert isinstance(errors[0], ZeroDivisionError)\n-\n-    # At this point another request does nothing.\n-    client.get(\"/success\")\n-    assert len(errors) == 3\n-    assert errors[1] is None\n-\n-\n def test_get_method_on_g(app_ctx):\n     assert flask.g.get(\"x\") is None\n     assert flask.g.get(\"x\", 11) == 11\n\n@@ -123,8 +123,7 @@ def test_request_exception_signal():\n         flask.got_request_exception.disconnect(record, app)\n \n \n-def test_appcontext_signals():\n-    app = flask.Flask(__name__)\n+def test_appcontext_signals(app, client):\n     recorded = []\n \n     def record_push(sender, **kwargs):\n@@ -140,10 +139,8 @@ def test_appcontext_signals():\n     flask.appcontext_pushed.connect(record_push, app)\n     flask.appcontext_popped.connect(record_pop, app)\n     try:\n-        with app.test_client() as c:\n-            rv = c.get(\"/\")\n+        rv = client.get(\"/\")\n         assert rv.data == b\"Hello\"\n-            assert recorded == [\"push\"]\n         assert recorded == [\"push\", \"pop\"]\n     finally:\n         flask.appcontext_pushed.disconnect(record_push, app)\n@@ -174,12 +171,12 @@ def test_flash_signal(app):\n         flask.message_flashed.disconnect(record, app)\n \n \n-def test_appcontext_tearing_down_signal():\n-    app = flask.Flask(__name__)\n+def test_appcontext_tearing_down_signal(app, client):\n+    app.testing = False\n     recorded = []\n \n-    def record_teardown(sender, **kwargs):\n-        recorded.append((\"tear_down\", kwargs))\n+    def record_teardown(sender, exc):\n+        recorded.append(exc)\n \n     @app.route(\"/\")\n     def index():\n@@ -187,10 +184,9 @@ def test_appcontext_tearing_down_signal():\n \n     flask.appcontext_tearing_down.connect(record_teardown, app)\n     try:\n-        with app.test_client() as c:\n-            rv = c.get(\"/\")\n+        rv = client.get(\"/\")\n         assert rv.status_code == 500\n-            assert recorded == []\n-        assert recorded == [(\"tear_down\", {\"exc\": None})]\n+        assert len(recorded) == 1\n+        assert isinstance(recorded[0], ZeroDivisionError)\n     finally:\n         flask.appcontext_tearing_down.disconnect(record_teardown, app)\n\n@@ -187,7 +187,6 @@ def test_session_transactions(app, client):\n \n def test_session_transactions_no_null_sessions():\n     app = flask.Flask(__name__)\n-    app.testing = True\n \n     with app.test_client() as c:\n         with pytest.raises(RuntimeError) as e:\n@@ -254,29 +253,6 @@ def test_reuse_client(client):\n         assert client.get(\"/\").status_code == 404\n \n \n-def test_test_client_calls_teardown_handlers(app, client):\n-    called = []\n-\n-    @app.teardown_request\n-    def remember(error):\n-        called.append(error)\n-\n-    with client:\n-        assert called == []\n-        client.get(\"/\")\n-        assert called == []\n-    assert called == [None]\n-\n-    del called[:]\n-    with client:\n-        assert called == []\n-        client.get(\"/\")\n-        assert called == []\n-        client.get(\"/\")\n-        assert called == [None]\n-    assert called == [None, None]\n-\n-\n def test_full_url_request(app, client):\n     @app.route(\"/action\", methods=[\"POST\"])\n     def action():\n@@ -412,13 +388,15 @@ def test_cli_custom_obj(app):\n def test_client_pop_all_preserved(app, req_ctx, client):\n     @app.route(\"/\")\n     def index():\n-        # stream_with_context pushes a third context, preserved by client\n-        return flask.Response(flask.stream_with_context(\"hello\"))\n+        # stream_with_context pushes a third context, preserved by response\n+        return flask.stream_with_context(\"hello\")\n \n-    # req_ctx fixture pushed an initial context, not marked preserved\n+    # req_ctx fixture pushed an initial context\n     with client:\n         # request pushes a second request context, preserved by client\n-        client.get(\"/\")\n+        rv = client.get(\"/\")\n \n+    # close the response, releasing the context held by stream_with_context\n+    rv.close()\n     # only req_ctx fixture should still be pushed\n     assert flask._request_ctx_stack.top is req_ctx\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#9e686d93b69f0e73f801cc11a57839f4dfe2ca1a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 26 | Files Changed: 1 | Hunks: 1 | Methods Changed: 2 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 26 | Churn Cumulative: 372 | Contributors (this commit): 8 | Commits (past 90d): 4 | Contributors (cumulative): 8 | DMM Complexity: 0.0\n\nDIFF:\n@@ -327,32 +327,6 @@ class RequestContext:\n         # functions.\n         self._after_request_functions: t.List[ft.AfterRequestCallable] = []\n \n-    @property\n-    def g(self) -> _AppCtxGlobals:\n-        import warnings\n-\n-        warnings.warn(\n-            \"Accessing 'g' on the request context is deprecated and\"\n-            \" will be removed in Flask 2.2. Access `g` directly or from\"\n-            \"the application context instead.\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        return _app_ctx_stack.top.g\n-\n-    @g.setter\n-    def g(self, value: _AppCtxGlobals) -> None:\n-        import warnings\n-\n-        warnings.warn(\n-            \"Setting 'g' on the request context is deprecated and\"\n-            \" will be removed in Flask 2.2. Set it on the application\"\n-            \" context instead.\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        _app_ctx_stack.top.g = value\n-\n     def copy(self) -> \"RequestContext\":\n         \"\"\"Creates a copy of this request context with the same request object.\n         This can be used to move a request context to a different greenlet.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#c2810ffdd2f2becbc37d35f63b69034b8b9ed5b8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 64 | Files Changed: 1 | Hunks: 12 | Methods Changed: 6 | Complexity Δ (Sum/Max): -4/0 | Churn Δ: 70 | Churn Cumulative: 1851 | Contributors (this commit): 16 | Commits (past 90d): 9 | Contributors (cumulative): 16 | DMM Complexity: 1.0\n\nDIFF:\n@@ -3,7 +3,6 @@ import pkgutil\n import socket\n import sys\n import typing as t\n-import warnings\n from datetime import datetime\n from functools import lru_cache\n from functools import update_wrapper\n@@ -390,53 +389,12 @@ def get_flashed_messages(\n     return flashes\n \n \n-def _prepare_send_file_kwargs(\n-    download_name: t.Optional[str] = None,\n-    attachment_filename: t.Optional[str] = None,\n-    etag: t.Optional[t.Union[bool, str]] = None,\n-    add_etags: t.Optional[t.Union[bool]] = None,\n-    max_age: t.Optional[\n-        t.Union[int, t.Callable[[t.Optional[str]], t.Optional[int]]]\n-    ] = None,\n-    cache_timeout: t.Optional[int] = None,\n-    **kwargs: t.Any,\n-) -> t.Dict[str, t.Any]:\n-    if attachment_filename is not None:\n-        warnings.warn(\n-            \"The 'attachment_filename' parameter has been renamed to\"\n-            \" 'download_name'. The old name will be removed in Flask\"\n-            \" 2.2.\",\n-            DeprecationWarning,\n-            stacklevel=3,\n-        )\n-        download_name = attachment_filename\n-\n-    if cache_timeout is not None:\n-        warnings.warn(\n-            \"The 'cache_timeout' parameter has been renamed to\"\n-            \" 'max_age'. The old name will be removed in Flask 2.2.\",\n-            DeprecationWarning,\n-            stacklevel=3,\n-        )\n-        max_age = cache_timeout\n-\n-    if add_etags is not None:\n-        warnings.warn(\n-            \"The 'add_etags' parameter has been renamed to 'etag'. The\"\n-            \" old name will be removed in Flask 2.2.\",\n-            DeprecationWarning,\n-            stacklevel=3,\n-        )\n-        etag = add_etags\n-\n-    if max_age is None:\n-        max_age = current_app.get_send_file_max_age\n+def _prepare_send_file_kwargs(**kwargs: t.Any) -> t.Dict[str, t.Any]:\n+    if kwargs.get(\"max_age\") is None:\n+        kwargs[\"max_age\"] = current_app.get_send_file_max_age\n \n     kwargs.update(\n         environ=request.environ,\n-        download_name=download_name,\n-        etag=etag,\n-        max_age=max_age,\n         use_x_sendfile=current_app.use_x_sendfile,\n         response_class=current_app.response_class,\n         _root_path=current_app.root_path,  # type: ignore\n@@ -449,16 +407,13 @@ def send_file(\n     mimetype: t.Optional[str] = None,\n     as_attachment: bool = False,\n     download_name: t.Optional[str] = None,\n-    attachment_filename: t.Optional[str] = None,\n     conditional: bool = True,\n     etag: t.Union[bool, str] = True,\n-    add_etags: t.Optional[bool] = None,\n     last_modified: t.Optional[t.Union[datetime, int, float]] = None,\n     max_age: t.Optional[\n         t.Union[int, t.Callable[[t.Optional[str]], t.Optional[int]]]\n     ] = None,\n-    cache_timeout: t.Optional[int] = None,\n-):\n+) -> \"Response\":\n     \"\"\"Send the contents of a file to the client.\n \n     The first argument can be a file path or a file-like object. Paths\n@@ -560,20 +515,17 @@ def send_file(\n \n     .. versionadded:: 0.2\n     \"\"\"\n-    return werkzeug.utils.send_file(\n+    return werkzeug.utils.send_file(  # type: ignore[return-value]\n         **_prepare_send_file_kwargs(\n             path_or_file=path_or_file,\n             environ=request.environ,\n             mimetype=mimetype,\n             as_attachment=as_attachment,\n             download_name=download_name,\n-            attachment_filename=attachment_filename,\n             conditional=conditional,\n             etag=etag,\n-            add_etags=add_etags,\n             last_modified=last_modified,\n             max_age=max_age,\n-            cache_timeout=cache_timeout,\n         )\n     )\n \n@@ -581,7 +533,6 @@ def send_file(\n def send_from_directory(\n     directory: t.Union[os.PathLike, str],\n     path: t.Union[os.PathLike, str],\n-    filename: t.Optional[str] = None,\n     **kwargs: t.Any,\n ) -> \"Response\":\n     \"\"\"Send a file from within a directory using :func:`send_file`.\n@@ -617,16 +568,7 @@ def send_from_directory(\n \n     .. versionadded:: 0.5\n     \"\"\"\n-    if filename is not None:\n-        warnings.warn(\n-            \"The 'filename' parameter has been renamed to 'path'. The\"\n-            \" old name will be removed in Flask 2.2.\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        path = filename\n-\n-    return werkzeug.utils.send_from_directory(  # type: ignore\n+    return werkzeug.utils.send_from_directory(  # type: ignore[return-value]\n         directory, path, **_prepare_send_file_kwargs(**kwargs)\n     )\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ab6a8b0330845c80d661a748314691302ea7d8f7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 8 | Files Changed: 1 | Hunks: 4 | Methods Changed: 6 | Complexity Δ (Sum/Max): -4/0 | Churn Δ: 15 | Churn Cumulative: 1836 | Contributors (this commit): 32 | Commits (past 90d): 8 | Contributors (cumulative): 32 | DMM Complexity: 0.0\n\nDIFF:\n@@ -422,8 +422,7 @@ def test_help_echo_exception():\n \n class TestRoutes:\n     @pytest.fixture\n-    def invoke(self, runner):\n-        def create_app():\n+    def app(self):\n         app = Flask(__name__)\n         app.testing = True\n \n@@ -437,7 +436,9 @@ class TestRoutes:\n \n         return app\n \n-        cli = FlaskGroup(create_app=create_app)\n+    @pytest.fixture\n+    def invoke(self, app, runner):\n+        cli = FlaskGroup(create_app=lambda: app)\n         return partial(runner.invoke, cli)\n \n     @pytest.fixture\n@@ -462,7 +463,7 @@ class TestRoutes:\n         assert result.exit_code == 0\n         self.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)\n \n-    def test_sort(self, invoke):\n+    def test_sort(self, app, invoke):\n         default_output = invoke([\"routes\"]).output\n         endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n         assert default_output == endpoint_output\n@@ -474,10 +475,8 @@ class TestRoutes:\n             [\"yyy_get_post\", \"static\", \"aaa_post\"],\n             invoke([\"routes\", \"-s\", \"rule\"]).output,\n         )\n-        self.expect_order(\n-            [\"aaa_post\", \"yyy_get_post\", \"static\"],\n-            invoke([\"routes\", \"-s\", \"match\"]).output,\n-        )\n+        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n+        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)\n \n     def test_all_methods(self, invoke):\n         output = invoke([\"routes\"]).output\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ca2bfbb0ac66fbbeeedbf6bbe317bee45cb23d29", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 4 | Files Changed: 3 | Hunks: 8 | Methods Changed: 3 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 20 | Churn Cumulative: 7061 | Contributors (this commit): 67 | Commits (past 90d): 30 | Contributors (cumulative): 79 | DMM Complexity: 0.6363636363636364\n\nDIFF:\n@@ -1830,6 +1830,9 @@ class Flask(Scaffold):\n             ``dict``\n                 A dictionary that will be jsonify'd before being returned.\n \n+            ``list``\n+                A list that will be jsonify'd before being returned.\n+\n             ``generator`` or ``iterator``\n                 A generator that returns ``str`` or ``bytes`` to be\n                 streamed as the response.\n@@ -1855,6 +1858,7 @@ class Flask(Scaffold):\n \n         .. versionchanged:: 2.2\n             A generator will be converted to a streaming response.\n+            A list will be converted to a JSON response.\n \n         .. versionchanged:: 1.1\n             A dict will be converted to a JSON response.\n@@ -1907,7 +1911,7 @@ class Flask(Scaffold):\n                     headers=headers,  # type: ignore[arg-type]\n                 )\n                 status = headers = None\n-            elif isinstance(rv, dict):\n+            elif isinstance(rv, (dict, list)):\n                 rv = jsonify(rv)\n             elif isinstance(rv, BaseResponse) or callable(rv):\n                 # evaluate a WSGI callable, or coerce a different response\n@@ -1920,14 +1924,14 @@ class Flask(Scaffold):\n                     raise TypeError(\n                         f\"{e}\\nThe view function did not return a valid\"\n                         \" response. The return type must be a string,\"\n-                        \" dict, tuple, Response instance, or WSGI\"\n+                        \" dict, list, tuple, Response instance, or WSGI\"\n                         f\" callable, but it was a {type(rv).__name__}.\"\n                     ).with_traceback(sys.exc_info()[2]) from None\n             else:\n                 raise TypeError(\n                     \"The view function did not return a valid\"\n                     \" response. The return type must be a string,\"\n-                    \" dict, tuple, Response instance, or WSGI\"\n+                    \" dict, list, tuple, Response instance, or WSGI\"\n                     f\" callable, but it was a {type(rv).__name__}.\"\n                 )\n \n\n@@ -7,7 +7,7 @@ if t.TYPE_CHECKING:  # pragma: no cover\n \n # The possible types that are directly convertible or are a Response object.\n ResponseValue = t.Union[\n-    \"Response\", str, bytes, t.Dict[str, t.Any], t.Iterator[str], t.Iterator[bytes]\n+    \"Response\", str, bytes, list, t.Dict[str, t.Any], t.Iterator[str], t.Iterator[bytes]\n ]\n \n # the possible types for an individual HTTP header\n\n@@ -1166,6 +1166,10 @@ def test_response_types(app, client):\n     def from_dict():\n         return {\"foo\": \"bar\"}, 201\n \n+    @app.route(\"/list\")\n+    def from_list():\n+        return [\"foo\", \"bar\"], 201\n+\n     assert client.get(\"/text\").data == \"Hällo Wörld\".encode()\n     assert client.get(\"/bytes\").data == \"Hällo Wörld\".encode()\n \n@@ -1205,6 +1209,10 @@ def test_response_types(app, client):\n     assert rv.json == {\"foo\": \"bar\"}\n     assert rv.status_code == 201\n \n+    rv = client.get(\"/list\")\n+    assert rv.json == [\"foo\", \"bar\"]\n+    assert rv.status_code == 201\n+\n \n def test_response_type_errors():\n     app = flask.Flask(__name__)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
