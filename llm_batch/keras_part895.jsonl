{"custom_id": "keras#f98b91f47190f69209d3fa7ea512a05cc58aea9a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 765 | Lines Deleted: 464 | Files Changed: 2 | Hunks: 37 | Methods Changed: 23 | Complexity Δ (Sum/Max): 18/21 | Churn Δ: 1229 | Churn Cumulative: 2233 | Contributors (this commit): 8 | Commits (past 90d): 2 | Contributors (cumulative): 12 | DMM Complexity: 0.35714285714285715\n\nDIFF:\n@@ -6,6 +6,14 @@ from keras.src.utils import model_to_dot\n from keras.src.utils import plot_model\n \n \n+class SubclassModel(keras.models.Model):\n+    def __init__(self, name):\n+        super().__init__(name=name)\n+\n+    def call(self, x):\n+        return x\n+\n+\n def parse_text_from_html(html):\n     pattern = r\"<font[^>]*>(.*?)</font>\"\n     matches = re.findall(pattern, html)\n@@ -27,20 +35,107 @@ def get_node_text(node):\n \n \n def get_edge_dict(dot):\n-    node_dict = dict()\n-    for node in dot.get_nodes():\n-        node_dict[node.get_name()] = get_node_text(node)\n+    def get_node_dict(graph, path=\"\"):\n+        nodes = {\n+            node.get_name(): path + get_node_text(node)\n+            for node in graph.get_nodes()\n+            if node.get_name() != \"node\"  # Dummy node inserted by pydot?\n+        }\n+\n+        for subgraph in graph.get_subgraphs():\n+            sub_nodes = get_node_dict(\n+                subgraph, path=path + subgraph.get_label() + \" > \"\n+            )\n+            nodes.update(sub_nodes)\n+\n+        return nodes\n+\n+    node_dict = get_node_dict(dot)\n+\n+    def get_edges(graph):\n+        edges = list(graph.get_edges())\n+        for subgraph in graph.get_subgraphs():\n+            edges.extend(get_edges(subgraph))\n+        return edges\n \n     edge_dict = dict()\n-    for edge in dot.get_edges():\n-        edge_dict[node_dict[edge.get_source()]] = node_dict[\n-            edge.get_destination()\n-        ]\n+    dangling_edges = []\n+    for edge in get_edges(dot):\n+        source_node = node_dict.get(edge.get_source(), None)\n+        destination_node = node_dict.get(edge.get_destination(), None)\n+        if source_node is None or destination_node is None:\n+            dangling_edges.append(\n+                f\"from '{source_node}'/'{edge.get_source()}' \"\n+                f\"to '{destination_node}'/'{edge.get_destination()}'\"\n+            )\n+        if source_node in edge_dict:\n+            destination_nodes = edge_dict[source_node]\n+            if not isinstance(destination_nodes, set):\n+                destination_nodes = set([destination_nodes])\n+                edge_dict[source_node] = destination_nodes\n+            destination_nodes.add(destination_node)\n+        else:\n+            edge_dict[source_node] = destination_node\n \n+    if dangling_edges:\n+        raise ValueError(f\"Dangling edges found: {dangling_edges}\")\n     return edge_dict\n \n \n class ModelVisualizationTest(testing.TestCase):\n+    def multi_plot_model(self, model, name, expand_nested=False):\n+        if expand_nested:\n+            name = name + \"-expand_nested\"\n+\n+        TEST_CASES = [\n+            {},\n+            {\n+                \"show_shapes\": True,\n+            },\n+            {\n+                \"show_shapes\": True,\n+                \"show_dtype\": True,\n+            },\n+            {\n+                \"show_shapes\": True,\n+                \"show_dtype\": True,\n+                \"show_layer_names\": True,\n+            },\n+            {\n+                \"show_shapes\": True,\n+                \"show_dtype\": True,\n+                \"show_layer_names\": True,\n+                \"show_layer_activations\": True,\n+            },\n+            {\n+                \"show_shapes\": True,\n+                \"show_dtype\": True,\n+                \"show_layer_names\": True,\n+                \"show_layer_activations\": True,\n+                \"show_trainable\": True,\n+            },\n+            {\n+                \"show_shapes\": True,\n+                \"show_dtype\": True,\n+                \"show_layer_names\": True,\n+                \"show_layer_activations\": True,\n+                \"show_trainable\": True,\n+                \"rankdir\": \"LR\",\n+            },\n+            {\n+                \"show_layer_activations\": True,\n+                \"show_trainable\": True,\n+            },\n+        ]\n+\n+        for test_case in TEST_CASES:\n+            tags = [v if k == \"rankdir\" else k for k, v in test_case.items()]\n+            file_name = \"-\".join([name] + tags) + \".png\"\n+            plot_model(\n+                model, file_name, expand_nested=expand_nested, **test_case\n+            )\n+            self.assertFileExists(file_name)\n+\n     def test_plot_sequential_model(self):\n         model = keras.Sequential(\n             [\n@@ -51,79 +146,13 @@ class ModelVisualizationTest(testing.TestCase):\n         )\n \n         edge_dict = get_edge_dict(model_to_dot(model))\n-        self.assertEqual(edge_dict[\"dense (Dense)\"], \"dense_1 (Dense)\")\n-\n-        file_name = \"sequential.png\"\n-        plot_model(model, file_name)\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"sequential-show_shapes.png\"\n-        plot_model(model, file_name, show_shapes=True)\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"sequential-show_shapes-show_dtype.png\"\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"dense (Dense)\": \"dense_1 (Dense)\",\n+            },\n         )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"sequential-show_shapes-show_dtype-show_layer_names.png\"\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"sequential-show_shapes-show_dtype-show_layer_names-show_layer_activations.png\"  # noqa: E501\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-            show_layer_activations=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"sequential-show_shapes-show_dtype-show_layer_names-show_layer_activations-show_trainable.png\"  # noqa: E501\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"sequential-show_shapes-show_dtype-show_layer_names-show_layer_activations-show_trainable-LR.png\"  # noqa: E501\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-            rankdir=\"LR\",\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"sequential-show_layer_activations-show_trainable.png\"\n-        plot_model(\n-            model,\n-            file_name,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-        )\n-        self.assertFileExists(file_name)\n+        self.multi_plot_model(model, \"sequential\")\n \n     def test_plot_functional_model(self):\n         inputs = keras.Input((3,), name=\"input\")\n@@ -146,203 +175,29 @@ class ModelVisualizationTest(testing.TestCase):\n         model = keras.Model(inputs, outputs)\n \n         edge_dict = get_edge_dict(model_to_dot(model))\n-\n-        self.assertEqual(edge_dict[\"input (InputLayer)\"], \"dense (Dense)\")\n-        self.assertEqual(edge_dict[\"dense (Dense)\"], \"add (Add)\")\n-        self.assertEqual(edge_dict[\"dense_1 (Dense)\"], \"dense_2 (Dense)\")\n-        self.assertEqual(edge_dict[\"dense_2 (Dense)\"], \"dense_3 (Dense)\")\n-        self.assertEqual(edge_dict[\"dense_3 (Dense)\"], \"add (Add)\")\n-        self.assertEqual(edge_dict[\"add (Add)\"], \"add_1 (Add)\")\n-        self.assertEqual(edge_dict[\"dense_4 (Dense)\"], \"dense_5 (Dense)\")\n-        self.assertEqual(edge_dict[\"dense_5 (Dense)\"], \"dense_6 (Dense)\")\n-        self.assertEqual(edge_dict[\"dense_6 (Dense)\"], \"add_1 (Add)\")\n-        self.assertEqual(edge_dict[\"add_1 (Add)\"], \"dropout (Dropout)\")\n-        self.assertEqual(edge_dict[\"dropout (Dropout)\"], \"dense_7 (Dense)\")\n-\n-        file_name = \"functional.png\"\n-        plot_model(model, file_name)\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"functional-show_shapes.png\"\n-        plot_model(model, file_name, show_shapes=True)\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"functional-show_shapes-show_dtype.png\"\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"input (InputLayer)\": \"dense (Dense)\",\n+                \"dense (Dense)\": {\"dense_1 (Dense)\", \"add (Add)\"},\n+                \"dense_1 (Dense)\": \"dense_2 (Dense)\",\n+                \"dense_2 (Dense)\": \"dense_3 (Dense)\",\n+                \"dense_3 (Dense)\": \"add (Add)\",\n+                \"add (Add)\": {\"dense_4 (Dense)\", \"add_1 (Add)\"},\n+                \"dense_4 (Dense)\": \"dense_5 (Dense)\",\n+                \"dense_5 (Dense)\": \"dense_6 (Dense)\",\n+                \"dense_6 (Dense)\": \"add_1 (Add)\",\n+                \"add_1 (Add)\": \"dropout (Dropout)\",\n+                \"dropout (Dropout)\": \"dense_7 (Dense)\",\n+            },\n         )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"functional-show_shapes-show_dtype-show_layer_names.png\"\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = (\n-            \"functional-show_shapes-show_dtype-show_layer_activations.png\"\n-        )\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-            show_layer_activations=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"functional-show_shapes-show_dtype-show_layer_activations-show_trainable.png\"  # noqa: E501\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"functional-show_shapes-show_dtype-show_layer_names-show_layer_activations-show_trainable-LR.png\"  # noqa: E501\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-            rankdir=\"LR\",\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"functional-show_layer_activations-show_trainable.png\"\n-        plot_model(\n-            model,\n-            file_name,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = (\n-            \"functional-show_shapes-show_layer_activations-show_trainable.png\"\n-        )\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-        )\n-        self.assertFileExists(file_name)\n+        self.multi_plot_model(model, \"functional\")\n \n     def test_plot_subclassed_model(self):\n-        class MyModel(keras.Model):\n-            def __init__(self, **kwargs):\n-                super().__init__(**kwargs)\n-                self.dense_1 = keras.layers.Dense(3, activation=\"relu\")\n-                self.dense_2 = keras.layers.Dense(1, activation=\"sigmoid\")\n-\n-            def call(self, x):\n-                return self.dense_2(self.dense_1(x))\n-\n-        model = MyModel()\n+        model = SubclassModel(name=\"subclass\")\n         model.build((None, 3))\n \n-        file_name = \"subclassed.png\"\n-        plot_model(model, file_name)\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"subclassed-show_shapes.png\"\n-        plot_model(model, file_name, show_shapes=True)\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"subclassed-show_shapes-show_dtype.png\"\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"subclassed-show_shapes-show_dtype-show_layer_names.png\"\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = (\n-            \"subclassed-show_shapes-show_dtype-show_layer_activations.png\"\n-        )\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-            show_layer_activations=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"subclassed-show_shapes-show_dtype-show_layer_names-show_layer_activations-show_trainable.png\"  # noqa: E501\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"subclassed-show_shapes-show_dtype-show_layer_names-show_layer_activations-show_trainable-LR.png\"  # noqa: E501\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-            rankdir=\"LR\",\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"subclassed-show_layer_activations-show_trainable.png\"\n-        plot_model(\n-            model,\n-            file_name,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = (\n-            \"subclassed-show_shapes-show_layer_activations-show_trainable.png\"\n-        )\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-        )\n-        self.assertFileExists(file_name)\n+        self.multi_plot_model(model, \"subclassed\")\n \n     def test_plot_nested_functional_model(self):\n         inputs = keras.Input((3,), name=\"input\")\n@@ -368,114 +223,44 @@ class ModelVisualizationTest(testing.TestCase):\n         model = keras.Model(inputs, outputs)\n \n         edge_dict = get_edge_dict(model_to_dot(model))\n-\n-        self.assertEqual(edge_dict[\"input_1 (InputLayer)\"], \"dense_3 (Dense)\")\n-        self.assertEqual(edge_dict[\"dense_3 (Dense)\"], \"add (Add)\")\n-        self.assertEqual(edge_dict[\"inner_model (Functional)\"], \"add (Add)\")\n-        self.assertEqual(edge_dict[\"add (Add)\"], \"add_1 (Add)\")\n-        self.assertEqual(edge_dict[\"dense_4 (Dense)\"], \"dense_5 (Dense)\")\n-        self.assertEqual(edge_dict[\"dense_5 (Dense)\"], \"dense_6 (Dense)\")\n-        self.assertEqual(edge_dict[\"dense_6 (Dense)\"], \"add_1 (Add)\")\n-        self.assertEqual(edge_dict[\"add_1 (Add)\"], \"dropout (Dropout)\")\n-        self.assertEqual(edge_dict[\"dropout (Dropout)\"], \"dense_7 (Dense)\")\n-\n-        file_name = \"nested-functional.png\"\n-        plot_model(model, file_name, expand_nested=True)\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"nested-functional-show_shapes.png\"\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            expand_nested=True,\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"input_1 (InputLayer)\": \"dense_3 (Dense)\",\n+                \"dense_3 (Dense)\": {\"inner_model (Functional)\", \"add (Add)\"},\n+                \"inner_model (Functional)\": \"add (Add)\",\n+                \"add (Add)\": {\"dense_4 (Dense)\", \"add_1 (Add)\"},\n+                \"dense_4 (Dense)\": \"dense_5 (Dense)\",\n+                \"dense_5 (Dense)\": \"dense_6 (Dense)\",\n+                \"dense_6 (Dense)\": \"add_1 (Add)\",\n+                \"add_1 (Add)\": \"dropout (Dropout)\",\n+                \"dropout (Dropout)\": \"dense_7 (Dense)\",\n+            },\n         )\n-        self.assertFileExists(file_name)\n+        self.multi_plot_model(model, \"nested-functional\")\n \n-        file_name = \"nested-functional-show_shapes-show_dtype.png\"\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            expand_nested=True,\n+        edge_dict = get_edge_dict(model_to_dot(model, expand_nested=True))\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"input_1 (InputLayer)\": \"dense_3 (Dense)\",\n+                \"dense_3 (Dense)\": {\n+                    \"inner_model > input (InputLayer)\",\n+                    \"add (Add)\",\n+                },\n+                \"inner_model > input (InputLayer)\": \"inner_model > dense (Dense)\",  # noqa: E501\n+                \"inner_model > dense (Dense)\": \"inner_model > dense_1 (Dense)\",  # noqa: E501\n+                \"inner_model > dense_1 (Dense)\": \"inner_model > dense_2 (Dense)\",  # noqa: E501\n+                \"inner_model > dense_2 (Dense)\": \"add (Add)\",\n+                \"add (Add)\": {\"dense_4 (Dense)\", \"add_1 (Add)\"},\n+                \"dense_4 (Dense)\": \"dense_5 (Dense)\",\n+                \"dense_5 (Dense)\": \"dense_6 (Dense)\",\n+                \"dense_6 (Dense)\": \"add_1 (Add)\",\n+                \"add_1 (Add)\": \"dropout (Dropout)\",\n+                \"dropout (Dropout)\": \"dense_7 (Dense)\",\n+            },\n         )\n-        self.assertFileExists(file_name)\n-\n-        file_name = (\n-            \"nested-functional-show_shapes-show_dtype-show_layer_names.png\"\n-        )\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-            expand_nested=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"nested-functional-show_shapes-show_dtype-show_layer_names-show_layer_activations.png\"  # noqa: E501\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-            show_layer_activations=True,\n-            expand_nested=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"nested-functional-show_shapes-show_dtype-show_layer_names-show_layer_activations-show_trainable.png\"  # noqa: E501\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-            expand_nested=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"nested-functional-show_shapes-show_dtype-show_layer_names-show_layer_activations-show_trainable-LR.png\"  # noqa: E501\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            show_layer_names=True,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-            rankdir=\"LR\",\n-            expand_nested=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = (\n-            \"nested-functional-show_layer_activations-show_trainable.png\"\n-        )\n-        plot_model(\n-            model,\n-            file_name,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-            expand_nested=True,\n-        )\n-        self.assertFileExists(file_name)\n-\n-        file_name = \"nested-functional-show_shapes-show_layer_activations-show_trainable.png\"  # noqa: E501\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_layer_activations=True,\n-            show_trainable=True,\n-            expand_nested=True,\n-        )\n-        self.assertFileExists(file_name)\n+        self.multi_plot_model(model, \"nested-functional\", expand_nested=True)\n \n     def test_plot_functional_model_with_splits_and_merges(self):\n         class SplitLayer(keras.Layer):\n@@ -496,39 +281,522 @@ class ModelVisualizationTest(testing.TestCase):\n         model = keras.Model(inputs, outputs)\n \n         edge_dict = get_edge_dict(model_to_dot(model))\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"input (InputLayer)\": \"split_layer (SplitLayer)\",\n+                \"split_layer (SplitLayer)\": {\n+                    \"dense (Dense)\",\n+                    \"dense_1 (Dense)\",\n+                },\n+                \"dense (Dense)\": \"concat_layer (ConcatLayer)\",\n+                \"dense_1 (Dense)\": \"concat_layer (ConcatLayer)\",\n+            },\n+        )\n+        self.multi_plot_model(model, \"split-functional\")\n \n-        self.assertEqual(\n-            edge_dict[\"input (InputLayer)\"], \"split_layer (SplitLayer)\"\n+    def test_plot_sequential_in_sequential(self):\n+        inner_model = keras.models.Sequential(\n+            [\n+                keras.layers.Dense(10, name=\"dense2\"),\n+                keras.layers.Dense(10, name=\"dense3\"),\n+            ],\n+            name=\"sub\",\n         )\n-        self.assertEqual(\n-            edge_dict[\"split_layer (SplitLayer)\"], \"dense_1 (Dense)\"\n+        model = keras.models.Sequential(\n+            [\n+                keras.layers.Dense(10, name=\"dense1\"),\n+                inner_model,\n+            ],\n         )\n+        model.build((1, 10))\n+\n+        #\n+        #  +-------------------------+\n+        #  |     dense1 (Dense)      |\n+        #  +-------------------------+\n+        #               |\n+        #               v\n+        #  +-------------------------+\n+        #  |    sub (Sequential)     |\n+        #  +-------------------------+\n+        #\n+        edge_dict = get_edge_dict(model_to_dot(model))\n         self.assertEqual(\n-            edge_dict[\"dense (Dense)\"], \"concat_layer (ConcatLayer)\"\n+            edge_dict,\n+            {\n+                \"dense1 (Dense)\": \"sub (Sequential)\",\n+            },\n         )\n+        self.multi_plot_model(model, \"sequential_in_sequential\")\n+\n+        #\n+        #    +-------------------------+\n+        #    |     dense1 (Dense)      |\n+        #    +-------------------------+\n+        #                 |\n+        #  +--------------|--------------+\n+        #  | sub          v              |\n+        #  | +-------------------------+ |\n+        #  | |     dense2 (Dense)      | |\n+        #  | +-------------------------+ |\n+        #  |              |              |\n+        #  |              v              |\n+        #  | +-------------------------+ |\n+        #  | |     dense3 (Dense)      | |\n+        #  | +-------------------------+ |\n+        #  +-----------------------------+\n+        #\n+        edge_dict = get_edge_dict(model_to_dot(model, expand_nested=True))\n         self.assertEqual(\n-            edge_dict[\"dense_1 (Dense)\"], \"concat_layer (ConcatLayer)\"\n+            edge_dict,\n+            {\n+                \"dense1 (Dense)\": \"sub > dense2 (Dense)\",\n+                \"sub > dense2 (Dense)\": \"sub > dense3 (Dense)\",\n+            },\n+        )\n+        self.multi_plot_model(\n+            model, \"sequential_in_sequential\", expand_nested=True\n         )\n \n-        file_name = \"split-functional.png\"\n-        plot_model(model, file_name, expand_nested=True)\n-        self.assertFileExists(file_name)\n+    def test_plot_functional_in_functional(self):\n+        inner_input = keras.layers.Input((10,), name=\"inner_input\")\n+        x = keras.layers.Dense(10, name=\"dense1\")(inner_input)\n+        x = keras.layers.Dense(10, name=\"dense2\")(x)\n+        inner_model = keras.models.Model(inner_input, x, name=\"inner\")\n \n-        file_name = \"split-functional-show_shapes.png\"\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            expand_nested=True,\n-        )\n-        self.assertFileExists(file_name)\n+        outer_input = keras.layers.Input((10,), name=\"outer_input\")\n+        model = keras.models.Model(outer_input, inner_model(outer_input))\n \n-        file_name = \"split-functional-show_shapes-show_dtype.png\"\n-        plot_model(\n-            model,\n-            file_name,\n-            show_shapes=True,\n-            show_dtype=True,\n-            expand_nested=True,\n+        #\n+        #  +-------------------------+\n+        #  |outer_input (InputLayer) |\n+        #  +-------------------------+\n+        #               |\n+        #               v\n+        #  +-------------------------+\n+        #  |   inner (Functional)    |\n+        #  +-------------------------+\n+        #\n+        edge_dict = get_edge_dict(model_to_dot(model))\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"outer_input (InputLayer)\": \"inner (Functional)\",\n+            },\n         )\n-        self.assertFileExists(file_name)\n+        self.multi_plot_model(model, \"functional_in_functional\")\n+\n+        #\n+        #    +-------------------------+\n+        #    |outer_input (InputLayer) |\n+        #    +-------------------------+\n+        #                 |\n+        #  +--------------|--------------+\n+        #  | inner        v              |\n+        #  | +-------------------------+ |\n+        #  | |inner_input (InputLayer) | |\n+        #  | +-------------------------+ |\n+        #  |              |              |\n+        #  |              v              |\n+        #  | +-------------------------+ |\n+        #  | |     dense1 (Dense)      | |\n+        #  | +-------------------------+ |\n+        #  |              |              |\n+        #  |              v              |\n+        #  | +-------------------------+ |\n+        #  | |     dense2 (Dense)      | |\n+        #  | +-------------------------+ |\n+        #  +-----------------------------+\n+        #\n+        edge_dict = get_edge_dict(model_to_dot(model, expand_nested=True))\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"outer_input (InputLayer)\": \"inner > inner_input (InputLayer)\",\n+                \"inner > inner_input (InputLayer)\": \"inner > dense1 (Dense)\",\n+                \"inner > dense1 (Dense)\": \"inner > dense2 (Dense)\",\n+            },\n+        )\n+        self.multi_plot_model(\n+            model, \"functional_in_functional\", expand_nested=True\n+        )\n+\n+    def test_plot_sequential_in_sequential_in_sequential(self):\n+        inner_model = keras.models.Sequential(\n+            [\n+                keras.layers.Dense(10, name=\"dense2\"),\n+                keras.layers.Dense(10, name=\"dense3\"),\n+            ],\n+            name=\"inner\",\n+        )\n+        mid_model = keras.models.Sequential(\n+            [\n+                inner_model,\n+            ],\n+            name=\"mid\",\n+        )\n+        model = keras.models.Sequential(\n+            [\n+                keras.layers.Dense(10, name=\"dense1\"),\n+                mid_model,\n+                keras.layers.Dense(10, name=\"dense4\"),\n+            ],\n+        )\n+        model.build((1, 10))\n+\n+        #\n+        #  +-------------------------+\n+        #  |     dense1 (Dense)      |\n+        #  +-------------------------+\n+        #               |\n+        #               v\n+        #  +-------------------------+\n+        #  |    mid (Sequential)     |\n+        #  +-------------------------+\n+        #               |\n+        #               v\n+        #  +-------------------------+\n+        #  |     dense4 (Dense)      |\n+        #  +-------------------------+\n+        #\n+        edge_dict = get_edge_dict(model_to_dot(model))\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"dense1 (Dense)\": \"mid (Sequential)\",\n+                \"mid (Sequential)\": \"dense4 (Dense)\",\n+            },\n+        )\n+        self.multi_plot_model(model, \"sequential_in_sequential_in_sequential\")\n+\n+        #\n+        #      +-------------------------+\n+        #      |     dense1 (Dense)      |\n+        #      +-------------------------+\n+        #                   |\n+        #  +----------------|----------------+\n+        #  | mid            |                |\n+        #  | +--------------|--------------+ |\n+        #  | | inner        v              | |\n+        #  | | +-------------------------+ | |\n+        #  | | |     dense2 (Dense)      | | |\n+        #  | | +-------------------------+ | |\n+        #  | |              |              | |\n+        #  | |              v              | |\n+        #  | | +-------------------------+ | |\n+        #  | | |     dense3 (Dense)      | | |\n+        #  | | +-------------------------+ | |\n+        #  | +--------------|--------------+ |\n+        #  +----------------|----------------+\n+        #                   v\n+        #      +-------------------------+\n+        #      |     dense4 (Dense)      |\n+        #      +-------------------------+\n+        #\n+        edge_dict = get_edge_dict(model_to_dot(model, expand_nested=True))\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"dense1 (Dense)\": \"mid > inner > dense2 (Dense)\",\n+                \"mid > inner > dense2 (Dense)\": \"mid > inner > dense3 (Dense)\",\n+                \"mid > inner > dense3 (Dense)\": \"dense4 (Dense)\",\n+            },\n+        )\n+        self.multi_plot_model(\n+            model, \"sequential_in_sequential_in_sequential\", expand_nested=True\n+        )\n+\n+    def test_plot_functional_in_sequential_in_sequential(self):\n+        input1 = keras.layers.Input((10,), name=\"input1\")\n+        x = keras.layers.Dense(10, name=\"dense2\")(input1)\n+        inner_model = keras.models.Model(input1, x, name=\"inner\")\n+\n+        mid_model = keras.models.Sequential(\n+            [\n+                inner_model,\n+            ],\n+            name=\"mid\",\n+        )\n+        model = keras.models.Sequential(\n+            [\n+                keras.layers.Dense(10, name=\"dense1\"),\n+                mid_model,\n+                keras.layers.Dense(10, name=\"dense3\"),\n+            ],\n+        )\n+        model.build((1, 10))\n+\n+        #\n+        #  +-------------------------+\n+        #  |     dense1 (Dense)      |\n+        #  +-------------------------+\n+        #               |\n+        #               v\n+        #  +-------------------------+\n+        #  |    mid (Sequential)     |\n+        #  +-------------------------+\n+        #               |\n+        #               v\n+        #  +-------------------------+\n+        #  |     dense3 (Dense)      |\n+        #  +-------------------------+\n+        #\n+        edge_dict = get_edge_dict(model_to_dot(model))\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"dense1 (Dense)\": \"mid (Sequential)\",\n+                \"mid (Sequential)\": \"dense3 (Dense)\",\n+            },\n+        )\n+        self.multi_plot_model(model, \"functional_in_sequential_in_sequential\")\n+\n+        #\n+        #      +-------------------------+\n+        #      |     dense1 (Dense)      |\n+        #      +-------------------------+\n+        #                   |\n+        #  +----------------|----------------+\n+        #  | mid            |                |\n+        #  | +--------------|--------------+ |\n+        #  | | inner        v              | |\n+        #  | | +-------------------------+ | |\n+        #  | | |   input1 (Inputlayer)   | | |\n+        #  | | +-------------------------+ | |\n+        #  | |              |              | |\n+        #  | |              v              | |\n+        #  | | +-------------------------+ | |\n+        #  | | |     dense2 (Dense)      | | |\n+        #  | | +-------------------------+ | |\n+        #  | +--------------|--------------+ |\n+        #  +----------------|----------------+\n+        #                   v\n+        #      +-------------------------+\n+        #      |     dense3 (Dense)      |\n+        #      +-------------------------+\n+        #\n+        edge_dict = get_edge_dict(model_to_dot(model, expand_nested=True))\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"dense1 (Dense)\": \"mid > inner > input1 (InputLayer)\",\n+                \"mid > inner > input1 (InputLayer)\": \"mid > inner > dense2 (Dense)\",  # noqa: E501\n+                \"mid > inner > dense2 (Dense)\": \"dense3 (Dense)\",\n+            },\n+        )\n+        self.multi_plot_model(\n+            model, \"functional_in_sequential_in_sequential\", expand_nested=True\n+        )\n+\n+    def test_plot_functional_in_functional_in_functional(self):\n+        # From https://github.com/keras-team/keras/issues/21119\n+        inner_input = keras.layers.Input((10,), name=\"inner_input\")\n+        x = keras.layers.Dense(10, name=\"dense1\")(inner_input)\n+        inner_model = keras.models.Model(inner_input, x, name=\"inner\")\n+\n+        mid_input = keras.layers.Input((10,), name=\"mid_input\")\n+        mid_output = inner_model(mid_input)\n+        mid_model = keras.models.Model(mid_input, mid_output, name=\"mid\")\n+\n+        outer_input = keras.layers.Input((10,), name=\"outer_input\")\n+        x = mid_model(outer_input)\n+        x = keras.layers.Dense(10, name=\"dense2\")(x)\n+        model = keras.models.Model(outer_input, x)\n+\n+        #\n+        #  +-------------------------+\n+        #  |outer_input (InputLayer) |\n+        #  +-------------------------+\n+        #               |\n+        #               v\n+        #  +-------------------------+\n+        #  |    mid (Functional)     |\n+        #  +-------------------------+\n+        #               |\n+        #               v\n+        #  +-------------------------+\n+        #  |     dense2 (Dense)      |\n+        #  +-------------------------+\n+        #\n+        edge_dict = get_edge_dict(model_to_dot(model))\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"outer_input (InputLayer)\": \"mid (Functional)\",\n+                \"mid (Functional)\": \"dense2 (Dense)\",\n+            },\n+        )\n+        self.multi_plot_model(model, \"functional_in_functional_in_functional\")\n+\n+        #\n+        #      +-------------------------+\n+        #      |outer_input (InputLayer) |\n+        #      +-------------------------+\n+        #                   |\n+        #  +----------------|----------------+\n+        #  | mid            |                |\n+        #  |   +-------------------------+   |\n+        #  |   | mid_input (Inputlayer)  |   |\n+        #  |   +-------------------------+   |\n+        #  | +--------------|--------------+ |\n+        #  | | inner        v              | |\n+        #  | | +-------------------------+ | |\n+        #  | | |inner_input (Inputlayer) | | |\n+        #  | | +-------------------------+ | |\n+        #  | |              |              | |\n+        #  | |              v              | |\n+        #  | | +-------------------------+ | |\n+        #  | | |     dense1 (Dense)      | | |\n+        #  | | +-------------------------+ | |\n+        #  | +--------------|--------------+ |\n+        #  +----------------|----------------+\n+        #                   v\n+        #      +-------------------------+\n+        #      |     dense2 (Dense)      |\n+        #      +-------------------------+\n+        #\n+        edge_dict = get_edge_dict(model_to_dot(model, expand_nested=True))\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"outer_input (InputLayer)\": \"mid > mid_input (InputLayer)\",\n+                \"mid > mid_input (InputLayer)\": \"mid > inner > inner_input (InputLayer)\",  # noqa: E501\n+                \"mid > inner > inner_input (InputLayer)\": \"mid > inner > dense1 (Dense)\",  # noqa: E501\n+                \"mid > inner > dense1 (Dense)\": \"dense2 (Dense)\",\n+            },\n+        )\n+        self.multi_plot_model(\n+            model, \"functional_in_functional_in_functional\", expand_nested=True\n+        )\n+\n+    def test_plot_complex(self):\n+        # Note: this test exercises the case when `output_index` is not 0 and\n+        # changes when going deeply in nested models to resolve the destination\n+        # of an edge.\n+        inner_inpt1 = keras.layers.Input(shape=(10,), name=\"inner_inpt1\")\n+        inner_inpt2 = keras.layers.Input(shape=(10,), name=\"inner_inpt2\")\n+        inner_model = keras.models.Model(\n+            [inner_inpt1, inner_inpt2],\n+            [\n+                keras.layers.Dense(10, name=\"dense1\")(inner_inpt1),\n+                keras.layers.Dense(10, name=\"dense2\")(inner_inpt2),\n+            ],\n+            name=\"inner\",\n+        )\n+\n+        input0 = keras.layers.Input(shape=(10,), name=\"input0\")\n+        input1 = keras.layers.Input(shape=(10,), name=\"input1\")\n+        input2 = keras.layers.Input(shape=(10,), name=\"input2\")\n+        input3 = keras.layers.Input(shape=(10,), name=\"input3\")\n+\n+        mid_sequential = keras.models.Sequential(\n+            [\n+                keras.layers.Dense(10, name=\"dense0\"),\n+                SubclassModel(name=\"subclass0\"),\n+            ],\n+            name=\"seq\",\n+        )\n+        mid_subclass = SubclassModel(name=\"subclass3\")\n+        mid_model = keras.models.Model(\n+            [input0, input1, input2, input3],\n+            [\n+                mid_sequential(input0),\n+                *inner_model([input1, input2]),\n+                mid_subclass(input3),\n+            ],\n+            name=\"mid\",\n+        )\n+\n+        outer_input = keras.layers.Input((10,), name=\"outer_input\")\n+        mid_outputs = mid_model(\n+            [outer_input, outer_input, outer_input, outer_input]\n+        )\n+        model = keras.models.Model(\n+            outer_input,\n+            [\n+                keras.layers.Add(name=\"add1\")([mid_outputs[0], mid_outputs[1]]),\n+                keras.layers.Add(name=\"add2\")([mid_outputs[2], mid_outputs[3]]),\n+            ],\n+        )\n+\n+        #\n+        #                 +-------------------------+\n+        #                 |outer_input (InputLayer) |\n+        #                 +-------------------------+\n+        #                              |\n+        #                              v\n+        #                 +-------------------------+\n+        #                 |    mid (Functional)     |\n+        #                 +-------------------------+\n+        #                          |      |\n+        #                          v      v\n+        #  +-------------------------+  +-------------------------+\n+        #  |       add1 (Add)        |  |       add2 (Add)        |\n+        #  +-------------------------+  +-------------------------+\n+        #\n+        edge_dict = get_edge_dict(model_to_dot(model))\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                \"outer_input (InputLayer)\": \"mid (Functional)\",\n+                \"mid (Functional)\": {\"add1 (Add)\", \"add2 (Add)\"},\n+            },\n+        )\n+        self.multi_plot_model(model, \"complex\")\n+\n+        #\n+        #                               +-----------+\n+        #            +------------------|outer_input|-----------------+\n+        #            |                  +-----------+                 |\n+        #            |                   |         |                  |\n+        #  +---------|-------------------|---------|------------------|-------+\n+        #  | mid     v                   v         v                  v       |\n+        #  |   +-----------+     +-----------+ +-----------+    +-----------+ |\n+        #  |   |  input0   |     |  input1   | |  input2   |    |  input3   | |\n+        #  |   +-----------+     +-----------+ +-----------+    +-----------+ |\n+        #  | +-------|-------+ +-------|-------------|-------+        |       |\n+        #  | | seq   v       | | inner v             v       |        |       |\n+        #  | | +-----------+ | | +-----------+ +-----------+ |  +-----------+ |\n+        #  | | |  dense0   | | | |inner_inp1t| |inner_inp2t| |  | subclass3 | |\n+        #  | | +-----------+ | | +-----------+ +-----------+ |  +-----------+ |\n+        #  | |       |       | |       |             |       |    |           |\n+        #  | |       v       | |       v             v       |    |           |\n+        #  | | +-----------+ | | +-----------+ +-----------+ |    |           |\n+        #  | | | subclass0 | | | |  dense1   | |  dense2   | |    |           |\n+        #  | | +-----------+ | | +-----------+ +-----------+ |    |           |\n+        #  | +-----------|---+ +---|---------------------|---+    |           |\n+        #  +-------------|---------|---------------------|--------|-----------+\n+        #                v         v                     v        v\n+        #               +-----------+                   +-----------+\n+        #               |    add1   |                   |   add2    |\n+        #               +-----------+                   +-----------+\n+        #\n+        edge_dict = get_edge_dict(model_to_dot(model, expand_nested=True))\n+        self.assertEqual(\n+            edge_dict,\n+            {\n+                # 1st row\n+                \"outer_input (InputLayer)\": {\n+                    \"mid > input0 (InputLayer)\",\n+                    \"mid > input1 (InputLayer)\",\n+                    \"mid > input2 (InputLayer)\",\n+                    \"mid > input3 (InputLayer)\",\n+                },\n+                # 2nd row\n+                \"mid > input0 (InputLayer)\": \"mid > seq > dense0 (Dense)\",\n+                \"mid > input1 (InputLayer)\": \"mid > inner > inner_inpt1 (InputLayer)\",  # noqa: E501\n+                \"mid > input2 (InputLayer)\": \"mid > inner > inner_inpt2 (InputLayer)\",  # noqa: E501\n+                \"mid > input3 (InputLayer)\": \"mid > subclass3 (SubclassModel)\",\n+                # 3rd row\n+                \"mid > seq > dense0 (Dense)\": \"mid > seq > subclass0 (SubclassModel)\",  # noqa: E501\n+                \"mid > inner > inner_inpt1 (InputLayer)\": \"mid > inner > dense1 (Dense)\",  # noqa: E501\n+                \"mid > inner > inner_inpt2 (InputLayer)\": \"mid > inner > dense2 (Dense)\",  # noqa: E501\n+                # 4th row\n+                \"mid > seq > subclass0 (SubclassModel)\": \"add1 (Add)\",\n+                \"mid > inner > dense1 (Dense)\": \"add1 (Add)\",\n+                \"mid > inner > dense2 (Dense)\": \"add2 (Add)\",\n+                \"mid > subclass3 (SubclassModel)\": \"add2 (Add)\",\n+            },\n+        )\n+        self.multi_plot_model(model, \"complex\", expand_nested=True)\n\n@@ -40,8 +40,10 @@ def check_graphviz():\n \n \n def add_edge(dot, src, dst):\n-    if not dot.get_edge(src, dst):\n-        edge = pydot.Edge(src, dst)\n+    src_id = str(id(src))\n+    dst_id = str(id(dst))\n+    if not dot.get_edge(src_id, dst_id):\n+        edge = pydot.Edge(src_id, dst_id)\n         edge.set(\"penwidth\", \"2\")\n         dot.add_edge(edge)\n \n@@ -189,14 +191,6 @@ def make_node(layer, **kwargs):\n     return node\n \n \n-def remove_unused_edges(dot):\n-    nodes = [v.get_name() for v in dot.get_nodes()]\n-    for edge in dot.get_edges():\n-        if edge.get_destination() not in nodes:\n-            dot.del_edge(edge.get_source(), edge.get_destination())\n-    return dot\n-\n-\n @keras_export(\"keras.utils.model_to_dot\")\n def model_to_dot(\n     model,\n@@ -290,11 +284,11 @@ def model_to_dot(\n         layers = model._operations\n \n     # Create graph nodes.\n-    sub_n_first_node = {}\n-    sub_n_last_node = {}\n     for i, layer in enumerate(layers):\n-        # Process nested functional models.\n-        if expand_nested and isinstance(layer, functional.Functional):\n+        # Process nested functional and sequential models.\n+        if expand_nested and isinstance(\n+            layer, (functional.Functional, sequential.Sequential)\n+        ):\n             submodel = model_to_dot(\n                 layer,\n                 show_shapes,\n@@ -306,10 +300,6 @@ def model_to_dot(\n                 show_layer_activations=show_layer_activations,\n                 show_trainable=show_trainable,\n             )\n-            # sub_n : submodel\n-            sub_n_nodes = submodel.get_nodes()\n-            sub_n_first_node[layer.name] = sub_n_nodes[0]\n-            sub_n_last_node[layer.name] = sub_n_nodes[-1]\n             dot.add_subgraph(submodel)\n \n         else:\n@@ -317,54 +307,98 @@ def model_to_dot(\n             dot.add_node(node)\n \n     # Connect nodes with edges.\n-    # Sequential case.\n     if isinstance(model, sequential.Sequential):\n-        for i in range(len(layers) - 1):\n-            inbound_layer_id = str(id(layers[i]))\n-            layer_id = str(id(layers[i + 1]))\n-            add_edge(dot, inbound_layer_id, layer_id)\n-        return dot\n-\n-    # Functional case.\n-    for i, layer in enumerate(layers):\n-        layer_id = str(id(layer))\n-        for i, node in enumerate(layer._inbound_nodes):\n-            node_key = make_node_key(layer, i)\n-            if node_key in model._nodes:\n-                for parent_node in node.parent_nodes:\n-                    inbound_layer = parent_node.operation\n-                    inbound_layer_id = str(id(inbound_layer))\n         if not expand_nested:\n-                        assert dot.get_node(inbound_layer_id)\n-                        assert dot.get_node(layer_id)\n-                        add_edge(dot, inbound_layer_id, layer_id)\n+            # Single Sequential case.\n+            for i in range(len(layers) - 1):\n+                add_edge(dot, layers[i], layers[i + 1])\n+            return dot\n         else:\n-                        # if inbound_layer is not Functional\n-                        if not isinstance(inbound_layer, functional.Functional):\n-                            # if current layer is not Functional\n-                            if not isinstance(layer, functional.Functional):\n-                                assert dot.get_node(inbound_layer_id)\n-                                assert dot.get_node(layer_id)\n-                                add_edge(dot, inbound_layer_id, layer_id)\n-                            # if current layer is Functional\n-                            elif isinstance(layer, functional.Functional):\n-                                add_edge(\n-                                    dot,\n-                                    inbound_layer_id,\n-                                    sub_n_first_node[layer.name].get_name(),\n-                                )\n-                        # if inbound_layer is Functional\n-                        elif isinstance(inbound_layer, functional.Functional):\n-                            name = sub_n_last_node[\n-                                inbound_layer.name\n-                            ].get_name()\n-                            if isinstance(layer, functional.Functional):\n-                                output_name = sub_n_first_node[\n-                                    layer.name\n-                                ].get_name()\n-                                add_edge(dot, name, output_name)\n+            # The first layer is connected to the `InputLayer`, which is not\n+            # represented for Sequential models, so we skip it. What will draw\n+            # the incoming edge from outside of the sequential model is the\n+            # edge connecting the Sequential model itself.\n+            layers = model.layers[1:]\n+\n+    # Functional and nested Sequential case.\n+    for layer in layers:\n+        # Go from current layer to input `Node`s.\n+        for inbound_index, inbound_node in enumerate(layer._inbound_nodes):\n+            # `inbound_node` is a `Node`.\n+            if (\n+                isinstance(model, functional.Functional)\n+                and make_node_key(layer, inbound_index) not in model._nodes\n+            ):\n+                continue\n+\n+            # Go from input `Node` to `KerasTensor` representing that input.\n+            for input_index, input_tensor in enumerate(\n+                inbound_node.input_tensors\n+            ):\n+                # `input_tensor` is a `KerasTensor`.\n+                # `input_history` is a `KerasHistory`.\n+                input_history = input_tensor._keras_history\n+                if input_history.operation is None:\n+                    # Operation is `None` for `Input` tensors.\n+                    continue\n+\n+                # Go from input `KerasTensor` to the `Operation` that produced\n+                # it as an output.\n+                input_node = input_history.operation._inbound_nodes[\n+                    input_history.node_index\n+                ]\n+                output_index = input_history.tensor_index\n+\n+                # Tentative source and destination of the edge.\n+                source = input_node.operation\n+                destination = layer\n+\n+                if not expand_nested:\n+                    # No nesting, connect directly.\n+                    add_edge(dot, source, layer)\n+                    continue\n+\n+                # ==== Potentially nested models case ====\n+\n+                # ---- Resolve the source of the edge ----\n+                while isinstance(\n+                    source,\n+                    (functional.Functional, sequential.Sequential),\n+                ):\n+                    # When `source` is a `Functional` or `Sequential` model, we\n+                    # need to connect to the correct box within that model.\n+                    # Functional and sequential models do not have explicit\n+                    # \"output\" boxes, so we need to find the correct layer that\n+                    # produces the output we're connecting to, which can be\n+                    # nested several levels deep in sub-models. Hence the while\n+                    # loop to continue going into nested models until we\n+                    # encounter a real layer that's not a `Functional` or\n+                    # `Sequential`.\n+                    source, _, output_index = source.outputs[\n+                        output_index\n+                    ]._keras_history\n+\n+                # ---- Resolve the destination of the edge ----\n+                while isinstance(\n+                    destination,\n+                    (functional.Functional, sequential.Sequential),\n+                ):\n+                    if isinstance(destination, functional.Functional):\n+                        # When `destination` is a `Functional`, we point to the\n+                        # specific `InputLayer` in the model.\n+                        destination = destination.inputs[\n+                            input_index\n+                        ]._keras_history.operation\n                     else:\n-                                add_edge(dot, name, layer_id)\n+                        # When `destination` is a `Sequential`, there is no\n+                        # explicit \"input\" box, so we want to point to the first\n+                        # box in the model, but it may itself be another model.\n+                        # Hence the while loop to continue going into nested\n+                        # models until we encounter a real layer that's not a\n+                        # `Functional` or `Sequential`.\n+                        destination = destination.layers[0]\n+\n+                add_edge(dot, source, destination)\n     return dot\n \n \n@@ -467,7 +501,6 @@ def plot_model(\n     to_file = str(to_file)\n     if dot is None:\n         return\n-    dot = remove_unused_edges(dot)\n     _, extension = os.path.splitext(to_file)\n     if not extension:\n         extension = \"png\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
