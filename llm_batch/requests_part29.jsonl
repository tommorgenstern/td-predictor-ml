{"custom_id": "requests#7fdb09b766a84534dadfb56e46033697292cab60", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 30 | Lines Deleted: 55 | Files Changed: 3 | Hunks: 20 | Methods Changed: 13 | Complexity Δ (Sum/Max): -3/0 | Churn Δ: 85 | Churn Cumulative: 5471 | Contributors (this commit): 32 | Commits (past 90d): 169 | Contributors (cumulative): 44 | DMM Complexity: 1.0\n\nDIFF:\n@@ -16,26 +16,32 @@ from urlparse import urlparse\n from .utils import randombytes, parse_dict_header\n \n \n-def http_basic(r, username, password):\n-    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\n-    Arguments should be considered non-positional.\n+class AuthBase(object):\n+    \"\"\"Base class that all auth implementations derive from\"\"\"\n \n-    \"\"\"\n-    username = str(username)\n-    password = str(password)\n+    def __call__(self, r):\n+        raise NotImplementedError('Auth hooks must be callable.')\n \n-    auth_s = b64encode('%s:%s' % (username, password))\n+\n+class HTTPBasicAuth(AuthBase):\n+    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n+    def __init__(self, username, password):\n+        self.username = str(username)\n+        self.password = str(password)\n+\n+    def __call__(self, r):\n+        auth_s = b64encode('%s:%s' % (self.username, self.password))\n         r.headers['Authorization'] = ('Basic %s' % auth_s)\n-\n         return r\n \n \n-def http_digest(r, username, password):\n-    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\n-    Arguments should be considered non-positional.\n-    \"\"\"\n+class HTTPDigestAuth(AuthBase):\n+    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n+    def __init__(self, username, password):\n+        self.username = username\n+        self.password = password\n \n-    def handle_401(r):\n+    def handle_401(self, r):\n         \"\"\"Takes the given response and tries digest-auth, if needed.\"\"\"\n \n         s_auth = r.headers.get('www-authenticate', '')\n@@ -70,7 +76,7 @@ def http_digest(r, username, password):\n             p_parsed = urlparse(r.request.url)\n             path = p_parsed.path + p_parsed.query\n \n-            A1 = \"%s:%s:%s\" % (username, realm, password)\n+            A1 = \"%s:%s:%s\" % (self.username, realm, self.password)\n             A2 = \"%s:%s\" % (r.request.method, path)\n \n             if qop == 'auth':\n@@ -95,7 +101,7 @@ def http_digest(r, username, password):\n \n             # XXX should the partial digests be encoded too?\n             base = 'username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", ' \\\n-                   'response=\"%s\"' % (username, realm, nonce, path, respdig)\n+                   'response=\"%s\"' % (self.username, realm, nonce, path, respdig)\n             if opaque:\n                 base += ', opaque=\"%s\"' % opaque\n             if entdig:\n@@ -104,7 +110,6 @@ def http_digest(r, username, password):\n             if qop:\n                 base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n \n-\n             r.request.headers['Authorization'] = 'Digest %s' % (base)\n             r.request.send(anyway=True)\n             _r = r.request.response\n@@ -114,33 +119,6 @@ def http_digest(r, username, password):\n \n         return r\n \n-    r.hooks['response'] = handle_401\n+    def __call__(self, r):\n+        r.hooks['response'] = self.handle_401\n         return r\n-\n-\n-def dispatch(t):\n-    \"\"\"Given an auth tuple, return an expanded version.\"\"\"\n-\n-    if not t:\n-        return t\n-    else:\n-        t = list(t)\n-\n-    # Make sure they're passing in something.\n-    assert len(t) >= 2\n-\n-    # If only two items are passed in, assume HTTPBasic.\n-    if (len(t) == 2):\n-        t.insert(0, 'basic')\n-\n-    # Allow built-in string referenced auths.\n-    if isinstance(t[0], basestring):\n-        if t[0] in ('basic', 'forced_basic'):\n-            t[0] = http_basic\n-        elif t[0] in ('digest',):\n-            t[0] = http_digest\n-\n-    # Return a custom callable.\n-    return (t[0], tuple(t[1:]))\n-\n-\n\n@@ -14,7 +14,6 @@ from Cookie import SimpleCookie\n from urlparse import urlparse, urlunparse, urljoin, urlsplit\n from datetime import datetime\n \n-from .auth import dispatch as auth_dispatch\n from .hooks import dispatch_hook\n from .structures import CaseInsensitiveDict\n from .status_codes import codes\n@@ -99,8 +98,7 @@ class Request(object):\n         self.response = Response()\n \n         #: Authentication tuple to attach to :class:`Request <Request>`.\n-        self._auth = auth\n-        self.auth = auth_dispatch(auth)\n+        self.auth = auth\n \n         #: CookieJar to attach to :class:`Request <Request>`.\n         self.cookies = dict(cookies or [])\n@@ -235,7 +233,7 @@ class Request(object):\n                     files=self.files,\n                     method=method,\n                     params=self.session.params,\n-                    auth=self._auth,\n+                    auth=self.auth,\n                     cookies=cookies,\n                     redirect=True,\n                     config=self.config,\n@@ -392,10 +390,8 @@ class Request(object):\n \n \n         if self.auth:\n-            auth_func, auth_args = self.auth\n-\n             # Allow auth to make its changes.\n-            r = auth_func(self, *auth_args)\n+            r = self.auth(self)\n \n             # Update self to reflect the auth changes.\n             self.__dict__.update(r.__dict__)\n\n@@ -10,6 +10,7 @@ import unittest\n import requests\n import envoy\n from requests import HTTPError\n+from requests.auth import HTTPBasicAuth, HTTPDigestAuth\n \n try:\n     import omnijson as json\n@@ -144,7 +145,7 @@ class RequestsTestSuite(unittest.TestCase):\n \n         for service in SERVICES:\n \n-            auth = ('user', 'pass')\n+            auth = HTTPBasicAuth('user', 'pass')\n             url = service('basic-auth', 'user', 'pass')\n \n             r = requests.get(url, auth=auth)\n@@ -163,7 +164,7 @@ class RequestsTestSuite(unittest.TestCase):\n \n         for service in SERVICES:\n \n-            auth = ('digest', 'user', 'pass')\n+            auth = HTTPDigestAuth('user', 'pass')\n             url = service('digest-auth', 'auth', 'user', 'pass')\n \n             r = requests.get(url, auth=auth)\n@@ -270,7 +271,7 @@ class RequestsTestSuite(unittest.TestCase):\n \n     def test_httpauth_recursion(self):\n \n-        http_auth = ('user', 'BADpass')\n+        http_auth = HTTPBasicAuth('user', 'BADpass')\n \n         for service in SERVICES:\n             r = requests.get(service('basic-auth', 'user', 'pass'), auth=http_auth)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#390024329756db774d5b044ebb124f58ef2ba503", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 3817 | Contributors (this commit): 26 | Commits (past 90d): 127 | Contributors (cumulative): 26 | DMM Complexity: None\n\nDIFF:\n@@ -214,7 +214,7 @@ class Request(object):\n                 # Facilitate non-RFC2616-compliant 'location' headers\n                 # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n                 if not urlparse(url).netloc:\n-                    url = urljoin(r.url, requote_path(url))\n+                    url = urljoin(r.url, url)\n \n                 # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n                 if r.status_code is codes.see_other:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c165255e9888d98ca7f6ff95b044be9b2abd7526", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 4 | Churn Cumulative: 700 | Contributors (this commit): 5 | Commits (past 90d): 40 | Contributors (cumulative): 5 | DMM Complexity: 0.0\n\nDIFF:\n@@ -140,6 +140,10 @@ class Session(object):\n         files = {} if files is None else files\n         headers = {} if headers is None else headers\n         params = {} if params is None else params\n+        hooks = {} if hooks is None else hooks\n+        # use session's hooks as defaults\n+        for key, cb in self.hooks.iteritems():\n+            hooks.setdefault(key, cb)\n \n         # Expand header values.\n         if headers:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#58e018af136190a2c757b13bf9371cecc2d51273", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 934 | Contributors (this commit): 12 | Commits (past 90d): 42 | Contributors (cumulative): 12 | DMM Complexity: None\n\nDIFF:\n@@ -37,7 +37,7 @@ def request(method, url,\n     :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.\n     :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n     :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n-    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n+    :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.\n     :param auth: (optional) Auth typle to enable Basic/Digest/Custom HTTP Auth.\n     :param timeout: (optional) Float describing the timeout of the request.\n     :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#5a7fbbb00d5b09b515bfe1e0b2768a29452d5ee6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 39 | Files Changed: 1 | Hunks: 1 | Methods Changed: 3 | Complexity Δ (Sum/Max): -4/0 | Churn Δ: 39 | Churn Cumulative: 500 | Contributors (this commit): 2 | Commits (past 90d): 5 | Contributors (cumulative): 2 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,39 +0,0 @@\n-#-*- coding: utf-8 -*-\n-\n-\"\"\"\n-requests.monkeys\n-~~~~~~~~~~~~~~~~\n-\n-Urllib2 Monkey patches.\n-\n-\"\"\"\n-\n-import urllib2\n-import re\n-\n-class Request(urllib2.Request):\n-    \"\"\"Hidden wrapper around the urllib2.Request object. Allows for manual\n-    setting of HTTP methods.\n-    \"\"\"\n-\n-    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):\n-        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)\n-        self.method = method\n-\n-    def get_method(self):\n-        if self.method:\n-            return self.method\n-\n-        return urllib2.Request.get_method(self)\n-\n-\n-class HTTPRedirectHandler(urllib2.HTTPRedirectHandler):\n-    \"\"\"HTTP Redirect handler.\"\"\"\n-    def _pass(self, req, fp, code, msg, headers):\n-        pass\n-\n-    http_error_302 = _pass\n-    http_error_303 = _pass\n-    http_error_307 = _pass\n-    http_error_301 = _pass\n-\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#43854067d42f53fece38348b2ce0bf12af95a09e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1197 | Lines Deleted: 0 | Files Changed: 4 | Hunks: 4 | Methods Changed: 52 | Complexity Δ (Sum/Max): 140/70 | Churn Δ: 1197 | Churn Cumulative: 1197 | Contributors (this commit): 1 | Commits (past 90d): 4 | Contributors (cumulative): 4 | DMM Complexity: 0.7062314540059347\n\nDIFF:\n@@ -0,0 +1,3 @@\n+# -*- coding: utf-8 -*-\n+\n+from .core import *\n\\ No newline at end of file\n\n@@ -0,0 +1,25 @@\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+oreos.core\n+~~~~~~~~~~\n+\n+The creamy white center.\n+\"\"\"\n+\n+from .structures import MultiDict\n+from .monkeys import SimpleCookie\n+\n+\n+def dict_from_string(s):\n+    \"\"\"Returns a MultiDict with Cookies.\"\"\"\n+\n+    cookies = MultiDict()\n+\n+    c = SimpleCookie()\n+    c.load(s)\n+\n+    for k,v in c.items():\n+        cookies.add(k, v.value)\n+\n+    return cookies\n\\ No newline at end of file\n\n@@ -0,0 +1,770 @@\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+oreos.monkeys\n+~~~~~~~~~~~~~\n+\n+Monkeypatches.\n+\"\"\"\n+#!/usr/bin/env python\n+#\n+\n+####\n+# Copyright 2000 by Timothy O'Malley <timo@alum.mit.edu>\n+#\n+#                All Rights Reserved\n+#\n+# Permission to use, copy, modify, and distribute this software\n+# and its documentation for any purpose and without fee is hereby\n+# granted, provided that the above copyright notice appear in all\n+# copies and that both that copyright notice and this permission\n+# notice appear in supporting documentation, and that the name of\n+# Timothy O'Malley  not be used in advertising or publicity\n+# pertaining to distribution of the software without specific, written\n+# prior permission.\n+#\n+# Timothy O'Malley DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n+# SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n+# AND FITNESS, IN NO EVENT SHALL Timothy O'Malley BE LIABLE FOR\n+# ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n+# PERFORMANCE OF THIS SOFTWARE.\n+#\n+####\n+#\n+# Id: Cookie.py,v 2.29 2000/08/23 05:28:49 timo Exp\n+#   by Timothy O'Malley <timo@alum.mit.edu>\n+#\n+#  Cookie.py is a Python module for the handling of HTTP\n+#  cookies as a Python dictionary.  See RFC 2109 for more\n+#  information on cookies.\n+#\n+#  The original idea to treat Cookies as a dictionary came from\n+#  Dave Mitchell (davem@magnet.com) in 1995, when he released the\n+#  first version of nscookie.py.\n+#\n+####\n+\n+r\"\"\"\n+Here's a sample session to show how to use this module.\n+At the moment, this is the only documentation.\n+\n+The Basics\n+----------\n+\n+Importing is easy..\n+\n+   >>> import Cookie\n+\n+Most of the time you start by creating a cookie.  Cookies come in\n+three flavors, each with slightly different encoding semantics, but\n+more on that later.\n+\n+   >>> C = Cookie.SimpleCookie()\n+   >>> C = Cookie.SerialCookie()\n+   >>> C = Cookie.SmartCookie()\n+\n+[Note: Long-time users of Cookie.py will remember using\n+Cookie.Cookie() to create an Cookie object.  Although deprecated, it\n+is still supported by the code.  See the Backward Compatibility notes\n+for more information.]\n+\n+Once you've created your Cookie, you can add values just as if it were\n+a dictionary.\n+\n+   >>> C = Cookie.SmartCookie()\n+   >>> C[\"fig\"] = \"newton\"\n+   >>> C[\"sugar\"] = \"wafer\"\n+   >>> C.output()\n+   'Set-Cookie: fig=newton\\r\\nSet-Cookie: sugar=wafer'\n+\n+Notice that the printable representation of a Cookie is the\n+appropriate format for a Set-Cookie: header.  This is the\n+default behavior.  You can change the header and printed\n+attributes by using the .output() function\n+\n+   >>> C = Cookie.SmartCookie()\n+   >>> C[\"rocky\"] = \"road\"\n+   >>> C[\"rocky\"][\"path\"] = \"/cookie\"\n+   >>> print C.output(header=\"Cookie:\")\n+   Cookie: rocky=road; Path=/cookie\n+   >>> print C.output(attrs=[], header=\"Cookie:\")\n+   Cookie: rocky=road\n+\n+The load() method of a Cookie extracts cookies from a string.  In a\n+CGI script, you would use this method to extract the cookies from the\n+HTTP_COOKIE environment variable.\n+\n+   >>> C = Cookie.SmartCookie()\n+   >>> C.load(\"chips=ahoy; vienna=finger\")\n+   >>> C.output()\n+   'Set-Cookie: chips=ahoy\\r\\nSet-Cookie: vienna=finger'\n+\n+The load() method is darn-tootin smart about identifying cookies\n+within a string.  Escaped quotation marks, nested semicolons, and other\n+such trickeries do not confuse it.\n+\n+   >>> C = Cookie.SmartCookie()\n+   >>> C.load('keebler=\"E=everybody; L=\\\\\"Loves\\\\\"; fudge=\\\\012;\";')\n+   >>> print C\n+   Set-Cookie: keebler=\"E=everybody; L=\\\"Loves\\\"; fudge=\\012;\"\n+\n+Each element of the Cookie also supports all of the RFC 2109\n+Cookie attributes.  Here's an example which sets the Path\n+attribute.\n+\n+   >>> C = Cookie.SmartCookie()\n+   >>> C[\"oreo\"] = \"doublestuff\"\n+   >>> C[\"oreo\"][\"path\"] = \"/\"\n+   >>> print C\n+   Set-Cookie: oreo=doublestuff; Path=/\n+\n+Each dictionary element has a 'value' attribute, which gives you\n+back the value associated with the key.\n+\n+   >>> C = Cookie.SmartCookie()\n+   >>> C[\"twix\"] = \"none for you\"\n+   >>> C[\"twix\"].value\n+   'none for you'\n+\n+\n+A Bit More Advanced\n+-------------------\n+\n+As mentioned before, there are three different flavors of Cookie\n+objects, each with different encoding/decoding semantics.  This\n+section briefly discusses the differences.\n+\n+SimpleCookie\n+\n+The SimpleCookie expects that all values should be standard strings.\n+Just to be sure, SimpleCookie invokes the str() builtin to convert\n+the value to a string, when the values are set dictionary-style.\n+\n+   >>> C = Cookie.SimpleCookie()\n+   >>> C[\"number\"] = 7\n+   >>> C[\"string\"] = \"seven\"\n+   >>> C[\"number\"].value\n+   '7'\n+   >>> C[\"string\"].value\n+   'seven'\n+   >>> C.output()\n+   'Set-Cookie: number=7\\r\\nSet-Cookie: string=seven'\n+\n+\n+SerialCookie\n+\n+The SerialCookie expects that all values should be serialized using\n+cPickle (or pickle, if cPickle isn't available).  As a result of\n+serializing, SerialCookie can save almost any Python object to a\n+value, and recover the exact same object when the cookie has been\n+returned.  (SerialCookie can yield some strange-looking cookie\n+values, however.)\n+\n+   >>> C = Cookie.SerialCookie()\n+   >>> C[\"number\"] = 7\n+   >>> C[\"string\"] = \"seven\"\n+   >>> C[\"number\"].value\n+   7\n+   >>> C[\"string\"].value\n+   'seven'\n+   >>> C.output()\n+   'Set-Cookie: number=\"I7\\\\012.\"\\r\\nSet-Cookie: string=\"S\\'seven\\'\\\\012p1\\\\012.\"'\n+\n+Be warned, however, if SerialCookie cannot de-serialize a value (because\n+it isn't a valid pickle'd object), IT WILL RAISE AN EXCEPTION.\n+\n+\n+SmartCookie\n+\n+The SmartCookie combines aspects of each of the other two flavors.\n+When setting a value in a dictionary-fashion, the SmartCookie will\n+serialize (ala cPickle) the value *if and only if* it isn't a\n+Python string.  String objects are *not* serialized.  Similarly,\n+when the load() method parses out values, it attempts to de-serialize\n+the value.  If it fails, then it fallsback to treating the value\n+as a string.\n+\n+   >>> C = Cookie.SmartCookie()\n+   >>> C[\"number\"] = 7\n+   >>> C[\"string\"] = \"seven\"\n+   >>> C[\"number\"].value\n+   7\n+   >>> C[\"string\"].value\n+   'seven'\n+   >>> C.output()\n+   'Set-Cookie: number=\"I7\\\\012.\"\\r\\nSet-Cookie: string=seven'\n+\n+\n+Backwards Compatibility\n+-----------------------\n+\n+In order to keep compatibilty with earlier versions of Cookie.py,\n+it is still possible to use Cookie.Cookie() to create a Cookie.  In\n+fact, this simply returns a SmartCookie.\n+\n+   >>> C = Cookie.Cookie()\n+   >>> print C.__class__.__name__\n+   SmartCookie\n+\n+\n+Finis.\n+\"\"\"  #\"\n+#     ^\n+#     |----helps out font-lock\n+\n+#\n+# Import our required modules\n+#\n+import string\n+\n+try:\n+    from cPickle import dumps, loads\n+except ImportError:\n+    from pickle import dumps, loads\n+\n+import re, warnings\n+\n+__all__ = [\"CookieError\",\"BaseCookie\",\"SimpleCookie\",\"SerialCookie\",\n+           \"SmartCookie\",\"Cookie\"]\n+\n+_nulljoin = ''.join\n+_semispacejoin = '; '.join\n+_spacejoin = ' '.join\n+\n+#\n+# Define an exception visible to External modules\n+#\n+class CookieError(Exception):\n+    pass\n+\n+\n+# These quoting routines conform to the RFC2109 specification, which in\n+# turn references the character definitions from RFC2068.  They provide\n+# a two-way quoting algorithm.  Any non-text character is translated\n+# into a 4 character sequence: a forward-slash followed by the\n+# three-digit octal equivalent of the character.  Any '\\' or '\"' is\n+# quoted with a preceeding '\\' slash.\n+#\n+# These are taken from RFC2068 and RFC2109.\n+#       _LegalChars       is the list of chars which don't require \"'s\n+#       _Translator       hash-table for fast quoting\n+#\n+_LegalChars       = string.ascii_letters + string.digits + \"!#$%&'*+-.^_`|~[]_\"\n+_Translator       = {\n+    '\\000' : '\\\\000',  '\\001' : '\\\\001',  '\\002' : '\\\\002',\n+    '\\003' : '\\\\003',  '\\004' : '\\\\004',  '\\005' : '\\\\005',\n+    '\\006' : '\\\\006',  '\\007' : '\\\\007',  '\\010' : '\\\\010',\n+    '\\011' : '\\\\011',  '\\012' : '\\\\012',  '\\013' : '\\\\013',\n+    '\\014' : '\\\\014',  '\\015' : '\\\\015',  '\\016' : '\\\\016',\n+    '\\017' : '\\\\017',  '\\020' : '\\\\020',  '\\021' : '\\\\021',\n+    '\\022' : '\\\\022',  '\\023' : '\\\\023',  '\\024' : '\\\\024',\n+    '\\025' : '\\\\025',  '\\026' : '\\\\026',  '\\027' : '\\\\027',\n+    '\\030' : '\\\\030',  '\\031' : '\\\\031',  '\\032' : '\\\\032',\n+    '\\033' : '\\\\033',  '\\034' : '\\\\034',  '\\035' : '\\\\035',\n+    '\\036' : '\\\\036',  '\\037' : '\\\\037',\n+\n+    # Because of the way browsers really handle cookies (as opposed\n+    # to what the RFC says) we also encode , and ;\n+\n+    ',' : '\\\\054', ';' : '\\\\073',\n+\n+    '\"' : '\\\\\"',       '\\\\' : '\\\\\\\\',\n+\n+    '\\177' : '\\\\177',  '\\200' : '\\\\200',  '\\201' : '\\\\201',\n+    '\\202' : '\\\\202',  '\\203' : '\\\\203',  '\\204' : '\\\\204',\n+    '\\205' : '\\\\205',  '\\206' : '\\\\206',  '\\207' : '\\\\207',\n+    '\\210' : '\\\\210',  '\\211' : '\\\\211',  '\\212' : '\\\\212',\n+    '\\213' : '\\\\213',  '\\214' : '\\\\214',  '\\215' : '\\\\215',\n+    '\\216' : '\\\\216',  '\\217' : '\\\\217',  '\\220' : '\\\\220',\n+    '\\221' : '\\\\221',  '\\222' : '\\\\222',  '\\223' : '\\\\223',\n+    '\\224' : '\\\\224',  '\\225' : '\\\\225',  '\\226' : '\\\\226',\n+    '\\227' : '\\\\227',  '\\230' : '\\\\230',  '\\231' : '\\\\231',\n+    '\\232' : '\\\\232',  '\\233' : '\\\\233',  '\\234' : '\\\\234',\n+    '\\235' : '\\\\235',  '\\236' : '\\\\236',  '\\237' : '\\\\237',\n+    '\\240' : '\\\\240',  '\\241' : '\\\\241',  '\\242' : '\\\\242',\n+    '\\243' : '\\\\243',  '\\244' : '\\\\244',  '\\245' : '\\\\245',\n+    '\\246' : '\\\\246',  '\\247' : '\\\\247',  '\\250' : '\\\\250',\n+    '\\251' : '\\\\251',  '\\252' : '\\\\252',  '\\253' : '\\\\253',\n+    '\\254' : '\\\\254',  '\\255' : '\\\\255',  '\\256' : '\\\\256',\n+    '\\257' : '\\\\257',  '\\260' : '\\\\260',  '\\261' : '\\\\261',\n+    '\\262' : '\\\\262',  '\\263' : '\\\\263',  '\\264' : '\\\\264',\n+    '\\265' : '\\\\265',  '\\266' : '\\\\266',  '\\267' : '\\\\267',\n+    '\\270' : '\\\\270',  '\\271' : '\\\\271',  '\\272' : '\\\\272',\n+    '\\273' : '\\\\273',  '\\274' : '\\\\274',  '\\275' : '\\\\275',\n+    '\\276' : '\\\\276',  '\\277' : '\\\\277',  '\\300' : '\\\\300',\n+    '\\301' : '\\\\301',  '\\302' : '\\\\302',  '\\303' : '\\\\303',\n+    '\\304' : '\\\\304',  '\\305' : '\\\\305',  '\\306' : '\\\\306',\n+    '\\307' : '\\\\307',  '\\310' : '\\\\310',  '\\311' : '\\\\311',\n+    '\\312' : '\\\\312',  '\\313' : '\\\\313',  '\\314' : '\\\\314',\n+    '\\315' : '\\\\315',  '\\316' : '\\\\316',  '\\317' : '\\\\317',\n+    '\\320' : '\\\\320',  '\\321' : '\\\\321',  '\\322' : '\\\\322',\n+    '\\323' : '\\\\323',  '\\324' : '\\\\324',  '\\325' : '\\\\325',\n+    '\\326' : '\\\\326',  '\\327' : '\\\\327',  '\\330' : '\\\\330',\n+    '\\331' : '\\\\331',  '\\332' : '\\\\332',  '\\333' : '\\\\333',\n+    '\\334' : '\\\\334',  '\\335' : '\\\\335',  '\\336' : '\\\\336',\n+    '\\337' : '\\\\337',  '\\340' : '\\\\340',  '\\341' : '\\\\341',\n+    '\\342' : '\\\\342',  '\\343' : '\\\\343',  '\\344' : '\\\\344',\n+    '\\345' : '\\\\345',  '\\346' : '\\\\346',  '\\347' : '\\\\347',\n+    '\\350' : '\\\\350',  '\\351' : '\\\\351',  '\\352' : '\\\\352',\n+    '\\353' : '\\\\353',  '\\354' : '\\\\354',  '\\355' : '\\\\355',\n+    '\\356' : '\\\\356',  '\\357' : '\\\\357',  '\\360' : '\\\\360',\n+    '\\361' : '\\\\361',  '\\362' : '\\\\362',  '\\363' : '\\\\363',\n+    '\\364' : '\\\\364',  '\\365' : '\\\\365',  '\\366' : '\\\\366',\n+    '\\367' : '\\\\367',  '\\370' : '\\\\370',  '\\371' : '\\\\371',\n+    '\\372' : '\\\\372',  '\\373' : '\\\\373',  '\\374' : '\\\\374',\n+    '\\375' : '\\\\375',  '\\376' : '\\\\376',  '\\377' : '\\\\377'\n+    }\n+\n+_idmap = ''.join(chr(x) for x in xrange(256))\n+\n+def _quote(str, LegalChars=_LegalChars,\n+           idmap=_idmap, translate=string.translate):\n+    #\n+    # If the string does not need to be double-quoted,\n+    # then just return the string.  Otherwise, surround\n+    # the string in doublequotes and precede quote (with a \\)\n+    # special characters.\n+    #\n+    if \"\" == translate(str, idmap, LegalChars):\n+        return str\n+    else:\n+        return '\"' + _nulljoin( map(_Translator.get, str, str) ) + '\"'\n+# end _quote\n+\n+\n+_OctalPatt = re.compile(r\"\\\\[0-3][0-7][0-7]\")\n+_QuotePatt = re.compile(r\"[\\\\].\")\n+\n+def _unquote(str):\n+    # If there aren't any doublequotes,\n+    # then there can't be any special characters.  See RFC 2109.\n+    if  len(str) < 2:\n+        return str\n+    if str[0] != '\"' or str[-1] != '\"':\n+        return str\n+\n+    # We have to assume that we must decode this string.\n+    # Down to work.\n+\n+    # Remove the \"s\n+    str = str[1:-1]\n+\n+    # Check for special sequences.  Examples:\n+    #    \\012 --> \\n\n+    #    \\\"   --> \"\n+    #\n+    i = 0\n+    n = len(str)\n+    res = []\n+    while 0 <= i < n:\n+        Omatch = _OctalPatt.search(str, i)\n+        Qmatch = _QuotePatt.search(str, i)\n+        if not Omatch and not Qmatch:              # Neither matched\n+            res.append(str[i:])\n+            break\n+        # else:\n+        j = k = -1\n+        if Omatch: j = Omatch.start(0)\n+        if Qmatch: k = Qmatch.start(0)\n+        if Qmatch and ( not Omatch or k < j ):     # QuotePatt matched\n+            res.append(str[i:k])\n+            res.append(str[k+1])\n+            i = k+2\n+        else:                                      # OctalPatt matched\n+            res.append(str[i:j])\n+            res.append( chr( int(str[j+1:j+4], 8) ) )\n+            i = j+4\n+    return _nulljoin(res)\n+# end _unquote\n+\n+# The _getdate() routine is used to set the expiration time in\n+# the cookie's HTTP header.      By default, _getdate() returns the\n+# current time in the appropriate \"expires\" format for a\n+# Set-Cookie header.     The one optional argument is an offset from\n+# now, in seconds.      For example, an offset of -3600 means \"one hour ago\".\n+# The offset may be a floating point number.\n+#\n+\n+_weekdayname = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n+\n+_monthname = [None,\n+              'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n+              'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n+\n+def _getdate(future=0, weekdayname=_weekdayname, monthname=_monthname):\n+    from time import gmtime, time\n+    now = time()\n+    year, month, day, hh, mm, ss, wd, y, z = gmtime(now + future)\n+    return \"%s, %02d-%3s-%4d %02d:%02d:%02d GMT\" % \\\n+           (weekdayname[wd], day, monthname[month], year, hh, mm, ss)\n+\n+\n+#\n+# A class to hold ONE key,value pair.\n+# In a cookie, each such pair may have several attributes.\n+#       so this class is used to keep the attributes associated\n+#       with the appropriate key,value pair.\n+# This class also includes a coded_value attribute, which\n+#       is used to hold the network representation of the\n+#       value.  This is most useful when Python objects are\n+#       pickled for network transit.\n+#\n+\n+class Morsel(dict):\n+    # RFC 2109 lists these attributes as reserved:\n+    #   path       comment         domain\n+    #   max-age    secure      version\n+    #\n+    # For historical reasons, these attributes are also reserved:\n+    #   expires\n+    #\n+    # This is an extension from Microsoft:\n+    #   httponly\n+    #\n+    # This dictionary provides a mapping from the lowercase\n+    # variant on the left to the appropriate traditional\n+    # formatting on the right.\n+    _reserved = { \"expires\" : \"expires\",\n+                   \"path\"        : \"Path\",\n+                   \"comment\" : \"Comment\",\n+                   \"domain\"      : \"Domain\",\n+                   \"max-age\" : \"Max-Age\",\n+                   \"secure\"      : \"secure\",\n+                   \"httponly\"  : \"httponly\",\n+                   \"version\" : \"Version\",\n+                   }\n+\n+    def __init__(self):\n+        # Set defaults\n+        self.key = self.value = self.coded_value = None\n+\n+        # Set default attributes\n+        for K in self._reserved:\n+            dict.__setitem__(self, K, \"\")\n+    # end __init__\n+\n+    def __setitem__(self, K, V):\n+        K = K.lower()\n+        if not K in self._reserved:\n+            raise CookieError(\"Invalid Attribute %s\" % K)\n+        dict.__setitem__(self, K, V)\n+    # end __setitem__\n+\n+    def isReservedKey(self, K):\n+        return K.lower() in self._reserved\n+    # end isReservedKey\n+\n+    def set(self, key, val, coded_val,\n+            LegalChars=_LegalChars,\n+            idmap=_idmap, translate=string.translate):\n+        # First we verify that the key isn't a reserved word\n+        # Second we make sure it only contains legal characters\n+        if key.lower() in self._reserved:\n+            raise CookieError(\"Attempt to set a reserved key: %s\" % key)\n+        if \"\" != translate(key, idmap, LegalChars):\n+            raise CookieError(\"Illegal key value: %s\" % key)\n+\n+        # It's a good key, so save it.\n+        self.key                 = key\n+        self.value               = val\n+        self.coded_value         = coded_val\n+    # end set\n+\n+    def output(self, attrs=None, header = \"Set-Cookie:\"):\n+        return \"%s %s\" % ( header, self.OutputString(attrs) )\n+\n+    __str__ = output\n+\n+    def __repr__(self):\n+        return '<%s: %s=%s>' % (self.__class__.__name__,\n+                                self.key, repr(self.value) )\n+\n+    def js_output(self, attrs=None):\n+        # Print javascript\n+        return \"\"\"\n+        <script type=\"text/javascript\">\n+        <!-- begin hiding\n+        document.cookie = \\\"%s\\\";\n+        // end hiding -->\n+        </script>\n+        \"\"\" % ( self.OutputString(attrs).replace('\"',r'\\\"'), )\n+    # end js_output()\n+\n+    def OutputString(self, attrs=None):\n+        # Build up our result\n+        #\n+        result = []\n+        RA = result.append\n+\n+        # First, the key=value pair\n+        RA(\"%s=%s\" % (self.key, self.coded_value))\n+\n+        # Now add any defined attributes\n+        if attrs is None:\n+            attrs = self._reserved\n+        items = self.items()\n+        items.sort()\n+        for K,V in items:\n+            if V == \"\": continue\n+            if K not in attrs: continue\n+            if K == \"expires\" and type(V) == type(1):\n+                RA(\"%s=%s\" % (self._reserved[K], _getdate(V)))\n+            elif K == \"max-age\" and type(V) == type(1):\n+                RA(\"%s=%d\" % (self._reserved[K], V))\n+            elif K == \"secure\":\n+                RA(str(self._reserved[K]))\n+            elif K == \"httponly\":\n+                RA(str(self._reserved[K]))\n+            else:\n+                RA(\"%s=%s\" % (self._reserved[K], V))\n+\n+        # Return the result\n+        return _semispacejoin(result)\n+    # end OutputString\n+# end Morsel class\n+\n+\n+\n+#\n+# Pattern for finding cookie\n+#\n+# This used to be strict parsing based on the RFC2109 and RFC2068\n+# specifications.  I have since discovered that MSIE 3.0x doesn't\n+# follow the character rules outlined in those specs.  As a\n+# result, the parsing rules here are less strict.\n+#\n+\n+_LegalCharsPatt  = r\"[\\w\\d!#%&'~_`><@,:/\\$\\*\\+\\-\\.\\^\\|\\)\\(\\?\\}\\{\\=\\[\\]\\_]\"\n+\n+_CookiePattern = re.compile(\n+    r\"(?x)\"                       # This is a Verbose pattern\n+    r\"(?P<key>\"                   # Start of group 'key'\n+    \"\"+ _LegalCharsPatt +\"+?\"     # Any word of at least one letter, nongreedy\n+    r\")\"                          # End of group 'key'\n+    r\"\\s*=\\s*\"                    # Equal Sign\n+    r\"(?P<val>\"                   # Start of group 'val'\n+    r'\"(?:[^\\\\\"]|\\\\.)*\"'            # Any doublequoted string\n+    r\"|\"                            # or\n+    r\"\\w{3},\\s[\\w\\d-]{9,11}\\s[\\d:]{8}\\sGMT\" # Special case for \"expires\" attr\n+    r\"|\"                            # or\n+    \"\"+ _LegalCharsPatt +\"*\"        # Any word or empty string\n+    r\")\"                          # End of group 'val'\n+    r\"\\s*;?\"                      # Probably ending in a semi-colon\n+    )\n+\n+\n+# At long last, here is the cookie class.\n+#   Using this class is almost just like using a dictionary.\n+# See this module's docstring for example usage.\n+#\n+class BaseCookie(dict):\n+    # A container class for a set of Morsels\n+    #\n+\n+    def value_decode(self, val):\n+        \"\"\"real_value, coded_value = value_decode(STRING)\n+        Called prior to setting a cookie's value from the network\n+        representation.  The VALUE is the value read from HTTP\n+        header.\n+        Override this function to modify the behavior of cookies.\n+        \"\"\"\n+        return val, val\n+    # end value_encode\n+\n+    def value_encode(self, val):\n+        \"\"\"real_value, coded_value = value_encode(VALUE)\n+        Called prior to setting a cookie's value from the dictionary\n+        representation.  The VALUE is the value being assigned.\n+        Override this function to modify the behavior of cookies.\n+        \"\"\"\n+        strval = str(val)\n+        return strval, strval\n+    # end value_encode\n+\n+    def __init__(self, input=None):\n+        if input: self.load(input)\n+    # end __init__\n+\n+    def __set(self, key, real_value, coded_value):\n+        \"\"\"Private method for setting a cookie's value\"\"\"\n+        M = self.get(key, Morsel())\n+        M.set(key, real_value, coded_value)\n+        dict.__setitem__(self, key, M)\n+    # end __set\n+\n+    def __setitem__(self, key, value):\n+        \"\"\"Dictionary style assignment.\"\"\"\n+        rval, cval = self.value_encode(value)\n+        self.__set(key, rval, cval)\n+    # end __setitem__\n+\n+    def output(self, attrs=None, header=\"Set-Cookie:\", sep=\"\\015\\012\"):\n+        \"\"\"Return a string suitable for HTTP.\"\"\"\n+        result = []\n+        items = self.items()\n+        items.sort()\n+        for K,V in items:\n+            result.append( V.output(attrs, header) )\n+        return sep.join(result)\n+    # end output\n+\n+    __str__ = output\n+\n+    def __repr__(self):\n+        L = []\n+        items = self.items()\n+        items.sort()\n+        for K,V in items:\n+            L.append( '%s=%s' % (K,repr(V.value) ) )\n+        return '<%s: %s>' % (self.__class__.__name__, _spacejoin(L))\n+\n+    def js_output(self, attrs=None):\n+        \"\"\"Return a string suitable for JavaScript.\"\"\"\n+        result = []\n+        items = self.items()\n+        items.sort()\n+        for K,V in items:\n+            result.append( V.js_output(attrs) )\n+        return _nulljoin(result)\n+    # end js_output\n+\n+    def load(self, rawdata):\n+        \"\"\"Load cookies from a string (presumably HTTP_COOKIE) or\n+        from a dictionary.  Loading cookies from a dictionary 'd'\n+        is equivalent to calling:\n+            map(Cookie.__setitem__, d.keys(), d.values())\n+        \"\"\"\n+        if type(rawdata) == type(\"\"):\n+            self.__ParseString(rawdata)\n+        else:\n+            # self.update() wouldn't call our custom __setitem__\n+            for k, v in rawdata.items():\n+                self[k] = v\n+        return\n+    # end load()\n+\n+    def __ParseString(self, str, patt=_CookiePattern):\n+        i = 0            # Our starting point\n+        n = len(str)     # Length of string\n+        M = None         # current morsel\n+\n+        while 0 <= i < n:\n+            # Start looking for a cookie\n+            match = patt.search(str, i)\n+            if not match: break          # No more cookies\n+\n+            K,V = match.group(\"key\"), match.group(\"val\")\n+            i = match.end(0)\n+\n+            # Parse the key, value in case it's metainfo\n+            if K[0] == \"$\":\n+                # We ignore attributes which pertain to the cookie\n+                # mechanism as a whole.  See RFC 2109.\n+                # (Does anyone care?)\n+                if M:\n+                    M[ K[1:] ] = V\n+            elif K.lower() in Morsel._reserved:\n+                if M:\n+                    M[ K ] = _unquote(V)\n+            else:\n+                rval, cval = self.value_decode(V)\n+                self.__set(K, rval, cval)\n+                M = self[K]\n+    # end __ParseString\n+# end BaseCookie class\n+\n+class SimpleCookie(BaseCookie):\n+    \"\"\"SimpleCookie\n+    SimpleCookie supports strings as cookie values.  When setting\n+    the value using the dictionary assignment notation, SimpleCookie\n+    calls the builtin str() to convert the value to a string.  Values\n+    received from HTTP are kept as strings.\n+    \"\"\"\n+    def value_decode(self, val):\n+        return _unquote( val ), val\n+    def value_encode(self, val):\n+        strval = str(val)\n+        return strval, _quote( strval )\n+# end SimpleCookie\n+\n+class SerialCookie(BaseCookie):\n+    \"\"\"SerialCookie\n+    SerialCookie supports arbitrary objects as cookie values. All\n+    values are serialized (using cPickle) before being sent to the\n+    client.  All incoming values are assumed to be valid Pickle\n+    representations.  IF AN INCOMING VALUE IS NOT IN A VALID PICKLE\n+    FORMAT, THEN AN EXCEPTION WILL BE RAISED.\n+\n+    Note: Large cookie values add overhead because they must be\n+    retransmitted on every HTTP transaction.\n+\n+    Note: HTTP has a 2k limit on the size of a cookie.  This class\n+    does not check for this limit, so be careful!!!\n+    \"\"\"\n+    def __init__(self, input=None):\n+        warnings.warn(\"SerialCookie class is insecure; do not use it\",\n+                      DeprecationWarning)\n+        BaseCookie.__init__(self, input)\n+    # end __init__\n+    def value_decode(self, val):\n+        # This could raise an exception!\n+        return loads( _unquote(val) ), val\n+    def value_encode(self, val):\n+        return val, _quote( dumps(val) )\n+# end SerialCookie\n+\n+class SmartCookie(BaseCookie):\n+    \"\"\"SmartCookie\n+    SmartCookie supports arbitrary objects as cookie values.  If the\n+    object is a string, then it is quoted.  If the object is not a\n+    string, however, then SmartCookie will use cPickle to serialize\n+    the object into a string representation.\n+\n+    Note: Large cookie values add overhead because they must be\n+    retransmitted on every HTTP transaction.\n+\n+    Note: HTTP has a 2k limit on the size of a cookie.  This class\n+    does not check for this limit, so be careful!!!\n+    \"\"\"\n+    def __init__(self, input=None):\n+        warnings.warn(\"Cookie/SmartCookie class is insecure; do not use it\",\n+                      DeprecationWarning)\n+        BaseCookie.__init__(self, input)\n+    # end __init__\n+    def value_decode(self, val):\n+        strval = _unquote(val)\n+        try:\n+            return loads(strval), val\n+        except:\n+            return strval, val\n+    def value_encode(self, val):\n+        if type(val) == type(\"\"):\n+            return val, _quote(val)\n+        else:\n+            return val, _quote( dumps(val) )\n+# end SmartCookie\n+\n+\n+###########################################################\n+# Backwards Compatibility:  Don't break any existing code!\n+\n+# We provide Cookie() as an alias for SmartCookie()\n+Cookie = SmartCookie\n+\n+#\n+###########################################################\n+\n+def _test():\n+    import doctest, Cookie\n+    return doctest.testmod(Cookie)\n+\n+if __name__ == \"__main__\":\n+    _test()\n+\n+\n+#Local Variables:\n+#tab-width: 4\n+#end:\n\n@@ -0,0 +1,399 @@\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+oreos.sructures\n+~~~~~~~~~~~~~~~\n+\n+The plastic blue packaging.\n+\n+This is mostly directly stolen from mitsuhiko/werkzeug.\n+\"\"\"\n+\n+__all__ = ('MultiDict',)\n+\n+class _Missing(object):\n+\n+    def __repr__(self):\n+        return 'no value'\n+\n+    def __reduce__(self):\n+        return '_missing'\n+\n+_missing = _Missing()\n+\n+\n+\n+def iter_multi_items(mapping):\n+    \"\"\"Iterates over the items of a mapping yielding keys and values\n+    without dropping any from more complex structures.\n+    \"\"\"\n+    if isinstance(mapping, MultiDict):\n+        for item in mapping.iteritems(multi=True):\n+            yield item\n+    elif isinstance(mapping, dict):\n+        for key, value in mapping.iteritems():\n+            if isinstance(value, (tuple, list)):\n+                for value in value:\n+                    yield key, value\n+            else:\n+                yield key, value\n+    else:\n+        for item in mapping:\n+            yield item\n+\n+\n+\n+class TypeConversionDict(dict):\n+    \"\"\"Works like a regular dict but the :meth:`get` method can perform\n+    type conversions.  :class:`MultiDict` and :class:`CombinedMultiDict`\n+    are subclasses of this class and provide the same feature.\n+\n+    .. versionadded:: 0.5\n+    \"\"\"\n+\n+    def get(self, key, default=None, type=None):\n+        \"\"\"Return the default value if the requested data doesn't exist.\n+        If `type` is provided and is a callable it should convert the value,\n+        return it or raise a :exc:`ValueError` if that is not possible.  In\n+        this case the function will return the default as if the value was not\n+        found:\n+\n+        >>> d = TypeConversionDict(foo='42', bar='blub')\n+        >>> d.get('foo', type=int)\n+        42\n+        >>> d.get('bar', -1, type=int)\n+        -1\n+\n+        :param key: The key to be looked up.\n+        :param default: The default value to be returned if the key can't\n+                        be looked up.  If not further specified `None` is\n+                        returned.\n+        :param type: A callable that is used to cast the value in the\n+                     :class:`MultiDict`.  If a :exc:`ValueError` is raised\n+                     by this callable the default value is returned.\n+        \"\"\"\n+        try:\n+            rv = self[key]\n+            if type is not None:\n+                rv = type(rv)\n+        except (KeyError, ValueError):\n+            rv = default\n+        return rv\n+\n+\n+class MultiDict(TypeConversionDict):\n+    \"\"\"A :class:`MultiDict` is a dictionary subclass customized to deal with\n+    multiple values for the same key which is for example used by the parsing\n+    functions in the wrappers.  This is necessary because some HTML form\n+    elements pass multiple values for the same key.\n+\n+    :class:`MultiDict` implements all standard dictionary methods.\n+    Internally, it saves all values for a key as a list, but the standard dict\n+    access methods will only return the first value for a key. If you want to\n+    gain access to the other values, too, you have to use the `list` methods as\n+    explained below.\n+\n+    Basic Usage:\n+\n+    >>> d = MultiDict([('a', 'b'), ('a', 'c')])\n+    >>> d\n+    MultiDict([('a', 'b'), ('a', 'c')])\n+    >>> d['a']\n+    'b'\n+    >>> d.getlist('a')\n+    ['b', 'c']\n+    >>> 'a' in d\n+    True\n+\n+    It behaves like a normal dict thus all dict functions will only return the\n+    first value when multiple values for one key are found.\n+\n+    From Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a\n+    subclass of the :exc:`~exceptions.BadRequest` HTTP exception and will\n+    render a page for a ``400 BAD REQUEST`` if caught in a catch-all for HTTP\n+    exceptions.\n+\n+    A :class:`MultiDict` can be constructed from an iterable of\n+    ``(key, value)`` tuples, a dict, a :class:`MultiDict` or from Werkzeug 0.2\n+    onwards some keyword parameters.\n+\n+    :param mapping: the initial value for the :class:`MultiDict`.  Either a\n+                    regular dict, an iterable of ``(key, value)`` tuples\n+                    or `None`.\n+    \"\"\"\n+\n+    def __init__(self, mapping=None):\n+        if isinstance(mapping, MultiDict):\n+            dict.__init__(self, ((k, l[:]) for k, l in mapping.iterlists()))\n+        elif isinstance(mapping, dict):\n+            tmp = {}\n+            for key, value in mapping.iteritems():\n+                if isinstance(value, (tuple, list)):\n+                    value = list(value)\n+                else:\n+                    value = [value]\n+                tmp[key] = value\n+            dict.__init__(self, tmp)\n+        else:\n+            tmp = {}\n+            for key, value in mapping or ():\n+                tmp.setdefault(key, []).append(value)\n+            dict.__init__(self, tmp)\n+\n+    def __getstate__(self):\n+        return dict(self.lists())\n+\n+    def __setstate__(self, value):\n+        dict.clear(self)\n+        dict.update(self, value)\n+\n+    def __iter__(self):\n+        return self.iterkeys()\n+\n+    def __getitem__(self, key):\n+        \"\"\"Return the first data value for this key;\n+        raises KeyError if not found.\n+\n+        :param key: The key to be looked up.\n+        :raise KeyError: if the key does not exist.\n+        \"\"\"\n+        if key in self:\n+            return dict.__getitem__(self, key)[0]\n+        raise KeyError(key)\n+\n+    def __setitem__(self, key, value):\n+        \"\"\"Like :meth:`add` but removes an existing key first.\n+\n+        :param key: the key for the value.\n+        :param value: the value to set.\n+        \"\"\"\n+        dict.__setitem__(self, key, [value])\n+\n+    def add(self, key, value):\n+        \"\"\"Adds a new value for the key.\n+\n+        .. versionadded:: 0.6\n+\n+        :param key: the key for the value.\n+        :param value: the value to add.\n+        \"\"\"\n+        dict.setdefault(self, key, []).append(value)\n+\n+    def getlist(self, key, type=None):\n+        \"\"\"Return the list of items for a given key. If that key is not in the\n+        `MultiDict`, the return value will be an empty list.  Just as `get`\n+        `getlist` accepts a `type` parameter.  All items will be converted\n+        with the callable defined there.\n+\n+        :param key: The key to be looked up.\n+        :param type: A callable that is used to cast the value in the\n+                     :class:`MultiDict`.  If a :exc:`ValueError` is raised\n+                     by this callable the value will be removed from the list.\n+        :return: a :class:`list` of all the values for the key.\n+        \"\"\"\n+        try:\n+            rv = dict.__getitem__(self, key)\n+        except KeyError:\n+            return []\n+        if type is None:\n+            return list(rv)\n+        result = []\n+        for item in rv:\n+            try:\n+                result.append(type(item))\n+            except ValueError:\n+                pass\n+        return result\n+\n+    def setlist(self, key, new_list):\n+        \"\"\"Remove the old values for a key and add new ones.  Note that the list\n+        you pass the values in will be shallow-copied before it is inserted in\n+        the dictionary.\n+\n+        >>> d = MultiDict()\n+        >>> d.setlist('foo', ['1', '2'])\n+        >>> d['foo']\n+        '1'\n+        >>> d.getlist('foo')\n+        ['1', '2']\n+\n+        :param key: The key for which the values are set.\n+        :param new_list: An iterable with the new values for the key.  Old values\n+                         are removed first.\n+        \"\"\"\n+        dict.__setitem__(self, key, list(new_list))\n+\n+    def setdefault(self, key, default=None):\n+        \"\"\"Returns the value for the key if it is in the dict, otherwise it\n+        returns `default` and sets that value for `key`.\n+\n+        :param key: The key to be looked up.\n+        :param default: The default value to be returned if the key is not\n+                        in the dict.  If not further specified it's `None`.\n+        \"\"\"\n+        if key not in self:\n+            self[key] = default\n+        else:\n+            default = self[key]\n+        return default\n+\n+    def setlistdefault(self, key, default_list=None):\n+        \"\"\"Like `setdefault` but sets multiple values.  The list returned\n+        is not a copy, but the list that is actually used internally.  This\n+        means that you can put new values into the dict by appending items\n+        to the list:\n+\n+        >>> d = MultiDict({\"foo\": 1})\n+        >>> d.setlistdefault(\"foo\").extend([2, 3])\n+        >>> d.getlist(\"foo\")\n+        [1, 2, 3]\n+\n+        :param key: The key to be looked up.\n+        :param default: An iterable of default values.  It is either copied\n+                        (in case it was a list) or converted into a list\n+                        before returned.\n+        :return: a :class:`list`\n+        \"\"\"\n+        if key not in self:\n+            default_list = list(default_list or ())\n+            dict.__setitem__(self, key, default_list)\n+        else:\n+            default_list = dict.__getitem__(self, key)\n+        return default_list\n+\n+    def items(self, multi=False):\n+        \"\"\"Return a list of ``(key, value)`` pairs.\n+\n+        :param multi: If set to `True` the list returned will have a\n+                      pair for each value of each key.  Otherwise it\n+                      will only contain pairs for the first value of\n+                      each key.\n+\n+        :return: a :class:`list`\n+        \"\"\"\n+        return list(self.iteritems(multi))\n+\n+    def lists(self):\n+        \"\"\"Return a list of ``(key, values)`` pairs, where values is the list of\n+        all values associated with the key.\n+\n+        :return: a :class:`list`\n+        \"\"\"\n+        return list(self.iterlists())\n+\n+    def values(self):\n+        \"\"\"Returns a list of the first value on every key's value list.\n+\n+        :return: a :class:`list`.\n+        \"\"\"\n+        return [self[key] for key in self.iterkeys()]\n+\n+    def listvalues(self):\n+        \"\"\"Return a list of all values associated with a key.  Zipping\n+        :meth:`keys` and this is the same as calling :meth:`lists`:\n+\n+        >>> d = MultiDict({\"foo\": [1, 2, 3]})\n+        >>> zip(d.keys(), d.listvalues()) == d.lists()\n+        True\n+\n+        :return: a :class:`list`\n+        \"\"\"\n+        return list(self.iterlistvalues())\n+\n+    def iteritems(self, multi=False):\n+        \"\"\"Like :meth:`items` but returns an iterator.\"\"\"\n+        for key, values in dict.iteritems(self):\n+            if multi:\n+                for value in values:\n+                    yield key, value\n+            else:\n+                yield key, values[0]\n+\n+    def iterlists(self):\n+        \"\"\"Like :meth:`items` but returns an iterator.\"\"\"\n+        for key, values in dict.iteritems(self):\n+            yield key, list(values)\n+\n+    def itervalues(self):\n+        \"\"\"Like :meth:`values` but returns an iterator.\"\"\"\n+        for values in dict.itervalues(self):\n+            yield values[0]\n+\n+    def iterlistvalues(self):\n+        \"\"\"Like :meth:`listvalues` but returns an iterator.\"\"\"\n+        return dict.itervalues(self)\n+\n+    def copy(self):\n+        \"\"\"Return a shallow copy of this object.\"\"\"\n+        return self.__class__(self)\n+\n+    def to_dict(self, flat=True):\n+        \"\"\"Return the contents as regular dict.  If `flat` is `True` the\n+        returned dict will only have the first item present, if `flat` is\n+        `False` all values will be returned as lists.\n+\n+        :param flat: If set to `False` the dict returned will have lists\n+                     with all the values in it.  Otherwise it will only\n+                     contain the first value for each key.\n+        :return: a :class:`dict`\n+        \"\"\"\n+        if flat:\n+            return dict(self.iteritems())\n+        return dict(self.lists())\n+\n+    def update(self, other_dict):\n+        \"\"\"update() extends rather than replaces existing key lists.\"\"\"\n+        for key, value in iter_multi_items(other_dict):\n+            MultiDict.add(self, key, value)\n+\n+    def pop(self, key, default=_missing):\n+        \"\"\"Pop the first item for a list on the dict.  Afterwards the\n+        key is removed from the dict, so additional values are discarded:\n+\n+        >>> d = MultiDict({\"foo\": [1, 2, 3]})\n+        >>> d.pop(\"foo\")\n+        1\n+        >>> \"foo\" in d\n+        False\n+\n+        :param key: the key to pop.\n+        :param default: if provided the value to return if the key was\n+                        not in the dictionary.\n+        \"\"\"\n+        try:\n+            return dict.pop(self, key)[0]\n+        except KeyError, e:\n+            if default is not _missing:\n+                return default\n+            raise KeyError(str(e))\n+\n+    def popitem(self):\n+        \"\"\"Pop an item from the dict.\"\"\"\n+        try:\n+            item = dict.popitem(self)\n+            return (item[0], item[1][0])\n+        except KeyError, e:\n+            raise KeyError(str(e))\n+\n+    def poplist(self, key):\n+        \"\"\"Pop the list for a key from the dict.  If the key is not in the dict\n+        an empty list is returned.\n+\n+        .. versionchanged:: 0.5\n+           If the key does no longer exist a list is returned instead of\n+           raising an error.\n+        \"\"\"\n+        return dict.pop(self, key, [])\n+\n+    def popitemlist(self):\n+        \"\"\"Pop a ``(key, list)`` tuple from the dict.\"\"\"\n+        try:\n+            return dict.popitem(self)\n+        except KeyError, e:\n+            raise KeyError(str(e))\n+\n+    def __copy__(self):\n+        return self.copy()\n+\n+    def __repr__(self):\n+        return '%s(%r)' % (self.__class__.__name__, self.items(multi=True))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
