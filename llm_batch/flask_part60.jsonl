{"custom_id": "flask#6c5ef2bc5c7c304c8d4a2ddbb8666167ae73d4c4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 5 | Files Changed: 2 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 9 | Churn Cumulative: 509 | Contributors (this commit): 13 | Commits (past 90d): 9 | Contributors (cumulative): 15 | DMM Complexity: 1.0\n\nDIFF:\n@@ -35,16 +35,14 @@ def make_test_environ_builder(app, path='/', base_url=None, json=None, *args, **\n             if url.query:\n                 path += '?' + url.query\n \n-    if json:\n+    if json is not None:\n         if 'data' in kwargs:\n             raise RuntimeError('Client cannot provide both `json` and `data`')\n         kwargs['data'] = json_dumps(json)\n \n         # Only set Content-Type when not explicitly provided\n-        if 'Content-Type' not in kwargs.get('headers', {}):\n-            new_headers = kwargs.get('headers', {}).copy()\n-            new_headers['Content-Type'] = 'application/json'\n-            kwargs['headers'] = new_headers\n+        if 'content_type' not in kwargs:\n+            kwargs['content_type'] = 'application/json'\n \n     return EnvironBuilder(path, base_url, *args, **kwargs)\n \n\n@@ -215,6 +215,7 @@ def test_json_request():\n         json_data = {'drink': {'gin': 1, 'tonic': True}, 'price': 10}\n         rv = c.post('/api', json=json_data)\n         assert rv.status_code == 200\n+        assert flask.request.is_json\n         assert flask.request.get_json() == json_data\n \n def test_subdomain():\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#b099999c6cb5c3563dc4fbe45f3101116aab0d3f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 283 | Contributors (this commit): 11 | Commits (past 90d): 6 | Contributors (cumulative): 11 | DMM Complexity: None\n\nDIFF:\n@@ -37,7 +37,7 @@ def make_test_environ_builder(app, path='/', base_url=None, json=None, *args, **\n \n     if json is not None:\n         if 'data' in kwargs:\n-            raise RuntimeError('Client cannot provide both `json` and `data`')\n+            raise ValueError('Client cannot provide both `json` and `data`')\n         kwargs['data'] = json_dumps(json)\n \n         # Only set Content-Type when not explicitly provided\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ca547f0ec375a8a3e8c623cfa6b747d68e75a239", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 88 | Lines Deleted: 12 | Files Changed: 2 | Hunks: 8 | Methods Changed: 8 | Complexity Δ (Sum/Max): 11/11 | Churn Δ: 100 | Churn Cumulative: 844 | Contributors (this commit): 22 | Commits (past 90d): 17 | Contributors (cumulative): 25 | DMM Complexity: 0.3225806451612903\n\nDIFF:\n@@ -25,6 +25,14 @@ def _get_data(req, cache):\n     return req.data\n \n \n+def _is_mimetype_json(mimetype):\n+    if mimetype == 'application/json':\n+        return True\n+    if mimetype.startswith('application/') and mimetype.endswith('+json'):\n+        return True\n+    return False\n+\n+\n class Request(RequestBase):\n     \"\"\"The request object used by default in Flask.  Remembers the\n     matched endpoint and view arguments.\n@@ -115,12 +123,7 @@ class Request(RequestBase):\n \n         .. versionadded:: 0.11\n         \"\"\"\n-        mt = self.mimetype\n-        if mt == 'application/json':\n-            return True\n-        if mt.startswith('application/') and mt.endswith('+json'):\n-            return True\n-        return False\n+        return _is_mimetype_json(self.mimetype)\n \n     def get_json(self, force=False, silent=False, cache=True):\n         \"\"\"Parses the incoming JSON request data and returns it.  By default\n@@ -202,3 +205,69 @@ class Response(ResponseBase):\n     set :attr:`~flask.Flask.response_class` to your subclass.\n     \"\"\"\n     default_mimetype = 'text/html'\n+\n+    @property\n+    def json(self):\n+        \"\"\"If the mimetype is :mimetype:`application/json` this will contain the\n+        parsed JSON data.  Otherwise this will be ``None``.\n+\n+        The :meth:`get_json` method should be used instead.\n+\n+        .. versionadded:: 1.0\n+        \"\"\"\n+        from warnings import warn\n+        warn(DeprecationWarning('json is deprecated.  '\n+                                'Use get_json() instead.'), stacklevel=2)\n+        return self.get_json()\n+\n+    @property\n+    def is_json(self):\n+        \"\"\"Indicates if this response is JSON or not.  By default a response\n+        is considered to include JSON data if the mimetype is\n+        :mimetype:`application/json` or :mimetype:`application/*+json`.\n+\n+        .. versionadded:: 1.0\n+        \"\"\"\n+        return _is_mimetype_json(self.mimetype)\n+\n+    def get_json(self, force=False, silent=False, cache=True):\n+        \"\"\"Parses the incoming JSON request data and returns it.  If\n+        parsing fails the :meth:`on_json_loading_failed` method on the\n+        request object will be invoked.  By default this function will\n+        only load the json data if the mimetype is :mimetype:`application/json`\n+        but this can be overridden by the `force` parameter.\n+\n+        :param force: if set to ``True`` the mimetype is ignored.\n+        :param silent: if set to ``True`` this method will fail silently\n+                       and return ``None``.\n+        :param cache: if set to ``True`` the parsed JSON data is remembered\n+                      on the request.\n+\n+        .. versionadded:: 1.0\n+        \"\"\"\n+        rv = getattr(self, '_cached_json', _missing)\n+        if rv is not _missing:\n+            return rv\n+\n+        if not (force or self.is_json):\n+            return None\n+\n+        # We accept a request charset against the specification as\n+        # certain clients have been using this in the past.  This\n+        # fits our general approach of being nice in what we accept\n+        # and strict in what we send out.\n+        request_charset = self.mimetype_params.get('charset')\n+        try:\n+            data = _get_data(self, cache)\n+            if request_charset is not None:\n+                rv = json.loads(data, encoding=request_charset)\n+            else:\n+                rv = json.loads(data)\n+        except ValueError as e:\n+            if silent:\n+                rv = None\n+            else:\n+                rv = self.on_json_loading_failed(e)\n+        if cache:\n+            self._cached_json = rv\n+        return rv\n\n@@ -13,6 +13,7 @@ import pytest\n import flask\n \n from flask._compat import text_type\n+from flask.json import jsonify\n \n \n def test_environ_defaults_from_config():\n@@ -203,21 +204,27 @@ def test_full_url_request():\n         assert 'gin' in flask.request.form\n         assert 'vodka' in flask.request.args\n \n-def test_json_request():\n+def test_json_request_and_response():\n     app = flask.Flask(__name__)\n     app.testing = True\n \n-    @app.route('/api', methods=['POST'])\n-    def api():\n-        return ''\n+    @app.route('/echo', methods=['POST'])\n+    def echo():\n+        return jsonify(flask.request.json)\n \n     with app.test_client() as c:\n         json_data = {'drink': {'gin': 1, 'tonic': True}, 'price': 10}\n-        rv = c.post('/api', json=json_data)\n-        assert rv.status_code == 200\n+        rv = c.post('/echo', json=json_data)\n+\n+        # Request should be in JSON\n         assert flask.request.is_json\n         assert flask.request.get_json() == json_data\n \n+        # Response should be in JSON\n+        assert rv.status_code == 200\n+        assert rv.is_json\n+        assert rv.get_json() == json_data\n+\n def test_subdomain():\n     app = flask.Flask(__name__)\n     app.config['SERVER_NAME'] = 'example.com'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#c9ef500c5c2bbc7cfcb51e8b599e00248d290fd4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 78 | Lines Deleted: 134 | Files Changed: 1 | Hunks: 7 | Methods Changed: 5 | Complexity Δ (Sum/Max): -10/0 | Churn Δ: 212 | Churn Cumulative: 809 | Contributors (this commit): 21 | Commits (past 90d): 13 | Contributors (cumulative): 21 | DMM Complexity: 0.7777777777777778\n\nDIFF:\n@@ -25,15 +25,88 @@ def _get_data(req, cache):\n     return req.data\n \n \n-def _is_mimetype_json(mimetype):\n-    if mimetype == 'application/json':\n+class JSONMixin(object):\n+    \"\"\"Mixin for both request and response classes to provide JSON parsing\n+    capabilities.\n+\n+    .. versionadded:: 0.12\n+    \"\"\"\n+\n+    @property\n+    def is_json(self):\n+        \"\"\"Indicates if this request/response is JSON or not.  By default it\n+        is considered to include JSON data if the mimetype is\n+        :mimetype:`application/json` or :mimetype:`application/*+json`.\n+        \"\"\"\n+        mt = self.mimetype\n+        if mt == 'application/json':\n             return True\n-    if mimetype.startswith('application/') and mimetype.endswith('+json'):\n+        if mt.startswith('application/') and mt.endswith('+json'):\n             return True\n         return False\n \n+    @property\n+    def json(self):\n+        \"\"\"If the mimetype is :mimetype:`application/json` this will contain the\n+        parsed JSON data.  Otherwise this will be ``None``.\n \n-class Request(RequestBase):\n+        The :meth:`get_json` method should be used instead.\n+        \"\"\"\n+        from warnings import warn\n+        warn(DeprecationWarning('json is deprecated.  '\n+                                'Use get_json() instead.'), stacklevel=2)\n+        return self.get_json()\n+\n+    def get_json(self, force=False, silent=False, cache=True):\n+        \"\"\"Parses the incoming JSON request data and returns it.  By default\n+        this function will return ``None`` if the mimetype is not\n+        :mimetype:`application/json` but this can be overridden by the\n+        ``force`` parameter. If parsing fails the\n+        :meth:`on_json_loading_failed` method on the request object will be\n+        invoked.\n+\n+        :param force: if set to ``True`` the mimetype is ignored.\n+        :param silent: if set to ``True`` this method will fail silently\n+                       and return ``None``.\n+        :param cache: if set to ``True`` the parsed JSON data is remembered\n+                      on the request.\n+        \"\"\"\n+        rv = getattr(self, '_cached_json', _missing)\n+        if rv is not _missing:\n+            return rv\n+\n+        if not (force or self.is_json):\n+            return None\n+\n+        # We accept a request charset against the specification as certain\n+        # clients have been using this in the past.  For responses, we assume\n+        # that if the response charset was set explicitly then the data had\n+        # been encoded correctly as well.\n+        charset = self.mimetype_params.get('charset')\n+        try:\n+            data = _get_data(self, cache)\n+            if charset is not None:\n+                rv = json.loads(data, encoding=charset)\n+            else:\n+                rv = json.loads(data)\n+        except ValueError as e:\n+            if silent:\n+                rv = None\n+            else:\n+                rv = self.on_json_loading_failed(e)\n+        if cache:\n+            self._cached_json = rv\n+        return rv\n+\n+    def on_json_loading_failed(self, e):\n+        \"\"\"Called if decoding of the JSON data failed.  The return value of\n+        this method is used by :meth:`get_json` when an error occurred.  The\n+        default implementation just raises a :class:`BadRequest` exception.\n+        \"\"\"\n+        raise BadRequest()\n+\n+\n+class Request(RequestBase, JSONMixin):\n     \"\"\"The request object used by default in Flask.  Remembers the\n     matched endpoint and view arguments.\n \n@@ -103,69 +176,6 @@ class Request(RequestBase):\n         if self.url_rule and '.' in self.url_rule.endpoint:\n             return self.url_rule.endpoint.rsplit('.', 1)[0]\n \n-    @property\n-    def json(self):\n-        \"\"\"If the mimetype is :mimetype:`application/json` this will contain the\n-        parsed JSON data.  Otherwise this will be ``None``.\n-\n-        The :meth:`get_json` method should be used instead.\n-        \"\"\"\n-        from warnings import warn\n-        warn(DeprecationWarning('json is deprecated.  '\n-                                'Use get_json() instead.'), stacklevel=2)\n-        return self.get_json()\n-\n-    @property\n-    def is_json(self):\n-        \"\"\"Indicates if this request is JSON or not.  By default a request\n-        is considered to include JSON data if the mimetype is\n-        :mimetype:`application/json` or :mimetype:`application/*+json`.\n-\n-        .. versionadded:: 0.11\n-        \"\"\"\n-        return _is_mimetype_json(self.mimetype)\n-\n-    def get_json(self, force=False, silent=False, cache=True):\n-        \"\"\"Parses the incoming JSON request data and returns it.  By default\n-        this function will return ``None`` if the mimetype is not\n-        :mimetype:`application/json` but this can be overridden by the\n-        ``force`` parameter. If parsing fails the\n-        :meth:`on_json_loading_failed` method on the request object will be\n-        invoked.\n-\n-        :param force: if set to ``True`` the mimetype is ignored.\n-        :param silent: if set to ``True`` this method will fail silently\n-                       and return ``None``.\n-        :param cache: if set to ``True`` the parsed JSON data is remembered\n-                      on the request.\n-        \"\"\"\n-        rv = getattr(self, '_cached_json', _missing)\n-        if rv is not _missing:\n-            return rv\n-\n-        if not (force or self.is_json):\n-            return None\n-\n-        # We accept a request charset against the specification as\n-        # certain clients have been using this in the past.  This\n-        # fits our general approach of being nice in what we accept\n-        # and strict in what we send out.\n-        request_charset = self.mimetype_params.get('charset')\n-        try:\n-            data = _get_data(self, cache)\n-            if request_charset is not None:\n-                rv = json.loads(data, encoding=request_charset)\n-            else:\n-                rv = json.loads(data)\n-        except ValueError as e:\n-            if silent:\n-                rv = None\n-            else:\n-                rv = self.on_json_loading_failed(e)\n-        if cache:\n-            self._cached_json = rv\n-        return rv\n-\n     def on_json_loading_failed(self, e):\n         \"\"\"Called if decoding of the JSON data failed.  The return value of\n         this method is used by :meth:`get_json` when an error occurred.  The\n@@ -195,7 +205,7 @@ class Request(RequestBase):\n             attach_enctype_error_multidict(self)\n \n \n-class Response(ResponseBase):\n+class Response(ResponseBase, JSONMixin):\n     \"\"\"The response object that is used by default in Flask.  Works like the\n     response object from Werkzeug but is set to have an HTML mimetype by\n     default.  Quite often you don't have to create this object yourself because\n@@ -205,69 +215,3 @@ class Response(ResponseBase):\n     set :attr:`~flask.Flask.response_class` to your subclass.\n     \"\"\"\n     default_mimetype = 'text/html'\n-\n-    @property\n-    def json(self):\n-        \"\"\"If the mimetype is :mimetype:`application/json` this will contain the\n-        parsed JSON data.  Otherwise this will be ``None``.\n-\n-        The :meth:`get_json` method should be used instead.\n-\n-        .. versionadded:: 1.0\n-        \"\"\"\n-        from warnings import warn\n-        warn(DeprecationWarning('json is deprecated.  '\n-                                'Use get_json() instead.'), stacklevel=2)\n-        return self.get_json()\n-\n-    @property\n-    def is_json(self):\n-        \"\"\"Indicates if this response is JSON or not.  By default a response\n-        is considered to include JSON data if the mimetype is\n-        :mimetype:`application/json` or :mimetype:`application/*+json`.\n-\n-        .. versionadded:: 1.0\n-        \"\"\"\n-        return _is_mimetype_json(self.mimetype)\n-\n-    def get_json(self, force=False, silent=False, cache=True):\n-        \"\"\"Parses the incoming JSON request data and returns it.  If\n-        parsing fails the :meth:`on_json_loading_failed` method on the\n-        request object will be invoked.  By default this function will\n-        only load the json data if the mimetype is :mimetype:`application/json`\n-        but this can be overridden by the `force` parameter.\n-\n-        :param force: if set to ``True`` the mimetype is ignored.\n-        :param silent: if set to ``True`` this method will fail silently\n-                       and return ``None``.\n-        :param cache: if set to ``True`` the parsed JSON data is remembered\n-                      on the request.\n-\n-        .. versionadded:: 1.0\n-        \"\"\"\n-        rv = getattr(self, '_cached_json', _missing)\n-        if rv is not _missing:\n-            return rv\n-\n-        if not (force or self.is_json):\n-            return None\n-\n-        # We accept a request charset against the specification as\n-        # certain clients have been using this in the past.  This\n-        # fits our general approach of being nice in what we accept\n-        # and strict in what we send out.\n-        request_charset = self.mimetype_params.get('charset')\n-        try:\n-            data = _get_data(self, cache)\n-            if request_charset is not None:\n-                rv = json.loads(data, encoding=request_charset)\n-            else:\n-                rv = json.loads(data)\n-        except ValueError as e:\n-            if silent:\n-                rv = None\n-            else:\n-                rv = self.on_json_loading_failed(e)\n-        if cache:\n-            self._cached_json = rv\n-        return rv\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#23de58682c730a67820e77605386a16303d57447", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 815 | Contributors (this commit): 21 | Commits (past 90d): 14 | Contributors (cumulative): 21 | DMM Complexity: None\n\nDIFF:\n@@ -18,10 +18,10 @@ from .globals import _request_ctx_stack\n _missing = object()\n \n \n-def _get_data(req, cache):\n+def _get_data(req):\n     getter = getattr(req, 'get_data', None)\n     if getter is not None:\n-        return getter(cache=cache)\n+        return getter()\n     return req.data\n \n \n@@ -84,7 +84,7 @@ class JSONMixin(object):\n         # been encoded correctly as well.\n         charset = self.mimetype_params.get('charset')\n         try:\n-            data = _get_data(self, cache)\n+            data = _get_data(self)\n             if charset is not None:\n                 rv = json.loads(data, encoding=charset)\n             else:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#f0f458e0c5c4610cc210ef80a89b2b0870baa1b6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 14 | Lines Deleted: 8 | Files Changed: 1 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 22 | Churn Cumulative: 837 | Contributors (this commit): 21 | Commits (past 90d): 15 | Contributors (cumulative): 21 | DMM Complexity: 1.0\n\nDIFF:\n@@ -18,13 +18,6 @@ from .globals import _request_ctx_stack\n _missing = object()\n \n \n-def _get_data(req):\n-    getter = getattr(req, 'get_data', None)\n-    if getter is not None:\n-        return getter()\n-    return req.data\n-\n-\n class JSONMixin(object):\n     \"\"\"Mixin for both request and response classes to provide JSON parsing\n     capabilities.\n@@ -57,6 +50,12 @@ class JSONMixin(object):\n                                 'Use get_json() instead.'), stacklevel=2)\n         return self.get_json()\n \n+    def _get_data_for_json(req, cache):\n+        getter = getattr(req, 'get_data', None)\n+        if getter is not None:\n+            return getter(cache=cache)\n+        return req.data\n+\n     def get_json(self, force=False, silent=False, cache=True):\n         \"\"\"Parses the incoming JSON request data and returns it.  By default\n         this function will return ``None`` if the mimetype is not\n@@ -84,7 +83,7 @@ class JSONMixin(object):\n         # been encoded correctly as well.\n         charset = self.mimetype_params.get('charset')\n         try:\n-            data = _get_data(self)\n+            data = self._get_data_for_json(cache)\n             if charset is not None:\n                 rv = json.loads(data, encoding=charset)\n             else:\n@@ -215,3 +214,10 @@ class Response(ResponseBase, JSONMixin):\n     set :attr:`~flask.Flask.response_class` to your subclass.\n     \"\"\"\n     default_mimetype = 'text/html'\n+\n+    def _get_data_for_json(req, cache):\n+        # Ignore the cache flag since response doesn't support it\n+        getter = getattr(req, 'get_data', None)\n+        if getter is not None:\n+            return getter()\n+        return req.data\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#f0d3b71a94994d52d64d315bc8ef7371db14d76f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 5 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 14 | Churn Cumulative: 851 | Contributors (this commit): 21 | Commits (past 90d): 15 | Contributors (cumulative): 21 | DMM Complexity: None\n\nDIFF:\n@@ -50,11 +50,11 @@ class JSONMixin(object):\n                                 'Use get_json() instead.'), stacklevel=2)\n         return self.get_json()\n \n-    def _get_data_for_json(req, cache):\n-        getter = getattr(req, 'get_data', None)\n+    def _get_data_for_json(self, cache):\n+        getter = getattr(self, 'get_data', None)\n         if getter is not None:\n             return getter(cache=cache)\n-        return req.data\n+        return self.data\n \n     def get_json(self, force=False, silent=False, cache=True):\n         \"\"\"Parses the incoming JSON request data and returns it.  By default\n@@ -215,9 +215,9 @@ class Response(ResponseBase, JSONMixin):\n     \"\"\"\n     default_mimetype = 'text/html'\n \n-    def _get_data_for_json(req, cache):\n-        # Ignore the cache flag since response doesn't support it\n-        getter = getattr(req, 'get_data', None)\n+    def _get_data_for_json(self, cache):\n+        getter = getattr(self, 'get_data', None)\n         if getter is not None:\n+            # Ignore the cache flag since response doesn't support it\n             return getter()\n-        return req.data\n+        return self.data\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#1df2788a8f29a1238cbdebd7fa59b0d6218995b5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 13 | Lines Deleted: 20 | Files Changed: 1 | Hunks: 6 | Methods Changed: 3 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 33 | Churn Cumulative: 884 | Contributors (this commit): 21 | Commits (past 90d): 16 | Contributors (cumulative): 21 | DMM Complexity: 0.0\n\nDIFF:\n@@ -13,7 +13,7 @@ from werkzeug.wrappers import Request as RequestBase, Response as ResponseBase\n from werkzeug.exceptions import BadRequest\n \n from . import json\n-from .globals import _request_ctx_stack\n+from .globals import _app_ctx_stack\n \n _missing = object()\n \n@@ -101,7 +101,17 @@ class JSONMixin(object):\n         \"\"\"Called if decoding of the JSON data failed.  The return value of\n         this method is used by :meth:`get_json` when an error occurred.  The\n         default implementation just raises a :class:`BadRequest` exception.\n+\n+        .. versionchanged:: 0.10\n+           Removed buggy previous behavior of generating a random JSON\n+           response.  If you want that behavior back you can trivially\n+           add it by subclassing.\n+\n+        .. versionadded:: 0.8\n         \"\"\"\n+        ctx = _app_ctx_stack.top\n+        if ctx is not None and ctx.app.debug:\n+            raise BadRequest('Failed to decode JSON object: {0}'.format(e))\n         raise BadRequest()\n \n \n@@ -142,7 +152,7 @@ class Request(RequestBase, JSONMixin):\n     @property\n     def max_content_length(self):\n         \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\"\n-        ctx = _request_ctx_stack.top\n+        ctx = _app_ctx_stack.top\n         if ctx is not None:\n             return ctx.app.config['MAX_CONTENT_LENGTH']\n \n@@ -175,29 +185,12 @@ class Request(RequestBase, JSONMixin):\n         if self.url_rule and '.' in self.url_rule.endpoint:\n             return self.url_rule.endpoint.rsplit('.', 1)[0]\n \n-    def on_json_loading_failed(self, e):\n-        \"\"\"Called if decoding of the JSON data failed.  The return value of\n-        this method is used by :meth:`get_json` when an error occurred.  The\n-        default implementation just raises a :class:`BadRequest` exception.\n-\n-        .. versionchanged:: 0.10\n-           Removed buggy previous behavior of generating a random JSON\n-           response.  If you want that behavior back you can trivially\n-           add it by subclassing.\n-\n-        .. versionadded:: 0.8\n-        \"\"\"\n-        ctx = _request_ctx_stack.top\n-        if ctx is not None and ctx.app.config.get('DEBUG', False):\n-            raise BadRequest('Failed to decode JSON object: {0}'.format(e))\n-        raise BadRequest()\n-\n     def _load_form_data(self):\n         RequestBase._load_form_data(self)\n \n         # In debug mode we're replacing the files multidict with an ad-hoc\n         # subclass that raises a different error for key errors.\n-        ctx = _request_ctx_stack.top\n+        ctx = _app_ctx_stack.top\n         if ctx is not None and ctx.app.debug and \\\n            self.mimetype != 'multipart/form-data' and not self.files:\n             from .debughelpers import attach_enctype_error_multidict\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#5ebdd5dd7455ca4a4c8ba1aff727f40e77a11c08", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 886 | Contributors (this commit): 21 | Commits (past 90d): 17 | Contributors (cumulative): 21 | DMM Complexity: None\n\nDIFF:\n@@ -57,7 +57,7 @@ class JSONMixin(object):\n         return self.data\n \n     def get_json(self, force=False, silent=False, cache=True):\n-        \"\"\"Parses the incoming JSON request data and returns it.  By default\n+        \"\"\"Parses the JSON request/response data and returns it.  By default\n         this function will return ``None`` if the mimetype is not\n         :mimetype:`application/json` but this can be overridden by the\n         ``force`` parameter. If parsing fails the\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#866118302ef910f2b216e23783c9013d282e7807", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 15 | Files Changed: 1 | Hunks: 9 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 31 | Churn Cumulative: 917 | Contributors (this commit): 21 | Commits (past 90d): 3 | Contributors (cumulative): 21 | DMM Complexity: 0.0\n\nDIFF:\n@@ -15,21 +15,21 @@ from werkzeug.exceptions import BadRequest\n from . import json\n from .globals import _app_ctx_stack\n \n-_missing = object()\n-\n \n class JSONMixin(object):\n-    \"\"\"Mixin for both request and response classes to provide JSON parsing\n-    capabilities.\n+    \"\"\"Common mixin for both request and response objects to provide JSON\n+    parsing capabilities.\n \n     .. versionadded:: 0.12\n     \"\"\"\n \n     @property\n     def is_json(self):\n-        \"\"\"Indicates if this request/response is JSON or not.  By default it\n-        is considered to include JSON data if the mimetype is\n+        \"\"\"Indicates if this request/response is in JSON format or not.  By\n+        default it is considered to include JSON data if the mimetype is\n         :mimetype:`application/json` or :mimetype:`application/*+json`.\n+\n+        .. versionadded:: 1.0\n         \"\"\"\n         mt = self.mimetype\n         if mt == 'application/json':\n@@ -40,14 +40,14 @@ class JSONMixin(object):\n \n     @property\n     def json(self):\n-        \"\"\"If the mimetype is :mimetype:`application/json` this will contain the\n-        parsed JSON data.  Otherwise this will be ``None``.\n+        \"\"\"If this request/response is in JSON format then this property will\n+        contain the parsed JSON data.  Otherwise it will be ``None``.\n \n         The :meth:`get_json` method should be used instead.\n         \"\"\"\n         from warnings import warn\n-        warn(DeprecationWarning('json is deprecated.  '\n-                                'Use get_json() instead.'), stacklevel=2)\n+        warn(DeprecationWarning(\n+            'json is deprecated.  Use get_json() instead.'), stacklevel=2)\n         return self.get_json()\n \n     def _get_data_for_json(self, cache):\n@@ -68,16 +68,17 @@ class JSONMixin(object):\n         :param silent: if set to ``True`` this method will fail silently\n                        and return ``None``.\n         :param cache: if set to ``True`` the parsed JSON data is remembered\n-                      on the request.\n+                      on the object.\n         \"\"\"\n-        rv = getattr(self, '_cached_json', _missing)\n-        if rv is not _missing:\n-            return rv\n+        try:\n+            return getattr(self, '_cached_json')\n+        except AttributeError:\n+            pass\n \n         if not (force or self.is_json):\n             return None\n \n-        # We accept a request charset against the specification as certain\n+        # We accept MIME charset header against the specification as certain\n         # clients have been using this in the past.  For responses, we assume\n         # that if the response charset was set explicitly then the data had\n         # been encoded correctly as well.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#62b0b6652aab03fcf7c411de4d2cbd242ed05ec9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 289 | Contributors (this commit): 12 | Commits (past 90d): 1 | Contributors (cumulative): 12 | DMM Complexity: None\n\nDIFF:\n@@ -21,7 +21,7 @@ except ImportError:\n     from urlparse import urlsplit as url_parse\n \n \n-def make_test_environ_builder(app, path='/', base_url=None, json=None, *args, **kwargs):\n+def make_test_environ_builder(app, path='/', base_url=None, *args, **kwargs):\n     \"\"\"Creates a new test builder with some application defaults thrown in.\"\"\"\n     http_host = app.config.get('SERVER_NAME')\n     app_root = app.config.get('APPLICATION_ROOT')\n@@ -35,10 +35,10 @@ def make_test_environ_builder(app, path='/', base_url=None, json=None, *args, **\n             if url.query:\n                 path += '?' + url.query\n \n-    if json is not None:\n+    if 'json' in kwargs:\n         if 'data' in kwargs:\n             raise ValueError('Client cannot provide both `json` and `data`')\n-        kwargs['data'] = json_dumps(json)\n+        kwargs['data'] = json_dumps(kwargs['json'])\n \n         # Only set Content-Type when not explicitly provided\n         if 'content_type' not in kwargs:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#5c4fa7e91cca82f769c11b098114aa6d3322599b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 7 | Churn Cumulative: 924 | Contributors (this commit): 21 | Commits (past 90d): 2 | Contributors (cumulative): 21 | DMM Complexity: 0.0\n\nDIFF:\n@@ -208,10 +208,3 @@ class Response(ResponseBase, JSONMixin):\n     set :attr:`~flask.Flask.response_class` to your subclass.\n     \"\"\"\n     default_mimetype = 'text/html'\n-\n-    def _get_data_for_json(self, cache):\n-        getter = getattr(self, 'get_data', None)\n-        if getter is not None:\n-            # Ignore the cache flag since response doesn't support it\n-            return getter()\n-        return self.data\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#136a833a8d65f2b89c277d9b909fef5f8a4628de", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 291 | Contributors (this commit): 12 | Commits (past 90d): 2 | Contributors (cumulative): 12 | DMM Complexity: None\n\nDIFF:\n@@ -38,7 +38,7 @@ def make_test_environ_builder(app, path='/', base_url=None, *args, **kwargs):\n     if 'json' in kwargs:\n         if 'data' in kwargs:\n             raise ValueError('Client cannot provide both `json` and `data`')\n-        kwargs['data'] = json_dumps(kwargs['json'])\n+        kwargs['data'] = json_dumps(kwargs.pop('json'))\n \n         # Only set Content-Type when not explicitly provided\n         if 'content_type' not in kwargs:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#9121e109bdcd8b2a50bf53cac73b470232d126df", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 17 | Churn Cumulative: 303 | Contributors (this commit): 10 | Commits (past 90d): 11 | Contributors (cumulative): 10 | DMM Complexity: 1.0\n\nDIFF:\n@@ -22,7 +22,7 @@ from flask import Flask, current_app\n \n from flask.cli import AppGroup, FlaskGroup, NoAppException, ScriptInfo, \\\n     find_best_app, locate_app, with_appcontext, prepare_exec_for_file, \\\n-    find_default_import_path\n+    find_default_import_path, get_version\n \n \n def test_cli_name(test_apps):\n@@ -98,6 +98,21 @@ def test_find_default_import_path(test_apps, monkeypatch, tmpdir):\n     assert find_default_import_path() == expect_rv\n \n \n+def test_get_version(test_apps, capsys):\n+    \"\"\"Test of get_version.\"\"\"\n+    from flask import __version__ as flask_ver\n+    from sys import version as py_ver\n+    class MockCtx(object):\n+        resilient_parsing = False\n+        color = None\n+        def exit(self): return\n+    ctx = MockCtx()\n+    get_version(ctx, None, \"test\")\n+    out, err = capsys.readouterr()\n+    assert flask_ver in out\n+    assert py_ver in out\n+\n+\n def test_scriptinfo(test_apps):\n     \"\"\"Test of ScriptInfo.\"\"\"\n     obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#f16e477b2a7329d249b5793a0dc4986503a48371", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 29 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): -7/0 | Churn Δ: 29 | Churn Cumulative: 754 | Contributors (this commit): 15 | Commits (past 90d): 15 | Contributors (cumulative): 15 | DMM Complexity: 1.0\n\nDIFF:\n@@ -12,6 +12,7 @@\n import pytest\n \n import os\n+import uuid\n import datetime\n import flask\n from logging import StreamHandler\n@@ -99,6 +100,22 @@ class TestJSON(object):\n             rv = flask.json.dumps(u'\\N{SNOWMAN}')\n             assert rv == u'\"\\u2603\"'\n \n+    def test_json_dump_to_file(self):\n+        app = flask.Flask(__name__)\n+\n+        test_data = {'lol': 'wut'}\n+\n+        with app.app_context():\n+            t_fh = open('test_json_dump_file', 'w')\n+            flask.json.dump(test_data, t_fh)\n+            t_fh.close()\n+\n+            t_fh = open('test_json_dump_file', 'r')\n+            rv = flask.json.load(t_fh)\n+            assert rv == test_data\n+            t_fh.close()\n+            os.remove('test_json_dump_file')\n+\n     def test_jsonify_basic_types(self):\n         \"\"\"Test jsonify with basic types.\"\"\"\n         # Should be able to use pytest parametrize on this, but I couldn't\n@@ -172,6 +189,18 @@ class TestJSON(object):\n             assert rv.mimetype == 'application/json'\n             assert flask.json.loads(rv.data)['x'] == http_date(d.timetuple())\n \n+    def test_jsonify_uuid_types(self):\n+        \"\"\"Test jsonify with uuid.UUID types\"\"\"\n+        test_uuid = uuid.UUID(bytes=b'\\xDE\\xAD\\xBE\\xEF'*4)\n+\n+        app = flask.Flask(__name__)\n+        c = app.test_client()\n+        url = '/uuid_test'\n+        app.add_url_rule(url, 'uuid_test', lambda val=test_uuid: flask.jsonify(x=val))\n+        rv = c.get(url)\n+        assert rv.mimetype == 'application/json'\n+        assert flask.json.loads(rv.data)['x'] == str(test_uuid)\n+\n     def test_json_attr(self):\n         app = flask.Flask(__name__)\n         @app.route('/add', methods=['POST'])\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#f193f590bc33bde70fad200782350beac3506585", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 15 | Files Changed: 1 | Hunks: 8 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 30 | Churn Cumulative: 784 | Contributors (this commit): 15 | Commits (past 90d): 13 | Contributors (cumulative): 15 | DMM Complexity: 0.0\n\nDIFF:\n@@ -19,7 +19,7 @@ from logging import StreamHandler\n from werkzeug.exceptions import BadRequest, NotFound\n from werkzeug.http import parse_cache_control_header, parse_options_header\n from werkzeug.http import http_date\n-from flask._compat import StringIO, text_type, PY2\n+from flask._compat import StringIO, text_type\n \n \n def has_encoding(name):\n@@ -102,19 +102,14 @@ class TestJSON(object):\n \n     def test_json_dump_to_file(self):\n         app = flask.Flask(__name__)\n-\n-        test_data = {'lol': 'wut'}\n+        test_data = {'name': 'Flask'}\n+        out = StringIO()\n \n         with app.app_context():\n-            t_fh = open('test_json_dump_file', 'w')\n-            flask.json.dump(test_data, t_fh)\n-            t_fh.close()\n-\n-            t_fh = open('test_json_dump_file', 'r')\n-            rv = flask.json.load(t_fh)\n+            flask.json.dump(test_data, out)\n+            out.seek(0)\n+            rv = flask.json.load(out)\n             assert rv == test_data\n-            t_fh.close()\n-            os.remove('test_json_dump_file')\n \n     def test_jsonify_basic_types(self):\n         \"\"\"Test jsonify with basic types.\"\"\"\n@@ -191,15 +186,20 @@ class TestJSON(object):\n \n     def test_jsonify_uuid_types(self):\n         \"\"\"Test jsonify with uuid.UUID types\"\"\"\n+\n         test_uuid = uuid.UUID(bytes=b'\\xDE\\xAD\\xBE\\xEF'*4)\n \n         app = flask.Flask(__name__)\n-        c = app.test_client()\n         url = '/uuid_test'\n-        app.add_url_rule(url, 'uuid_test', lambda val=test_uuid: flask.jsonify(x=val))\n+        app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n+\n+        c = app.test_client()\n         rv = c.get(url)\n-        assert rv.mimetype == 'application/json'\n-        assert flask.json.loads(rv.data)['x'] == str(test_uuid)\n+\n+        rv_x = flask.json.loads(rv.data)['x']\n+        assert rv_x == str(test_uuid)\n+        rv_uuid = uuid.UUID(rv_x)\n+        assert rv_uuid == test_uuid\n \n     def test_json_attr(self):\n         app = flask.Flask(__name__)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#5f009374fd28aba381f375391b70ac131926bd9d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 20 | Lines Deleted: 9 | Files Changed: 6 | Hunks: 8 | Methods Changed: 0 | Complexity Δ (Sum/Max): 14/14 | Churn Δ: 29 | Churn Cumulative: 38 | Contributors (this commit): 1 | Commits (past 90d): 8 | Contributors (cumulative): 6 | DMM Complexity: None\n\nDIFF:\n@@ -1,6 +0,0 @@\n-import sys, os\n-\n-basedir = os.path.dirname(os.path.abspath(__file__))\n-sys.path.insert(0, basedir + '/../')\n-\n-from flaskr import flaskr\n\\ No newline at end of file\n\n@@ -9,11 +9,11 @@\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n \n-import pytest\n import os\n import tempfile\n+import pytest\n+from flaskr import flaskr\n \n-from context import flaskr\n \n @pytest.fixture\n def client(request):\n\n@@ -0,0 +1 @@\n+from minitwit import app\n\\ No newline at end of file\n\n\n@@ -0,0 +1,16 @@\n+from setuptools import setup\n+\n+setup(\n+    name='minitwit',\n+    packages=['minitwit'],\n+    include_package_data=True,\n+    install_requires=[\n+        'flask',\n+    ],\n+    setup_requires=[\n+        'pytest-runner',\n+    ],\n+    tests_require=[\n+        'pytest',\n+    ],\n+)\n\\ No newline at end of file\n\n@@ -9,9 +9,9 @@\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n import os\n-import minitwit\n import tempfile\n import pytest\n+from minitwit import minitwit\n \n \n @pytest.fixture\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#e00e2c22aadf9e5b9dc353c31f1b70dad488b47a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 132 | Contributors (this commit): 4 | Commits (past 90d): 1 | Contributors (cumulative): 4 | DMM Complexity: 1.0\n\nDIFF:\n@@ -87,4 +87,8 @@ def create_logger(app):\n     logger.__class__ = DebugLogger\n     logger.addHandler(debug_handler)\n     logger.addHandler(prod_handler)\n+\n+    # Disable propagation by default\n+    logger.propagate = False\n+\n     return logger\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#71e10be28665eee6a919045f9e5d8773508dc756", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 60 | Lines Deleted: 27 | Files Changed: 2 | Hunks: 17 | Methods Changed: 6 | Complexity Δ (Sum/Max): -1/1 | Churn Δ: 87 | Churn Cumulative: 2805 | Contributors (this commit): 48 | Commits (past 90d): 19 | Contributors (cumulative): 58 | DMM Complexity: 0.47058823529411764\n\nDIFF:\n@@ -437,7 +437,14 @@ def send_file(filename_or_fp, mimetype=None, as_attachment=False,\n     to ``True`` to directly emit an ``X-Sendfile`` header.  This however\n     requires support of the underlying webserver for ``X-Sendfile``.\n \n-    You must explicitly provide the mimetype for the filename or file object.\n+    By default it will try to guess the mimetype for you, but you can\n+    also explicitly provide one.  For extra security you probably want\n+    to send certain files as attachment (HTML for instance).  The mimetype\n+    guessing requires a `filename` or an `attachment_filename` to be\n+    provided.\n+\n+    ETags will also be attached automatically if a `filename` is provided. You\n+    can turn this off by setting `add_etags=False`.\n \n     Please never pass filenames to this function from user sources;\n     you should use :func:`send_from_directory` instead.\n@@ -458,9 +465,13 @@ def send_file(filename_or_fp, mimetype=None, as_attachment=False,\n        cache_timeout pulls its default from application config, when None.\n \n     .. versionchanged:: 0.12\n-       mimetype guessing and etag support removed for file objects.\n-       If no mimetype or attachment_filename is provided, application/octet-stream\n-       will be used.\n+       The filename is no longer automatically inferred from file objects. If\n+       you want to use automatic mimetype and etag support, pass a filepath via\n+       `filename_or_fp` or `attachment_filename`.\n+\n+    .. versionchanged:: 0.12\n+       The `attachment_filename` is preferred over `filename` for MIME-type\n+       detection.\n \n     :param filename_or_fp: the filename of the file to send in `latin-1`.\n                            This is relative to the :attr:`~Flask.root_path`\n@@ -470,8 +481,9 @@ def send_file(filename_or_fp, mimetype=None, as_attachment=False,\n                            back to the traditional method.  Make sure that the\n                            file pointer is positioned at the start of data to\n                            send before calling :func:`send_file`.\n-    :param mimetype: the mimetype of the file if provided, otherwise\n-                     auto detection happens.\n+    :param mimetype: the mimetype of the file if provided. If a file path is\n+                     given, auto detection happens as fallback, otherwise an\n+                     error will be raised.\n     :param as_attachment: set to ``True`` if you want to send this file with\n                           a ``Content-Disposition: attachment`` header.\n     :param attachment_filename: the filename for the attachment if it\n@@ -490,26 +502,36 @@ def send_file(filename_or_fp, mimetype=None, as_attachment=False,\n     mtime = None\n     if isinstance(filename_or_fp, string_types):\n         filename = filename_or_fp\n-        file = None\n-    else:\n-        file = filename_or_fp\n-        filename = getattr(file, 'name', None)\n-\n-    if filename is not None:\n         if not os.path.isabs(filename):\n             filename = os.path.join(current_app.root_path, filename)\n-    if mimetype is None and (filename or attachment_filename):\n-        mimetype = mimetypes.guess_type(filename or attachment_filename)[0]\n+        file = None\n+        if attachment_filename is None:\n+            attachment_filename = os.path.basename(filename)\n+    else:\n+        file = filename_or_fp\n+        filename = None\n+\n     if mimetype is None:\n-        mimetype = 'application/octet-stream'\n+        if attachment_filename is not None:\n+            mimetype = mimetypes.guess_type(attachment_filename)[0]\n+\n+        if mimetype is None:\n+            if attachment_filename is not None:\n+                raise ValueError(\n+                    'Unable to infer MIME-type from filename {!r}, please '\n+                    'pass one explicitly.'.format(mimetype_filename)\n+                )\n+            raise ValueError(\n+                'Unable to infer MIME-type because no filename is available. '\n+                'Please set either `attachment_filename`, pass a filepath to '\n+                '`filename_or_fp` or set your own MIME-type via `mimetype`.'\n+            )\n \n     headers = Headers()\n     if as_attachment:\n         if attachment_filename is None:\n-            if filename is None:\n             raise TypeError('filename unavailable, required for '\n                             'sending as attachment')\n-            attachment_filename = os.path.basename(filename)\n         headers.add('Content-Disposition', 'attachment',\n                     filename=attachment_filename)\n \n\n@@ -384,18 +384,30 @@ class TestSendfile(object):\n \n         @app.route('/')\n         def index():\n-            return flask.send_file(StringIO(\"party like it's\"), last_modified=last_modified)\n+            return flask.send_file(StringIO(\"party like it's\"),\n+                                   last_modified=last_modified,\n+                                   mimetype='text/plain')\n \n         c = app.test_client()\n         rv = c.get('/')\n         assert rv.last_modified == last_modified\n \n+    def test_send_file_object_without_mimetype(self):\n+        app = flask.Flask(__name__)\n+\n+        with app.test_request_context():\n+            with pytest.raises(ValueError) as excinfo:\n+                flask.send_file(StringIO(\"LOL\"))\n+\n+            assert 'Unable to infer MIME-type' in str(excinfo)\n+            assert 'no filename is available' in str(excinfo)\n+\n     def test_send_file_object(self):\n         app = flask.Flask(__name__)\n \n         with app.test_request_context():\n             with open(os.path.join(app.root_path, 'static/index.html'), mode='rb') as f:\n-                rv = flask.send_file(f)\n+                rv = flask.send_file(f, mimetype='text/html')\n                 rv.direct_passthrough = False\n                 with app.open_resource('static/index.html') as f:\n                     assert rv.data == f.read()\n@@ -406,17 +418,15 @@ class TestSendfile(object):\n \n         with app.test_request_context():\n             with open(os.path.join(app.root_path, 'static/index.html')) as f:\n-                rv = flask.send_file(f)\n+                rv = flask.send_file(f, mimetype='text/html')\n                 assert rv.mimetype == 'text/html'\n-                assert 'x-sendfile' in rv.headers\n-                assert rv.headers['x-sendfile'] == \\\n-                    os.path.join(app.root_path, 'static/index.html')\n+                assert 'x-sendfile' not in rv.headers\n                 rv.close()\n \n         app.use_x_sendfile = False\n         with app.test_request_context():\n             f = StringIO('Test')\n-            rv = flask.send_file(f)\n+            rv = flask.send_file(f, mimetype='application/octet-stream')\n             rv.direct_passthrough = False\n             assert rv.data == b'Test'\n             assert rv.mimetype == 'application/octet-stream'\n@@ -429,7 +439,7 @@ class TestSendfile(object):\n                     return getattr(self._io, name)\n             f = PyStringIO('Test')\n             f.name = 'test.txt'\n-            rv = flask.send_file(f)\n+            rv = flask.send_file(f, attachment_filename=f.name)\n             rv.direct_passthrough = False\n             assert rv.data == b'Test'\n             assert rv.mimetype == 'text/plain'\n@@ -446,7 +456,7 @@ class TestSendfile(object):\n \n         with app.test_request_context():\n             f = StringIO('Test')\n-            rv = flask.send_file(f)\n+            rv = flask.send_file(f, mimetype='text/html')\n             assert 'x-sendfile' not in rv.headers\n             rv.close()\n \n@@ -454,7 +464,8 @@ class TestSendfile(object):\n         app = flask.Flask(__name__)\n         with app.test_request_context():\n             with open(os.path.join(app.root_path, 'static/index.html')) as f:\n-                rv = flask.send_file(f, as_attachment=True)\n+                rv = flask.send_file(f, as_attachment=True,\n+                                     attachment_filename='index.html')\n                 value, options = \\\n                     parse_options_header(rv.headers['Content-Disposition'])\n                 assert value == 'attachment'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
