{"custom_id": "scrapy#760c0db094b3147236294f656f4168c16502de97", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 448 | Contributors (this commit): 1 | Commits (past 90d): 9 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -1,5 +1,4 @@\n-from collections.abc import Mapping\n-from typing import Any, Dict, Iterator, Optional, OrderedDict\n+from typing import Any, Dict, Iterator, Mapping, Optional, OrderedDict\n \n from scrapy.utils.conf import build_component_list\n from scrapy.utils.misc import load_object\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#ebce5b4bcb8b0af172dce063d9a220359202cf36", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 60 | Lines Deleted: 9 | Files Changed: 1 | Hunks: 6 | Methods Changed: 9 | Complexity Δ (Sum/Max): 13/13 | Churn Δ: 69 | Churn Cumulative: 220 | Contributors (this commit): 1 | Commits (past 90d): 3 | Contributors (cumulative): 1 | DMM Complexity: 0.3076923076923077\n\nDIFF:\n@@ -51,8 +51,16 @@ stats_dump_2 = {\n }\n \n \n+class TestExtPeriodicLog(PeriodicLog):\n+    def set_a(self):\n+        self.stats._stats = stats_dump_1\n+\n+    def set_b(self):\n+        self.stats._stats = stats_dump_2\n+\n+\n def extension(settings=None):\n-    return PeriodicLog.from_crawler(\n+    return TestExtPeriodicLog.from_crawler(\n         Crawler(\n             MetaSpider,\n             settings=settings,\n@@ -124,14 +132,57 @@ class TestPeriodicLog(unittest.TestCase):\n             }\n         )\n \n-    def test_periodic_log_stats(self):\n-        pass\n-\n     def test_log_delta(self):\n-        pass\n+        def emulate(settings=None):\n+            ext = extension(settings)\n+            ext.spider_opened(MetaSpider)\n+            ext.set_a()\n+            a = ext.log_delta()\n+            ext.set_a()\n+            b = ext.log_delta()\n+            return ext, a, b\n \n-    def test_settings_include(self):\n-        pass\n+        def check(settings: dict, condition: callable):\n+            ext, a, b = emulate(settings)\n+            assert list(a[\"delta\"].keys()) == [\n+                k for k, v in ext.stats._stats.items() if condition(k, v)\n+            ]\n+            assert list(b[\"delta\"].keys()) == [\n+                k for k, v in ext.stats._stats.items() if condition(k, v)\n+            ]\n \n-    def test_settings_exclude(self):\n-        pass\n+        # Including all\n+        check({\"PERIODIC_LOG_DELTA\": True}, lambda k, v: isinstance(v, (int, float)))\n+\n+        # include:\n+        check(\n+            {\"PERIODIC_LOG_DELTA\": {\"include\": [\"downloader/\"]}},\n+            lambda k, v: isinstance(v, (int, float)) and \"downloader/\" in k,\n+        )\n+\n+        # include multiple\n+        check(\n+            {\"PERIODIC_LOG_DELTA\": {\"include\": [\"downloader/\", \"scheduler/\"]}},\n+            lambda k, v: isinstance(v, (int, float))\n+            and (\"downloader/\" in k or \"scheduler/\" in k),\n+        )\n+\n+        # exclude\n+        check(\n+            {\"PERIODIC_LOG_DELTA\": {\"exclude\": [\"downloader/\"]}},\n+            lambda k, v: isinstance(v, (int, float)) and \"downloader/\" not in k,\n+        )\n+\n+        # exclude multiple\n+        check(\n+            {\"PERIODIC_LOG_DELTA\": {\"exclude\": [\"downloader/\", \"scheduler/\"]}},\n+            lambda k, v: isinstance(v, (int, float))\n+            and (\"downloader/\" not in k and \"scheduler/\" not in k),\n+        )\n+\n+        # include exclude combined\n+        check(\n+            {\"PERIODIC_LOG_DELTA\": {\"include\": [\"downloader/\"], \"exclude\": [\"bytes\"]}},\n+            lambda k, v: isinstance(v, (int, float))\n+            and (\"downloader/\" in k and \"scheduler/\" not in k),\n+        )\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#315861c31d1bb1b2430883267b6973604b34a147", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 2 | Churn Cumulative: 34 | Contributors (this commit): 1 | Commits (past 90d): 4 | Contributors (cumulative): 1 | DMM Complexity: 0.0\n\nDIFF:\n@@ -127,6 +127,8 @@ class PeriodicLog:\n         for p in exclude:\n             if p in stat_name:\n                 return False\n+        if exclude and not include:\n+            return True\n         for p in include:\n             if p in stat_name:\n                 return True\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#56c38231b49f4f49fe5e215e46ec80c71755d44e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 54 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 4 | Complexity Δ (Sum/Max): 10/10 | Churn Δ: 55 | Churn Cumulative: 275 | Contributors (this commit): 1 | Commits (past 90d): 4 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -184,5 +184,58 @@ class TestPeriodicLog(unittest.TestCase):\n         check(\n             {\"PERIODIC_LOG_DELTA\": {\"include\": [\"downloader/\"], \"exclude\": [\"bytes\"]}},\n             lambda k, v: isinstance(v, (int, float))\n-            and (\"downloader/\" in k and \"scheduler/\" not in k),\n+            and (\"downloader/\" in k and \"bytes\" not in k),\n         )\n+\n+    def test_log_stats(self):\n+        def emulate(settings=None):\n+            ext = extension(settings)\n+            ext.spider_opened(MetaSpider)\n+            ext.set_a()\n+            a = ext.log_crawler_stats()\n+            ext.set_a()\n+            b = ext.log_crawler_stats()\n+            return ext, a, b\n+\n+        def check(settings: dict, condition: callable):\n+            ext, a, b = emulate(settings)\n+            assert list(a[\"stats\"].keys()) == [\n+                k for k, v in ext.stats._stats.items() if condition(k, v)\n+            ]\n+            assert list(b[\"stats\"].keys()) == [\n+                k for k, v in ext.stats._stats.items() if condition(k, v)\n+            ]\n+\n+        # Including all\n+        check({\"PERIODIC_LOG_STATS\": True}, lambda k, v: True)\n+\n+        # include:\n+        check(\n+            {\"PERIODIC_LOG_STATS\": {\"include\": [\"downloader/\"]}},\n+            lambda k, v: \"downloader/\" in k,\n+        )\n+\n+        # include multiple\n+        check(\n+            {\"PERIODIC_LOG_STATS\": {\"include\": [\"downloader/\", \"scheduler/\"]}},\n+            lambda k, v: \"downloader/\" in k or \"scheduler/\" in k,\n+        )\n+\n+        # exclude\n+        check(\n+            {\"PERIODIC_LOG_STATS\": {\"exclude\": [\"downloader/\"]}},\n+            lambda k, v: \"downloader/\" not in k,\n+        )\n+\n+        # exclude multiple\n+        check(\n+            {\"PERIODIC_LOG_STATS\": {\"exclude\": [\"downloader/\", \"scheduler/\"]}},\n+            lambda k, v: \"downloader/\" not in k and \"scheduler/\" not in k,\n+        )\n+\n+        # include exclude combined\n+        check(\n+            {\"PERIODIC_LOG_STATS\": {\"include\": [\"downloader/\"], \"exclude\": [\"bytes\"]}},\n+            lambda k, v: \"downloader/\" in k and \"bytes\" not in k,\n+        )\n+        #\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#b6196309cb654e6662197e19de36a9d18a83f12f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 9 | Files Changed: 2 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 14 | Churn Cumulative: 2181 | Contributors (this commit): 25 | Commits (past 90d): 7 | Contributors (cumulative): 38 | DMM Complexity: 0.0\n\nDIFF:\n@@ -449,12 +449,12 @@ class BaseSettings(MutableMapping):\n \n     def pop(self, name, default=__default):\n         try:\n-            value = self.attributes[name]\n+            value = self.attributes[name].value\n         except KeyError:\n             if default is self.__default:\n                 raise\n \n-            return SettingsAttribute(default, get_settings_priority(\"project\"))\n+            return default\n         else:\n             self.__delitem__(name)\n             return value\n\n@@ -457,19 +457,15 @@ class SettingsTest(unittest.TestCase):\n         with self.assertRaises(KeyError):\n             settings.pop(\"DUMMY_CONFIG\")\n \n-        dummy_config = settings.pop(\"DUMMY_CONFIG\", \"dummy_value\")\n-\n-        self.assertEqual(\n-            repr(dummy_config), \"<SettingsAttribute value='dummy_value' priority=20>\"\n-        )\n-        self.assertEqual(dummy_config.value, \"dummy_value\")\n+        dummy_config_value = settings.pop(\"DUMMY_CONFIG\", \"dummy_value\")\n+        self.assertEqual(dummy_config_value, \"dummy_value\")\n \n     def test_pop_item_with_immutable_settings(self):\n         settings = Settings(\n             {\"DUMMY_CONFIG\": \"dummy_value\", \"OTHER_DUMMY_CONFIG\": \"other_dummy_value\"}\n         )\n \n-        self.assertEqual(settings.pop(\"DUMMY_CONFIG\").value, \"dummy_value\")\n+        self.assertEqual(settings.pop(\"DUMMY_CONFIG\"), \"dummy_value\")\n \n         settings.freeze()\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#9612ae3e93239b86cedcd124073de6fff2736e99", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 25 | Lines Deleted: 163 | Files Changed: 3 | Hunks: 20 | Methods Changed: 23 | Complexity Δ (Sum/Max): -19/0 | Churn Δ: 188 | Churn Cumulative: 2138 | Contributors (this commit): 20 | Commits (past 90d): 16 | Contributors (cumulative): 22 | DMM Complexity: 0.20408163265306123\n\nDIFF:\n@@ -1,100 +1,16 @@\n-from typing import Any, Dict, Iterator, Mapping, Optional, OrderedDict\n+from typing import Any, List\n \n from scrapy.utils.conf import build_component_list\n from scrapy.utils.misc import load_object\n \n \n-class Addon(object):\n-    name: str\n-\n-    default_config = None\n-    \"\"\"``dict`` with default configuration.\"\"\"\n-\n-    config_mapping = None\n-    \"\"\"``dict`` with mappings from config names to setting names. The given\n-    setting names will be taken as given, not uppercased.\n-    \"\"\"\n-\n-    def export_config(self, config, settings):\n-        \"\"\"Export the add-on configuration, all keys in caps, into the settings\n-        object.\n-\n-        For example, the add-on configuration ``{'key': 'value'}`` will export\n-        the setting ``KEY`` with a value of ``value``. All settings\n-        will be exported with ``addon`` priority (see\n-        :ref:`topics-api-settings`).\n-\n-        :param config: Add-on configuration to be exposed\n-        :type config: ``dict``\n-\n-        :param settings: Settings object into which to export the configuration\n-        :type settings: :class:`~scrapy.settings.Settings`\n-        \"\"\"\n-        conf = self.default_config or {}\n-        conf.update(config)\n-        # Since default exported config is case-insensitive (everything will be\n-        # uppercased), make mapped config case-insensitive as well\n-        conf_mapping = {k.lower(): v for k, v in (self.config_mapping or {}).items()}\n-        for key, val in conf.items():\n-            if key.lower() in conf_mapping:\n-                key = conf_mapping[key.lower()]\n-            else:\n-                key = key.upper()\n-            settings.set(key, val, \"addon\")\n-\n-    def update_settings(self, config, settings):\n-        \"\"\"Modifiy `settings` to enable and configure required components.\n-\n-        :param config: Add-on configuration\n-        :type config: ``dict``\n-\n-        :param settings: Crawler settings object\n-        :type settings: :class:`~scrapy.settings.Settings`\n-        \"\"\"\n-        self.export_config(config, settings)\n-\n-    def check_configuration(self, config, crawler):\n-        \"\"\"Perform post-initialization checks on fully configured `crawler`.\n-\n-        :param config: Add-on configuration\n-        :type config: ``dict``\n-\n-        :param crawler: the fully-initialized crawler\n-        :type crawler: :class:`~scrapy.crawler.Crawler`\n-        \"\"\"\n-        pass\n-\n-\n-class AddonManager(Mapping[str, Addon]):\n-    \"\"\"This class facilitates loading and storing :ref:`topics-addons`.\n-\n-    You can treat it like a read-only dictionary in which keys correspond to\n-    add-on names and values correspond to the add-on objects. Add-on\n-    configurations are saved in the :attr:`config` dictionary attribute::\n-\n-        addons = AddonManager()\n-        # ... load some add-ons here\n-        print(addons.enabled)  # prints names of all enabled add-ons\n-        print(addons['TestAddon'].version)  # prints version of add-on with name\n-                                           # 'TestAddon'\n-        print(addons.configs['TestAddon'])  # prints configuration of 'TestAddon'\n-\n-    \"\"\"\n+class AddonManager:\n+    \"\"\"This class facilitates loading and storing :ref:`topics-addons`.\"\"\"\n \n     def __init__(self) -> None:\n-        self._addons: OrderedDict[str, Addon] = OrderedDict[str, Addon]()\n-        self.configs: Dict[str, Dict[str, Any]] = {}\n+        self.addons: List[Any] = []\n \n-    def __getitem__(self, name: str) -> Addon:\n-        return self._addons[name]\n-\n-    def __iter__(self) -> Iterator[str]:\n-        return iter(self._addons)\n-\n-    def __len__(self) -> int:\n-        return len(self._addons)\n-\n-    def add(self, addon: Any, config: Optional[Dict[str, Any]] = None):\n+    def add(self, addon: Any) -> None:\n         \"\"\"Store an add-on.\n \n         :param addon: The add-on object (or path) to be stored\n@@ -107,19 +23,13 @@ class AddonManager(Mapping[str, Addon]):\n             addon = load_object(addon)\n         if isinstance(addon, type):\n             addon = addon()\n-        name = addon.name\n-        if name in self:\n-            raise ValueError(f\"Addon '{name}' already loaded\")\n-        self._addons[name] = addon\n-        self.configs[name] = config or {}\n+        self.addons.append(addon)\n \n-    def load_settings(self, settings):\n+    def load_settings(self, settings) -> None:\n         \"\"\"Load add-ons and configurations from settings object.\n \n         This will load the addon for every add-on path in the\n-        ``ADDONS`` setting. For each of these add-ons, the configuration will be\n-        read from the dictionary setting whose name matches the uppercase add-on\n-        name.\n+        ``ADDONS`` setting.\n \n         :param settings: The :class:`~scrapy.settings.Settings` object from \\\n             which to read the add-on configuration\n@@ -127,9 +37,8 @@ class AddonManager(Mapping[str, Addon]):\n         \"\"\"\n         paths = build_component_list(settings[\"ADDONS\"])\n         addons = [load_object(path) for path in paths]\n-        configs = [settings.getdict(addon.name.upper()) for addon in addons]\n-        for a, c in zip(addons, configs):\n-            self.add(a, c)\n+        for a in addons:\n+            self.add(a)\n \n     def update_settings(self, settings) -> None:\n         \"\"\"Call ``update_settings()`` of all held add-ons.\n@@ -138,14 +47,5 @@ class AddonManager(Mapping[str, Addon]):\n             updated\n         :type settings: :class:`~scrapy.settings.Settings`\n         \"\"\"\n-        for name in self:\n-            self[name].update_settings(self.configs[name], settings)\n-\n-    def check_configuration(self, crawler) -> None:\n-        \"\"\"Call ``check_configuration()`` of all held add-ons.\n-\n-        :param crawler: the fully-initialized crawler\n-        :type crawler: :class:`~scrapy.crawler.Crawler`\n-        \"\"\"\n-        for name in self:\n-            self[name].check_configuration(self.configs[name], crawler)\n+        for addon in self.addons:\n+            addon.update_settings(settings)\n\n@@ -1,47 +1,29 @@\n import unittest\n+from typing import Any, Dict, Optional\n \n-from scrapy.addons import Addon, AddonManager\n+from scrapy.addons import AddonManager\n from scrapy.settings import BaseSettings\n \n \n-class GoodAddon(object):\n+class GoodAddon:\n     name = \"GoodAddon\"\n \n-    def update_settings(self, config, settings):\n-        pass\n+    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:\n+        super().__init__()\n+        self.config = config or {}\n \n-    def check_configuration(self, config, crawler):\n-        pass\n+    def update_settings(self, settings):\n+        settings.update(self.config, \"addon\")\n \n \n class AddonTest(unittest.TestCase):\n-    def setUp(self):\n-        class AddonWithAttributes(Addon):\n-            name = \"Test\"\n-\n-        self.testaddon = AddonWithAttributes()\n-\n-    def test_export_config(self):\n-        settings = BaseSettings()\n-        self.testaddon.config_mapping = {\"MAPPED_key\": \"MAPPING_WORKED\"}\n-        self.testaddon.default_config = {\"key\": 55, \"defaultkey\": 100}\n-        self.testaddon.export_config(\n-            {\"key\": 313, \"OTHERKEY\": True, \"mapped_KEY\": 99}, settings\n-        )\n-        self.assertEqual(settings[\"KEY\"], 313)\n-        self.assertEqual(settings[\"DEFAULTKEY\"], 100)\n-        self.assertEqual(settings[\"OTHERKEY\"], True)\n-        self.assertNotIn(\"MAPPED_key\", settings)\n-        self.assertNotIn(\"MAPPED_KEY\", settings)\n-        self.assertEqual(settings[\"MAPPING_WORKED\"], 99)\n-        self.assertEqual(settings.getpriority(\"KEY\"), 15)\n-\n     def test_update_settings(self):\n         settings = BaseSettings()\n         settings.set(\"KEY1\", \"default\", priority=\"default\")\n         settings.set(\"KEY2\", \"project\", priority=\"project\")\n-        addon_config = {\"key1\": \"addon\", \"key2\": \"addon\", \"key3\": \"addon\"}\n-        self.testaddon.update_settings(addon_config, settings)\n+        addon_config = {\"KEY1\": \"addon\", \"KEY2\": \"addon\", \"KEY3\": \"addon\"}\n+        testaddon = GoodAddon(addon_config)\n+        testaddon.update_settings(settings)\n         self.assertEqual(settings[\"KEY1\"], \"addon\")\n         self.assertEqual(settings[\"KEY2\"], \"project\")\n         self.assertEqual(settings[\"KEY3\"], \"addon\")\n@@ -54,8 +36,7 @@ class AddonManagerTest(unittest.TestCase):\n     def test_add(self):\n         manager = AddonManager()\n         manager.add(\"tests.test_addons.GoodAddon\")\n-        self.assertCountEqual(manager, [\"GoodAddon\"])\n-        self.assertIsInstance(manager[\"GoodAddon\"], GoodAddon)\n+        self.assertIsInstance(manager.addons[0], GoodAddon)\n \n     def test_load_settings(self):\n         settings = BaseSettings()\n@@ -66,7 +47,4 @@ class AddonManagerTest(unittest.TestCase):\n         settings.set(\"GOODADDON\", {\"key\": \"val2\"})\n         manager = AddonManager()\n         manager.load_settings(settings)\n-        self.assertCountEqual(manager, [\"GoodAddon\"])\n-        self.assertIsInstance(manager[\"GoodAddon\"], GoodAddon)\n-        self.assertCountEqual(manager.configs[\"GoodAddon\"], [\"key\"])\n-        self.assertEqual(manager.configs[\"GoodAddon\"][\"key\"], \"val2\")\n+        self.assertIsInstance(manager.addons[0], GoodAddon)\n\n@@ -13,7 +13,6 @@ from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy import signals\n-from scrapy.addons import Addon, AddonManager\n from scrapy.crawler import CrawlerRunner\n from scrapy.exceptions import StopDownload\n from scrapy.http import Request\n@@ -408,21 +407,6 @@ with multiples lines\n         self._assert_retried(log)\n         self.assertIn(\"Got response 200\", str(log))\n \n-    @defer.inlineCallbacks\n-    def test_abort_on_addon_failed_check(self):\n-        class FailedCheckAddon(Addon):\n-            name = \"FailedCheckAddon\"\n-\n-            def check_configuration(self, config, crawler):\n-                raise ValueError\n-\n-        addonmgr = AddonManager()\n-        addonmgr.add(FailedCheckAddon())\n-        crawler = get_crawler(SimpleSpider)\n-        crawler.addons = addonmgr\n-        with self.assertRaises(ValueError):\n-            yield crawler.crawl()\n-\n \n class CrawlSpiderTestCase(TestCase):\n     def setUp(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#f1ed5598f4d312337a9dd76e0c1a5856cabea8bc", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 2061 | Contributors (this commit): 31 | Commits (past 90d): 6 | Contributors (cumulative): 31 | DMM Complexity: 0.0\n\nDIFF:\n@@ -133,7 +133,6 @@ class Crawler:\n         try:\n             self.spider = self._create_spider(*args, **kwargs)\n             self.engine = self._create_engine()\n-            self.addons.check_configuration(self)\n             start_requests = iter(self.spider.start_requests())\n             yield self.engine.open_spider(self.spider, start_requests)\n             yield defer.maybeDeferred(self.engine.start)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#6fd94fdcb3d633015372f8834308b7a0dcde5bf7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 50 | Files Changed: 1 | Hunks: 8 | Methods Changed: 5 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 56 | Churn Cumulative: 331 | Contributors (this commit): 1 | Commits (past 90d): 5 | Contributors (cumulative): 1 | DMM Complexity: 0.0\n\nDIFF:\n@@ -2,7 +2,6 @@ import datetime\n import unittest\n \n from scrapy.crawler import Crawler\n-from scrapy.exceptions import NotConfigured\n from scrapy.extensions.periodic_log import PeriodicLog\n \n from .spiders import MetaSpider\n@@ -85,61 +84,16 @@ class TestPeriodicLog(unittest.TestCase):\n         assert extension({\"PERIODIC_LOG_DELTA\": True, \"LOGSTATS_INTERVAL\": 60})\n         assert extension({\"PERIODIC_LOG_DELTA\": \"True\", \"LOGSTATS_INTERVAL\": 60})\n \n-        # Raise not configured if not set by settings\n-        with self.assertRaises(NotConfigured):\n-            extension()\n-\n-        # Regular use cases:\n-        assert extension(\n-            {\n-                \"PERIODIC_LOG_STATS\": {\n-                    \"include\": [\n-                        \"downloader/\",\n-                        \"scheduler/\",\n-                        \"log_count/\",\n-                        \"item_scraped_count/\",\n-                    ],\n-                    \"exclude\": [\"scheduler/\"],\n-                }\n-            }\n-        )\n-\n-        assert extension(\n-            {\n-                \"PERIODIC_LOG_DELTA\": {\"include\": [\"downloader/\"]},\n-                \"PERIODIC_LOG_TIMING_ENABLED\": True,\n-            }\n-        )\n-\n-        assert extension(\n-            {\n-                \"PERIODIC_LOG_TIMING_ENABLED\": True,\n-            }\n-        )\n-\n-        assert extension(\n-            {\n-                \"PERIODIC_LOG_STATS\": {\n-                    \"include\": [\n-                        \"downloader/\",\n-                        \"scheduler/\",\n-                        \"log_count/\",\n-                        \"item_scraped_count/\",\n-                    ],\n-                    \"exclude\": [\"scheduler/\"],\n-                },\n-                \"PERIODIC_LOG_DELTA\": {\"include\": [\"downloader/\"]},\n-            }\n-        )\n-\n     def test_log_delta(self):\n         def emulate(settings=None):\n+            spider = MetaSpider()\n             ext = extension(settings)\n-            ext.spider_opened(MetaSpider)\n+            ext.spider_opened(spider)\n             ext.set_a()\n             a = ext.log_delta()\n             ext.set_a()\n             b = ext.log_delta()\n+            ext.spider_closed(spider, reason=\"finished\")\n             return ext, a, b\n \n         def check(settings: dict, condition: callable):\n@@ -189,12 +143,14 @@ class TestPeriodicLog(unittest.TestCase):\n \n     def test_log_stats(self):\n         def emulate(settings=None):\n+            spider = MetaSpider()\n             ext = extension(settings)\n-            ext.spider_opened(MetaSpider)\n+            ext.spider_opened(spider)\n             ext.set_a()\n             a = ext.log_crawler_stats()\n             ext.set_a()\n             b = ext.log_crawler_stats()\n+            ext.spider_closed(spider, reason=\"finished\")\n             return ext, a, b\n \n         def check(settings: dict, condition: callable):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#c92c9af075217c2296af364a4d9ea55463dbe7f0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 42 | Lines Deleted: 20 | Files Changed: 3 | Hunks: 13 | Methods Changed: 11 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 62 | Churn Cumulative: 2815 | Contributors (this commit): 31 | Commits (past 90d): 21 | Contributors (cumulative): 33 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,13 +1,17 @@\n-from typing import Any, List\n+from typing import TYPE_CHECKING, Any, List\n \n from scrapy.utils.conf import build_component_list\n-from scrapy.utils.misc import load_object\n+from scrapy.utils.misc import create_instance, load_object\n+\n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n \n \n class AddonManager:\n     \"\"\"This class facilitates loading and storing :ref:`topics-addons`.\"\"\"\n \n-    def __init__(self) -> None:\n+    def __init__(self, crawler: \"Crawler\") -> None:\n+        self.crawler: \"Crawler\" = crawler\n         self.addons: List[Any] = []\n \n     def add(self, addon: Any) -> None:\n@@ -22,7 +26,7 @@ class AddonManager:\n         if isinstance(addon, (type, str)):\n             addon = load_object(addon)\n         if isinstance(addon, type):\n-            addon = addon()\n+            addon = create_instance(addon, settings=None, crawler=self.crawler)\n         self.addons.append(addon)\n \n     def load_settings(self, settings) -> None:\n\n@@ -69,7 +69,7 @@ class Crawler:\n         self.settings: Settings = settings.copy()\n         self.spidercls.update_settings(self.settings)\n \n-        self.addons: AddonManager = AddonManager()\n+        self.addons: AddonManager = AddonManager(self)\n         self.addons.load_settings(self.settings)\n         self.addons.update_settings(self.settings)\n \n\n@@ -1,13 +1,12 @@\n import unittest\n from typing import Any, Dict, Optional\n \n-from scrapy.addons import AddonManager\n+from scrapy.crawler import Crawler\n from scrapy.settings import BaseSettings\n+from scrapy.utils.test import get_crawler\n \n \n class GoodAddon:\n-    name = \"GoodAddon\"\n-\n     def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:\n         super().__init__()\n         self.config = config or {}\n@@ -16,6 +15,20 @@ class GoodAddon:\n         settings.update(self.config, \"addon\")\n \n \n+class CreateInstanceAddon:\n+    def __init__(self, crawler: Crawler) -> None:\n+        super().__init__()\n+        self.crawler = crawler\n+        self.config = crawler.settings.getdict(\"MYADDON\")\n+\n+    @classmethod\n+    def from_crawler(cls, crawler: Crawler):\n+        return cls(crawler)\n+\n+    def update_settings(self, settings):\n+        settings.update(self.config, \"addon\")\n+\n+\n class AddonTest(unittest.TestCase):\n     def test_update_settings(self):\n         settings = BaseSettings()\n@@ -30,21 +43,26 @@ class AddonTest(unittest.TestCase):\n \n \n class AddonManagerTest(unittest.TestCase):\n-    def setUp(self):\n-        self.manager = AddonManager()\n-\n     def test_add(self):\n-        manager = AddonManager()\n+        crawler = get_crawler()\n+        manager = crawler.addons\n         manager.add(\"tests.test_addons.GoodAddon\")\n         self.assertIsInstance(manager.addons[0], GoodAddon)\n \n     def test_load_settings(self):\n-        settings = BaseSettings()\n-        settings.set(\n-            \"ADDONS\",\n-            {\"tests.test_addons.GoodAddon\": 0},\n-        )\n-        settings.set(\"GOODADDON\", {\"key\": \"val2\"})\n-        manager = AddonManager()\n-        manager.load_settings(settings)\n+        settings_dict = {\n+            \"ADDONS\": {\"tests.test_addons.GoodAddon\": 0},\n+        }\n+        crawler = get_crawler(settings_dict=settings_dict)\n+        manager = crawler.addons\n         self.assertIsInstance(manager.addons[0], GoodAddon)\n+\n+    def test_create_instance(self):\n+        settings_dict = {\n+            \"ADDONS\": {\"tests.test_addons.CreateInstanceAddon\": 0},\n+            \"MYADDON\": {\"MYADDON_KEY\": \"val\"},\n+        }\n+        crawler = get_crawler(settings_dict=settings_dict)\n+        manager = crawler.addons\n+        self.assertIsInstance(manager.addons[0], CreateInstanceAddon)\n+        self.assertEqual(crawler.settings.get(\"MYADDON_KEY\"), \"val\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#d5f74c72247e8fd4775e380569e0b809ad1cc6b5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 10 | Churn Cumulative: 594 | Contributors (this commit): 1 | Commits (past 90d): 12 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,3 +1,4 @@\n+import logging\n from typing import TYPE_CHECKING, Any, List\n \n from scrapy.utils.conf import build_component_list\n@@ -6,6 +7,8 @@ from scrapy.utils.misc import create_instance, load_object\n if TYPE_CHECKING:\n     from scrapy.crawler import Crawler\n \n+logger = logging.getLogger(__name__)\n+\n \n class AddonManager:\n     \"\"\"This class facilitates loading and storing :ref:`topics-addons`.\"\"\"\n@@ -43,6 +46,13 @@ class AddonManager:\n         addons = [load_object(path) for path in paths]\n         for a in addons:\n             self.add(a)\n+        logger.info(\n+            \"Enabled addons:\\n%(addons)s\",\n+            {\n+                \"addons\": addons,\n+            },\n+            extra={\"crawler\": self.crawler},\n+        )\n \n     def update_settings(self, settings) -> None:\n         \"\"\"Call ``update_settings()`` of all held add-ons.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#7ce3d8f98ad6b28d138757bdc5655d8c91ffd042", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 394 | Contributors (this commit): 18 | Commits (past 90d): 1 | Contributors (cumulative): 18 | DMM Complexity: None\n\nDIFF:\n@@ -12,8 +12,8 @@ DATADIR_CFG_SECTION = \"datadir\"\n \n \n def inside_project():\n-    scrapy_module = os.environ.get(\"SCRAPY_SETTINGS_MODULE\")\n-    if scrapy_module is not None:\n+    scrapy_module = os.environ.get(ENVVAR)\n+    if scrapy_module:\n         try:\n             import_module(scrapy_module)\n         except ImportError as exc:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#187e8f9a2d2fbf2c84fb5b39c25e7e7fc155ced0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 139 | Lines Deleted: 51 | Files Changed: 4 | Hunks: 56 | Methods Changed: 72 | Complexity Δ (Sum/Max): 4/2 | Churn Δ: 190 | Churn Cumulative: 5040 | Contributors (this commit): 47 | Commits (past 90d): 18 | Contributors (cumulative): 89 | DMM Complexity: 0.9156626506024096\n\nDIFF:\n@@ -55,7 +55,7 @@ class Crawler:\n     def __init__(\n         self,\n         spidercls: Type[Spider],\n-        settings: Union[None, dict, Settings] = None,\n+        settings: Union[None, Dict[str, Any], Settings] = None,\n         init_reactor: bool = False,\n     ):\n         if isinstance(spidercls, Spider):\n\n@@ -1,12 +1,41 @@\n+from __future__ import annotations\n+\n import copy\n import json\n-from collections.abc import MutableMapping\n from importlib import import_module\n from pprint import pformat\n+from types import ModuleType\n+from typing import (\n+    TYPE_CHECKING,\n+    Any,\n+    Dict,\n+    Iterable,\n+    Iterator,\n+    List,\n+    Mapping,\n+    MutableMapping,\n+    Optional,\n+    Tuple,\n+    Union,\n+    cast,\n+)\n \n from scrapy.settings import default_settings\n \n-SETTINGS_PRIORITIES = {\n+# The key types are restricted in BaseSettings._get_key() to ones supported by JSON,\n+# see https://github.com/scrapy/scrapy/issues/5383.\n+_SettingsKeyT = Union[bool, float, int, str, None]\n+\n+if TYPE_CHECKING:\n+    # typing.Self requires Python 3.11\n+    # https://github.com/python/typing/issues/445#issuecomment-1131458824\n+    from _typeshed import SupportsItems\n+    from typing_extensions import Self\n+\n+    _SettingsInputT = Union[SupportsItems[_SettingsKeyT, Any], str, None]\n+\n+\n+SETTINGS_PRIORITIES: Dict[str, int] = {\n     \"default\": 0,\n     \"command\": 10,\n     \"project\": 20,\n@@ -15,7 +44,7 @@ SETTINGS_PRIORITIES = {\n }\n \n \n-def get_settings_priority(priority):\n+def get_settings_priority(priority: Union[int, str]) -> int:\n     \"\"\"\n     Small helper function that looks up a given string priority in the\n     :attr:`~scrapy.settings.SETTINGS_PRIORITIES` dictionary and returns its\n@@ -34,14 +63,15 @@ class SettingsAttribute:\n     for settings configuration, not this one.\n     \"\"\"\n \n-    def __init__(self, value, priority):\n-        self.value = value\n+    def __init__(self, value: Any, priority: int):\n+        self.value: Any = value\n+        self.priority: int\n         if isinstance(self.value, BaseSettings):\n             self.priority = max(self.value.maxpriority(), priority)\n         else:\n             self.priority = priority\n \n-    def set(self, value, priority):\n+    def set(self, value: Any, priority: int) -> None:\n         \"\"\"Sets value if priority is higher or equal than current priority.\"\"\"\n         if priority >= self.priority:\n             if isinstance(self.value, BaseSettings):\n@@ -49,11 +79,11 @@ class SettingsAttribute:\n             self.value = value\n             self.priority = priority\n \n-    def __repr__(self):\n+    def __repr__(self) -> str:\n         return f\"<SettingsAttribute value={self.value!r} priority={self.priority}>\"\n \n \n-class BaseSettings(MutableMapping):\n+class BaseSettings(MutableMapping[_SettingsKeyT, Any]):\n     \"\"\"\n     Instances of this class behave like dictionaries, but store priorities\n     along with their ``(key, value)`` pairs, and can be frozen (i.e. marked\n@@ -77,21 +107,23 @@ class BaseSettings(MutableMapping):\n \n     __default = object()\n \n-    def __init__(self, values=None, priority=\"project\"):\n-        self.frozen = False\n-        self.attributes = {}\n+    def __init__(\n+        self, values: _SettingsInputT = None, priority: Union[int, str] = \"project\"\n+    ):\n+        self.frozen: bool = False\n+        self.attributes: dict[_SettingsKeyT, SettingsAttribute] = {}\n         if values:\n             self.update(values, priority)\n \n-    def __getitem__(self, opt_name):\n+    def __getitem__(self, opt_name: _SettingsKeyT) -> Any:\n         if opt_name not in self:\n             return None\n         return self.attributes[opt_name].value\n \n-    def __contains__(self, name):\n+    def __contains__(self, name: Any) -> bool:\n         return name in self.attributes\n \n-    def get(self, name, default=None):\n+    def get(self, name: _SettingsKeyT, default: Any = None) -> Any:\n         \"\"\"\n         Get a setting value without affecting its original type.\n \n@@ -103,7 +135,7 @@ class BaseSettings(MutableMapping):\n         \"\"\"\n         return self[name] if self[name] is not None else default\n \n-    def getbool(self, name, default=False):\n+    def getbool(self, name: _SettingsKeyT, default: bool = False) -> bool:\n         \"\"\"\n         Get a setting value as a boolean.\n \n@@ -133,7 +165,7 @@ class BaseSettings(MutableMapping):\n                 \"'True'/'False' and 'true'/'false'\"\n             )\n \n-    def getint(self, name, default=0):\n+    def getint(self, name: _SettingsKeyT, default: int = 0) -> int:\n         \"\"\"\n         Get a setting value as an int.\n \n@@ -145,7 +177,7 @@ class BaseSettings(MutableMapping):\n         \"\"\"\n         return int(self.get(name, default))\n \n-    def getfloat(self, name, default=0.0):\n+    def getfloat(self, name: _SettingsKeyT, default: float = 0.0) -> float:\n         \"\"\"\n         Get a setting value as a float.\n \n@@ -157,7 +189,9 @@ class BaseSettings(MutableMapping):\n         \"\"\"\n         return float(self.get(name, default))\n \n-    def getlist(self, name, default=None):\n+    def getlist(\n+        self, name: _SettingsKeyT, default: Optional[List[Any]] = None\n+    ) -> List[Any]:\n         \"\"\"\n         Get a setting value as a list. If the setting original type is a list, a\n         copy of it will be returned. If it's a string it will be split by \",\".\n@@ -176,7 +210,9 @@ class BaseSettings(MutableMapping):\n             value = value.split(\",\")\n         return list(value)\n \n-    def getdict(self, name, default=None):\n+    def getdict(\n+        self, name: _SettingsKeyT, default: Optional[Dict[Any, Any]] = None\n+    ) -> Dict[Any, Any]:\n         \"\"\"\n         Get a setting value as a dictionary. If the setting original type is a\n         dictionary, a copy of it will be returned. If it is a string it will be\n@@ -197,7 +233,11 @@ class BaseSettings(MutableMapping):\n             value = json.loads(value)\n         return dict(value)\n \n-    def getdictorlist(self, name, default=None):\n+    def getdictorlist(\n+        self,\n+        name: _SettingsKeyT,\n+        default: Union[Dict[Any, Any], List[Any], None] = None,\n+    ) -> Union[Dict[Any, Any], List[Any]]:\n         \"\"\"Get a setting value as either a :class:`dict` or a :class:`list`.\n \n         If the setting is already a dict or a list, a copy of it will be\n@@ -224,24 +264,29 @@ class BaseSettings(MutableMapping):\n             return {}\n         if isinstance(value, str):\n             try:\n-                return json.loads(value)\n+                value_loaded = json.loads(value)\n+                assert isinstance(value_loaded, (dict, list))\n+                return value_loaded\n             except ValueError:\n                 return value.split(\",\")\n+        assert isinstance(value, (dict, list))\n         return copy.deepcopy(value)\n \n-    def getwithbase(self, name):\n+    def getwithbase(self, name: _SettingsKeyT) -> \"BaseSettings\":\n         \"\"\"Get a composition of a dictionary-like setting and its `_BASE`\n         counterpart.\n \n         :param name: name of the dictionary-like setting\n         :type name: str\n         \"\"\"\n+        if not isinstance(name, str):\n+            raise ValueError(f\"Base setting key must be a string, got {name}\")\n         compbs = BaseSettings()\n         compbs.update(self[name + \"_BASE\"])\n         compbs.update(self[name])\n         return compbs\n \n-    def getpriority(self, name):\n+    def getpriority(self, name: _SettingsKeyT) -> Optional[int]:\n         \"\"\"\n         Return the current numerical priority value of a setting, or ``None`` if\n         the given ``name`` does not exist.\n@@ -253,7 +298,7 @@ class BaseSettings(MutableMapping):\n             return None\n         return self.attributes[name].priority\n \n-    def maxpriority(self):\n+    def maxpriority(self) -> int:\n         \"\"\"\n         Return the numerical value of the highest priority present throughout\n         all settings, or the numerical value for ``default`` from\n@@ -261,13 +306,15 @@ class BaseSettings(MutableMapping):\n         stored.\n         \"\"\"\n         if len(self) > 0:\n-            return max(self.getpriority(name) for name in self)\n+            return max(cast(int, self.getpriority(name)) for name in self)\n         return get_settings_priority(\"default\")\n \n-    def __setitem__(self, name, value):\n+    def __setitem__(self, name: _SettingsKeyT, value: Any) -> None:\n         self.set(name, value)\n \n-    def set(self, name, value, priority=\"project\"):\n+    def set(\n+        self, name: _SettingsKeyT, value: Any, priority: Union[int, str] = \"project\"\n+    ) -> None:\n         \"\"\"\n         Store a key/value attribute with a given priority.\n \n@@ -295,17 +342,26 @@ class BaseSettings(MutableMapping):\n         else:\n             self.attributes[name].set(value, priority)\n \n-    def setdefault(self, name, default=None, priority=\"project\"):\n+    def setdefault(\n+        self,\n+        name: _SettingsKeyT,\n+        default: Any = None,\n+        priority: Union[int, str] = \"project\",\n+    ) -> Any:\n         if name not in self:\n             self.set(name, default, priority)\n             return default\n \n         return self.attributes[name].value\n \n-    def setdict(self, values, priority=\"project\"):\n+    def setdict(\n+        self, values: _SettingsInputT, priority: Union[int, str] = \"project\"\n+    ) -> None:\n         self.update(values, priority)\n \n-    def setmodule(self, module, priority=\"project\"):\n+    def setmodule(\n+        self, module: Union[ModuleType, str], priority: Union[int, str] = \"project\"\n+    ) -> None:\n         \"\"\"\n         Store settings from a module with a given priority.\n \n@@ -327,7 +383,8 @@ class BaseSettings(MutableMapping):\n             if key.isupper():\n                 self.set(key, getattr(module, key), priority)\n \n-    def update(self, values, priority=\"project\"):\n+    # BaseSettings.update() doesn't support all inputs that MutableMapping.update() supports\n+    def update(self, values: _SettingsInputT, priority: Union[int, str] = \"project\") -> None:  # type: ignore[override]\n         \"\"\"\n         Store key/value pairs with a given priority.\n \n@@ -351,30 +408,34 @@ class BaseSettings(MutableMapping):\n         \"\"\"\n         self._assert_mutability()\n         if isinstance(values, str):\n-            values = json.loads(values)\n+            values = cast(dict, json.loads(values))\n         if values is not None:\n             if isinstance(values, BaseSettings):\n                 for name, value in values.items():\n-                    self.set(name, value, values.getpriority(name))\n+                    self.set(name, value, cast(int, values.getpriority(name)))\n             else:\n                 for name, value in values.items():\n                     self.set(name, value, priority)\n \n-    def delete(self, name, priority=\"project\"):\n+    def delete(\n+        self, name: _SettingsKeyT, priority: Union[int, str] = \"project\"\n+    ) -> None:\n+        if name not in self:\n+            raise KeyError(name)\n         self._assert_mutability()\n         priority = get_settings_priority(priority)\n-        if priority >= self.getpriority(name):\n+        if priority >= cast(int, self.getpriority(name)):\n             del self.attributes[name]\n \n-    def __delitem__(self, name):\n+    def __delitem__(self, name: _SettingsKeyT) -> None:\n         self._assert_mutability()\n         del self.attributes[name]\n \n-    def _assert_mutability(self):\n+    def _assert_mutability(self) -> None:\n         if self.frozen:\n             raise TypeError(\"Trying to modify an immutable Settings object\")\n \n-    def copy(self):\n+    def copy(self) -> \"Self\":\n         \"\"\"\n         Make a deep copy of current settings.\n \n@@ -386,7 +447,7 @@ class BaseSettings(MutableMapping):\n         \"\"\"\n         return copy.deepcopy(self)\n \n-    def freeze(self):\n+    def freeze(self) -> None:\n         \"\"\"\n         Disable further changes to the current settings.\n \n@@ -396,7 +457,7 @@ class BaseSettings(MutableMapping):\n         \"\"\"\n         self.frozen = True\n \n-    def frozencopy(self):\n+    def frozencopy(self) -> \"Self\":\n         \"\"\"\n         Return an immutable copy of the current settings.\n \n@@ -406,26 +467,26 @@ class BaseSettings(MutableMapping):\n         copy.freeze()\n         return copy\n \n-    def __iter__(self):\n+    def __iter__(self) -> Iterator[_SettingsKeyT]:\n         return iter(self.attributes)\n \n-    def __len__(self):\n+    def __len__(self) -> int:\n         return len(self.attributes)\n \n-    def _to_dict(self):\n+    def _to_dict(self) -> Dict[_SettingsKeyT, Any]:\n         return {\n             self._get_key(k): (v._to_dict() if isinstance(v, BaseSettings) else v)\n             for k, v in self.items()\n         }\n \n-    def _get_key(self, key_value):\n+    def _get_key(self, key_value: Any) -> _SettingsKeyT:\n         return (\n             key_value\n             if isinstance(key_value, (bool, float, int, str, type(None)))\n             else str(key_value)\n         )\n \n-    def copy_to_dict(self):\n+    def copy_to_dict(self) -> Dict[_SettingsKeyT, Any]:\n         \"\"\"\n         Make a copy of current settings and convert to a dict.\n \n@@ -441,13 +502,14 @@ class BaseSettings(MutableMapping):\n         settings = self.copy()\n         return settings._to_dict()\n \n-    def _repr_pretty_(self, p, cycle):\n+    # https://ipython.readthedocs.io/en/stable/config/integrating.html#pretty-printing\n+    def _repr_pretty_(self, p: Any, cycle: bool) -> None:\n         if cycle:\n             p.text(repr(self))\n         else:\n             p.text(pformat(self.copy_to_dict()))\n \n-    def pop(self, name, default=__default):\n+    def pop(self, name: _SettingsKeyT, default: Any = __default) -> Any:\n         try:\n             value = self.attributes[name].value\n         except KeyError:\n@@ -471,7 +533,9 @@ class Settings(BaseSettings):\n     described on :ref:`topics-settings-ref` already populated.\n     \"\"\"\n \n-    def __init__(self, values=None, priority=\"project\"):\n+    def __init__(\n+        self, values: _SettingsInputT = None, priority: Union[int, str] = \"project\"\n+    ):\n         # Do not pass kwarg values here. We don't want to promote user-defined\n         # dicts, and we want to update, not replace, default dicts with the\n         # values given by the user\n@@ -485,14 +549,16 @@ class Settings(BaseSettings):\n         self.update(values, priority)\n \n \n-def iter_default_settings():\n+def iter_default_settings() -> Iterable[Tuple[str, Any]]:\n     \"\"\"Return the default settings as an iterator of (name, value) tuples\"\"\"\n     for name in dir(default_settings):\n         if name.isupper():\n             yield name, getattr(default_settings, name)\n \n \n-def overridden_settings(settings):\n+def overridden_settings(\n+    settings: Mapping[_SettingsKeyT, Any]\n+) -> Iterable[Tuple[str, Any]]:\n     \"\"\"Return a dict of the settings that have been overridden\"\"\"\n     for name, defvalue in iter_default_settings():\n         value = settings[name]\n\n@@ -28,6 +28,7 @@ def build_component_list(compdict, custom=None, convert=update_classpath):\n             compbs = BaseSettings()\n             for k, v in compdict.items():\n                 prio = compdict.getpriority(k)\n+                assert prio is not None\n                 if compbs.getpriority(convert(k)) == prio:\n                     raise ValueError(\n                         f\"Some paths in {list(compdict.keys())!r} \"\n\n@@ -1,6 +1,8 @@\n import unittest\n from unittest import mock\n \n+import pytest\n+\n from scrapy.settings import (\n     SETTINGS_PRIORITIES,\n     BaseSettings,\n@@ -199,6 +201,21 @@ class BaseSettingsTest(unittest.TestCase):\n         settings.update({\"key_lowprio\": 3}, priority=20)\n         self.assertEqual(settings[\"key_lowprio\"], 1)\n \n+    @pytest.mark.xfail(\n+        raises=TypeError, reason=\"BaseSettings.update doesn't support kwargs input\"\n+    )\n+    def test_update_kwargs(self):\n+        settings = BaseSettings({\"key\": 0})\n+        settings.update(key=1)\n+\n+    @pytest.mark.xfail(\n+        raises=AttributeError,\n+        reason=\"BaseSettings.update doesn't support iterable input\",\n+    )\n+    def test_update_iterable(self):\n+        settings = BaseSettings({\"key\": 0})\n+        settings.update([(\"key\", 1)])\n+\n     def test_update_jsonstring(self):\n         settings = BaseSettings({\"number\": 0, \"dict\": BaseSettings({\"key\": \"val\"})})\n         settings.update('{\"number\": 1, \"newnumber\": 2}')\n@@ -217,6 +234,10 @@ class BaseSettingsTest(unittest.TestCase):\n         self.assertIn(\"key_highprio\", settings)\n         del settings[\"key_highprio\"]\n         self.assertNotIn(\"key_highprio\", settings)\n+        with self.assertRaises(KeyError):\n+            settings.delete(\"notkey\")\n+        with self.assertRaises(KeyError):\n+            del settings[\"notkey\"]\n \n     def test_get(self):\n         test_configuration = {\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
