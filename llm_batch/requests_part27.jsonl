{"custom_id": "requests#69e7e94c4ce349b243d8dde82a69166d8792ab81", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 31 | Lines Deleted: 17 | Files Changed: 11 | Hunks: 20 | Methods Changed: 8 | Complexity Δ (Sum/Max): -109/1 | Churn Δ: 48 | Churn Cumulative: 3504 | Contributors (this commit): 1 | Commits (past 90d): 62 | Contributors (cumulative): 11 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,3 +1,3 @@\n from __future__ import absolute_import\n \n-from . import poster\n+from . import urllib3\n\n@@ -10,7 +10,7 @@ urllib3 - Thread-safe connection pooling and re-using.\n \n __author__ = 'Andrey Petrov (andrey.petrov@shazow.net)'\n __license__ = 'MIT'\n-__version__ = '1.0.1'\n+__version__ = '1.0.2'\n \n \n from .connectionpool import (\n\n@@ -4,8 +4,9 @@\n # This module is part of urllib3 and is released under\n # the MIT License: http://www.opensource.org/licenses/mit-license.php\n \n-from collections import MutableMapping, deque\n+from collections import deque, MutableMapping\n \n+from threading import RLock\n \n __all__ = ['RecentlyUsedContainer']\n \n@@ -24,9 +25,6 @@ class RecentlyUsedContainer(MutableMapping):\n     away the least-recently-used keys beyond ``maxsize``.\n     \"\"\"\n \n-    # TODO: Make this threadsafe. _prune_invalidated_entries should be the\n-    # only real pain-point for this.\n-\n     # If len(self.access_log) exceeds self._maxsize * CLEANUP_FACTOR, then we\n     # will attempt to cleanup the invalidated entries in the access_log\n     # datastructure during the next 'get' operation.\n@@ -39,6 +37,7 @@ class RecentlyUsedContainer(MutableMapping):\n \n         # We use a deque to to store our keys ordered by the last access.\n         self.access_log = deque()\n+        self.access_log_lock = RLock()\n \n         # We look up the access log entry by the key to invalidate it so we can\n         # insert a new authorative entry at the head without having to dig and\n@@ -48,43 +47,58 @@ class RecentlyUsedContainer(MutableMapping):\n         # Trigger a heap cleanup when we get past this size\n         self.access_log_limit = maxsize * self.CLEANUP_FACTOR\n \n-    def _push_entry(self, key):\n-        \"Push entry onto our access log, invalidate the old entry if exists.\"\n-        # Invalidate old entry if it exists\n+    def _invalidate_entry(self, key):\n+        \"If exists: Invalidate old entry and return it.\"\n         old_entry = self.access_lookup.get(key)\n         if old_entry:\n             old_entry.is_valid = False\n \n-        new_entry = AccessEntry(key)\n+        return old_entry\n \n+    def _push_entry(self, key):\n+        \"Push entry onto our access log, invalidate the old entry if exists.\"\n+        self._invalidate_entry(key)\n+\n+        new_entry = AccessEntry(key)\n         self.access_lookup[key] = new_entry\n+\n+        self.access_log_lock.acquire()\n         self.access_log.appendleft(new_entry)\n+        self.access_log_lock.release()\n \n     def _prune_entries(self, num):\n         \"Pop entries from our access log until we popped ``num`` valid ones.\"\n         while num > 0:\n+            self.access_log_lock.acquire()\n             p = self.access_log.pop()\n+            self.access_log_lock.release()\n \n             if not p.is_valid:\n                 continue # Invalidated entry, skip\n \n-            del self._container[p.key]\n-            del self.access_lookup[p.key]\n+            self._container.pop(p.key, None)\n+            self.access_lookup.pop(p.key, None)\n             num -= 1\n \n     def _prune_invalidated_entries(self):\n         \"Rebuild our access_log without the invalidated entries.\"\n+        self.access_log_lock.acquire()\n         self.access_log = deque(e for e in self.access_log if e.is_valid)\n+        self.access_log_lock.release()\n \n     def _get_ordered_access_keys(self):\n-        # Used for testing\n-        return [e.key for e in self.access_log if e.is_valid]\n+        \"Return ordered access keys for inspection. Used for testing.\"\n+        self.access_log_lock.acquire()\n+        r = [e.key for e in self.access_log if e.is_valid]\n+        self.access_log_lock.release()\n+\n+        return r\n \n     def __getitem__(self, key):\n         item = self._container.get(key)\n \n         if not item:\n-            return\n+            raise KeyError(key)\n \n         # Insert new entry with new high priority, also implicitly invalidates\n         # the old entry.\n@@ -108,7 +122,7 @@ class RecentlyUsedContainer(MutableMapping):\n     def __delitem__(self, key):\n         self._invalidate_entry(key)\n         del self._container[key]\n-        del self._access_lookup[key]\n+        del self.access_lookup[key]\n \n     def __len__(self):\n         return self._container.__len__()\n\n\n\n\n\n\n@@ -108,7 +108,7 @@ class PoolManager(RequestMethods):\n         return conn.urlopen(method, url, assert_same_host=False, **kw)\n \n \n-class ProxyManager(object):\n+class ProxyManager(RequestMethods):\n     \"\"\"\n     Given a ConnectionPool to a proxy, the ProxyManager's ``urlopen`` method\n     will make requests to any url through the defined proxy.\n\n\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#50279dd83c378e2de73695db9ebe06a2ba079a1f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 130 | Contributors (this commit): 1 | Commits (past 90d): 12 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -33,7 +33,6 @@ defaults['base_headers'] = {\n }\n \n defaults['verbose'] = None\n-defaults['timeout'] = None\n defaults['max_redirects'] = 30\n defaults['decode_unicode'] = True\n defaults['keep_alive'] = True\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#7c206c74ba270bdfa2e748c33e4c6c89deea517b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 4 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 10 | Churn Cumulative: 3699 | Contributors (this commit): 21 | Commits (past 90d): 136 | Contributors (cumulative): 21 | DMM Complexity: 0.0\n\nDIFF:\n@@ -20,6 +20,8 @@ from .hooks import dispatch_hook\n from .structures import CaseInsensitiveDict\n from .status_codes import codes\n from .packages.urllib3.exceptions import MaxRetryError\n+from .packages.urllib3.exceptions import SSLError as _SSLError\n+from .packages.urllib3.exceptions import HTTPError as _HTTPError\n from .packages.urllib3 import connectionpool, poolmanager\n from .exceptions import (\n     Timeout, URLRequired, TooManyRedirects, HTTPError, ConnectionError)\n@@ -405,15 +407,21 @@ class Request(object):\n                     assert_same_host=False,\n                     preload_content=prefetch,\n                     decode_content=False,\n-                    retries=self.config.get('max_retries', 0)\n+                    retries=self.config.get('max_retries', 0),\n+                    timeout=self.timeout,\n                 )\n \n+\n             except MaxRetryError, e:\n                 if not self.config.get('safe_mode', False):\n                     raise ConnectionError(e)\n                 else:\n                     r = None\n \n+            except (_SSLError, _HTTPError), e:\n+                if not self.config.get('safe_mode', False):\n+                    raise Timeout('Request timed out.')\n+\n             self._build_response(r)\n \n             # Response manipulation hook.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#df2c80e28eb2ed0dbc1a9f86ae65fb5e756936ce", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 1404 | Contributors (this commit): 15 | Commits (past 90d): 33 | Contributors (cumulative): 15 | DMM Complexity: None\n\nDIFF:\n@@ -306,7 +306,7 @@ class RequestsTestSuite(unittest.TestCase):\n             rbody = json.loads(r.content)\n             # Body wasn't valid url encoded data, so the server returns None as\n             # \"form\" and the raw body as \"data\".\n-            self.assertEquals(rbody.get('form'), None)\n+            self.assertAlmostEquals(rbody.get('form'), {})\n             self.assertEquals(rbody.get('data'), 'fooaowpeuf')\n \n \n@@ -354,7 +354,7 @@ class RequestsTestSuite(unittest.TestCase):\n \n             rbody = json.loads(r.content)\n \n-            self.assertEquals(rbody.get('form'), None)\n+            self.assertEquals(rbody.get('form'), {})\n             self.assertEquals(rbody.get('data'), 'foobar')\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#02408973c6da4bd89401d2a1994b4ea26dc260c9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 13 | Lines Deleted: 11 | Files Changed: 2 | Hunks: 10 | Methods Changed: 9 | Complexity Δ (Sum/Max): 5/5 | Churn Δ: 24 | Churn Cumulative: 816 | Contributors (this commit): 4 | Commits (past 90d): 55 | Contributors (cumulative): 5 | DMM Complexity: 0.0\n\nDIFF:\n@@ -35,8 +35,8 @@ defaults['base_headers'] = {\n defaults['verbose'] = None\n defaults['max_redirects'] = 30\n defaults['decode_unicode'] = True\n-defaults['keep_alive'] = True\n defaults['pool_connections'] = 10\n-defaults['pool_maxsize'] = 1\n+defaults['pool_maxsize'] = 10\n defaults['max_retries'] = 0\n defaults['safe_mode'] = False\n+defaults['keep_alive'] = True\n\n@@ -63,8 +63,7 @@ class Session(object):\n         proxies=None,\n         hooks=None,\n         params=None,\n-        config=None,\n-        keep_alive=True):\n+        config=None):\n \n         self.headers = headers or {}\n         self.cookies = cookies or {}\n@@ -74,7 +73,6 @@ class Session(object):\n         self.hooks = hooks or {}\n         self.params = params or {}\n         self.config = config or {}\n-        self.keep_alive = keep_alive\n \n         for (k, v) in defaults.items():\n             self.config.setdefault(k, v)\n@@ -136,8 +134,12 @@ class Session(object):\n \n         method = str(method).upper()\n \n-        if cookies is None:\n-            cookies = {}\n+        # Default empty dicts for dict params.\n+        cookies = {} if cookies is None else cookies\n+        data = {} if data is None else data\n+        files = {} if files is None else files\n+        headers = {} if headers is None else headers\n+        params = {} if params is None else params\n \n         # Expand header values\n         if headers:\n@@ -221,7 +223,7 @@ class Session(object):\n         return self.request('HEAD', url, **kwargs)\n \n \n-    def post(self, url, data='', **kwargs):\n+    def post(self, url, data=None, **kwargs):\n         \"\"\"Sends a POST request. Returns :class:`Response` object.\n \n         :param url: URL for the new :class:`Request` object.\n@@ -232,7 +234,7 @@ class Session(object):\n         return self.request('post', url, data=data, **kwargs)\n \n \n-    def put(self, url, data='', **kwargs):\n+    def put(self, url, data=None, **kwargs):\n         \"\"\"Sends a PUT request. Returns :class:`Response` object.\n \n         :param url: URL for the new :class:`Request` object.\n@@ -243,7 +245,7 @@ class Session(object):\n         return self.request('put', url, data=data, **kwargs)\n \n \n-    def patch(self, url, data='', **kwargs):\n+    def patch(self, url, data=None, **kwargs):\n         \"\"\"Sends a PATCH request. Returns :class:`Response` object.\n \n         :param url: URL for the new :class:`Request` object.\n@@ -251,7 +253,7 @@ class Session(object):\n         :param **kwargs: Optional arguments that ``request`` takes.\n         \"\"\"\n \n-        return self.request('patch', url,  data='', **kwargs)\n+        return self.request('patch', url,  data=data, **kwargs)\n \n \n     def delete(self, url, **kwargs):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#58e3dd9de85c98214b8838e133881fc263e5a3ac", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 54/54 | Churn Δ: 2 | Churn Cumulative: 1643 | Contributors (this commit): 1 | Commits (past 90d): 14 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -338,7 +338,7 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n \n         except (SocketTimeout, Empty), e:\n             # Timed out either by socket or queue\n-            raise TimeoutError(\"Request timed out after %f seconds\" %\n+            raise TimeoutError(\"Request timed out after %s seconds\" %\n                                self.timeout)\n \n         except (BaseSSLError), e:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c0d8e8e8467a337f7ad0a10206b64087d8eef14a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 8 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 6 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 10 | Churn Cumulative: 3709 | Contributors (this commit): 21 | Commits (past 90d): 136 | Contributors (cumulative): 21 | DMM Complexity: 0.0\n\nDIFF:\n@@ -23,6 +23,7 @@ from .packages.urllib3.exceptions import MaxRetryError\n from .packages.urllib3.exceptions import SSLError as _SSLError\n from .packages.urllib3.exceptions import HTTPError as _HTTPError\n from .packages.urllib3 import connectionpool, poolmanager\n+from .packages.urllib3.filepost import encode_multipart_formdata\n from .exceptions import (\n     Timeout, URLRequired, TooManyRedirects, HTTPError, ConnectionError)\n from .utils import (\n@@ -30,6 +31,8 @@ from .utils import (\n     stream_decode_response_unicode, decode_gzip, stream_decode_gzip)\n \n \n+\n+\n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n \n \n@@ -330,8 +333,6 @@ class Request(object):\n         body = None\n         content_type = None\n \n-        from .packages.urllib3.filepost import encode_multipart_formdata\n-\n         # Multi-part file uploads.\n         if self.files:\n             if not isinstance(self.data, basestring):\n@@ -349,7 +350,11 @@ class Request(object):\n                 # TODO: Conflict?\n         else:\n             if self.data:\n+\n                 body = self._enc_data\n+                if isinstance(self.data, basestring):\n+                    content_type = None\n+                else:\n                     content_type = 'application/x-www-form-urlencoded'\n \n         # Add content-type if it wasn't explicitly provided.\n@@ -398,6 +403,7 @@ class Request(object):\n \n             try:\n                 # Send the request.\n+\n                 r = conn.urlopen(\n                     method=self.method,\n                     url=url,\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c05c64d21bd5144079b8dcfc85cf6ae5de115058", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 3 | Methods Changed: 6 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 6 | Churn Cumulative: 906 | Contributors (this commit): 11 | Commits (past 90d): 46 | Contributors (cumulative): 11 | DMM Complexity: None\n\nDIFF:\n@@ -90,7 +90,7 @@ def head(url, **kwargs):\n     return request('HEAD', url, **kwargs)\n \n \n-def post(url, data='', **kwargs):\n+def post(url, data=None, **kwargs):\n     \"\"\"Sends a POST request. Returns :class:`Response` object.\n \n     :param url: URL for the new :class:`Request` object.\n@@ -101,7 +101,7 @@ def post(url, data='', **kwargs):\n     return request('post', url, data=data, **kwargs)\n \n \n-def put(url, data='', **kwargs):\n+def put(url, data=None, **kwargs):\n     \"\"\"Sends a PUT request. Returns :class:`Response` object.\n \n     :param url: URL for the new :class:`Request` object.\n@@ -112,7 +112,7 @@ def put(url, data='', **kwargs):\n     return request('put', url, data=data, **kwargs)\n \n \n-def patch(url, data='', **kwargs):\n+def patch(url, data=None, **kwargs):\n     \"\"\"Sends a PATCH request. Returns :class:`Response` object.\n \n     :param url: URL for the new :class:`Request` object.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f1e8700e9a6bdb8aaa3e4f86414b7ceeb729063c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 7 | Files Changed: 2 | Hunks: 7 | Methods Changed: 7 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 14 | Churn Cumulative: 1602 | Contributors (this commit): 12 | Commits (past 90d): 90 | Contributors (cumulative): 15 | DMM Complexity: None\n\nDIFF:\n@@ -65,7 +65,7 @@ def get(url, **kwargs):\n     \"\"\"\n \n     kwargs.setdefault('allow_redirects', True)\n-    return request('GET', url, **kwargs)\n+    return request('get', url, **kwargs)\n \n \n def options(url, **kwargs):\n@@ -76,7 +76,7 @@ def options(url, **kwargs):\n     \"\"\"\n \n     kwargs.setdefault('allow_redirects', True)\n-    return request('OPTIONS', url, **kwargs)\n+    return request('options', url, **kwargs)\n \n \n def head(url, **kwargs):\n@@ -87,7 +87,7 @@ def head(url, **kwargs):\n     \"\"\"\n \n     kwargs.setdefault('allow_redirects', True)\n-    return request('HEAD', url, **kwargs)\n+    return request('head', url, **kwargs)\n \n \n def post(url, data=None, **kwargs):\n\n@@ -141,7 +141,7 @@ class Session(object):\n         headers = {} if headers is None else headers\n         params = {} if params is None else params\n \n-        # Expand header values\n+        # Expand header values.\n         if headers:\n             for k, v in headers.items() or {}:\n                 headers[k] = header_expand(v)\n@@ -198,7 +198,7 @@ class Session(object):\n         \"\"\"\n \n         kwargs.setdefault('allow_redirects', True)\n-        return self.request('GET', url, **kwargs)\n+        return self.request('get', url, **kwargs)\n \n \n     def options(self, url, **kwargs):\n@@ -209,7 +209,7 @@ class Session(object):\n         \"\"\"\n \n         kwargs.setdefault('allow_redirects', True)\n-        return self.request('OPTIONS', url, **kwargs)\n+        return self.request('options', url, **kwargs)\n \n \n     def head(self, url, **kwargs):\n@@ -220,7 +220,7 @@ class Session(object):\n         \"\"\"\n \n         kwargs.setdefault('allow_redirects', True)\n-        return self.request('HEAD', url, **kwargs)\n+        return self.request('head', url, **kwargs)\n \n \n     def post(self, url, data=None, **kwargs):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#474e17b0af27b397e6abcb7eca3353775993426c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 3 | Churn Cumulative: 1305 | Contributors (this commit): 14 | Commits (past 90d): 65 | Contributors (cumulative): 16 | DMM Complexity: None\n\nDIFF:\n@@ -13,8 +13,6 @@ This module implements the Requests API.\n \n from .sessions import session\n \n-__all__ = ('request', 'get', 'options', 'head', 'post', 'patch', 'put', 'delete')\n-\n \n def request(method, url,\n     params=None,\n\n@@ -20,7 +20,6 @@ except ImportError:\n curious_george.patch_all(thread=False)\n \n from . import api\n-from .hooks import dispatch_hook\n \n \n __all__ = (\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#6a23625c1150cfc46c1a73d9c2472a2d2aa3fc60", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 7 | Churn Cumulative: 4406 | Contributors (this commit): 22 | Commits (past 90d): 181 | Contributors (cumulative): 25 | DMM Complexity: 0.0\n\nDIFF:\n@@ -14,7 +14,6 @@ from Cookie import SimpleCookie\n from urlparse import urlparse, urlunparse, urljoin\n from datetime import datetime\n \n-\n from .auth import dispatch as auth_dispatch\n from .hooks import dispatch_hook\n from .structures import CaseInsensitiveDict\n@@ -117,6 +116,9 @@ class Request(object):\n         #: Event-handling hooks.\n         self.hooks = hooks\n \n+        #: Session.\n+        self.session = None\n+\n         if headers:\n             headers = CaseInsensitiveDict(self.headers)\n         else:\n@@ -234,7 +236,7 @@ class Request(object):\n                     headers=headers,\n                     files=self.files,\n                     method=method,\n-                    # params=self.params,\n+                    params=self.session.params,\n                     auth=self._auth,\n                     cookies=cookies,\n                     redirect=True,\n\n@@ -175,6 +175,7 @@ class Session(object):\n \n         # Create the (empty) response.\n         r = Request(**args)\n+        r.session = self\n \n         # Don't send if asked nicely.\n         if not return_response:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#3fccf63f491b53a443b6fb187da5db48ec33203d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 695 | Contributors (this commit): 4 | Commits (past 90d): 45 | Contributors (cumulative): 4 | DMM Complexity: None\n\nDIFF:\n@@ -163,18 +163,20 @@ class Session(object):\n             _poolmanager=self.poolmanager\n         )\n \n+        # Merge local kwargs with session kwargs.\n         for attr in self.__attrs__:\n             session_val = getattr(self, attr, None)\n             local_val = args.get(attr)\n \n             args[attr] = merge_kwargs(local_val, session_val)\n \n-\n         # Arguments manipulation hook.\n         args = dispatch_hook('args', args['hooks'], args)\n \n         # Create the (empty) response.\n         r = Request(**args)\n+\n+        # Give the response some context.\n         r.session = self\n \n         # Don't send if asked nicely.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#7ee2b7912707796e0abf0cd3201434198c800642", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 214 | Contributors (this commit): 3 | Commits (past 90d): 19 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -31,3 +31,8 @@ from .exceptions import (\n     RequestException, Timeout, URLRequired,\n     TooManyRedirects, HTTPError, ConnectionError\n )\n+\n+try:\n+    from . import async\n+except RuntimeError:\n+    pass\n\\ No newline at end of file\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#6730818ddcfc5edcdf6aaebb17ca689f3ea39db6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 18 | Churn Cumulative: 932 | Contributors (this commit): 11 | Commits (past 90d): 49 | Contributors (cumulative): 11 | DMM Complexity: 1.0\n\nDIFF:\n@@ -48,9 +48,21 @@ def request(method, url,\n \n     s = session()\n     return s.request(\n-        method, url, params, data, headers, cookies, files, auth,\n-        timeout, allow_redirects, proxies, hooks, return_response,\n-        config, prefetch\n+        method=method,\n+        url=url,\n+        params=params,\n+        data=data,\n+        headers=headers,\n+        cookies=cookies,\n+        files=files,\n+        auth=auth,\n+        timeout=timeout,\n+        allow_redirects=allow_redirects,\n+        proxies=proxies,\n+        hooks=hooks,\n+        return_response=return_response,\n+        config=config,\n+        prefetch=prefetch\n     )\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#cfc1a76381ac3b728456f0d02a81acf38cfca4db", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 5 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 219 | Contributors (this commit): 3 | Commits (past 90d): 20 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -31,8 +31,3 @@ from .exceptions import (\n     RequestException, Timeout, URLRequired,\n     TooManyRedirects, HTTPError, ConnectionError\n )\n-\n-try:\n-    from . import async\n-except RuntimeError:\n-    pass\n\\ No newline at end of file\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e84d84b5b8660efa66feb66564683628944505bb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 3 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 290 | Contributors (this commit): 1 | Commits (past 90d): 6 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -4,10 +4,12 @@\n # This module is part of urllib3 and is released under\n # the MIT License: http://www.opensource.org/licenses/mit-license.php\n \n-from collections import deque, MutableMapping\n \n+from collections import deque\n from threading import RLock\n \n+from .__collections import MutableMapping\n+\n __all__ = ['RecentlyUsedContainer']\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#ec926a49580619a03c36f58f02df0874fbf9303b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 3 | Files Changed: 3 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 2985 | Contributors (this commit): 19 | Commits (past 90d): 83 | Contributors (cumulative): 23 | DMM Complexity: None\n\nDIFF:\n@@ -269,7 +269,6 @@ class Session(object):\n         return self.request('delete', url, **kwargs)\n \n \n-\n def session(**kwargs):\n     \"\"\"Returns a :class:`Session` for context-management.\"\"\"\n \n\n@@ -8,6 +8,7 @@ Data structures that power Requests.\n \n \"\"\"\n \n+\n class CaseInsensitiveDict(dict):\n     \"\"\"Case-insensitive Dictionary\n \n\n@@ -306,7 +306,7 @@ class RequestsTestSuite(unittest.TestCase):\n             rbody = json.loads(r.content)\n             # Body wasn't valid url encoded data, so the server returns None as\n             # \"form\" and the raw body as \"data\".\n-            self.assertAlmostEquals(rbody.get('form'), {})\n+            self.assertEquals(rbody.get('form'), {})\n             self.assertEquals(rbody.get('data'), 'fooaowpeuf')\n \n \n@@ -538,7 +538,6 @@ class RequestsTestSuite(unittest.TestCase):\n         assert params3['c'] in r3.content\n \n     def test_invalid_content(self):\n-\n         # WARNING: if you're using a terrible DNS provider (comcast),\n         # this will fail.\n         try:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#0a4b7356ac039ffc0eed3086ced33d5f6b54dbba", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 991 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 94 | Complexity Δ (Sum/Max): 292/292 | Churn Δ: 991 | Churn Cumulative: 991 | Contributors (this commit): 1 | Commits (past 90d): 1 | Contributors (cumulative): 1 | DMM Complexity: 0.8452380952380952\n\nDIFF:\n@@ -0,0 +1,991 @@\n+from __future__ import with_statement\n+\n+\n+# Copyright 2007 Google, Inc. All Rights Reserved.\n+# Licensed to PSF under a Contributor Agreement.\n+\n+\"\"\"Abstract Base Classes (ABCs) according to PEP 3119.\"\"\"\n+\n+import types\n+\n+from _weakref import ref\n+\n+__all__ = ['WeakSet']\n+\n+\n+class _IterationGuard(object):\n+    # This context manager registers itself in the current iterators of the\n+    # weak container, such as to delay all removals until the context manager\n+    # exits.\n+    # This technique should be relatively thread-safe (since sets are).\n+\n+    def __init__(self, weakcontainer):\n+        # Don't create cycles\n+        self.weakcontainer = ref(weakcontainer)\n+\n+    def __enter__(self):\n+        w = self.weakcontainer()\n+        if w is not None:\n+            w._iterating.add(self)\n+        return self\n+\n+    def __exit__(self, e, t, b):\n+        w = self.weakcontainer()\n+        if w is not None:\n+            s = w._iterating\n+            s.remove(self)\n+            if not s:\n+                w._commit_removals()\n+\n+\n+class WeakSet(object):\n+    def __init__(self, data=None):\n+        self.data = set()\n+        def _remove(item, selfref=ref(self)):\n+            self = selfref()\n+            if self is not None:\n+                if self._iterating:\n+                    self._pending_removals.append(item)\n+                else:\n+                    self.data.discard(item)\n+        self._remove = _remove\n+        # A list of keys to be removed\n+        self._pending_removals = []\n+        self._iterating = set()\n+        if data is not None:\n+            self.update(data)\n+\n+    def _commit_removals(self):\n+        l = self._pending_removals\n+        discard = self.data.discard\n+        while l:\n+            discard(l.pop())\n+\n+    def __iter__(self):\n+        with _IterationGuard(self):\n+            for itemref in self.data:\n+                item = itemref()\n+                if item is not None:\n+                    yield item\n+\n+    def __len__(self):\n+        return sum(x() is not None for x in self.data)\n+\n+    def __contains__(self, item):\n+        try:\n+            wr = ref(item)\n+        except TypeError:\n+            return False\n+        return wr in self.data\n+\n+    def __reduce__(self):\n+        return (self.__class__, (list(self),),\n+                getattr(self, '__dict__', None))\n+\n+    __hash__ = None\n+\n+    def add(self, item):\n+        if self._pending_removals:\n+            self._commit_removals()\n+        self.data.add(ref(item, self._remove))\n+\n+    def clear(self):\n+        if self._pending_removals:\n+            self._commit_removals()\n+        self.data.clear()\n+\n+    def copy(self):\n+        return self.__class__(self)\n+\n+    def pop(self):\n+        if self._pending_removals:\n+            self._commit_removals()\n+        while True:\n+            try:\n+                itemref = self.data.pop()\n+            except KeyError:\n+                raise KeyError('pop from empty WeakSet')\n+            item = itemref()\n+            if item is not None:\n+                return item\n+\n+    def remove(self, item):\n+        if self._pending_removals:\n+            self._commit_removals()\n+        self.data.remove(ref(item))\n+\n+    def discard(self, item):\n+        if self._pending_removals:\n+            self._commit_removals()\n+        self.data.discard(ref(item))\n+\n+    def update(self, other):\n+        if self._pending_removals:\n+            self._commit_removals()\n+        if isinstance(other, self.__class__):\n+            self.data.update(other.data)\n+        else:\n+            for element in other:\n+                self.add(element)\n+\n+    def __ior__(self, other):\n+        self.update(other)\n+        return self\n+\n+    # Helper functions for simple delegating methods.\n+    def _apply(self, other, method):\n+        if not isinstance(other, self.__class__):\n+            other = self.__class__(other)\n+        newdata = method(other.data)\n+        newset = self.__class__()\n+        newset.data = newdata\n+        return newset\n+\n+    def difference(self, other):\n+        return self._apply(other, self.data.difference)\n+    __sub__ = difference\n+\n+    def difference_update(self, other):\n+        if self._pending_removals:\n+            self._commit_removals()\n+        if self is other:\n+            self.data.clear()\n+        else:\n+            self.data.difference_update(ref(item) for item in other)\n+    def __isub__(self, other):\n+        if self._pending_removals:\n+            self._commit_removals()\n+        if self is other:\n+            self.data.clear()\n+        else:\n+            self.data.difference_update(ref(item) for item in other)\n+        return self\n+\n+    def intersection(self, other):\n+        return self._apply(other, self.data.intersection)\n+    __and__ = intersection\n+\n+    def intersection_update(self, other):\n+        if self._pending_removals:\n+            self._commit_removals()\n+        self.data.intersection_update(ref(item) for item in other)\n+    def __iand__(self, other):\n+        if self._pending_removals:\n+            self._commit_removals()\n+        self.data.intersection_update(ref(item) for item in other)\n+        return self\n+\n+    def issubset(self, other):\n+        return self.data.issubset(ref(item) for item in other)\n+    __lt__ = issubset\n+\n+    def __le__(self, other):\n+        return self.data <= set(ref(item) for item in other)\n+\n+    def issuperset(self, other):\n+        return self.data.issuperset(ref(item) for item in other)\n+    __gt__ = issuperset\n+\n+    def __ge__(self, other):\n+        return self.data >= set(ref(item) for item in other)\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return NotImplemented\n+        return self.data == set(ref(item) for item in other)\n+\n+    def symmetric_difference(self, other):\n+        return self._apply(other, self.data.symmetric_difference)\n+    __xor__ = symmetric_difference\n+\n+    def symmetric_difference_update(self, other):\n+        if self._pending_removals:\n+            self._commit_removals()\n+        if self is other:\n+            self.data.clear()\n+        else:\n+            self.data.symmetric_difference_update(ref(item) for item in other)\n+    def __ixor__(self, other):\n+        if self._pending_removals:\n+            self._commit_removals()\n+        if self is other:\n+            self.data.clear()\n+        else:\n+            self.data.symmetric_difference_update(ref(item) for item in other)\n+        return self\n+\n+    def union(self, other):\n+        return self._apply(other, self.data.union)\n+    __or__ = union\n+\n+    def isdisjoint(self, other):\n+        return len(self.intersection(other)) == 0\n+\n+\n+# Instance of old-style class\n+class _C: pass\n+_InstanceType = type(_C())\n+\n+\n+def abstractmethod(funcobj):\n+    \"\"\"A decorator indicating abstract methods.\n+\n+    Requires that the metaclass is ABCMeta or derived from it.  A\n+    class that has a metaclass derived from ABCMeta cannot be\n+    instantiated unless all of its abstract methods are overridden.\n+    The abstract methods can be called using any of the normal\n+    'super' call mechanisms.\n+\n+    Usage:\n+\n+        class C:\n+            __metaclass__ = ABCMeta\n+            @abstractmethod\n+            def my_abstract_method(self, ...):\n+                ...\n+    \"\"\"\n+    funcobj.__isabstractmethod__ = True\n+    return funcobj\n+\n+\n+class abstractproperty(property):\n+    \"\"\"A decorator indicating abstract properties.\n+\n+    Requires that the metaclass is ABCMeta or derived from it.  A\n+    class that has a metaclass derived from ABCMeta cannot be\n+    instantiated unless all of its abstract properties are overridden.\n+    The abstract properties can be called using any of the normal\n+    'super' call mechanisms.\n+\n+    Usage:\n+\n+        class C:\n+            __metaclass__ = ABCMeta\n+            @abstractproperty\n+            def my_abstract_property(self):\n+                ...\n+\n+    This defines a read-only property; you can also define a read-write\n+    abstract property using the 'long' form of property declaration:\n+\n+        class C:\n+            __metaclass__ = ABCMeta\n+            def getx(self): ...\n+            def setx(self, value): ...\n+            x = abstractproperty(getx, setx)\n+    \"\"\"\n+    __isabstractmethod__ = True\n+\n+\n+class ABCMeta(type):\n+\n+    \"\"\"Metaclass for defining Abstract Base Classes (ABCs).\n+\n+    Use this metaclass to create an ABC.  An ABC can be subclassed\n+    directly, and then acts as a mix-in class.  You can also register\n+    unrelated concrete classes (even built-in classes) and unrelated\n+    ABCs as 'virtual subclasses' -- these and their descendants will\n+    be considered subclasses of the registering ABC by the built-in\n+    issubclass() function, but the registering ABC won't show up in\n+    their MRO (Method Resolution Order) nor will method\n+    implementations defined by the registering ABC be callable (not\n+    even via super()).\n+\n+    \"\"\"\n+\n+    # A global counter that is incremented each time a class is\n+    # registered as a virtual subclass of anything.  It forces the\n+    # negative cache to be cleared before its next use.\n+    _abc_invalidation_counter = 0\n+\n+    def __new__(mcls, name, bases, namespace):\n+        cls = super(ABCMeta, mcls).__new__(mcls, name, bases, namespace)\n+        # Compute set of abstract method names\n+        abstracts = set(name\n+                     for name, value in namespace.items()\n+                     if getattr(value, \"__isabstractmethod__\", False))\n+        for base in bases:\n+            for name in getattr(base, \"__abstractmethods__\", set()):\n+                value = getattr(cls, name, None)\n+                if getattr(value, \"__isabstractmethod__\", False):\n+                    abstracts.add(name)\n+        cls.__abstractmethods__ = frozenset(abstracts)\n+        # Set up inheritance registry\n+        cls._abc_registry = WeakSet()\n+        cls._abc_cache = WeakSet()\n+        cls._abc_negative_cache = WeakSet()\n+        cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter\n+        return cls\n+\n+    def register(cls, subclass):\n+        \"\"\"Register a virtual subclass of an ABC.\"\"\"\n+        if not isinstance(subclass, (type, types.ClassType)):\n+            raise TypeError(\"Can only register classes\")\n+        if issubclass(subclass, cls):\n+            return  # Already a subclass\n+        # Subtle: test for cycles *after* testing for \"already a subclass\";\n+        # this means we allow X.register(X) and interpret it as a no-op.\n+        if issubclass(cls, subclass):\n+            # This would create a cycle, which is bad for the algorithm below\n+            raise RuntimeError(\"Refusing to create an inheritance cycle\")\n+        cls._abc_registry.add(subclass)\n+        ABCMeta._abc_invalidation_counter += 1  # Invalidate negative cache\n+\n+    def _dump_registry(cls, file=None):\n+        \"\"\"Debug helper to print the ABC registry.\"\"\"\n+        print >> file, \"Class: %s.%s\" % (cls.__module__, cls.__name__)\n+        print >> file, \"Inv.counter: %s\" % ABCMeta._abc_invalidation_counter\n+        for name in sorted(cls.__dict__.keys()):\n+            if name.startswith(\"_abc_\"):\n+                value = getattr(cls, name)\n+                print >> file, \"%s: %r\" % (name, value)\n+\n+    def __instancecheck__(cls, instance):\n+        \"\"\"Override for isinstance(instance, cls).\"\"\"\n+        # Inline the cache checking when it's simple.\n+        subclass = getattr(instance, '__class__', None)\n+        if subclass is not None and subclass in cls._abc_cache:\n+            return True\n+        subtype = type(instance)\n+        # Old-style instances\n+        if subtype is _InstanceType:\n+            subtype = subclass\n+        if subtype is subclass or subclass is None:\n+            if (cls._abc_negative_cache_version ==\n+                ABCMeta._abc_invalidation_counter and\n+                subtype in cls._abc_negative_cache):\n+                return False\n+            # Fall back to the subclass check.\n+            return cls.__subclasscheck__(subtype)\n+        return (cls.__subclasscheck__(subclass) or\n+                cls.__subclasscheck__(subtype))\n+\n+    def __subclasscheck__(cls, subclass):\n+        \"\"\"Override for issubclass(subclass, cls).\"\"\"\n+        # Check cache\n+        if subclass in cls._abc_cache:\n+            return True\n+        # Check negative cache; may have to invalidate\n+        if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:\n+            # Invalidate the negative cache\n+            cls._abc_negative_cache = WeakSet()\n+            cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter\n+        elif subclass in cls._abc_negative_cache:\n+            return False\n+        # Check the subclass hook\n+        ok = cls.__subclasshook__(subclass)\n+        if ok is not NotImplemented:\n+            assert isinstance(ok, bool)\n+            if ok:\n+                cls._abc_cache.add(subclass)\n+            else:\n+                cls._abc_negative_cache.add(subclass)\n+            return ok\n+        # Check if it's a direct subclass\n+        if cls in getattr(subclass, '__mro__', ()):\n+            cls._abc_cache.add(subclass)\n+            return True\n+        # Check if it's a subclass of a registered class (recursive)\n+        for rcls in cls._abc_registry:\n+            if issubclass(subclass, rcls):\n+                cls._abc_cache.add(subclass)\n+                return True\n+        # Check if it's a subclass of a subclass (recursive)\n+        for scls in cls.__subclasses__():\n+            if issubclass(subclass, scls):\n+                cls._abc_cache.add(subclass)\n+                return True\n+        # No dice; update negative cache\n+        cls._abc_negative_cache.add(subclass)\n+        return False\n+\n+\n+\n+\n+\n+\n+\n+\n+import sys\n+\n+### ONE-TRICK PONIES ###\n+\n+def _hasattr(C, attr):\n+    try:\n+        return any(attr in B.__dict__ for B in C.__mro__)\n+    except AttributeError:\n+        # Old-style class\n+        return hasattr(C, attr)\n+\n+\n+class Hashable:\n+    __metaclass__ = ABCMeta\n+\n+    @abstractmethod\n+    def __hash__(self):\n+        return 0\n+\n+    @classmethod\n+    def __subclasshook__(cls, C):\n+        if cls is Hashable:\n+            try:\n+                for B in C.__mro__:\n+                    if \"__hash__\" in B.__dict__:\n+                        if B.__dict__[\"__hash__\"]:\n+                            return True\n+                        break\n+            except AttributeError:\n+                # Old-style class\n+                if getattr(C, \"__hash__\", None):\n+                    return True\n+        return NotImplemented\n+\n+\n+class Iterable:\n+    __metaclass__ = ABCMeta\n+\n+    @abstractmethod\n+    def __iter__(self):\n+        while False:\n+            yield None\n+\n+    @classmethod\n+    def __subclasshook__(cls, C):\n+        if cls is Iterable:\n+            if _hasattr(C, \"__iter__\"):\n+                return True\n+        return NotImplemented\n+\n+Iterable.register(str)\n+\n+\n+class Iterator(Iterable):\n+\n+    @abstractmethod\n+    def next(self):\n+        raise StopIteration\n+\n+    def __iter__(self):\n+        return self\n+\n+    @classmethod\n+    def __subclasshook__(cls, C):\n+        if cls is Iterator:\n+            if _hasattr(C, \"next\") and _hasattr(C, \"__iter__\"):\n+                return True\n+        return NotImplemented\n+\n+\n+class Sized:\n+    __metaclass__ = ABCMeta\n+\n+    @abstractmethod\n+    def __len__(self):\n+        return 0\n+\n+    @classmethod\n+    def __subclasshook__(cls, C):\n+        if cls is Sized:\n+            if _hasattr(C, \"__len__\"):\n+                return True\n+        return NotImplemented\n+\n+\n+class Container:\n+    __metaclass__ = ABCMeta\n+\n+    @abstractmethod\n+    def __contains__(self, x):\n+        return False\n+\n+    @classmethod\n+    def __subclasshook__(cls, C):\n+        if cls is Container:\n+            if _hasattr(C, \"__contains__\"):\n+                return True\n+        return NotImplemented\n+\n+\n+class Callable:\n+    __metaclass__ = ABCMeta\n+\n+    @abstractmethod\n+    def __call__(self, *args, **kwds):\n+        return False\n+\n+    @classmethod\n+    def __subclasshook__(cls, C):\n+        if cls is Callable:\n+            if _hasattr(C, \"__call__\"):\n+                return True\n+        return NotImplemented\n+\n+\n+### SETS ###\n+\n+\n+class Set(Sized, Iterable, Container):\n+    \"\"\"A set is a finite, iterable container.\n+\n+    This class provides concrete generic implementations of all\n+    methods except for __contains__, __iter__ and __len__.\n+\n+    To override the comparisons (presumably for speed, as the\n+    semantics are fixed), all you have to do is redefine __le__ and\n+    then the other operations will automatically follow suit.\n+    \"\"\"\n+\n+    def __le__(self, other):\n+        if not isinstance(other, Set):\n+            return NotImplemented\n+        if len(self) > len(other):\n+            return False\n+        for elem in self:\n+            if elem not in other:\n+                return False\n+        return True\n+\n+    def __lt__(self, other):\n+        if not isinstance(other, Set):\n+            return NotImplemented\n+        return len(self) < len(other) and self.__le__(other)\n+\n+    def __gt__(self, other):\n+        if not isinstance(other, Set):\n+            return NotImplemented\n+        return other < self\n+\n+    def __ge__(self, other):\n+        if not isinstance(other, Set):\n+            return NotImplemented\n+        return other <= self\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, Set):\n+            return NotImplemented\n+        return len(self) == len(other) and self.__le__(other)\n+\n+    def __ne__(self, other):\n+        return not (self == other)\n+\n+    @classmethod\n+    def _from_iterable(cls, it):\n+        '''Construct an instance of the class from any iterable input.\n+\n+        Must override this method if the class constructor signature\n+        does not accept an iterable for an input.\n+        '''\n+        return cls(it)\n+\n+    def __and__(self, other):\n+        if not isinstance(other, Iterable):\n+            return NotImplemented\n+        return self._from_iterable(value for value in other if value in self)\n+\n+    def isdisjoint(self, other):\n+        for value in other:\n+            if value in self:\n+                return False\n+        return True\n+\n+    def __or__(self, other):\n+        if not isinstance(other, Iterable):\n+            return NotImplemented\n+        chain = (e for s in (self, other) for e in s)\n+        return self._from_iterable(chain)\n+\n+    def __sub__(self, other):\n+        if not isinstance(other, Set):\n+            if not isinstance(other, Iterable):\n+                return NotImplemented\n+            other = self._from_iterable(other)\n+        return self._from_iterable(value for value in self\n+                                   if value not in other)\n+\n+    def __xor__(self, other):\n+        if not isinstance(other, Set):\n+            if not isinstance(other, Iterable):\n+                return NotImplemented\n+            other = self._from_iterable(other)\n+        return (self - other) | (other - self)\n+\n+    # Sets are not hashable by default, but subclasses can change this\n+    __hash__ = None\n+\n+    def _hash(self):\n+        \"\"\"Compute the hash value of a set.\n+\n+        Note that we don't define __hash__: not all sets are hashable.\n+        But if you define a hashable set type, its __hash__ should\n+        call this function.\n+\n+        This must be compatible __eq__.\n+\n+        All sets ought to compare equal if they contain the same\n+        elements, regardless of how they are implemented, and\n+        regardless of the order of the elements; so there's not much\n+        freedom for __eq__ or __hash__.  We match the algorithm used\n+        by the built-in frozenset type.\n+        \"\"\"\n+        MAX = sys.maxint\n+        MASK = 2 * MAX + 1\n+        n = len(self)\n+        h = 1927868237 * (n + 1)\n+        h &= MASK\n+        for x in self:\n+            hx = hash(x)\n+            h ^= (hx ^ (hx << 16) ^ 89869747)  * 3644798167\n+            h &= MASK\n+        h = h * 69069 + 907133923\n+        h &= MASK\n+        if h > MAX:\n+            h -= MASK + 1\n+        if h == -1:\n+            h = 590923713\n+        return h\n+\n+Set.register(frozenset)\n+\n+\n+class MutableSet(Set):\n+\n+    @abstractmethod\n+    def add(self, value):\n+        \"\"\"Add an element.\"\"\"\n+        raise NotImplementedError\n+\n+    @abstractmethod\n+    def discard(self, value):\n+        \"\"\"Remove an element.  Do not raise an exception if absent.\"\"\"\n+        raise NotImplementedError\n+\n+    def remove(self, value):\n+        \"\"\"Remove an element. If not a member, raise a KeyError.\"\"\"\n+        if value not in self:\n+            raise KeyError(value)\n+        self.discard(value)\n+\n+    def pop(self):\n+        \"\"\"Return the popped value.  Raise KeyError if empty.\"\"\"\n+        it = iter(self)\n+        try:\n+            value = next(it)\n+        except StopIteration:\n+            raise KeyError\n+        self.discard(value)\n+        return value\n+\n+    def clear(self):\n+        \"\"\"This is slow (creates N new iterators!) but effective.\"\"\"\n+        try:\n+            while True:\n+                self.pop()\n+        except KeyError:\n+            pass\n+\n+    def __ior__(self, it):\n+        for value in it:\n+            self.add(value)\n+        return self\n+\n+    def __iand__(self, it):\n+        for value in (self - it):\n+            self.discard(value)\n+        return self\n+\n+    def __ixor__(self, it):\n+        if it is self:\n+            self.clear()\n+        else:\n+            if not isinstance(it, Set):\n+                it = self._from_iterable(it)\n+            for value in it:\n+                if value in self:\n+                    self.discard(value)\n+                else:\n+                    self.add(value)\n+        return self\n+\n+    def __isub__(self, it):\n+        if it is self:\n+            self.clear()\n+        else:\n+            for value in it:\n+                self.discard(value)\n+        return self\n+\n+MutableSet.register(set)\n+\n+\n+### MAPPINGS ###\n+\n+\n+class Mapping(Sized, Iterable, Container):\n+\n+    @abstractmethod\n+    def __getitem__(self, key):\n+        raise KeyError\n+\n+    def get(self, key, default=None):\n+        try:\n+            return self[key]\n+        except KeyError:\n+            return default\n+\n+    def __contains__(self, key):\n+        try:\n+            self[key]\n+        except KeyError:\n+            return False\n+        else:\n+            return True\n+\n+    def iterkeys(self):\n+        return iter(self)\n+\n+    def itervalues(self):\n+        for key in self:\n+            yield self[key]\n+\n+    def iteritems(self):\n+        for key in self:\n+            yield (key, self[key])\n+\n+    def keys(self):\n+        return list(self)\n+\n+    def items(self):\n+        return [(key, self[key]) for key in self]\n+\n+    def values(self):\n+        return [self[key] for key in self]\n+\n+    # Mappings are not hashable by default, but subclasses can change this\n+    __hash__ = None\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, Mapping):\n+            return NotImplemented\n+        return dict(self.items()) == dict(other.items())\n+\n+    def __ne__(self, other):\n+        return not (self == other)\n+\n+class MappingView(Sized):\n+\n+    def __init__(self, mapping):\n+        self._mapping = mapping\n+\n+    def __len__(self):\n+        return len(self._mapping)\n+\n+    def __repr__(self):\n+        return '{0.__class__.__name__}({0._mapping!r})'.format(self)\n+\n+\n+class KeysView(MappingView, Set):\n+\n+    @classmethod\n+    def _from_iterable(self, it):\n+        return set(it)\n+\n+    def __contains__(self, key):\n+        return key in self._mapping\n+\n+    def __iter__(self):\n+        for key in self._mapping:\n+            yield key\n+\n+\n+class ItemsView(MappingView, Set):\n+\n+    @classmethod\n+    def _from_iterable(self, it):\n+        return set(it)\n+\n+    def __contains__(self, item):\n+        key, value = item\n+        try:\n+            v = self._mapping[key]\n+        except KeyError:\n+            return False\n+        else:\n+            return v == value\n+\n+    def __iter__(self):\n+        for key in self._mapping:\n+            yield (key, self._mapping[key])\n+\n+\n+class ValuesView(MappingView):\n+\n+    def __contains__(self, value):\n+        for key in self._mapping:\n+            if value == self._mapping[key]:\n+                return True\n+        return False\n+\n+    def __iter__(self):\n+        for key in self._mapping:\n+            yield self._mapping[key]\n+\n+\n+class MutableMapping(Mapping):\n+\n+    @abstractmethod\n+    def __setitem__(self, key, value):\n+        raise KeyError\n+\n+    @abstractmethod\n+    def __delitem__(self, key):\n+        raise KeyError\n+\n+    __marker = object()\n+\n+    def pop(self, key, default=__marker):\n+        try:\n+            value = self[key]\n+        except KeyError:\n+            if default is self.__marker:\n+                raise\n+            return default\n+        else:\n+            del self[key]\n+            return value\n+\n+    def popitem(self):\n+        try:\n+            key = next(iter(self))\n+        except StopIteration:\n+            raise KeyError\n+        value = self[key]\n+        del self[key]\n+        return key, value\n+\n+    def clear(self):\n+        try:\n+            while True:\n+                self.popitem()\n+        except KeyError:\n+            pass\n+\n+    def update(*args, **kwds):\n+        if len(args) > 2:\n+            raise TypeError(\"update() takes at most 2 positional \"\n+                            \"arguments ({} given)\".format(len(args)))\n+        elif not args:\n+            raise TypeError(\"update() takes at least 1 argument (0 given)\")\n+        self = args[0]\n+        other = args[1] if len(args) >= 2 else ()\n+\n+        if isinstance(other, Mapping):\n+            for key in other:\n+                self[key] = other[key]\n+        elif hasattr(other, \"keys\"):\n+            for key in other.keys():\n+                self[key] = other[key]\n+        else:\n+            for key, value in other:\n+                self[key] = value\n+        for key, value in kwds.items():\n+            self[key] = value\n+\n+    def setdefault(self, key, default=None):\n+        try:\n+            return self[key]\n+        except KeyError:\n+            self[key] = default\n+        return default\n+\n+MutableMapping.register(dict)\n+\n+\n+### SEQUENCES ###\n+\n+\n+class Sequence(Sized, Iterable, Container):\n+    \"\"\"All the operations on a read-only sequence.\n+\n+    Concrete subclasses must override __new__ or __init__,\n+    __getitem__, and __len__.\n+    \"\"\"\n+\n+    @abstractmethod\n+    def __getitem__(self, index):\n+        raise IndexError\n+\n+    def __iter__(self):\n+        i = 0\n+        try:\n+            while True:\n+                v = self[i]\n+                yield v\n+                i += 1\n+        except IndexError:\n+            return\n+\n+    def __contains__(self, value):\n+        for v in self:\n+            if v == value:\n+                return True\n+        return False\n+\n+    def __reversed__(self):\n+        for i in reversed(range(len(self))):\n+            yield self[i]\n+\n+    def index(self, value):\n+        for i, v in enumerate(self):\n+            if v == value:\n+                return i\n+        raise ValueError\n+\n+    def count(self, value):\n+        return sum(1 for v in self if v == value)\n+\n+Sequence.register(tuple)\n+Sequence.register(basestring)\n+Sequence.register(buffer)\n+Sequence.register(xrange)\n+\n+\n+class MutableSequence(Sequence):\n+\n+    @abstractmethod\n+    def __setitem__(self, index, value):\n+        raise IndexError\n+\n+    @abstractmethod\n+    def __delitem__(self, index):\n+        raise IndexError\n+\n+    @abstractmethod\n+    def insert(self, index, value):\n+        raise IndexError\n+\n+    def append(self, value):\n+        self.insert(len(self), value)\n+\n+    def reverse(self):\n+        n = len(self)\n+        for i in range(n//2):\n+            self[i], self[n-i-1] = self[n-i-1], self[i]\n+\n+    def extend(self, values):\n+        for v in values:\n+            self.append(v)\n+\n+    def pop(self, index=-1):\n+        v = self[index]\n+        del self[index]\n+        return v\n+\n+    def remove(self, value):\n+        del self[self.index(value)]\n+\n+    def __iadd__(self, values):\n+        self.extend(values)\n+        return self\n+\n+MutableSequence.register(list)\n+\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
