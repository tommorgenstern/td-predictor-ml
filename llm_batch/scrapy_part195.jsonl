{"custom_id": "scrapy#407349865279795387b9ff84afb9011e2303bb9d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 40 | Lines Deleted: 24 | Files Changed: 2 | Hunks: 26 | Methods Changed: 11 | Complexity Δ (Sum/Max): 4/3 | Churn Δ: 64 | Churn Cumulative: 644 | Contributors (this commit): 10 | Commits (past 90d): 6 | Contributors (cumulative): 12 | DMM Complexity: 1.0\n\nDIFF:\n@@ -142,11 +142,14 @@ def re_rsearch(pattern, text, chunk_size=1024):\n             yield (text[offset:], offset)\n         yield (text, 0)\n \n-    pattern = re.compile(pattern) if isinstance(pattern, basestring) else pattern\n+    if isinstance(pattern, six.string_types):\n+        pattern = re.compile(pattern)\n+\n     for chunk, offset in _chunk_iter():\n         matches = [match for match in pattern.finditer(chunk)]\n         if matches:\n-            return (offset + matches[-1].span()[0], offset + matches[-1].span()[1])\n+            start, end = matches[-1].span()\n+            return offset + start, offset + end\n     return None\n \n \n@@ -162,14 +165,16 @@ def memoizemethod_noargs(method):\n         return cache[self]\n     return new_method\n \n-_BINARYCHARS = set(map(chr, range(32))) - set([\"\\0\", \"\\t\", \"\\n\", \"\\r\"])\n+_BINARYCHARS = {six.b(chr(i)) for i in range(32)} - {b\"\\0\", b\"\\t\", b\"\\n\", b\"\\r\"}\n+_BINARYCHARS |= {ord(ch) for ch in _BINARYCHARS}\n \n \n def isbinarytext(text):\n-    \"\"\"Return True if the given text is considered binary, or false\n+    \"\"\"Return True if the given text is considered binary, or False\n     otherwise, by looking for binary bytes at their chars\n     \"\"\"\n-    assert isinstance(text, str), \"text must be str, got '%s'\" % type(text).__name__\n+    if not isinstance(text, bytes):\n+        raise TypeError(\"text must be bytes, got '%s'\" % type(text).__name__)\n     return any(c in _BINARYCHARS for c in text)\n \n \n@@ -273,20 +278,22 @@ class WeakKeyCache(object):\n         return self._weakdict[key]\n \n \n+@deprecated\n def stringify_dict(dct_or_tuples, encoding='utf-8', keys_only=True):\n-    \"\"\"Return a (new) dict with the unicode keys (and values if, keys_only is\n+    \"\"\"Return a (new) dict with unicode keys (and values when \"keys_only\" is\n     False) of the given dict converted to strings. `dct_or_tuples` can be a\n     dict or a list of tuples, like any dict constructor supports.\n     \"\"\"\n     d = {}\n     for k, v in six.iteritems(dict(dct_or_tuples)):\n-        k = k.encode(encoding) if isinstance(k, unicode) else k\n+        k = k.encode(encoding) if isinstance(k, six.text_type) else k\n         if not keys_only:\n-            v = v.encode(encoding) if isinstance(v, unicode) else v\n+            v = v.encode(encoding) if isinstance(v, six.text_type) else v\n         d[k] = v\n     return d\n \n \n+@deprecated\n def is_writable(path):\n     \"\"\"Return True if the given path can be written (if it exists) or created\n     (if it doesn't exist)\n@@ -297,6 +304,7 @@ def is_writable(path):\n         return os.access(os.path.dirname(path), os.W_OK)\n \n \n+@deprecated\n def setattr_default(obj, name, value):\n     \"\"\"Set attribute value, but only if it's not already set. Similar to\n     setdefault() for dicts.\n\n@@ -2,6 +2,7 @@ import functools\n import operator\n import unittest\n from itertools import count\n+import six\n \n from scrapy.utils.python import (\n     memoizemethod_noargs, isbinarytext, equal_attributes,\n@@ -44,7 +45,7 @@ class ToBytesTest(unittest.TestCase):\n         self.assertIn(b'?', to_bytes(u'a\\ufffdb', 'latin-1', errors='replace'))\n \n \n-class UtilsPythonTestCase(unittest.TestCase):\n+class MemoizedMethodTest(unittest.TestCase):\n     def test_memoizemethod_noargs(self):\n         class A(object):\n \n@@ -62,19 +63,23 @@ class UtilsPythonTestCase(unittest.TestCase):\n         assert one is two\n         assert one is not three\n \n+\n+class IsBinaryTextTest(unittest.TestCase):\n     def test_isbinarytext(self):\n+        assert not isbinarytext(b\"hello\")\n \n-        # basic tests\n-        assert not isbinarytext(\"hello\")\n-\n-        # utf-16 strings contain null bytes\n+    def utf_16_strings_contain_null_bytes(self):\n         assert not isbinarytext(u\"hello\".encode('utf-16'))\n \n-        # one with encoding\n-        assert not isbinarytext(\"<div>Price \\xa3</div>\")\n+    def test_one_with_encoding(self):\n+        assert not isbinarytext(b\"<div>Price \\xa3</div>\")\n \n-        # finally some real binary bytes\n-        assert isbinarytext(\"\\x02\\xa3\")\n+    def test_finally_some_real_binary_bytes(self):\n+        assert isbinarytext(b\"\\x02\\xa3\")\n+\n+\n+\n+class UtilsPythonTestCase(unittest.TestCase):\n \n     def test_equal_attributes(self):\n         class Obj:\n@@ -134,29 +139,32 @@ class UtilsPythonTestCase(unittest.TestCase):\n         del k\n         self.assertFalse(len(wk._weakdict))\n \n+    @unittest.skipUnless(six.PY2, \"deprecated function\")\n     def test_stringify_dict(self):\n-        d = {'a': 123, u'b': 'c', u'd': u'e', object(): u'e'}\n+        d = {'a': 123, u'b': b'c', u'd': u'e', object(): u'e'}\n         d2 = stringify_dict(d, keys_only=False)\n         self.assertEqual(d, d2)\n         self.failIf(d is d2)  # shouldn't modify in place\n-        self.failIf(any(isinstance(x, unicode) for x in d2.keys()))\n-        self.failIf(any(isinstance(x, unicode) for x in d2.values()))\n+        self.failIf(any(isinstance(x, six.text_type) for x in d2.keys()))\n+        self.failIf(any(isinstance(x, six.text_type) for x in d2.values()))\n \n+    @unittest.skipUnless(six.PY2, \"deprecated function\")\n     def test_stringify_dict_tuples(self):\n         tuples = [('a', 123), (u'b', 'c'), (u'd', u'e'), (object(), u'e')]\n         d = dict(tuples)\n         d2 = stringify_dict(tuples, keys_only=False)\n         self.assertEqual(d, d2)\n         self.failIf(d is d2)  # shouldn't modify in place\n-        self.failIf(any(isinstance(x, unicode) for x in d2.keys()), d2.keys())\n-        self.failIf(any(isinstance(x, unicode) for x in d2.values()))\n+        self.failIf(any(isinstance(x, six.text_type) for x in d2.keys()), d2.keys())\n+        self.failIf(any(isinstance(x, six.text_type) for x in d2.values()))\n \n+    @unittest.skipUnless(six.PY2, \"deprecated function\")\n     def test_stringify_dict_keys_only(self):\n         d = {'a': 123, u'b': 'c', u'd': u'e', object(): u'e'}\n         d2 = stringify_dict(d)\n         self.assertEqual(d, d2)\n         self.failIf(d is d2)  # shouldn't modify in place\n-        self.failIf(any(isinstance(x, unicode) for x in d2.keys()))\n+        self.failIf(any(isinstance(x, six.text_type) for x in d2.keys()))\n \n     def test_get_func_args(self):\n         def f1(a, b, c):\n@@ -194,7 +202,7 @@ class UtilsPythonTestCase(unittest.TestCase):\n         self.assertEqual(get_func_args(object), [])\n \n         # TODO: how do we fix this to return the actual argument names?\n-        self.assertEqual(get_func_args(unicode.split), [])\n+        self.assertEqual(get_func_args(six.text_type.split), [])\n         self.assertEqual(get_func_args(\" \".join), [])\n         self.assertEqual(get_func_args(operator.itemgetter(2)), [])\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#a7b4a3e7f95fed8f1d4b9bddf79f7e9a91555fdb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 13 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 5 | Methods Changed: 8 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 20 | Churn Cumulative: 161 | Contributors (this commit): 2 | Commits (past 90d): 4 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -24,8 +24,11 @@ class ToUnicodeTest(unittest.TestCase):\n     def test_converting_a_strange_object_should_raise_TypeError(self):\n         self.assertRaises(TypeError, to_unicode, 423)\n \n-    def test_check_errors_argument_works(self):\n-        self.assertIn(u'\\ufffd', to_unicode(b'a\\xedb', 'utf-8', errors='replace'))\n+    def test_errors_argument(self):\n+        self.assertEqual(\n+            to_unicode(b'a\\xedb', 'utf-8', errors='replace'),\n+            u'a\\ufffdb'\n+        )\n \n \n class ToBytesTest(unittest.TestCase):\n@@ -35,14 +38,17 @@ class ToBytesTest(unittest.TestCase):\n     def test_converting_a_unicode_object_to_a_latin_1_encoded_string(self):\n         self.assertEqual(to_bytes(u'\\xa3 49', 'latin-1'), b'\\xa3 49')\n \n-    def test_converting_a_regular_string_to_string_should_return_the_same_object(self):\n+    def test_converting_a_regular_bytes_to_bytes_should_return_the_same_object(self):\n         self.assertEqual(to_bytes(b'lel\\xf1e'), b'lel\\xf1e')\n \n     def test_converting_a_strange_object_should_raise_TypeError(self):\n         self.assertRaises(TypeError, to_bytes, unittest)\n \n-    def test_check_errors_argument_works(self):\n-        self.assertIn(b'?', to_bytes(u'a\\ufffdb', 'latin-1', errors='replace'))\n+    def test_errors_argument(self):\n+        self.assertEqual(\n+            to_bytes(u'a\\ufffdb', 'latin-1', errors='replace'),\n+            b'a?b'\n+        )\n \n \n class MemoizedMethodTest(unittest.TestCase):\n@@ -68,13 +74,13 @@ class IsBinaryTextTest(unittest.TestCase):\n     def test_isbinarytext(self):\n         assert not isbinarytext(b\"hello\")\n \n-    def utf_16_strings_contain_null_bytes(self):\n+    def test_utf_16_strings_contain_null_bytes(self):\n         assert not isbinarytext(u\"hello\".encode('utf-16'))\n \n     def test_one_with_encoding(self):\n         assert not isbinarytext(b\"<div>Price \\xa3</div>\")\n \n-    def test_finally_some_real_binary_bytes(self):\n+    def test_real_binary_bytes(self):\n         assert isbinarytext(b\"\\x02\\xa3\")\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#9aaa8f81251e3859ee52eef2aaed60ce9f28ecb0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 15 | Contributors (this commit): 4 | Commits (past 90d): 1 | Contributors (cumulative): 4 | DMM Complexity: None\n\nDIFF:\n@@ -5,6 +5,8 @@ from twisted.python.failure import Failure\n from scrapy.utils.defer import mustbe_deferred, process_chain, \\\n     process_chain_both, process_parallel, iter_errback\n \n+from six.moves import xrange\n+\n \n class MustbeDeferredTest(unittest.TestCase):\n     def test_success_function(self):\n@@ -86,7 +88,7 @@ class IterErrbackTest(unittest.TestCase):\n \n         errors = []\n         out = list(iter_errback(itergood(), errors.append))\n-        self.assertEqual(out, range(10))\n+        self.assertEqual(out, list(range(10)))\n         self.failIf(errors)\n \n     def test_iter_errback_bad(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#e853d9e910151a83dcb944fa3c7ad82a19075edd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 161 | Lines Deleted: 169 | Files Changed: 8 | Hunks: 113 | Methods Changed: 60 | Complexity Δ (Sum/Max): -7/1 | Churn Δ: 330 | Churn Cumulative: 2450 | Contributors (this commit): 25 | Commits (past 90d): 11 | Contributors (cumulative): 51 | DMM Complexity: 0.0\n\nDIFF:\n@@ -8,6 +8,7 @@ import six\n from w3lib.url import safe_url_string\n \n from scrapy.http.headers import Headers\n+from scrapy.utils.python import to_native_str, to_bytes\n from scrapy.utils.trackref import object_ref\n from scrapy.utils.url import escape_ajax\n from scrapy.http.common import obsolete_setter\n@@ -46,15 +47,12 @@ class Request(object_ref):\n         return self._url\n \n     def _set_url(self, url):\n-        if isinstance(url, str):\n-            self._url = escape_ajax(safe_url_string(url))\n-        elif isinstance(url, six.text_type):\n-            if self.encoding is None:\n-                raise TypeError('Cannot convert unicode url - %s has no encoding' %\n-                                type(self).__name__)\n-            self._set_url(url.encode(self.encoding))\n-        else:\n+        if not isinstance(url, six.string_types):\n             raise TypeError('Request url must be str or unicode, got %s:' % type(url).__name__)\n+\n+        url = to_native_str(url, self.encoding)\n+        self._url = escape_ajax(safe_url_string(url))\n+\n         if ':' not in self._url:\n             raise ValueError('Missing scheme in request url: %s' % self._url)\n \n@@ -64,17 +62,10 @@ class Request(object_ref):\n         return self._body\n \n     def _set_body(self, body):\n-        if isinstance(body, str):\n-            self._body = body\n-        elif isinstance(body, six.text_type):\n-            if self.encoding is None:\n-                raise TypeError('Cannot convert unicode body - %s has no encoding' %\n-                                type(self).__name__)\n-            self._body = body.encode(self.encoding)\n-        elif body is None:\n-            self._body = ''\n+        if body is None:\n+            self._body = b''\n         else:\n-            raise TypeError(\"Request body must either str or unicode. Got: '%s'\" % type(body).__name__)\n+            self._body = to_bytes(body, self.encoding)\n \n     body = property(_get_body, obsolete_setter(_set_body, 'body'))\n \n\n@@ -9,7 +9,7 @@ from six.moves.urllib.parse import urljoin, urlencode\n import lxml.html\n import six\n from scrapy.http.request import Request\n-from scrapy.utils.python import to_bytes\n+from scrapy.utils.python import to_bytes, is_listlike\n \n \n class FormRequest(Request):\n@@ -25,7 +25,7 @@ class FormRequest(Request):\n             items = formdata.items() if isinstance(formdata, dict) else formdata\n             querystr = _urlencode(items, self.encoding)\n             if self.method == 'POST':\n-                self.headers.setdefault('Content-Type', 'application/x-www-form-urlencoded')\n+                self.headers.setdefault(b'Content-Type', b'application/x-www-form-urlencoded')\n                 self._set_body(querystr)\n             else:\n                 self._set_url(self.url + ('&' if '?' in self.url else '?') + querystr)\n@@ -50,7 +50,7 @@ def _get_form_url(form, url):\n def _urlencode(seq, enc):\n     values = [(to_bytes(k, enc), to_bytes(v, enc))\n               for k, vs in seq\n-              for v in (vs if hasattr(vs, '__iter__') else [vs])]\n+              for v in (vs if is_listlike(vs) else [vs])]\n     return urlencode(values, doseq=1)\n \n \n\n@@ -4,9 +4,6 @@ responses in Scrapy.\n \n See documentation in docs/topics/request-response.rst\n \"\"\"\n-\n-import copy\n-\n from six.moves.urllib.parse import urljoin\n \n from scrapy.http.headers import Headers\n@@ -15,7 +12,7 @@ from scrapy.http.common import obsolete_setter\n \n class Response(object_ref):\n \n-    def __init__(self, url, status=200, headers=None, body='', flags=None, request=None):\n+    def __init__(self, url, status=200, headers=None, body=b'', flags=None, request=None):\n         self.headers = Headers(headers or {})\n         self.status = int(status)\n         self._set_body(body)\n@@ -28,8 +25,10 @@ class Response(object_ref):\n         try:\n             return self.request.meta\n         except AttributeError:\n-            raise AttributeError(\"Response.meta not available, this response \" \\\n-                \"is not tied to any request\")\n+            raise AttributeError(\n+                \"Response.meta not available, this response \"\n+                \"is not tied to any request\"\n+            )\n \n     def _get_url(self):\n         return self._url\n@@ -38,7 +37,7 @@ class Response(object_ref):\n         if isinstance(url, str):\n             self._url = url\n         else:\n-            raise TypeError('%s url must be str, got %s:' % (type(self).__name__, \\\n+            raise TypeError('%s url must be str, got %s:' % (type(self).__name__,\n                 type(url).__name__))\n \n     url = property(_get_url, obsolete_setter(_set_url, 'url'))\n@@ -47,16 +46,15 @@ class Response(object_ref):\n         return self._body\n \n     def _set_body(self, body):\n-        if isinstance(body, str):\n-            self._body = body\n-        elif isinstance(body, unicode):\n-            raise TypeError(\"Cannot assign a unicode body to a raw Response. \" \\\n-                \"Use TextResponse, HtmlResponse, etc\")\n-        elif body is None:\n-            self._body = ''\n+        if body is None:\n+            self._body = b''\n+        elif not isinstance(body, bytes):\n+            raise TypeError(\n+                \"Response body must be bytes. \"\n+                \"If you want to pass unicode body use TextResponse \"\n+                \"or HtmlResponse.\")\n         else:\n-            raise TypeError(\"Response body must either be str or unicode. Got: '%s'\" \\\n-                % type(body).__name__)\n+            self._body = body\n \n     body = property(_get_body, obsolete_setter(_set_body, 'body'))\n \n\n@@ -5,13 +5,14 @@ discovering (through HTTP headers) to base Response class.\n See documentation in docs/topics/request-response.rst\n \"\"\"\n \n+import six\n from six.moves.urllib.parse import urljoin\n \n from w3lib.encoding import html_to_unicode, resolve_encoding, \\\n     html_body_declared_encoding, http_content_type_encoding\n from scrapy.http.response import Response\n from scrapy.utils.response import get_base_url\n-from scrapy.utils.python import memoizemethod_noargs\n+from scrapy.utils.python import memoizemethod_noargs, to_native_str\n \n \n class TextResponse(Response):\n@@ -26,18 +27,18 @@ class TextResponse(Response):\n         super(TextResponse, self).__init__(*args, **kwargs)\n \n     def _set_url(self, url):\n-        if isinstance(url, unicode):\n-            if self.encoding is None:\n-                raise TypeError('Cannot convert unicode url - %s has no encoding' %\n-                    type(self).__name__)\n-            self._url = url.encode(self.encoding)\n+        if isinstance(url, six.text_type):\n+            if six.PY2 and self.encoding is None:\n+                raise TypeError(\"Cannot convert unicode url - %s \"\n+                                \"has no encoding\" % type(self).__name__)\n+            self._url = to_native_str(url, self.encoding)\n         else:\n             super(TextResponse, self)._set_url(url)\n \n     def _set_body(self, body):\n-        self._body = ''\n-        if isinstance(body, unicode):\n-            if self.encoding is None:\n+        self._body = b''  # used by encoding detection\n+        if isinstance(body, six.text_type):\n+            if self._encoding is None:\n                 raise TypeError('Cannot convert unicode body - %s has no encoding' %\n                     type(self).__name__)\n             self._body = body.encode(self._encoding)\n@@ -73,14 +74,14 @@ class TextResponse(Response):\n \n     @memoizemethod_noargs\n     def _headers_encoding(self):\n-        content_type = self.headers.get('Content-Type')\n-        return http_content_type_encoding(content_type)\n+        content_type = self.headers.get(b'Content-Type', b'')\n+        return http_content_type_encoding(to_native_str(content_type))\n \n     def _body_inferred_encoding(self):\n         if self._cached_benc is None:\n-            content_type = self.headers.get('Content-Type')\n-            benc, ubody = html_to_unicode(content_type, self.body, \\\n-                    auto_detect_fun=self._auto_detect_fun, \\\n+            content_type = to_native_str(self.headers.get(b'Content-Type', b''))\n+            benc, ubody = html_to_unicode(content_type, self.body,\n+                    auto_detect_fun=self._auto_detect_fun,\n                     default_encoding=self._DEFAULT_ENCODING)\n             self._cached_benc = benc\n             self._cached_ubody = ubody\n\n@@ -121,7 +121,7 @@ class Selector(object_ref):\n         try:\n             return etree.tostring(self._root,\n                                   method=self._tostring_method,\n-                                  encoding=unicode,\n+                                  encoding=\"unicode\",\n                                   with_tail=False)\n         except (AttributeError, TypeError):\n             if self._root is True:\n@@ -129,7 +129,7 @@ class Selector(object_ref):\n             elif self._root is False:\n                 return u'0'\n             else:\n-                return unicode(self._root)\n+                return six.text_type(self._root)\n \n     def register_namespace(self, prefix, uri):\n         if self.namespaces is None:\n\n@@ -7,7 +7,7 @@ from pkgutil import iter_modules\n import six\n from w3lib.html import replace_entities\n \n-from scrapy.utils.python import flatten\n+from scrapy.utils.python import flatten, to_unicode\n from scrapy.item import BaseItem\n \n \n@@ -81,7 +81,7 @@ def extract_regex(regex, text, encoding='utf-8'):\n     * if the regex doesn't contain any group the entire regex matching is returned\n     \"\"\"\n \n-    if isinstance(regex, basestring):\n+    if isinstance(regex, six.string_types):\n         regex = re.compile(regex, re.UNICODE)\n \n     try:\n@@ -90,10 +90,11 @@ def extract_regex(regex, text, encoding='utf-8'):\n         strings = regex.findall(text)    # full regex or numbered groups\n     strings = flatten(strings)\n \n-    if isinstance(text, unicode):\n+    if isinstance(text, six.text_type):\n         return [replace_entities(s, keep=['lt', 'amp']) for s in strings]\n     else:\n-        return [replace_entities(unicode(s, encoding), keep=['lt', 'amp']) for s in strings]\n+        return [replace_entities(to_unicode(s, encoding), keep=['lt', 'amp'])\n+                for s in strings]\n \n \n def md5sum(file):\n\n@@ -1,9 +1,12 @@\n import cgi\n import unittest\n+\n+import six\n from six.moves import xmlrpc_client as xmlrpclib\n from six.moves.urllib.parse import urlparse\n \n from scrapy.http import Request, FormRequest, XmlRpcRequest, Headers, HtmlResponse\n+from scrapy.utils.python import to_bytes, to_native_str\n \n \n class RequestTest(unittest.TestCase):\n@@ -31,13 +34,13 @@ class RequestTest(unittest.TestCase):\n         self.assertEqual(r.meta, self.default_meta)\n \n         meta = {\"lala\": \"lolo\"}\n-        headers = {\"caca\": \"coco\"}\n+        headers = {b\"caca\": b\"coco\"}\n         r = self.request_class(\"http://www.example.com\", meta=meta, headers=headers, body=\"a body\")\n \n         assert r.meta is not meta\n         self.assertEqual(r.meta, meta)\n         assert r.headers is not headers\n-        self.assertEqual(r.headers[\"caca\"], \"coco\")\n+        self.assertEqual(r.headers[b\"caca\"], b\"coco\")\n \n     def test_url_no_scheme(self):\n         self.assertRaises(ValueError, self.request_class, 'foo')\n@@ -45,7 +48,7 @@ class RequestTest(unittest.TestCase):\n     def test_headers(self):\n         # Different ways of setting headers attribute\n         url = 'http://www.scrapy.org'\n-        headers = {'Accept':'gzip', 'Custom-Header':'nothing to tell you'}\n+        headers = {b'Accept':'gzip', b'Custom-Header':'nothing to tell you'}\n         r = self.request_class(url=url, headers=headers)\n         p = self.request_class(url=url, headers=r.headers)\n \n@@ -57,9 +60,9 @@ class RequestTest(unittest.TestCase):\n         h = Headers({'key1': u'val1', u'key2': 'val2'})\n         h[u'newkey'] = u'newval'\n         for k, v in h.iteritems():\n-            self.assert_(isinstance(k, str))\n+            self.assert_(isinstance(k, bytes))\n             for s in v:\n-                self.assert_(isinstance(s, str))\n+                self.assert_(isinstance(s, bytes))\n \n     def test_eq(self):\n         url = 'http://www.scrapy.org'\n@@ -73,17 +76,17 @@ class RequestTest(unittest.TestCase):\n         self.assertEqual(len(set_), 2)\n \n     def test_url(self):\n-        \"\"\"Request url tests\"\"\"\n         r = self.request_class(url=\"http://www.scrapy.org/path\")\n         self.assertEqual(r.url, \"http://www.scrapy.org/path\")\n \n-        # url quoting on creation\n+    def test_url_quoting(self):\n         r = self.request_class(url=\"http://www.scrapy.org/blank%20space\")\n         self.assertEqual(r.url, \"http://www.scrapy.org/blank%20space\")\n         r = self.request_class(url=\"http://www.scrapy.org/blank space\")\n         self.assertEqual(r.url, \"http://www.scrapy.org/blank%20space\")\n \n-        # url encoding\n+    @unittest.skipUnless(six.PY2, \"TODO\")\n+    def test_url_encoding(self):\n         r1 = self.request_class(url=u\"http://www.scrapy.org/price/\\xa3\", encoding=\"utf-8\")\n         r2 = self.request_class(url=u\"http://www.scrapy.org/price/\\xa3\", encoding=\"latin1\")\n         self.assertEqual(r1.url, \"http://www.scrapy.org/price/%C2%A3\")\n@@ -91,19 +94,19 @@ class RequestTest(unittest.TestCase):\n \n     def test_body(self):\n         r1 = self.request_class(url=\"http://www.example.com/\")\n-        assert r1.body == ''\n+        assert r1.body == b''\n \n-        r2 = self.request_class(url=\"http://www.example.com/\", body=\"\")\n-        assert isinstance(r2.body, str)\n+        r2 = self.request_class(url=\"http://www.example.com/\", body=b\"\")\n+        assert isinstance(r2.body, bytes)\n         self.assertEqual(r2.encoding, 'utf-8') # default encoding\n \n         r3 = self.request_class(url=\"http://www.example.com/\", body=u\"Price: \\xa3100\", encoding='utf-8')\n-        assert isinstance(r3.body, str)\n-        self.assertEqual(r3.body, \"Price: \\xc2\\xa3100\")\n+        assert isinstance(r3.body, bytes)\n+        self.assertEqual(r3.body, b\"Price: \\xc2\\xa3100\")\n \n         r4 = self.request_class(url=\"http://www.example.com/\", body=u\"Price: \\xa3100\", encoding='latin1')\n-        assert isinstance(r4.body, str)\n-        self.assertEqual(r4.body, \"Price: \\xa3100\")\n+        assert isinstance(r4.body, bytes)\n+        self.assertEqual(r4.body, b\"Price: \\xa3100\")\n \n     def test_ajax_url(self):\n         # ascii url\n@@ -155,18 +158,19 @@ class RequestTest(unittest.TestCase):\n     def test_replace(self):\n         \"\"\"Test Request.replace() method\"\"\"\n         r1 = self.request_class(\"http://www.example.com\", method='GET')\n-        hdrs = Headers(dict(r1.headers, key='value'))\n+        hdrs = Headers(r1.headers)\n+        hdrs[b'key'] = b'value'\n         r2 = r1.replace(method=\"POST\", body=\"New body\", headers=hdrs)\n         self.assertEqual(r1.url, r2.url)\n         self.assertEqual((r1.method, r2.method), (\"GET\", \"POST\"))\n-        self.assertEqual((r1.body, r2.body), ('', \"New body\"))\n+        self.assertEqual((r1.body, r2.body), (b'', b\"New body\"))\n         self.assertEqual((r1.headers, r2.headers), (self.default_headers, hdrs))\n \n         # Empty attributes (which may fail if not compared properly)\n         r3 = self.request_class(\"http://www.example.com\", meta={'a': 1}, dont_filter=True)\n-        r4 = r3.replace(url=\"http://www.example.com/2\", body='', meta={}, dont_filter=False)\n+        r4 = r3.replace(url=\"http://www.example.com/2\", body=b'', meta={}, dont_filter=False)\n         self.assertEqual(r4.url, \"http://www.example.com/2\")\n-        self.assertEqual(r4.body, '')\n+        self.assertEqual(r4.body, b'')\n         self.assertEqual(r4.meta, {})\n         assert r4.dont_filter is False\n \n@@ -184,39 +188,41 @@ class FormRequestTest(RequestTest):\n \n     request_class = FormRequest\n \n-    def assertSortedEqual(self, first, second, msg=None):\n+    def assertQueryEqual(self, first, second, msg=None):\n+        first = to_native_str(first).split(\"&\")\n+        second = to_native_str(second).split(\"&\")\n         return self.assertEqual(sorted(first), sorted(second), msg)\n \n     def test_empty_formdata(self):\n         r1 = self.request_class(\"http://www.example.com\", formdata={})\n-        self.assertEqual(r1.body, '')\n+        self.assertEqual(r1.body, b'')\n \n+    @unittest.skipUnless(six.PY2, \"TODO\")\n     def test_default_encoding(self):\n         # using default encoding (utf-8)\n         data = {'one': 'two', 'price': '\\xc2\\xa3 100'}\n         r2 = self.request_class(\"http://www.example.com\", formdata=data)\n         self.assertEqual(r2.method, 'POST')\n         self.assertEqual(r2.encoding, 'utf-8')\n-        self.assertSortedEqual(r2.body.split('&'),\n-                               'price=%C2%A3+100&one=two'.split('&'))\n-        self.assertEqual(r2.headers['Content-Type'], 'application/x-www-form-urlencoded')\n+        self.assertQueryEqual(r2.body, b'price=%C2%A3+100&one=two')\n+        self.assertEqual(r2.headers[b'Content-Type'], b'application/x-www-form-urlencoded')\n \n     def test_custom_encoding(self):\n         data = {'price': u'\\xa3 100'}\n         r3 = self.request_class(\"http://www.example.com\", formdata=data, encoding='latin1')\n         self.assertEqual(r3.encoding, 'latin1')\n-        self.assertEqual(r3.body, 'price=%A3+100')\n+        self.assertEqual(r3.body, b'price=%A3+100')\n \n     def test_multi_key_values(self):\n         # using multiples values for a single key\n         data = {'price': u'\\xa3 100', 'colours': ['red', 'blue', 'green']}\n         r3 = self.request_class(\"http://www.example.com\", formdata=data)\n-        self.assertSortedEqual(r3.body.split('&'),\n-            'colours=red&colours=blue&colours=green&price=%C2%A3+100'.split('&'))\n+        self.assertQueryEqual(r3.body,\n+            b'colours=red&colours=blue&colours=green&price=%C2%A3+100')\n \n     def test_from_response_post(self):\n         response = _buildresponse(\n-            \"\"\"<form action=\"post.php\" method=\"POST\">\n+            b\"\"\"<form action=\"post.php\" method=\"POST\">\n             <input type=\"hidden\" name=\"test\" value=\"val1\">\n             <input type=\"hidden\" name=\"test\" value=\"val2\">\n             <input type=\"hidden\" name=\"test2\" value=\"xxx\">\n@@ -225,13 +231,13 @@ class FormRequestTest(RequestTest):\n         req = self.request_class.from_response(response,\n                 formdata={'one': ['two', 'three'], 'six': 'seven'})\n         self.assertEqual(req.method, 'POST')\n-        self.assertEqual(req.headers['Content-type'], 'application/x-www-form-urlencoded')\n+        self.assertEqual(req.headers[b'Content-type'], b'application/x-www-form-urlencoded')\n         self.assertEqual(req.url, \"http://www.example.com/this/post.php\")\n         fs = _qs(req)\n-        self.assertEqual(set(fs[\"test\"]), set([\"val1\", \"val2\"]))\n-        self.assertEqual(set(fs[\"one\"]), set([\"two\", \"three\"]))\n-        self.assertEqual(fs['test2'], ['xxx'])\n-        self.assertEqual(fs['six'], ['seven'])\n+        self.assertEqual(set(fs[b\"test\"]), {b\"val1\", b\"val2\"})\n+        self.assertEqual(set(fs[b\"one\"]), {b\"two\", b\"three\"})\n+        self.assertEqual(fs[b'test2'], [b'xxx'])\n+        self.assertEqual(fs[b'six'], [b'seven'])\n \n     def test_from_response_extra_headers(self):\n         response = _buildresponse(\n@@ -244,8 +250,8 @@ class FormRequestTest(RequestTest):\n                 formdata={'one': ['two', 'three'], 'six': 'seven'},\n                 headers={\"Accept-Encoding\": \"gzip,deflate\"})\n         self.assertEqual(req.method, 'POST')\n-        self.assertEqual(req.headers['Content-type'], 'application/x-www-form-urlencoded')\n-        self.assertEqual(req.headers['Accept-Encoding'], 'gzip,deflate')\n+        self.assertEqual(req.headers['Content-type'], b'application/x-www-form-urlencoded')\n+        self.assertEqual(req.headers['Accept-Encoding'], b'gzip,deflate')\n \n     def test_from_response_get(self):\n         response = _buildresponse(\n@@ -274,8 +280,8 @@ class FormRequestTest(RequestTest):\n             </form>\"\"\")\n         req = self.request_class.from_response(response, formdata={'two': '2'})\n         fs = _qs(req)\n-        self.assertEqual(fs['one'], ['1'])\n-        self.assertEqual(fs['two'], ['2'])\n+        self.assertEqual(fs[b'one'], [b'1'])\n+        self.assertEqual(fs[b'two'], [b'2'])\n \n     def test_from_response_override_method(self):\n         response = _buildresponse(\n@@ -379,7 +385,7 @@ class FormRequestTest(RequestTest):\n         req = self.request_class.from_response(response, \\\n                 clickdata={'name': u'price in \\u00a3'})\n         fs = _qs(req)\n-        self.assertTrue(fs[u'price in \\u00a3'.encode('utf-8')])\n+        self.assertTrue(fs[to_native_str(u'price in \\u00a3')])\n \n     def test_from_response_multiple_forms_clickdata(self):\n         response = _buildresponse(\n@@ -489,9 +495,9 @@ class FormRequestTest(RequestTest):\n             </form>\"\"\")\n         r1 = self.request_class.from_response(response, formdata={'two':'3'})\n         self.assertEqual(r1.method, 'POST')\n-        self.assertEqual(r1.headers['Content-type'], 'application/x-www-form-urlencoded')\n+        self.assertEqual(r1.headers['Content-type'], b'application/x-www-form-urlencoded')\n         fs = _qs(r1)\n-        self.assertEqual(fs, {'one': ['1'], 'two': ['3']})\n+        self.assertEqual(fs, {b'one': [b'1'], b'two': [b'3']})\n \n     def test_from_response_formname_exists(self):\n         response = _buildresponse(\n@@ -506,7 +512,7 @@ class FormRequestTest(RequestTest):\n         r1 = self.request_class.from_response(response, formname=\"form2\")\n         self.assertEqual(r1.method, 'POST')\n         fs = _qs(r1)\n-        self.assertEqual(fs, {'four': ['4'], 'three': ['3']})\n+        self.assertEqual(fs, {b'four': [b'4'], b'three': [b'3']})\n \n     def test_from_response_formname_notexist(self):\n         response = _buildresponse(\n@@ -519,7 +525,7 @@ class FormRequestTest(RequestTest):\n         r1 = self.request_class.from_response(response, formname=\"form3\")\n         self.assertEqual(r1.method, 'POST')\n         fs = _qs(r1)\n-        self.assertEqual(fs, {'one': ['1']})\n+        self.assertEqual(fs, {b'one': [b'1']})\n \n     def test_from_response_formname_errors_formnumber(self):\n         response = _buildresponse(\n@@ -664,11 +670,11 @@ class FormRequestTest(RequestTest):\n             </form>\"\"\")\n         r1 = self.request_class.from_response(response, formxpath=\"//form[@action='post.php']\")\n         fs = _qs(r1)\n-        self.assertEqual(fs['one'], ['1'])\n+        self.assertEqual(fs[b'one'], [b'1'])\n \n         r1 = self.request_class.from_response(response, formxpath=\"//form/input[@name='four']\")\n         fs = _qs(r1)\n-        self.assertEqual(fs['three'], ['3'])\n+        self.assertEqual(fs[b'three'], [b'3'])\n \n         self.assertRaises(ValueError, self.request_class.from_response,\n                           response, formxpath=\"//form/input[@name='abc']\")\n@@ -691,12 +697,12 @@ class XmlRpcRequestTest(RequestTest):\n \n     request_class = XmlRpcRequest\n     default_method = 'POST'\n-    default_headers = {'Content-Type': ['text/xml']}\n+    default_headers = {b'Content-Type': [b'text/xml']}\n \n     def _test_request(self, **kwargs):\n         r = self.request_class('http://scrapytest.org/rpc2', **kwargs)\n-        self.assertEqual(r.headers['Content-Type'], 'text/xml')\n-        self.assertEqual(r.body, xmlrpclib.dumps(**kwargs))\n+        self.assertEqual(r.headers[b'Content-Type'], b'text/xml')\n+        self.assertEqual(r.body, to_bytes(xmlrpclib.dumps(**kwargs)))\n         self.assertEqual(r.method, 'POST')\n         self.assertEqual(r.encoding, kwargs.get('encoding', 'utf-8'))\n         self.assertTrue(r.dont_filter, True)\n@@ -706,11 +712,14 @@ class XmlRpcRequestTest(RequestTest):\n         self._test_request(params=('username', 'password'), methodname='login')\n         self._test_request(params=('response', ), methodresponse='login')\n         self._test_request(params=(u'pas\\xa3',), encoding='utf-8')\n-        self._test_request(params=(u'pas\\xa3',), encoding='latin')\n         self._test_request(params=(None,), allow_none=1)\n         self.assertRaises(TypeError, self._test_request)\n         self.assertRaises(TypeError, self._test_request, params=(None,))\n \n+    @unittest.skipUnless(six.PY2, \"TODO\")\n+    def test_latin1(self):\n+        self._test_request(params=(u'pas\\xa3',), encoding='latin')\n+\n \n if __name__ == \"__main__\":\n     unittest.main()\n\n@@ -1,8 +1,12 @@\n import unittest\n \n+import six\n from w3lib.encoding import resolve_encoding\n-from scrapy.http import Request, Response, TextResponse, HtmlResponse, XmlResponse, Headers\n+\n+from scrapy.http import (Request, Response, TextResponse, HtmlResponse,\n+                         XmlResponse, Headers)\n from scrapy.selector import Selector\n+from scrapy.utils.python import to_native_str\n \n \n class BaseResponseTest(unittest.TestCase):\n@@ -14,10 +18,10 @@ class BaseResponseTest(unittest.TestCase):\n         self.assertRaises(Exception, self.response_class)\n         self.assertTrue(isinstance(self.response_class('http://example.com/'), self.response_class))\n         # body can be str or None\n-        self.assertTrue(isinstance(self.response_class('http://example.com/', body=''), self.response_class))\n-        self.assertTrue(isinstance(self.response_class('http://example.com/', body='body'), self.response_class))\n+        self.assertTrue(isinstance(self.response_class('http://example.com/', body=b''), self.response_class))\n+        self.assertTrue(isinstance(self.response_class('http://example.com/', body=b'body'), self.response_class))\n         # test presence of all optional parameters\n-        self.assertTrue(isinstance(self.response_class('http://example.com/', headers={}, status=200, body=''), self.response_class))\n+        self.assertTrue(isinstance(self.response_class('http://example.com/', body=b'', headers={}, status=200), self.response_class))\n \n         r = self.response_class(\"http://www.example.com\")\n         assert isinstance(r.url, str)\n@@ -27,12 +31,12 @@ class BaseResponseTest(unittest.TestCase):\n         assert isinstance(r.headers, Headers)\n         self.assertEqual(r.headers, {})\n \n-        headers = {\"caca\": \"coco\"}\n-        body = \"a body\"\n+        headers = {\"foo\": \"bar\"}\n+        body = b\"a body\"\n         r = self.response_class(\"http://www.example.com\", headers=headers, body=body)\n \n         assert r.headers is not headers\n-        self.assertEqual(r.headers[\"caca\"], \"coco\")\n+        self.assertEqual(r.headers[b\"foo\"], b\"bar\")\n \n         r = self.response_class(\"http://www.example.com\", status=301)\n         self.assertEqual(r.status, 301)\n@@ -43,7 +47,7 @@ class BaseResponseTest(unittest.TestCase):\n     def test_copy(self):\n         \"\"\"Test Response copy\"\"\"\n \n-        r1 = self.response_class(\"http://www.example.com\", body=\"Some body\")\n+        r1 = self.response_class(\"http://www.example.com\", body=b\"Some body\")\n         r1.flags.append('cached')\n         r2 = r1.copy()\n \n@@ -61,7 +65,7 @@ class BaseResponseTest(unittest.TestCase):\n     def test_copy_meta(self):\n         req = Request(\"http://www.example.com\")\n         req.meta['foo'] = 'bar'\n-        r1 = self.response_class(\"http://www.example.com\", body=\"Some body\", request=req)\n+        r1 = self.response_class(\"http://www.example.com\", body=b\"Some body\", request=req)\n         assert r1.meta is req.meta\n \n     def test_copy_inherited_classes(self):\n@@ -79,30 +83,30 @@ class BaseResponseTest(unittest.TestCase):\n         \"\"\"Test Response.replace() method\"\"\"\n         hdrs = Headers({\"key\": \"value\"})\n         r1 = self.response_class(\"http://www.example.com\")\n-        r2 = r1.replace(status=301, body=\"New body\", headers=hdrs)\n-        assert r1.body == ''\n+        r2 = r1.replace(status=301, body=b\"New body\", headers=hdrs)\n+        assert r1.body == b''\n         self.assertEqual(r1.url, r2.url)\n         self.assertEqual((r1.status, r2.status), (200, 301))\n-        self.assertEqual((r1.body, r2.body), ('', \"New body\"))\n+        self.assertEqual((r1.body, r2.body), (b'', b\"New body\"))\n         self.assertEqual((r1.headers, r2.headers), ({}, hdrs))\n \n         # Empty attributes (which may fail if not compared properly)\n         r3 = self.response_class(\"http://www.example.com\", flags=['cached'])\n-        r4 = r3.replace(body='', flags=[])\n-        self.assertEqual(r4.body, '')\n+        r4 = r3.replace(body=b'', flags=[])\n+        self.assertEqual(r4.body, b'')\n         self.assertEqual(r4.flags, [])\n \n     def _assert_response_values(self, response, encoding, body):\n-        if isinstance(body, unicode):\n+        if isinstance(body, six.text_type):\n             body_unicode = body\n-            body_str = body.encode(encoding)\n+            body_bytes = body.encode(encoding)\n         else:\n             body_unicode = body.decode(encoding)\n-            body_str = body\n+            body_bytes = body\n \n-        assert isinstance(response.body, str)\n+        assert isinstance(response.body, bytes)\n         self._assert_response_encoding(response, encoding)\n-        self.assertEqual(response.body, body_str)\n+        self.assertEqual(response.body, body_bytes)\n         self.assertEqual(response.body_as_unicode(), body_unicode)\n \n     def _assert_response_encoding(self, response, encoding):\n@@ -120,12 +124,6 @@ class BaseResponseTest(unittest.TestCase):\n         self.assertEqual(joined, absolute)\n \n \n-class ResponseText(BaseResponseTest):\n-\n-    def test_no_unicode_url(self):\n-        self.assertRaises(TypeError, self.response_class, u'http://www.example.com')\n-\n-\n class TextResponseTest(BaseResponseTest):\n \n     response_class = TextResponse\n@@ -152,11 +150,11 @@ class TextResponseTest(BaseResponseTest):\n         assert isinstance(resp.url, str)\n \n         resp = self.response_class(url=u\"http://www.example.com/price/\\xa3\", encoding='utf-8')\n-        self.assertEqual(resp.url, 'http://www.example.com/price/\\xc2\\xa3')\n+        self.assertEqual(resp.url, to_native_str(b'http://www.example.com/price/\\xc2\\xa3'))\n         resp = self.response_class(url=u\"http://www.example.com/price/\\xa3\", encoding='latin-1')\n         self.assertEqual(resp.url, 'http://www.example.com/price/\\xa3')\n         resp = self.response_class(u\"http://www.example.com/price/\\xa3\", headers={\"Content-type\": [\"text/html; charset=utf-8\"]})\n-        self.assertEqual(resp.url, 'http://www.example.com/price/\\xc2\\xa3')\n+        self.assertEqual(resp.url, to_native_str(b'http://www.example.com/price/\\xc2\\xa3'))\n         resp = self.response_class(u\"http://www.example.com/price/\\xa3\", headers={\"Content-type\": [\"text/html; charset=iso-8859-1\"]})\n         self.assertEqual(resp.url, 'http://www.example.com/price/\\xa3')\n \n@@ -168,17 +166,17 @@ class TextResponseTest(BaseResponseTest):\n         r1 = self.response_class('http://www.example.com', body=original_string, encoding='cp1251')\n \n         # check body_as_unicode\n-        self.assertTrue(isinstance(r1.body_as_unicode(), unicode))\n+        self.assertTrue(isinstance(r1.body_as_unicode(), six.text_type))\n         self.assertEqual(r1.body_as_unicode(), unicode_string)\n \n     def test_encoding(self):\n-        r1 = self.response_class(\"http://www.example.com\", headers={\"Content-type\": [\"text/html; charset=utf-8\"]}, body=\"\\xc2\\xa3\")\n+        r1 = self.response_class(\"http://www.example.com\", headers={\"Content-type\": [\"text/html; charset=utf-8\"]}, body=b\"\\xc2\\xa3\")\n         r2 = self.response_class(\"http://www.example.com\", encoding='utf-8', body=u\"\\xa3\")\n-        r3 = self.response_class(\"http://www.example.com\", headers={\"Content-type\": [\"text/html; charset=iso-8859-1\"]}, body=\"\\xa3\")\n-        r4 = self.response_class(\"http://www.example.com\", body=\"\\xa2\\xa3\")\n-        r5 = self.response_class(\"http://www.example.com\", headers={\"Content-type\": [\"text/html; charset=None\"]}, body=\"\\xc2\\xa3\")\n-        r6 = self.response_class(\"http://www.example.com\", headers={\"Content-type\": [\"text/html; charset=gb2312\"]}, body=\"\\xa8D\")\n-        r7 = self.response_class(\"http://www.example.com\", headers={\"Content-type\": [\"text/html; charset=gbk\"]}, body=\"\\xa8D\")\n+        r3 = self.response_class(\"http://www.example.com\", headers={\"Content-type\": [\"text/html; charset=iso-8859-1\"]}, body=b\"\\xa3\")\n+        r4 = self.response_class(\"http://www.example.com\", body=b\"\\xa2\\xa3\")\n+        r5 = self.response_class(\"http://www.example.com\", headers={\"Content-type\": [\"text/html; charset=None\"]}, body=b\"\\xc2\\xa3\")\n+        r6 = self.response_class(\"http://www.example.com\", headers={\"Content-type\": [\"text/html; charset=gb2312\"]}, body=b\"\\xa8D\")\n+        r7 = self.response_class(\"http://www.example.com\", headers={\"Content-type\": [\"text/html; charset=gbk\"]}, body=b\"\\xa8D\")\n \n         self.assertEqual(r1._headers_encoding(), \"utf-8\")\n         self.assertEqual(r2._headers_encoding(), None)\n@@ -203,21 +201,21 @@ class TextResponseTest(BaseResponseTest):\n         \"\"\"Check that unknown declared encodings are ignored\"\"\"\n         r = self.response_class(\"http://www.example.com\",\n                                 headers={\"Content-type\": [\"text/html; charset=UKNOWN\"]},\n-                                body=\"\\xc2\\xa3\")\n+                                body=b\"\\xc2\\xa3\")\n         self.assertEqual(r._declared_encoding(), None)\n         self._assert_response_values(r, 'utf-8', u\"\\xa3\")\n \n     def test_utf16(self):\n         \"\"\"Test utf-16 because UnicodeDammit is known to have problems with\"\"\"\n         r = self.response_class(\"http://www.example.com\",\n-                                body='\\xff\\xfeh\\x00i\\x00',\n+                                body=b'\\xff\\xfeh\\x00i\\x00',\n                                 encoding='utf-16')\n         self._assert_response_values(r, 'utf-16', u\"hi\")\n \n     def test_invalid_utf8_encoded_body_with_valid_utf8_BOM(self):\n         r6 = self.response_class(\"http://www.example.com\",\n                                  headers={\"Content-type\": [\"text/html; charset=utf-8\"]},\n-                                 body=\"\\xef\\xbb\\xbfWORD\\xe3\\xab\")\n+                                 body=b\"\\xef\\xbb\\xbfWORD\\xe3\\xab\")\n         self.assertEqual(r6.encoding, 'utf-8')\n         self.assertEqual(r6.body_as_unicode(), u'WORD\\ufffd\\ufffd')\n \n@@ -227,7 +225,7 @@ class TextResponseTest(BaseResponseTest):\n         # response.body_as_unicode() in indistint order doesn't affect final\n         # values for encoding and decoded body.\n         url = 'http://example.com'\n-        body = \"\\xef\\xbb\\xbfWORD\"\n+        body = b\"\\xef\\xbb\\xbfWORD\"\n         headers = {\"Content-type\": [\"text/html; charset=utf-8\"]}\n \n         # Test response without content-type and BOM encoding\n@@ -250,7 +248,7 @@ class TextResponseTest(BaseResponseTest):\n \n     def test_replace_wrong_encoding(self):\n         \"\"\"Test invalid chars are replaced properly\"\"\"\n-        r = self.response_class(\"http://www.example.com\", encoding='utf-8', body='PREFIX\\xe3\\xabSUFFIX')\n+        r = self.response_class(\"http://www.example.com\", encoding='utf-8', body=b'PREFIX\\xe3\\xabSUFFIX')\n         # XXX: Policy for replacing invalid chars may suffer minor variations\n         # but it should always contain the unicode replacement char (u'\\ufffd')\n         assert u'\\ufffd' in r.body_as_unicode(), repr(r.body_as_unicode())\n@@ -259,7 +257,7 @@ class TextResponseTest(BaseResponseTest):\n \n         # Do not destroy html tags due to encoding bugs\n         r = self.response_class(\"http://example.com\", encoding='utf-8', \\\n-                body='\\xf0<span>value</span>')\n+                body=b'\\xf0<span>value</span>')\n         assert u'<span>value</span>' in r.body_as_unicode(), repr(r.body_as_unicode())\n \n         # FIXME: This test should pass once we stop using BeautifulSoup's UnicodeDammit in TextResponse\n@@ -267,7 +265,7 @@ class TextResponseTest(BaseResponseTest):\n         #assert u'\\ufffd' in r.body_as_unicode(), repr(r.body_as_unicode())\n \n     def test_selector(self):\n-        body = \"<html><head><title>Some page</title><body></body></html>\"\n+        body = b\"<html><head><title>Some page</title><body></body></html>\"\n         response = self.response_class(\"http://www.example.com\", body=body)\n \n         self.assertIsInstance(response.selector, Selector)\n@@ -289,7 +287,7 @@ class TextResponseTest(BaseResponseTest):\n         )\n \n     def test_selector_shortcuts(self):\n-        body = \"<html><head><title>Some page</title><body></body></html>\"\n+        body = b\"<html><head><title>Some page</title><body></body></html>\"\n         response = self.response_class(\"http://www.example.com\", body=body)\n \n         self.assertEqual(\n@@ -303,17 +301,17 @@ class TextResponseTest(BaseResponseTest):\n \n     def test_urljoin_with_base_url(self):\n         \"\"\"Test urljoin shortcut which also evaluates base-url through get_base_url().\"\"\"\n-        body = '<html><body><base href=\"https://example.net\"></body></html>'\n+        body = b'<html><body><base href=\"https://example.net\"></body></html>'\n         joined = self.response_class('http://www.example.com', body=body).urljoin('/test')\n         absolute = 'https://example.net/test'\n         self.assertEqual(joined, absolute)\n \n-        body = '<html><body><base href=\"/elsewhere\"></body></html>'\n+        body = b'<html><body><base href=\"/elsewhere\"></body></html>'\n         joined = self.response_class('http://www.example.com', body=body).urljoin('test')\n         absolute = 'http://www.example.com/test'\n         self.assertEqual(joined, absolute)\n \n-        body = '<html><body><base href=\"/elsewhere/\"></body></html>'\n+        body = b'<html><body><base href=\"/elsewhere/\"></body></html>'\n         joined = self.response_class('http://www.example.com', body=body).urljoin('test')\n         absolute = 'http://www.example.com/elsewhere/test'\n         self.assertEqual(joined, absolute)\n@@ -325,13 +323,13 @@ class HtmlResponseTest(TextResponseTest):\n \n     def test_html_encoding(self):\n \n-        body = \"\"\"<html><head><title>Some page</title><meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n+        body = b\"\"\"<html><head><title>Some page</title><meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n         </head><body>Price: \\xa3100</body></html>'\n         \"\"\"\n         r1 = self.response_class(\"http://www.example.com\", body=body)\n         self._assert_response_values(r1, 'iso-8859-1', body)\n \n-        body = \"\"\"<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n+        body = b\"\"\"<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n         <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n         Price: \\xa3100\n         \"\"\"\n@@ -339,19 +337,19 @@ class HtmlResponseTest(TextResponseTest):\n         self._assert_response_values(r2, 'iso-8859-1', body)\n \n         # for conflicting declarations headers must take precedence\n-        body = \"\"\"<html><head><title>Some page</title><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n+        body = b\"\"\"<html><head><title>Some page</title><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n         </head><body>Price: \\xa3100</body></html>'\n         \"\"\"\n         r3 = self.response_class(\"http://www.example.com\", headers={\"Content-type\": [\"text/html; charset=iso-8859-1\"]}, body=body)\n         self._assert_response_values(r3, 'iso-8859-1', body)\n \n         # make sure replace() preserves the encoding of the original response\n-        body = \"New body \\xa3\"\n+        body = b\"New body \\xa3\"\n         r4 = r3.replace(body=body)\n         self._assert_response_values(r4, 'iso-8859-1', body)\n \n     def test_html5_meta_charset(self):\n-        body = \"\"\"<html><head><meta charset=\"gb2312\" /><title>Some page</title><body>bla bla</body>\"\"\"\n+        body = b\"\"\"<html><head><meta charset=\"gb2312\" /><title>Some page</title><body>bla bla</body>\"\"\"\n         r1 = self.response_class(\"http://www.example.com\", body=body)\n         self._assert_response_values(r1, 'gb2312', body)\n \n@@ -361,26 +359,25 @@ class XmlResponseTest(TextResponseTest):\n     response_class = XmlResponse\n \n     def test_xml_encoding(self):\n-\n-        body = \"<xml></xml>\"\n+        body = b\"<xml></xml>\"\n         r1 = self.response_class(\"http://www.example.com\", body=body)\n         self._assert_response_values(r1, self.response_class._DEFAULT_ENCODING, body)\n \n-        body = \"\"\"<?xml version=\"1.0\" encoding=\"iso-8859-1\"?><xml></xml>\"\"\"\n+        body = b\"\"\"<?xml version=\"1.0\" encoding=\"iso-8859-1\"?><xml></xml>\"\"\"\n         r2 = self.response_class(\"http://www.example.com\", body=body)\n         self._assert_response_values(r2, 'iso-8859-1', body)\n \n         # make sure replace() preserves the explicit encoding passed in the constructor\n-        body = \"\"\"<?xml version=\"1.0\" encoding=\"iso-8859-1\"?><xml></xml>\"\"\"\n+        body = b\"\"\"<?xml version=\"1.0\" encoding=\"iso-8859-1\"?><xml></xml>\"\"\"\n         r3 = self.response_class(\"http://www.example.com\", body=body, encoding='utf-8')\n-        body2 = \"New body\"\n+        body2 = b\"New body\"\n         r4 = r3.replace(body=body2)\n         self._assert_response_values(r4, 'utf-8', body2)\n \n     def test_replace_encoding(self):\n         # make sure replace() keeps the previous encoding unless overridden explicitly\n-        body = \"\"\"<?xml version=\"1.0\" encoding=\"iso-8859-1\"?><xml></xml>\"\"\"\n-        body2 = \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?><xml></xml>\"\"\"\n+        body = b\"\"\"<?xml version=\"1.0\" encoding=\"iso-8859-1\"?><xml></xml>\"\"\"\n+        body2 = b\"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?><xml></xml>\"\"\"\n         r5 = self.response_class(\"http://www.example.com\", body=body)\n         r6 = r5.replace(body=body2)\n         r7 = r5.replace(body=body2, encoding='utf-8')\n@@ -389,7 +386,7 @@ class XmlResponseTest(TextResponseTest):\n         self._assert_response_values(r7, 'utf-8', body2)\n \n     def test_selector(self):\n-        body = '<?xml version=\"1.0\" encoding=\"utf-8\"?><xml><elem>value</elem></xml>'\n+        body = b'<?xml version=\"1.0\" encoding=\"utf-8\"?><xml><elem>value</elem></xml>'\n         response = self.response_class(\"http://www.example.com\", body=body)\n \n         self.assertIsInstance(response.selector, Selector)\n@@ -403,15 +400,10 @@ class XmlResponseTest(TextResponseTest):\n         )\n \n     def test_selector_shortcuts(self):\n-        body = '<?xml version=\"1.0\" encoding=\"utf-8\"?><xml><elem>value</elem></xml>'\n+        body = b'<?xml version=\"1.0\" encoding=\"utf-8\"?><xml><elem>value</elem></xml>'\n         response = self.response_class(\"http://www.example.com\", body=body)\n \n         self.assertEqual(\n             response.xpath(\"//elem/text()\").extract(),\n             response.selector.xpath(\"//elem/text()\").extract(),\n         )\n-\n-\n-\n-if __name__ == \"__main__\":\n-    unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
