{"custom_id": "flask#9c82840f5256e8aca82c26ab4025712e5c928977", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 12 | Churn Cumulative: 111 | Contributors (this commit): 1 | Commits (past 90d): 4 | Contributors (cumulative): 1 | DMM Complexity: 0.75\n\nDIFF:\n@@ -17,7 +17,9 @@ class ExtImportHookTestCase(FlaskTestCase):\n \n     def setup(self):\n         for entry, value in sys.modules.items():\n-            if entry.startswith('flask.ext.') and value is not None:\n+            if (entry.startswith('flask.ext.') or\n+                entry.startswith('flask_') or\n+                entry.startswith('flaskext.')) and value is not None:\n                 sys.modules.pop(entry, None)\n         from flask import ext\n         reload(ext)\n@@ -54,6 +56,10 @@ class ExtImportHookTestCase(FlaskTestCase):\n         self.assert_equal(newext_package.ext_id, 'newext_package')\n         self.assert_equal(newext_package.__name__, 'flask_newext_package')\n \n+    def test_flaskext_new_package_import_submodule_function(self):\n+        from flask.ext.newext_package.submodule import test_function\n+        self.assert_equal(test_function(), 42)\n+\n     def test_flaskext_new_package_import_submodule(self):\n         from flask.ext.newext_package import submodule\n         self.assert_equal(submodule.__name__, 'flask_newext_package.submodule')\n@@ -82,6 +88,10 @@ class ExtImportHookTestCase(FlaskTestCase):\n         self.assert_equal(submodule.__name__, 'flaskext.oldext_package.submodule')\n         self.assert_equal(submodule.test_function(), 42)\n \n+    def test_flaskext_old_package_import_submodule_function(self):\n+        from flask.ext.oldext_package.submodule import test_function\n+        self.assert_equal(test_function(), 42)\n+\n \n def suite():\n     suite = unittest.TestSuite()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#d4d6cc8401b94ab7c92b70ca5e5b21d22636dd5d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 10 | Files Changed: 1 | Hunks: 5 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 17 | Churn Cumulative: 202 | Contributors (this commit): 4 | Commits (past 90d): 9 | Contributors (cumulative): 4 | DMM Complexity: 1.0\n\nDIFF:\n@@ -49,7 +49,7 @@ class run_audit(Command):\n     user_options = []\n \n     def initialize_options(self):\n-        all = None\n+        pass\n \n     def finalize_options(self):\n         pass\n@@ -62,22 +62,19 @@ class run_audit(Command):\n             print \"Audit requires PyFlakes installed in your system.\"\"\"\n             sys.exit(-1)\n \n-        dirs = ['flask', 'tests']\n-        # Add example directories\n-        for dir in ['flaskr', 'jqueryexample', 'minitwit']:\n-            dirs.append(os.path.join('examples', dir))\n-        # TODO: Add test subdirectories\n         warns = 0\n+        # Define top-level directories\n+        dirs = ('flask', 'examples', 'scripts')\n         for dir in dirs:\n-            for filename in os.listdir(dir):\n-                if filename.endswith('.py') and filename != '__init__.py':\n-                    warns += flakes.checkPath(os.path.join(dir, filename))\n+            for root, _, files in os.walk(dir):\n+                for file in files:\n+                    if file != '__init__.py' and file.endswith('.py') :\n+                        warns += flakes.checkPath(os.path.join(root, file))\n         if warns > 0:\n             print (\"Audit finished with total %d warnings.\" % warns)\n         else:\n             print (\"No problems found in sourcecode.\")\n \n-\n setup(\n     name='Flask',\n     version='0.8-dev',\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#907c24e6ffc436971d437b0b9122b840db9466d7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 7 | Churn Cumulative: 2524 | Contributors (this commit): 14 | Commits (past 90d): 55 | Contributors (cumulative): 14 | DMM Complexity: None\n\nDIFF:\n@@ -657,7 +657,7 @@ class Flask(_PackageBoundObject):\n         # existing views.\n         context.update(orig_ctx)\n \n-    def run(self, host='127.0.0.1', port=5000, **options):\n+    def run(self, host='127.0.0.1', port=5000, debug=None, **options):\n         \"\"\"Runs the application on a local development server.  If the\n         :attr:`debug` flag is set the server will automatically reload\n         for code changes and show a debugger in case an exception happened.\n@@ -680,14 +680,15 @@ class Flask(_PackageBoundObject):\n         :param host: the hostname to listen on.  set this to ``'0.0.0.0'``\n                      to have the server available externally as well.\n         :param port: the port of the webserver\n+        :param debug: if given, enable or disable debug mode.\n         :param options: the options to be forwarded to the underlying\n                         Werkzeug server.  See\n                         :func:`werkzeug.serving.run_simple` for more\n                         information.\n         \"\"\"\n         from werkzeug.serving import run_simple\n-        if 'debug' in options:\n-            self.debug = options.pop('debug')\n+        if debug is not None:\n+            self.debug = bool(debug)\n         options.setdefault('use_reloader', self.debug)\n         options.setdefault('use_debugger', self.debug)\n         try:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#90884a78fbba4068fa93f87626baccd148cd4a57", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 2525 | Contributors (this commit): 14 | Commits (past 90d): 42 | Contributors (cumulative): 14 | DMM Complexity: None\n\nDIFF:\n@@ -681,6 +681,7 @@ class Flask(_PackageBoundObject):\n                      to have the server available externally as well.\n         :param port: the port of the webserver\n         :param debug: if given, enable or disable debug mode.\n+                      See :attr:`debug`.\n         :param options: the options to be forwarded to the underlying\n                         Werkzeug server.  See\n                         :func:`werkzeug.serving.run_simple` for more\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#7997bae5bb048e4623647c57faae447b28da907f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 21 | Lines Deleted: 33 | Files Changed: 1 | Hunks: 8 | Methods Changed: 4 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 54 | Churn Cumulative: 127 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 1 | DMM Complexity: 0.0\n\nDIFF:\n@@ -14,39 +14,30 @@\n     :copyright: (c) 2011 by Armin Ronacher.\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n+import sys\n+import imp\n+\n+\n+ext_module = imp.new_module('flask.ext')\n+ext_module.__path__ = []\n+ext_module.__package__ = ext_module.__name__\n \n \n class _ExtensionImporter(object):\n-    \"\"\"This importer redirects imports from this submodule to other locations.\n-    This makes it possible to transition from the old flaskext.name to the\n-    newer flask_name without people having a hard time.\n+    \"\"\"This importer redirects imports from the flask.ext module to other\n+    locations.\n     \"\"\"\n     _module_choices = ['flask_%s', 'flaskext.%s']\n-\n-    def __init__(self):\n-        from sys import meta_path\n-        self.prefix = __name__ + '.'\n-        self.prefix_cutoff = __name__.count('.') + 1\n-\n-        # since people might reload the flask.ext module (by accident or\n-        # intentionally) we have to make sure to not add more than one\n-        # import hook.  We can't check class types here either since a new\n-        # class will be created on reload.  As a result of that we check\n-        # the name of the class and remove stale instances.\n-        def _name(x):\n-            cls = type(x)\n-            return cls.__module__ + '.' + cls.__name__\n-        this = _name(self)\n-        meta_path[:] = [x for x in meta_path if _name(x) != this] + [self]\n+    prefix = ext_module.__name__ + '.'\n+    prefix_cutoff = prefix.count('.')\n \n     def find_module(self, fullname, path=None):\n         if fullname.startswith(self.prefix):\n             return self\n \n     def load_module(self, fullname):\n-        from sys import modules\n-        if fullname in modules:\n-            return modules[fullname]\n+        if fullname in sys.modules:\n+            return sys.modules[fullname]\n         modname = fullname.split('.', self.prefix_cutoff)[self.prefix_cutoff]\n         for path in self._module_choices:\n             realname = path % modname\n@@ -54,20 +45,17 @@ class _ExtensionImporter(object):\n                 __import__(realname)\n             except ImportError:\n                 continue\n-            module = modules[fullname] = modules[realname]\n+            module = sys.modules[fullname] = sys.modules[realname]\n             if '.' not in modname:\n-                setattr(modules[__name__], modname, module)\n+                setattr(ext_module, modname, module)\n             return module\n         raise ImportError(fullname)\n \n \n-import sys\n+def activate():\n+    \"\"\"Activates the compatibility system.\"\"\"\n     import flask\n-try:\n-    __import__('flask.ext')\n-except ImportError:\n-    sys.modules['flask.ext'] = flask.ext = sys.modules[__name__]\n-    __name__ = __package__ = 'flask.ext'\n-    __path__ = []\n-    _ExtensionImporter()\n-del _ExtensionImporter, sys, flask\n+    if hasattr(flask, 'ext'):\n+        return\n+    sys.modules['flask.ext'] = flask.ext = ext_module\n+    sys.meta_path.append(_ExtensionImporter())\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#9a70e62b8d545c8de7e3728e544cebe289a39254", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 35 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 5 | Methods Changed: 4 | Complexity Δ (Sum/Max): 8/4 | Churn Δ: 38 | Churn Cumulative: 265 | Contributors (this commit): 1 | Commits (past 90d): 8 | Contributors (cumulative): 2 | DMM Complexity: 0.0\n\nDIFF:\n@@ -47,7 +47,7 @@ class _ExtensionImporter(object):\n             return self\n \n     def load_module(self, fullname):\n-        from sys import modules\n+        from sys import modules, exc_info\n         if fullname in modules:\n             return modules[fullname]\n         modname = fullname.split('.', self.prefix_cutoff)[self.prefix_cutoff]\n@@ -56,12 +56,28 @@ class _ExtensionImporter(object):\n             try:\n                 __import__(realname)\n             except ImportError:\n+                exc_type, exc_value, tb = exc_info()\n+                if self.is_important_traceback(realname, tb):\n+                    raise exc_type, exc_value, tb\n                 continue\n             module = modules[fullname] = modules[realname]\n             if '.' not in modname:\n                 setattr(modules[__name__], modname, module)\n             return module\n-        raise ImportError(fullname)\n+        raise ImportError('No module named %s' % fullname)\n+\n+    def is_important_traceback(self, important_module, tb):\n+        \"\"\"Walks a traceback's frames and checks if any of the frames\n+        originated in the given important module.  If that is the case\n+        then we were able to import the module itself but apparently\n+        something went wrong when the module was imported.  (Eg: import\n+        of an import failed).\n+        \"\"\"\n+        while tb is not None:\n+            if tb.tb_frame.f_globals.get('__name__') == important_module:\n+                return True\n+            tb = tb.tb_next\n+        return False\n \n \n _ExtensionImporter()\n\n@@ -44,12 +44,28 @@ class _ExtensionImporter(object):\n             try:\n                 __import__(realname)\n             except ImportError:\n+                exc_type, exc_value, tb = sys.exc_info()\n+                if self.is_important_traceback(realname, tb):\n+                    raise exc_type, exc_value, tb\n                 continue\n             module = sys.modules[fullname] = sys.modules[realname]\n             if '.' not in modname:\n                 setattr(ext_module, modname, module)\n             return module\n-        raise ImportError(fullname)\n+        raise ImportError('No module named %s' % fullname)\n+\n+    def is_important_traceback(self, important_module, tb):\n+        \"\"\"Walks a traceback's frames and checks if any of the frames\n+        originated in the given important module.  If that is the case\n+        then we were able to import the module itself but apparently\n+        something went wrong when the module was imported.  (Eg: import\n+        of an import failed).\n+        \"\"\"\n+        while tb is not None:\n+            if tb.tb_frame.f_globals.get('__name__') == important_module:\n+                return True\n+            tb = tb.tb_next\n+        return False\n \n \n def activate():\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ee9b4016323ba0f7a773a5e014bc23bcf1a322cd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 14 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 14 | Churn Cumulative: 134 | Contributors (this commit): 1 | Commits (past 90d): 6 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -73,6 +73,20 @@ class _ExtensionImporter(object):\n         something went wrong when the module was imported.  (Eg: import\n         of an import failed).\n         \"\"\"\n+        # Why can we access f_globals' __name__ here and the value is\n+        # not None?  I honestly don't know but here is my thinking.\n+        # The module owns a reference to globals and the frame has one.\n+        # Each function only keeps a reference to the globals not do the\n+        # module which normally causes the problem that when the module\n+        # shuts down all globals are set to None.  Now however when the\n+        # import system fails Python takes the short way out and does not\n+        # actually properly shut down the module by Noneing the values\n+        # but by just removing the entry from sys.modules.  This means\n+        # that the regular reference based cleanup kicks in.\n+        #\n+        # The good thing: At worst we will swallow an exception we should\n+        # not and the error message will be messed up.  However I think\n+        # this should be sufficiently reliable.\n         while tb is not None:\n             if tb.tb_frame.f_globals.get('__name__') == important_module:\n                 return True\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#9691b7f0bf70553e61a88c8c7b6ffcac776b8d26", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 49 | Lines Deleted: 7 | Files Changed: 6 | Hunks: 8 | Methods Changed: 8 | Complexity Δ (Sum/Max): 9/7 | Churn Δ: 56 | Churn Cumulative: 705 | Contributors (this commit): 2 | Commits (past 90d): 25 | Contributors (cumulative): 7 | DMM Complexity: 0.92\n\nDIFF:\n@@ -57,6 +57,17 @@ class _ExtensionImporter(object):\n                 __import__(realname)\n             except ImportError:\n                 exc_type, exc_value, tb = exc_info()\n+                # since we only establish the entry in sys.modules at the\n+                # very this seems to be redundant, but if recursive imports\n+                # happen we will call into the move import a second time.\n+                # On the second invocation we still don't have an entry for\n+                # fullname in sys.modules, but we will end up with the same\n+                # fake module name and that import will succeed since this\n+                # one already has a temporary entry in the modules dict.\n+                # Since this one \"succeeded\" temporarily that second\n+                # invocation now will have created a fullname entry in\n+                # sys.modules which we have to kill.\n+                modules.pop(fullname, None)\n                 if self.is_important_traceback(realname, tb):\n                     raise exc_type, exc_value, tb\n                 continue\n\n@@ -134,6 +134,32 @@ class FlaskTestCase(unittest.TestCase):\n     def assert_equal(self, x, y):\n         return self.assertEqual(x, y)\n \n+    def assert_raises(self, exc_type, callable=None, *args, **kwargs):\n+        catcher = _ExceptionCatcher(self, exc_type)\n+        if callable is None:\n+            return catcher\n+        with catcher:\n+            callable(*args, **kwargs)\n+\n+\n+class _ExceptionCatcher(object):\n+\n+    def __init__(self, test_case, exc_type):\n+        self.test_case = test_case\n+        self.exc_type = exc_type\n+\n+    def __enter__(self):\n+        return self\n+\n+    def __exit__(self, exc_type, exc_value, tb):\n+        exception_name = self.exc_type.__name__\n+        if exc_type is None:\n+            self.test_case.fail('Expected exception of type %r' %\n+                                exception_name)\n+        elif not issubclass(exc_type, self.exc_type):\n+            raise exc_type, exc_value, tb\n+        return True\n+\n \n class BetterLoader(unittest.TestLoader):\n     \"\"\"A nicer loader that solves two problems.  First of all we are setting\n\n@@ -8,6 +8,8 @@\n     :copyright: (c) 2011 by Armin Ronacher.\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n+from __future__ import with_statement\n+\n import sys\n import unittest\n from flask.testsuite import FlaskTestCase\n@@ -92,6 +94,11 @@ class ExtImportHookTestCase(FlaskTestCase):\n         from flask.ext.oldext_package.submodule import test_function\n         self.assert_equal(test_function(), 42)\n \n+    def test_flaskext_broken_package_no_module_caching(self):\n+        for x in xrange(2):\n+            with self.assert_raises(ImportError):\n+                import flask.ext.broken\n+\n \n def suite():\n     suite = unittest.TestSuite()\n\n@@ -0,0 +1,2 @@\n+import flask.ext.broken.b\n+import missing_module\n\n\n@@ -25,7 +25,8 @@ ext_module.__package__ = ext_module.__name__\n \n class _ExtensionImporter(object):\n     \"\"\"This importer redirects imports from the flask.ext module to other\n-    locations.\n+    locations.  For implementation details see the code in Flask 0.8\n+    that does the same.\n     \"\"\"\n     _module_choices = ['flask_%s', 'flaskext.%s']\n     prefix = ext_module.__name__ + '.'\n@@ -45,6 +46,7 @@ class _ExtensionImporter(object):\n                 __import__(realname)\n             except ImportError:\n                 exc_type, exc_value, tb = sys.exc_info()\n+                sys.modules.pop(fullname, None)\n                 if self.is_important_traceback(realname, tb):\n                     raise exc_type, exc_value, tb\n                 continue\n@@ -55,12 +57,6 @@ class _ExtensionImporter(object):\n         raise ImportError('No module named %s' % fullname)\n \n     def is_important_traceback(self, important_module, tb):\n-        \"\"\"Walks a traceback's frames and checks if any of the frames\n-        originated in the given important module.  If that is the case\n-        then we were able to import the module itself but apparently\n-        something went wrong when the module was imported.  (Eg: import\n-        of an import failed).\n-        \"\"\"\n         while tb is not None:\n             if tb.tb_frame.f_globals.get('__name__') == important_module:\n                 return True\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#d4d75701bc1ea02a0e9b7e3e0d1aee777bd59116", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 204 | Contributors (this commit): 4 | Commits (past 90d): 10 | Contributors (cumulative): 4 | DMM Complexity: None\n\nDIFF:\n@@ -85,7 +85,7 @@ setup(\n     description='A microframework based on Werkzeug, Jinja2 '\n                 'and good intentions',\n     long_description=__doc__,\n-    packages=['flask', 'flask.testsuite'],\n+    packages=['flask', 'flask.ext', 'flask.testsuite'],\n     include_package_data=True,\n     zip_safe=False,\n     platforms='any',\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#56afafae67ff0db8b9994a4c59d978b56327e886", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 14 | Lines Deleted: 9 | Files Changed: 3 | Hunks: 5 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/1 | Churn Δ: 23 | Churn Cumulative: 579 | Contributors (this commit): 2 | Commits (past 90d): 22 | Contributors (cumulative): 4 | DMM Complexity: 0.0\n\nDIFF:\n@@ -24,7 +24,10 @@ from werkzeug.utils import import_string, find_modules\n \n \n def add_to_path(path):\n-    \"\"\"Adds an entry to sys.path_info if it's not already there.\"\"\"\n+    \"\"\"Adds an entry to sys.path_info if it's not already there.  This does\n+    not append it but moves it to the front so that we can be sure it\n+    is loaded.\n+    \"\"\"\n     if not os.path.isdir(path):\n         raise RuntimeError('Tried to add nonexisting path')\n \n@@ -33,13 +36,8 @@ def add_to_path(path):\n             return os.path.samefile(x, y)\n         except (IOError, OSError):\n             return False\n-    for entry in sys.path:\n-        try:\n-            if os.path.samefile(path, entry):\n-                return\n-        except (OSError, IOError):\n-            pass\n-    sys.path.append(path)\n+    sys.path[:] = [x for x in sys.path if not _samefile(path, x)]\n+    sys.path.insert(0, path)\n \n \n def iter_suites():\n\n@@ -18,10 +18,15 @@ from flask.testsuite import FlaskTestCase\n class ExtImportHookTestCase(FlaskTestCase):\n \n     def setup(self):\n+        # we clear this out for various reasons.  The most important one is\n+        # that a real flaskext could be in there which would disable our\n+        # fake package.  Secondly we want to make sure that the flaskext\n+        # import hook does not break on reloading.\n         for entry, value in sys.modules.items():\n             if (entry.startswith('flask.ext.') or\n                 entry.startswith('flask_') or\n-                entry.startswith('flaskext.')) and value is not None:\n+                entry.startswith('flaskext.') or\n+                entry == 'flaskext') and value is not None:\n                 sys.modules.pop(entry, None)\n         from flask import ext\n         reload(ext)\n\n@@ -1,3 +1,5 @@\n #!/usr/bin/env python\n+import sys, os\n+sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))\n from flask.testsuite import main\n main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#b8ef7360eb80b2018c21384f1f32693ab22595d0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 301 | Contributors (this commit): 3 | Commits (past 90d): 9 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -24,7 +24,7 @@ from werkzeug.utils import import_string, find_modules\n \n \n def add_to_path(path):\n-    \"\"\"Adds an entry to sys.path_info if it's not already there.  This does\n+    \"\"\"Adds an entry to sys.path if it's not already there.  This does\n     not append it but moves it to the front so that we can be sure it\n     is loaded.\n     \"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#d2eefe25e7fec31a5f4254f6a65934bd00ab0392", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 2527 | Contributors (this commit): 14 | Commits (past 90d): 42 | Contributors (cumulative): 14 | DMM Complexity: None\n\nDIFF:\n@@ -466,7 +466,7 @@ class Flask(_PackageBoundObject):\n         if self.import_name == '__main__':\n             fn = getattr(sys.modules['__main__'], '__file__', None)\n             if fn is None:\n-                return 'unknown'\n+                return '__main__'\n             return os.path.splitext(os.path.basename(fn))[0]\n         return self.import_name\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#c6316132b173f96a6f5a90ff3b62f706f8a62560", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 57 | Lines Deleted: 17 | Files Changed: 4 | Hunks: 14 | Methods Changed: 10 | Complexity Δ (Sum/Max): 5/3 | Churn Δ: 74 | Churn Cumulative: 1866 | Contributors (this commit): 6 | Commits (past 90d): 27 | Contributors (cumulative): 12 | DMM Complexity: 1.0\n\nDIFF:\n@@ -89,6 +89,10 @@ class RequestContext(object):\n         self.flashes = None\n         self.session = None\n \n+        # indicator if the context was preserved.  Next time another context\n+        # is pushed the preserved context is popped.\n+        self.preserved = False\n+\n         self.match_request()\n \n         # XXX: Support for deprecated functionality.  This is doing away with\n@@ -114,6 +118,18 @@ class RequestContext(object):\n \n     def push(self):\n         \"\"\"Binds the request context to the current context.\"\"\"\n+        # If an exception ocurrs in debug mode or if context preservation is\n+        # activated under exception situations exactly one context stays\n+        # on the stack.  The rationale is that you want to access that\n+        # information under debug situations.  However if someone forgets to\n+        # pop that context again we want to make sure that on the next push\n+        # it's invalidated otherwise we run at risk that something leaks\n+        # memory.  This is usually only a problem in testsuite since this\n+        # functionality is not active in production environments.\n+        top = _request_ctx_stack.top\n+        if top is not None and top.preserved:\n+            top.pop()\n+\n         _request_ctx_stack.push(self)\n \n         # Open the session at the moment that the request context is\n@@ -128,8 +144,11 @@ class RequestContext(object):\n         also trigger the execution of functions registered by the\n         :meth:`~flask.Flask.teardown_request` decorator.\n         \"\"\"\n+        self.preserved = False\n         self.app.do_teardown_request()\n-        _request_ctx_stack.pop()\n+        rv = _request_ctx_stack.pop()\n+        assert rv is self, 'Popped wrong request context.  (%r instead of %r)' \\\n+            % (rv, self)\n \n     def __enter__(self):\n         self.push()\n@@ -141,6 +160,16 @@ class RequestContext(object):\n         # access the request object in the interactive shell.  Furthermore\n         # the context can be force kept alive for the test client.\n         # See flask.testing for how this works.\n-        if not self.request.environ.get('flask._preserve_context') and \\\n-           (tb is None or not self.app.preserve_context_on_exception):\n+        if self.request.environ.get('flask._preserve_context') or \\\n+           (tb is not None and self.app.preserve_context_on_exception):\n+            self.preserved = True\n+        else:\n             self.pop()\n+\n+    def __repr__(self):\n+        return '<%s \\'%s\\' [%s] of %s>' % (\n+            self.__class__.__name__,\n+            self.request.url,\n+            self.request.method,\n+            self.app.name\n+        )\n\n@@ -19,6 +19,7 @@ def _lookup_object(name):\n         raise RuntimeError('working outside of request context')\n     return getattr(top, name)\n \n+\n # context locals\n _request_ctx_stack = LocalStack()\n current_app = LocalProxy(partial(_lookup_object, 'app'))\n\n@@ -37,7 +37,7 @@ class FlaskClient(Client):\n     Basic usage is outlined in the :ref:`testing` chapter.\n     \"\"\"\n \n-    preserve_context = context_preserved = False\n+    preserve_context = False\n \n     @contextmanager\n     def session_transaction(self, *args, **kwargs):\n@@ -88,7 +88,6 @@ class FlaskClient(Client):\n             self.cookie_jar.extract_wsgi(c.request.environ, headers)\n \n     def open(self, *args, **kwargs):\n-        self._pop_reqctx_if_necessary()\n         kwargs.setdefault('environ_overrides', {}) \\\n             ['flask._preserve_context'] = self.preserve_context\n \n@@ -97,14 +96,10 @@ class FlaskClient(Client):\n         follow_redirects = kwargs.pop('follow_redirects', False)\n         builder = make_test_environ_builder(self.application, *args, **kwargs)\n \n-        old = _request_ctx_stack.top\n-        try:\n         return Client.open(self, builder,\n                            as_tuple=as_tuple,\n                            buffered=buffered,\n                            follow_redirects=follow_redirects)\n-        finally:\n-            self.context_preserved = _request_ctx_stack.top is not old\n \n     def __enter__(self):\n         if self.preserve_context:\n@@ -114,12 +109,10 @@ class FlaskClient(Client):\n \n     def __exit__(self, exc_type, exc_value, tb):\n         self.preserve_context = False\n-        self._pop_reqctx_if_necessary()\n \n-    def _pop_reqctx_if_necessary(self):\n-        if self.context_preserved:\n-            # we have to use _request_ctx_stack.top.pop instead of\n-            # _request_ctx_stack.pop since we want teardown handlers\n-            # to be executed.\n-            _request_ctx_stack.top.pop()\n-            self.context_preserved = False\n+        # on exit we want to clean up earlier.  Normally the request context\n+        # stays preserved until the next request in the same thread comes\n+        # in.  See RequestGlobals.push() for the general behavior.\n+        top = _request_ctx_stack.top\n+        if top is not None and top.preserved:\n+            top.pop()\n\n@@ -904,6 +904,23 @@ class BasicFunctionalityTestCase(FlaskTestCase):\n         self.assertEqual(c.get('/bar/').data, 'bar')\n         self.assertEqual(c.get('/bar/123').data, '123')\n \n+    def test_preserve_only_once(self):\n+        app = flask.Flask(__name__)\n+        app.debug = True\n+\n+        @app.route('/fail')\n+        def fail_func():\n+            1/0\n+\n+        c = app.test_client()\n+        for x in xrange(3):\n+            with self.assert_raises(ZeroDivisionError):\n+                c.get('/fail')\n+\n+        self.assert_(flask._request_ctx_stack.top is not None)\n+        flask._request_ctx_stack.pop()\n+        self.assert_(flask._request_ctx_stack.top is None)\n+\n \n class ContextTestCase(FlaskTestCase):\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#df1dd57045b38ea7dcca44622744ab24e53e399e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 17 | Lines Deleted: 59 | Files Changed: 1 | Hunks: 5 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 76 | Churn Cumulative: 2603 | Contributors (this commit): 14 | Commits (past 90d): 42 | Contributors (cumulative): 14 | DMM Complexity: None\n\nDIFF:\n@@ -824,9 +824,11 @@ class Flask(_PackageBoundObject):\n \n             app.view_functions['index'] = index\n \n-        If a view function is provided some defaults can be specified directly\n-        on the view function.  For more information refer to\n-        :ref:`view-func-options`.\n+        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want\n+        to customize the behavior via subclassing you only need to change\n+        this method.\n+\n+        For more information refer to :ref:`url-route-registrations`.\n \n         .. versionchanged:: 0.2\n            `view_func` parameter added.\n@@ -885,73 +887,29 @@ class Flask(_PackageBoundObject):\n \n     def route(self, rule, **options):\n         \"\"\"A decorator that is used to register a view function for a\n-        given URL rule.  Example::\n+        given URL rule.  This does the same thing as :meth:`add_url_rule`\n+        but is intended for decorator usage::\n \n             @app.route('/')\n             def index():\n                 return 'Hello World'\n \n-        Variables parts in the route can be specified with angular\n-        brackets (``/user/<username>``).  By default a variable part\n-        in the URL accepts any string without a slash however a different\n-        converter can be specified as well by using ``<converter:name>``.\n-\n-        Variable parts are passed to the view function as keyword\n-        arguments.\n-\n-        The following converters are possible:\n-\n-        =========== ===========================================\n-        `int`       accepts integers\n-        `float`     like `int` but for floating point values\n-        `path`      like the default but also accepts slashes\n-        =========== ===========================================\n-\n-        Here some examples::\n-\n-            @app.route('/')\n-            def index():\n-                pass\n-\n-            @app.route('/<username>')\n-            def show_user(username):\n-                pass\n-\n-            @app.route('/post/<int:post_id>')\n-            def show_post(post_id):\n-                pass\n-\n-        An important detail to keep in mind is how Flask deals with trailing\n-        slashes.  The idea is to keep each URL unique so the following rules\n-        apply:\n-\n-        1. If a rule ends with a slash and is requested without a slash\n-           by the user, the user is automatically redirected to the same\n-           page with a trailing slash attached.\n-        2. If a rule does not end with a trailing slash and the user request\n-           the page with a trailing slash, a 404 not found is raised.\n-\n-        This is consistent with how web servers deal with static files.  This\n-        also makes it possible to use relative link targets safely.\n-\n-        The :meth:`route` decorator accepts a couple of other arguments\n-        as well:\n+        For more information refer to :ref:`url-route-registrations`.\n \n         :param rule: the URL rule as string\n-        :param methods: a list of methods this rule should be limited\n+        :param endpoint: the endpoint for the registered URL rule.  Flask\n+                         itself assumes the name of the view function as\n+                         endpoint\n+        :param view_func: the function to call when serving a request to the\n+                          provided endpoint\n+        :param options: the options to be forwarded to the underlying\n+                        :class:`~werkzeug.routing.Rule` object.  A change\n+                        to Werkzeug is handling of method options.  methods\n+                        is a list of methods this rule should be limited\n                         to (`GET`, `POST` etc.).  By default a rule\n                         just listens for `GET` (and implicitly `HEAD`).\n                         Starting with Flask 0.6, `OPTIONS` is implicitly\n                         added and handled by the standard request handling.\n-        :param subdomain: specifies the rule for the subdomain in case\n-                          subdomain matching is in use.\n-        :param strict_slashes: can be used to disable the strict slashes\n-                               setting for this rule.  See above.\n-        :param endpoint: Since version 0.8 you can also pass the enpoint,\n-                         it will be used instead of generating the endpoint\n-                         from the function name.\n-        :param options: other options to be forwarded to the underlying\n-                        :class:`~werkzeug.routing.Rule` object.\n         \"\"\"\n         def decorator(f):\n             endpoint = options.pop('endpoint', None)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#6dccf775468ea0a849d3c1c3965e3a1db6a36a3f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 26 | Lines Deleted: 9 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 35 | Churn Cumulative: 2638 | Contributors (this commit): 14 | Commits (past 90d): 43 | Contributors (cumulative): 14 | DMM Complexity: 1.0\n\nDIFF:\n@@ -177,15 +177,6 @@ class Flask(_PackageBoundObject):\n     #: `SESSION_COOKIE_NAME` configuration key.  Defaults to ``'session'``\n     session_cookie_name = ConfigAttribute('SESSION_COOKIE_NAME')\n \n-    #: A :class:`~datetime.timedelta` which is used to set the expiration\n-    #: date of a permanent session.  The default is 31 days which makes a\n-    #: permanent session survive for roughly one month.\n-    #:\n-    #: This attribute can also be configured from the config with the\n-    #: `PERMANENT_SESSION_LIFETIME` configuration key.  Defaults to\n-    #: ``timedelta(days=31)``\n-    permanent_session_lifetime = ConfigAttribute('PERMANENT_SESSION_LIFETIME')\n-\n     #: Enable this if you want to use the X-Sendfile feature.  Keep in\n     #: mind that the server has to support this.  This only affects files\n     #: sent with the :func:`send_file` method.\n@@ -495,6 +486,32 @@ class Flask(_PackageBoundObject):\n             return rv\n         return self.debug\n \n+    def _get_permanent_session_lifetime(self):\n+        \"\"\"A :class:`~datetime.timedelta` which is used to set the expiration\n+        date of a permanent session.  The default is 31 days which makes a\n+        permanent session survive for roughly one month.\n+\n+        This attribute can also be configured from the config with the\n+        `PERMANENT_SESSION_LIFETIME` configuration key.  Defaults to\n+        ``timedelta(days=31)``.\n+\n+        If you want to have this value as seconds you can use ``total_seconds()``::\n+\n+            app.permanent_session_lifetime.total_seconds()\n+\n+        Note that the config key can be a timedelta object or number of seconds\n+        as integer since Flask 0.8.\n+        \"\"\"\n+        rv = self.config['PERMANENT_SESSION_LIFETIME']\n+        if not isinstance(rv, timedelta):\n+            return timedelta(seconds=rv)\n+        return rv\n+    def _set_permanent_session_lifetime(self, value):\n+        self.config['PERMANENT_SESSION_LIFETIME'] = value\n+    permanent_session_lifetime = property(_get_permanent_session_lifetime,\n+                                          _set_permanent_session_lifetime)\n+    del _get_permanent_session_lifetime, _set_permanent_session_lifetime\n+\n     @property\n     def logger(self):\n         \"\"\"A :class:`logging.Logger` object for this application.  The\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#8da8a21b69cc06e58b1b28fa0ecec63b5cf3d9b4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 27 | Lines Deleted: 28 | Files Changed: 3 | Hunks: 7 | Methods Changed: 7 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 55 | Churn Cumulative: 2950 | Contributors (this commit): 16 | Commits (past 90d): 52 | Contributors (cumulative): 19 | DMM Complexity: 1.0\n\nDIFF:\n@@ -41,6 +41,12 @@ from .signals import request_started, request_finished, got_request_exception, \\\n _logger_lock = Lock()\n \n \n+def _make_timedelta(value):\n+    if not isinstance(value, timedelta):\n+        return timedelta(seconds=value)\n+    return value\n+\n+\n def setupmethod(f):\n     \"\"\"Wraps a method so that it performs a check in debug mode if the\n     first request was already handled.\n@@ -177,6 +183,16 @@ class Flask(_PackageBoundObject):\n     #: `SESSION_COOKIE_NAME` configuration key.  Defaults to ``'session'``\n     session_cookie_name = ConfigAttribute('SESSION_COOKIE_NAME')\n \n+    #: A :class:`~datetime.timedelta` which is used to set the expiration\n+    #: date of a permanent session.  The default is 31 days which makes a\n+    #: permanent session survive for roughly one month.\n+    #:\n+    #: This attribute can also be configured from the config with the\n+    #: `PERMANENT_SESSION_LIFETIME` configuration key.  Defaults to\n+    #: ``timedelta(days=31)``\n+    permanent_session_lifetime = ConfigAttribute('PERMANENT_SESSION_LIFETIME',\n+        get_converter=_make_timedelta)\n+\n     #: Enable this if you want to use the X-Sendfile feature.  Keep in\n     #: mind that the server has to support this.  This only affects files\n     #: sent with the :func:`send_file` method.\n@@ -486,32 +502,6 @@ class Flask(_PackageBoundObject):\n             return rv\n         return self.debug\n \n-    def _get_permanent_session_lifetime(self):\n-        \"\"\"A :class:`~datetime.timedelta` which is used to set the expiration\n-        date of a permanent session.  The default is 31 days which makes a\n-        permanent session survive for roughly one month.\n-\n-        This attribute can also be configured from the config with the\n-        `PERMANENT_SESSION_LIFETIME` configuration key.  Defaults to\n-        ``timedelta(days=31)``.\n-\n-        If you want to have this value as seconds you can use ``total_seconds()``::\n-\n-            app.permanent_session_lifetime.total_seconds()\n-\n-        Note that the config key can be a timedelta object or number of seconds\n-        as integer since Flask 0.8.\n-        \"\"\"\n-        rv = self.config['PERMANENT_SESSION_LIFETIME']\n-        if not isinstance(rv, timedelta):\n-            return timedelta(seconds=rv)\n-        return rv\n-    def _set_permanent_session_lifetime(self, value):\n-        self.config['PERMANENT_SESSION_LIFETIME'] = value\n-    permanent_session_lifetime = property(_get_permanent_session_lifetime,\n-                                          _set_permanent_session_lifetime)\n-    del _get_permanent_session_lifetime, _set_permanent_session_lifetime\n-\n     @property\n     def logger(self):\n         \"\"\"A :class:`logging.Logger` object for this application.  The\n\n@@ -21,13 +21,17 @@ from werkzeug.utils import import_string\n class ConfigAttribute(object):\n     \"\"\"Makes an attribute forward to the config\"\"\"\n \n-    def __init__(self, name):\n+    def __init__(self, name, get_converter=None):\n         self.__name__ = name\n+        self.get_converter = get_converter\n \n     def __get__(self, obj, type=None):\n         if obj is None:\n             return self\n-        return obj.config[self.__name__]\n+        rv = obj.config[self.__name__]\n+        if self.get_converter is not None:\n+            rv = self.get_converter(rv)\n+        return rv\n \n     def __set__(self, obj, value):\n         obj.config[self.__name__] = value\n\n@@ -78,6 +78,11 @@ class ConfigTestCase(FlaskTestCase):\n             self.assert_(0, 'expected config')\n         self.assert_(not app.config.from_pyfile('missing.cfg', silent=True))\n \n+    def test_session_lifetime(self):\n+        app = flask.Flask(__name__)\n+        app.config['PERMANENT_SESSION_LIFETIME'] = 42\n+        self.assert_equal(app.permanent_session_lifetime.total_seconds(), 42)\n+\n \n class InstanceTestCase(FlaskTestCase):\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#f01b654ac4c0a4789369440557267b75df55fd59", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 212 | Contributors (this commit): 1 | Commits (past 90d): 6 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -81,7 +81,7 @@ class ConfigTestCase(FlaskTestCase):\n     def test_session_lifetime(self):\n         app = flask.Flask(__name__)\n         app.config['PERMANENT_SESSION_LIFETIME'] = 42\n-        self.assert_equal(app.permanent_session_lifetime.total_seconds(), 42)\n+        self.assert_equal(app.permanent_session_lifetime.seconds, 42)\n \n \n class InstanceTestCase(FlaskTestCase):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#95c4dcb4d50e69b927855cd6a446579d2fe45b4e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 211 | Lines Deleted: 109 | Files Changed: 4 | Hunks: 18 | Methods Changed: 24 | Complexity Δ (Sum/Max): 24/24 | Churn Δ: 320 | Churn Cumulative: 745 | Contributors (this commit): 1 | Commits (past 90d): 21 | Contributors (cumulative): 4 | DMM Complexity: 1.0\n\nDIFF:\n@@ -19,91 +19,11 @@\n \"\"\"\n \n \n-class _ExtensionImporter(object):\n-    \"\"\"This importer redirects imports from this submodule to other locations.\n-    This makes it possible to transition from the old flaskext.name to the\n-    newer flask_name without people having a hard time.\n-    \"\"\"\n-    _module_choices = ['flask_%s', 'flaskext.%s']\n-\n-    def __init__(self):\n-        from sys import meta_path\n-        self.prefix = __name__ + '.'\n-        self.prefix_cutoff = __name__.count('.') + 1\n-\n-        # since people might reload the flask.ext module (by accident or\n-        # intentionally) we have to make sure to not add more than one\n-        # import hook.  We can't check class types here either since a new\n-        # class will be created on reload.  As a result of that we check\n-        # the name of the class and remove stale instances.\n-        def _name(x):\n-            cls = type(x)\n-            return cls.__module__ + '.' + cls.__name__\n-        this = _name(self)\n-        meta_path[:] = [x for x in meta_path if _name(x) != this] + [self]\n-\n-    def find_module(self, fullname, path=None):\n-        if fullname.startswith(self.prefix):\n-            return self\n-\n-    def load_module(self, fullname):\n-        from sys import modules, exc_info\n-        if fullname in modules:\n-            return modules[fullname]\n-        modname = fullname.split('.', self.prefix_cutoff)[self.prefix_cutoff]\n-        for path in self._module_choices:\n-            realname = path % modname\n-            try:\n-                __import__(realname)\n-            except ImportError:\n-                exc_type, exc_value, tb = exc_info()\n-                # since we only establish the entry in sys.modules at the\n-                # very this seems to be redundant, but if recursive imports\n-                # happen we will call into the move import a second time.\n-                # On the second invocation we still don't have an entry for\n-                # fullname in sys.modules, but we will end up with the same\n-                # fake module name and that import will succeed since this\n-                # one already has a temporary entry in the modules dict.\n-                # Since this one \"succeeded\" temporarily that second\n-                # invocation now will have created a fullname entry in\n-                # sys.modules which we have to kill.\n-                modules.pop(fullname, None)\n-                if self.is_important_traceback(realname, tb):\n-                    raise exc_type, exc_value, tb\n-                continue\n-            module = modules[fullname] = modules[realname]\n-            if '.' not in modname:\n-                setattr(modules[__name__], modname, module)\n-            return module\n-        raise ImportError('No module named %s' % fullname)\n-\n-    def is_important_traceback(self, important_module, tb):\n-        \"\"\"Walks a traceback's frames and checks if any of the frames\n-        originated in the given important module.  If that is the case\n-        then we were able to import the module itself but apparently\n-        something went wrong when the module was imported.  (Eg: import\n-        of an import failed).\n-        \"\"\"\n-        # Why can we access f_globals' __name__ here and the value is\n-        # not None?  I honestly don't know but here is my thinking.\n-        # The module owns a reference to globals and the frame has one.\n-        # Each function only keeps a reference to the globals not do the\n-        # module which normally causes the problem that when the module\n-        # shuts down all globals are set to None.  Now however when the\n-        # import system fails Python takes the short way out and does not\n-        # actually properly shut down the module by Noneing the values\n-        # but by just removing the entry from sys.modules.  This means\n-        # that the regular reference based cleanup kicks in.\n-        #\n-        # The good thing: At worst we will swallow an exception we should\n-        # not and the error message will be messed up.  However I think\n-        # this should be sufficiently reliable.\n-        while tb is not None:\n-            if tb.tb_frame.f_globals.get('__name__') == important_module:\n-                return True\n-            tb = tb.tb_next\n-        return False\n+def setup():\n+    from ..exthook import ExtensionImporter\n+    importer = ExtensionImporter(['flask_%s', 'flaskext.%s'], __name__)\n+    importer.install()\n \n \n-_ExtensionImporter()\n-del _ExtensionImporter\n+setup()\n+del setup\n\n@@ -0,0 +1,119 @@\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+    flask.exthook\n+    ~~~~~~~~~~~~~\n+\n+    Redirect imports for extensions.  This module basically makes it possible\n+    for us to transition from flaskext.foo to flask_foo without having to\n+    force all extensions to upgrade at the same time.\n+\n+    When a user does ``from flask.ext.foo import bar`` it will attempt to\n+    import ``from flask_foo import bar`` first and when that fails it will\n+    try to import ``from flaskext.foo import bar``.\n+\n+    We're switching from namespace packages because it was just too painful for\n+    everybody involved.\n+\n+    This is used by `flask.ext`.\n+\n+    :copyright: (c) 2011 by Armin Ronacher.\n+    :license: BSD, see LICENSE for more details.\n+\"\"\"\n+import sys\n+import os\n+\n+\n+class ExtensionImporter(object):\n+    \"\"\"This importer redirects imports from this submodule to other locations.\n+    This makes it possible to transition from the old flaskext.name to the\n+    newer flask_name without people having a hard time.\n+    \"\"\"\n+\n+    def __init__(self, module_choices, wrapper_module):\n+        self.module_choices = module_choices\n+        self.wrapper_module = wrapper_module\n+        self.prefix = wrapper_module + '.'\n+        self.prefix_cutoff = wrapper_module.count('.') + 1\n+\n+    def __eq__(self, other):\n+        return self.__class__.__module__ == other.__class__.__module__ and \\\n+               self.__class__.__name__ == other.__class__.__name__ and \\\n+               self.wrapper_module == other.wrapper_module and \\\n+               self.module_choices == other.module_choices\n+\n+    def __ne__(self, other):\n+        return not self.__eq__(other)\n+\n+    def install(self):\n+        sys.meta_path[:] = [x for x in sys.meta_path if self != x] + [self]\n+\n+    def find_module(self, fullname, path=None):\n+        if fullname.startswith(self.prefix):\n+            return self\n+\n+    def load_module(self, fullname):\n+        if fullname in sys.modules:\n+            return sys.modules[fullname]\n+        modname = fullname.split('.', self.prefix_cutoff)[self.prefix_cutoff]\n+        for path in self.module_choices:\n+            realname = path % modname\n+            try:\n+                __import__(realname)\n+            except ImportError:\n+                exc_type, exc_value, tb = sys.exc_info()\n+                # since we only establish the entry in sys.modules at the\n+                # very this seems to be redundant, but if recursive imports\n+                # happen we will call into the move import a second time.\n+                # On the second invocation we still don't have an entry for\n+                # fullname in sys.modules, but we will end up with the same\n+                # fake module name and that import will succeed since this\n+                # one already has a temporary entry in the modules dict.\n+                # Since this one \"succeeded\" temporarily that second\n+                # invocation now will have created a fullname entry in\n+                # sys.modules which we have to kill.\n+                sys.modules.pop(fullname, None)\n+\n+                # If it's an important traceback we reraise it, otherwise\n+                # we swallow it and try the next choice.  The skipped frame\n+                # is the one from __import__ above which we don't care about\n+                if self.is_important_traceback(realname, tb):\n+                    raise exc_type, exc_value, tb.tb_next\n+                continue\n+            module = sys.modules[fullname] = sys.modules[realname]\n+            if '.' not in modname:\n+                setattr(sys.modules[self.wrapper_module], modname, module)\n+            return module\n+        raise ImportError('No module named %s' % fullname)\n+\n+    def is_important_traceback(self, important_module, tb):\n+        \"\"\"Walks a traceback's frames and checks if any of the frames\n+        originated in the given important module.  If that is the case then we\n+        were able to import the module itself but apparently something went\n+        wrong when the module was imported.  (Eg: import of an import failed).\n+        \"\"\"\n+        while tb is not None:\n+            if self.is_important_frame(important_module, tb):\n+                return True\n+            tb = tb.tb_next\n+        return False\n+\n+    def is_important_frame(self, important_module, tb):\n+        \"\"\"Checks a single frame if it's important.\"\"\"\n+        g = tb.tb_frame.f_globals\n+        if '__name__' not in g:\n+            return False\n+\n+        module_name = g['__name__']\n+\n+        # Python 2.7 Behavior.  Modules are cleaned up late so the\n+        # name shows up properly here.  Success!\n+        if module_name == important_module:\n+            return True\n+\n+        # Some python verisons will will clean up modules so early that the\n+        # module name at that point is no longer set.  Try guessing from\n+        # the filename then.\n+        filename = os.path.abspath(tb.tb_frame.f_code.co_filename)\n+        test_string = os.path.sep + important_module.replace('.', os.path.sep)\n+        return test_string + '.py' in filename or \\\n+               test_string + os.path.sep + '__init__.py' in filename\n\n@@ -35,8 +35,8 @@ class ExtImportHookTestCase(FlaskTestCase):\n         import_hooks = 0\n         for item in sys.meta_path:\n             cls = type(item)\n-            if cls.__module__ == 'flask.ext' and \\\n-               cls.__name__ == '_ExtensionImporter':\n+            if cls.__module__ == 'flask.exthook' and \\\n+               cls.__name__ == 'ExtensionImporter':\n                 import_hooks += 1\n         self.assert_equal(import_hooks, 1)\n \n@@ -104,6 +104,18 @@ class ExtImportHookTestCase(FlaskTestCase):\n             with self.assert_raises(ImportError):\n                 import flask.ext.broken\n \n+    def test_no_error_swallowing(self):\n+        try:\n+            import flask.ext.broken\n+        except ImportError:\n+            exc_type, exc_value, tb = sys.exc_info()\n+            self.assert_(exc_type is ImportError)\n+            self.assert_equal(str(exc_value), 'No module named missing_module')\n+            self.assert_(tb.tb_frame.f_globals is globals())\n+\n+            next = tb.tb_next\n+            self.assert_('flask_broken/__init__.py' in next.tb_frame.f_code.co_filename)\n+\n \n def suite():\n     suite = unittest.TestSuite()\n\n@@ -15,22 +15,33 @@\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n import sys\n+import os\n import imp\n \n \n-ext_module = imp.new_module('flask.ext')\n-ext_module.__path__ = []\n-ext_module.__package__ = ext_module.__name__\n-\n-\n-class _ExtensionImporter(object):\n-    \"\"\"This importer redirects imports from the flask.ext module to other\n-    locations.  For implementation details see the code in Flask 0.8\n-    that does the same.\n+class ExtensionImporter(object):\n+    \"\"\"This importer redirects imports from this submodule to other locations.\n+    This makes it possible to transition from the old flaskext.name to the\n+    newer flask_name without people having a hard time.\n     \"\"\"\n-    _module_choices = ['flask_%s', 'flaskext.%s']\n-    prefix = ext_module.__name__ + '.'\n-    prefix_cutoff = prefix.count('.')\n+\n+    def __init__(self, module_choices, wrapper_module):\n+        self.module_choices = module_choices\n+        self.wrapper_module = wrapper_module\n+        self.prefix = wrapper_module + '.'\n+        self.prefix_cutoff = wrapper_module.count('.') + 1\n+\n+    def __eq__(self, other):\n+        return self.__class__.__module__ == other.__class__.__module__ and \\\n+               self.__class__.__name__ == other.__class__.__name__ and \\\n+               self.wrapper_module == other.wrapper_module and \\\n+               self.module_choices == other.module_choices\n+\n+    def __ne__(self, other):\n+        return not self.__eq__(other)\n+\n+    def install(self):\n+        sys.meta_path[:] = [x for x in sys.meta_path if self != x] + [self]\n \n     def find_module(self, fullname, path=None):\n         if fullname.startswith(self.prefix):\n@@ -40,34 +51,74 @@ class _ExtensionImporter(object):\n         if fullname in sys.modules:\n             return sys.modules[fullname]\n         modname = fullname.split('.', self.prefix_cutoff)[self.prefix_cutoff]\n-        for path in self._module_choices:\n+        for path in self.module_choices:\n             realname = path % modname\n             try:\n                 __import__(realname)\n             except ImportError:\n                 exc_type, exc_value, tb = sys.exc_info()\n+                # since we only establish the entry in sys.modules at the\n+                # very this seems to be redundant, but if recursive imports\n+                # happen we will call into the move import a second time.\n+                # On the second invocation we still don't have an entry for\n+                # fullname in sys.modules, but we will end up with the same\n+                # fake module name and that import will succeed since this\n+                # one already has a temporary entry in the modules dict.\n+                # Since this one \"succeeded\" temporarily that second\n+                # invocation now will have created a fullname entry in\n+                # sys.modules which we have to kill.\n                 sys.modules.pop(fullname, None)\n+\n+                # If it's an important traceback we reraise it, otherwise\n+                # we swallow it and try the next choice.  The skipped frame\n+                # is the one from __import__ above which we don't care about\n                 if self.is_important_traceback(realname, tb):\n-                    raise exc_type, exc_value, tb\n+                    raise exc_type, exc_value, tb.tb_next\n                 continue\n             module = sys.modules[fullname] = sys.modules[realname]\n             if '.' not in modname:\n-                setattr(ext_module, modname, module)\n+                setattr(sys.modules[self.wrapper_module], modname, module)\n             return module\n         raise ImportError('No module named %s' % fullname)\n \n     def is_important_traceback(self, important_module, tb):\n+        \"\"\"Walks a traceback's frames and checks if any of the frames\n+        originated in the given important module.  If that is the case then we\n+        were able to import the module itself but apparently something went\n+        wrong when the module was imported.  (Eg: import of an import failed).\n+        \"\"\"\n         while tb is not None:\n-            if tb.tb_frame.f_globals.get('__name__') == important_module:\n+            if self.is_important_frame(important_module, tb):\n                 return True\n             tb = tb.tb_next\n         return False\n \n+    def is_important_frame(self, important_module, tb):\n+        \"\"\"Checks a single frame if it's important.\"\"\"\n+        g = tb.tb_frame.f_globals\n+        if '__name__' not in g:\n+            return False\n+\n+        module_name = g['__name__']\n+\n+        # Python 2.7 Behavior.  Modules are cleaned up late so the\n+        # name shows up properly here.  Success!\n+        if module_name == important_module:\n+            return True\n+\n+        # Some python verisons will will clean up modules so early that the\n+        # module name at that point is no longer set.  Try guessing from\n+        # the filename then.\n+        filename = os.path.abspath(tb.tb_frame.f_code.co_filename)\n+        test_string = os.path.sep + important_module.replace('.', os.path.sep)\n+        return test_string + '.py' in filename or \\\n+               test_string + os.path.sep + '__init__.py' in filename\n+\n \n def activate():\n-    \"\"\"Activates the compatibility system.\"\"\"\n     import flask\n-    if hasattr(flask, 'ext'):\n-        return\n-    sys.modules['flask.ext'] = flask.ext = ext_module\n-    sys.meta_path.append(_ExtensionImporter())\n+    ext_module = imp.new_module('flask.ext')\n+    ext_module.__path__ = []\n+    flask.ext = sys.modules['flask.ext'] = ext_module\n+    importer = ExtensionImporter(['flask_%s', 'flaskext.%s'], 'flask.ext')\n+    importer.install()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
