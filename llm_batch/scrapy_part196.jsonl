{"custom_id": "scrapy#7874bb9f13cc4ec797925adc99bf58742071ed6c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 22 | Lines Deleted: 18 | Files Changed: 2 | Hunks: 15 | Methods Changed: 5 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 40 | Churn Cumulative: 134 | Contributors (this commit): 5 | Commits (past 90d): 2 | Contributors (cumulative): 7 | DMM Complexity: 0.0\n\nDIFF:\n@@ -10,6 +10,7 @@ from six.moves.urllib.parse import urlunparse\n \n from twisted.internet.defer import Deferred\n from w3lib.http import basic_auth_header\n+from scrapy.utils.python import to_bytes, to_native_str\n \n from scrapy.utils.url import canonicalize_url\n from scrapy.utils.httpobj import urlparse_cached\n@@ -44,13 +45,14 @@ def request_fingerprint(request, include_headers=None):\n \n     \"\"\"\n     if include_headers:\n-        include_headers = tuple([h.lower() for h in sorted(include_headers)])\n+        include_headers = tuple([to_bytes(h.lower())\n+                                 for h in sorted(include_headers)])\n     cache = _fingerprint_cache.setdefault(request, {})\n     if include_headers not in cache:\n         fp = hashlib.sha1()\n-        fp.update(request.method)\n-        fp.update(canonicalize_url(request.url))\n-        fp.update(request.body or '')\n+        fp.update(to_bytes(request.method))\n+        fp.update(to_bytes(canonicalize_url(request.url)))\n+        fp.update(request.body or b'')\n         if include_headers:\n             for hdr in include_headers:\n                 if hdr in request.headers:\n@@ -60,12 +62,14 @@ def request_fingerprint(request, include_headers=None):\n         cache[include_headers] = fp.hexdigest()\n     return cache[include_headers]\n \n+\n def request_authenticate(request, username, password):\n     \"\"\"Autenticate the given request (in place) using the HTTP basic access\n     authentication mechanism (RFC 2617) and the given username and password\n     \"\"\"\n     request.headers['Authorization'] = basic_auth_header(username, password)\n \n+\n def request_httprepr(request):\n     \"\"\"Return the raw HTTP representation (as string) of the given request.\n     This is provided only for reference since it's not the actual stream of\n@@ -74,11 +78,11 @@ def request_httprepr(request):\n     \"\"\"\n     parsed = urlparse_cached(request)\n     path = urlunparse(('', '', parsed.path or '/', parsed.params, parsed.query, ''))\n-    s  = \"%s %s HTTP/1.1\\r\\n\" % (request.method, path)\n-    s += \"Host: %s\\r\\n\" % parsed.hostname\n+    s = to_bytes(request.method) + b\" \" + to_bytes(path) + b\" HTTP/1.1\\r\\n\"\n+    s += b\"Host: \" + to_bytes(parsed.hostname) + b\"\\r\\n\"\n     if request.headers:\n-        s += request.headers.to_string() + \"\\r\\n\"\n-    s += \"\\r\\n\"\n+        s += request.headers.to_string() + b\"\\r\\n\"\n+    s += b\"\\r\\n\"\n     s += request.body\n     return s\n \n\n@@ -21,15 +21,15 @@ class UtilsRequestTest(unittest.TestCase):\n \n         r1 = Request(\"http://www.example.com/members/offers.html\")\n         r2 = Request(\"http://www.example.com/members/offers.html\")\n-        r2.headers['SESSIONID'] = \"somehash\"\n+        r2.headers['SESSIONID'] = b\"somehash\"\n         self.assertEqual(request_fingerprint(r1), request_fingerprint(r2))\n \n         r1 = Request(\"http://www.example.com/\")\n         r2 = Request(\"http://www.example.com/\")\n-        r2.headers['Accept-Language'] = 'en'\n+        r2.headers['Accept-Language'] = b'en'\n         r3 = Request(\"http://www.example.com/\")\n-        r3.headers['Accept-Language'] = 'en'\n-        r3.headers['SESSIONID'] = \"somehash\"\n+        r3.headers['Accept-Language'] = b'en'\n+        r3.headers['SESSIONID'] = b\"somehash\"\n \n         self.assertEqual(request_fingerprint(r1), request_fingerprint(r2), request_fingerprint(r3))\n \n@@ -44,7 +44,7 @@ class UtilsRequestTest(unittest.TestCase):\n \n         r1 = Request(\"http://www.example.com\")\n         r2 = Request(\"http://www.example.com\", method='POST')\n-        r3 = Request(\"http://www.example.com\", method='POST', body='request body')\n+        r3 = Request(\"http://www.example.com\", method='POST', body=b'request body')\n \n         self.assertNotEqual(request_fingerprint(r1), request_fingerprint(r2))\n         self.assertNotEqual(request_fingerprint(r2), request_fingerprint(r3))\n@@ -59,17 +59,17 @@ class UtilsRequestTest(unittest.TestCase):\n     def test_request_authenticate(self):\n         r = Request(\"http://www.example.com\")\n         request_authenticate(r, 'someuser', 'somepass')\n-        self.assertEqual(r.headers['Authorization'], 'Basic c29tZXVzZXI6c29tZXBhc3M=')\n+        self.assertEqual(r.headers['Authorization'], b'Basic c29tZXVzZXI6c29tZXBhc3M=')\n \n     def test_request_httprepr(self):\n         r1 = Request(\"http://www.example.com\")\n-        self.assertEqual(request_httprepr(r1), 'GET / HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n')\n+        self.assertEqual(request_httprepr(r1), b'GET / HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n')\n \n         r1 = Request(\"http://www.example.com/some/page.html?arg=1\")\n-        self.assertEqual(request_httprepr(r1), 'GET /some/page.html?arg=1 HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n')\n+        self.assertEqual(request_httprepr(r1), b'GET /some/page.html?arg=1 HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n')\n \n-        r1 = Request(\"http://www.example.com\", method='POST', headers={\"Content-type\": \"text/html\"}, body=\"Some body\")\n-        self.assertEqual(request_httprepr(r1), 'POST / HTTP/1.1\\r\\nHost: www.example.com\\r\\nContent-Type: text/html\\r\\n\\r\\nSome body')\n+        r1 = Request(\"http://www.example.com\", method='POST', headers={\"Content-type\": b\"text/html\"}, body=b\"Some body\")\n+        self.assertEqual(request_httprepr(r1), b'POST / HTTP/1.1\\r\\nHost: www.example.com\\r\\nContent-Type: text/html\\r\\n\\r\\nSome body')\n \n if __name__ == \"__main__\":\n     unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#82304c4faeaf7820058f92d74c86411d5f193d5e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 179 | Contributors (this commit): 7 | Commits (past 90d): 2 | Contributors (cumulative): 7 | DMM Complexity: None\n\nDIFF:\n@@ -61,7 +61,7 @@ def parallel(iterable, count, callable, *args, **named):\n     \"\"\"\n     coop = task.Cooperator()\n     work = (callable(elem, *args, **named) for elem in iterable)\n-    return defer.DeferredList([coop.coiterate(work) for i in xrange(count)])\n+    return defer.DeferredList([coop.coiterate(work) for i in range(count)])\n \n def process_chain(callbacks, input, *a, **kw):\n     \"\"\"Return a Deferred built by chaining the given callbacks\"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#776064aee19b545f80c37c45ba64a6332199f583", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 13 | Lines Deleted: 830 | Files Changed: 11 | Hunks: 17 | Methods Changed: 29 | Complexity Δ (Sum/Max): -105/0 | Churn Δ: 843 | Churn Cumulative: 1749 | Contributors (this commit): 14 | Commits (past 90d): 16 | Contributors (cumulative): 41 | DMM Complexity: 0.42857142857142855\n\nDIFF:\n@@ -1,5 +1,5 @@\n from __future__ import absolute_import\n-from scrapy.xlib.pydispatch import dispatcher\n+from pydispatch import dispatcher\n from scrapy.utils import signal as _signal\n \n \n\n@@ -5,19 +5,23 @@ import logging\n from twisted.internet.defer import maybeDeferred, DeferredList, Deferred\n from twisted.python.failure import Failure\n \n-from scrapy.xlib.pydispatch.dispatcher import Any, Anonymous, liveReceivers, \\\n+from pydispatch.dispatcher import Any, Anonymous, liveReceivers, \\\n     getAllReceivers, disconnect\n-from scrapy.xlib.pydispatch.robustapply import robustApply\n+from pydispatch.robustapply import robustApply\n from scrapy.utils.log import failure_to_exc_info\n \n logger = logging.getLogger(__name__)\n \n \n+class _IgnoredException(Exception):\n+    pass\n+\n+\n def send_catch_log(signal=Any, sender=Anonymous, *arguments, **named):\n     \"\"\"Like pydispatcher.robust.sendRobust but it also logs errors and returns\n     Failures instead of exceptions.\n     \"\"\"\n-    dont_log = named.pop('dont_log', None)\n+    dont_log = named.pop('dont_log', _IgnoredException)\n     spider = named.get('spider', None)\n     responses = []\n     for receiver in liveReceivers(getAllReceivers(sender, signal)):\n@@ -39,6 +43,7 @@ def send_catch_log(signal=Any, sender=Anonymous, *arguments, **named):\n         responses.append((receiver, result))\n     return responses\n \n+\n def send_catch_log_deferred(signal=Any, sender=Anonymous, *arguments, **named):\n     \"\"\"Like send_catch_log but supports returning deferreds on signal handlers.\n     Returns a deferred that gets fired once all signal handlers deferreds were\n@@ -65,6 +70,7 @@ def send_catch_log_deferred(signal=Any, sender=Anonymous, *arguments, **named):\n     d.addCallback(lambda out: [x[1] for x in out])\n     return d\n \n+\n def disconnect_all(signal=Any, sender=Any):\n     \"\"\"Disconnect all signal handlers. Useful for cleaning up after running\n     tests\n\n@@ -1,6 +0,0 @@\n-\"\"\"Multi-consumer multi-producer dispatching mechanism\n-\"\"\"\n-__version__ = \"2.0.0\"\n-__author__ = \"Patrick K. O'Brien\"\n-__license__ = \"BSD-style, see license.txt for details\"\n-\n\n@@ -1,511 +0,0 @@\n-\"\"\"Multiple-producer-multiple-consumer signal-dispatching\n-\n-dispatcher is the core of the PyDispatcher system,\n-providing the primary API and the core logic for the\n-system.\n-\n-Module attributes of note:\n-\n-    Any -- Singleton used to signal either \"Any Sender\" or\n-        \"Any Signal\".  See documentation of the _Any class.\n-    Anonymous -- Singleton used to signal \"Anonymous Sender\"\n-        See documentation of the _Anonymous class.\n-\n-Internal attributes:\n-    WEAKREF_TYPES -- tuple of types/classes which represent\n-        weak references to receivers, and thus must be de-\n-        referenced on retrieval to retrieve the callable\n-        object\n-    connections -- { senderkey (id) : { signal : [receivers...]}}\n-    senders -- { senderkey (id) : weakref(sender) }\n-        used for cleaning up sender references on sender\n-        deletion\n-    sendersBack -- { receiverkey (id) : [senderkey (id)...] }\n-        used for cleaning up receiver references on receiver\n-        deletion, (considerably speeds up the cleanup process\n-        vs. the original code.)\n-\"\"\"\n-from __future__ import generators\n-import types, weakref, six\n-from scrapy.xlib.pydispatch import saferef, robustapply, errors\n-\n-__author__ = \"Patrick K. O'Brien <pobrien@orbtech.com>\"\n-__cvsid__ = \"$Id: dispatcher.py,v 1.1.1.1 2006/07/07 15:59:38 mcfletch Exp $\"\n-__version__ = \"$Revision: 1.1.1.1 $\"[11:-2]\n-\n-\n-class _Parameter:\n-    \"\"\"Used to represent default parameter values.\"\"\"\n-\n-    def __repr__(self):\n-        return self.__class__.__name__\n-\n-\n-class _Any(_Parameter):\n-    \"\"\"Singleton used to signal either \"Any Sender\" or \"Any Signal\"\n-\n-    The Any object can be used with connect, disconnect,\n-    send, or sendExact to signal that the parameter given\n-    Any should react to all senders/signals, not just\n-    a particular sender/signal.\n-    \"\"\"\n-\n-\n-Any = _Any()\n-\n-\n-class _Anonymous(_Parameter):\n-    \"\"\"Singleton used to signal \"Anonymous Sender\"\n-\n-    The Anonymous object is used to signal that the sender\n-    of a message is not specified (as distinct from being\n-    \"any sender\").  Registering callbacks for Anonymous\n-    will only receive messages sent without senders.  Sending\n-    with anonymous will only send messages to those receivers\n-    registered for Any or Anonymous.\n-\n-    Note:\n-        The default sender for connect is Any, while the\n-        default sender for send is Anonymous.  This has\n-        the effect that if you do not specify any senders\n-        in either function then all messages are routed\n-        as though there was a single sender (Anonymous)\n-        being used everywhere.\n-    \"\"\"\n-\n-\n-Anonymous = _Anonymous()\n-\n-WEAKREF_TYPES = (weakref.ReferenceType, saferef.BoundMethodWeakref)\n-\n-connections = {}\n-senders = {}\n-sendersBack = {}\n-\n-\n-def connect(receiver, signal=Any, sender=Any, weak=True):\n-    \"\"\"Connect receiver to sender for signal\n-\n-    receiver -- a callable Python object which is to receive\n-        messages/signals/events.  Receivers must be hashable\n-        objects.\n-\n-        if weak is True, then receiver must be weak-referencable\n-        (more precisely saferef.safeRef() must be able to create\n-        a reference to the receiver).\n-\n-        Receivers are fairly flexible in their specification,\n-        as the machinery in the robustApply module takes care\n-        of most of the details regarding figuring out appropriate\n-        subsets of the sent arguments to apply to a given\n-        receiver.\n-\n-        Note:\n-            if receiver is itself a weak reference (a callable),\n-            it will be de-referenced by the system's machinery,\n-            so *generally* weak references are not suitable as\n-            receivers, though some use might be found for the\n-            facility whereby a higher-level library passes in\n-            pre-weakrefed receiver references.\n-\n-    signal -- the signal to which the receiver should respond\n-\n-        if Any, receiver will receive any signal from the\n-        indicated sender (which might also be Any, but is not\n-        necessarily Any).\n-\n-        Otherwise must be a hashable Python object other than\n-        None (DispatcherError raised on None).\n-\n-    sender -- the sender to which the receiver should respond\n-\n-        if Any, receiver will receive the indicated signals\n-        from any sender.\n-\n-        if Anonymous, receiver will only receive indicated\n-        signals from send/sendExact which do not specify a\n-        sender, or specify Anonymous explicitly as the sender.\n-\n-        Otherwise can be any python object.\n-\n-    weak -- whether to use weak references to the receiver\n-        By default, the module will attempt to use weak\n-        references to the receiver objects.  If this parameter\n-        is false, then strong references will be used.\n-\n-    returns None, may raise DispatcherTypeError\n-    \"\"\"\n-    if signal is None:\n-        raise errors.DispatcherTypeError(\n-            'Signal cannot be None (receiver=%r sender=%r)' % (\n-                receiver, sender)\n-        )\n-    if weak:\n-        receiver = saferef.safeRef(receiver, onDelete=_removeReceiver)\n-    senderkey = id(sender)\n-    if senderkey in connections:\n-        signals = connections[senderkey]\n-    else:\n-        connections[senderkey] = signals = {}\n-    # Keep track of senders for cleanup.\n-    # Is Anonymous something we want to clean up?\n-    if sender not in (None, Anonymous, Any):\n-        def remove(object, senderkey=senderkey):\n-            _removeSender(senderkey=senderkey)\n-\n-        # Skip objects that can not be weakly referenced, which means\n-        # they won't be automatically cleaned up, but that's too bad.\n-        try:\n-            weakSender = weakref.ref(sender, remove)\n-            senders[senderkey] = weakSender\n-        except:\n-            pass\n-\n-    receiverID = id(receiver)\n-    # get current set, remove any current references to\n-    # this receiver in the set, including back-references\n-    if signal in signals:\n-        receivers = signals[signal]\n-        _removeOldBackRefs(senderkey, signal, receiver, receivers)\n-    else:\n-        receivers = signals[signal] = []\n-    try:\n-        current = sendersBack.get(receiverID)\n-        if current is None:\n-            sendersBack[receiverID] = current = []\n-        if senderkey not in current:\n-            current.append(senderkey)\n-    except:\n-        pass\n-\n-    receivers.append(receiver)\n-\n-\n-def disconnect(receiver, signal=Any, sender=Any, weak=True):\n-    \"\"\"Disconnect receiver from sender for signal\n-\n-    receiver -- the registered receiver to disconnect\n-    signal -- the registered signal to disconnect\n-    sender -- the registered sender to disconnect\n-    weak -- the weakref state to disconnect\n-\n-    disconnect reverses the process of connect,\n-    the semantics for the individual elements are\n-    logically equivalent to a tuple of\n-    (receiver, signal, sender, weak) used as a key\n-    to be deleted from the internal routing tables.\n-    (The actual process is slightly more complex\n-    but the semantics are basically the same).\n-\n-    Note:\n-        Using disconnect is not required to cleanup\n-        routing when an object is deleted, the framework\n-        will remove routes for deleted objects\n-        automatically.  It's only necessary to disconnect\n-        if you want to stop routing to a live object.\n-\n-    returns None, may raise DispatcherTypeError or\n-        DispatcherKeyError\n-    \"\"\"\n-    if signal is None:\n-        raise errors.DispatcherTypeError(\n-            'Signal cannot be None (receiver=%r sender=%r)' % (\n-                receiver, sender)\n-        )\n-    if weak: receiver = saferef.safeRef(receiver)\n-    senderkey = id(sender)\n-    try:\n-        signals = connections[senderkey]\n-        receivers = signals[signal]\n-    except KeyError:\n-        raise errors.DispatcherKeyError(\n-            \"\"\"No receivers found for signal %r from sender %r\"\"\" % (\n-                signal,\n-                sender\n-            )\n-        )\n-    try:\n-        # also removes from receivers\n-        _removeOldBackRefs(senderkey, signal, receiver, receivers)\n-    except ValueError:\n-        raise errors.DispatcherKeyError(\n-            \"\"\"No connection to receiver %s for signal %s from sender %s\"\"\" % (\n-                receiver,\n-                signal,\n-                sender\n-            )\n-        )\n-    _cleanupConnections(senderkey, signal)\n-\n-\n-def getReceivers(sender=Any, signal=Any):\n-    \"\"\"Get list of receivers from global tables\n-\n-    This utility function allows you to retrieve the\n-    raw list of receivers from the connections table\n-    for the given sender and signal pair.\n-\n-    Note:\n-        there is no guarantee that this is the actual list\n-        stored in the connections table, so the value\n-        should be treated as a simple iterable/truth value\n-        rather than, for instance a list to which you\n-        might append new records.\n-\n-    Normally you would use liveReceivers( getReceivers( ...))\n-    to retrieve the actual receiver objects as an iterable\n-    object.\n-    \"\"\"\n-    try:\n-        return connections[id(sender)][signal]\n-    except KeyError:\n-        return []\n-\n-\n-def liveReceivers(receivers):\n-    \"\"\"Filter sequence of receivers to get resolved, live receivers\n-\n-    This is a generator which will iterate over\n-    the passed sequence, checking for weak references\n-    and resolving them, then returning all live\n-    receivers.\n-    \"\"\"\n-    for receiver in receivers:\n-        if isinstance(receiver, WEAKREF_TYPES):\n-            # Dereference the weak reference.\n-            receiver = receiver()\n-            if receiver is not None:\n-                yield receiver\n-        else:\n-            yield receiver\n-\n-\n-def getAllReceivers(sender=Any, signal=Any):\n-    \"\"\"Get list of all receivers from global tables\n-\n-    This gets all receivers which should receive\n-    the given signal from sender, each receiver should\n-    be produced only once by the resulting generator\n-    \"\"\"\n-    receivers = {}\n-    for set in (\n-            # Get receivers that receive *this* signal from *this* sender.\n-            getReceivers(sender, signal),\n-            # Add receivers that receive *any* signal from *this* sender.\n-            getReceivers(sender, Any),\n-            # Add receivers that receive *this* signal from *any* sender.\n-            getReceivers(Any, signal),\n-            # Add receivers that receive *any* signal from *any* sender.\n-            getReceivers(Any, Any),\n-    ):\n-        for receiver in set:\n-            if receiver:  # filter out dead instance-method weakrefs\n-                try:\n-                    if receiver not in receivers:\n-                        receivers[receiver] = 1\n-                        yield receiver\n-                except TypeError:\n-                    # dead weakrefs raise TypeError on hash...\n-                    pass\n-\n-\n-def send(signal=Any, sender=Anonymous, *arguments, **named):\n-    \"\"\"Send signal from sender to all connected receivers.\n-\n-    signal -- (hashable) signal value, see connect for details\n-\n-    sender -- the sender of the signal\n-\n-        if Any, only receivers registered for Any will receive\n-        the message.\n-\n-        if Anonymous, only receivers registered to receive\n-        messages from Anonymous or Any will receive the message\n-\n-        Otherwise can be any python object (normally one\n-        registered with a connect if you actually want\n-        something to occur).\n-\n-    arguments -- positional arguments which will be passed to\n-        *all* receivers. Note that this may raise TypeErrors\n-        if the receivers do not allow the particular arguments.\n-        Note also that arguments are applied before named\n-        arguments, so they should be used with care.\n-\n-    named -- named arguments which will be filtered according\n-        to the parameters of the receivers to only provide those\n-        acceptable to the receiver.\n-\n-    Return a list of tuple pairs [(receiver, response), ... ]\n-\n-    if any receiver raises an error, the error propagates back\n-    through send, terminating the dispatch loop, so it is quite\n-    possible to not have all receivers called if a raises an\n-    error.\n-    \"\"\"\n-    # Call each receiver with whatever arguments it can accept.\n-    # Return a list of tuple pairs [(receiver, response), ... ].\n-    responses = []\n-    for receiver in liveReceivers(getAllReceivers(sender, signal)):\n-        response = robustapply.robustApply(\n-            receiver,\n-            signal=signal,\n-            sender=sender,\n-            *arguments,\n-            **named\n-        )\n-        responses.append((receiver, response))\n-    return responses\n-\n-\n-def sendExact(signal=Any, sender=Anonymous, *arguments, **named):\n-    \"\"\"Send signal only to those receivers registered for exact message\n-\n-    sendExact allows for avoiding Any/Anonymous registered\n-    handlers, sending only to those receivers explicitly\n-    registered for a particular signal on a particular\n-    sender.\n-    \"\"\"\n-    responses = []\n-    for receiver in liveReceivers(getReceivers(sender, signal)):\n-        response = robustapply.robustApply(\n-            receiver,\n-            signal=signal,\n-            sender=sender,\n-            *arguments,\n-            **named\n-        )\n-        responses.append((receiver, response))\n-    return responses\n-\n-\n-def _removeReceiver(receiver):\n-    \"\"\"Remove receiver from connections.\"\"\"\n-    if not sendersBack:\n-        # During module cleanup the mapping will be replaced with None\n-        return False\n-    backKey = id(receiver)\n-    try:\n-        backSet = sendersBack.pop(backKey)\n-    except KeyError as err:\n-        return False\n-    else:\n-        for senderkey in backSet:\n-            try:\n-                signals = connections[senderkey].keys()\n-            except KeyError as err:\n-                pass\n-            else:\n-                for signal in signals:\n-                    try:\n-                        receivers = connections[senderkey][signal]\n-                    except KeyError:\n-                        pass\n-                    else:\n-                        try:\n-                            receivers.remove(receiver)\n-                        except Exception as err:\n-                            pass\n-                    _cleanupConnections(senderkey, signal)\n-\n-\n-def _cleanupConnections(senderkey, signal):\n-    \"\"\"Delete any empty signals for senderkey. Delete senderkey if empty.\"\"\"\n-    try:\n-        receivers = connections[senderkey][signal]\n-    except:\n-        pass\n-    else:\n-        if not receivers:\n-            # No more connected receivers. Therefore, remove the signal.\n-            try:\n-                signals = connections[senderkey]\n-            except KeyError:\n-                pass\n-            else:\n-                del signals[signal]\n-                if not signals:\n-                    # No more signal connections. Therefore, remove the sender.\n-                    _removeSender(senderkey)\n-\n-\n-def _removeSender(senderkey):\n-    \"\"\"Remove senderkey from connections.\"\"\"\n-    _removeBackrefs(senderkey)\n-    try:\n-        del connections[senderkey]\n-    except KeyError:\n-        pass\n-    # Senderkey will only be in senders dictionary if sender\n-    # could be weakly referenced.\n-    try:\n-        del senders[senderkey]\n-    except:\n-        pass\n-\n-\n-def _removeBackrefs(senderkey):\n-    \"\"\"Remove all back-references to this senderkey\"\"\"\n-    try:\n-        signals = connections[senderkey]\n-    except KeyError:\n-        signals = None\n-    else:\n-        items = signals.items()\n-\n-        def allReceivers():\n-            for signal, set in items:\n-                for item in set:\n-                    yield item\n-\n-        for receiver in allReceivers():\n-            _killBackref(receiver, senderkey)\n-\n-\n-def _removeOldBackRefs(senderkey, signal, receiver, receivers):\n-    \"\"\"Kill old sendersBack references from receiver\n-\n-    This guards against multiple registration of the same\n-    receiver for a given signal and sender leaking memory\n-    as old back reference records build up.\n-\n-    Also removes old receiver instance from receivers\n-    \"\"\"\n-    try:\n-        index = receivers.index(receiver)\n-        # need to scan back references here and remove senderkey\n-    except ValueError:\n-        return False\n-    else:\n-        oldReceiver = receivers[index]\n-        del receivers[index]\n-        found = 0\n-        signals = connections.get(signal)\n-        if signals is not None:\n-            for sig, recs in six.iteritems(connections.get(signal, {})):\n-                if sig != signal:\n-                    for rec in recs:\n-                        if rec is oldReceiver:\n-                            found = 1\n-                            break\n-        if not found:\n-            _killBackref(oldReceiver, senderkey)\n-            return True\n-        return False\n-\n-\n-def _killBackref(receiver, senderkey):\n-    \"\"\"Do the actual removal of back reference from receiver to senderkey\"\"\"\n-    receiverkey = id(receiver)\n-    set = sendersBack.get(receiverkey, ())\n-    while senderkey in set:\n-        try:\n-            set.remove(senderkey)\n-        except:\n-            break\n-    if not set:\n-        try:\n-            del sendersBack[receiverkey]\n-        except KeyError:\n-            pass\n-    return True\n\n@@ -1,15 +0,0 @@\n-\"\"\"Error types for dispatcher mechanism\n-\"\"\"\n-\n-\n-class DispatcherError(Exception):\n-    \"\"\"Base class for all Dispatcher errors\"\"\"\n-\n-\n-class DispatcherKeyError(KeyError, DispatcherError):\n-    \"\"\"Error raised when unknown (sender,signal) set specified\"\"\"\n-\n-\n-class DispatcherTypeError(TypeError, DispatcherError):\n-    \"\"\"Error raised when inappropriate signal-type specified (None)\"\"\"\n-\n\n@@ -1,54 +0,0 @@\n-\"\"\"Module implementing error-catching version of send (sendRobust)\"\"\"\n-from scrapy.xlib.pydispatch.dispatcher import Any, Anonymous, liveReceivers, getAllReceivers\n-from scrapy.xlib.pydispatch.robustapply import robustApply\n-\n-\n-def sendRobust(signal=Any, sender=Anonymous, *arguments, **named):\n-    \"\"\"Send signal from sender to all connected receivers catching errors\n-\n-    signal -- (hashable) signal value, see connect for details\n-\n-    sender -- the sender of the signal\n-\n-        if Any, only receivers registered for Any will receive\n-        the message.\n-\n-        if Anonymous, only receivers registered to receive\n-        messages from Anonymous or Any will receive the message\n-\n-        Otherwise can be any python object (normally one\n-        registered with a connect if you actually want\n-        something to occur).\n-\n-    arguments -- positional arguments which will be passed to\n-        *all* receivers. Note that this may raise TypeErrors\n-        if the receivers do not allow the particular arguments.\n-        Note also that arguments are applied before named\n-        arguments, so they should be used with care.\n-\n-    named -- named arguments which will be filtered according\n-        to the parameters of the receivers to only provide those\n-        acceptable to the receiver.\n-\n-    Return a list of tuple pairs [(receiver, response), ... ]\n-\n-    if any receiver raises an error (specifically any subclass of Exception),\n-    the error instance is returned as the result for that receiver.\n-    \"\"\"\n-    # Call each receiver with whatever arguments it can accept.\n-    # Return a list of tuple pairs [(receiver, response), ... ].\n-    responses = []\n-    for receiver in liveReceivers(getAllReceivers(sender, signal)):\n-        try:\n-            response = robustApply(\n-                receiver,\n-                signal=signal,\n-                sender=sender,\n-                *arguments,\n-                **named\n-            )\n-        except Exception as err:\n-            responses.append((receiver, err))\n-        else:\n-            responses.append((receiver, response))\n-    return responses\n\n@@ -1,58 +0,0 @@\n-\"\"\"Robust apply mechanism\n-\n-Provides a function \"call\", which can sort out\n-what arguments a given callable object can take,\n-and subset the given arguments to match only\n-those which are acceptable.\n-\"\"\"\n-import inspect\n-\n-\n-def function(receiver):\n-    \"\"\"Get function-like callable object for given receiver\n-\n-    returns (function_or_method, codeObject, fromMethod)\n-\n-    If fromMethod is true, then the callable already\n-    has its first argument bound\n-    \"\"\"\n-    if inspect.isclass(receiver) and hasattr(receiver, '__call__'):\n-        # receiver is a class instance; assume it is callable.\n-        # Reassign receiver to the actual method that will be called.\n-        if hasattr(receiver.__call__, 'im_func') or \\\n-                hasattr(receiver.__call__, 'im_code'):\n-            receiver = receiver.__call__\n-\n-    if hasattr(receiver, 'im_func'):\n-        # an instance-method...\n-        return receiver, receiver.im_func.func_code, 1\n-    elif not hasattr(receiver, 'func_code'):\n-        raise ValueError(\n-            'unknown receiver type %s %s' % (receiver, type(receiver)))\n-\n-    return receiver, receiver.func_code, 0\n-\n-\n-def robustApply(receiver, *arguments, **named):\n-    \"\"\"Call receiver with arguments and an appropriate subset of named\n-    \"\"\"\n-    receiver, codeObject, startIndex = function(receiver)\n-    acceptable = codeObject.co_varnames[\n-                 startIndex + len(arguments):codeObject.co_argcount]\n-    for name in codeObject.co_varnames[startIndex:startIndex + len(arguments)]:\n-        if name in named:\n-            raise TypeError(\n-                \"\"\"Argument %r specified both positionally and as a keyword for calling %r\"\"\" % (\n-                    name, receiver,\n-                )\n-            )\n-\n-    if not (codeObject.co_flags & 8):\n-        # fc does not have a **kwds type parameter, therefore\n-        # remove unacceptable arguments.\n-        for arg in named.keys():\n-            if arg not in acceptable:\n-                del named[arg]\n-\n-    return receiver(*arguments, **named)\n-\n\n@@ -1,180 +0,0 @@\n-\"\"\"Refactored \"safe reference\" from dispatcher.py\"\"\"\n-from __future__ import print_function\n-import weakref, traceback\n-\n-\n-def safeRef(target, onDelete=None):\n-    \"\"\"Return a *safe* weak reference to a callable target\n-\n-    target -- the object to be weakly referenced, if it's a\n-        bound method reference, will create a BoundMethodWeakref,\n-        otherwise creates a simple weakref.\n-    onDelete -- if provided, will have a hard reference stored\n-        to the callable to be called after the safe reference\n-        goes out of scope with the reference object, (either a\n-        weakref or a BoundMethodWeakref) as argument.\n-    \"\"\"\n-    if hasattr(target, 'im_self'):\n-        if target.im_self is not None:\n-            # Turn a bound method into a BoundMethodWeakref instance.\n-            # Keep track of these instances for lookup by disconnect().\n-            assert hasattr(target, 'im_func'), \"\"\"safeRef target %r has im_self, but no im_func, don't know how to create reference\"\"\"%( target,)\n-            reference = BoundMethodWeakref(\n-                target=target,\n-                onDelete=onDelete\n-            )\n-            return reference\n-    if onDelete is not None:\n-        return weakref.ref(target, onDelete)\n-    else:\n-        return weakref.ref(target)\n-\n-\n-class BoundMethodWeakref(object):\n-    \"\"\"'Safe' and reusable weak references to instance methods\n-\n-    BoundMethodWeakref objects provide a mechanism for\n-    referencing a bound method without requiring that the\n-    method object itself (which is normally a transient\n-    object) is kept alive.  Instead, the BoundMethodWeakref\n-    object keeps weak references to both the object and the\n-    function which together define the instance method.\n-\n-    Attributes:\n-        key -- the identity key for the reference, calculated\n-            by the class's calculateKey method applied to the\n-            target instance method\n-        deletionMethods -- sequence of callable objects taking\n-            single argument, a reference to this object which\n-            will be called when *either* the target object or\n-            target function is garbage collected (i.e. when\n-            this object becomes invalid).  These are specified\n-            as the onDelete parameters of safeRef calls.\n-        weakSelf -- weak reference to the target object\n-        weakFunc -- weak reference to the target function\n-\n-    Class Attributes:\n-        _allInstances -- class attribute pointing to all live\n-            BoundMethodWeakref objects indexed by the class's\n-            calculateKey(target) method applied to the target\n-            objects.  This weak value dictionary is used to\n-            short-circuit creation so that multiple references\n-            to the same (object, function) pair produce the\n-            same BoundMethodWeakref instance.\n-\n-    \"\"\"\n-    _allInstances = weakref.WeakValueDictionary()\n-\n-    def __new__(cls, target, onDelete=None, *arguments, **named):\n-        \"\"\"Create new instance or return current instance\n-\n-        Basically this method of construction allows us to\n-        short-circuit creation of references to already-\n-        referenced instance methods.  The key corresponding\n-        to the target is calculated, and if there is already\n-        an existing reference, that is returned, with its\n-        deletionMethods attribute updated.  Otherwise the\n-        new instance is created and registered in the table\n-        of already-referenced methods.\n-        \"\"\"\n-        key = cls.calculateKey(target)\n-        current = cls._allInstances.get(key)\n-        if current is not None:\n-            current.deletionMethods.append(onDelete)\n-            return current\n-        else:\n-            base = super(BoundMethodWeakref, cls).__new__(cls)\n-            cls._allInstances[key] = base\n-            base.__init__(target, onDelete, *arguments, **named)\n-            return base\n-\n-    def __init__(self, target, onDelete=None):\n-        \"\"\"Return a weak-reference-like instance for a bound method\n-\n-        target -- the instance-method target for the weak\n-            reference, must have im_self and im_func attributes\n-            and be reconstructable via:\n-                target.im_func.__get__( target.im_self )\n-            which is true of built-in instance methods.\n-        onDelete -- optional callback which will be called\n-            when this weak reference ceases to be valid\n-            (i.e. either the object or the function is garbage\n-            collected).  Should take a single argument,\n-            which will be passed a pointer to this object.\n-        \"\"\"\n-\n-        def remove(weak, self=self):\n-            \"\"\"Set self.isDead to true when method or instance is destroyed\"\"\"\n-            methods = self.deletionMethods[:]\n-            del self.deletionMethods[:]\n-            try:\n-                del self.__class__._allInstances[self.key]\n-            except KeyError:\n-                pass\n-            for function in methods:\n-                try:\n-                    if callable(function):\n-                        function(self)\n-                except Exception as e:\n-                    try:\n-                        traceback.print_exc()\n-                    except AttributeError as err:\n-                        print(\n-                            '''Exception during saferef %s cleanup function %s: %s''' % (\n-                                self, function, e\n-                            ))\n-\n-        self.deletionMethods = [onDelete]\n-        self.key = self.calculateKey(target)\n-        self.weakSelf = weakref.ref(target.im_self, remove)\n-        self.weakFunc = weakref.ref(target.im_func, remove)\n-        self.selfName = target.im_self.__class__.__name__\n-        self.funcName = str(target.im_func.__name__)\n-\n-    def calculateKey(cls, target):\n-        \"\"\"Calculate the reference key for this reference\n-\n-        Currently this is a two-tuple of the id()'s of the\n-        target object and the target function respectively.\n-        \"\"\"\n-        return (id(target.im_self), id(target.im_func))\n-\n-    calculateKey = classmethod(calculateKey)\n-\n-    def __str__(self):\n-        \"\"\"Give a friendly representation of the object\"\"\"\n-        return \"\"\"%s( %s.%s )\"\"\" % (\n-            self.__class__.__name__,\n-            self.selfName,\n-            self.funcName,\n-        )\n-\n-    __repr__ = __str__\n-\n-    def __nonzero__(self):\n-        \"\"\"Whether we are still a valid reference\"\"\"\n-        return self() is not None\n-\n-    def __cmp__(self, other):\n-        \"\"\"Compare with another reference\"\"\"\n-        if not isinstance(other, self.__class__):\n-            return cmp(self.__class__, type(other))\n-        return cmp(self.key, other.key)\n-\n-    def __call__(self):\n-        \"\"\"Return a strong reference to the bound method\n-\n-        If the target cannot be retrieved, then will\n-        return None, otherwise returns a bound instance\n-        method for our object and function.\n-\n-        Note:\n-            You may call this method any number of times,\n-            as it does not invalidate the reference.\n-        \"\"\"\n-        target = self.weakSelf()\n-        if target is not None:\n-            function = self.weakFunc()\n-            if function is not None:\n-                return function.__get__(target)\n-        return None\n\n@@ -44,5 +44,6 @@ setup(\n         'pyOpenSSL',\n         'cssselect>=0.9',\n         'six>=1.5.2',\n+        'PyDispatcher>=2.0.5',\n     ],\n )\n\n@@ -20,7 +20,7 @@ from twisted.trial import unittest\n \n from scrapy import signals\n from scrapy.utils.test import get_crawler\n-from scrapy.xlib.pydispatch import dispatcher\n+from pydispatch import dispatcher\n from tests import tests_datadir\n from scrapy.spiders import Spider\n from scrapy.item import Item, Field\n\n@@ -2,8 +2,8 @@ from testfixtures import LogCapture\n from twisted.trial import unittest\n from twisted.python.failure import Failure\n from twisted.internet import defer, reactor\n+from pydispatch import dispatcher\n \n-from scrapy.xlib.pydispatch import dispatcher\n from scrapy.utils.signal import send_catch_log, send_catch_log_deferred\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#2c937f35544de1492c627d8bcad9747653d4c813", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 5 | Contributors (this commit): 2 | Commits (past 90d): 1 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -3,6 +3,7 @@ import unittest\n \n from scrapy.dupefilters import RFPDupeFilter\n from scrapy.http import Request\n+from scrapy.utils.python import to_bytes\n \n \n class RFPDupeFilterTest(unittest.TestCase):\n@@ -43,7 +44,7 @@ class RFPDupeFilterTest(unittest.TestCase):\n \n             def request_fingerprint(self, request):\n                 fp = hashlib.sha1()\n-                fp.update(request.url.lower())\n+                fp.update(to_bytes(request.url.lower()))\n                 return fp.hexdigest()\n \n         case_insensitive_dupefilter = CaseInsensitiveRFPDupeFilter()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#c78e2636f944c291c875108c32bfe229112ad9fa", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 23 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 23 | Churn Cumulative: 28 | Contributors (this commit): 3 | Commits (past 90d): 2 | Contributors (cumulative): 3 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,5 +1,7 @@\n import hashlib\n+import tempfile\n import unittest\n+import shutil\n \n from scrapy.dupefilters import RFPDupeFilter\n from scrapy.http import Request\n@@ -23,6 +25,27 @@ class RFPDupeFilterTest(unittest.TestCase):\n \n         dupefilter.close('finished')\n \n+    def test_dupefilter_path(self):\n+        r1 = Request('http://scrapytest.org/1')\n+        r2 = Request('http://scrapytest.org/2')\n+\n+        path = tempfile.mkdtemp()\n+        try:\n+            df = RFPDupeFilter(path)\n+            df.open()\n+            assert not df.request_seen(r1)\n+            assert df.request_seen(r1)\n+            df.close('finished')\n+\n+            df2 = RFPDupeFilter(path)\n+            df2.open()\n+            assert df2.request_seen(r1)\n+            assert not df2.request_seen(r2)\n+            assert df2.request_seen(r2)\n+            df2.close('finished')\n+        finally:\n+            shutil.rmtree(path)\n+\n     def test_request_fingerprint(self):\n         \"\"\"Test if customization of request_fingerprint method will change\n         output of request_seen.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#836cb84b7a78f7d8ea439362234387d799c06b5b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 18/18 | Churn Δ: 1 | Churn Cumulative: 1 | Contributors (this commit): 2 | Commits (past 90d): 1 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -36,6 +36,7 @@ class RFPDupeFilter(BaseDupeFilter):\n         self.logger = logging.getLogger(__name__)\n         if path:\n             self.file = open(os.path.join(path, 'requests.seen'), 'a+')\n+            self.file.seek(0)\n             self.fingerprints.update(x.rstrip() for x in self.file)\n \n     @classmethod\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#1a1bc2c6b5230fdff516b38c2bee247baeb7c5b0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 99 | Lines Deleted: 34 | Files Changed: 2 | Hunks: 11 | Methods Changed: 20 | Complexity Δ (Sum/Max): 12/10 | Churn Δ: 133 | Churn Cumulative: 224 | Contributors (this commit): 6 | Commits (past 90d): 4 | Contributors (cumulative): 8 | DMM Complexity: 1.0\n\nDIFF:\n@@ -65,5 +65,17 @@ class RobotsTxtMiddleware(object):\n \n     def _parse_robots(self, response):\n         rp = robotparser.RobotFileParser(response.url)\n-        rp.parse(response.body.splitlines())\n+        body = ''\n+        if hasattr(response, 'body_as_unicode'):\n+            body = response.body_as_unicode()\n+        else: # last effort try\n+            try:\n+                body = response.body.decode('utf-8')\n+            except UnicodeDecodeError:\n+                # If we found garbage, disregard it:,\n+                # but keep the lookup cached (in self._parsers)\n+                # Running rp.parse() will set rp state from\n+                # 'disallow all' to 'allow any'.\n+                pass\n+        rp.parse(body.splitlines())\n         self._parsers[urlparse_cached(response).netloc] = rp\n\n@@ -6,15 +6,44 @@ from twisted.python import failure\n from twisted.trial import unittest\n from scrapy.downloadermiddlewares.robotstxt import RobotsTxtMiddleware\n from scrapy.exceptions import IgnoreRequest, NotConfigured\n-from scrapy.http import Request, Response\n+from scrapy.http import Request, Response, TextResponse\n from scrapy.settings import Settings\n from tests import mock\n \n \n class RobotsTxtMiddlewareTest(unittest.TestCase):\n \n+    def setUp(self):\n+        self.crawler = mock.MagicMock()\n+        self.crawler.settings = Settings()\n+        self.crawler.engine.download = mock.MagicMock()\n+\n+    def tearDown(self):\n+        del self.crawler\n+\n+    def test_robotstxt_settings(self):\n+        self.crawler.settings = Settings()\n+        self.crawler.settings.set('USER_AGENT', 'CustomAgent')\n+        self.assertRaises(NotConfigured, RobotsTxtMiddleware, self.crawler)\n+\n+    def _get_successful_crawler(self):\n+        crawler = self.crawler\n+        crawler.settings.set('ROBOTSTXT_OBEY', True)\n+        ROBOTS = re.sub(b'^\\s+(?m)', b'', b'''\n+        User-Agent: *\n+        Disallow: /admin/\n+        Disallow: /static/\n+        ''')\n+        response = TextResponse('http://site.local/robots.txt', body=ROBOTS)\n+        def return_response(request, spider):\n+            deferred = Deferred()\n+            reactor.callFromThread(deferred.callback, response)\n+            return deferred\n+        crawler.engine.download.side_effect = return_response\n+        return crawler\n+\n     def test_robotstxt(self):\n-        middleware = self._get_middleware()\n+        middleware = RobotsTxtMiddleware(self._get_successful_crawler())\n         # There is a bit of neglect in robotstxt.py: robots.txt is fetched asynchronously,\n         # and it is actually fetched only *after* first process_request completes.\n         # So, first process_request will always succeed.\n@@ -30,8 +59,8 @@ class RobotsTxtMiddlewareTest(unittest.TestCase):\n         return deferred\n \n     def test_robotstxt_meta(self):\n+        middleware = RobotsTxtMiddleware(self._get_successful_crawler())\n         meta = {'dont_obey_robotstxt': True}\n-        middleware = self._get_middleware()\n         self.assertNotIgnored(Request('http://site.local', meta=meta), middleware)\n         def test(r):\n             self.assertNotIgnored(Request('http://site.local/allowed', meta=meta), middleware)\n@@ -42,19 +71,67 @@ class RobotsTxtMiddlewareTest(unittest.TestCase):\n         reactor.callFromThread(deferred.callback, None)\n         return deferred\n \n-    def test_robotstxt_error(self):\n-        crawler = mock.MagicMock()\n-        crawler.settings = Settings()\n+    def _get_garbage_crawler(self):\n+        crawler = self.crawler\n         crawler.settings.set('ROBOTSTXT_OBEY', True)\n-        crawler.engine.download = mock.MagicMock()\n+        response = Response('http://site.local/robots.txt', body=b'GIF89a\\xd3\\x00\\xfe\\x00\\xa2')\n+        def return_response(request, spider):\n+            deferred = Deferred()\n+            reactor.callFromThread(deferred.callback, response)\n+            return deferred\n+        crawler.engine.download.side_effect = return_response\n+        return crawler\n+\n+    def test_robotstxt_garbage(self):\n+        # garbage response should be discarded, equal 'allow all'\n+        middleware = RobotsTxtMiddleware(self._get_garbage_crawler())\n+        middleware._logerror = mock.MagicMock()\n+        middleware.process_request(Request('http://site.local'), None)\n+        self.assertNotIgnored(Request('http://site.local'), middleware)\n+        def test(r):\n+            self.assertNotIgnored(Request('http://site.local/allowed'), middleware)\n+            self.assertNotIgnored(Request('http://site.local/admin/main'), middleware)\n+            self.assertNotIgnored(Request('http://site.local/static/'), middleware)\n+        deferred = Deferred()\n+        deferred.addCallback(test)\n+        deferred.addErrback(lambda _: self.assertIsNone(middleware._logerror.assert_any_call()))\n+        reactor.callFromThread(deferred.callback, None)\n+        return deferred\n+\n+    def _get_emptybody_crawler(self):\n+        crawler = self.crawler\n+        crawler.settings.set('ROBOTSTXT_OBEY', True)\n+        response = Response('http://site.local/robots.txt')\n+        def return_response(request, spider):\n+            deferred = Deferred()\n+            reactor.callFromThread(deferred.callback, response)\n+            return deferred\n+        crawler.engine.download.side_effect = return_response\n+        return crawler\n+\n+    def test_robotstxt_empty_response(self):\n+        # empty response should equal 'allow all'\n+        middleware = RobotsTxtMiddleware(self._get_emptybody_crawler())\n+        self.assertNotIgnored(Request('http://site.local'), middleware)\n+        def test(r):\n+            self.assertNotIgnored(Request('http://site.local/allowed'), middleware)\n+            self.assertNotIgnored(Request('http://site.local/admin/main'), middleware)\n+            self.assertNotIgnored(Request('http://site.local/static/'), middleware)\n+        deferred = Deferred()\n+        deferred.addCallback(test)\n+        reactor.callFromThread(deferred.callback, None)\n+        return deferred\n+\n+    def test_robotstxt_error(self):\n+        self.crawler.settings.set('ROBOTSTXT_OBEY', True)\n         err = error.DNSLookupError('Robotstxt address not found')\n         def return_failure(request, spider):\n             deferred = Deferred()\n             reactor.callFromThread(deferred.errback, failure.Failure(err))\n             return deferred\n-        crawler.engine.download.side_effect = return_failure\n+        self.crawler.engine.download.side_effect = return_failure\n \n-        middleware = RobotsTxtMiddleware(crawler)\n+        middleware = RobotsTxtMiddleware(self.crawler)\n         middleware._logerror = mock.MagicMock()\n         middleware.process_request(Request('http://site.local'), None)\n         deferred = Deferred()\n@@ -69,27 +146,3 @@ class RobotsTxtMiddlewareTest(unittest.TestCase):\n     def assertIgnored(self, request, middleware):\n         spider = None  # not actually used\n         self.assertRaises(IgnoreRequest, middleware.process_request, request, spider)\n-\n-    def _get_crawler(self):\n-        crawler = mock.MagicMock()\n-        crawler.settings = Settings()\n-        crawler.settings.set('USER_AGENT', 'CustomAgent')\n-        self.assertRaises(NotConfigured, RobotsTxtMiddleware, crawler)\n-        crawler.settings.set('ROBOTSTXT_OBEY', True)\n-        crawler.engine.download = mock.MagicMock()\n-        ROBOTS = re.sub(r'^\\s+(?m)', '', '''\n-        User-Agent: *\n-        Disallow: /admin/\n-        Disallow: /static/\n-        ''')\n-        response = Response('http://site.local/robots.txt', body=ROBOTS)\n-        def return_response(request, spider):\n-            deferred = Deferred()\n-            reactor.callFromThread(deferred.callback, response)\n-            return deferred\n-        crawler.engine.download.side_effect = return_response\n-        return crawler\n-\n-    def _get_middleware(self):\n-        crawler = self._get_crawler()\n-        return RobotsTxtMiddleware(crawler)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
