{"custom_id": "fastapi#265dbeb6635864e527cfd4c7376f0b32bc2301c1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 2 | Churn Cumulative: 2 | Contributors (this commit): 2 | Commits (past 90d): 1 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -3,7 +3,7 @@ from fastapi.middleware.gzip import GZipMiddleware\n \n app = FastAPI()\n \n-app.add_middleware(GZipMiddleware, minimum_size=1000)\n+app.add_middleware(GZipMiddleware, minimum_size=1000, compresslevel=5)\n \n \n @app.get(\"/\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#3a3ad5d66d0cae4be95675b93d8ee8b10c3ce212", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 20 | Lines Deleted: 20 | Files Changed: 6 | Hunks: 8 | Methods Changed: 9 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 40 | Churn Cumulative: 13732 | Contributors (this commit): 81 | Commits (past 90d): 7 | Contributors (cumulative): 105 | DMM Complexity: None\n\nDIFF:\n@@ -515,9 +515,9 @@ def get_individual_sponsors(settings: Settings):\n \n     tiers: DefaultDict[float, Dict[str, SponsorEntity]] = defaultdict(dict)\n     for node in nodes:\n-        tiers[node.tier.monthlyPriceInDollars][\n-            node.sponsorEntity.login\n-        ] = node.sponsorEntity\n+        tiers[node.tier.monthlyPriceInDollars][node.sponsorEntity.login] = (\n+            node.sponsorEntity\n+        )\n     return tiers\n \n \n\n@@ -342,9 +342,9 @@ def analyze_param(\n             if isinstance(arg, (params.Param, params.Body, params.Depends))\n         ]\n         if fastapi_specific_annotations:\n-            fastapi_annotation: Union[\n-                FieldInfo, params.Depends, None\n-            ] = fastapi_specific_annotations[-1]\n+            fastapi_annotation: Union[FieldInfo, params.Depends, None] = (\n+                fastapi_specific_annotations[-1]\n+            )\n         else:\n             fastapi_annotation = None\n         if isinstance(fastapi_annotation, FieldInfo):\n\n@@ -454,9 +454,9 @@ class APIRoute(routing.Route):\n             methods = [\"GET\"]\n         self.methods: Set[str] = {method.upper() for method in methods}\n         if isinstance(generate_unique_id_function, DefaultPlaceholder):\n-            current_generate_unique_id: Callable[\n-                [\"APIRoute\"], str\n-            ] = generate_unique_id_function.value\n+            current_generate_unique_id: Callable[[APIRoute], str] = (\n+                generate_unique_id_function.value\n+            )\n         else:\n             current_generate_unique_id = generate_unique_id_function\n         self.unique_id = self.operation_id or current_generate_unique_id(self)\n@@ -482,9 +482,9 @@ class APIRoute(routing.Route):\n             # By being a new field, no inheritance will be passed as is. A new model\n             # will always be created.\n             # TODO: remove when deprecating Pydantic v1\n-            self.secure_cloned_response_field: Optional[\n-                ModelField\n-            ] = create_cloned_field(self.response_field)\n+            self.secure_cloned_response_field: Optional[ModelField] = (\n+                create_cloned_field(self.response_field)\n+            )\n         else:\n             self.response_field = None  # type: ignore\n             self.secure_cloned_response_field = None\n\n@@ -34,9 +34,9 @@ if TYPE_CHECKING:  # pragma: nocover\n     from .routing import APIRoute\n \n # Cache for `create_cloned_field`\n-_CLONED_TYPES_CACHE: MutableMapping[\n-    Type[BaseModel], Type[BaseModel]\n-] = WeakKeyDictionary()\n+_CLONED_TYPES_CACHE: MutableMapping[Type[BaseModel], Type[BaseModel]] = (\n+    WeakKeyDictionary()\n+)\n \n \n def is_body_allowed_for_status_code(status_code: Union[int, str, None]) -> bool:\n\n@@ -196,9 +196,9 @@ async def get_sync_context_b_bg(\n     tasks: BackgroundTasks, state: dict = Depends(context_b)\n ):\n     async def bg(state: dict):\n-        state[\n-            \"sync_bg\"\n-        ] = f\"sync_bg set - b: {state['context_b']} - a: {state['context_a']}\"\n+        state[\"sync_bg\"] = (\n+            f\"sync_bg set - b: {state['context_b']} - a: {state['context_a']}\"\n+        )\n \n     tasks.add_task(bg, state)\n     return state\n\n@@ -36,7 +36,7 @@ def test_pydanticv2():\n     def return_fast_uuid():\n         asyncpg_uuid = MyUuid(\"a10ff360-3b1e-4984-a26f-d3ab460bdb51\")\n         assert isinstance(asyncpg_uuid, uuid.UUID)\n-        assert type(asyncpg_uuid) != uuid.UUID\n+        assert type(asyncpg_uuid) is not uuid.UUID\n         with pytest.raises(TypeError):\n             vars(asyncpg_uuid)\n         return {\"fast_uuid\": asyncpg_uuid}\n@@ -79,7 +79,7 @@ def test_pydanticv1():\n     def return_fast_uuid():\n         asyncpg_uuid = MyUuid(\"a10ff360-3b1e-4984-a26f-d3ab460bdb51\")\n         assert isinstance(asyncpg_uuid, uuid.UUID)\n-        assert type(asyncpg_uuid) != uuid.UUID\n+        assert type(asyncpg_uuid) is not uuid.UUID\n         with pytest.raises(TypeError):\n             vars(asyncpg_uuid)\n         return {\"fast_uuid\": asyncpg_uuid}\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#659350e9cd0e1948ce2bdc95cc3ac2ffb5a41238", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 7531 | Contributors (this commit): 36 | Commits (past 90d): 1 | Contributors (cumulative): 36 | DMM Complexity: None\n\nDIFF:\n@@ -1056,7 +1056,7 @@ class FastAPI(Starlette):\n     def add_api_route(\n         self,\n         path: str,\n-        endpoint: Callable[..., Coroutine[Any, Any, Response]],\n+        endpoint: Callable[..., Any],\n         *,\n         response_model: Any = Default(None),\n         status_code: Optional[int] = None,\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#85cded53c8273cb26ee50089383498422d75f658", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 3034 | Contributors (this commit): 7 | Commits (past 90d): 1 | Contributors (cumulative): 7 | DMM Complexity: None\n\nDIFF:\n@@ -2343,7 +2343,7 @@ def Security(  # noqa: N802\n     ```python\n     from typing import Annotated\n \n-    from fastapi import Depends, FastAPI\n+    from fastapi import Security, FastAPI\n \n     from .db import User\n     from .security import get_current_active_user\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#9bfc48ad9fba044462eb9d0e1b556cf721f56ae4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 1207 | Contributors (this commit): 5 | Commits (past 90d): 7 | Contributors (cumulative): 6 | DMM Complexity: None\n\nDIFF:\n@@ -29,6 +29,7 @@ missing_translation_snippet = \"\"\"\n non_translated_sections = [\n     \"reference/\",\n     \"release-notes.md\",\n+    \"fastapi-people.md\",\n     \"external-links.md\",\n     \"newsletter.md\",\n     \"management-tasks.md\",\n\n@@ -11,6 +11,7 @@ from mkdocs.structure.pages import Page\n non_translated_sections = [\n     \"reference/\",\n     \"release-notes.md\",\n+    \"fastapi-people.md\",\n     \"external-links.md\",\n     \"newsletter.md\",\n     \"management-tasks.md\",\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#3a4ac2467594d0ccad92ecfb7f7f10ffa5d1d992", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 158 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 9 | Methods Changed: 18 | Complexity Δ (Sum/Max): 21/15 | Churn Δ: 162 | Churn Cumulative: 8852 | Contributors (this commit): 44 | Commits (past 90d): 3 | Contributors (cumulative): 47 | DMM Complexity: 0.9701492537313433\n\nDIFF:\n@@ -3,14 +3,16 @@ import dataclasses\n import email.message\n import inspect\n import json\n-from contextlib import AsyncExitStack\n+from contextlib import AsyncExitStack, asynccontextmanager\n from enum import Enum, IntEnum\n from typing import (\n     Any,\n+    AsyncIterator,\n     Callable,\n     Coroutine,\n     Dict,\n     List,\n+    Mapping,\n     Optional,\n     Sequence,\n     Set,\n@@ -67,7 +69,7 @@ from starlette.routing import (\n     websocket_session,\n )\n from starlette.routing import Mount as Mount  # noqa\n-from starlette.types import ASGIApp, Lifespan, Scope\n+from starlette.types import AppType, ASGIApp, Lifespan, Scope\n from starlette.websockets import WebSocket\n from typing_extensions import Annotated, Doc, deprecated\n \n@@ -119,6 +121,23 @@ def _prepare_response_content(\n     return res\n \n \n+def _merge_lifespan_context(\n+    original_context: Lifespan[Any], nested_context: Lifespan[Any]\n+) -> Lifespan[Any]:\n+    @asynccontextmanager\n+    async def merged_lifespan(\n+        app: AppType,\n+    ) -> AsyncIterator[Optional[Mapping[str, Any]]]:\n+        async with original_context(app) as maybe_original_state:\n+            async with nested_context(app) as maybe_nested_state:\n+                if maybe_nested_state is None and maybe_original_state is None:\n+                    yield None  # old ASGI compatibility\n+                else:\n+                    yield {**(maybe_nested_state or {}), **(maybe_original_state or {})}\n+\n+    return merged_lifespan  # type: ignore[return-value]\n+\n+\n async def serialize_response(\n     *,\n     field: Optional[ModelField] = None,\n@@ -1308,6 +1327,10 @@ class APIRouter(routing.Router):\n             self.add_event_handler(\"startup\", handler)\n         for handler in router.on_shutdown:\n             self.add_event_handler(\"shutdown\", handler)\n+        self.lifespan_context = _merge_lifespan_context(\n+            self.lifespan_context,\n+            router.lifespan_context,\n+        )\n \n     def get(\n         self,\n\n@@ -1,8 +1,8 @@\n from contextlib import asynccontextmanager\n-from typing import AsyncGenerator, Dict\n+from typing import AsyncGenerator, Dict, Union\n \n import pytest\n-from fastapi import APIRouter, FastAPI\n+from fastapi import APIRouter, FastAPI, Request\n from fastapi.testclient import TestClient\n from pydantic import BaseModel\n \n@@ -109,3 +109,134 @@ def test_app_lifespan_state(state: State) -> None:\n         assert response.json() == {\"message\": \"Hello World\"}\n     assert state.app_startup is True\n     assert state.app_shutdown is True\n+\n+\n+def test_router_nested_lifespan_state(state: State) -> None:\n+    @asynccontextmanager\n+    async def lifespan(app: FastAPI) -> AsyncGenerator[Dict[str, bool], None]:\n+        state.app_startup = True\n+        yield {\"app\": True}\n+        state.app_shutdown = True\n+\n+    @asynccontextmanager\n+    async def router_lifespan(app: FastAPI) -> AsyncGenerator[Dict[str, bool], None]:\n+        state.router_startup = True\n+        yield {\"router\": True}\n+        state.router_shutdown = True\n+\n+    @asynccontextmanager\n+    async def subrouter_lifespan(app: FastAPI) -> AsyncGenerator[Dict[str, bool], None]:\n+        state.sub_router_startup = True\n+        yield {\"sub_router\": True}\n+        state.sub_router_shutdown = True\n+\n+    sub_router = APIRouter(lifespan=subrouter_lifespan)\n+\n+    router = APIRouter(lifespan=router_lifespan)\n+    router.include_router(sub_router)\n+\n+    app = FastAPI(lifespan=lifespan)\n+    app.include_router(router)\n+\n+    @app.get(\"/\")\n+    def main(request: Request) -> Dict[str, str]:\n+        assert request.state.app\n+        assert request.state.router\n+        assert request.state.sub_router\n+        return {\"message\": \"Hello World\"}\n+\n+    assert state.app_startup is False\n+    assert state.router_startup is False\n+    assert state.sub_router_startup is False\n+    assert state.app_shutdown is False\n+    assert state.router_shutdown is False\n+    assert state.sub_router_shutdown is False\n+\n+    with TestClient(app) as client:\n+        assert state.app_startup is True\n+        assert state.router_startup is True\n+        assert state.sub_router_startup is True\n+        assert state.app_shutdown is False\n+        assert state.router_shutdown is False\n+        assert state.sub_router_shutdown is False\n+        response = client.get(\"/\")\n+        assert response.status_code == 200, response.text\n+        assert response.json() == {\"message\": \"Hello World\"}\n+\n+    assert state.app_startup is True\n+    assert state.router_startup is True\n+    assert state.sub_router_startup is True\n+    assert state.app_shutdown is True\n+    assert state.router_shutdown is True\n+    assert state.sub_router_shutdown is True\n+\n+\n+def test_router_nested_lifespan_state_overriding_by_parent() -> None:\n+    @asynccontextmanager\n+    async def lifespan(\n+        app: FastAPI,\n+    ) -> AsyncGenerator[Dict[str, Union[str, bool]], None]:\n+        yield {\n+            \"app_specific\": True,\n+            \"overridden\": \"app\",\n+        }\n+\n+    @asynccontextmanager\n+    async def router_lifespan(\n+        app: FastAPI,\n+    ) -> AsyncGenerator[Dict[str, Union[str, bool]], None]:\n+        yield {\n+            \"router_specific\": True,\n+            \"overridden\": \"router\",  # should override parent\n+        }\n+\n+    router = APIRouter(lifespan=router_lifespan)\n+    app = FastAPI(lifespan=lifespan)\n+    app.include_router(router)\n+\n+    with TestClient(app) as client:\n+        assert client.app_state == {\n+            \"app_specific\": True,\n+            \"router_specific\": True,\n+            \"overridden\": \"app\",\n+        }\n+\n+\n+def test_merged_no_return_lifespans_return_none() -> None:\n+    @asynccontextmanager\n+    async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:\n+        yield\n+\n+    @asynccontextmanager\n+    async def router_lifespan(app: FastAPI) -> AsyncGenerator[None, None]:\n+        yield\n+\n+    router = APIRouter(lifespan=router_lifespan)\n+    app = FastAPI(lifespan=lifespan)\n+    app.include_router(router)\n+\n+    with TestClient(app) as client:\n+        assert not client.app_state\n+\n+\n+def test_merged_mixed_state_lifespans() -> None:\n+    @asynccontextmanager\n+    async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:\n+        yield\n+\n+    @asynccontextmanager\n+    async def router_lifespan(app: FastAPI) -> AsyncGenerator[Dict[str, bool], None]:\n+        yield {\"router\": True}\n+\n+    @asynccontextmanager\n+    async def sub_router_lifespan(app: FastAPI) -> AsyncGenerator[None, None]:\n+        yield\n+\n+    sub_router = APIRouter(lifespan=sub_router_lifespan)\n+    router = APIRouter(lifespan=router_lifespan)\n+    app = FastAPI(lifespan=lifespan)\n+    router.include_router(sub_router)\n+    app.include_router(router)\n+\n+    with TestClient(app) as client:\n+        assert client.app_state == {\"router\": True}\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#51b625e127982f626886d467122ef85d5772d1db", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 85 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 3 | Methods Changed: 7 | Complexity Δ (Sum/Max): 5/5 | Churn Δ: 87 | Churn Cumulative: 1362 | Contributors (this commit): 9 | Commits (past 90d): 2 | Contributors (cumulative): 10 | DMM Complexity: 1.0\n\nDIFF:\n@@ -91,7 +91,7 @@ class Param(FieldInfo):\n             max_length=max_length,\n             discriminator=discriminator,\n             multiple_of=multiple_of,\n-            allow_nan=allow_inf_nan,\n+            allow_inf_nan=allow_inf_nan,\n             max_digits=max_digits,\n             decimal_places=decimal_places,\n             **extra,\n@@ -547,7 +547,7 @@ class Body(FieldInfo):\n             max_length=max_length,\n             discriminator=discriminator,\n             multiple_of=multiple_of,\n-            allow_nan=allow_inf_nan,\n+            allow_inf_nan=allow_inf_nan,\n             max_digits=max_digits,\n             decimal_places=decimal_places,\n             **extra,\n\n@@ -0,0 +1,83 @@\n+import pytest\n+from fastapi import Body, FastAPI, Query\n+from fastapi.testclient import TestClient\n+from typing_extensions import Annotated\n+\n+app = FastAPI()\n+\n+\n+@app.post(\"/\")\n+async def get(\n+    x: Annotated[float, Query(allow_inf_nan=True)] = 0,\n+    y: Annotated[float, Query(allow_inf_nan=False)] = 0,\n+    z: Annotated[float, Query()] = 0,\n+    b: Annotated[float, Body(allow_inf_nan=False)] = 0,\n+) -> str:\n+    return \"OK\"\n+\n+\n+client = TestClient(app)\n+\n+\n+@pytest.mark.parametrize(\n+    \"value,code\",\n+    [\n+        (\"-1\", 200),\n+        (\"inf\", 200),\n+        (\"-inf\", 200),\n+        (\"nan\", 200),\n+        (\"0\", 200),\n+        (\"342\", 200),\n+    ],\n+)\n+def test_allow_inf_nan_param_true(value: str, code: int):\n+    response = client.post(f\"/?x={value}\")\n+    assert response.status_code == code, response.text\n+\n+\n+@pytest.mark.parametrize(\n+    \"value,code\",\n+    [\n+        (\"-1\", 200),\n+        (\"inf\", 422),\n+        (\"-inf\", 422),\n+        (\"nan\", 422),\n+        (\"0\", 200),\n+        (\"342\", 200),\n+    ],\n+)\n+def test_allow_inf_nan_param_false(value: str, code: int):\n+    response = client.post(f\"/?y={value}\")\n+    assert response.status_code == code, response.text\n+\n+\n+@pytest.mark.parametrize(\n+    \"value,code\",\n+    [\n+        (\"-1\", 200),\n+        (\"inf\", 200),\n+        (\"-inf\", 200),\n+        (\"nan\", 200),\n+        (\"0\", 200),\n+        (\"342\", 200),\n+    ],\n+)\n+def test_allow_inf_nan_param_default(value: str, code: int):\n+    response = client.post(f\"/?z={value}\")\n+    assert response.status_code == code, response.text\n+\n+\n+@pytest.mark.parametrize(\n+    \"value,code\",\n+    [\n+        (\"-1\", 200),\n+        (\"inf\", 422),\n+        (\"-inf\", 422),\n+        (\"nan\", 422),\n+        (\"0\", 200),\n+        (\"342\", 200),\n+    ],\n+)\n+def test_allow_inf_nan_body(value: str, code: int):\n+    response = client.post(\"/\", json=value)\n+    assert response.status_code == code, response.text\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#d00af00d3f15e9a963e2f1baf8f9b4c8357f6f66", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 485 | Contributors (this commit): 2 | Commits (past 90d): 4 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -1,6 +1,6 @@\n \"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n \n-__version__ = \"0.112.1\"\n+__version__ = \"0.112.2\"\n \n from starlette import status as status\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#9b35d355bfb44c33000359a2b24f215286996693", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 0 | Files Changed: 3 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 3/1 | Churn Δ: 6 | Churn Cumulative: 47 | Contributors (this commit): 3 | Commits (past 90d): 3 | Contributors (cumulative): 7 | DMM Complexity: 1.0\n\nDIFF:\n@@ -13,4 +13,6 @@ async def read_items(\n     results = {\"item_id\": item_id}\n     if q:\n         results.update({\"q\": q})\n+    if size:\n+        results.update({\"size\": size})\n     return results\n\n@@ -14,4 +14,6 @@ async def read_items(\n     results = {\"item_id\": item_id}\n     if q:\n         results.update({\"q\": q})\n+    if size:\n+        results.update({\"size\": size})\n     return results\n\n@@ -15,4 +15,6 @@ async def read_items(\n     results = {\"item_id\": item_id}\n     if q:\n         results.update({\"q\": q})\n+    if size:\n+        results.update({\"size\": size})\n     return results\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#6e98249c2121959b5253cecc1237ee5438f98758", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 20 | Contributors (this commit): 3 | Commits (past 90d): 1 | Contributors (cumulative): 3 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,12 +1,14 @@\n import pytest\n-from httpx import AsyncClient\n+from httpx import ASGITransport, AsyncClient\n \n from .main import app\n \n \n @pytest.mark.anyio\n async def test_root():\n-    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n+    async with AsyncClient(\n+        transport=ASGITransport(app=app), base_url=\"http://test\"\n+    ) as ac:\n         response = await ac.get(\"/\")\n     assert response.status_code == 200\n     assert response.json() == {\"message\": \"Tomato\"}\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#581aacc4a9f3bbb872b082ee55535fe60655de2e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 28 | Lines Deleted: 49 | Files Changed: 2 | Hunks: 6 | Methods Changed: 4 | Complexity Δ (Sum/Max): -8/0 | Churn Δ: 77 | Churn Cumulative: 2847 | Contributors (this commit): 32 | Commits (past 90d): 3 | Contributors (cumulative): 38 | DMM Complexity: 0.9318181818181818\n\nDIFF:\n@@ -1,58 +1,37 @@\n-from typing import Any, Callable, List, Optional, Sequence\n+from dataclasses import dataclass, field\n+from typing import Any, Callable, List, Optional, Sequence, Tuple\n \n from fastapi._compat import ModelField\n from fastapi.security.base import SecurityBase\n \n \n+@dataclass\n class SecurityRequirement:\n-    def __init__(\n-        self, security_scheme: SecurityBase, scopes: Optional[Sequence[str]] = None\n-    ):\n-        self.security_scheme = security_scheme\n-        self.scopes = scopes\n+    security_scheme: SecurityBase\n+    scopes: Optional[Sequence[str]] = None\n \n \n+@dataclass\n class Dependant:\n-    def __init__(\n-        self,\n-        *,\n-        path_params: Optional[List[ModelField]] = None,\n-        query_params: Optional[List[ModelField]] = None,\n-        header_params: Optional[List[ModelField]] = None,\n-        cookie_params: Optional[List[ModelField]] = None,\n-        body_params: Optional[List[ModelField]] = None,\n-        dependencies: Optional[List[\"Dependant\"]] = None,\n-        security_schemes: Optional[List[SecurityRequirement]] = None,\n-        name: Optional[str] = None,\n-        call: Optional[Callable[..., Any]] = None,\n-        request_param_name: Optional[str] = None,\n-        websocket_param_name: Optional[str] = None,\n-        http_connection_param_name: Optional[str] = None,\n-        response_param_name: Optional[str] = None,\n-        background_tasks_param_name: Optional[str] = None,\n-        security_scopes_param_name: Optional[str] = None,\n-        security_scopes: Optional[List[str]] = None,\n-        use_cache: bool = True,\n-        path: Optional[str] = None,\n-    ) -> None:\n-        self.path_params = path_params or []\n-        self.query_params = query_params or []\n-        self.header_params = header_params or []\n-        self.cookie_params = cookie_params or []\n-        self.body_params = body_params or []\n-        self.dependencies = dependencies or []\n-        self.security_requirements = security_schemes or []\n-        self.request_param_name = request_param_name\n-        self.websocket_param_name = websocket_param_name\n-        self.http_connection_param_name = http_connection_param_name\n-        self.response_param_name = response_param_name\n-        self.background_tasks_param_name = background_tasks_param_name\n-        self.security_scopes = security_scopes\n-        self.security_scopes_param_name = security_scopes_param_name\n-        self.name = name\n-        self.call = call\n-        self.use_cache = use_cache\n-        # Store the path to be able to re-generate a dependable from it in overrides\n-        self.path = path\n-        # Save the cache key at creation to optimize performance\n+    path_params: List[ModelField] = field(default_factory=list)\n+    query_params: List[ModelField] = field(default_factory=list)\n+    header_params: List[ModelField] = field(default_factory=list)\n+    cookie_params: List[ModelField] = field(default_factory=list)\n+    body_params: List[ModelField] = field(default_factory=list)\n+    dependencies: List[\"Dependant\"] = field(default_factory=list)\n+    security_requirements: List[SecurityRequirement] = field(default_factory=list)\n+    name: Optional[str] = None\n+    call: Optional[Callable[..., Any]] = None\n+    request_param_name: Optional[str] = None\n+    websocket_param_name: Optional[str] = None\n+    http_connection_param_name: Optional[str] = None\n+    response_param_name: Optional[str] = None\n+    background_tasks_param_name: Optional[str] = None\n+    security_scopes_param_name: Optional[str] = None\n+    security_scopes: Optional[List[str]] = None\n+    use_cache: bool = True\n+    path: Optional[str] = None\n+    cache_key: Tuple[Optional[Callable[..., Any]], Tuple[str, ...]] = field(init=False)\n+\n+    def __post_init__(self) -> None:\n         self.cache_key = (self.call, tuple(sorted(set(self.security_scopes or []))))\n\n@@ -175,7 +175,7 @@ def get_flat_dependant(\n         header_params=dependant.header_params.copy(),\n         cookie_params=dependant.cookie_params.copy(),\n         body_params=dependant.body_params.copy(),\n-        security_schemes=dependant.security_requirements.copy(),\n+        security_requirements=dependant.security_requirements.copy(),\n         use_cache=dependant.use_cache,\n         path=dependant.path,\n     )\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#08547e1d571df8e8cf71d8b15a767acbc38aea62", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 19 | Lines Deleted: 11 | Files Changed: 1 | Hunks: 11 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 30 | Churn Cumulative: 2642 | Contributors (this commit): 32 | Commits (past 90d): 3 | Contributors (cumulative): 32 | DMM Complexity: None\n\nDIFF:\n@@ -1,6 +1,7 @@\n import inspect\n from contextlib import AsyncExitStack, contextmanager\n from copy import copy, deepcopy\n+from dataclasses import dataclass\n from typing import (\n     Any,\n     Callable,\n@@ -258,16 +259,16 @@ def get_dependant(\n     )\n     for param_name, param in signature_params.items():\n         is_path_param = param_name in path_param_names\n-        type_annotation, depends, param_field = analyze_param(\n+        param_details = analyze_param(\n             param_name=param_name,\n             annotation=param.annotation,\n             value=param.default,\n             is_path_param=is_path_param,\n         )\n-        if depends is not None:\n+        if param_details.depends is not None:\n             sub_dependant = get_param_sub_dependant(\n                 param_name=param_name,\n-                depends=depends,\n+                depends=param_details.depends,\n                 path=path,\n                 security_scopes=security_scopes,\n             )\n@@ -275,18 +276,18 @@ def get_dependant(\n             continue\n         if add_non_field_param_to_dependency(\n             param_name=param_name,\n-            type_annotation=type_annotation,\n+            type_annotation=param_details.type_annotation,\n             dependant=dependant,\n         ):\n             assert (\n-                param_field is None\n+                param_details.field is None\n             ), f\"Cannot specify multiple FastAPI annotations for {param_name!r}\"\n             continue\n-        assert param_field is not None\n-        if is_body_param(param_field=param_field, is_path_param=is_path_param):\n-            dependant.body_params.append(param_field)\n+        assert param_details.field is not None\n+        if is_body_param(param_field=param_details.field, is_path_param=is_path_param):\n+            dependant.body_params.append(param_details.field)\n         else:\n-            add_param_to_fields(field=param_field, dependant=dependant)\n+            add_param_to_fields(field=param_details.field, dependant=dependant)\n     return dependant\n \n \n@@ -314,13 +315,20 @@ def add_non_field_param_to_dependency(\n     return None\n \n \n+@dataclass\n+class ParamDetails:\n+    type_annotation: Any\n+    depends: Optional[params.Depends]\n+    field: Optional[ModelField]\n+\n+\n def analyze_param(\n     *,\n     param_name: str,\n     annotation: Any,\n     value: Any,\n     is_path_param: bool,\n-) -> Tuple[Any, Optional[params.Depends], Optional[ModelField]]:\n+) -> ParamDetails:\n     field_info = None\n     depends = None\n     type_annotation: Any = Any\n@@ -450,7 +458,7 @@ def analyze_param(\n             field_info=field_info,\n         )\n \n-    return type_annotation, depends, field\n+    return ParamDetails(type_annotation=type_annotation, depends=depends, field=field)\n \n \n def is_body_param(*, param_field: ModelField, is_path_param: bool) -> bool:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#5b7fa3900e3156dcb93f496516740bc06903d7d8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 45 | Lines Deleted: 33 | Files Changed: 2 | Hunks: 16 | Methods Changed: 5 | Complexity Δ (Sum/Max): 23/23 | Churn Δ: 78 | Churn Cumulative: 11278 | Contributors (this commit): 66 | Commits (past 90d): 7 | Contributors (cumulative): 75 | DMM Complexity: 0.0\n\nDIFF:\n@@ -529,6 +529,15 @@ async def solve_generator(\n     return await stack.enter_async_context(cm)\n \n \n+@dataclass\n+class SolvedDependency:\n+    values: Dict[str, Any]\n+    errors: List[Any]\n+    background_tasks: Optional[StarletteBackgroundTasks]\n+    response: Response\n+    dependency_cache: Dict[Tuple[Callable[..., Any], Tuple[str]], Any]\n+\n+\n async def solve_dependencies(\n     *,\n     request: Union[Request, WebSocket],\n@@ -539,13 +548,7 @@ async def solve_dependencies(\n     dependency_overrides_provider: Optional[Any] = None,\n     dependency_cache: Optional[Dict[Tuple[Callable[..., Any], Tuple[str]], Any]] = None,\n     async_exit_stack: AsyncExitStack,\n-) -> Tuple[\n-    Dict[str, Any],\n-    List[Any],\n-    Optional[StarletteBackgroundTasks],\n-    Response,\n-    Dict[Tuple[Callable[..., Any], Tuple[str]], Any],\n-]:\n+) -> SolvedDependency:\n     values: Dict[str, Any] = {}\n     errors: List[Any] = []\n     if response is None:\n@@ -587,27 +590,21 @@ async def solve_dependencies(\n             dependency_cache=dependency_cache,\n             async_exit_stack=async_exit_stack,\n         )\n-        (\n-            sub_values,\n-            sub_errors,\n-            background_tasks,\n-            _,  # the subdependency returns the same response we have\n-            sub_dependency_cache,\n-        ) = solved_result\n-        dependency_cache.update(sub_dependency_cache)\n-        if sub_errors:\n-            errors.extend(sub_errors)\n+        background_tasks = solved_result.background_tasks\n+        dependency_cache.update(solved_result.dependency_cache)\n+        if solved_result.errors:\n+            errors.extend(solved_result.errors)\n             continue\n         if sub_dependant.use_cache and sub_dependant.cache_key in dependency_cache:\n             solved = dependency_cache[sub_dependant.cache_key]\n         elif is_gen_callable(call) or is_async_gen_callable(call):\n             solved = await solve_generator(\n-                call=call, stack=async_exit_stack, sub_values=sub_values\n+                call=call, stack=async_exit_stack, sub_values=solved_result.values\n             )\n         elif is_coroutine_callable(call):\n-            solved = await call(**sub_values)\n+            solved = await call(**solved_result.values)\n         else:\n-            solved = await run_in_threadpool(call, **sub_values)\n+            solved = await run_in_threadpool(call, **solved_result.values)\n         if sub_dependant.name is not None:\n             values[sub_dependant.name] = solved\n         if sub_dependant.cache_key not in dependency_cache:\n@@ -654,7 +651,13 @@ async def solve_dependencies(\n         values[dependant.security_scopes_param_name] = SecurityScopes(\n             scopes=dependant.security_scopes\n         )\n-    return values, errors, background_tasks, response, dependency_cache\n+    return SolvedDependency(\n+        values=values,\n+        errors=errors,\n+        background_tasks=background_tasks,\n+        response=response,\n+        dependency_cache=dependency_cache,\n+    )\n \n \n def request_params_to_args(\n\n@@ -292,26 +292,34 @@ def get_request_handler(\n                     dependency_overrides_provider=dependency_overrides_provider,\n                     async_exit_stack=async_exit_stack,\n                 )\n-                values, errors, background_tasks, sub_response, _ = solved_result\n+                errors = solved_result.errors\n                 if not errors:\n                     raw_response = await run_endpoint_function(\n-                        dependant=dependant, values=values, is_coroutine=is_coroutine\n+                        dependant=dependant,\n+                        values=solved_result.values,\n+                        is_coroutine=is_coroutine,\n                     )\n                     if isinstance(raw_response, Response):\n                         if raw_response.background is None:\n-                            raw_response.background = background_tasks\n+                            raw_response.background = solved_result.background_tasks\n                         response = raw_response\n                     else:\n-                        response_args: Dict[str, Any] = {\"background\": background_tasks}\n+                        response_args: Dict[str, Any] = {\n+                            \"background\": solved_result.background_tasks\n+                        }\n                         # If status_code was set, use it, otherwise use the default from the\n                         # response class, in the case of redirect it's 307\n                         current_status_code = (\n-                            status_code if status_code else sub_response.status_code\n+                            status_code\n+                            if status_code\n+                            else solved_result.response.status_code\n                         )\n                         if current_status_code is not None:\n                             response_args[\"status_code\"] = current_status_code\n-                        if sub_response.status_code:\n-                            response_args[\"status_code\"] = sub_response.status_code\n+                        if solved_result.response.status_code:\n+                            response_args[\"status_code\"] = (\n+                                solved_result.response.status_code\n+                            )\n                         content = await serialize_response(\n                             field=response_field,\n                             response_content=raw_response,\n@@ -326,7 +334,7 @@ def get_request_handler(\n                         response = actual_response_class(content, **response_args)\n                         if not is_body_allowed_for_status_code(response.status_code):\n                             response.body = b\"\"\n-                        response.headers.raw.extend(sub_response.headers.raw)\n+                        response.headers.raw.extend(solved_result.response.headers.raw)\n             if errors:\n                 validation_error = RequestValidationError(\n                     _normalize_errors(errors), body=body\n@@ -360,11 +368,12 @@ def get_websocket_app(\n                 dependency_overrides_provider=dependency_overrides_provider,\n                 async_exit_stack=async_exit_stack,\n             )\n-            values, errors, _, _2, _3 = solved_result\n-            if errors:\n-                raise WebSocketRequestValidationError(_normalize_errors(errors))\n+            if solved_result.errors:\n+                raise WebSocketRequestValidationError(\n+                    _normalize_errors(solved_result.errors)\n+                )\n             assert dependant.call is not None, \"dependant.call must be a function\"\n-            await dependant.call(**values)\n+            await dependant.call(**solved_result.values)\n \n     return app\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#d08b95ea57fa5740c8c04da554f2b6e259f4dea4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 12 | Files Changed: 3 | Hunks: 10 | Methods Changed: 6 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 21 | Churn Cumulative: 12096 | Contributors (this commit): 79 | Commits (past 90d): 11 | Contributors (cumulative): 99 | DMM Complexity: 1.0\n\nDIFF:\n@@ -55,7 +55,7 @@ from fastapi.logger import logger\n from fastapi.security.base import SecurityBase\n from fastapi.security.oauth2 import OAuth2, SecurityScopes\n from fastapi.security.open_id_connect_url import OpenIdConnect\n-from fastapi.utils import create_response_field, get_path_param_names\n+from fastapi.utils import create_model_field, get_path_param_names\n from pydantic.fields import FieldInfo\n from starlette.background import BackgroundTasks as StarletteBackgroundTasks\n from starlette.concurrency import run_in_threadpool\n@@ -449,7 +449,7 @@ def analyze_param(\n         else:\n             alias = field_info.alias or param_name\n         field_info.alias = alias\n-        field = create_response_field(\n+        field = create_model_field(\n             name=param_name,\n             type_=use_annotation_from_field_info,\n             default=field_info.default,\n@@ -818,7 +818,7 @@ def get_body_field(*, dependant: Dependant, name: str) -> Optional[ModelField]:\n         ]\n         if len(set(body_param_media_types)) == 1:\n             BodyFieldInfo_kwargs[\"media_type\"] = body_param_media_types[0]\n-    final_field = create_response_field(\n+    final_field = create_model_field(\n         name=\"body\",\n         type_=BodyModel,\n         required=required,\n\n@@ -49,7 +49,7 @@ from fastapi.exceptions import (\n from fastapi.types import DecoratedCallable, IncEx\n from fastapi.utils import (\n     create_cloned_field,\n-    create_response_field,\n+    create_model_field,\n     generate_unique_id,\n     get_value_or_default,\n     is_body_allowed_for_status_code,\n@@ -497,7 +497,7 @@ class APIRoute(routing.Route):\n                 status_code\n             ), f\"Status code {status_code} must not have a response body\"\n             response_name = \"Response_\" + self.unique_id\n-            self.response_field = create_response_field(\n+            self.response_field = create_model_field(\n                 name=response_name,\n                 type_=self.response_model,\n                 mode=\"serialization\",\n@@ -530,7 +530,7 @@ class APIRoute(routing.Route):\n                     additional_status_code\n                 ), f\"Status code {additional_status_code} must not have a response body\"\n                 response_name = f\"Response_{additional_status_code}_{self.unique_id}\"\n-                response_field = create_response_field(name=response_name, type_=model)\n+                response_field = create_model_field(name=response_name, type_=model)\n                 response_fields[additional_status_code] = response_field\n         if response_fields:\n             self.response_fields: Dict[Union[int, str], ModelField] = response_fields\n\n@@ -60,9 +60,9 @@ def get_path_param_names(path: str) -> Set[str]:\n     return set(re.findall(\"{(.*?)}\", path))\n \n \n-def create_response_field(\n+def create_model_field(\n     name: str,\n-    type_: Type[Any],\n+    type_: Any,\n     class_validators: Optional[Dict[str, Validator]] = None,\n     default: Optional[Any] = Undefined,\n     required: Union[bool, UndefinedType] = Undefined,\n@@ -71,9 +71,6 @@ def create_response_field(\n     alias: Optional[str] = None,\n     mode: Literal[\"validation\", \"serialization\"] = \"validation\",\n ) -> ModelField:\n-    \"\"\"\n-    Create a new response field. Raises if type_ is invalid.\n-    \"\"\"\n     class_validators = class_validators or {}\n     if PYDANTIC_V2:\n         field_info = field_info or FieldInfo(\n@@ -135,7 +132,7 @@ def create_cloned_field(\n                 use_type.__fields__[f.name] = create_cloned_field(\n                     f, cloned_types=cloned_types\n                 )\n-    new_field = create_response_field(name=field.name, type_=use_type)\n+    new_field = create_model_field(name=field.name, type_=use_type)\n     new_field.has_alias = field.has_alias  # type: ignore[attr-defined]\n     new_field.alias = field.alias  # type: ignore[misc]\n     new_field.class_validators = field.class_validators  # type: ignore[attr-defined]\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#23bda0ffeb26e906b5dcf58423522ab4166669ed", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 13 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 14 | Methods Changed: 4 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 19 | Churn Cumulative: 2712 | Contributors (this commit): 32 | Commits (past 90d): 6 | Contributors (cumulative): 32 | DMM Complexity: 0.0\n\nDIFF:\n@@ -80,9 +80,7 @@ multipart_incorrect_install_error = (\n )\n \n \n-def check_file_field(field: ModelField) -> None:\n-    field_info = field.field_info\n-    if isinstance(field_info, params.Form):\n+def ensure_multipart_is_installed() -> None:\n     try:\n         # __version__ is available in both multiparts, and can be mocked\n         from multipart import __version__  # type: ignore\n@@ -336,6 +334,7 @@ def analyze_param(\n     if annotation is not inspect.Signature.empty:\n         use_annotation = annotation\n         type_annotation = annotation\n+    # Extract Annotated info\n     if get_origin(use_annotation) is Annotated:\n         annotated_args = get_args(annotation)\n         type_annotation = annotated_args[0]\n@@ -355,6 +354,7 @@ def analyze_param(\n             )\n         else:\n             fastapi_annotation = None\n+        # Set default for Annotated FieldInfo\n         if isinstance(fastapi_annotation, FieldInfo):\n             # Copy `field_info` because we mutate `field_info.default` below.\n             field_info = copy_field_info(\n@@ -369,9 +369,10 @@ def analyze_param(\n                 field_info.default = value\n             else:\n                 field_info.default = Required\n+        # Get Annotated Depends\n         elif isinstance(fastapi_annotation, params.Depends):\n             depends = fastapi_annotation\n-\n+    # Get Depends from default value\n     if isinstance(value, params.Depends):\n         assert depends is None, (\n             \"Cannot specify `Depends` in `Annotated` and default value\"\n@@ -382,6 +383,7 @@ def analyze_param(\n             f\" default value together for {param_name!r}\"\n         )\n         depends = value\n+    # Get FieldInfo from default value\n     elif isinstance(value, FieldInfo):\n         assert field_info is None, (\n             \"Cannot specify FastAPI annotations in `Annotated` and default value\"\n@@ -391,11 +393,13 @@ def analyze_param(\n         if PYDANTIC_V2:\n             field_info.annotation = type_annotation\n \n+    # Get Depends from type annotation\n     if depends is not None and depends.dependency is None:\n         # Copy `depends` before mutating it\n         depends = copy(depends)\n         depends.dependency = type_annotation\n \n+    # Handle non-param type annotations like Request\n     if lenient_issubclass(\n         type_annotation,\n         (\n@@ -411,6 +415,7 @@ def analyze_param(\n         assert (\n             field_info is None\n         ), f\"Cannot specify FastAPI annotation for type {type_annotation!r}\"\n+    # Handle default assignations, neither field_info nor depends was not found in Annotated nor default value\n     elif field_info is None and depends is None:\n         default_value = value if value is not inspect.Signature.empty else Required\n         if is_path_param:\n@@ -428,7 +433,9 @@ def analyze_param(\n             field_info = params.Query(annotation=use_annotation, default=default_value)\n \n     field = None\n+    # It's a field_info, not a dependency\n     if field_info is not None:\n+        # Handle field_info.in_\n         if is_path_param:\n             assert isinstance(field_info, params.Path), (\n                 f\"Cannot use `{field_info.__class__.__name__}` for path param\"\n@@ -444,6 +451,8 @@ def analyze_param(\n             field_info,\n             param_name,\n         )\n+        if isinstance(field_info, params.Form):\n+            ensure_multipart_is_installed()\n         if not field_info.alias and getattr(field_info, \"convert_underscores\", None):\n             alias = param_name.replace(\"_\", \"-\")\n         else:\n@@ -786,7 +795,6 @@ def get_body_field(*, dependant: Dependant, name: str) -> Optional[ModelField]:\n     embed = getattr(field_info, \"embed\", None)\n     body_param_names_set = {param.name for param in flat_dependant.body_params}\n     if len(body_param_names_set) == 1 and not embed:\n-        check_file_field(first_param)\n         return first_param\n     # If one field requires to embed, all have to be embedded\n     # in case a sub-dependency is evaluated with a single unique body field\n@@ -825,5 +833,4 @@ def get_body_field(*, dependant: Dependant, name: str) -> Optional[ModelField]:\n         alias=\"body\",\n         field_info=BodyFieldInfo(**BodyFieldInfo_kwargs),\n     )\n-    check_file_field(final_field)\n     return final_field\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#7213d421f5bf0a4b9b8815e69a141550b4fc3f09", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 487 | Contributors (this commit): 2 | Commits (past 90d): 5 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -1,6 +1,6 @@\n \"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n \n-__version__ = \"0.112.2\"\n+__version__ = \"0.112.3\"\n \n from starlette import status as status\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#aa21814a89853c17c139054a5c51f0bb1ea68a0a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 298 | Lines Deleted: 110 | Files Changed: 7 | Hunks: 47 | Methods Changed: 33 | Complexity Δ (Sum/Max): 12/7 | Churn Δ: 408 | Churn Cumulative: 16791 | Contributors (this commit): 72 | Commits (past 90d): 19 | Contributors (cumulative): 95 | DMM Complexity: 0.8066666666666666\n\nDIFF:\n@@ -279,6 +279,12 @@ if PYDANTIC_V2:\n         BodyModel: Type[BaseModel] = create_model(model_name, **field_params)  # type: ignore[call-overload]\n         return BodyModel\n \n+    def get_model_fields(model: Type[BaseModel]) -> List[ModelField]:\n+        return [\n+            ModelField(field_info=field_info, name=name)\n+            for name, field_info in model.model_fields.items()\n+        ]\n+\n else:\n     from fastapi.openapi.constants import REF_PREFIX as REF_PREFIX\n     from pydantic import AnyUrl as Url  # noqa: F401\n@@ -513,6 +519,9 @@ else:\n             BodyModel.__fields__[f.name] = f  # type: ignore[index]\n         return BodyModel\n \n+    def get_model_fields(model: Type[BaseModel]) -> List[ModelField]:\n+        return list(model.__fields__.values())  # type: ignore[attr-defined]\n+\n \n def _regenerate_error_with_loc(\n     *, errors: Sequence[Any], loc_prefix: Tuple[Union[str, int], ...]\n@@ -532,6 +541,12 @@ def _annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n \n \n def field_annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:\n+    origin = get_origin(annotation)\n+    if origin is Union or origin is UnionType:\n+        for arg in get_args(annotation):\n+            if field_annotation_is_sequence(arg):\n+                return True\n+        return False\n     return _annotation_is_sequence(annotation) or _annotation_is_sequence(\n         get_origin(annotation)\n     )\n\n@@ -59,7 +59,13 @@ from fastapi.utils import create_model_field, get_path_param_names\n from pydantic.fields import FieldInfo\n from starlette.background import BackgroundTasks as StarletteBackgroundTasks\n from starlette.concurrency import run_in_threadpool\n-from starlette.datastructures import FormData, Headers, QueryParams, UploadFile\n+from starlette.datastructures import (\n+    FormData,\n+    Headers,\n+    ImmutableMultiDict,\n+    QueryParams,\n+    UploadFile,\n+)\n from starlette.requests import HTTPConnection, Request\n from starlette.responses import Response\n from starlette.websockets import WebSocket\n@@ -282,7 +288,7 @@ def get_dependant(\n             ), f\"Cannot specify multiple FastAPI annotations for {param_name!r}\"\n             continue\n         assert param_details.field is not None\n-        if is_body_param(param_field=param_details.field, is_path_param=is_path_param):\n+        if isinstance(param_details.field.field_info, params.Body):\n             dependant.body_params.append(param_details.field)\n         else:\n             add_param_to_fields(field=param_details.field, dependant=dependant)\n@@ -466,27 +472,14 @@ def analyze_param(\n             required=field_info.default in (Required, Undefined),\n             field_info=field_info,\n         )\n-\n-    return ParamDetails(type_annotation=type_annotation, depends=depends, field=field)\n-\n-\n-def is_body_param(*, param_field: ModelField, is_path_param: bool) -> bool:\n         if is_path_param:\n             assert is_scalar_field(\n-            field=param_field\n+                field=field\n             ), \"Path params must be of one of the supported types\"\n-        return False\n-    elif is_scalar_field(field=param_field):\n-        return False\n-    elif isinstance(\n-        param_field.field_info, (params.Query, params.Header)\n-    ) and is_scalar_sequence_field(param_field):\n-        return False\n-    else:\n-        assert isinstance(\n-            param_field.field_info, params.Body\n-        ), f\"Param: {param_field.name} can only be a request body, using Body()\"\n-        return True\n+        elif isinstance(field_info, params.Query):\n+            assert is_scalar_field(field) or is_scalar_sequence_field(field)\n+\n+    return ParamDetails(type_annotation=type_annotation, depends=depends, field=field)\n \n \n def add_param_to_fields(*, field: ModelField, dependant: Dependant) -> None:\n@@ -557,6 +550,7 @@ async def solve_dependencies(\n     dependency_overrides_provider: Optional[Any] = None,\n     dependency_cache: Optional[Dict[Tuple[Callable[..., Any], Tuple[str]], Any]] = None,\n     async_exit_stack: AsyncExitStack,\n+    embed_body_fields: bool,\n ) -> SolvedDependency:\n     values: Dict[str, Any] = {}\n     errors: List[Any] = []\n@@ -598,6 +592,7 @@ async def solve_dependencies(\n             dependency_overrides_provider=dependency_overrides_provider,\n             dependency_cache=dependency_cache,\n             async_exit_stack=async_exit_stack,\n+            embed_body_fields=embed_body_fields,\n         )\n         background_tasks = solved_result.background_tasks\n         dependency_cache.update(solved_result.dependency_cache)\n@@ -640,7 +635,9 @@ async def solve_dependencies(\n             body_values,\n             body_errors,\n         ) = await request_body_to_args(  # body_params checked above\n-            required_params=dependant.body_params, received_body=body\n+            body_fields=dependant.body_params,\n+            received_body=body,\n+            embed_body_fields=embed_body_fields,\n         )\n         values.update(body_values)\n         errors.extend(body_errors)\n@@ -669,95 +666,107 @@ async def solve_dependencies(\n     )\n \n \n+def _validate_value_with_model_field(\n+    *, field: ModelField, value: Any, values: Dict[str, Any], loc: Tuple[str, ...]\n+) -> Tuple[Any, List[Any]]:\n+    if value is None:\n+        if field.required:\n+            return None, [get_missing_field_error(loc=loc)]\n+        else:\n+            return deepcopy(field.default), []\n+    v_, errors_ = field.validate(value, values, loc=loc)\n+    if isinstance(errors_, ErrorWrapper):\n+        return None, [errors_]\n+    elif isinstance(errors_, list):\n+        new_errors = _regenerate_error_with_loc(errors=errors_, loc_prefix=())\n+        return None, new_errors\n+    else:\n+        return v_, []\n+\n+\n+def _get_multidict_value(field: ModelField, values: Mapping[str, Any]) -> Any:\n+    if is_sequence_field(field) and isinstance(values, (ImmutableMultiDict, Headers)):\n+        value = values.getlist(field.alias)\n+    else:\n+        value = values.get(field.alias, None)\n+    if (\n+        value is None\n+        or (\n+            isinstance(field.field_info, params.Form)\n+            and isinstance(value, str)  # For type checks\n+            and value == \"\"\n+        )\n+        or (is_sequence_field(field) and len(value) == 0)\n+    ):\n+        if field.required:\n+            return\n+        else:\n+            return deepcopy(field.default)\n+    return value\n+\n+\n def request_params_to_args(\n-    required_params: Sequence[ModelField],\n+    fields: Sequence[ModelField],\n     received_params: Union[Mapping[str, Any], QueryParams, Headers],\n ) -> Tuple[Dict[str, Any], List[Any]]:\n-    values = {}\n+    values: Dict[str, Any] = {}\n     errors = []\n-    for field in required_params:\n-        if is_scalar_sequence_field(field) and isinstance(\n-            received_params, (QueryParams, Headers)\n-        ):\n-            value = received_params.getlist(field.alias) or field.default\n-        else:\n-            value = received_params.get(field.alias)\n+    for field in fields:\n+        value = _get_multidict_value(field, received_params)\n         field_info = field.field_info\n         assert isinstance(\n             field_info, params.Param\n         ), \"Params must be subclasses of Param\"\n         loc = (field_info.in_.value, field.alias)\n-        if value is None:\n-            if field.required:\n-                errors.append(get_missing_field_error(loc=loc))\n-            else:\n-                values[field.name] = deepcopy(field.default)\n-            continue\n-        v_, errors_ = field.validate(value, values, loc=loc)\n-        if isinstance(errors_, ErrorWrapper):\n-            errors.append(errors_)\n-        elif isinstance(errors_, list):\n-            new_errors = _regenerate_error_with_loc(errors=errors_, loc_prefix=())\n-            errors.extend(new_errors)\n+        v_, errors_ = _validate_value_with_model_field(\n+            field=field, value=value, values=values, loc=loc\n+        )\n+        if errors_:\n+            errors.extend(errors_)\n         else:\n             values[field.name] = v_\n     return values, errors\n \n \n-async def request_body_to_args(\n-    required_params: List[ModelField],\n-    received_body: Optional[Union[Dict[str, Any], FormData]],\n-) -> Tuple[Dict[str, Any], List[Dict[str, Any]]]:\n+def _should_embed_body_fields(fields: List[ModelField]) -> bool:\n+    if not fields:\n+        return False\n+    # More than one dependency could have the same field, it would show up as multiple\n+    # fields but it's the same one, so count them by name\n+    body_param_names_set = {field.name for field in fields}\n+    # A top level field has to be a single field, not multiple\n+    if len(body_param_names_set) > 1:\n+        return True\n+    first_field = fields[0]\n+    # If it explicitly specifies it is embedded, it has to be embedded\n+    if getattr(first_field.field_info, \"embed\", None):\n+        return True\n+    # If it's a Form (or File) field, it has to be a BaseModel to be top level\n+    # otherwise it has to be embedded, so that the key value pair can be extracted\n+    if isinstance(first_field.field_info, params.Form):\n+        return True\n+    return False\n+\n+\n+async def _extract_form_body(\n+    body_fields: List[ModelField],\n+    received_body: FormData,\n+) -> Dict[str, Any]:\n     values = {}\n-    errors: List[Dict[str, Any]] = []\n-    if required_params:\n-        field = required_params[0]\n-        field_info = field.field_info\n-        embed = getattr(field_info, \"embed\", None)\n-        field_alias_omitted = len(required_params) == 1 and not embed\n-        if field_alias_omitted:\n-            received_body = {field.alias: received_body}\n+    first_field = body_fields[0]\n+    first_field_info = first_field.field_info\n \n-        for field in required_params:\n-            loc: Tuple[str, ...]\n-            if field_alias_omitted:\n-                loc = (\"body\",)\n-            else:\n-                loc = (\"body\", field.alias)\n-\n-            value: Optional[Any] = None\n-            if received_body is not None:\n-                if (is_sequence_field(field)) and isinstance(received_body, FormData):\n-                    value = received_body.getlist(field.alias)\n-                else:\n-                    try:\n-                        value = received_body.get(field.alias)\n-                    except AttributeError:\n-                        errors.append(get_missing_field_error(loc))\n-                        continue\n+    for field in body_fields:\n+        value = _get_multidict_value(field, received_body)\n         if (\n-                value is None\n-                or (isinstance(field_info, params.Form) and value == \"\")\n-                or (\n-                    isinstance(field_info, params.Form)\n-                    and is_sequence_field(field)\n-                    and len(value) == 0\n-                )\n-            ):\n-                if field.required:\n-                    errors.append(get_missing_field_error(loc))\n-                else:\n-                    values[field.name] = deepcopy(field.default)\n-                continue\n-            if (\n-                isinstance(field_info, params.File)\n+            isinstance(first_field_info, params.File)\n             and is_bytes_field(field)\n             and isinstance(value, UploadFile)\n         ):\n             value = await value.read()\n         elif (\n             is_bytes_sequence_field(field)\n-                and isinstance(field_info, params.File)\n+            and isinstance(first_field_info, params.File)\n             and value_is_sequence(value)\n         ):\n             # For types\n@@ -774,33 +783,68 @@ async def request_body_to_args(\n                 for sub_value in value:\n                     tg.start_soon(process_fn, sub_value.read)\n             value = serialize_sequence_value(field=field, value=results)\n+        values[field.name] = value\n+    return values\n \n-            v_, errors_ = field.validate(value, values, loc=loc)\n \n-            if isinstance(errors_, list):\n+async def request_body_to_args(\n+    body_fields: List[ModelField],\n+    received_body: Optional[Union[Dict[str, Any], FormData]],\n+    embed_body_fields: bool,\n+) -> Tuple[Dict[str, Any], List[Dict[str, Any]]]:\n+    values: Dict[str, Any] = {}\n+    errors: List[Dict[str, Any]] = []\n+    assert body_fields, \"request_body_to_args() should be called with fields\"\n+    single_not_embedded_field = len(body_fields) == 1 and not embed_body_fields\n+    first_field = body_fields[0]\n+    body_to_process = received_body\n+    if isinstance(received_body, FormData):\n+        body_to_process = await _extract_form_body(body_fields, received_body)\n+\n+    if single_not_embedded_field:\n+        loc: Tuple[str, ...] = (\"body\",)\n+        v_, errors_ = _validate_value_with_model_field(\n+            field=first_field, value=body_to_process, values=values, loc=loc\n+        )\n+        return {first_field.name: v_}, errors_\n+    for field in body_fields:\n+        loc = (\"body\", field.alias)\n+        value: Optional[Any] = None\n+        if body_to_process is not None:\n+            try:\n+                value = body_to_process.get(field.alias)\n+            # If the received body is a list, not a dict\n+            except AttributeError:\n+                errors.append(get_missing_field_error(loc))\n+                continue\n+        v_, errors_ = _validate_value_with_model_field(\n+            field=field, value=value, values=values, loc=loc\n+        )\n+        if errors_:\n             errors.extend(errors_)\n-            elif errors_:\n-                errors.append(errors_)\n         else:\n             values[field.name] = v_\n     return values, errors\n \n \n-def get_body_field(*, dependant: Dependant, name: str) -> Optional[ModelField]:\n-    flat_dependant = get_flat_dependant(dependant)\n+def get_body_field(\n+    *, flat_dependant: Dependant, name: str, embed_body_fields: bool\n+) -> Optional[ModelField]:\n+    \"\"\"\n+    Get a ModelField representing the request body for a path operation, combining\n+    all body parameters into a single field if necessary.\n+\n+    Used to check if it's form data (with `isinstance(body_field, params.Form)`)\n+    or JSON and to generate the JSON Schema for a request body.\n+\n+    This is **not** used to validate/parse the request body, that's done with each\n+    individual body parameter.\n+    \"\"\"\n     if not flat_dependant.body_params:\n         return None\n     first_param = flat_dependant.body_params[0]\n-    field_info = first_param.field_info\n-    embed = getattr(field_info, \"embed\", None)\n-    body_param_names_set = {param.name for param in flat_dependant.body_params}\n-    if len(body_param_names_set) == 1 and not embed:\n+    if not embed_body_fields:\n         return first_param\n-    # If one field requires to embed, all have to be embedded\n-    # in case a sub-dependency is evaluated with a single unique body field\n-    # That is combined (embedded) with other body fields\n-    for param in flat_dependant.body_params:\n-        setattr(param.field_info, \"embed\", True)  # noqa: B010\n     model_name = \"Body_\" + name\n     BodyModel = create_body_model(\n         fields=flat_dependant.body_params, model_name=model_name\n\n@@ -1282,7 +1282,7 @@ def Body(  # noqa: N802\n         ),\n     ] = _Unset,\n     embed: Annotated[\n-        bool,\n+        Union[bool, None],\n         Doc(\n             \"\"\"\n             When `embed` is `True`, the parameter will be expected in a JSON body as a\n@@ -1294,7 +1294,7 @@ def Body(  # noqa: N802\n             [FastAPI docs for Body - Multiple Parameters](https://fastapi.tiangolo.com/tutorial/body-multiple-params/#embed-a-single-body-parameter).\n             \"\"\"\n         ),\n-    ] = False,\n+    ] = None,\n     media_type: Annotated[\n         str,\n         Doc(\n\n@@ -479,7 +479,7 @@ class Body(FieldInfo):\n         *,\n         default_factory: Union[Callable[[], Any], None] = _Unset,\n         annotation: Optional[Any] = None,\n-        embed: bool = False,\n+        embed: Union[bool, None] = None,\n         media_type: str = \"application/json\",\n         alias: Optional[str] = None,\n         alias_priority: Union[int, None] = _Unset,\n@@ -642,7 +642,6 @@ class Form(Body):\n             default=default,\n             default_factory=default_factory,\n             annotation=annotation,\n-            embed=True,\n             media_type=media_type,\n             alias=alias,\n             alias_priority=alias_priority,\n\n@@ -33,8 +33,10 @@ from fastapi._compat import (\n from fastapi.datastructures import Default, DefaultPlaceholder\n from fastapi.dependencies.models import Dependant\n from fastapi.dependencies.utils import (\n+    _should_embed_body_fields,\n     get_body_field,\n     get_dependant,\n+    get_flat_dependant,\n     get_parameterless_sub_dependant,\n     get_typed_return_annotation,\n     solve_dependencies,\n@@ -225,6 +227,7 @@ def get_request_handler(\n     response_model_exclude_defaults: bool = False,\n     response_model_exclude_none: bool = False,\n     dependency_overrides_provider: Optional[Any] = None,\n+    embed_body_fields: bool = False,\n ) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n     assert dependant.call is not None, \"dependant.call must be a function\"\n     is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n@@ -291,6 +294,7 @@ def get_request_handler(\n                     body=body,\n                     dependency_overrides_provider=dependency_overrides_provider,\n                     async_exit_stack=async_exit_stack,\n+                    embed_body_fields=embed_body_fields,\n                 )\n                 errors = solved_result.errors\n                 if not errors:\n@@ -354,7 +358,9 @@ def get_request_handler(\n \n \n def get_websocket_app(\n-    dependant: Dependant, dependency_overrides_provider: Optional[Any] = None\n+    dependant: Dependant,\n+    dependency_overrides_provider: Optional[Any] = None,\n+    embed_body_fields: bool = False,\n ) -> Callable[[WebSocket], Coroutine[Any, Any, Any]]:\n     async def app(websocket: WebSocket) -> None:\n         async with AsyncExitStack() as async_exit_stack:\n@@ -367,6 +373,7 @@ def get_websocket_app(\n                 dependant=dependant,\n                 dependency_overrides_provider=dependency_overrides_provider,\n                 async_exit_stack=async_exit_stack,\n+                embed_body_fields=embed_body_fields,\n             )\n             if solved_result.errors:\n                 raise WebSocketRequestValidationError(\n@@ -399,11 +406,15 @@ class APIWebSocketRoute(routing.WebSocketRoute):\n                 0,\n                 get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n             )\n-\n+        self._flat_dependant = get_flat_dependant(self.dependant)\n+        self._embed_body_fields = _should_embed_body_fields(\n+            self._flat_dependant.body_params\n+        )\n         self.app = websocket_session(\n             get_websocket_app(\n                 dependant=self.dependant,\n                 dependency_overrides_provider=dependency_overrides_provider,\n+                embed_body_fields=self._embed_body_fields,\n             )\n         )\n \n@@ -544,7 +555,15 @@ class APIRoute(routing.Route):\n                 0,\n                 get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n             )\n-        self.body_field = get_body_field(dependant=self.dependant, name=self.unique_id)\n+        self._flat_dependant = get_flat_dependant(self.dependant)\n+        self._embed_body_fields = _should_embed_body_fields(\n+            self._flat_dependant.body_params\n+        )\n+        self.body_field = get_body_field(\n+            flat_dependant=self._flat_dependant,\n+            name=self.unique_id,\n+            embed_body_fields=self._embed_body_fields,\n+        )\n         self.app = request_response(self.get_route_handler())\n \n     def get_route_handler(self) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n@@ -561,6 +580,7 @@ class APIRoute(routing.Route):\n             response_model_exclude_defaults=self.response_model_exclude_defaults,\n             response_model_exclude_none=self.response_model_exclude_none,\n             dependency_overrides_provider=self.dependency_overrides_provider,\n+            embed_body_fields=self._embed_body_fields,\n         )\n \n     def matches(self, scope: Scope) -> Tuple[Match, Scope]:\n\n@@ -1,11 +1,13 @@\n-from typing import List, Union\n+from typing import Any, Dict, List, Union\n \n from fastapi import FastAPI, UploadFile\n from fastapi._compat import (\n     ModelField,\n     Undefined,\n     _get_model_config,\n+    get_model_fields,\n     is_bytes_sequence_annotation,\n+    is_scalar_field,\n     is_uploadfile_sequence_annotation,\n )\n from fastapi.testclient import TestClient\n@@ -91,3 +93,12 @@ def test_is_uploadfile_sequence_annotation():\n     # and other types, but I'm not even sure it's a good idea to support it as a first\n     # class \"feature\"\n     assert is_uploadfile_sequence_annotation(Union[List[str], List[UploadFile]])\n+\n+\n+def test_is_pv1_scalar_field():\n+    # For coverage\n+    class Model(BaseModel):\n+        foo: Union[str, Dict[str, Any]]\n+\n+    fields = get_model_fields(Model)\n+    assert not is_scalar_field(fields[0])\n\n@@ -0,0 +1,99 @@\n+from fastapi import FastAPI, Form\n+from fastapi.testclient import TestClient\n+from typing_extensions import Annotated\n+\n+app = FastAPI()\n+\n+\n+@app.post(\"/form/\")\n+def post_form(username: Annotated[str, Form()]):\n+    return username\n+\n+\n+client = TestClient(app)\n+\n+\n+def test_single_form_field():\n+    response = client.post(\"/form/\", data={\"username\": \"Rick\"})\n+    assert response.status_code == 200, response.text\n+    assert response.json() == \"Rick\"\n+\n+\n+def test_openapi_schema():\n+    response = client.get(\"/openapi.json\")\n+    assert response.status_code == 200, response.text\n+    assert response.json() == {\n+        \"openapi\": \"3.1.0\",\n+        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n+        \"paths\": {\n+            \"/form/\": {\n+                \"post\": {\n+                    \"summary\": \"Post Form\",\n+                    \"operationId\": \"post_form_form__post\",\n+                    \"requestBody\": {\n+                        \"content\": {\n+                            \"application/x-www-form-urlencoded\": {\n+                                \"schema\": {\n+                                    \"$ref\": \"#/components/schemas/Body_post_form_form__post\"\n+                                }\n+                            }\n+                        },\n+                        \"required\": True,\n+                    },\n+                    \"responses\": {\n+                        \"200\": {\n+                            \"description\": \"Successful Response\",\n+                            \"content\": {\"application/json\": {\"schema\": {}}},\n+                        },\n+                        \"422\": {\n+                            \"description\": \"Validation Error\",\n+                            \"content\": {\n+                                \"application/json\": {\n+                                    \"schema\": {\n+                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n+                                    }\n+                                }\n+                            },\n+                        },\n+                    },\n+                }\n+            }\n+        },\n+        \"components\": {\n+            \"schemas\": {\n+                \"Body_post_form_form__post\": {\n+                    \"properties\": {\"username\": {\"type\": \"string\", \"title\": \"Username\"}},\n+                    \"type\": \"object\",\n+                    \"required\": [\"username\"],\n+                    \"title\": \"Body_post_form_form__post\",\n+                },\n+                \"HTTPValidationError\": {\n+                    \"properties\": {\n+                        \"detail\": {\n+                            \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n+                            \"type\": \"array\",\n+                            \"title\": \"Detail\",\n+                        }\n+                    },\n+                    \"type\": \"object\",\n+                    \"title\": \"HTTPValidationError\",\n+                },\n+                \"ValidationError\": {\n+                    \"properties\": {\n+                        \"loc\": {\n+                            \"items\": {\n+                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]\n+                            },\n+                            \"type\": \"array\",\n+                            \"title\": \"Location\",\n+                        },\n+                        \"msg\": {\"type\": \"string\", \"title\": \"Message\"},\n+                        \"type\": {\"type\": \"string\", \"title\": \"Error Type\"},\n+                    },\n+                    \"type\": \"object\",\n+                    \"required\": [\"loc\", \"msg\", \"type\"],\n+                    \"title\": \"ValidationError\",\n+                },\n+            }\n+        },\n+    }\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
