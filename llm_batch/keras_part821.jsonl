{"custom_id": "keras#a1bbbc505af85cbda4786d62c7c66fa42c167072", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 12 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 13 | Churn Cumulative: 58 | Contributors (this commit): 3 | Commits (past 90d): 7 | Contributors (cumulative): 6 | DMM Complexity: 1.0\n\nDIFF:\n@@ -316,6 +316,7 @@ class StringLookup(IndexLookup):\n             raise ValueError(\n                 \"`sparse=True` can only be used with the \" \"TensorFlow backend.\"\n             )\n+        self.encoding = encoding\n         super().__init__(\n             max_tokens=max_tokens,\n             num_oov_indices=num_oov_indices,\n@@ -331,7 +332,6 @@ class StringLookup(IndexLookup):\n             vocabulary_dtype=\"string\",\n             **kwargs,\n         )\n-        self.encoding = encoding\n         self._convert_input_args = False\n         self._allow_non_tensor_positional_args = True\n         self.supports_jit = False\n\n@@ -5,6 +5,7 @@ from tensorflow import data as tf_data\n from keras.src import backend\n from keras.src import layers\n from keras.src import testing\n+from keras.src.ops import convert_to_tensor\n \n \n class StringLookupTest(testing.TestCase):\n@@ -79,3 +80,13 @@ class StringLookupTest(testing.TestCase):\n         for output in ds.take(1):\n             output = output.numpy()\n         self.assertAllClose(output, np.array([2, 3, 0]))\n+\n+    @pytest.mark.skipif(not backend.backend() == \"tensorflow\", reason=\"tf only\")\n+    def test_tensor_as_vocab(self):\n+        vocab = convert_to_tensor([\"a\", \"b\", \"c\", \"d\"])\n+        data = [[\"a\", \"c\", \"d\"], [\"d\", \"z\", \"b\"]]\n+        layer = layers.StringLookup(\n+            vocabulary=vocab,\n+        )\n+        output = layer(data)\n+        self.assertAllClose(output, np.array([[1, 3, 4], [4, 0, 2]]))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#53940d75b2c17712885acad7fc2163b820b37638", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 33 | Lines Deleted: 11 | Files Changed: 5 | Hunks: 13 | Methods Changed: 5 | Complexity Δ (Sum/Max): 3/2 | Churn Δ: 44 | Churn Cumulative: 246 | Contributors (this commit): 4 | Commits (past 90d): 19 | Contributors (cumulative): 14 | DMM Complexity: 1.0\n\nDIFF:\n@@ -464,7 +464,13 @@ class FeatureSpaceTest(testing.TestCase):\n         out = fs(data)\n         self.assertEqual(tuple(out.shape), (10, 32))\n \n-    @pytest.mark.skipif(backend.backend() == \"numpy\", reason=\"TODO: debug it\")\n+    @pytest.mark.skipif(\n+        backend.backend() in (\"numpy\", \"torch\"),\n+        reason=(\n+            \"TODO: When using FeatureSpace as a Model in torch and numpy, \"\n+            \"the error is large.\"\n+        ),\n+    )\n     def test_saving(self):\n         cls = feature_space.FeatureSpace\n         fs = feature_space.FeatureSpace(\n\n@@ -306,22 +306,25 @@ class Normalization(TFDataLayer):\n         inputs = self.backend.core.convert_to_tensor(\n             inputs, dtype=self.compute_dtype\n         )\n+        # Enusre the weights are in the correct backend. Without this, it is\n+        # possible to cause breakage when using this layer in tf.data.\n+        mean = self.convert_weight(self.mean)\n+        variance = self.convert_weight(self.variance)\n         if self.invert:\n             return self.backend.numpy.add(\n-                self.mean,\n+                mean,\n                 self.backend.numpy.multiply(\n                     inputs,\n                     self.backend.numpy.maximum(\n-                        self.backend.numpy.sqrt(self.variance),\n-                        backend.epsilon(),\n+                        self.backend.numpy.sqrt(variance), backend.epsilon()\n                     ),\n                 ),\n             )\n         else:\n             return self.backend.numpy.divide(\n-                self.backend.numpy.subtract(inputs, self.mean),\n+                self.backend.numpy.subtract(inputs, mean),\n                 self.backend.numpy.maximum(\n-                    self.backend.numpy.sqrt(self.variance), backend.epsilon()\n+                    self.backend.numpy.sqrt(variance), backend.epsilon()\n                 ),\n             )\n \n\n@@ -55,3 +55,11 @@ class TFDataLayer(Layer):\n         seed_generator = SeedGenerator(self.seed, backend=self.backend)\n         self._backend_generators[backend] = seed_generator\n         return seed_generator\n+\n+    def convert_weight(self, weight):\n+        \"\"\"Convert the weight if it is from the a different backend.\"\"\"\n+        if self.backend.name == keras.backend.backend():\n+            return weight\n+        else:\n+            weight = keras.ops.convert_to_numpy(weight)\n+            return self.backend.convert_to_tensor(weight)\n\n@@ -445,9 +445,9 @@ class LinalgOpsCorrectnessTest(testing.TestCase, parameterized.TestCase):\n     )\n     def test_norm(self, ndim, ord, axis, keepdims):\n         if ndim == 1:\n-            x = np.random.random((5,))\n+            x = np.random.random((5,)).astype(\"float32\")\n         else:\n-            x = np.random.random((5, 6))\n+            x = np.random.random((5, 6)).astype(\"float32\")\n \n         vector_norm = (ndim == 1) or isinstance(axis, int)\n \n@@ -482,7 +482,7 @@ class LinalgOpsCorrectnessTest(testing.TestCase, parameterized.TestCase):\n         expected_result = np.linalg.norm(\n             x, ord=ord, axis=axis, keepdims=keepdims\n         )\n-        self.assertAllClose(output, expected_result)\n+        self.assertAllClose(output, expected_result, atol=1e-5)\n \n     def test_qr(self):\n         x = np.random.random((4, 5))\n@@ -526,12 +526,13 @@ class LinalgOpsCorrectnessTest(testing.TestCase, parameterized.TestCase):\n         self.assertAllClose(output, expected_result)\n \n     def test_svd(self):\n-        x = np.random.rand(4, 30, 20)\n+        x = np.random.rand(4, 30, 20).astype(\"float32\")\n         u, s, vh = linalg.svd(x)\n         x_reconstructed = (u[..., :, : s.shape[-1]] * s[..., None, :]) @ vh[\n             ..., : s.shape[-1], :\n         ]\n-        self.assertAllClose(x_reconstructed, x, atol=1e-4)\n+        # High tolerance due to numerical instability\n+        self.assertAllClose(x_reconstructed, x, atol=1e-3)\n \n     @parameterized.named_parameters(\n         (\"b_rank_1\", 1, None),\n\n@@ -65,6 +65,10 @@ class DynamicBackend:\n     def reset(self):\n         self._backend = backend_module.backend()\n \n+    @property\n+    def name(self):\n+        return self._backend\n+\n     def __getattr__(self, name):\n         if self._backend == \"tensorflow\":\n             from keras.src.backend import tensorflow as tf_backend\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#8481973d90606dbff677737a9572532f84c22277", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 12 | Churn Cumulative: 24 | Contributors (this commit): 2 | Commits (past 90d): 2 | Contributors (cumulative): 2 | DMM Complexity: 0.0\n\nDIFF:\n@@ -214,12 +214,20 @@ class Lambda(Layer):\n                     closure=inner_config[\"closure\"],\n                 )\n                 config[\"output_shape\"] = fn\n-            else:\n-                config[\"output_shape\"] = (\n+            elif (\n+                isinstance(fn_config, list)\n+                and all(isinstance(e, (int, None)) for e in fn_config)\n+            ):\n+                config[\"output_shape\"] = tuple(\n                     serialization_lib.deserialize_keras_object(\n                         fn_config, custom_objects=custom_objects\n                     )\n                 )\n+            else:\n+                config[\"output_shape\"] = serialization_lib.deserialize_keras_object(\n+                    fn_config, custom_objects=custom_objects\n+                )\n+\n         if \"arguments\" in config:\n             config[\"arguments\"] = serialization_lib.deserialize_keras_object(\n                 config[\"arguments\"], custom_objects=custom_objects\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#26f438edd5516bf02504a5a0e13a20ceec69cb29", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 10 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 16 | Churn Cumulative: 40 | Contributors (this commit): 3 | Commits (past 90d): 3 | Contributors (cumulative): 3 | DMM Complexity: 1.0\n\nDIFF:\n@@ -214,19 +214,15 @@ class Lambda(Layer):\n                     closure=inner_config[\"closure\"],\n                 )\n                 config[\"output_shape\"] = fn\n-            elif (\n-                isinstance(fn_config, list)\n-                and all(isinstance(e, (int, None)) for e in fn_config)\n-            ):\n-                config[\"output_shape\"] = tuple(\n-                    serialization_lib.deserialize_keras_object(\n-                        fn_config, custom_objects=custom_objects\n-                    )\n-                )\n             else:\n-                config[\"output_shape\"] = serialization_lib.deserialize_keras_object(\n+                output_shape = serialization_lib.deserialize_keras_object(\n                     fn_config, custom_objects=custom_objects\n                 )\n+                if isinstance(output_shape, list) and all(\n+                    isinstance(e, (int, None)) for e in output_shape\n+                ):\n+                    output_shape = tuple(output_shape)\n+                config[\"output_shape\"] = output_shape\n \n         if \"arguments\" in config:\n             config[\"arguments\"] = serialization_lib.deserialize_keras_object(\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#c94663711d738b50af324214d89f895e046a2b66", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 37 | Lines Deleted: 4 | Files Changed: 4 | Hunks: 5 | Methods Changed: 5 | Complexity Δ (Sum/Max): 3/6 | Churn Δ: 41 | Churn Cumulative: 973 | Contributors (this commit): 7 | Commits (past 90d): 19 | Contributors (cumulative): 17 | DMM Complexity: 1.0\n\nDIFF:\n@@ -448,10 +448,6 @@ def one_hot(x, num_classes, axis=-1, dtype=\"float32\", sparse=False):\n     x = convert_to_tensor(x)\n     input_shape = x.shape\n \n-    # Shrink the last dimension if the shape is (..., 1).\n-    if input_shape and input_shape[-1] == 1 and len(input_shape) > 1:\n-        input_shape = tuple(input_shape[:-1])\n-\n     x = x.reshape(-1)\n     if not num_classes:\n         num_classes = np.max(x) + 1\n\n@@ -195,6 +195,16 @@ class CategoryEncodingTest(testing.TestCase, parameterized.TestCase):\n             layer.compute_output_shape(input_data.shape),\n         )\n \n+        # Test compute_output_shape with 1 extra dimension\n+        input_data = np.array([[3], [2], [0], [1]])\n+        layer = layers.CategoryEncoding(\n+            num_tokens=num_tokens, output_mode=\"one_hot\", sparse=sparse\n+        )\n+        self.assertEqual(\n+            layer(input_data).shape,\n+            layer.compute_output_shape(input_data.shape),\n+        )\n+\n         input_data = np.array((4,))\n         layer = layers.CategoryEncoding(\n             num_tokens=num_tokens, output_mode=\"one_hot\", sparse=sparse\n\n@@ -1650,6 +1650,15 @@ class NNOpsCorrectnessTest(testing.TestCase, parameterized.TestCase):\n         )\n         self.assertSparse(output_2d, sparse)\n \n+        # Test 1D one-hot with 1 extra dimension.\n+        indices_1d = np.array([[0], [1], [2], [3]])\n+        output_1d = knn.one_hot(indices_1d, 4, sparse=sparse)\n+        self.assertAllClose(output_1d, np.eye(4)[indices_1d])\n+        self.assertSparse(output_1d, sparse)\n+        output_1d = knn.one_hot(indices_1d, 4, axis=0, sparse=sparse)\n+        self.assertAllClose(output_1d, np.eye(4)[indices_1d].swapaxes(1, 2))\n+        self.assertSparse(output_1d, sparse)\n+\n         # Test 1D one-hot with negative inputs\n         indices_1d = np.array([0, -1, -1, 3])\n         output_1d = knn.one_hot(indices_1d, 4, sparse=sparse)\n\n@@ -73,6 +73,15 @@ def to_categorical(x, num_classes=None):\n     [0. 0. 0. 0.]\n     \"\"\"\n     if backend.is_tensor(x):\n+        input_shape = backend.core.shape(x)\n+        # Shrink the last dimension if the shape is (..., 1).\n+        if (\n+            input_shape is not None\n+            and len(input_shape) > 1\n+            and input_shape[-1] == 1\n+        ):\n+            newshape = tuple(input_shape[:-1])\n+            x = backend.numpy.reshape(x, newshape)\n         return backend.nn.one_hot(x, num_classes)\n     x = np.array(x, dtype=\"int64\")\n     input_shape = x.shape\n@@ -130,6 +139,15 @@ def encode_categorical_inputs(\n             inputs, depth, dtype=dtype, sparse=sparse\n         )\n     elif output_mode == \"one_hot\":\n+        input_shape = backend_module.core.shape(inputs)\n+        # Shrink the last dimension if the shape is (..., 1).\n+        if (\n+            input_shape is not None\n+            and len(input_shape) > 1\n+            and input_shape[-1] == 1\n+        ):\n+            newshape = tuple(input_shape[:-1])\n+            inputs = backend_module.numpy.reshape(inputs, newshape)\n         return backend_module.nn.one_hot(\n             inputs, depth, dtype=dtype, sparse=sparse\n         )\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#41aff3dbf0e8bcb43f047062f32c4bc66b976e2d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 12 | Contributors (this commit): 2 | Commits (past 90d): 2 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -14,7 +14,7 @@ class Permute(Layer):\n     Args:\n         dims: Tuple of integers. Permutation pattern does not include the\n             batch dimension. Indexing starts at 1.\n-            For instance, `(2, 1)` permutes the first and second dimensions\n+            For instance, `(1, 3, 2)` permutes the second and third dimensions\n             of the input.\n \n     Input shape:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#33756c12ea19a4a61cfeb1e284b29a109bce522e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 71 | Lines Deleted: 16 | Files Changed: 2 | Hunks: 6 | Methods Changed: 4 | Complexity Δ (Sum/Max): 9/7 | Churn Δ: 87 | Churn Cumulative: 109 | Contributors (this commit): 2 | Commits (past 90d): 4 | Contributors (cumulative): 3 | DMM Complexity: 0.0\n\nDIFF:\n@@ -60,6 +60,11 @@ class DynamicBackend:\n         self._backend = backend or backend_module.backend()\n \n     def set_backend(self, backend):\n+        if backend not in (\"tensorflow\", \"jax\", \"torch\", \"numpy\"):\n+            raise ValueError(\n+                \"Available backends are ('tensorflow', 'jax', 'torch' and \"\n+                f\"'numpy'). Received: backend={backend}\"\n+            )\n         self._backend = backend\n \n     def reset(self):\n@@ -71,25 +76,22 @@ class DynamicBackend:\n \n     def __getattr__(self, name):\n         if self._backend == \"tensorflow\":\n-            from keras.src.backend import tensorflow as tf_backend\n-\n-            return getattr(tf_backend, name)\n+            module = importlib.import_module(\"keras.src.backend.tensorflow\")\n+            return getattr(module, name)\n         if self._backend == \"jax\":\n-            from keras.src.backend import jax as jax_backend\n-\n-            return getattr(jax_backend, name)\n+            module = importlib.import_module(\"keras.src.backend.jax\")\n+            return getattr(module, name)\n         if self._backend == \"torch\":\n-            from keras.src.backend import torch as torch_backend\n-\n-            return getattr(torch_backend, name)\n+            module = importlib.import_module(\"keras.src.backend.torch\")\n+            return getattr(module, name)\n         if self._backend == \"numpy\":\n-            # TODO (ariG23498):\n-            # The import `from keras.src.backend import numpy as numpy_backend`\n-            # is not working. This is a temporary fix.\n-            # The import is redirected to `keras.backend.numpy.numpy.py`\n-            from keras.src import backend as numpy_backend\n-\n-            return getattr(numpy_backend, name)\n+            if backend_module.backend() == \"numpy\":\n+                return getattr(backend_module, name)\n+            else:\n+                raise NotImplementedError(\n+                    \"Currently, we cannot dynamically import the numpy backend \"\n+                    \"because it would disrupt the namespace of the import.\"\n+                )\n \n \n @keras_export(\"keras.config.set_backend\")\n\n@@ -0,0 +1,53 @@\n+import numpy as np\n+from absl.testing import parameterized\n+\n+from keras.src import backend\n+from keras.src import testing\n+from keras.src.utils import backend_utils\n+\n+\n+class BackendUtilsTest(testing.TestCase, parameterized.TestCase):\n+    @parameterized.named_parameters(\n+        (\"numpy\", \"numpy\"),\n+        (\"jax\", \"jax\"),\n+        (\"tensorflow\", \"tensorflow\"),\n+        (\"torch\", \"torch\"),\n+    )\n+    def test_dynamic_backend(self, name):\n+        dynamic_backend = backend_utils.DynamicBackend()\n+        x = np.random.uniform(size=[1, 2, 3])\n+\n+        if name == \"numpy\":\n+            dynamic_backend.set_backend(name)\n+            if backend.backend() != \"numpy\":\n+                with self.assertRaisesRegex(\n+                    NotImplementedError,\n+                    \"Currently, we cannot dynamically import the numpy backend\",\n+                ):\n+                    y = dynamic_backend.numpy.log10(x)\n+            else:\n+                y = dynamic_backend.numpy.log10(x)\n+                self.assertIsInstance(y, np.ndarray)\n+        elif name == \"jax\":\n+            import jax\n+\n+            dynamic_backend.set_backend(name)\n+            y = dynamic_backend.numpy.log10(x)\n+            self.assertIsInstance(y, jax.Array)\n+        elif name == \"tensorflow\":\n+            import tensorflow as tf\n+\n+            dynamic_backend.set_backend(name)\n+            y = dynamic_backend.numpy.log10(x)\n+            self.assertIsInstance(y, tf.Tensor)\n+        elif name == \"torch\":\n+            import torch\n+\n+            dynamic_backend.set_backend(name)\n+            y = dynamic_backend.numpy.log10(x)\n+            self.assertIsInstance(y, torch.Tensor)\n+\n+    def test_dynamic_backend_invalid_name(self):\n+        dynamic_backend = backend_utils.DynamicBackend()\n+        with self.assertRaisesRegex(ValueError, \"Available backends are\"):\n+            dynamic_backend.set_backend(\"abc\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#bf607fffbac61ab3bf509094c9b7a6a17853458c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 66 | Lines Deleted: 0 | Files Changed: 6 | Hunks: 8 | Methods Changed: 7 | Complexity Δ (Sum/Max): 9/3 | Churn Δ: 66 | Churn Cumulative: 431 | Contributors (this commit): 4 | Commits (past 90d): 21 | Contributors (cumulative): 18 | DMM Complexity: 1.0\n\nDIFF:\n@@ -181,6 +181,10 @@ class Functional(Function, Model):\n         # From Function\n         return super().compute_output_spec(inputs)\n \n+    def compute_output_shape(self, input_shape):\n+        # From Function\n+        return super().compute_output_shape(input_shape)\n+\n     def build(self, input_shape):\n         self.built = True\n \n\n@@ -118,6 +118,20 @@ class FunctionalTest(testing.TestCase):\n         out_val = model(in_val)\n         self.assertEqual(out_val.shape, (2, 4))\n \n+    def test_basic_flow_as_a_submodel(self):\n+        # Build submodel\n+        submodel_inputs = Input([4])\n+        submodel_outputs = layers.Flatten()(submodel_inputs)\n+        submodel = Model(submodel_inputs, submodel_outputs)\n+\n+        inputs = Input((None, 4))\n+        outputs = layers.TimeDistributed(submodel)(inputs)\n+        model = Model(inputs=inputs, outputs=outputs)\n+\n+        x = np.random.random((2, 3, 4))\n+        y = model(x)\n+        self.assertEqual(y.shape, (2, 3, 4))\n+\n     @pytest.mark.requires_trainable_backend\n     def test_named_input_dict_io(self):\n         input_a = Input(shape=(3,), batch_size=2, name=\"a\")\n\n@@ -252,6 +252,15 @@ class Sequential(Model):\n             inputs = outputs\n         return outputs\n \n+    def compute_output_shape(self, input_shape):\n+        if self._functional:\n+            return self._functional.compute_output_shape(input_shape)\n+        # Direct application\n+        for layer in self.layers:\n+            output_shape = layer.compute_output_shape(input_shape)\n+            input_shape = output_shape\n+        return output_shape\n+\n     @property\n     def input_shape(self):\n         if self._functional:\n\n@@ -8,6 +8,7 @@ from keras.src import layers\n from keras.src import testing\n from keras.src.layers.core.input_layer import Input\n from keras.src.models.functional import Functional\n+from keras.src.models.model import Model\n from keras.src.models.sequential import Sequential\n \n \n@@ -135,6 +136,20 @@ class SequentialTest(testing.TestCase):\n         y = model(x)\n         self.assertEqual(y.shape, (3, 4))\n \n+    def test_basic_flow_as_a_submodel(self):\n+        # Build submodel\n+        submodel = Sequential()\n+        submodel.add(layers.Flatten())\n+        self.assertFalse(submodel.built)\n+\n+        inputs = Input((None, 4))\n+        outputs = layers.TimeDistributed(submodel)(inputs)\n+        model = Model(inputs=inputs, outputs=outputs)\n+\n+        x = np.random.random((2, 3, 4))\n+        y = model(x)\n+        self.assertEqual(y.shape, (2, 3, 4))\n+\n     def test_dict_inputs(self):\n         class DictLayer(layers.Layer):\n             def call(self, inputs):\n@@ -271,3 +286,8 @@ class SequentialTest(testing.TestCase):\n             ValueError, \"can only have a single positional\"\n         ):\n             model.build((None, 2))\n+\n+    def test_compute_output_shape(self):\n+        layer = Sequential([layers.Dense(4), layers.Dense(8)])\n+        output_shape = layer.compute_output_shape((1, 2))\n+        self.assertEqual(output_shape, (1, 8))\n\n@@ -118,6 +118,20 @@ class Function(Operation):\n             inputs, operation_fn=lambda op: op.compute_output_spec\n         )\n \n+    def compute_output_shape(self, input_shape):\n+        # Wrap `input_shape` into the structure of KerasTensor to utilize\n+        # `compute_output_spec`.\n+        input_shape_struct = tree.map_shape_structure(\n+            lambda x: KerasTensor(shape=x), input_shape\n+        )\n+        # Ensure that dtype and sparse settings are the same as self._inputs,\n+        # because we only care about the shape in this function.\n+        for x, x_ref in zip(tree.flatten(input_shape_struct), self._inputs):\n+            x.dtype = x_ref.dtype\n+            x.sparse = x_ref.sparse\n+        output_spec = self.compute_output_spec(input_shape_struct)\n+        return tree.map_structure(lambda x: x.shape, output_spec)\n+\n     def call(self, inputs):\n         \"\"\"Computes output tensors for new inputs.\"\"\"\n         self._assert_input_compatibility(inputs)\n\n@@ -55,6 +55,11 @@ class FunctionTest(testing.TestCase):\n         self.assertIsInstance(out, keras_tensor.KerasTensor)\n         self.assertEqual(out.shape, (4, 3))\n \n+        # Test with compute_output_shape\n+        out = fn.compute_output_shape((None, 3))\n+        self.assertIsInstance(out, tuple)\n+        self.assertEqual(out, (None, 3))\n+\n         # Test with call\n         out = fn(keras_tensor.KerasTensor((4, 3)))\n         self.assertIsInstance(out, keras_tensor.KerasTensor)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#4b4cf604445810562272655163e643f601e16441", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 127 | Contributors (this commit): 6 | Commits (past 90d): 8 | Contributors (cumulative): 6 | DMM Complexity: None\n\nDIFF:\n@@ -138,9 +138,9 @@ class Model(Trainer, base_trainer.Trainer, Layer):\n     def __new__(cls, *args, **kwargs):\n         # Signature detection for usage of `Model` as a `Functional`\n         if functional_init_arguments(args, kwargs) and cls == Model:\n-            from keras.src.models import functional\n+            from keras.src.models.functional import Functional\n \n-            return functional.Functional(*args, **kwargs)\n+            return Functional.__new__(Functional, *args, **kwargs)\n         return typing.cast(Model, super().__new__(cls))\n \n     def __init__(self, *args, **kwargs):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#a2df0f9ac595639aa2d3a0359122b030d934389e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 17 | Contributors (this commit): 3 | Commits (past 90d): 3 | Contributors (cumulative): 3 | DMM Complexity: 1.0\n\nDIFF:\n@@ -243,6 +243,7 @@ class LayerNormalization(Layer):\n             \"epsilon\": self.epsilon,\n             \"center\": self.center,\n             \"scale\": self.scale,\n+            \"rms_scaling\": self.rms_scaling,\n             \"beta_initializer\": initializers.serialize(self.beta_initializer),\n             \"gamma_initializer\": initializers.serialize(self.gamma_initializer),\n             \"beta_regularizer\": regularizers.serialize(self.beta_regularizer),\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#13ac85cb2af7a9500d0ed6316265beee440ca4af", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 23 | Lines Deleted: 16 | Files Changed: 5 | Hunks: 13 | Methods Changed: 14 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 39 | Churn Cumulative: 1477 | Contributors (this commit): 6 | Commits (past 90d): 67 | Contributors (cumulative): 28 | DMM Complexity: 1.0\n\nDIFF:\n@@ -598,10 +598,10 @@ def imag(x):\n     return jnp.imag(x)\n \n \n-def isclose(x1, x2):\n+def isclose(x1, x2, rtol=1e-5, atol=1e-8, equal_nan=False):\n     x1 = convert_to_tensor(x1)\n     x2 = convert_to_tensor(x2)\n-    return jnp.isclose(x1, x2)\n+    return jnp.isclose(x1, x2, rtol, atol, equal_nan)\n \n \n @sparse.densifying_unary\n\n@@ -505,8 +505,8 @@ def imag(x):\n     return np.imag(x)\n \n \n-def isclose(x1, x2):\n-    return np.isclose(x1, x2)\n+def isclose(x1, x2, rtol=1e-5, atol=1e-8, equal_nan=False):\n+    return np.isclose(x1, x2, rtol, atol, equal_nan)\n \n \n def isfinite(x):\n\n@@ -8,6 +8,7 @@ import warnings\n import numpy as np\n import tensorflow as tf\n from tensorflow.python.ops.linalg.sparse import sparse_csr_matrix_ops\n+from tensorflow.python.ops.math_ops import is_nan\n \n from keras.src import tree\n from keras.src.backend import config\n@@ -1250,16 +1251,17 @@ def imag(x):\n     return tf.math.imag(x)\n \n \n-def isclose(x1, x2):\n+def isclose(x1, x2, rtol=1e-5, atol=1e-8, equal_nan=False):\n     x1 = convert_to_tensor(x1)\n     x2 = convert_to_tensor(x2)\n     dtype = dtypes.result_type(x1.dtype, x2.dtype)\n     x1 = tf.cast(x1, dtype)\n     x2 = tf.cast(x2, dtype)\n     if \"float\" in dtype:\n-        # atol defaults to 1e-08\n-        # rtol defaults to 1e-05\n-        return tf.abs(x1 - x2) <= (1e-08 + 1e-05 * tf.abs(x2))\n+        result = tf.abs(x1 - x2) <= (atol + rtol * tf.abs(x2))\n+        if equal_nan:\n+            result = result | (is_nan(x1) & is_nan(x2))\n+        return result\n     else:\n         return tf.equal(x1, x2)\n \n\n@@ -697,13 +697,13 @@ def imag(x):\n     return torch.imag(x)\n \n \n-def isclose(x1, x2):\n+def isclose(x1, x2, rtol=1e-5, atol=1e-8, equal_nan=False):\n     x1 = convert_to_tensor(x1)\n     x2 = convert_to_tensor(x2)\n     result_dtype = dtypes.result_type(x1.dtype, x2.dtype)\n     x1 = cast(x1, result_dtype)\n     x2 = cast(x2, result_dtype)\n-    return torch.isclose(x1, x2)\n+    return torch.isclose(x1, x2, rtol, atol, equal_nan)\n \n \n def isfinite(x):\n\n@@ -2801,10 +2801,12 @@ def imag(x):\n \n \n class Isclose(Operation):\n-    def call(self, x1, x2):\n-        return backend.numpy.isclose(x1, x2)\n+    def call(self, x1, x2, rtol=1e-5, atol=1e-8, equal_nan=False):\n+        return backend.numpy.isclose(x1, x2, rtol, atol, equal_nan)\n \n-    def compute_output_spec(self, x1, x2):\n+    def compute_output_spec(\n+        self, x1, x2, rtol=1e-5, atol=1e-8, equal_nan=False\n+    ):\n         x1_shape = getattr(x1, \"shape\", [])\n         x2_shape = getattr(x2, \"shape\", [])\n         output_shape = broadcast_shapes(x1_shape, x2_shape)\n@@ -2812,19 +2814,22 @@ class Isclose(Operation):\n \n \n @keras_export([\"keras.ops.isclose\", \"keras.ops.numpy.isclose\"])\n-def isclose(x1, x2):\n+def isclose(x1, x2, rtol=1e-5, atol=1e-8, equal_nan=False):\n     \"\"\"Return whether two tensors are element-wise almost equal.\n \n     Args:\n         x1: First input tensor.\n         x2: Second input tensor.\n+        rtol: Relative tolerance.\n+        atol: Absolute tolerance.\n+        equal_nan: If `True`, element-wise NaNs are considered equal.\n \n     Returns:\n         Output boolean tensor.\n     \"\"\"\n     if any_symbolic_tensors((x1, x2)):\n-        return Isclose().symbolic_call(x1, x2)\n-    return backend.numpy.isclose(x1, x2)\n+        return Isclose().symbolic_call(x1, x2, rtol, atol, equal_nan)\n+    return backend.numpy.isclose(x1, x2, rtol, atol, equal_nan)\n \n \n class Isfinite(Operation):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#314fa3b9e38a73bd90872f22532efe44c3a9553d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 5 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 10 | Churn Cumulative: 28 | Contributors (this commit): 3 | Commits (past 90d): 3 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -40,11 +40,11 @@ def top_k(x, k, sorted=True):\n \n \n def in_top_k(targets, predictions, k):\n-    targets = targets[..., None]\n-    topk_values = top_k(predictions, k)[0]\n-    targets_values = jnp.take_along_axis(predictions, targets, axis=-1)\n-    mask = targets_values >= topk_values\n-    return jnp.any(mask, axis=1)\n+    preds_at_label = jnp.take_along_axis(\n+        predictions, jnp.expand_dims(targets, axis=-1), axis=-1\n+    )\n+    rank = 1 + jnp.sum(jnp.greater(predictions, preds_at_label), axis=-1)\n+    return jnp.less_equal(rank, k)\n \n \n def logsumexp(x, axis=None, keepdims=False):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#230777a2cefbb3c79f81f28841661784bb8cbf40", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 19 | Lines Deleted: 2 | Files Changed: 3 | Hunks: 3 | Methods Changed: 4 | Complexity Δ (Sum/Max): 2/1 | Churn Δ: 21 | Churn Cumulative: 175 | Contributors (this commit): 5 | Commits (past 90d): 15 | Contributors (cumulative): 11 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1444,6 +1444,10 @@ class Layer(BackendLayer, Operation, KerasSaveable):\n             \"trainable\": self.trainable,\n             \"dtype\": dtype_policies.serialize(self.dtype_policy),\n         }\n+        if self.activity_regularizer is not None:\n+            config[\"activity_regularizer\"] = regularizers.serialize(\n+                self.activity_regularizer\n+            )\n         return {**base_config, **config}\n \n     def _open_name_scope(self):\n\n@@ -980,3 +980,16 @@ class LayerTest(testing.TestCase):\n         layer = layers.Dense(2)\n         reloaded = pickle.loads(pickle.dumps(layer))\n         self.assertEqual(layer.get_config(), reloaded.get_config())\n+\n+    def test_serialize_activity_regularizer(self):\n+        layer = layers.Dense(2, activity_regularizer=\"l2\")\n+        config = layer.get_config()\n+        self.assertIn(\"activity_regularizer\", config)\n+        new_layer = layers.Dense.from_config(config)\n+        self.assertEqual(\n+            new_layer.activity_regularizer.__class__.__name__, \"L2\"\n+        )\n+\n+        layer = layers.Dense(2)\n+        config = layer.get_config()\n+        self.assertNotIn(\"activity_regularizer\", config)\n\n@@ -24,8 +24,8 @@ ALL_OBJECTS_DICT.update(\n \n \n @keras_export(\"keras.regularizers.serialize\")\n-def serialize(initializer):\n-    return serialization_lib.serialize_keras_object(initializer)\n+def serialize(regularizer):\n+    return serialization_lib.serialize_keras_object(regularizer)\n \n \n @keras_export(\"keras.regularizers.deserialize\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#da72e2241ce4488efb036128d87d93e303f0a8f7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 7 | Contributors (this commit): 2 | Commits (past 90d): 2 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -36,5 +36,6 @@ class ActivityRegularization(Layer):\n \n     def get_config(self):\n         base_config = super().get_config()\n+        base_config.pop(\"activity_regularizer\", None)\n         config = {\"l1\": self.l1, \"l2\": self.l2}\n         return {**base_config, **config}\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#857a7acfc2496963dec777e13da8a6486ac50c38", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 42 | Contributors (this commit): 3 | Commits (past 90d): 4 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -219,7 +219,7 @@ class Lambda(Layer):\n                     fn_config, custom_objects=custom_objects\n                 )\n                 if isinstance(output_shape, list) and all(\n-                    isinstance(e, (int, None)) for e in output_shape\n+                    isinstance(e, (int, type(None))) for e in output_shape\n                 ):\n                     output_shape = tuple(output_shape)\n                 config[\"output_shape\"] = output_shape\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#efaaf85e19113400f23462cbafcef433cd95ad9c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 172 | Lines Deleted: 81 | Files Changed: 3 | Hunks: 42 | Methods Changed: 12 | Complexity Δ (Sum/Max): 11/10 | Churn Δ: 253 | Churn Cumulative: 262 | Contributors (this commit): 3 | Commits (past 90d): 7 | Contributors (cumulative): 7 | DMM Complexity: 1.0\n\nDIFF:\n@@ -6,7 +6,7 @@ def register_tree_node_class(cls):\n \n \n def is_nested(structure):\n-    dmtree.is_nested(structure)\n+    return dmtree.is_nested(structure)\n \n \n def traverse(func, structure, top_down=True):\n\n@@ -1,10 +1,12 @@\n import collections\n \n import numpy as np\n+import parameterized\n \n from keras.src import ops\n from keras.src import testing\n-from keras.src import tree\n+from keras.src.utils.module_utils import dmtree\n+from keras.src.utils.module_utils import optree\n \n STRUCTURE1 = (((1, 2), 3), 4, (5, 6))\n STRUCTURE2 = (((\"foo1\", \"foo2\"), \"foo3\"), \"foo4\", (\"foo5\", \"foo6\"))\n@@ -12,50 +14,96 @@ STRUCTURE_DIFFERENT_NUM_ELEMENTS = (\"spam\", \"eggs\")\n STRUCTURE_DIFFERENT_NESTING = (((1, 2), 3), 4, 5, (6,))\n \n \n+@parameterized.parameterized_class(\n+    (\"tree_module\",),\n+    [\n+        (dmtree,),\n+        (optree,),\n+    ],\n+)\n class TreeTest(testing.TestCase):\n+    tree_impl = None\n+    tree_api_name = \"\"\n+\n+    def setUp(self):\n+        super().setUp()\n+        if self.tree_module.available:\n+            if self.tree_module == dmtree:\n+                from keras.src.tree import dmtree_impl as tree_impl\n+\n+                self.tree_impl = tree_impl\n+                self.tree_api_name = \"dmtree\"\n+            elif self.tree_module == optree:\n+                from keras.src.tree import optree_impl as tree_impl\n+\n+                self.tree_impl = tree_impl\n+                self.tree_api_name = \"optree\"\n+            else:\n+                raise ValueError(f\"Unrecognized module {self.tree_module}.\")\n+        else:\n+            self.skipTest(f\"Skip since {self.tree_module} is not available.\")\n+\n     def test_is_nested(self):\n-        self.assertFalse(tree.is_nested(\"1234\"))\n-        self.assertFalse(tree.is_nested(b\"1234\"))\n-        self.assertFalse(tree.is_nested(bytearray(\"1234\", \"ascii\")))\n-        self.assertTrue(tree.is_nested([1, 3, [4, 5]]))\n-        self.assertTrue(tree.is_nested(((7, 8), (5, 6))))\n-        self.assertTrue(tree.is_nested([]))\n-        self.assertTrue(tree.is_nested({\"a\": 1, \"b\": 2}))\n-        self.assertFalse(tree.is_nested(set([1, 2])))\n+        self.assertFalse(self.tree_impl.is_nested(\"1234\"))\n+        self.assertFalse(self.tree_impl.is_nested(b\"1234\"))\n+        self.assertFalse(self.tree_impl.is_nested(bytearray(\"1234\", \"ascii\")))\n+        self.assertTrue(self.tree_impl.is_nested([1, 3, [4, 5]]))\n+        self.assertTrue(self.tree_impl.is_nested(((7, 8), (5, 6))))\n+        self.assertTrue(self.tree_impl.is_nested([]))\n+        self.assertTrue(self.tree_impl.is_nested({\"a\": 1, \"b\": 2}))\n+        self.assertFalse(self.tree_impl.is_nested(set([1, 2])))\n         ones = np.ones([2, 3])\n-        self.assertFalse(tree.is_nested(ones))\n-        self.assertFalse(tree.is_nested(np.tanh(ones)))\n-        self.assertFalse(tree.is_nested(np.ones((4, 5))))\n+        self.assertFalse(self.tree_impl.is_nested(ones))\n+        self.assertFalse(self.tree_impl.is_nested(np.tanh(ones)))\n+        self.assertFalse(self.tree_impl.is_nested(np.ones((4, 5))))\n \n     def test_flatten(self):\n         structure = ((3, 4), 5, (6, 7, (9, 10), 8))\n         flat = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"]\n \n-        self.assertEqual(tree.flatten(structure), [3, 4, 5, 6, 7, 9, 10, 8])\n+        self.assertEqual(\n+            self.tree_impl.flatten(structure), [3, 4, 5, 6, 7, 9, 10, 8]\n+        )\n         point = collections.namedtuple(\"Point\", [\"x\", \"y\"])\n         structure = (point(x=4, y=2), ((point(x=1, y=0),),))\n         flat = [4, 2, 1, 0]\n-        self.assertEqual(tree.flatten(structure), flat)\n+        self.assertEqual(self.tree_impl.flatten(structure), flat)\n \n-        self.assertEqual([5], tree.flatten(5))\n-        self.assertEqual([np.array([5])], tree.flatten(np.array([5])))\n+        self.assertEqual([5], self.tree_impl.flatten(5))\n+        self.assertEqual([np.array([5])], self.tree_impl.flatten(np.array([5])))\n \n     def test_flatten_dict_order(self):\n         ordered = collections.OrderedDict(\n             [(\"d\", 3), (\"b\", 1), (\"a\", 0), (\"c\", 2)]\n         )\n         plain = {\"d\": 3, \"b\": 1, \"a\": 0, \"c\": 2}\n-        ordered_flat = tree.flatten(ordered)\n-        plain_flat = tree.flatten(plain)\n+        ordered_flat = self.tree_impl.flatten(ordered)\n+        plain_flat = self.tree_impl.flatten(plain)\n+        # dmtree does not respect the ordered dict.\n+        if self.tree_api_name == \"optree\":\n             self.assertEqual([3, 1, 0, 2], ordered_flat)\n+        else:\n+            self.assertEqual([0, 1, 2, 3], ordered_flat)\n         self.assertEqual([0, 1, 2, 3], plain_flat)\n \n     def test_map_structure(self):\n+        assertion_message = (\n+            \"have the same structure\"\n+            if self.tree_api_name == \"optree\"\n+            else \"have the same nested structure\"\n+        )\n+        assertion_type_error = (\n+            ValueError if self.tree_api_name == \"optree\" else TypeError\n+        )\n         structure2 = (((7, 8), 9), 10, (11, 12))\n-        structure1_plus1 = tree.map_structure(lambda x: x + 1, STRUCTURE1)\n-        tree.assert_same_structure(STRUCTURE1, structure1_plus1)\n-        self.assertAllEqual([2, 3, 4, 5, 6, 7], tree.flatten(structure1_plus1))\n-        structure1_plus_structure2 = tree.map_structure(\n+        structure1_plus1 = self.tree_impl.map_structure(\n+            lambda x: x + 1, STRUCTURE1\n+        )\n+        self.tree_impl.assert_same_structure(STRUCTURE1, structure1_plus1)\n+        self.assertAllEqual(\n+            [2, 3, 4, 5, 6, 7], self.tree_impl.flatten(structure1_plus1)\n+        )\n+        structure1_plus_structure2 = self.tree_impl.map_structure(\n             lambda x, y: x + y, STRUCTURE1, structure2\n         )\n         self.assertEqual(\n@@ -63,38 +111,49 @@ class TreeTest(testing.TestCase):\n             structure1_plus_structure2,\n         )\n \n-        self.assertEqual(3, tree.map_structure(lambda x: x - 1, 4))\n+        self.assertEqual(3, self.tree_impl.map_structure(lambda x: x - 1, 4))\n \n-        self.assertEqual(7, tree.map_structure(lambda x, y: x + y, 3, 4))\n+        self.assertEqual(\n+            7, self.tree_impl.map_structure(lambda x, y: x + y, 3, 4)\n+        )\n \n         # Empty structures\n-        self.assertEqual((), tree.map_structure(lambda x: x + 1, ()))\n-        self.assertEqual([], tree.map_structure(lambda x: x + 1, []))\n-        self.assertEqual({}, tree.map_structure(lambda x: x + 1, {}))\n+        self.assertEqual((), self.tree_impl.map_structure(lambda x: x + 1, ()))\n+        self.assertEqual([], self.tree_impl.map_structure(lambda x: x + 1, []))\n+        self.assertEqual({}, self.tree_impl.map_structure(lambda x: x + 1, {}))\n         empty_nt = collections.namedtuple(\"empty_nt\", \"\")\n         self.assertEqual(\n-            empty_nt(), tree.map_structure(lambda x: x + 1, empty_nt())\n+            empty_nt(),\n+            self.tree_impl.map_structure(lambda x: x + 1, empty_nt()),\n         )\n \n         # This is checking actual equality of types, empty list != empty tuple\n-        self.assertNotEqual((), tree.map_structure(lambda x: x + 1, []))\n+        self.assertNotEqual(\n+            (), self.tree_impl.map_structure(lambda x: x + 1, [])\n+        )\n \n         with self.assertRaisesRegex(TypeError, \"callable\"):\n-            tree.map_structure(\"bad\", structure1_plus1)\n+            self.tree_impl.map_structure(\"bad\", structure1_plus1)\n         with self.assertRaisesRegex(ValueError, \"at least one structure\"):\n-            tree.map_structure(lambda x: x)\n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.map_structure(lambda x, y: None, (3, 4), (3, 4, 5))\n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.map_structure(lambda x, y: None, 3, (3,))\n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.map_structure(lambda x, y: None, ((3, 4), 5), [(3, 4), 5])\n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.map_structure(lambda x, y: None, ((3, 4), 5), (3, (4, 5)))\n+            self.tree_impl.map_structure(lambda x: x)\n+        with self.assertRaisesRegex(ValueError, assertion_message):\n+            self.tree_impl.map_structure(lambda x, y: None, (3, 4), (3, 4, 5))\n+        with self.assertRaisesRegex(ValueError, assertion_message):\n+            self.tree_impl.map_structure(lambda x, y: None, 3, (3,))\n+        with self.assertRaisesRegex(assertion_type_error, assertion_message):\n+            self.tree_impl.map_structure(\n+                lambda x, y: None, ((3, 4), 5), [(3, 4), 5]\n+            )\n+        with self.assertRaisesRegex(ValueError, assertion_message):\n+            self.tree_impl.map_structure(\n+                lambda x, y: None, ((3, 4), 5), (3, (4, 5))\n+            )\n \n         structure1_list = [[[1, 2], 3], 4, [5, 6]]\n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.map_structure(lambda x, y: None, STRUCTURE1, structure1_list)\n+        with self.assertRaisesRegex(assertion_type_error, assertion_message):\n+            self.tree_impl.map_structure(\n+                lambda x, y: None, STRUCTURE1, structure1_list\n+            )\n \n     def test_map_structure_up_to(self):\n         # Named tuples.\n@@ -102,7 +161,7 @@ class TreeTest(testing.TestCase):\n         op_tuple = collections.namedtuple(\"op_tuple\", \"add, mul\")\n         inp_val = ab_tuple(a=2, b=3)\n         inp_ops = ab_tuple(a=op_tuple(add=1, mul=2), b=op_tuple(add=2, mul=3))\n-        out = tree.map_structure_up_to(\n+        out = self.tree_impl.map_structure_up_to(\n             inp_val,\n             lambda val, ops: (val + ops.add) * ops.mul,\n             inp_val,\n@@ -114,7 +173,7 @@ class TreeTest(testing.TestCase):\n         # Lists.\n         data_list = [[2, 4, 6, 8], [[1, 3, 5, 7, 9], [3, 5, 7]]]\n         name_list = [\"evens\", [\"odds\", \"primes\"]]\n-        out = tree.map_structure_up_to(\n+        out = self.tree_impl.map_structure_up_to(\n             name_list,\n             lambda name, sec: \"first_{}_{}\".format(len(sec), name),\n             name_list,\n@@ -125,37 +184,62 @@ class TreeTest(testing.TestCase):\n         )\n \n     def test_assert_same_structure(self):\n-        tree.assert_same_structure(STRUCTURE1, STRUCTURE2, check_types=False)\n-        tree.assert_same_structure(\"abc\", 1.0, check_types=False)\n-        tree.assert_same_structure(b\"abc\", 1.0, check_types=False)\n-        tree.assert_same_structure(\"abc\", 1.0, check_types=False)\n-        tree.assert_same_structure(\n+        assertion_message = (\n+            \"have the same structure\"\n+            if self.tree_api_name == \"optree\"\n+            else \"have the same nested structure\"\n+        )\n+        assertion_type_error = (\n+            ValueError if self.tree_api_name == \"optree\" else TypeError\n+        )\n+        self.tree_impl.assert_same_structure(\n+            STRUCTURE1, STRUCTURE2, check_types=False\n+        )\n+        self.tree_impl.assert_same_structure(\"abc\", 1.0, check_types=False)\n+        self.tree_impl.assert_same_structure(b\"abc\", 1.0, check_types=False)\n+        self.tree_impl.assert_same_structure(\"abc\", 1.0, check_types=False)\n+        self.tree_impl.assert_same_structure(\n             bytearray(\"abc\", \"ascii\"), 1.0, check_types=False\n         )\n-        tree.assert_same_structure(\"abc\", np.array([0, 1]), check_types=False)\n+        self.tree_impl.assert_same_structure(\n+            \"abc\", np.array([0, 1]), check_types=False\n+        )\n \n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.assert_same_structure(\n+        with self.assertRaisesRegex(ValueError, assertion_message):\n+            self.tree_impl.assert_same_structure(\n                 STRUCTURE1, STRUCTURE_DIFFERENT_NUM_ELEMENTS\n             )\n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.assert_same_structure([0, 1], np.array([0, 1]))\n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.assert_same_structure(0, [0, 1])\n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.assert_same_structure((0, 1), [0, 1])\n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.assert_same_structure(STRUCTURE1, STRUCTURE_DIFFERENT_NESTING)\n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.assert_same_structure([[3], 4], [3, [4]])\n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.assert_same_structure({\"a\": 1}, {\"b\": 1})\n+        with self.assertRaisesRegex(ValueError, assertion_message):\n+            self.tree_impl.assert_same_structure([0, 1], np.array([0, 1]))\n+        with self.assertRaisesRegex(ValueError, assertion_message):\n+            self.tree_impl.assert_same_structure(0, [0, 1])\n+        with self.assertRaisesRegex(assertion_type_error, assertion_message):\n+            self.tree_impl.assert_same_structure((0, 1), [0, 1])\n+        with self.assertRaisesRegex(ValueError, assertion_message):\n+            self.tree_impl.assert_same_structure(\n+                STRUCTURE1, STRUCTURE_DIFFERENT_NESTING\n+            )\n+        with self.assertRaisesRegex(ValueError, assertion_message):\n+            self.tree_impl.assert_same_structure([[3], 4], [3, [4]])\n+        with self.assertRaisesRegex(ValueError, assertion_message):\n+            self.tree_impl.assert_same_structure({\"a\": 1}, {\"b\": 1})\n         structure1_list = [[[1, 2], 3], 4, [5, 6]]\n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.assert_same_structure(STRUCTURE1, structure1_list)\n-        tree.assert_same_structure(STRUCTURE1, STRUCTURE2, check_types=False)\n-        with self.assertRaisesRegex(ValueError, \"have the same structure\"):\n-            tree.assert_same_structure(\n+        with self.assertRaisesRegex(assertion_type_error, assertion_message):\n+            self.tree_impl.assert_same_structure(STRUCTURE1, structure1_list)\n+        self.tree_impl.assert_same_structure(\n+            STRUCTURE1, STRUCTURE2, check_types=False\n+        )\n+        # dm-tree treat list and tuple only on type mismatch, but optree treat\n+        # them as structure mismatch.\n+        if self.tree_api_name == \"optree\":\n+            with self.assertRaisesRegex(\n+                assertion_type_error, assertion_message\n+            ):\n+                self.tree_impl.assert_same_structure(\n+                    STRUCTURE1, structure1_list, check_types=False\n+                )\n+        else:\n+            self.tree_impl.assert_same_structure(\n                 STRUCTURE1, structure1_list, check_types=False\n             )\n \n@@ -163,13 +247,13 @@ class TreeTest(testing.TestCase):\n         structure = {\"key3\": \"\", \"key1\": \"\", \"key2\": \"\"}\n         flat_sequence = [\"value1\", \"value2\", \"value3\"]\n         self.assertEqual(\n-            tree.pack_sequence_as(structure, flat_sequence),\n+            self.tree_impl.pack_sequence_as(structure, flat_sequence),\n             {\"key3\": \"value3\", \"key1\": \"value1\", \"key2\": \"value2\"},\n         )\n         structure = ((\"a\", \"b\"), (\"c\", \"d\", \"e\"), \"f\")\n         flat_sequence = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n         self.assertEqual(\n-            tree.pack_sequence_as(structure, flat_sequence),\n+            self.tree_impl.pack_sequence_as(structure, flat_sequence),\n             ((1.0, 2.0), (3.0, 4.0, 5.0), 6.0),\n         )\n         structure = {\n@@ -178,7 +262,7 @@ class TreeTest(testing.TestCase):\n         }\n         flat_sequence = [\"val2\", \"val1\", 3.0, 1.0, 2.0]\n         self.assertEqual(\n-            tree.pack_sequence_as(structure, flat_sequence),\n+            self.tree_impl.pack_sequence_as(structure, flat_sequence),\n             {\n                 \"key3\": {\"c\": (1.0, 2.0), \"a\": 3.0},\n                 \"key1\": {\"e\": \"val1\", \"d\": \"val2\"},\n@@ -187,39 +271,43 @@ class TreeTest(testing.TestCase):\n         structure = [\"a\"]\n         flat_sequence = [np.array([[1, 2], [3, 4]])]\n         self.assertAllClose(\n-            tree.pack_sequence_as(structure, flat_sequence),\n+            self.tree_impl.pack_sequence_as(structure, flat_sequence),\n             [np.array([[1, 2], [3, 4]])],\n         )\n         structure = [\"a\"]\n         flat_sequence = [ops.ones([2, 2])]\n         self.assertAllClose(\n-            tree.pack_sequence_as(structure, flat_sequence),\n+            self.tree_impl.pack_sequence_as(structure, flat_sequence),\n             [ops.ones([2, 2])],\n         )\n \n         with self.assertRaisesRegex(TypeError, \"Attempted to pack value:\"):\n             structure = [\"a\"]\n             flat_sequence = 1\n-            tree.pack_sequence_as(structure, flat_sequence)\n+            self.tree_impl.pack_sequence_as(structure, flat_sequence)\n         with self.assertRaisesRegex(ValueError, \"The target structure is of\"):\n             structure = \"a\"\n             flat_sequence = [1, 2]\n-            tree.pack_sequence_as(structure, flat_sequence)\n+            self.tree_impl.pack_sequence_as(structure, flat_sequence)\n \n     def test_lists_to_tuples(self):\n         structure = [1, 2, 3]\n-        self.assertEqual(tree.lists_to_tuples(structure), (1, 2, 3))\n+        self.assertEqual(self.tree_impl.lists_to_tuples(structure), (1, 2, 3))\n         structure = [[1], [2, 3]]\n-        self.assertEqual(tree.lists_to_tuples(structure), ((1,), (2, 3)))\n+        self.assertEqual(\n+            self.tree_impl.lists_to_tuples(structure), ((1,), (2, 3))\n+        )\n         structure = [[1], [2, [3]]]\n-        self.assertEqual(tree.lists_to_tuples(structure), ((1,), (2, (3,))))\n+        self.assertEqual(\n+            self.tree_impl.lists_to_tuples(structure), ((1,), (2, (3,)))\n+        )\n \n     def test_traverse(self):\n         # Lists to tuples\n         structure = [(1, 2), [3], {\"a\": [4]}]\n         self.assertEqual(\n             ((1, 2), (3,), {\"a\": (4,)}),\n-            tree.traverse(\n+            self.tree_impl.traverse(\n                 lambda x: tuple(x) if isinstance(x, list) else x,\n                 structure,\n                 top_down=False,\n@@ -233,7 +321,7 @@ class TreeTest(testing.TestCase):\n             visited.append(x)\n             return \"X\" if isinstance(x, tuple) and len(x) > 2 else None\n \n-        output = tree.traverse(visit, structure)\n+        output = self.tree_impl.traverse(visit, structure)\n         self.assertEqual([(1, [2]), [3, \"X\"]], output)\n         self.assertEqual(\n             [\n\n@@ -35,6 +35,9 @@ class LazyModule:\n             self.initialize()\n         return getattr(self.module, name)\n \n+    def __repr__(self):\n+        return f\"LazyModule({self.name})\"\n+\n \n tensorflow = LazyModule(\"tensorflow\")\n gfile = LazyModule(\"tensorflow.io.gfile\", pip_name=\"tensorflow\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
