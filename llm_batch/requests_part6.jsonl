{"custom_id": "requests#d93731213afad71d8125551ebcbdda0a66691622", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 12 | Files Changed: 1 | Hunks: 14 | Methods Changed: 12 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 28 | Churn Cumulative: 1906 | Contributors (this commit): 6 | Commits (past 90d): 87 | Contributors (cumulative): 6 | DMM Complexity: 1.0\n\nDIFF:\n@@ -14,6 +14,7 @@ from __future__ import absolute_import\n \n import urllib\n import urllib2\n+import socket\n import zlib\n \n from urllib2 import HTTPError\n@@ -63,7 +64,7 @@ class Request(object):\n     _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')\n \n     def __init__(self, url=None, headers=dict(), files=None, method=None,\n-                 data=dict(), auth=None, cookiejar=None):\n+                 data=dict(), auth=None, cookiejar=None, timeout=None):\n \n         self.url = url\n         self.headers = headers\n@@ -71,6 +72,8 @@ class Request(object):\n         self.method = method\n         self.data = data\n         \n+        socket.setdefaulttimeout(timeout)\n+\n         # url encode data if it's a dict\n         if hasattr(data, 'items'):\n             self._enc_data = urllib.urlencode(data)\n@@ -448,13 +451,14 @@ def request(method, url, **kwargs):\n \n     r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),\n                 cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),\n-                auth=kwargs.pop('auth', auth_manager.get_auth(url)))\n+                auth=kwargs.pop('auth', auth_manager.get_auth(url)),\n+                timeout=kwargs.pop('timeout', None))\n     r.send()\n \n     return r.response\n \n \n-def get(url, params={}, headers={}, cookies=None, auth=None):\n+def get(url, params={}, headers={}, cookies=None, auth=None, timeout=None):\n     \"\"\"Sends a GET request. Returns :class:`Response` object.\n \n     :param url: URL for the new :class:`Request` object.\n@@ -464,10 +468,10 @@ def get(url, params={}, headers={}, cookies=None, auth=None):\n     :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n     \"\"\"\n \n-    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth)\n+    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth, timeout=timeout)\n \n \n-def head(url, params={}, headers={}, cookies=None, auth=None):\n+def head(url, params={}, headers={}, cookies=None, auth=None, timeout=None):\n     \"\"\"Sends a HEAD request. Returns :class:`Response` object.\n \n     :param url: URL for the new :class:`Request` object.\n@@ -477,10 +481,10 @@ def head(url, params={}, headers={}, cookies=None, auth=None):\n     :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n     \"\"\"\n \n-    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth)\n+    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth, timeout=timeout)\n \n \n-def post(url, data={}, headers={}, files=None, cookies=None, auth=None):\n+def post(url, data={}, headers={}, files=None, cookies=None, auth=None, timeout=None):\n     \"\"\"Sends a POST request. Returns :class:`Response` object.\n \n     :param url: URL for the new :class:`Request` object.\n@@ -491,10 +495,10 @@ def post(url, data={}, headers={}, files=None, cookies=None, auth=None):\n     :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n     \"\"\"\n \n-    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)\n+    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, timeout=timeout)\n \n \n-def put(url, data='', headers={}, files={}, cookies=None, auth=None):\n+def put(url, data='', headers={}, files={}, cookies=None, auth=None, timeout=None):\n     \"\"\"Sends a PUT request. Returns :class:`Response` object.\n \n     :param url: URL for the new :class:`Request` object.\n@@ -505,10 +509,10 @@ def put(url, data='', headers={}, files={}, cookies=None, auth=None):\n     :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n     \"\"\"\n \n-    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)\n+    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, timeout=timeout)\n \n \n-def delete(url, params={}, headers={}, cookies=None, auth=None):\n+def delete(url, params={}, headers={}, cookies=None, auth=None, timeout=None):\n     \"\"\"Sends a DELETE request. Returns :class:`Response` object.\n \n     :param url: URL for the new :class:`Request` object.\n@@ -518,7 +522,7 @@ def delete(url, params={}, headers={}, cookies=None, auth=None):\n     :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n     \"\"\"\n \n-    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth)\n+    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth, timeout=timeout)\n \n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#77f4b8a75e804b83cca7c917a16bec93fdd6b302", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 43 | Lines Deleted: 13 | Files Changed: 2 | Hunks: 22 | Methods Changed: 14 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 56 | Churn Cumulative: 1992 | Contributors (this commit): 6 | Commits (past 90d): 97 | Contributors (cumulative): 8 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,6 +1,31 @@\n # -*- coding: utf-8 -*-\n \n+import inspect\n+\n import packages\n from core import *\n \n from core import __version__\n+\n+timeout = None\n+\n+class settings:\n+    \"\"\"Context manager for settings.\"\"\"\n+    \n+    cache = {}\n+    \n+    def __init__(self, timeout):\n+        self.module = inspect.getmodule(self)\n+        \n+        # Cache settings\n+        self.cache['timeout'] = self.module.timeout\n+        \n+        self.module.timeout = timeout\n+        \n+    def __enter__(self):\n+        pass\n+        \n+    def __exit__(self, type, value, traceback):\n+        # Restore settings \n+        for key in self.cache:\n+            setattr(self.module, key, self.cache[key])\n\n@@ -12,6 +12,7 @@\n \n from __future__ import absolute_import\n \n+import requests\n import urllib\n import urllib2\n import socket\n@@ -24,7 +25,6 @@ from .packages.poster.encode import multipart_encode\n from .packages.poster.streaminghttp import register_openers, get_handlers\n \n \n-\n __title__ = 'requests'\n __version__ = '0.3.2'\n __build__ = 0x000302\n@@ -39,7 +39,6 @@ __all__ = [\n ]\n \n \n-\n class _Request(urllib2.Request):\n     \"\"\"Hidden wrapper around the urllib2.Request object. Allows for manual\n     setting of HTTP methods.\n@@ -446,19 +445,20 @@ def request(method, url, **kwargs):\n     :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n     :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n     :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n+    :param timeout: (optional) Float describing the timeout of the request.\n     \"\"\"\n     data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())\n     \n     r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),\n                 cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),\n                 auth=kwargs.pop('auth', auth_manager.get_auth(url)),\n-                timeout=kwargs.pop('timeout', None))\n+                timeout=kwargs.pop('timeout', requests.timeout))\n     r.send()\n \n     return r.response\n \n \n-def get(url, params={}, headers={}, cookies=None, auth=None, timeout=None):\n+def get(url, params={}, headers={}, cookies=None, auth=None, **kwargs):\n     \"\"\"Sends a GET request. Returns :class:`Response` object.\n \n     :param url: URL for the new :class:`Request` object.\n@@ -466,12 +466,13 @@ def get(url, params={}, headers={}, cookies=None, auth=None, timeout=None):\n     :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n     :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n     :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n+    :param timeout: (optional) Float describing the timeout of the request.\n     \"\"\"\n \n-    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth, timeout=timeout)\n+    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)\n \n \n-def head(url, params={}, headers={}, cookies=None, auth=None, timeout=None):\n+def head(url, params={}, headers={}, cookies=None, auth=None, **kwargs):\n     \"\"\"Sends a HEAD request. Returns :class:`Response` object.\n \n     :param url: URL for the new :class:`Request` object.\n@@ -479,12 +480,13 @@ def head(url, params={}, headers={}, cookies=None, auth=None, timeout=None):\n     :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.\n     :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n     :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n+    :param timeout: (optional) Float describing the timeout of the request.\n     \"\"\"\n \n-    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth, timeout=timeout)\n+    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)\n \n \n-def post(url, data={}, headers={}, files=None, cookies=None, auth=None, timeout=None):\n+def post(url, data={}, headers={}, files=None, cookies=None, auth=None, **kwargs):\n     \"\"\"Sends a POST request. Returns :class:`Response` object.\n \n     :param url: URL for the new :class:`Request` object.\n@@ -493,12 +495,13 @@ def post(url, data={}, headers={}, files=None, cookies=None, auth=None, timeout=\n     :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n     :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n     :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n+    :param timeout: (optional) Float describing the timeout of the request.\n     \"\"\"\n \n-    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, timeout=timeout)\n+    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)\n \n \n-def put(url, data='', headers={}, files={}, cookies=None, auth=None, timeout=None):\n+def put(url, data='', headers={}, files={}, cookies=None, auth=None, **kwargs):\n     \"\"\"Sends a PUT request. Returns :class:`Response` object.\n \n     :param url: URL for the new :class:`Request` object.\n@@ -507,12 +510,13 @@ def put(url, data='', headers={}, files={}, cookies=None, auth=None, timeout=Non\n     :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n     :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n     :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n+    :param timeout: (optional) Float describing the timeout of the request.\n     \"\"\"\n \n-    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, timeout=timeout)\n+    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)\n \n \n-def delete(url, params={}, headers={}, cookies=None, auth=None, timeout=None):\n+def delete(url, params={}, headers={}, cookies=None, auth=None, **kwargs):\n     \"\"\"Sends a DELETE request. Returns :class:`Response` object.\n \n     :param url: URL for the new :class:`Request` object.\n@@ -520,9 +524,10 @@ def delete(url, params={}, headers={}, cookies=None, auth=None, timeout=None):\n     :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.\n     :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n     :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n+    :param timeout: (optional) Float describing the timeout of the request.\n     \"\"\"\n \n-    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth, timeout=timeout)\n+    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)\n \n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#64d6c3074f2e1bd5ae5f5d786f83d592a5a56ead", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 238 | Contributors (this commit): 1 | Commits (past 90d): 3 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -25,7 +25,7 @@ import sys, os\n \n # Add any Sphinx extension module names here, as strings. They can be extensions\n # coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\n-extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.pngmath', 'sphinx.ext.jsmath', 'sphinx.ext.viewcode']\n+extensions = ['sphinx.ext.autodoc']\n \n # Add any paths that contain templates here, relative to this directory.\n templates_path = ['_templates']\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#8a4a05aac071095ff26d5cf3b4949cbcd01b3cef", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 6 | Churn Cumulative: 281 | Contributors (this commit): 3 | Commits (past 90d): 21 | Contributors (cumulative): 3 | DMM Complexity: 1.0\n\nDIFF:\n@@ -139,5 +139,11 @@ class RequestsTestSuite(unittest.TestCase):\n         r = requests.get('https://convore.com/api/account/verify.json')\n         self.assertEquals(r.status_code, 200)\n \n+    def test_unicode_get(self):\n+        requests.get('http://google.com', params={'foo': u'føø'})\n+        requests.get('http://google.com', params={'foo': u'foo'})\n+        requests.get('http://google.com/ø', params={'foo': u'foo'})\n+\n+\n if __name__ == '__main__':\n     unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b6f6048cff7189afee6a4fb89f9f0cdca0095b66", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 10 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 18 | Churn Cumulative: 1955 | Contributors (this commit): 6 | Commits (past 90d): 89 | Contributors (cumulative): 6 | DMM Complexity: None\n\nDIFF:\n@@ -74,11 +74,14 @@ class Request(object):\n \n         socket.setdefaulttimeout(timeout)\n \n+        for (k, v) in self.data.iteritems():\n+            self.data[k] = v.encode('utf-8')\n+\n         # url encode data if it's a dict\n         if hasattr(data, 'items'):\n-            self._enc_data = urllib.urlencode(data)\n+            self._enc_data = urllib.urlencode(self.data)\n         else:\n-            self._enc_data = data\n+            self._enc_data = self.data\n \n         self.response = Response()\n \n@@ -158,8 +161,9 @@ class Request(object):\n \n         self.response.url = getattr(resp, 'url', None)\n \n+\n     @staticmethod\n-    def _build_url(url, data):\n+    def _build_url(url, data=None):\n         \"\"\"Build URLs.\"\"\"\n \n         if urlparse(url).query:\n@@ -170,6 +174,7 @@ class Request(object):\n             else:\n                 return url\n \n+\n     def send(self, anyway=False):\n         \"\"\"Sends the request. Returns True of successful, false if not.\n         If there was an HTTPError during transmission,\n@@ -203,6 +208,9 @@ class Request(object):\n             req.headers.update(self.headers)\n \n         if not self.sent or anyway:\n+\n+\n+\n             try:\n                 opener = self._get_opener()\n                 resp = opener(req)\n@@ -229,6 +237,8 @@ class Request(object):\n     def read(self, *args):\n         return self.response.read()\n \n+\n+\n class Response(object):\n     \"\"\"The :class:`Request` object. All :class:`Request` objects contain a\n     :class:`Request.response <response>` attribute, which is an instance of\n@@ -263,6 +273,7 @@ class Response(object):\n         return self.content\n \n \n+\n class AuthManager(object):\n     \"\"\"Authentication Manager.\"\"\"\n \n@@ -299,6 +310,7 @@ class AuthManager(object):\n \n         self._auth[uri] = auth\n \n+\n     def add_password(self, realm, uri, user, passwd):\n         \"\"\"Adds password to AuthManager.\"\"\"\n         # uri could be a single URI or a sequence\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#01b22a7e127d1b9c90d02a7101267b12ef1ed2ec", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 2199 | Contributors (this commit): 6 | Commits (past 90d): 94 | Contributors (cumulative): 7 | DMM Complexity: None\n\nDIFF:\n@@ -48,7 +48,7 @@ copyright = u'2011, Kenneth Reitz'\n # built documents.\n #\n # The short X.Y version.\n-version = '0.3.2'\n+version = '0.3.3'\n # The full version, including alpha/beta/rc tags.\n release = version\n \n\n@@ -26,8 +26,8 @@ from .packages.poster.streaminghttp import register_openers, get_handlers\n \n \n __title__ = 'requests'\n-__version__ = '0.3.2'\n-__build__ = 0x000302\n+__version__ = '0.3.3'\n+__build__ = 0x000303\n __author__ = 'Kenneth Reitz'\n __license__ = 'ISC'\n __copyright__ = 'Copyright 2011 Kenneth Reitz'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#23ee58d6ec47a06358008cb7a4ab4f9556edc285", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 13 | Churn Cumulative: 2253 | Contributors (this commit): 6 | Commits (past 90d): 113 | Contributors (cumulative): 10 | DMM Complexity: 1.0\n\nDIFF:\n@@ -70,13 +70,16 @@ class Request(object):\n         self.headers = headers\n         self.files = files\n         self.method = method\n-        self.data = data\n+        \n+        self.data = {}\n+        for (k, v) in data.items():\n+            self.data.update({\n+                k.encode('utf-8') if k.__class__ is unicode else k: \\\n+                v.encode('utf-8') if v.__class__ is unicode else v\n+            })\n \n         socket.setdefaulttimeout(timeout)\n \n-        for (k, v) in self.data.iteritems():\n-            self.data[k] = v.encode('utf-8')\n-\n         # url encode data if it's a dict\n         if hasattr(data, 'items'):\n             self._enc_data = urllib.urlencode(self.data)\n\n@@ -141,6 +141,8 @@ class RequestsTestSuite(unittest.TestCase):\n \n     def test_unicode_get(self):\n         requests.get('http://google.com', params={'foo': u'føø'})\n+        requests.get('http://google.com', params={u'føø': u'føø'})\n+        requests.get('http://google.com', params={'føø': 'føø'})\n         requests.get('http://google.com', params={'foo': u'foo'})\n         requests.get('http://google.com/ø', params={'foo': u'foo'})\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#912f48eececb6355b3511416d4d5361aedbd5d08", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 1974 | Contributors (this commit): 6 | Commits (past 90d): 92 | Contributors (cumulative): 6 | DMM Complexity: None\n\nDIFF:\n@@ -73,8 +73,8 @@ class Request(object):\n         self.data = {}\n         for (k, v) in data.items():\n             self.data.update({\n-                k.encode('utf-8') if k.__class__ is unicode else k: \\\n-                v.encode('utf-8') if v.__class__ is unicode else v\n+                k.encode('utf-8') if isinstance(k, unicode) else k:\n+                v.encode('utf-8') if isinstance(v, unicode) else v\n             })\n \n         socket.setdefaulttimeout(timeout)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#1971bdbe6726af224d92723b3f5f12f26aa4277f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 5 | Files Changed: 2 | Hunks: 5 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 12 | Churn Cumulative: 2269 | Contributors (this commit): 7 | Commits (past 90d): 116 | Contributors (cumulative): 12 | DMM Complexity: 1.0\n\nDIFF:\n@@ -69,18 +69,17 @@ class Request(object):\n         self.headers = headers\n         self.files = files\n         self.method = method\n-\n         self.data = {}\n+\n+        socket.setdefaulttimeout(timeout)\n+\n+        if hasattr(data, 'items'):\n             for (k, v) in data.items():\n                 self.data.update({\n                     k.encode('utf-8') if isinstance(k, unicode) else k:\n                     v.encode('utf-8') if isinstance(v, unicode) else v\n                 })\n-\n-        socket.setdefaulttimeout(timeout)\n-\n             # url encode data if it's a dict\n-        if hasattr(data, 'items'):\n             self._enc_data = urllib.urlencode(self.data)\n         else:\n             self._enc_data = self.data\n\n@@ -79,6 +79,9 @@ class RequestsTestSuite(unittest.TestCase):\n         post2 = requests.post(bin.url, files={'some': open('test_requests.py')})\n         self.assertEqual(post2.status_code, 201)\n \n+        post3 = requests.post(bin.url, data='[{\"some\": \"json\"}]')\n+        self.assertEqual(post.status_code, 201)\n+\n     def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):\n         bin = requests.post('http://www.postbin.org/')\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b1e28c7fd8a9fe15d16a9636950559869b46ea96", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 5 | Files Changed: 1 | Hunks: 6 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 12 | Churn Cumulative: 1995 | Contributors (this commit): 7 | Commits (past 90d): 94 | Contributors (cumulative): 7 | DMM Complexity: None\n\nDIFF:\n@@ -65,24 +65,28 @@ class Request(object):\n     def __init__(self, url=None, headers=dict(), files=None, method=None,\n                  data=dict(), auth=None, cookiejar=None, timeout=None):\n \n+        socket.setdefaulttimeout(timeout)\n+\n         self.url = url\n         self.headers = headers\n         self.files = files\n         self.method = method\n         self.data = {}\n \n-        socket.setdefaulttimeout(timeout)\n-\n+        # self.data = {}\n         if hasattr(data, 'items'):\n             for (k, v) in data.items():\n                 self.data.update({\n                     k.encode('utf-8') if isinstance(k, unicode) else k:\n                     v.encode('utf-8') if isinstance(v, unicode) else v\n                 })\n+\n         # url encode data if it's a dict\n+        if hasattr(data, 'items'):\n             self._enc_data = urllib.urlencode(self.data)\n         else:\n-            self._enc_data = self.data\n+            self._enc_data = data\n+\n \n         self.response = Response()\n \n@@ -210,8 +214,6 @@ class Request(object):\n \n         if not self.sent or anyway:\n \n-\n-\n             try:\n                 opener = self._get_opener()\n                 resp = opener(req)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#1421ffa32ab4709c9a7634493803bd55a3c6615f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 37 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 6 | Methods Changed: 5 | Complexity Δ (Sum/Max): 7/6 | Churn Δ: 38 | Churn Cumulative: 2319 | Contributors (this commit): 7 | Commits (past 90d): 119 | Contributors (cumulative): 12 | DMM Complexity: 1.0\n\nDIFF:\n@@ -55,6 +55,28 @@ class _Request(urllib2.Request):\n         return urllib2.Request.get_method(self)\n \n \n+class _HTTPBasicAuthHandler(urllib2.HTTPBasicAuthHandler):\n+    # from mercurial\n+\n+    def __init__(self, *args, **kwargs):\n+        urllib2.HTTPBasicAuthHandler.__init__(self, *args, **kwargs)\n+        self.retried_req = None\n+\n+    def reset_retry_count(self):\n+        # Python 2.6.5 will call this on 401 or 407 errors and thus loop\n+        # forever. We disable reset_retry_count completely and reset in\n+        # http_error_auth_reqed instead.\n+        pass\n+\n+    def http_error_auth_reqed(self, auth_header, host, req, headers):\n+        # Reset the retry counter once for each request.\n+        if req is not self.retried_req:\n+            self.retried_req = req\n+            self.retried = 0\n+        return urllib2.HTTPBasicAuthHandler.http_error_auth_reqed(\n+                        self, auth_header, host, req, headers)\n+\n+\n class Request(object):\n     \"\"\"The :class:`Request` object. It carries out all functionality of\n     Requests. Recommended interface is with the Requests functions.\n@@ -153,10 +175,17 @@ class Request(object):\n \n     def _build_response(self, resp):\n         \"\"\"Build internal Response object from given response.\"\"\"\n+        if isinstance(resp, HTTPError):\n+            # print resp.__dict__\n+            pass\n \n         self.response.status_code = getattr(resp, 'code', None)\n+\n+        try:\n             self.response.headers = getattr(resp.info(), 'dict', None)\n             self.response.content = resp.read()\n+        except AttributeError, why:\n+            pass\n \n         if self.response.headers.get('content-encoding', None) == 'gzip':\n             try:\n@@ -431,7 +460,7 @@ class AuthObject(object):\n     \"\"\"\n \n     _handlers = {\n-        'basic': urllib2.HTTPBasicAuthHandler,\n+        'basic': _HTTPBasicAuthHandler,\n         'digest': urllib2.HTTPDigestAuthHandler,\n         'proxy_basic': urllib2.ProxyBasicAuthHandler,\n         'proxy_digest': urllib2.ProxyDigestAuthHandler\n\n@@ -149,6 +149,13 @@ class RequestsTestSuite(unittest.TestCase):\n         requests.get('http://google.com', params={'foo': u'foo'})\n         requests.get('http://google.com/ø', params={'foo': u'foo'})\n \n+    def test_httpauth_recursion(self):\n+        conv_auth = ('requeststest', 'bad_password')\n+\n+        r = requests.get('https://convore.com/api/account/verify.json', auth=conv_auth)\n+        self.assertEquals(r.status_code, 401)\n+        print r.__dict__\n+\n \n if __name__ == '__main__':\n     unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#14ef4622634ae8746bce600523cbed15a119d15a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 644 | Lines Deleted: 571 | Files Changed: 6 | Hunks: 10 | Methods Changed: 70 | Complexity Δ (Sum/Max): 6/83 | Churn Δ: 1215 | Churn Cumulative: 3534 | Contributors (this commit): 7 | Commits (past 90d): 125 | Contributors (cumulative): 16 | DMM Complexity: 1.0\n\nDIFF:\n@@ -0,0 +1,115 @@\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+requests.api\n+~~~~~~~~~~~~\n+\n+This module impliments the Requests API.\n+\n+:copyright: (c) 2011 by Kenneth Reitz.\n+:license: ISC, see LICENSE for more details.\n+\n+\"\"\"\n+\n+import requests\n+from .models import Request, Response, AuthManager, AuthObject, auth_manager\n+\n+\n+__all__ = ('request', 'get', 'head', 'post', 'put', 'delete')\n+\n+\n+\n+def request(method, url, **kwargs):\n+    \"\"\"Sends a `method` request. Returns :class:`Response` object.\n+\n+    :param method: method for the new :class:`Request` object.\n+    :param url: URL for the new :class:`Request` object.\n+    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.\n+    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.\n+    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n+    :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n+    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n+    :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n+    :param timeout: (optional) Float describing the timeout of the request.\n+    \"\"\"\n+    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())\n+\n+    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),\n+                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),\n+                auth=kwargs.pop('auth', auth_manager.get_auth(url)),\n+                timeout=kwargs.pop('timeout', requests.timeout))\n+    r.send()\n+\n+    return r.response\n+\n+\n+def get(url, params={}, headers={}, cookies=None, auth=None, **kwargs):\n+    \"\"\"Sends a GET request. Returns :class:`Response` object.\n+\n+    :param url: URL for the new :class:`Request` object.\n+    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.\n+    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n+    :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n+    :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n+    :param timeout: (optional) Float describing the timeout of the request.\n+    \"\"\"\n+\n+    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)\n+\n+\n+def head(url, params={}, headers={}, cookies=None, auth=None, **kwargs):\n+    \"\"\"Sends a HEAD request. Returns :class:`Response` object.\n+\n+    :param url: URL for the new :class:`Request` object.\n+    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.\n+    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.\n+    :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n+    :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n+    :param timeout: (optional) Float describing the timeout of the request.\n+    \"\"\"\n+\n+    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)\n+\n+\n+def post(url, data={}, headers={}, files=None, cookies=None, auth=None, **kwargs):\n+    \"\"\"Sends a POST request. Returns :class:`Response` object.\n+\n+    :param url: URL for the new :class:`Request` object.\n+    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.\n+    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.\n+    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n+    :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n+    :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n+    :param timeout: (optional) Float describing the timeout of the request.\n+    \"\"\"\n+\n+    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)\n+\n+\n+def put(url, data='', headers={}, files={}, cookies=None, auth=None, **kwargs):\n+    \"\"\"Sends a PUT request. Returns :class:`Response` object.\n+\n+    :param url: URL for the new :class:`Request` object.\n+    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.\n+    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.\n+    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n+    :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n+    :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n+    :param timeout: (optional) Float describing the timeout of the request.\n+    \"\"\"\n+\n+    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)\n+\n+\n+def delete(url, params={}, headers={}, cookies=None, auth=None, **kwargs):\n+    \"\"\"Sends a DELETE request. Returns :class:`Response` object.\n+\n+    :param url: URL for the new :class:`Request` object.\n+    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.\n+    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.\n+    :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n+    :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n+    :param timeout: (optional) Float describing the timeout of the request.\n+    \"\"\"\n+\n+    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)\n\n@@ -8,23 +8,9 @@\n \n :copyright: (c) 2011 by Kenneth Reitz.\n :license: ISC, see LICENSE for more details.\n+\n \"\"\"\n \n-from __future__ import absolute_import\n-\n-import requests\n-import urllib\n-import urllib2\n-import socket\n-import zlib\n-\n-from urllib2 import HTTPError\n-from urlparse import urlparse\n-\n-from .packages.poster.encode import multipart_encode\n-from .packages.poster.streaminghttp import register_openers, get_handlers\n-\n-\n __title__ = 'requests'\n __version__ = '0.3.3'\n __build__ = 0x000303\n@@ -32,559 +18,6 @@ __author__ = 'Kenneth Reitz'\n __license__ = 'ISC'\n __copyright__ = 'Copyright 2011 Kenneth Reitz'\n \n-__all__ = [\n-    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete',\n-    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError',\n-    'URLRequired', 'InvalidMethod', 'HTTPError'\n-]\n \n-\n-class _Request(urllib2.Request):\n-    \"\"\"Hidden wrapper around the urllib2.Request object. Allows for manual\n-    setting of HTTP methods.\n-    \"\"\"\n-\n-    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):\n-        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)\n-        self.method = method\n-\n-    def get_method(self):\n-        if self.method:\n-            return self.method\n-\n-        return urllib2.Request.get_method(self)\n-\n-\n-class _HTTPBasicAuthHandler(urllib2.HTTPBasicAuthHandler):\n-    # from mercurial\n-\n-    def __init__(self, *args, **kwargs):\n-        urllib2.HTTPBasicAuthHandler.__init__(self, *args, **kwargs)\n-        self.retried_req = None\n-\n-    def reset_retry_count(self):\n-        # Python 2.6.5 will call this on 401 or 407 errors and thus loop\n-        # forever. We disable reset_retry_count completely and reset in\n-        # http_error_auth_reqed instead.\n-        pass\n-\n-    def http_error_auth_reqed(self, auth_header, host, req, headers):\n-        # Reset the retry counter once for each request.\n-        if req is not self.retried_req:\n-            self.retried_req = req\n-            self.retried = 0\n-        return urllib2.HTTPBasicAuthHandler.http_error_auth_reqed(\n-                        self, auth_header, host, req, headers)\n-\n-\n-class Request(object):\n-    \"\"\"The :class:`Request` object. It carries out all functionality of\n-    Requests. Recommended interface is with the Requests functions.\n-    \"\"\"\n-\n-    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')\n-\n-    def __init__(self, url=None, headers=dict(), files=None, method=None,\n-                 data=dict(), auth=None, cookiejar=None, timeout=None):\n-\n-        socket.setdefaulttimeout(timeout)\n-\n-        self.url = url\n-        self.headers = headers\n-        self.files = files\n-        self.method = method\n-        self.data = {}\n-\n-        # self.data = {}\n-        if hasattr(data, 'items'):\n-            for (k, v) in data.items():\n-                self.data.update({\n-                    k.encode('utf-8') if isinstance(k, unicode) else k:\n-                    v.encode('utf-8') if isinstance(v, unicode) else v\n-                })\n-\n-        # url encode data if it's a dict\n-        if hasattr(data, 'items'):\n-            self._enc_data = urllib.urlencode(self.data)\n-        else:\n-            self._enc_data = data\n-\n-\n-        self.response = Response()\n-\n-        if isinstance(auth, (list, tuple)):\n-            auth = AuthObject(*auth)\n-        if not auth:\n-            auth = auth_manager.get_auth(self.url)\n-        self.auth = auth\n-        self.cookiejar = cookiejar\n-        self.sent = False\n-\n-\n-    def __repr__(self):\n-        return '<Request [%s]>' % (self.method)\n-\n-\n-    def __setattr__(self, name, value):\n-        if (name == 'method') and (value):\n-            if not value in self._METHODS:\n-                raise InvalidMethod()\n-\n-        object.__setattr__(self, name, value)\n-\n-\n-    def _checks(self):\n-        \"\"\"Deterministic checks for consistency.\"\"\"\n-\n-        if not self.url:\n-            raise URLRequired\n-\n-\n-    def _get_opener(self):\n-        \"\"\"Creates appropriate opener object for urllib2.\"\"\"\n-\n-        _handlers = []\n-\n-        if self.cookiejar is not None:\n-            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))\n-\n-        if self.auth:\n-            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):\n-                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)\n-                self.auth.handler = self.auth.handler(auth_manager)\n-                auth_manager.add_auth(self.url, self.auth)\n-\n-            _handlers.append(self.auth.handler)\n-\n-        if not _handlers:\n-            return urllib2.urlopen\n-\n-        _handlers.extend(get_handlers())\n-        opener = urllib2.build_opener(*_handlers)\n-\n-        if self.headers:\n-            # Allow default headers in the opener to be overloaded\n-            normal_keys = [k.capitalize() for k in self.headers]\n-            for key, val in opener.addheaders[:]:\n-                if key not in normal_keys:\n-                    continue\n-                # Remove it, we have a value to take its place\n-                opener.addheaders.remove((key, val))\n-\n-        return opener.open\n-\n-    def _build_response(self, resp):\n-        \"\"\"Build internal Response object from given response.\"\"\"\n-        if isinstance(resp, HTTPError):\n-            # print resp.__dict__\n-            pass\n-\n-        self.response.status_code = getattr(resp, 'code', None)\n-\n-        try:\n-            self.response.headers = getattr(resp.info(), 'dict', None)\n-            self.response.content = resp.read()\n-        except AttributeError, why:\n-            pass\n-\n-        if self.response.headers.get('content-encoding', None) == 'gzip':\n-            try:\n-                self.response.content = zlib.decompress(self.response.content, 16+zlib.MAX_WBITS)\n-            except zlib.error:\n-                pass\n-\n-        self.response.url = getattr(resp, 'url', None)\n-\n-\n-    @staticmethod\n-    def _build_url(url, data=None):\n-        \"\"\"Build URLs.\"\"\"\n-\n-        if urlparse(url).query:\n-            return '%s&%s' % (url, data)\n-        else:\n-            if data:\n-                return '%s?%s' % (url, data)\n-            else:\n-                return url\n-\n-\n-    def send(self, anyway=False):\n-        \"\"\"Sends the request. Returns True of successful, false if not.\n-        If there was an HTTPError during transmission,\n-        self.response.status_code will contain the HTTPError code.\n-\n-        Once a request is successfully sent, `sent` will equal True.\n-\n-        :param anyway: If True, request will be sent, even if it has\n-        already been sent.\n-        \"\"\"\n-        self._checks()\n-        success = False\n-\n-        if self.method in ('GET', 'HEAD', 'DELETE'):\n-            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)\n-        else:\n-\n-            if self.files:\n-                register_openers()\n-\n-                if self.data:\n-                    self.files.update(self.data)\n-\n-                datagen, headers = multipart_encode(self.files)\n-                req = _Request(self.url, data=datagen, headers=headers, method=self.method)\n-\n-            else:\n-                req = _Request(self.url, data=self._enc_data, method=self.method)\n-\n-        if self.headers:\n-            req.headers.update(self.headers)\n-\n-        if not self.sent or anyway:\n-\n-            try:\n-                opener = self._get_opener()\n-                resp = opener(req)\n-\n-                if self.cookiejar is not None:\n-                    self.cookiejar.extract_cookies(resp, req)\n-\n-            except urllib2.HTTPError, why:\n-                self._build_response(why)\n-                self.response.error = why\n-            else:\n-                self._build_response(resp)\n-                self.response.ok = True\n-\n-            self.response.cached = False\n-        else:\n-            self.response.cached = True\n-\n-        self.sent = self.response.ok\n-\n-        return self.sent\n-\n-\n-    def read(self, *args):\n-        return self.response.read()\n-\n-\n-\n-class Response(object):\n-    \"\"\"The :class:`Request` object. All :class:`Request` objects contain a\n-    :class:`Request.response <response>` attribute, which is an instance of\n-    this class.\n-    \"\"\"\n-\n-    def __init__(self):\n-        self.content = None\n-        self.status_code = None\n-        self.headers = dict()\n-        self.url = None\n-        self.ok = False\n-        self.error = None\n-        self.cached = False\n-\n-\n-    def __repr__(self):\n-        return '<Response [%s]>' % (self.status_code)\n-\n-\n-    def __nonzero__(self):\n-        \"\"\"Returns true if status_code is 'OK'.\"\"\"\n-        return not self.error\n-\n-\n-    def raise_for_status(self):\n-        \"\"\"Raises stored HTTPError if one exists.\"\"\"\n-        if self.error:\n-            raise self.error\n-\n-    def read(self, *args):\n-        return self.content\n-\n-\n-\n-class AuthManager(object):\n-    \"\"\"Authentication Manager.\"\"\"\n-\n-    def __new__(cls):\n-        singleton = cls.__dict__.get('__singleton__')\n-        if singleton is not None:\n-            return singleton\n-\n-        cls.__singleton__ = singleton = object.__new__(cls)\n-\n-        return singleton\n-\n-\n-    def __init__(self):\n-        self.passwd = {}\n-        self._auth = {}\n-\n-\n-    def __repr__(self):\n-        return '<AuthManager [%s]>' % (self.method)\n-\n-\n-    def add_auth(self, uri, auth):\n-        \"\"\"Registers AuthObject to AuthManager.\"\"\"\n-\n-        uri = self.reduce_uri(uri, False)\n-\n-        # try to make it an AuthObject\n-        if not isinstance(auth, AuthObject):\n-            try:\n-                auth = AuthObject(*auth)\n-            except TypeError:\n-                pass\n-\n-        self._auth[uri] = auth\n-\n-\n-    def add_password(self, realm, uri, user, passwd):\n-        \"\"\"Adds password to AuthManager.\"\"\"\n-        # uri could be a single URI or a sequence\n-        if isinstance(uri, basestring):\n-            uri = [uri]\n-\n-        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])\n-\n-        if reduced_uri not in self.passwd:\n-            self.passwd[reduced_uri] = {}\n-        self.passwd[reduced_uri] = (user, passwd)\n-\n-\n-    def find_user_password(self, realm, authuri):\n-        for uris, authinfo in self.passwd.iteritems():\n-            reduced_authuri = self.reduce_uri(authuri, False)\n-            for uri in uris:\n-                if self.is_suburi(uri, reduced_authuri):\n-                    return authinfo\n-\n-        return (None, None)\n-\n-\n-    def get_auth(self, uri):\n-        (in_domain, in_path) = self.reduce_uri(uri, False)\n-\n-        for domain, path, authority in (\n-            (i[0][0], i[0][1], i[1]) for i in self._auth.iteritems()\n-        ):\n-            if in_domain == domain:\n-                if path in in_path:\n-                    return authority\n-\n-\n-    def reduce_uri(self, uri, default_port=True):\n-        \"\"\"Accept authority or URI and extract only the authority and path.\"\"\"\n-        # note HTTP URLs do not have a userinfo component\n-        parts = urllib2.urlparse.urlsplit(uri)\n-        if parts[1]:\n-            # URI\n-            scheme = parts[0]\n-            authority = parts[1]\n-            path = parts[2] or '/'\n-        else:\n-            # host or host:port\n-            scheme = None\n-            authority = uri\n-            path = '/'\n-        host, port = urllib2.splitport(authority)\n-        if default_port and port is None and scheme is not None:\n-            dport = {\"http\": 80,\n-                     \"https\": 443,\n-                     }.get(scheme)\n-            if dport is not None:\n-                authority = \"%s:%d\" % (host, dport)\n-\n-        return authority, path\n-\n-\n-    def is_suburi(self, base, test):\n-        \"\"\"Check if test is below base in a URI tree\n-\n-        Both args must be URIs in reduced form.\n-        \"\"\"\n-        if base == test:\n-            return True\n-        if base[0] != test[0]:\n-            return False\n-        common = urllib2.posixpath.commonprefix((base[1], test[1]))\n-        if len(common) == len(base[1]):\n-            return True\n-        return False\n-\n-\n-    def empty(self):\n-        self.passwd = {}\n-\n-\n-    def remove(self, uri, realm=None):\n-        # uri could be a single URI or a sequence\n-        if isinstance(uri, basestring):\n-            uri = [uri]\n-\n-        for default_port in True, False:\n-            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])\n-            del self.passwd[reduced_uri][realm]\n-\n-\n-    def __contains__(self, uri):\n-        # uri could be a single URI or a sequence\n-        if isinstance(uri, basestring):\n-            uri = [uri]\n-\n-        uri = tuple([self.reduce_uri(u, False) for u in uri])\n-\n-        if uri in self.passwd:\n-            return True\n-\n-        return False\n-\n-auth_manager = AuthManager()\n-\n-\n-\n-class AuthObject(object):\n-    \"\"\"The :class:`AuthObject` is a simple HTTP Authentication token. When\n-    given to a Requests function, it enables Basic HTTP Authentication for that\n-    Request. You can also enable Authorization for domain realms with AutoAuth.\n-    See AutoAuth for more details.\n-\n-    :param username: Username to authenticate with.\n-    :param password: Password for given username.\n-    :param realm: (optional) the realm this auth applies to\n-    :param handler: (optional) basic || digest || proxy_basic || proxy_digest\n-    \"\"\"\n-\n-    _handlers = {\n-        'basic': _HTTPBasicAuthHandler,\n-        'digest': urllib2.HTTPDigestAuthHandler,\n-        'proxy_basic': urllib2.ProxyBasicAuthHandler,\n-        'proxy_digest': urllib2.ProxyDigestAuthHandler\n-    }\n-\n-    def __init__(self, username, password, handler='basic', realm=None):\n-        self.username = username\n-        self.password = password\n-        self.realm = realm\n-\n-        if isinstance(handler, basestring):\n-            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)\n-        else:\n-            self.handler = handler\n-\n-\n-\n-\n-def request(method, url, **kwargs):\n-    \"\"\"Sends a `method` request. Returns :class:`Response` object.\n-\n-    :param method: method for the new :class:`Request` object.\n-    :param url: URL for the new :class:`Request` object.\n-    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.\n-    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.\n-    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n-    :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n-    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n-    :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n-    :param timeout: (optional) Float describing the timeout of the request.\n-    \"\"\"\n-    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())\n-\n-    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),\n-                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),\n-                auth=kwargs.pop('auth', auth_manager.get_auth(url)),\n-                timeout=kwargs.pop('timeout', requests.timeout))\n-    r.send()\n-\n-    return r.response\n-\n-\n-def get(url, params={}, headers={}, cookies=None, auth=None, **kwargs):\n-    \"\"\"Sends a GET request. Returns :class:`Response` object.\n-\n-    :param url: URL for the new :class:`Request` object.\n-    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.\n-    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n-    :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n-    :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n-    :param timeout: (optional) Float describing the timeout of the request.\n-    \"\"\"\n-\n-    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)\n-\n-\n-def head(url, params={}, headers={}, cookies=None, auth=None, **kwargs):\n-    \"\"\"Sends a HEAD request. Returns :class:`Response` object.\n-\n-    :param url: URL for the new :class:`Request` object.\n-    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.\n-    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.\n-    :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n-    :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n-    :param timeout: (optional) Float describing the timeout of the request.\n-    \"\"\"\n-\n-    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)\n-\n-\n-def post(url, data={}, headers={}, files=None, cookies=None, auth=None, **kwargs):\n-    \"\"\"Sends a POST request. Returns :class:`Response` object.\n-\n-    :param url: URL for the new :class:`Request` object.\n-    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.\n-    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.\n-    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n-    :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n-    :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n-    :param timeout: (optional) Float describing the timeout of the request.\n-    \"\"\"\n-\n-    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)\n-\n-\n-def put(url, data='', headers={}, files={}, cookies=None, auth=None, **kwargs):\n-    \"\"\"Sends a PUT request. Returns :class:`Response` object.\n-\n-    :param url: URL for the new :class:`Request` object.\n-    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.\n-    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.\n-    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n-    :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n-    :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n-    :param timeout: (optional) Float describing the timeout of the request.\n-    \"\"\"\n-\n-    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)\n-\n-\n-def delete(url, params={}, headers={}, cookies=None, auth=None, **kwargs):\n-    \"\"\"Sends a DELETE request. Returns :class:`Response` object.\n-\n-    :param url: URL for the new :class:`Request` object.\n-    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.\n-    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.\n-    :param cookies: (optional) CookieJar object to send with the :class:`Request`.\n-    :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n-    :param timeout: (optional) Float describing the timeout of the request.\n-    \"\"\"\n-\n-    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)\n-\n-\n-\n-class RequestException(Exception):\n-    \"\"\"There was an ambiguous exception that occured while handling your\n-    request.\"\"\"\n-\n-class AuthenticationError(RequestException):\n-    \"\"\"The authentication credentials provided were invalid.\"\"\"\n-\n-class URLRequired(RequestException):\n-    \"\"\"A valid URL is required to make a request.\"\"\"\n-\n-class InvalidMethod(RequestException):\n-    \"\"\"An inappropriate method was attempted.\"\"\"\n+from .models import HTTPError, auth_manager\n+from .api import *\n\n@@ -0,0 +1,435 @@\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+requests.system\n+~~~~~~~~~~~~~~~\n+\n+\"\"\"\n+\n+import requests\n+import urllib\n+import urllib2\n+import socket\n+import zlib\n+\n+from urllib2 import HTTPError\n+from urlparse import urlparse\n+\n+from .monkeys import _Request, _HTTPBasicAuthHandler, _HTTPDigestAuthHandler\n+\n+from .packages.poster.encode import multipart_encode\n+from .packages.poster.streaminghttp import register_openers, get_handlers\n+\n+\n+\n+class Request(object):\n+    \"\"\"The :class:`Request` object. It carries out all functionality of\n+    Requests. Recommended interface is with the Requests functions.\n+    \"\"\"\n+\n+    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')\n+\n+    def __init__(self, url=None, headers=dict(), files=None, method=None,\n+                 data=dict(), auth=None, cookiejar=None, timeout=None):\n+\n+        socket.setdefaulttimeout(timeout)\n+\n+        self.url = url\n+        self.headers = headers\n+        self.files = files\n+        self.method = method\n+        self.data = {}\n+\n+        # self.data = {}\n+        if hasattr(data, 'items'):\n+            for (k, v) in data.items():\n+                self.data.update({\n+                    k.encode('utf-8') if isinstance(k, unicode) else k:\n+                    v.encode('utf-8') if isinstance(v, unicode) else v\n+                })\n+\n+        # url encode data if it's a dict\n+        if hasattr(data, 'items'):\n+            self._enc_data = urllib.urlencode(self.data)\n+        else:\n+            self._enc_data = data\n+\n+\n+        self.response = Response()\n+\n+        if isinstance(auth, (list, tuple)):\n+            auth = AuthObject(*auth)\n+        if not auth:\n+            auth = auth_manager.get_auth(self.url)\n+        self.auth = auth\n+        self.cookiejar = cookiejar\n+        self.sent = False\n+\n+\n+    def __repr__(self):\n+        return '<Request [%s]>' % (self.method)\n+\n+\n+    def __setattr__(self, name, value):\n+        if (name == 'method') and (value):\n+            if not value in self._METHODS:\n+                raise InvalidMethod()\n+\n+        object.__setattr__(self, name, value)\n+\n+\n+    def _checks(self):\n+        \"\"\"Deterministic checks for consistency.\"\"\"\n+\n+        if not self.url:\n+            raise URLRequired\n+\n+\n+    def _get_opener(self):\n+        \"\"\"Creates appropriate opener object for urllib2.\"\"\"\n+\n+        _handlers = []\n+\n+        if self.cookiejar is not None:\n+            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))\n+\n+        if self.auth:\n+            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):\n+                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)\n+                self.auth.handler = self.auth.handler(auth_manager)\n+                auth_manager.add_auth(self.url, self.auth)\n+\n+            _handlers.append(self.auth.handler)\n+\n+        if not _handlers:\n+            return urllib2.urlopen\n+\n+        _handlers.extend(get_handlers())\n+        opener = urllib2.build_opener(*_handlers)\n+\n+        if self.headers:\n+            # Allow default headers in the opener to be overloaded\n+            normal_keys = [k.capitalize() for k in self.headers]\n+            for key, val in opener.addheaders[:]:\n+                if key not in normal_keys:\n+                    continue\n+                # Remove it, we have a value to take its place\n+                opener.addheaders.remove((key, val))\n+\n+        return opener.open\n+\n+    def _build_response(self, resp):\n+        \"\"\"Build internal Response object from given response.\"\"\"\n+        if isinstance(resp, HTTPError):\n+            # print resp.__dict__\n+            pass\n+\n+        self.response.status_code = getattr(resp, 'code', None)\n+\n+        try:\n+            self.response.headers = getattr(resp.info(), 'dict', None)\n+            self.response.content = resp.read()\n+        except AttributeError, why:\n+            pass\n+\n+        if self.response.headers.get('content-encoding', None) == 'gzip':\n+            try:\n+                self.response.content = zlib.decompress(self.response.content, 16+zlib.MAX_WBITS)\n+            except zlib.error:\n+                pass\n+\n+        self.response.url = getattr(resp, 'url', None)\n+\n+\n+    @staticmethod\n+    def _build_url(url, data=None):\n+        \"\"\"Build URLs.\"\"\"\n+\n+        if urlparse(url).query:\n+            return '%s&%s' % (url, data)\n+        else:\n+            if data:\n+                return '%s?%s' % (url, data)\n+            else:\n+                return url\n+\n+\n+    def send(self, anyway=False):\n+        \"\"\"Sends the request. Returns True of successful, false if not.\n+        If there was an HTTPError during transmission,\n+        self.response.status_code will contain the HTTPError code.\n+\n+        Once a request is successfully sent, `sent` will equal True.\n+\n+        :param anyway: If True, request will be sent, even if it has\n+        already been sent.\n+        \"\"\"\n+        self._checks()\n+        success = False\n+\n+        if self.method in ('GET', 'HEAD', 'DELETE'):\n+            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)\n+        else:\n+\n+            if self.files:\n+                register_openers()\n+\n+                if self.data:\n+                    self.files.update(self.data)\n+\n+                datagen, headers = multipart_encode(self.files)\n+                req = _Request(self.url, data=datagen, headers=headers, method=self.method)\n+\n+            else:\n+                req = _Request(self.url, data=self._enc_data, method=self.method)\n+\n+        if self.headers:\n+            req.headers.update(self.headers)\n+\n+        if not self.sent or anyway:\n+\n+            try:\n+                opener = self._get_opener()\n+                resp = opener(req)\n+\n+                if self.cookiejar is not None:\n+                    self.cookiejar.extract_cookies(resp, req)\n+\n+            except urllib2.HTTPError, why:\n+                self._build_response(why)\n+                self.response.error = why\n+            else:\n+                self._build_response(resp)\n+                self.response.ok = True\n+\n+            self.response.cached = False\n+        else:\n+            self.response.cached = True\n+\n+        self.sent = self.response.ok\n+\n+        return self.sent\n+\n+\n+    def read(self, *args):\n+        return self.response.read()\n+\n+\n+\n+class Response(object):\n+    \"\"\"The :class:`Request` object. All :class:`Request` objects contain a\n+    :class:`Request.response <response>` attribute, which is an instance of\n+    this class.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.content = None\n+        self.status_code = None\n+        self.headers = dict()\n+        self.url = None\n+        self.ok = False\n+        self.error = None\n+        self.cached = False\n+\n+\n+    def __repr__(self):\n+        return '<Response [%s]>' % (self.status_code)\n+\n+\n+    def __nonzero__(self):\n+        \"\"\"Returns true if status_code is 'OK'.\"\"\"\n+        return not self.error\n+\n+\n+    def raise_for_status(self):\n+        \"\"\"Raises stored HTTPError if one exists.\"\"\"\n+        if self.error:\n+            raise self.error\n+\n+    def read(self, *args):\n+        return self.content\n+\n+\n+\n+class AuthManager(object):\n+    \"\"\"Authentication Manager.\"\"\"\n+\n+    def __new__(cls):\n+        singleton = cls.__dict__.get('__singleton__')\n+        if singleton is not None:\n+            return singleton\n+\n+        cls.__singleton__ = singleton = object.__new__(cls)\n+\n+        return singleton\n+\n+\n+    def __init__(self):\n+        self.passwd = {}\n+        self._auth = {}\n+\n+\n+    def __repr__(self):\n+        return '<AuthManager [%s]>' % (self.method)\n+\n+\n+    def add_auth(self, uri, auth):\n+        \"\"\"Registers AuthObject to AuthManager.\"\"\"\n+\n+        uri = self.reduce_uri(uri, False)\n+\n+        # try to make it an AuthObject\n+        if not isinstance(auth, AuthObject):\n+            try:\n+                auth = AuthObject(*auth)\n+            except TypeError:\n+                pass\n+\n+        self._auth[uri] = auth\n+\n+\n+    def add_password(self, realm, uri, user, passwd):\n+        \"\"\"Adds password to AuthManager.\"\"\"\n+        # uri could be a single URI or a sequence\n+        if isinstance(uri, basestring):\n+            uri = [uri]\n+\n+        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])\n+\n+        if reduced_uri not in self.passwd:\n+            self.passwd[reduced_uri] = {}\n+        self.passwd[reduced_uri] = (user, passwd)\n+\n+\n+    def find_user_password(self, realm, authuri):\n+        for uris, authinfo in self.passwd.iteritems():\n+            reduced_authuri = self.reduce_uri(authuri, False)\n+            for uri in uris:\n+                if self.is_suburi(uri, reduced_authuri):\n+                    return authinfo\n+\n+        return (None, None)\n+\n+\n+    def get_auth(self, uri):\n+        (in_domain, in_path) = self.reduce_uri(uri, False)\n+\n+        for domain, path, authority in (\n+            (i[0][0], i[0][1], i[1]) for i in self._auth.iteritems()\n+        ):\n+            if in_domain == domain:\n+                if path in in_path:\n+                    return authority\n+\n+\n+    def reduce_uri(self, uri, default_port=True):\n+        \"\"\"Accept authority or URI and extract only the authority and path.\"\"\"\n+        # note HTTP URLs do not have a userinfo component\n+        parts = urllib2.urlparse.urlsplit(uri)\n+        if parts[1]:\n+            # URI\n+            scheme = parts[0]\n+            authority = parts[1]\n+            path = parts[2] or '/'\n+        else:\n+            # host or host:port\n+            scheme = None\n+            authority = uri\n+            path = '/'\n+        host, port = urllib2.splitport(authority)\n+        if default_port and port is None and scheme is not None:\n+            dport = {\"http\": 80,\n+                     \"https\": 443,\n+                     }.get(scheme)\n+            if dport is not None:\n+                authority = \"%s:%d\" % (host, dport)\n+\n+        return authority, path\n+\n+\n+    def is_suburi(self, base, test):\n+        \"\"\"Check if test is below base in a URI tree\n+\n+        Both args must be URIs in reduced form.\n+        \"\"\"\n+        if base == test:\n+            return True\n+        if base[0] != test[0]:\n+            return False\n+        common = urllib2.posixpath.commonprefix((base[1], test[1]))\n+        if len(common) == len(base[1]):\n+            return True\n+        return False\n+\n+\n+    def empty(self):\n+        self.passwd = {}\n+\n+\n+    def remove(self, uri, realm=None):\n+        # uri could be a single URI or a sequence\n+        if isinstance(uri, basestring):\n+            uri = [uri]\n+\n+        for default_port in True, False:\n+            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])\n+            del self.passwd[reduced_uri][realm]\n+\n+\n+    def __contains__(self, uri):\n+        # uri could be a single URI or a sequence\n+        if isinstance(uri, basestring):\n+            uri = [uri]\n+\n+        uri = tuple([self.reduce_uri(u, False) for u in uri])\n+\n+        if uri in self.passwd:\n+            return True\n+\n+        return False\n+\n+auth_manager = AuthManager()\n+\n+\n+\n+class AuthObject(object):\n+    \"\"\"The :class:`AuthObject` is a simple HTTP Authentication token. When\n+    given to a Requests function, it enables Basic HTTP Authentication for that\n+    Request. You can also enable Authorization for domain realms with AutoAuth.\n+    See AutoAuth for more details.\n+\n+    :param username: Username to authenticate with.\n+    :param password: Password for given username.\n+    :param realm: (optional) the realm this auth applies to\n+    :param handler: (optional) basic || digest || proxy_basic || proxy_digest\n+    \"\"\"\n+\n+    _handlers = {\n+        'basic': _HTTPBasicAuthHandler,\n+        'digest': _HTTPDigestAuthHandler,\n+        'proxy_basic': urllib2.ProxyBasicAuthHandler,\n+        'proxy_digest': urllib2.ProxyDigestAuthHandler\n+    }\n+\n+    def __init__(self, username, password, handler='basic', realm=None):\n+        self.username = username\n+        self.password = password\n+        self.realm = realm\n+\n+        if isinstance(handler, basestring):\n+            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)\n+        else:\n+            self.handler = handler\n+\n+class RequestException(Exception):\n+    \"\"\"There was an ambiguous exception that occured while handling your\n+    request.\"\"\"\n+\n+class AuthenticationError(RequestException):\n+    \"\"\"The authentication credentials provided were invalid.\"\"\"\n+\n+class URLRequired(RequestException):\n+    \"\"\"A valid URL is required to make a request.\"\"\"\n+\n+class InvalidMethod(RequestException):\n+    \"\"\"An inappropriate method was attempted.\"\"\"\n\n@@ -0,0 +1,85 @@\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+requests.monkeys\n+~~~~~~~~~~~~~~~~\n+\n+Monkey patches to urllib2 and the like.\n+\n+\"\"\"\n+\n+# import requests\n+# import urllib\n+import urllib2\n+# import socket\n+# import zlib\n+\n+\n+class _Request(urllib2.Request):\n+    \"\"\"Hidden wrapper around the urllib2.Request object. Allows for manual\n+    setting of HTTP methods.\n+    \"\"\"\n+\n+    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):\n+        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)\n+        self.method = method\n+\n+    def get_method(self):\n+        if self.method:\n+            return self.method\n+\n+        return urllib2.Request.get_method(self)\n+\n+\n+class _HTTPBasicAuthHandler(urllib2.HTTPBasicAuthHandler):\n+    # from mercurial\n+\n+    def __init__(self, *args, **kwargs):\n+        urllib2.HTTPBasicAuthHandler.__init__(self, *args, **kwargs)\n+        self.retried_req = None\n+\n+    def reset_retry_count(self):\n+        # Python 2.6.5 will call this on 401 or 407 errors and thus loop\n+        # forever. We disable reset_retry_count completely and reset in\n+        # http_error_auth_reqed instead.\n+        pass\n+\n+    def http_error_auth_reqed(self, auth_header, host, req, headers):\n+        # Reset the retry counter once for each request.\n+        if req is not self.retried_req:\n+            self.retried_req = req\n+            self.retried = 0\n+        return urllib2.HTTPBasicAuthHandler.http_error_auth_reqed(\n+                        self, auth_header, host, req, headers)\n+\n+\n+\n+class _HTTPDigestAuthHandler(urllib2.HTTPDigestAuthHandler):\n+\n+    def __init__(self, *args, **kwargs):\n+        urllib2.HTTPDigestAuthHandler.__init__(self, *args, **kwargs)\n+        self.retried_req = None\n+\n+    def reset_retry_count(self):\n+        # Python 2.6.5 will call this on 401 or 407 errors and thus loop\n+        # forever. We disable reset_retry_count completely and reset in\n+        # http_error_auth_reqed instead.\n+        pass\n+\n+    def http_error_auth_reqed(self, auth_header, host, req, headers):\n+        # Reset the retry counter once for each request.\n+        if req is not self.retried_req:\n+            self.retried_req = req\n+            self.retried = 0\n+        # In python < 2.5 AbstractDigestAuthHandler raises a ValueError if\n+        # it doesn't know about the auth type requested. This can happen if\n+        # somebody is using BasicAuth and types a bad password.\n+\n+        try:\n+            return urllib2.HTTPDigestAuthHandler.http_error_auth_reqed(\n+                        self, auth_header, host, req, headers)\n+        except ValueError, inst:\n+            arg = inst.args[0]\n+            if arg.startswith(\"AbstractDigestAuthHandler doesn't know \"):\n+                return\n+            raise\n\\ No newline at end of file\n\n@@ -0,0 +1,5 @@\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+requests.monkeys\n+\"\"\"\n\n@@ -123,6 +123,7 @@ class RequestsTestSuite(unittest.TestCase):\n         \"\"\"\n         .. todo:: This really doesn't test to make sure the cookie is working\n         \"\"\"\n+\n         jar = cookielib.CookieJar()\n         self.assertFalse(jar)\n \n@@ -154,7 +155,6 @@ class RequestsTestSuite(unittest.TestCase):\n \n         r = requests.get('https://convore.com/api/account/verify.json', auth=conv_auth)\n         self.assertEquals(r.status_code, 401)\n-        print r.__dict__\n \n \n if __name__ == '__main__':\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
