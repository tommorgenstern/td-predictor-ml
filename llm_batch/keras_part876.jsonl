{"custom_id": "keras#fd2955f28ad05f087c23e79a2747f67d15436918", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 69 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): -9/0 | Churn Δ: 69 | Churn Cumulative: 886 | Contributors (this commit): 9 | Commits (past 90d): 11 | Contributors (cumulative): 9 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1219,75 +1219,6 @@ class ModelTest(testing.TestCase):\n         )\n         self.assertListEqual(hist_keys, ref_keys)\n \n-    @parameterized.named_parameters(\n-        (\"tf_saved_model\", \"tf_saved_model\"),\n-        (\"onnx\", \"onnx\"),\n-    )\n-    @pytest.mark.skipif(\n-        backend.backend() not in (\"tensorflow\", \"jax\", \"torch\"),\n-        reason=(\n-            \"Currently, `Model.export` only supports the tensorflow, jax and \"\n-            \"torch backends.\"\n-        ),\n-    )\n-    @pytest.mark.skipif(\n-        testing.jax_uses_gpu(), reason=\"Leads to core dumps on CI\"\n-    )\n-    def test_export(self, export_format):\n-        if export_format == \"tf_saved_model\" and testing.torch_uses_gpu():\n-            self.skipTest(\"Leads to core dumps on CI\")\n-\n-        temp_filepath = os.path.join(self.get_temp_dir(), \"exported_model\")\n-        model = _get_model()\n-        x1 = np.random.rand(1, 3).astype(\"float32\")\n-        x2 = np.random.rand(1, 3).astype(\"float32\")\n-        ref_output = model([x1, x2])\n-\n-        model.export(temp_filepath, format=export_format)\n-\n-        if export_format == \"tf_saved_model\":\n-            import tensorflow as tf\n-\n-            revived_model = tf.saved_model.load(temp_filepath)\n-            self.assertAllClose(ref_output, revived_model.serve([x1, x2]))\n-\n-            # Test with a different batch size\n-            if backend.backend() == \"torch\":\n-                # TODO: Dynamic shape is not supported yet in the torch backend\n-                return\n-            revived_model.serve(\n-                [\n-                    np.concatenate([x1, x1], axis=0),\n-                    np.concatenate([x2, x2], axis=0),\n-                ]\n-            )\n-        elif export_format == \"onnx\":\n-            import onnxruntime\n-\n-            ort_session = onnxruntime.InferenceSession(temp_filepath)\n-            ort_inputs = {\n-                k.name: v for k, v in zip(ort_session.get_inputs(), [x1, x2])\n-            }\n-            self.assertAllClose(\n-                ref_output, ort_session.run(None, ort_inputs)[0]\n-            )\n-\n-            # Test with a different batch size\n-            if backend.backend() == \"torch\":\n-                # TODO: Dynamic shape is not supported yet in the torch backend\n-                return\n-            ort_inputs = {\n-                k.name: v\n-                for k, v in zip(\n-                    ort_session.get_inputs(),\n-                    [\n-                        np.concatenate([x1, x1], axis=0),\n-                        np.concatenate([x2, x2], axis=0),\n-                    ],\n-                )\n-            }\n-            ort_session.run(None, ort_inputs)\n-\n     def test_export_error(self):\n         temp_filepath = os.path.join(self.get_temp_dir(), \"exported_model\")\n         model = _get_model()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#97c1c00af87aaae69dd56aa2480ff304d40cf516", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 42 | Contributors (this commit): 3 | Commits (past 90d): 4 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -474,7 +474,6 @@ class MeanIoU(IoU):\n             is used to determine each sample's most likely associated label.\n         axis: (Optional) The dimension containing the logits. Defaults to `-1`.\n \n-    Example:\n \n     Example:\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#3d20616ea73602f32ea30e85be4ab505947131cb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 58 | Lines Deleted: 76 | Files Changed: 34 | Hunks: 44 | Methods Changed: 41 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 134 | Churn Cumulative: 10829 | Contributors (this commit): 34 | Commits (past 90d): 111 | Contributors (cumulative): 147 | DMM Complexity: 0.21052631578947367\n\nDIFF:\n@@ -242,9 +242,9 @@ class OpenVINOKerasTensor:\n     def __len__(self):\n         ov_output = self.output\n         ov_shape = ov_output.get_partial_shape()\n-        assert (\n-            ov_shape.rank.is_static and ov_shape.rank.get_length() > 0\n-        ), \"rank must be static and greater than zero\"\n+        assert ov_shape.rank.is_static and ov_shape.rank.get_length() > 0, (\n+            \"rank must be static and greater than zero\"\n+        )\n         assert ov_shape[0].is_static, \"the first dimension must be static\"\n         return ov_shape[0].get_length()\n \n@@ -425,11 +425,11 @@ def convert_to_numpy(x):\n             x = x.value\n         else:\n             return x.value.data\n-    assert isinstance(\n-        x, OpenVINOKerasTensor\n-    ), \"unsupported type {} for `convert_to_numpy` in openvino backend\".format(\n+    assert isinstance(x, OpenVINOKerasTensor), (\n+        \"unsupported type {} for `convert_to_numpy` in openvino backend\".format(\n             type(x)\n         )\n+    )\n     try:\n         ov_result = x.output\n         ov_model = Model(results=[ov_result], parameters=[])\n\n@@ -325,9 +325,9 @@ def depthwise_conv(\n     data_format = backend.standardize_data_format(data_format)\n     num_spatial_dims = inputs.get_partial_shape().rank.get_length() - 2\n \n-    assert (\n-        data_format == \"channels_last\"\n-    ), \"`depthwise_conv` is supported only for channels_last data_format\"\n+    assert data_format == \"channels_last\", (\n+        \"`depthwise_conv` is supported only for channels_last data_format\"\n+    )\n \n     strides = _adjust_strides_dilation(strides, num_spatial_dims)\n     dilation_rate = _adjust_strides_dilation(dilation_rate, num_spatial_dims)\n\n@@ -81,9 +81,9 @@ def mean(x, axis=None, keepdims=False):\n \n \n def max(x, axis=None, keepdims=False, initial=None):\n-    assert (\n-        initial is None\n-    ), \"`max` with not None initial is not supported by openvino backend\"\n+    assert initial is None, (\n+        \"`max` with not None initial is not supported by openvino backend\"\n+    )\n     x = get_ov_output(x)\n     reduce_axis = ov_opset.constant(axis, Type.i32).output(0)\n     return OpenVINOKerasTensor(\n@@ -260,9 +260,9 @@ def bincount(x, weights=None, minlength=0, sparse=False):\n \n \n def broadcast_to(x, shape):\n-    assert isinstance(\n-        shape, (tuple, list)\n-    ), \"`broadcast_to` is supported only for tuple and list `shape`\"\n+    assert isinstance(shape, (tuple, list)), (\n+        \"`broadcast_to` is supported only for tuple and list `shape`\"\n+    )\n     target_shape = ov_opset.constant(list(shape), Type.i32).output(0)\n     x = get_ov_output(x)\n     return OpenVINOKerasTensor(ov_opset.broadcast(x, target_shape).output(0))\n\n@@ -203,8 +203,7 @@ def lstsq(a, b, rcond=None):\n         b = b[:, None]\n     if a.ndim != 2:\n         raise TypeError(\n-            f\"{a.ndim}-dimensional array given. \"\n-            \"Array must be two-dimensional\"\n+            f\"{a.ndim}-dimensional array given. Array must be two-dimensional\"\n         )\n     if b.ndim != 2:\n         raise TypeError(\n\n@@ -2469,8 +2469,7 @@ def squeeze(x, axis=None):\n         for a in axis:\n             if static_shape[a] != 1:\n                 raise ValueError(\n-                    f\"Cannot squeeze axis={a}, because the \"\n-                    \"dimension is not 1.\"\n+                    f\"Cannot squeeze axis={a}, because the dimension is not 1.\"\n                 )\n         axis = sorted([canonicalize_axis(a, len(static_shape)) for a in axis])\n     if isinstance(x, tf.SparseTensor):\n\n@@ -59,7 +59,7 @@ class CSVLogger(Callback):\n                 isinstance(k, collections.abc.Iterable)\n                 and not is_zero_dim_ndarray\n             ):\n-                return f\"\\\"[{', '.join(map(str, k))}]\\\"\"\n+                return f'\"[{\", \".join(map(str, k))}]\"'\n             else:\n                 return k\n \n\n@@ -53,7 +53,7 @@ class SwapEMAWeightsTest(testing.TestCase):\n         model = self._get_compiled_model(use_ema=False)\n         with self.assertRaisesRegex(\n             ValueError,\n-            (\"SwapEMAWeights must be used when \" \"`use_ema=True` is set\"),\n+            (\"SwapEMAWeights must be used when `use_ema=True` is set\"),\n         ):\n             model.fit(\n                 self.x_train,\n\n@@ -65,7 +65,7 @@ def make_input_spec(x):\n     if isinstance(x, layers.InputSpec):\n         if x.shape is None or x.dtype is None:\n             raise ValueError(\n-                \"The `shape` and `dtype` must be provided. \" f\"Received: x={x}\"\n+                f\"The `shape` and `dtype` must be provided. Received: x={x}\"\n             )\n         input_spec = x\n     elif isinstance(x, backend.KerasTensor):\n\n@@ -116,8 +116,7 @@ def _check_jax_kwargs(kwargs):\n         }\n     if kwargs[\"is_static\"] is not True:\n         raise ValueError(\n-            \"`is_static` must be `True` in `kwargs` when using the jax \"\n-            \"backend.\"\n+            \"`is_static` must be `True` in `kwargs` when using the jax backend.\"\n         )\n     if kwargs[\"jax2tf_kwargs\"][\"enable_xla\"] is not False:\n         raise ValueError(\n\n@@ -39,8 +39,7 @@ class LeakyReLU(Layer):\n         if \"alpha\" in kwargs:\n             negative_slope = kwargs.pop(\"alpha\")\n             warnings.warn(\n-                \"Argument `alpha` is deprecated. \"\n-                \"Use `negative_slope` instead.\"\n+                \"Argument `alpha` is deprecated. Use `negative_slope` instead.\"\n             )\n         super().__init__(**kwargs)\n         if negative_slope is None or negative_slope < 0:\n\n@@ -112,8 +112,7 @@ class GroupedQueryAttention(Layer):\n         self.num_key_value_heads = num_key_value_heads\n         if num_query_heads % num_key_value_heads != 0:\n             raise ValueError(\n-                \"`num_query_heads` must be divisible\"\n-                \" by `num_key_value_heads`.\"\n+                \"`num_query_heads` must be divisible by `num_key_value_heads`.\"\n             )\n         self.num_repeats = num_query_heads // num_key_value_heads\n         self.dropout = dropout\n\n@@ -644,7 +644,7 @@ class MultiHeadAttentionTest(testing.TestCase):\n         output = mha(query=query, value=value)\n \n         assert output.shape == (2, 4, 8), (\n-            f\"Expected shape (2, 4, 8),\" f\" got {output.shape}\"\n+            f\"Expected shape (2, 4, 8), got {output.shape}\"\n         )\n \n     def test_multi_head_attention_output_shape_as_tuple(self):\n@@ -657,7 +657,7 @@ class MultiHeadAttentionTest(testing.TestCase):\n         output = mha(query=query, value=value)\n \n         assert output.shape == (2, 4, 8, 8), (\n-            f\"Expected shape (2, 4, 8, 8),\" f\" got {output.shape}\"\n+            f\"Expected shape (2, 4, 8, 8), got {output.shape}\"\n         )\n \n     def test_multi_head_attention_output_shape_error(self):\n\n@@ -282,8 +282,7 @@ class BaseConv(Layer):\n             )\n         if self.lora_enabled:\n             raise ValueError(\n-                \"lora is already enabled. \"\n-                \"This can only be done once per layer.\"\n+                \"lora is already enabled. This can only be done once per layer.\"\n             )\n         self._tracker.unlock()\n         self.lora_kernel_a = self.add_weight(\n\n@@ -168,8 +168,7 @@ class Dense(Layer):\n             )\n         if self.lora_enabled:\n             raise ValueError(\n-                \"lora is already enabled. \"\n-                \"This can only be done once per layer.\"\n+                \"lora is already enabled. This can only be done once per layer.\"\n             )\n         self._tracker.unlock()\n         self.lora_kernel_a = self.add_weight(\n\n@@ -224,8 +224,7 @@ class EinsumDense(Layer):\n             )\n         if self.lora_enabled:\n             raise ValueError(\n-                \"lora is already enabled. \"\n-                \"This can only be done once per layer.\"\n+                \"lora is already enabled. This can only be done once per layer.\"\n             )\n         self._tracker.unlock()\n         self.lora_kernel_a = self.add_weight(\n\n@@ -163,8 +163,7 @@ class Embedding(Layer):\n             )\n         if self.lora_enabled:\n             raise ValueError(\n-                \"lora is already enabled. \"\n-                \"This can only be done once per layer.\"\n+                \"lora is already enabled. This can only be done once per layer.\"\n             )\n         self._tracker.unlock()\n         self.lora_embeddings_a = self.add_weight(\n\n@@ -1430,8 +1430,7 @@ class Layer(BackendLayer, Operation, KerasSaveable):\n \n     def __repr__(self):\n         return (\n-            f\"<{self.__class__.__name__} \"\n-            f\"name={self.name}, built={self.built}>\"\n+            f\"<{self.__class__.__name__} name={self.name}, built={self.built}>\"\n         )\n \n     def __str__(self):\n\n@@ -87,10 +87,7 @@ class LayerNormalizationTest(testing.TestCase):\n     def test_invalid_axis(self):\n         with self.assertRaisesRegex(\n             TypeError,\n-            (\n-                \"Expected an int or a list/tuple of ints for the argument \"\n-                \"'axis'\"\n-            ),\n+            (\"Expected an int or a list/tuple of ints for the argument 'axis'\"),\n         ):\n             layers.LayerNormalization(axis={\"axis\": -1})\n \n\n@@ -90,7 +90,7 @@ class HashedCrossing(Layer):\n         super().__init__(name=name, dtype=dtype)\n         if sparse and backend.backend() != \"tensorflow\":\n             raise ValueError(\n-                \"`sparse=True` can only be used with the \" \"TensorFlow backend.\"\n+                \"`sparse=True` can only be used with the TensorFlow backend.\"\n             )\n \n         argument_validation.validate_string_arg(\n\n@@ -49,8 +49,7 @@ class RandomGrayscale(BaseImagePreprocessingLayer):\n         super().__init__(**kwargs)\n         if factor < 0 or factor > 1:\n             raise ValueError(\n-                \"`factor` should be between 0 and 1. \"\n-                f\"Received: factor={factor}\"\n+                f\"`factor` should be between 0 and 1. Received: factor={factor}\"\n             )\n         self.factor = factor\n         self.data_format = backend.standardize_data_format(data_format)\n\n@@ -328,7 +328,7 @@ class IntegerLookup(IndexLookup):\n             )\n         if sparse and backend.backend() != \"tensorflow\":\n             raise ValueError(\n-                \"`sparse=True` can only be used with the \" \"TensorFlow backend.\"\n+                \"`sparse=True` can only be used with the TensorFlow backend.\"\n             )\n         if vocabulary_dtype != \"int64\":\n             raise ValueError(\n\n@@ -314,7 +314,7 @@ class StringLookup(IndexLookup):\n             )\n         if sparse and backend.backend() != \"tensorflow\":\n             raise ValueError(\n-                \"`sparse=True` can only be used with the \" \"TensorFlow backend.\"\n+                \"`sparse=True` can only be used with the TensorFlow backend.\"\n             )\n         self.encoding = encoding\n         super().__init__(\n\n@@ -226,11 +226,11 @@ class TextVectorization(Layer):\n             )\n         if sparse and backend.backend() != \"tensorflow\":\n             raise ValueError(\n-                \"`sparse=True` can only be used with the \" \"TensorFlow backend.\"\n+                \"`sparse=True` can only be used with the TensorFlow backend.\"\n             )\n         if ragged and backend.backend() != \"tensorflow\":\n             raise ValueError(\n-                \"`ragged=True` can only be used with the \" \"TensorFlow backend.\"\n+                \"`ragged=True` can only be used with the TensorFlow backend.\"\n             )\n \n         # 'standardize' must be one of\n\n@@ -247,7 +247,7 @@ class Metric(KerasSaveable):\n             )\n \n     def __repr__(self):\n-        return f\"<{self.__class__.__name__} \" f\"name={self.name}>\"\n+        return f\"<{self.__class__.__name__} name={self.name}>\"\n \n     def __str__(self):\n         return self.__repr__()\n\n@@ -978,8 +978,7 @@ def _pad_images(\n         )\n     if left_padding < 0:\n         raise ValueError(\n-            \"left_padding must be >= 0. \"\n-            f\"Received: left_padding={left_padding}\"\n+            f\"left_padding must be >= 0. Received: left_padding={left_padding}\"\n         )\n     if right_padding < 0:\n         raise ValueError(\n@@ -1198,8 +1197,7 @@ def _crop_images(\n \n     if top_cropping < 0:\n         raise ValueError(\n-            \"top_cropping must be >= 0. \"\n-            f\"Received: top_cropping={top_cropping}\"\n+            f\"top_cropping must be >= 0. Received: top_cropping={top_cropping}\"\n         )\n     if target_height < 0:\n         raise ValueError(\n@@ -1213,8 +1211,7 @@ def _crop_images(\n         )\n     if target_width < 0:\n         raise ValueError(\n-            \"target_width must be >= 0. \"\n-            f\"Received: target_width={target_width}\"\n+            f\"target_width must be >= 0. Received: target_width={target_width}\"\n         )\n \n     # Compute start_indices and shape\n\n@@ -596,12 +596,11 @@ class Lstsq(Operation):\n     def compute_output_spec(self, a, b):\n         if len(a.shape) != 2:\n             raise ValueError(\n-                \"Expected a to have rank 2. \" f\"Received: a.shape={a.shape}\"\n+                f\"Expected a to have rank 2. Received: a.shape={a.shape}\"\n             )\n         if len(b.shape) not in (1, 2):\n             raise ValueError(\n-                \"Expected b to have rank 1 or 2. \"\n-                f\"Received: b.shape={b.shape}\"\n+                f\"Expected b to have rank 1 or 2. Received: b.shape={b.shape}\"\n             )\n         m, n = a.shape\n         if b.shape[0] != m:\n@@ -666,8 +665,7 @@ def _assert_1d(*arrays):\n     for a in arrays:\n         if a.ndim < 1:\n             raise ValueError(\n-                \"Expected input to have rank >= 1. \"\n-                \"Received scalar input {a}.\"\n+                \"Expected input to have rank >= 1. Received scalar input {a}.\"\n             )\n \n \n\n@@ -6754,7 +6754,7 @@ class Argpartition(Operation):\n     def __init__(self, kth, axis=-1):\n         super().__init__()\n         if not isinstance(kth, int):\n-            raise ValueError(\"kth must be an integer. Received:\" f\"kth = {kth}\")\n+            raise ValueError(f\"kth must be an integer. Received:kth = {kth}\")\n         self.kth = kth\n         self.axis = axis\n \n\n@@ -76,7 +76,7 @@ class SeedGenerator:\n \n         if not isinstance(seed, int):\n             raise ValueError(\n-                \"Argument `seed` must be an integer. \" f\"Received: seed={seed}\"\n+                f\"Argument `seed` must be an integer. Received: seed={seed}\"\n             )\n \n         def seed_initializer(*args, **kwargs):\n\n@@ -500,7 +500,7 @@ class KerasFileEditor:\n         if rich_style:\n             version = f\"{summary_utils.highlight_symbol(version)}\"\n             date = f\"{summary_utils.highlight_symbol(date)}\"\n-        return f\"Saved with Keras {version} \" f\"- date: {date}\"\n+        return f\"Saved with Keras {version} - date: {date}\"\n \n     def _print_weights_structure(\n         self, weights_dict, indent=0, is_first=True, prefix=\"\", inner_path=\"\"\n\n@@ -53,9 +53,7 @@ class TestCase(parameterized.TestCase, unittest.TestCase):\n             return\n         msg = msg or \"\"\n         raise AssertionError(\n-            f\"The two values are close at all elements. \\n\"\n-            f\"{msg}.\\n\"\n-            f\"Values: {x1}\"\n+            f\"The two values are close at all elements. \\n{msg}.\\nValues: {x1}\"\n         )\n \n     def assertAlmostEqual(self, x1, x2, decimal=3, msg=None):\n@@ -225,8 +223,7 @@ class TestCase(parameterized.TestCase, unittest.TestCase):\n         \"\"\"\n         if input_shape is not None and input_data is not None:\n             raise ValueError(\n-                \"input_shape and input_data cannot be passed \"\n-                \"at the same time.\"\n+                \"input_shape and input_data cannot be passed at the same time.\"\n             )\n         if expected_output_shape is not None and expected_output is not None:\n             raise ValueError(\n\n@@ -542,8 +542,7 @@ class CompileLoss(losses_module.Loss):\n \n         else:\n             raise TypeError(\n-                f\"Unsupported type {type(loss)} \"\n-                f\"in the `loss` configuration.\"\n+                f\"Unsupported type {type(loss)} in the `loss` configuration.\"\n             )\n \n         for key, _loss in iterator:\n\n@@ -682,7 +682,7 @@ def get_training_or_validation_split(samples, labels, validation_split, subset):\n     num_val_samples = int(validation_split * len(samples))\n     if subset == \"training\":\n         io_utils.print_msg(\n-            f\"Using {len(samples) - num_val_samples} \" f\"files for training.\"\n+            f\"Using {len(samples) - num_val_samples} files for training.\"\n         )\n         samples = samples[:-num_val_samples]\n         if labels is not None:\n\n@@ -324,7 +324,12 @@ class TestJaxLayer(testing.TestCase):\n         model2.export(path, format=\"tf_saved_model\")\n         model4 = tf.saved_model.load(path)\n         output4 = model4.serve(x_test)\n-        self.assertAllClose(output1, output4)\n+        self.assertAllClose(\n+            output1,\n+            output4,\n+            # The output difference might be significant when using the GPU\n+            atol=1e-2 if testing.jax_uses_gpu() else 1e-6,\n+        )\n \n         # test subclass model building without a build method\n         class TestModel(models.Model):\n\n@@ -149,7 +149,7 @@ def make_layer_label(layer, **kwargs):\n         cols.append(\n             (\n                 '<td bgcolor=\"white\"><font point-size=\"14\">'\n-                f'Output dtype: <b>{dtype or \"?\"}</b>'\n+                f\"Output dtype: <b>{dtype or '?'}</b>\"\n                 \"</font></td>\"\n             )\n         )\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#e67ac8ffd0c883bec68eb65bb52340c7f9d3a903", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 8 | Files Changed: 2 | Hunks: 5 | Methods Changed: 3 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 18 | Churn Cumulative: 376 | Contributors (this commit): 9 | Commits (past 90d): 9 | Contributors (cumulative): 12 | DMM Complexity: 1.0\n\nDIFF:\n@@ -19,6 +19,7 @@ from keras.src.ops.function import _build_map\n from keras.src.ops.function import make_node_key\n from keras.src.ops.node import KerasHistory\n from keras.src.ops.node import Node\n+from keras.src.ops.operation import Operation\n from keras.src.saving import serialization_lib\n from keras.src.utils import tracking\n \n@@ -523,6 +524,11 @@ def functional_from_config(cls, config, custom_objects=None):\n             layer = serialization_lib.deserialize_keras_object(\n                 layer_data, custom_objects=custom_objects\n             )\n+        if not isinstance(layer, Operation):\n+            raise ValueError(\n+                \"Unexpected object from deserialization, expected a layer or \"\n+                f\"operation, got a {type(layer)}\"\n+            )\n         created_layers[layer_name] = layer\n \n         # Gather layer inputs.\n\n@@ -783,22 +783,18 @@ def _retrieve_class_or_fn(\n \n         # Otherwise, attempt to retrieve the class object given the `module`\n         # and `class_name`. Import the module, find the class.\n+        if module == \"keras.src\" or module.startswith(\"keras.src.\"):\n             try:\n                 mod = importlib.import_module(module)\n+                obj = vars(mod).get(name, None)\n+                if obj is not None:\n+                    return obj\n             except ModuleNotFoundError:\n                 raise TypeError(\n                     f\"Could not deserialize {obj_type} '{name}' because \"\n                     f\"its parent module {module} cannot be imported. \"\n                     f\"Full object config: {full_config}\"\n                 )\n-        obj = vars(mod).get(name, None)\n-\n-        # Special case for keras.metrics.metrics\n-        if obj is None and registered_name is not None:\n-            obj = vars(mod).get(registered_name, None)\n-\n-        if obj is not None:\n-            return obj\n \n     raise TypeError(\n         f\"Could not locate {obj_type} '{name}'. \"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#cdbe4fb1754a30d39fc818fc3e8d02b3e818148a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 233 | Lines Deleted: 0 | Files Changed: 6 | Hunks: 6 | Methods Changed: 15 | Complexity Δ (Sum/Max): 45/11 | Churn Δ: 233 | Churn Cumulative: 4188 | Contributors (this commit): 17 | Commits (past 90d): 42 | Contributors (cumulative): 64 | DMM Complexity: 0.6898395721925134\n\nDIFF:\n@@ -15,6 +15,19 @@ from keras.src.backend.jax.core import cast\n from keras.src.backend.jax.core import convert_to_tensor\n \n \n+def rot90(array, k=1, axes=(0, 1)):\n+    \"\"\"Rotate an array by 90 degrees in the specified plane.\"\"\"\n+    if array.ndim < 2:\n+        raise ValueError(\n+            f\"Input array must have at least 2 dimensions. Received: array.ndim={array.ndim}\"\n+        )\n+    if len(axes) != 2 or axes[0] == axes[1]:\n+        raise ValueError(\n+            f\"Invalid axes: {axes}. Axes must be a tuple of two different dimensions.\"\n+        )\n+    return jnp.rot90(array, k=k, axes=axes)\n+\n+\n @sparse.elementwise_binary_union(linear=True, use_sparsify=True)\n def add(x1, x2):\n     x1 = convert_to_tensor(x1)\n\n@@ -8,6 +8,19 @@ from keras.src.backend.common.backend_utils import standardize_axis_for_numpy\n from keras.src.backend.numpy.core import convert_to_tensor\n \n \n+def rot90(array, k=1, axes=(0, 1)):\n+    \"\"\"Rotate an array by 90 degrees in the specified plane.\"\"\"\n+    if array.ndim < 2:\n+        raise ValueError(\n+            f\"Input array must have at least 2 dimensions. Received: array.ndim={array.ndim}\"\n+        )\n+    if len(axes) != 2 or axes[0] == axes[1]:\n+        raise ValueError(\n+            f\"Invalid axes: {axes}. Axes must be a tuple of two different dimensions.\"\n+        )\n+    return np.rot90(array, k=k, axes=axes)\n+\n+\n def add(x1, x2):\n     if not isinstance(x1, (int, float)):\n         x1 = convert_to_tensor(x1)\n\n@@ -23,6 +23,49 @@ from keras.src.backend.tensorflow.core import convert_to_tensor\n from keras.src.backend.tensorflow.core import shape as shape_op\n \n \n+def rot90(array, k=1, axes=(0, 1)):\n+    \"\"\"Rotate an array by 90 degrees in the specified plane.\"\"\"\n+    array = convert_to_tensor(array)\n+    \n+    if array.shape.rank < 2:\n+        raise ValueError(\n+            f\"Input array must have at least 2 dimensions. Received: array.ndim={array.shape.rank}\"\n+        )\n+    \n+    if len(axes) != 2 or axes[0] == axes[1]:\n+        raise ValueError(\n+            f\"Invalid axes: {axes}. Axes must be a tuple of two different dimensions.\"\n+        )\n+    \n+    k = k % 4\n+    if k == 0:\n+        return array\n+    \n+    axes = tuple(axis if axis >= 0 else array.shape.rank + axis for axis in axes)\n+    \n+    perm = [i for i in range(array.shape.rank) if i not in axes]\n+    perm.extend(axes)\n+    array = tf.transpose(array, perm)\n+    \n+    shape = tf.shape(array)\n+    non_rot_shape = shape[:-2]\n+    rot_shape = shape[-2:]\n+    \n+    array = tf.reshape(array, tf.concat([[-1], rot_shape], axis=0))\n+    \n+    for _ in range(k):\n+        array = tf.transpose(array, [0, 2, 1])\n+        array = tf.reverse(array, axis=[1])\n+    array = tf.reshape(array, tf.concat([non_rot_shape, rot_shape], axis=0))\n+    \n+    inv_perm = [0] * len(perm)\n+    for i, p in enumerate(perm):\n+        inv_perm[p] = i\n+    array = tf.transpose(array, inv_perm)\n+    \n+    return array\n+\n+\n @sparse.elementwise_binary_union(tf.sparse.add)\n def add(x1, x2):\n     if not isinstance(x1, (int, float)):\n\n@@ -25,6 +25,40 @@ TORCH_INT_TYPES = (\n )\n \n \n+def rot90(array, k=1, axes=(0, 1)):\n+    \"\"\"Rotate an array by 90 degrees in the specified plane using PyTorch.\n+    \n+    Args:\n+        array: Input tensor\n+        k: Number of 90-degree rotations (default=1)\n+        axes: Tuple of two axes that define the plane of rotation (default=(0,1))\n+    \n+    Returns:\n+        Rotated tensor\n+    \"\"\"\n+    array = convert_to_tensor(array)\n+    \n+    if array.ndim < 2:\n+        raise ValueError(\n+            f\"Input array must have at least 2 dimensions. Received: array.ndim={array.ndim}\"\n+        )\n+    if len(axes) != 2 or axes[0] == axes[1]:\n+        raise ValueError(\n+            f\"Invalid axes: {axes}. Axes must be a tuple of two different dimensions.\"\n+        )\n+    \n+    axes = tuple(axis if axis >= 0 else array.ndim + axis for axis in axes)\n+\n+    if not builtins.all(0 <= axis < array.ndim for axis in axes):\n+        raise ValueError(f\"Invalid axes {axes} for tensor with {array.ndim} dimensions\")\n+    \n+    rotated = torch.rot90(array, k=k, dims=axes)\n+    if isinstance(array, np.ndarray):\n+        rotated = rotated.cpu().numpy()\n+    \n+    return rotated\n+\n+\n def add(x1, x2):\n     x1 = convert_to_tensor(x1)\n     x2 = convert_to_tensor(x2)\n\n@@ -16,6 +16,69 @@ from keras.src.ops.operation_utils import broadcast_shapes\n from keras.src.ops.operation_utils import reduce_shape\n \n \n+class Rot90(Operation):\n+    def __init__(self, k=1, axes=(0, 1)):\n+        super().__init__()\n+        self.k = k\n+        self.axes = axes\n+\n+    def call(self, array):\n+        return backend.numpy.rot90(array, k=self.k, axes=self.axes)\n+\n+    def compute_output_spec(self, array):\n+        array_shape = list(array.shape)\n+        if len(array_shape) < 2:\n+            raise ValueError(\n+                \"Input array must have at least 2 dimensions. \"\n+                f\"Received: array.shape={array_shape}\"\n+            )\n+        if len(self.axes) != 2 or self.axes[0] == self.axes[1]:\n+            raise ValueError(\n+                f\"Invalid axes: {self.axes}. Axes must be a tuple of two different dimensions.\"\n+            )\n+        axis1, axis2 = self.axes\n+        array_shape[axis1], array_shape[axis2] = array_shape[axis2], array_shape[axis1]\n+        return KerasTensor(shape=array_shape, dtype=array.dtype)\n+\n+\n+@keras_export([\"keras.ops.rot90\", \"keras.ops.numpy.rot90\"])\n+def rot90(array, k=1, axes=(0, 1)):\n+    \"\"\"Rotate an array by 90 degrees in the plane specified by axes.\n+\n+    This function rotates an array counterclockwise by 90 degrees `k` times\n+    in the plane specified by `axes`. Supports arrays of two or more dimensions.\n+\n+    Args:\n+        array: Input array to rotate.\n+        k: Number of times the array is rotated by 90 degrees.\n+        axes: A tuple of two integers specifying the plane for rotation.\n+\n+    Returns:\n+        Rotated array.\n+\n+    Examples:\n+\n+    >>> import numpy as np\n+    >>> from keras import ops\n+    >>> m = np.array([[1, 2], [3, 4]])\n+    >>> rotated = ops.rot90(m)\n+    >>> rotated\n+    array([[2, 4],\n+           [1, 3]])\n+\n+    >>> m = np.arange(8).reshape((2, 2, 2))\n+    >>> rotated = ops.rot90(m, k=1, axes=(1, 2))\n+    >>> rotated\n+    array([[[1, 3],\n+            [0, 2]],\n+           [[5, 7],\n+            [4, 6]]])\n+    \"\"\"\n+    if any_symbolic_tensors((array,)):\n+        return Rot90(k=k, axes=axes).symbolic_call(array)\n+    return backend.numpy.rot90(array, k=k, axes=axes)\n+\n+\n def shape_equal(shape1, shape2, axis=None, allow_none=True):\n     \"\"\"Check if two shapes are equal.\n \n\n@@ -19,6 +19,73 @@ from keras.src.ops import numpy as knp\n from keras.src.testing.test_utils import named_product\n \n \n+class NumPyTestRot90(testing.TestCase):\n+    def test_basic(self):\n+        array = np.array([[1, 2], [3, 4]])\n+        rotated = knp.rot90(array)\n+        expected = np.array([[2, 4], [1, 3]])\n+        assert np.array_equal(rotated, expected), f\"Failed basic 2D test: {rotated}\"\n+\n+    def test_multiple_k(self):\n+        array = np.array([[1, 2], [3, 4]])\n+\n+        # k=2 (180 degrees rotation)\n+        rotated = knp.rot90(array, k=2)\n+        expected = np.array([[4, 3], [2, 1]])\n+        assert np.array_equal(rotated, expected), f\"Failed k=2 test: {rotated}\"\n+\n+        # k=3 (270 degrees rotation)\n+        rotated = knp.rot90(array, k=3)\n+        expected = np.array([[3, 1], [4, 2]])\n+        assert np.array_equal(rotated, expected), f\"Failed k=3 test: {rotated}\"\n+\n+        # k=4 (full rotation)\n+        rotated = knp.rot90(array, k=4)\n+        expected = array\n+        assert np.array_equal(rotated, expected), f\"Failed k=4 test: {rotated}\"\n+\n+    def test_axes(self):\n+        array = np.arange(8).reshape((2, 2, 2))\n+        rotated = knp.rot90(array, k=1, axes=(1, 2))\n+        expected = np.array([[[1, 3], [0, 2]], [[5, 7], [4, 6]]])\n+        assert np.array_equal(rotated, expected), f\"Failed custom axes test: {rotated}\"\n+\n+    def test_single_image(self):\n+        array = np.random.random((4, 4, 3))\n+        rotated = knp.rot90(array, k=1, axes=(0, 1))\n+        expected = np.rot90(array, k=1, axes=(0, 1))\n+        assert np.allclose(rotated, expected), \"Failed single image test\"\n+\n+    def test_batch_images(self):\n+        array = np.random.random((2, 4, 4, 3))\n+        rotated = knp.rot90(array, k=1, axes=(1, 2))\n+        expected = np.rot90(array, k=1, axes=(1, 2))\n+        assert np.allclose(rotated, expected), \"Failed batch images test\"\n+\n+    def test_invalid_axes(self):\n+        array = np.array([[1, 2], [3, 4]])\n+        try:\n+            knp.rot90(array, axes=(0, 0))\n+        except ValueError as e:\n+            assert (\n+                \"Invalid axes: (0, 0). Axes must be a tuple of two different dimensions.\"\n+                in str(e)\n+            ), f\"Failed invalid axes test: {e}\"\n+        else:\n+            raise AssertionError(\"Failed to raise error for invalid axes\")\n+\n+    def test_invalid_rank(self):\n+        array = np.array([1, 2, 3])  # 1D array\n+        try:\n+            knp.rot90(array)\n+        except ValueError as e:\n+            assert (\n+                \"Input array must have at least 2 dimensions.\" in str(e)\n+            ), f\"Failed invalid rank test: {e}\"\n+        else:\n+            raise AssertionError(\"Failed to raise error for invalid input rank\")\n+\n+\n class NumpyTwoInputOpsDynamicShapeTest(testing.TestCase):\n     def test_add(self):\n         x = KerasTensor((None, 3))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#509c92b451e6fd0d3bf9cdb787f9c0bedca335d4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 71 | Lines Deleted: 43 | Files Changed: 10 | Hunks: 28 | Methods Changed: 17 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 114 | Churn Cumulative: 7081 | Contributors (this commit): 21 | Commits (past 90d): 70 | Contributors (cumulative): 82 | DMM Complexity: 0.6785714285714286\n\nDIFF:\n@@ -19,11 +19,13 @@ def rot90(array, k=1, axes=(0, 1)):\n     \"\"\"Rotate an array by 90 degrees in the specified plane.\"\"\"\n     if array.ndim < 2:\n         raise ValueError(\n-            f\"Input array must have at least 2 dimensions. Received: array.ndim={array.ndim}\"\n+            f\"Input array must have at least 2 dimensions. \"\n+            f\"Received: array.ndim={array.ndim}\"\n         )\n     if len(axes) != 2 or axes[0] == axes[1]:\n         raise ValueError(\n-            f\"Invalid axes: {axes}. Axes must be a tuple of two different dimensions.\"\n+            f\"Invalid axes: {axes}. Axes must be a tuple of \"\n+            \"two different dimensions.\"\n         )\n     return jnp.rot90(array, k=k, axes=axes)\n \n\n@@ -12,11 +12,13 @@ def rot90(array, k=1, axes=(0, 1)):\n     \"\"\"Rotate an array by 90 degrees in the specified plane.\"\"\"\n     if array.ndim < 2:\n         raise ValueError(\n-            f\"Input array must have at least 2 dimensions. Received: array.ndim={array.ndim}\"\n+            \"Input array must have at least 2 dimensions. \"\n+            f\"Received: array.ndim={array.ndim}\"\n         )\n     if len(axes) != 2 or axes[0] == axes[1]:\n         raise ValueError(\n-            f\"Invalid axes: {axes}. Axes must be a tuple of two different dimensions.\"\n+            f\"Invalid axes: {axes}. Axes must be a tuple \"\n+            \"of two different dimensions.\"\n         )\n     return np.rot90(array, k=k, axes=axes)\n \n\n@@ -242,9 +242,9 @@ class OpenVINOKerasTensor:\n     def __len__(self):\n         ov_output = self.output\n         ov_shape = ov_output.get_partial_shape()\n-        assert ov_shape.rank.is_static and ov_shape.rank.get_length() > 0, (\n-            \"rank must be static and greater than zero\"\n-        )\n+        assert (\n+            ov_shape.rank.is_static and ov_shape.rank.get_length() > 0\n+        ), \"rank must be static and greater than zero\"\n         assert ov_shape[0].is_static, \"the first dimension must be static\"\n         return ov_shape[0].get_length()\n \n@@ -425,11 +425,11 @@ def convert_to_numpy(x):\n             x = x.value\n         else:\n             return x.value.data\n-    assert isinstance(x, OpenVINOKerasTensor), (\n-        \"unsupported type {} for `convert_to_numpy` in openvino backend\".format(\n+    assert isinstance(\n+        x, OpenVINOKerasTensor\n+    ), \"unsupported type {} for `convert_to_numpy` in openvino backend\".format(\n         type(x)\n     )\n-    )\n     try:\n         ov_result = x.output\n         ov_model = Model(results=[ov_result], parameters=[])\n\n@@ -325,9 +325,9 @@ def depthwise_conv(\n     data_format = backend.standardize_data_format(data_format)\n     num_spatial_dims = inputs.get_partial_shape().rank.get_length() - 2\n \n-    assert data_format == \"channels_last\", (\n-        \"`depthwise_conv` is supported only for channels_last data_format\"\n-    )\n+    assert (\n+        data_format == \"channels_last\"\n+    ), \"`depthwise_conv` is supported only for channels_last data_format\"\n \n     strides = _adjust_strides_dilation(strides, num_spatial_dims)\n     dilation_rate = _adjust_strides_dilation(dilation_rate, num_spatial_dims)\n\n@@ -81,9 +81,9 @@ def mean(x, axis=None, keepdims=False):\n \n \n def max(x, axis=None, keepdims=False, initial=None):\n-    assert initial is None, (\n-        \"`max` with not None initial is not supported by openvino backend\"\n-    )\n+    assert (\n+        initial is None\n+    ), \"`max` with not None initial is not supported by openvino backend\"\n     x = get_ov_output(x)\n     reduce_axis = ov_opset.constant(axis, Type.i32).output(0)\n     return OpenVINOKerasTensor(\n@@ -260,9 +260,9 @@ def bincount(x, weights=None, minlength=0, sparse=False):\n \n \n def broadcast_to(x, shape):\n-    assert isinstance(shape, (tuple, list)), (\n-        \"`broadcast_to` is supported only for tuple and list `shape`\"\n-    )\n+    assert isinstance(\n+        shape, (tuple, list)\n+    ), \"`broadcast_to` is supported only for tuple and list `shape`\"\n     target_shape = ov_opset.constant(list(shape), Type.i32).output(0)\n     x = get_ov_output(x)\n     return OpenVINOKerasTensor(ov_opset.broadcast(x, target_shape).output(0))\n\n@@ -29,19 +29,23 @@ def rot90(array, k=1, axes=(0, 1)):\n \n     if array.shape.rank < 2:\n         raise ValueError(\n-            f\"Input array must have at least 2 dimensions. Received: array.ndim={array.shape.rank}\"\n+            f\"Input array must have at least 2 dimensions. \"\n+            f\"Received: array.ndim={array.shape.rank}\"\n         )\n \n     if len(axes) != 2 or axes[0] == axes[1]:\n         raise ValueError(\n-            f\"Invalid axes: {axes}. Axes must be a tuple of two different dimensions.\"\n+            f\"Invalid axes: {axes}. Axes must be a tuple of \"\n+            \"two different dimensions.\"\n         )\n \n     k = k % 4\n     if k == 0:\n         return array\n \n-    axes = tuple(axis if axis >= 0 else array.shape.rank + axis for axis in axes)\n+    axes = tuple(\n+        axis if axis >= 0 else array.shape.rank + axis for axis in axes\n+    )\n \n     perm = [i for i in range(array.shape.rank) if i not in axes]\n     perm.extend(axes)\n\n@@ -31,7 +31,8 @@ def rot90(array, k=1, axes=(0, 1)):\n     Args:\n         array: Input tensor\n         k: Number of 90-degree rotations (default=1)\n-        axes: Tuple of two axes that define the plane of rotation (default=(0,1))\n+        axes: Tuple of two axes that define the\n+            plane of rotation (defaults to `(0, 1)`).\n \n     Returns:\n         Rotated tensor\n@@ -40,17 +41,21 @@ def rot90(array, k=1, axes=(0, 1)):\n \n     if array.ndim < 2:\n         raise ValueError(\n-            f\"Input array must have at least 2 dimensions. Received: array.ndim={array.ndim}\"\n+            \"Input array must have at least 2 dimensions. \"\n+            f\"Received: array.ndim={array.ndim}\"\n         )\n     if len(axes) != 2 or axes[0] == axes[1]:\n         raise ValueError(\n-            f\"Invalid axes: {axes}. Axes must be a tuple of two different dimensions.\"\n+            f\"Invalid axes: {axes}. Axes must be a tuple \"\n+            \"of two different dimensions.\"\n         )\n \n     axes = tuple(axis if axis >= 0 else array.ndim + axis for axis in axes)\n \n     if not builtins.all(0 <= axis < array.ndim for axis in axes):\n-        raise ValueError(f\"Invalid axes {axes} for tensor with {array.ndim} dimensions\")\n+        raise ValueError(\n+            f\"Invalid axes {axes} for tensor with {array.ndim} dimensions\"\n+        )\n \n     rotated = torch.rot90(array, k=k, dims=axes)\n     if isinstance(array, np.ndarray):\n\n@@ -643,9 +643,11 @@ class MultiHeadAttentionTest(testing.TestCase):\n         value = random.uniform((2, 4, 16))\n         output = mha(query=query, value=value)\n \n-        assert output.shape == (2, 4, 8), (\n-            f\"Expected shape (2, 4, 8), got {output.shape}\"\n-        )\n+        assert output.shape == (\n+            2,\n+            4,\n+            8,\n+        ), f\"Expected shape (2, 4, 8), got {output.shape}\"\n \n     def test_multi_head_attention_output_shape_as_tuple(self):\n         \"\"\"Test MultiHeadAttention with output_shape as a tuple.\"\"\"\n@@ -656,9 +658,12 @@ class MultiHeadAttentionTest(testing.TestCase):\n         value = random.uniform((2, 4, 16))\n         output = mha(query=query, value=value)\n \n-        assert output.shape == (2, 4, 8, 8), (\n-            f\"Expected shape (2, 4, 8, 8), got {output.shape}\"\n-        )\n+        assert output.shape == (\n+            2,\n+            4,\n+            8,\n+            8,\n+        ), f\"Expected shape (2, 4, 8, 8), got {output.shape}\"\n \n     def test_multi_head_attention_output_shape_error(self):\n         with self.assertRaisesRegex(ValueError, r\"Invalid `output_shape`\"):\n\n@@ -34,10 +34,14 @@ class Rot90(Operation):\n             )\n         if len(self.axes) != 2 or self.axes[0] == self.axes[1]:\n             raise ValueError(\n-                f\"Invalid axes: {self.axes}. Axes must be a tuple of two different dimensions.\"\n+                f\"Invalid axes: {self.axes}. \"\n+                \"Axes must be a tuple of two different dimensions.\"\n             )\n         axis1, axis2 = self.axes\n-        array_shape[axis1], array_shape[axis2] = array_shape[axis2], array_shape[axis1]\n+        array_shape[axis1], array_shape[axis2] = (\n+            array_shape[axis2],\n+            array_shape[axis1],\n+        )\n         return KerasTensor(shape=array_shape, dtype=array.dtype)\n \n \n@@ -45,13 +49,15 @@ class Rot90(Operation):\n def rot90(array, k=1, axes=(0, 1)):\n     \"\"\"Rotate an array by 90 degrees in the plane specified by axes.\n \n-    This function rotates an array counterclockwise by 90 degrees `k` times\n-    in the plane specified by `axes`. Supports arrays of two or more dimensions.\n+    This function rotates an array counterclockwise\n+    by 90 degrees `k` times in the plane specified by `axes`.\n+    Supports arrays of two or more dimensions.\n \n     Args:\n         array: Input array to rotate.\n         k: Number of times the array is rotated by 90 degrees.\n-        axes: A tuple of two integers specifying the plane for rotation.\n+        axes: A tuple of two integers specifying the\n+            plane of rotation (defaults to `(0, 1)`).\n \n     Returns:\n         Rotated array.\n\n@@ -24,7 +24,9 @@ class NumPyTestRot90(testing.TestCase):\n         array = np.array([[1, 2], [3, 4]])\n         rotated = knp.rot90(array)\n         expected = np.array([[2, 4], [1, 3]])\n-        assert np.array_equal(rotated, expected), f\"Failed basic 2D test: {rotated}\"\n+        assert np.array_equal(\n+            rotated, expected\n+        ), f\"Failed basic 2D test: {rotated}\"\n \n     def test_multiple_k(self):\n         array = np.array([[1, 2], [3, 4]])\n@@ -48,7 +50,9 @@ class NumPyTestRot90(testing.TestCase):\n         array = np.arange(8).reshape((2, 2, 2))\n         rotated = knp.rot90(array, k=1, axes=(1, 2))\n         expected = np.array([[[1, 3], [0, 2]], [[5, 7], [4, 6]]])\n-        assert np.array_equal(rotated, expected), f\"Failed custom axes test: {rotated}\"\n+        assert np.array_equal(\n+            rotated, expected\n+        ), f\"Failed custom axes test: {rotated}\"\n \n     def test_single_image(self):\n         array = np.random.random((4, 4, 3))\n@@ -68,7 +72,7 @@ class NumPyTestRot90(testing.TestCase):\n             knp.rot90(array, axes=(0, 0))\n         except ValueError as e:\n             assert (\n-                \"Invalid axes: (0, 0). Axes must be a tuple of two different dimensions.\"\n+                \"Invalid axes: (0, 0). Axes must be a tuple of two different\"\n                 in str(e)\n             ), f\"Failed invalid axes test: {e}\"\n         else:\n@@ -79,11 +83,11 @@ class NumPyTestRot90(testing.TestCase):\n         try:\n             knp.rot90(array)\n         except ValueError as e:\n-            assert (\n-                \"Input array must have at least 2 dimensions.\" in str(e)\n+            assert \"Input array must have at least 2 dimensions.\" in str(\n+                e\n             ), f\"Failed invalid rank test: {e}\"\n         else:\n-            raise AssertionError(\"Failed to raise error for invalid input rank\")\n+            raise AssertionError(\"Failed to raise error for invalid input\")\n \n \n class NumpyTwoInputOpsDynamicShapeTest(testing.TestCase):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#78dda1ca3cf7e5acb0a83fca3c218426a638620a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 24 | Lines Deleted: 24 | Files Changed: 4 | Hunks: 9 | Methods Changed: 8 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 48 | Churn Cumulative: 3509 | Contributors (this commit): 15 | Commits (past 90d): 23 | Contributors (cumulative): 23 | DMM Complexity: None\n\nDIFF:\n@@ -242,9 +242,9 @@ class OpenVINOKerasTensor:\n     def __len__(self):\n         ov_output = self.output\n         ov_shape = ov_output.get_partial_shape()\n-        assert (\n-            ov_shape.rank.is_static and ov_shape.rank.get_length() > 0\n-        ), \"rank must be static and greater than zero\"\n+        assert ov_shape.rank.is_static and ov_shape.rank.get_length() > 0, (\n+            \"rank must be static and greater than zero\"\n+        )\n         assert ov_shape[0].is_static, \"the first dimension must be static\"\n         return ov_shape[0].get_length()\n \n@@ -425,11 +425,11 @@ def convert_to_numpy(x):\n             x = x.value\n         else:\n             return x.value.data\n-    assert isinstance(\n-        x, OpenVINOKerasTensor\n-    ), \"unsupported type {} for `convert_to_numpy` in openvino backend\".format(\n+    assert isinstance(x, OpenVINOKerasTensor), (\n+        \"unsupported type {} for `convert_to_numpy` in openvino backend\".format(\n             type(x)\n         )\n+    )\n     try:\n         ov_result = x.output\n         ov_model = Model(results=[ov_result], parameters=[])\n\n@@ -325,9 +325,9 @@ def depthwise_conv(\n     data_format = backend.standardize_data_format(data_format)\n     num_spatial_dims = inputs.get_partial_shape().rank.get_length() - 2\n \n-    assert (\n-        data_format == \"channels_last\"\n-    ), \"`depthwise_conv` is supported only for channels_last data_format\"\n+    assert data_format == \"channels_last\", (\n+        \"`depthwise_conv` is supported only for channels_last data_format\"\n+    )\n \n     strides = _adjust_strides_dilation(strides, num_spatial_dims)\n     dilation_rate = _adjust_strides_dilation(dilation_rate, num_spatial_dims)\n\n@@ -81,9 +81,9 @@ def mean(x, axis=None, keepdims=False):\n \n \n def max(x, axis=None, keepdims=False, initial=None):\n-    assert (\n-        initial is None\n-    ), \"`max` with not None initial is not supported by openvino backend\"\n+    assert initial is None, (\n+        \"`max` with not None initial is not supported by openvino backend\"\n+    )\n     x = get_ov_output(x)\n     reduce_axis = ov_opset.constant(axis, Type.i32).output(0)\n     return OpenVINOKerasTensor(\n@@ -260,9 +260,9 @@ def bincount(x, weights=None, minlength=0, sparse=False):\n \n \n def broadcast_to(x, shape):\n-    assert isinstance(\n-        shape, (tuple, list)\n-    ), \"`broadcast_to` is supported only for tuple and list `shape`\"\n+    assert isinstance(shape, (tuple, list)), (\n+        \"`broadcast_to` is supported only for tuple and list `shape`\"\n+    )\n     target_shape = ov_opset.constant(list(shape), Type.i32).output(0)\n     x = get_ov_output(x)\n     return OpenVINOKerasTensor(ov_opset.broadcast(x, target_shape).output(0))\n\n@@ -24,9 +24,9 @@ class NumPyTestRot90(testing.TestCase):\n         array = np.array([[1, 2], [3, 4]])\n         rotated = knp.rot90(array)\n         expected = np.array([[2, 4], [1, 3]])\n-        assert np.array_equal(\n-            rotated, expected\n-        ), f\"Failed basic 2D test: {rotated}\"\n+        assert np.array_equal(rotated, expected), (\n+            f\"Failed basic 2D test: {rotated}\"\n+        )\n \n     def test_multiple_k(self):\n         array = np.array([[1, 2], [3, 4]])\n@@ -50,9 +50,9 @@ class NumPyTestRot90(testing.TestCase):\n         array = np.arange(8).reshape((2, 2, 2))\n         rotated = knp.rot90(array, k=1, axes=(1, 2))\n         expected = np.array([[[1, 3], [0, 2]], [[5, 7], [4, 6]]])\n-        assert np.array_equal(\n-            rotated, expected\n-        ), f\"Failed custom axes test: {rotated}\"\n+        assert np.array_equal(rotated, expected), (\n+            f\"Failed custom axes test: {rotated}\"\n+        )\n \n     def test_single_image(self):\n         array = np.random.random((4, 4, 3))\n@@ -83,9 +83,9 @@ class NumPyTestRot90(testing.TestCase):\n         try:\n             knp.rot90(array)\n         except ValueError as e:\n-            assert \"Input array must have at least 2 dimensions.\" in str(\n-                e\n-            ), f\"Failed invalid rank test: {e}\"\n+            assert \"Input array must have at least 2 dimensions.\" in str(e), (\n+                f\"Failed invalid rank test: {e}\"\n+            )\n         else:\n             raise AssertionError(\"Failed to raise error for invalid input\")\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
