{"custom_id": "keras#c1ec2aa65b33306d3ae437bf39771416d115861f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 3 | Files Changed: 3 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 62 | Contributors (this commit): 1 | Commits (past 90d): 8 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -386,7 +386,7 @@ class AudioDatasetFromDirectoryTest(testing.TestCase):\n             ValueError, \"`class_names` passed did not match\"\n         ):\n             _ = audio_dataset_utils.audio_dataset_from_directory(\n-                directory, class_names=[\"class_0\", \"class_2\"]\n+                directory, class_names=[\"class_0\", \"wrong_class\"]\n             )\n \n         with self.assertRaisesRegex(ValueError, \"there must be exactly 2\"):\n\n@@ -370,7 +370,7 @@ class ImageDatasetFromDirectoryTest(testing.TestCase):\n             ValueError, \"`class_names` passed did not match\"\n         ):\n             _ = image_dataset_utils.image_dataset_from_directory(\n-                directory, class_names=[\"class_0\", \"class_2\"]\n+                directory, class_names=[\"class_0\", \"wrong_class\"]\n             )\n \n         with self.assertRaisesRegex(ValueError, \"there must be exactly 2\"):\n\n@@ -253,7 +253,7 @@ class TextDatasetFromDirectoryTest(testing.TestCase):\n             ValueError, \"`class_names` passed did not match\"\n         ):\n             _ = text_dataset_utils.text_dataset_from_directory(\n-                directory, class_names=[\"class_0\", \"class_2\"]\n+                directory, class_names=[\"class_0\", \"wrong_class\"]\n             )\n \n         with self.assertRaisesRegex(ValueError, \"there must be exactly 2\"):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#aa02010b6d89b05b43d87fbd62d865c626f3b415", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 511 | Lines Deleted: 402 | Files Changed: 2 | Hunks: 150 | Methods Changed: 24 | Complexity Δ (Sum/Max): 130/130 | Churn Δ: 913 | Churn Cumulative: 2590 | Contributors (this commit): 8 | Commits (past 90d): 10 | Contributors (cumulative): 11 | DMM Complexity: 0.0\n\nDIFF:\n@@ -122,7 +122,7 @@ def np_conv2d_transpose(\n         strides,\n         padding,\n         output_padding,\n-        data_format,\n+        \"channels_last\",\n         dilation_rate,\n     )\n     jax_padding = compute_conv_transpose_padding_args_for_jax(\n\n@@ -80,37 +80,80 @@ class NNOpsDynamicShapeTest(testing.TestCase, parameterized.TestCase):\n         self.assertEqual(knn.log_softmax(x, axis=-1).shape, (None, 2, 3))\n \n     def test_max_pool(self):\n-        x = KerasTensor([None, 8, 3])\n-        self.assertEqual(knn.max_pool(x, 2, 1).shape, (None, 7, 3))\n+        data_format = backend.config.image_data_format()\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 8, 3)\n+        else:\n+            input_shape = (None, 3, 8)\n+        x = KerasTensor(input_shape)\n         self.assertEqual(\n-            knn.max_pool(x, 2, 2, padding=\"same\").shape, (None, 4, 3)\n+            knn.max_pool(x, 2, 1).shape,\n+            (None, 7, 3) if data_format == \"channels_last\" else (None, 3, 7),\n+        )\n+        self.assertEqual(\n+            knn.max_pool(x, 2, 2, padding=\"same\").shape,\n+            (None, 4, 3) if data_format == \"channels_last\" else (None, 3, 4),\n         )\n \n-        x = KerasTensor([None, 8, None, 3])\n-        self.assertEqual(knn.max_pool(x, 2, 1).shape, (None, 7, None, 3))\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 8, None, 3)\n+        else:\n+            input_shape = (None, 3, 8, None)\n+        x = KerasTensor(input_shape)\n         self.assertEqual(\n-            knn.max_pool(x, 2, 2, padding=\"same\").shape, (None, 4, None, 3)\n+            knn.max_pool(x, 2, 1).shape, (None, 7, None, 3)\n+        ) if data_format == \"channels_last\" else (None, 3, 7, None)\n+        self.assertEqual(\n+            knn.max_pool(x, 2, 2, padding=\"same\").shape,\n+            (None, 4, None, 3)\n+            if data_format == \"channels_last\"\n+            else (None, 3, 4, None),\n         )\n         self.assertEqual(\n             knn.max_pool(x, (2, 2), (2, 2), padding=\"same\").shape,\n-            (None, 4, None, 3),\n+            (None, 4, None, 3)\n+            if data_format == \"channels_last\"\n+            else (None, 3, 4, None),\n         )\n \n     def test_average_pool(self):\n-        x = KerasTensor([None, 8, 3])\n-        self.assertEqual(knn.average_pool(x, 2, 1).shape, (None, 7, 3))\n+        data_format = backend.config.image_data_format()\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 8, 3)\n+        else:\n+            input_shape = (None, 3, 8)\n+        x = KerasTensor(input_shape)\n         self.assertEqual(\n-            knn.average_pool(x, 2, 2, padding=\"same\").shape, (None, 4, 3)\n+            knn.average_pool(x, 2, 1).shape,\n+            (None, 7, 3) if data_format == \"channels_last\" else (None, 3, 7),\n+        )\n+        self.assertEqual(\n+            knn.average_pool(x, 2, 2, padding=\"same\").shape,\n+            (None, 4, 3) if data_format == \"channels_last\" else (None, 3, 4),\n         )\n \n-        x = KerasTensor([None, 8, None, 3])\n-        self.assertEqual(knn.average_pool(x, 2, 1).shape, (None, 7, None, 3))\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 8, None, 3)\n+        else:\n+            input_shape = (None, 3, 8, None)\n+        x = KerasTensor(input_shape)\n         self.assertEqual(\n-            knn.average_pool(x, 2, 2, padding=\"same\").shape, (None, 4, None, 3)\n+            knn.average_pool(x, 2, 1).shape,\n+            (None, 7, None, 3)\n+            if data_format == \"channels_last\"\n+            else (None, 3, 7, None),\n+        )\n+        self.assertEqual(\n+            knn.average_pool(x, 2, 2, padding=\"same\").shape,\n+            (None, 4, None, 3)\n+            if data_format == \"channels_last\"\n+            else (None, 3, 4, None),\n         )\n         self.assertEqual(\n             knn.average_pool(x, (2, 2), (2, 2), padding=\"same\").shape,\n-            (None, 4, None, 3),\n+            (None, 4, None, 3)\n+            if data_format == \"channels_last\"\n+            else (None, 3, 4, None),\n         )\n \n     def test_multi_hot(self):\n@@ -127,205 +170,297 @@ class NNOpsDynamicShapeTest(testing.TestCase, parameterized.TestCase):\n         self.assertEqual(backend.standardize_dtype(out.dtype), dtype)\n \n     def test_conv(self):\n+        data_format = backend.config.image_data_format()\n         # Test 1D conv.\n-        inputs_1d = KerasTensor([None, 20, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 20, 3)\n+        else:\n+            input_shape = (None, 3, 20)\n+        inputs_1d = KerasTensor(input_shape)\n         kernel = KerasTensor([4, 3, 2])\n         for padding in [\"valid\", \"VALID\"]:\n             self.assertEqual(\n                 knn.conv(inputs_1d, kernel, 1, padding=padding).shape,\n-                (None, 17, 2),\n+                (None, 17, 2)\n+                if data_format == \"channels_last\"\n+                else (None, 2, 17),\n             )\n         for padding in [\"same\", \"SAME\"]:\n             self.assertEqual(\n                 knn.conv(inputs_1d, kernel, 1, padding=padding).shape,\n-                (None, 20, 2),\n+                (None, 20, 2)\n+                if data_format == \"channels_last\"\n+                else (None, 2, 20),\n             )\n         self.assertEqual(\n             knn.conv(inputs_1d, kernel, (2,), dilation_rate=2).shape,\n-            (None, 7, 2),\n+            (None, 7, 2) if data_format == \"channels_last\" else (None, 2, 7),\n         )\n \n         # Test 2D conv.\n-        inputs_2d = KerasTensor([None, 10, None, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 10, None, 3)\n+        else:\n+            input_shape = (None, 3, 10, None)\n+        inputs_2d = KerasTensor(input_shape)\n         kernel = KerasTensor([2, 2, 3, 2])\n         for padding in [\"valid\", \"VALID\"]:\n             self.assertEqual(\n                 knn.conv(inputs_2d, kernel, 1, padding=padding).shape,\n-                (None, 9, None, 2),\n+                (None, 9, None, 2)\n+                if data_format == \"channels_last\"\n+                else (None, 2, 9, None),\n             )\n         for padding in [\"same\", \"SAME\"]:\n             self.assertEqual(\n                 knn.conv(inputs_2d, kernel, 1, padding=padding).shape,\n-                (None, 10, None, 2),\n+                (None, 10, None, 2)\n+                if data_format == \"channels_last\"\n+                else (None, 2, 10, None),\n             )\n         self.assertEqual(\n             knn.conv(inputs_2d, kernel, (2, 1), dilation_rate=(2, 1)).shape,\n-            (None, 4, None, 2),\n+            (None, 4, None, 2)\n+            if data_format == \"channels_last\"\n+            else (None, 2, 4, None),\n         )\n \n         # Test 2D conv - H, W specified\n-        inputs_2d = KerasTensor([None, 10, 10, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 10, 10, 3)\n+        else:\n+            input_shape = (None, 3, 10, 10)\n+        inputs_2d = KerasTensor(input_shape)\n         kernel = KerasTensor([2, 2, 3, 2])\n         for padding in [\"valid\", \"VALID\"]:\n             self.assertEqual(\n                 knn.conv(inputs_2d, kernel, 1, padding=padding).shape,\n-                (None, 9, 9, 2),\n+                (None, 9, 9, 2)\n+                if data_format == \"channels_last\"\n+                else (None, 2, 9, 9),\n             )\n         for padding in [\"same\", \"SAME\"]:\n             self.assertEqual(\n                 knn.conv(inputs_2d, kernel, 1, padding=padding).shape,\n-                (None, 10, 10, 2),\n+                (None, 10, 10, 2)\n+                if data_format == \"channels_last\"\n+                else (None, 2, 10, 10),\n             )\n         self.assertEqual(\n             knn.conv(inputs_2d, kernel, (2, 1), dilation_rate=(2, 1)).shape,\n-            (None, 4, 9, 2),\n+            (None, 4, 9, 2)\n+            if data_format == \"channels_last\"\n+            else (None, 2, 4, 9),\n         )\n \n         # Test 3D conv.\n-        inputs_3d = KerasTensor([None, 8, None, 8, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 8, None, 8, 3)\n+        else:\n+            input_shape = (None, 3, 8, None, 8)\n+        inputs_3d = KerasTensor(input_shape)\n         kernel = KerasTensor([3, 3, 3, 3, 2])\n         for padding in [\"valid\", \"VALID\"]:\n             self.assertEqual(\n                 knn.conv(inputs_3d, kernel, 1, padding=padding).shape,\n-                (None, 6, None, 6, 2),\n+                (None, 6, None, 6, 2)\n+                if data_format == \"channels_last\"\n+                else (None, 2, 6, None, 6),\n             )\n         for padding in [\"same\", \"SAME\"]:\n             self.assertEqual(\n                 knn.conv(inputs_3d, kernel, (2, 1, 2), padding=padding).shape,\n-                (None, 4, None, 4, 2),\n+                (None, 4, None, 4, 2)\n+                if data_format == \"channels_last\"\n+                else (None, 2, 4, None, 4),\n             )\n         self.assertEqual(\n             knn.conv(\n                 inputs_3d, kernel, 1, padding=\"valid\", dilation_rate=(1, 2, 2)\n             ).shape,\n-            (None, 6, None, 4, 2),\n+            (None, 6, None, 4, 2)\n+            if data_format == \"channels_last\"\n+            else (None, 2, 6, None, 4),\n         )\n \n     def test_depthwise_conv(self):\n+        data_format = backend.config.image_data_format()\n         # Test 1D depthwise conv.\n-        inputs_1d = KerasTensor([None, 20, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 20, 3)\n+        else:\n+            input_shape = (None, 3, 20)\n+        inputs_1d = KerasTensor(input_shape)\n         kernel = KerasTensor([4, 3, 1])\n         for padding in [\"valid\", \"VALID\"]:\n             self.assertEqual(\n                 knn.depthwise_conv(inputs_1d, kernel, 1, padding=padding).shape,\n-                (None, 17, 3),\n+                (None, 17, 3)\n+                if data_format == \"channels_last\"\n+                else (None, 3, 17),\n             )\n         for padding in [\"same\", \"SAME\"]:\n             self.assertEqual(\n                 knn.depthwise_conv(\n                     inputs_1d, kernel, (1,), padding=padding\n                 ).shape,\n-                (None, 20, 3),\n+                (None, 20, 3)\n+                if data_format == \"channels_last\"\n+                else (None, 3, 20),\n             )\n         self.assertEqual(\n             knn.depthwise_conv(inputs_1d, kernel, 2, dilation_rate=2).shape,\n-            (None, 7, 3),\n+            (None, 7, 3) if data_format == \"channels_last\" else (None, 3, 7),\n         )\n \n         # Test 2D depthwise conv.\n-        inputs_2d = KerasTensor([None, 10, 10, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 10, 10, 3)\n+        else:\n+            input_shape = (None, 3, 10, 10)\n+        inputs_2d = KerasTensor(input_shape)\n         kernel = KerasTensor([2, 2, 3, 1])\n         for padding in [\"valid\", \"VALID\"]:\n             self.assertEqual(\n                 knn.depthwise_conv(inputs_2d, kernel, 1, padding=padding).shape,\n-                (None, 9, 9, 3),\n+                (None, 9, 9, 3)\n+                if data_format == \"channels_last\"\n+                else (None, 3, 9, 9),\n             )\n         for padding in [\"same\", \"SAME\"]:\n             self.assertEqual(\n                 knn.depthwise_conv(\n                     inputs_2d, kernel, (1, 2), padding=padding\n                 ).shape,\n-                (None, 10, 5, 3),\n+                (None, 10, 5, 3)\n+                if data_format == \"channels_last\"\n+                else (None, 3, 10, 5),\n             )\n         self.assertEqual(\n             knn.depthwise_conv(inputs_2d, kernel, 2, dilation_rate=2).shape,\n-            (None, 4, 4, 3),\n+            (None, 4, 4, 3)\n+            if data_format == \"channels_last\"\n+            else (None, 3, 4, 4),\n         )\n         self.assertEqual(\n             knn.depthwise_conv(\n                 inputs_2d, kernel, 2, dilation_rate=(2, 1)\n             ).shape,\n-            (None, 4, 5, 3),\n+            (None, 4, 5, 3)\n+            if data_format == \"channels_last\"\n+            else (None, 3, 4, 5),\n         )\n \n     def test_separable_conv(self):\n+        data_format = backend.config.image_data_format()\n         # Test 1D separable conv.\n-        inputs_1d = KerasTensor([None, 20, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 20, 3)\n+        else:\n+            input_shape = (None, 3, 20)\n+        inputs_1d = KerasTensor(input_shape)\n         kernel = KerasTensor([4, 3, 2])\n         pointwise_kernel = KerasTensor([1, 6, 5])\n         self.assertEqual(\n             knn.separable_conv(\n                 inputs_1d, kernel, pointwise_kernel, 1, padding=\"valid\"\n             ).shape,\n-            (None, 17, 5),\n+            (None, 17, 5) if data_format == \"channels_last\" else (None, 5, 17),\n         )\n         self.assertEqual(\n             knn.separable_conv(\n                 inputs_1d, kernel, pointwise_kernel, 1, padding=\"same\"\n             ).shape,\n-            (None, 20, 5),\n+            (None, 20, 5) if data_format == \"channels_last\" else (None, 5, 20),\n         )\n         self.assertEqual(\n             knn.separable_conv(\n                 inputs_1d, kernel, pointwise_kernel, 2, dilation_rate=2\n             ).shape,\n-            (None, 7, 5),\n+            (None, 7, 5) if data_format == \"channels_last\" else (None, 5, 7),\n         )\n \n         # Test 2D separable conv.\n-        inputs_2d = KerasTensor([None, 10, 10, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 10, 10, 3)\n+        else:\n+            input_shape = (None, 3, 10, 10)\n+        inputs_2d = KerasTensor(input_shape)\n         kernel = KerasTensor([2, 2, 3, 2])\n         pointwise_kernel = KerasTensor([1, 1, 6, 5])\n         self.assertEqual(\n             knn.separable_conv(\n                 inputs_2d, kernel, pointwise_kernel, 1, padding=\"valid\"\n             ).shape,\n-            (None, 9, 9, 5),\n+            (None, 9, 9, 5)\n+            if data_format == \"channels_last\"\n+            else (None, 5, 9, 9),\n         )\n         self.assertEqual(\n             knn.separable_conv(\n                 inputs_2d, kernel, pointwise_kernel, (1, 2), padding=\"same\"\n             ).shape,\n-            (None, 10, 5, 5),\n+            (None, 10, 5, 5)\n+            if data_format == \"channels_last\"\n+            else (None, 5, 10, 5),\n         )\n         self.assertEqual(\n             knn.separable_conv(\n                 inputs_2d, kernel, pointwise_kernel, 2, dilation_rate=(2, 1)\n             ).shape,\n-            (None, 4, 5, 5),\n+            (None, 4, 5, 5)\n+            if data_format == \"channels_last\"\n+            else (None, 5, 4, 5),\n         )\n \n     def test_conv_transpose(self):\n-        inputs_1d = KerasTensor([None, 4, 3])\n+        data_format = backend.config.image_data_format()\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 4, 3)\n+        else:\n+            input_shape = (None, 3, 4)\n+        inputs_1d = KerasTensor(input_shape)\n         kernel = KerasTensor([2, 5, 3])\n         self.assertEqual(\n-            knn.conv_transpose(inputs_1d, kernel, 2).shape, (None, 8, 5)\n+            knn.conv_transpose(inputs_1d, kernel, 2).shape,\n+            (None, 8, 5) if data_format == \"channels_last\" else (None, 5, 8),\n         )\n         self.assertEqual(\n             knn.conv_transpose(inputs_1d, kernel, 2, padding=\"same\").shape,\n-            (None, 8, 5),\n+            (None, 8, 5) if data_format == \"channels_last\" else (None, 5, 8),\n         )\n         self.assertEqual(\n             knn.conv_transpose(\n                 inputs_1d, kernel, 5, padding=\"valid\", output_padding=4\n             ).shape,\n-            (None, 21, 5),\n+            (None, 21, 5) if data_format == \"channels_last\" else (None, 5, 21),\n         )\n \n-        inputs_2d = KerasTensor([None, 4, 4, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (None, 4, 4, 3)\n+        else:\n+            input_shape = (None, 3, 4, 4)\n+        inputs_2d = KerasTensor(input_shape)\n         kernel = KerasTensor([2, 2, 5, 3])\n         self.assertEqual(\n-            knn.conv_transpose(inputs_2d, kernel, 2).shape, (None, 8, 8, 5)\n+            knn.conv_transpose(inputs_2d, kernel, 2).shape,\n+            (None, 8, 8, 5)\n+            if data_format == \"channels_last\"\n+            else (None, 5, 8, 8),\n         )\n         self.assertEqual(\n             knn.conv_transpose(inputs_2d, kernel, (2, 2), padding=\"same\").shape,\n-            (None, 8, 8, 5),\n+            (None, 8, 8, 5)\n+            if data_format == \"channels_last\"\n+            else (None, 5, 8, 8),\n         )\n         self.assertEqual(\n             knn.conv_transpose(\n                 inputs_2d, kernel, (5, 5), padding=\"valid\", output_padding=4\n             ).shape,\n-            (None, 21, 21, 5),\n+            (None, 21, 21, 5)\n+            if data_format == \"channels_last\"\n+            else (None, 5, 21, 21),\n         )\n \n     def test_one_hot(self):\n@@ -418,199 +553,293 @@ class NNOpsStaticShapeTest(testing.TestCase):\n         self.assertEqual(knn.log_softmax(x, axis=-1).shape, (1, 2, 3))\n \n     def test_max_pool(self):\n-        x = KerasTensor([1, 8, 3])\n-        self.assertEqual(knn.max_pool(x, 2, 1).shape, (1, 7, 3))\n-        self.assertEqual(knn.max_pool(x, 2, 2, padding=\"same\").shape, (1, 4, 3))\n-\n-        x = KerasTensor([1, 8, 8, 3])\n-        self.assertEqual(knn.max_pool(x, 2, 1).shape, (1, 7, 7, 3))\n+        data_format = backend.config.image_data_format()\n+        if data_format == \"channels_last\":\n+            input_shape = (1, 8, 3)\n+        else:\n+            input_shape = (1, 3, 8)\n+        x = KerasTensor(input_shape)\n         self.assertEqual(\n-            knn.max_pool(x, 2, 2, padding=\"same\").shape, (1, 4, 4, 3)\n+            knn.max_pool(x, 2, 1).shape,\n+            (1, 7, 3) if data_format == \"channels_last\" else (1, 3, 7),\n         )\n         self.assertEqual(\n-            knn.max_pool(x, (2, 2), (2, 2), padding=\"same\").shape, (1, 4, 4, 3)\n+            knn.max_pool(x, 2, 2, padding=\"same\").shape,\n+            (1, 4, 3) if data_format == \"channels_last\" else (1, 3, 4),\n+        )\n+\n+        if data_format == \"channels_last\":\n+            input_shape = (1, 8, 8, 3)\n+        else:\n+            input_shape = (1, 3, 8, 8)\n+        x = KerasTensor(input_shape)\n+        self.assertEqual(\n+            knn.max_pool(x, 2, 1).shape,\n+            (1, 7, 7, 3) if data_format == \"channels_last\" else (1, 3, 7, 7),\n+        )\n+        self.assertEqual(\n+            knn.max_pool(x, 2, 2, padding=\"same\").shape,\n+            (1, 4, 4, 3) if data_format == \"channels_last\" else (1, 3, 4, 4),\n+        )\n+        self.assertEqual(\n+            knn.max_pool(x, (2, 2), (2, 2), padding=\"same\").shape,\n+            (1, 4, 4, 3) if data_format == \"channels_last\" else (1, 3, 4, 4),\n         )\n \n     def test_average_pool(self):\n-        x = KerasTensor([1, 8, 3])\n-        self.assertEqual(knn.average_pool(x, 2, 1).shape, (1, 7, 3))\n+        data_format = backend.config.image_data_format()\n+        if data_format == \"channels_last\":\n+            input_shape = (1, 8, 3)\n+        else:\n+            input_shape = (1, 3, 8)\n+        x = KerasTensor(input_shape)\n         self.assertEqual(\n-            knn.average_pool(x, 2, 2, padding=\"same\").shape, (1, 4, 3)\n+            knn.average_pool(x, 2, 1).shape,\n+            (1, 7, 3) if data_format == \"channels_last\" else (1, 3, 7),\n+        )\n+        self.assertEqual(\n+            knn.average_pool(x, 2, 2, padding=\"same\").shape,\n+            (1, 4, 3) if data_format == \"channels_last\" else (1, 3, 4),\n         )\n \n-        x = KerasTensor([1, 8, 8, 3])\n-        self.assertEqual(knn.average_pool(x, 2, 1).shape, (1, 7, 7, 3))\n+        if data_format == \"channels_last\":\n+            input_shape = (1, 8, 8, 3)\n+        else:\n+            input_shape = (1, 3, 8, 8)\n+        x = KerasTensor(input_shape)\n         self.assertEqual(\n-            knn.average_pool(x, 2, 2, padding=\"same\").shape, (1, 4, 4, 3)\n+            knn.average_pool(x, 2, 1).shape,\n+            (1, 7, 7, 3) if data_format == \"channels_last\" else (1, 3, 7, 7),\n+        )\n+        self.assertEqual(\n+            knn.average_pool(x, 2, 2, padding=\"same\").shape,\n+            (1, 4, 4, 3) if data_format == \"channels_last\" else (1, 3, 4, 4),\n         )\n         self.assertEqual(\n             knn.average_pool(x, (2, 2), (2, 2), padding=\"same\").shape,\n-            (1, 4, 4, 3),\n+            (1, 4, 4, 3) if data_format == \"channels_last\" else (1, 3, 4, 4),\n         )\n \n     def test_conv(self):\n+        data_format = backend.config.image_data_format()\n         # Test 1D conv.\n-        inputs_1d = KerasTensor([2, 20, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 20, 3)\n+        else:\n+            input_shape = (2, 3, 20)\n+        inputs_1d = KerasTensor(input_shape)\n         kernel = KerasTensor([4, 3, 2])\n         self.assertEqual(\n-            knn.conv(inputs_1d, kernel, 1, padding=\"valid\").shape, (2, 17, 2)\n+            knn.conv(inputs_1d, kernel, 1, padding=\"valid\").shape,\n+            (2, 17, 2) if data_format == \"channels_last\" else (2, 2, 17),\n         )\n         self.assertEqual(\n-            knn.conv(inputs_1d, kernel, 1, padding=\"same\").shape, (2, 20, 2)\n+            knn.conv(inputs_1d, kernel, 1, padding=\"same\").shape,\n+            (2, 20, 2) if data_format == \"channels_last\" else (2, 2, 20),\n         )\n         self.assertEqual(\n-            knn.conv(inputs_1d, kernel, (2,), dilation_rate=2).shape, (2, 7, 2)\n+            knn.conv(inputs_1d, kernel, (2,), dilation_rate=2).shape,\n+            (2, 7, 2) if data_format == \"channels_last\" else (2, 2, 7),\n         )\n \n         # Test 2D conv.\n-        inputs_2d = KerasTensor([2, 10, 10, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 10, 10, 3)\n+        else:\n+            input_shape = (2, 3, 10, 10)\n+        inputs_2d = KerasTensor(input_shape)\n         kernel = KerasTensor([2, 2, 3, 2])\n         self.assertEqual(\n-            knn.conv(inputs_2d, kernel, 1, padding=\"valid\").shape, (2, 9, 9, 2)\n+            knn.conv(inputs_2d, kernel, 1, padding=\"valid\").shape,\n+            (2, 9, 9, 2) if data_format == \"channels_last\" else (2, 2, 9, 9),\n         )\n         self.assertEqual(\n-            knn.conv(inputs_2d, kernel, 1, padding=\"same\").shape, (2, 10, 10, 2)\n+            knn.conv(inputs_2d, kernel, 1, padding=\"same\").shape,\n+            (2, 10, 10, 2)\n+            if data_format == \"channels_last\"\n+            else (2, 2, 10, 10),\n         )\n         self.assertEqual(\n             knn.conv(inputs_2d, kernel, (2, 1), dilation_rate=(2, 1)).shape,\n-            (2, 4, 9, 2),\n+            (2, 4, 9, 2) if data_format == \"channels_last\" else (2, 2, 4, 9),\n         )\n \n         # Test 3D conv.\n-        inputs_3d = KerasTensor([2, 8, 8, 8, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 8, 8, 8, 3)\n+        else:\n+            input_shape = (2, 3, 8, 8, 8)\n+        inputs_3d = KerasTensor(input_shape)\n         kernel = KerasTensor([3, 3, 3, 3, 2])\n         self.assertEqual(\n             knn.conv(inputs_3d, kernel, 1, padding=\"valid\").shape,\n-            (2, 6, 6, 6, 2),\n+            (2, 6, 6, 6, 2)\n+            if data_format == \"channels_last\"\n+            else (2, 2, 6, 6, 6),\n         )\n         self.assertEqual(\n             knn.conv(inputs_3d, kernel, (2, 1, 2), padding=\"same\").shape,\n-            (2, 4, 8, 4, 2),\n+            (2, 4, 8, 4, 2)\n+            if data_format == \"channels_last\"\n+            else (2, 2, 4, 8, 4),\n         )\n         self.assertEqual(\n             knn.conv(\n                 inputs_3d, kernel, 1, padding=\"valid\", dilation_rate=(1, 2, 2)\n             ).shape,\n-            (2, 6, 4, 4, 2),\n+            (2, 6, 4, 4, 2)\n+            if data_format == \"channels_last\"\n+            else (2, 2, 6, 4, 4),\n         )\n \n     def test_depthwise_conv(self):\n+        data_format = backend.config.image_data_format()\n         # Test 1D depthwise conv.\n-        inputs_1d = KerasTensor([2, 20, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 20, 3)\n+        else:\n+            input_shape = (2, 3, 20)\n+        inputs_1d = KerasTensor(input_shape)\n         kernel = KerasTensor([4, 3, 1])\n         self.assertEqual(\n             knn.depthwise_conv(inputs_1d, kernel, 1, padding=\"valid\").shape,\n-            (2, 17, 3),\n+            (2, 17, 3) if data_format == \"channels_last\" else (2, 3, 17),\n         )\n         self.assertEqual(\n             knn.depthwise_conv(inputs_1d, kernel, (1,), padding=\"same\").shape,\n-            (2, 20, 3),\n+            (2, 20, 3) if data_format == \"channels_last\" else (2, 3, 20),\n         )\n         self.assertEqual(\n             knn.depthwise_conv(inputs_1d, kernel, 2, dilation_rate=2).shape,\n-            (2, 7, 3),\n+            (2, 7, 3) if data_format == \"channels_last\" else (2, 3, 7),\n         )\n \n         # Test 2D depthwise conv.\n-        inputs_2d = KerasTensor([2, 10, 10, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 10, 10, 3)\n+        else:\n+            input_shape = (2, 3, 10, 10)\n+        inputs_2d = KerasTensor(input_shape)\n         kernel = KerasTensor([2, 2, 3, 1])\n         self.assertEqual(\n             knn.depthwise_conv(inputs_2d, kernel, 1, padding=\"valid\").shape,\n-            (2, 9, 9, 3),\n+            (2, 9, 9, 3) if data_format == \"channels_last\" else (2, 3, 9, 9),\n         )\n         self.assertEqual(\n             knn.depthwise_conv(inputs_2d, kernel, (1, 2), padding=\"same\").shape,\n-            (2, 10, 5, 3),\n+            (2, 10, 5, 3) if data_format == \"channels_last\" else (2, 3, 10, 5),\n         )\n         self.assertEqual(\n             knn.depthwise_conv(inputs_2d, kernel, 2, dilation_rate=2).shape,\n-            (2, 4, 4, 3),\n+            (2, 4, 4, 3) if data_format == \"channels_last\" else (2, 3, 4, 4),\n         )\n         self.assertEqual(\n             knn.depthwise_conv(\n                 inputs_2d, kernel, 2, dilation_rate=(2, 1)\n             ).shape,\n-            (2, 4, 5, 3),\n+            (2, 4, 5, 3) if data_format == \"channels_last\" else (2, 3, 4, 5),\n         )\n \n     def test_separable_conv(self):\n-        # Test 1D separable conv.\n-        inputs_1d = KerasTensor([2, 20, 3])\n+        data_format = backend.config.image_data_format()\n+        # Test 1D max pooling.\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 20, 3)\n+        else:\n+            input_shape = (2, 3, 20)\n+        inputs_1d = KerasTensor(input_shape)\n         kernel = KerasTensor([4, 3, 2])\n         pointwise_kernel = KerasTensor([1, 6, 5])\n         self.assertEqual(\n             knn.separable_conv(\n                 inputs_1d, kernel, pointwise_kernel, 1, padding=\"valid\"\n             ).shape,\n-            (2, 17, 5),\n+            (2, 17, 5) if data_format == \"channels_last\" else (2, 5, 17),\n         )\n         self.assertEqual(\n             knn.separable_conv(\n                 inputs_1d, kernel, pointwise_kernel, 1, padding=\"same\"\n             ).shape,\n-            (2, 20, 5),\n+            (2, 20, 5) if data_format == \"channels_last\" else (2, 5, 20),\n         )\n         self.assertEqual(\n             knn.separable_conv(\n                 inputs_1d, kernel, pointwise_kernel, 2, dilation_rate=2\n             ).shape,\n-            (2, 7, 5),\n+            (2, 7, 5) if data_format == \"channels_last\" else (2, 5, 7),\n         )\n \n         # Test 2D separable conv.\n-        inputs_2d = KerasTensor([2, 10, 10, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 10, 10, 3)\n+        else:\n+            input_shape = (2, 3, 10, 10)\n+        inputs_2d = KerasTensor(input_shape)\n         kernel = KerasTensor([2, 2, 3, 2])\n         pointwise_kernel = KerasTensor([1, 1, 6, 5])\n         self.assertEqual(\n             knn.separable_conv(\n                 inputs_2d, kernel, pointwise_kernel, 1, padding=\"valid\"\n             ).shape,\n-            (2, 9, 9, 5),\n+            (2, 9, 9, 5) if data_format == \"channels_last\" else (2, 5, 9, 9),\n         )\n         self.assertEqual(\n             knn.separable_conv(\n                 inputs_2d, kernel, pointwise_kernel, (1, 2), padding=\"same\"\n             ).shape,\n-            (2, 10, 5, 5),\n+            (2, 10, 5, 5) if data_format == \"channels_last\" else (2, 5, 10, 5),\n         )\n         self.assertEqual(\n             knn.separable_conv(\n                 inputs_2d, kernel, pointwise_kernel, 2, dilation_rate=(2, 1)\n             ).shape,\n-            (2, 4, 5, 5),\n+            (2, 4, 5, 5) if data_format == \"channels_last\" else (2, 5, 4, 5),\n         )\n \n     def test_conv_transpose(self):\n-        inputs_1d = KerasTensor([2, 4, 3])\n+        data_format = backend.config.image_data_format()\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 4, 3)\n+        else:\n+            input_shape = (2, 3, 4)\n+        inputs_1d = KerasTensor(input_shape)\n         kernel = KerasTensor([2, 5, 3])\n         self.assertEqual(\n-            knn.conv_transpose(inputs_1d, kernel, 2).shape, (2, 8, 5)\n+            knn.conv_transpose(inputs_1d, kernel, 2).shape,\n+            (2, 8, 5) if data_format == \"channels_last\" else (2, 5, 8),\n         )\n         self.assertEqual(\n             knn.conv_transpose(inputs_1d, kernel, 2, padding=\"same\").shape,\n-            (2, 8, 5),\n+            (2, 8, 5) if data_format == \"channels_last\" else (2, 5, 8),\n         )\n         self.assertEqual(\n             knn.conv_transpose(\n                 inputs_1d, kernel, 5, padding=\"valid\", output_padding=4\n             ).shape,\n-            (2, 21, 5),\n+            (2, 21, 5) if data_format == \"channels_last\" else (2, 5, 21),\n         )\n \n-        inputs_2d = KerasTensor([2, 4, 4, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 4, 4, 3)\n+        else:\n+            input_shape = (2, 3, 4, 4)\n+        inputs_2d = KerasTensor(input_shape)\n         kernel = KerasTensor([2, 2, 5, 3])\n         self.assertEqual(\n-            knn.conv_transpose(inputs_2d, kernel, 2).shape, (2, 8, 8, 5)\n+            knn.conv_transpose(inputs_2d, kernel, 2).shape,\n+            (2, 8, 8, 5) if data_format == \"channels_last\" else (2, 5, 8, 8),\n         )\n         self.assertEqual(\n             knn.conv_transpose(inputs_2d, kernel, (2, 2), padding=\"same\").shape,\n-            (2, 8, 8, 5),\n+            (2, 8, 8, 5) if data_format == \"channels_last\" else (2, 5, 8, 8),\n         )\n         self.assertEqual(\n             knn.conv_transpose(\n                 inputs_2d, kernel, (5, 5), padding=\"valid\", output_padding=4\n             ).shape,\n-            (2, 21, 21, 5),\n+            (2, 21, 21, 5)\n+            if data_format == \"channels_last\"\n+            else (2, 5, 21, 21),\n         )\n \n     def test_batched_and_unbatched_inputs_multi_hot(self):\n@@ -793,43 +1022,59 @@ class NNOpsCorrectnessTest(testing.TestCase, parameterized.TestCase):\n         )\n \n     def test_max_pool(self):\n+        data_format = backend.config.image_data_format()\n         # Test 1D max pooling.\n-        x = np.arange(120, dtype=float).reshape([2, 20, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 20, 3)\n+        else:\n+            input_shape = (2, 3, 20)\n+        x = np.arange(120, dtype=float).reshape(input_shape)\n         self.assertAllClose(\n             knn.max_pool(x, 2, 1, padding=\"valid\"),\n-            np_maxpool1d(x, 2, 1, padding=\"valid\", data_format=\"channels_last\"),\n+            np_maxpool1d(x, 2, 1, padding=\"valid\", data_format=data_format),\n         )\n         self.assertAllClose(\n             knn.max_pool(x, 2, 2, padding=\"same\"),\n-            np_maxpool1d(x, 2, 2, padding=\"same\", data_format=\"channels_last\"),\n+            np_maxpool1d(x, 2, 2, padding=\"same\", data_format=data_format),\n         )\n \n         # Test 2D max pooling.\n-        x = np.arange(540, dtype=float).reshape([2, 10, 9, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 10, 9, 3)\n+        else:\n+            input_shape = (2, 3, 10, 9)\n+        x = np.arange(540, dtype=float).reshape(input_shape)\n         self.assertAllClose(\n             knn.max_pool(x, 2, 1, padding=\"valid\"),\n-            np_maxpool2d(x, 2, 1, padding=\"valid\", data_format=\"channels_last\"),\n+            np_maxpool2d(x, 2, 1, padding=\"valid\", data_format=data_format),\n         )\n         self.assertAllClose(\n             knn.max_pool(x, 2, (2, 1), padding=\"same\"),\n-            np_maxpool2d(\n-                x, 2, (2, 1), padding=\"same\", data_format=\"channels_last\"\n-            ),\n+            np_maxpool2d(x, 2, (2, 1), padding=\"same\", data_format=data_format),\n         )\n \n     def test_average_pool_valid_padding(self):\n+        data_format = backend.config.image_data_format()\n         # Test 1D max pooling.\n-        x = np.arange(120, dtype=float).reshape([2, 20, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 20, 3)\n+        else:\n+            input_shape = (2, 3, 20)\n+        x = np.arange(120, dtype=float).reshape(input_shape)\n         self.assertAllClose(\n             knn.average_pool(x, 2, 1, padding=\"valid\"),\n-            np_avgpool1d(x, 2, 1, padding=\"valid\", data_format=\"channels_last\"),\n+            np_avgpool1d(x, 2, 1, padding=\"valid\", data_format=data_format),\n         )\n \n         # Test 2D max pooling.\n-        x = np.arange(540, dtype=float).reshape([2, 10, 9, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 10, 9, 3)\n+        else:\n+            input_shape = (2, 3, 10, 9)\n+        x = np.arange(540, dtype=float).reshape(input_shape)\n         self.assertAllClose(\n             knn.average_pool(x, 2, 1, padding=\"valid\"),\n-            np_avgpool2d(x, 2, 1, padding=\"valid\", data_format=\"channels_last\"),\n+            np_avgpool2d(x, 2, 1, padding=\"valid\", data_format=data_format),\n         )\n \n     @pytest.mark.skipif(\n@@ -837,20 +1082,28 @@ class NNOpsCorrectnessTest(testing.TestCase, parameterized.TestCase):\n         reason=\"Torch outputs differently from TF when using `same` padding.\",\n     )\n     def test_average_pool_same_padding(self):\n+        data_format = backend.config.image_data_format()\n         # Test 1D max pooling.\n-        x = np.arange(120, dtype=float).reshape([2, 20, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 20, 3)\n+        else:\n+            input_shape = (2, 3, 20)\n+        x = np.arange(120, dtype=float).reshape(input_shape)\n+\n         self.assertAllClose(\n             knn.average_pool(x, 2, 2, padding=\"same\"),\n-            np_avgpool1d(x, 2, 2, padding=\"same\", data_format=\"channels_last\"),\n+            np_avgpool1d(x, 2, 2, padding=\"same\", data_format=data_format),\n         )\n \n         # Test 2D max pooling.\n-        x = np.arange(540, dtype=float).reshape([2, 10, 9, 3])\n+        if data_format == \"channels_last\":\n+            input_shape = (2, 10, 9, 3)\n+        else:\n+            input_shape = (2, 3, 10, 9)\n+        x = np.arange(540, dtype=float).reshape(input_shape)\n         self.assertAllClose(\n             knn.average_pool(x, 2, (2, 1), padding=\"same\"),\n-            np_avgpool2d(\n-                x, 2, (2, 1), padding=\"same\", data_format=\"channels_last\"\n-            ),\n+            np_avgpool2d(x, 2, (2, 1), padding=\"same\", data_format=data_format),\n         )\n \n     @parameterized.product(\n@@ -862,7 +1115,11 @@ class NNOpsCorrectnessTest(testing.TestCase, parameterized.TestCase):\n         if strides > 1 and dilation_rate > 1:\n             pytest.skip(\"Unsupported configuration\")\n \n-        inputs_1d = np.arange(120, dtype=float).reshape([2, 20, 3])\n+        if backend.config.image_data_format() == \"channels_last\":\n+            input_shape = (2, 20, 3)\n+        else:\n+            input_shape = (2, 3, 20)\n+        inputs_1d = np.arange(120, dtype=float).reshape(input_shape)\n         kernel = np.arange(24, dtype=float).reshape([4, 3, 2])\n \n         outputs = knn.conv(\n@@ -878,371 +1135,222 @@ class NNOpsCorrectnessTest(testing.TestCase, parameterized.TestCase):\n             bias_weights=np.zeros((2,)),\n             strides=strides,\n             padding=padding.lower(),\n-            data_format=\"channels_last\",\n+            data_format=backend.config.image_data_format(),\n             dilation_rate=dilation_rate,\n             groups=1,\n         )\n         self.assertAllClose(outputs, expected)\n \n-    def test_conv_2d(self):\n-        inputs_2d = np.arange(600, dtype=float).reshape([2, 10, 10, 3])\n+    @parameterized.product(strides=(1, 2, (1, 2)), padding=(\"valid\", \"same\"))\n+    def test_conv_2d(self, strides, padding):\n+        if backend.config.image_data_format() == \"channels_last\":\n+            input_shape = (2, 10, 10, 3)\n+        else:\n+            input_shape = (2, 3, 10, 10)\n+        inputs_2d = np.arange(600, dtype=float).reshape(input_shape)\n         kernel = np.arange(24, dtype=float).reshape([2, 2, 3, 2])\n \n-        outputs = knn.conv(inputs_2d, kernel, 1, padding=\"valid\")\n+        outputs = knn.conv(inputs_2d, kernel, strides, padding=padding)\n         expected = np_conv2d(\n             inputs_2d,\n             kernel,\n             bias_weights=np.zeros((2,)),\n-            strides=1,\n-            padding=\"valid\",\n-            data_format=\"channels_last\",\n+            strides=strides,\n+            padding=padding,\n+            data_format=backend.config.image_data_format(),\n             dilation_rate=1,\n             groups=1,\n         )\n         self.assertAllClose(outputs, expected)\n \n-        outputs = knn.conv(inputs_2d, kernel, (1, 2), padding=\"valid\")\n-        expected = np_conv2d(\n-            inputs_2d,\n-            kernel,\n-            bias_weights=np.zeros((2,)),\n-            strides=(1, 2),\n-            padding=\"valid\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n-            groups=1,\n-        )\n-        self.assertAllClose(outputs, expected)\n-\n-        outputs = knn.conv(inputs_2d, kernel, (1, 2), padding=\"same\")\n-        expected = np_conv2d(\n-            inputs_2d,\n-            kernel,\n-            bias_weights=np.zeros((2,)),\n-            strides=(1, 2),\n-            padding=\"same\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n-            groups=1,\n-        )\n-        self.assertAllClose(outputs, expected)\n-\n-        outputs = knn.conv(inputs_2d, kernel, 2, padding=\"same\")\n-        expected = np_conv2d(\n-            inputs_2d,\n-            kernel,\n-            bias_weights=np.zeros((2,)),\n-            strides=2,\n-            padding=\"same\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n-            groups=1,\n-        )\n-        self.assertAllClose(outputs, expected)\n-\n-        # Test group > 1.\n-        inputs_2d = np.ones([2, 10, 10, 4])\n+    @parameterized.product(strides=(1, 2), dilation_rate=(1, (2, 1)))\n+    def test_conv_2d_group_2(self, strides, dilation_rate):\n+        if (\n+            backend.backend() == \"tensorflow\"\n+            and strides == 2\n+            and dilation_rate == (2, 1)\n+        ):\n+            # This case is not supported by the TF backend.\n+            return\n+        if backend.config.image_data_format() == \"channels_last\":\n+            input_shape = (2, 10, 10, 4)\n+        else:\n+            input_shape = (2, 4, 10, 10)\n+        inputs_2d = np.ones(input_shape)\n         kernel = np.ones([2, 2, 2, 6])\n         outputs = knn.conv(\n-            inputs_2d, kernel, 2, padding=\"same\", dilation_rate=1\n+            inputs_2d,\n+            kernel,\n+            strides,\n+            padding=\"same\",\n+            dilation_rate=dilation_rate,\n         )\n         expected = np_conv2d(\n             inputs_2d,\n             kernel,\n             bias_weights=np.zeros((6,)),\n-            strides=2,\n+            strides=strides,\n             padding=\"same\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n+            data_format=backend.config.image_data_format(),\n+            dilation_rate=dilation_rate,\n             groups=1,\n         )\n         self.assertAllClose(outputs, expected)\n \n-        outputs = knn.conv(\n-            inputs_2d,\n-            kernel,\n-            1,\n-            padding=\"same\",\n-            dilation_rate=(2, 1),\n-        )\n-        expected = np_conv2d(\n-            inputs_2d,\n-            kernel,\n-            bias_weights=np.zeros((6,)),\n-            strides=1,\n-            padding=\"same\",\n-            data_format=\"channels_last\",\n-            dilation_rate=(2, 1),\n-            groups=1,\n-        )\n-        self.assertAllClose(outputs, expected)\n-\n-    def test_conv_3d(self):\n-        inputs_3d = np.arange(3072, dtype=float).reshape([2, 8, 8, 8, 3])\n+    @parameterized.product(strides=(1, (1, 1, 1), 2), padding=(\"valid\", \"same\"))\n+    def test_conv_3d(self, strides, padding):\n+        if backend.config.image_data_format() == \"channels_last\":\n+            input_shape = (2, 8, 8, 8, 3)\n+        else:\n+            input_shape = (2, 3, 8, 8, 8)\n+        inputs_3d = np.arange(3072, dtype=float).reshape(input_shape)\n         kernel = np.arange(162, dtype=float).reshape([3, 3, 3, 3, 2])\n \n-        outputs = knn.conv(inputs_3d, kernel, 1, padding=\"valid\")\n+        outputs = knn.conv(inputs_3d, kernel, strides, padding=padding)\n         expected = np_conv3d(\n             inputs_3d,\n             kernel,\n             bias_weights=np.zeros((2,)),\n-            strides=(1, 1, 1),\n-            padding=\"valid\",\n-            data_format=\"channels_last\",\n+            strides=strides,\n+            padding=padding,\n+            data_format=backend.config.image_data_format(),\n             dilation_rate=1,\n             groups=1,\n         )\n         self.assertAllClose(outputs, expected, rtol=1e-5, atol=1e-5)\n \n-        outputs = knn.conv(\n-            inputs_3d,\n-            kernel,\n-            (1, 1, 1),\n-            padding=\"valid\",\n-            dilation_rate=(1, 1, 1),\n+    @parameterized.product(\n+        strides=(1, (1, 1), (2, 2)),\n+        padding=(\"valid\", \"same\"),\n+        dilation_rate=(1, (2, 2)),\n     )\n-        expected = np_conv3d(\n-            inputs_3d,\n-            kernel,\n-            bias_weights=np.zeros((2,)),\n-            strides=(1, 1, 1),\n-            padding=\"valid\",\n-            data_format=\"channels_last\",\n-            dilation_rate=(1, 1, 1),\n-            groups=1,\n-        )\n-        self.assertAllClose(outputs, expected, rtol=1e-5, atol=1e-5)\n-\n-        outputs = knn.conv(inputs_3d, kernel, 2, padding=\"valid\")\n-        expected = np_conv3d(\n-            inputs_3d,\n-            kernel,\n-            bias_weights=np.zeros((2,)),\n-            strides=2,\n-            padding=\"valid\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n-            groups=1,\n-        )\n-        self.assertAllClose(outputs, expected, rtol=1e-5, atol=1e-5)\n-\n-        outputs = knn.conv(inputs_3d, kernel, 2, padding=\"same\")\n-        expected = np_conv3d(\n-            inputs_3d,\n-            kernel,\n-            bias_weights=np.zeros((2,)),\n-            strides=2,\n-            padding=\"same\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n-            groups=1,\n-        )\n-        self.assertAllClose(outputs, expected, rtol=1e-5, atol=1e-5)\n-\n-    def test_depthwise_conv_2d(self):\n-        inputs_2d = np.arange(600, dtype=float).reshape([2, 10, 10, 3])\n+    def test_depthwise_conv_2d(self, strides, padding, dilation_rate):\n+        if (\n+            backend.backend() == \"tensorflow\"\n+            and strides == (2, 2)\n+            and dilation_rate == (2, 2)\n+        ):\n+            # This case is not supported by the TF backend.\n+            return\n+        print(strides, padding, dilation_rate)\n+        if backend.config.image_data_format() == \"channels_last\":\n+            input_shape = (2, 10, 10, 3)\n+        else:\n+            input_shape = (2, 3, 10, 10)\n+        inputs_2d = np.arange(600, dtype=float).reshape(input_shape)\n         kernel = np.arange(24, dtype=float).reshape([2, 2, 3, 2])\n \n-        outputs = knn.depthwise_conv(inputs_2d, kernel, 1, padding=\"valid\")\n-        expected = np_depthwise_conv2d(\n-            inputs_2d,\n-            kernel,\n-            bias_weights=np.zeros((6,)),\n-            strides=1,\n-            padding=\"valid\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n-        )\n-        self.assertAllClose(outputs, expected)\n-\n-        outputs = knn.depthwise_conv(inputs_2d, kernel, (1, 1), padding=\"valid\")\n-        expected = np_depthwise_conv2d(\n-            inputs_2d,\n-            kernel,\n-            bias_weights=np.zeros((6,)),\n-            strides=(1, 1),\n-            padding=\"valid\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n-        )\n-        self.assertAllClose(outputs, expected)\n-\n-        outputs = knn.depthwise_conv(inputs_2d, kernel, (2, 2), padding=\"same\")\n-        expected = np_depthwise_conv2d(\n-            inputs_2d,\n-            kernel,\n-            bias_weights=np.zeros((6,)),\n-            strides=(2, 2),\n-            padding=\"same\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n-        )\n-        self.assertAllClose(outputs, expected)\n-\n         outputs = knn.depthwise_conv(\n-            inputs_2d, kernel, 1, padding=\"same\", dilation_rate=(2, 2)\n+            inputs_2d,\n+            kernel,\n+            strides,\n+            padding=padding,\n+            dilation_rate=dilation_rate,\n         )\n         expected = np_depthwise_conv2d(\n             inputs_2d,\n             kernel,\n             bias_weights=np.zeros((6,)),\n-            strides=1,\n-            padding=\"same\",\n-            data_format=\"channels_last\",\n-            dilation_rate=(2, 2),\n+            strides=strides,\n+            padding=padding,\n+            data_format=backend.config.image_data_format(),\n+            dilation_rate=dilation_rate,\n         )\n         self.assertAllClose(outputs, expected)\n \n-    def test_separable_conv_2d(self):\n+    @parameterized.product(\n+        strides=(1, 2),\n+        padding=(\"valid\", \"same\"),\n+        dilation_rate=(1, (2, 2)),\n+    )\n+    def test_separable_conv_2d(self, strides, padding, dilation_rate):\n+        if (\n+            backend.backend() == \"tensorflow\"\n+            and strides == 2\n+            and dilation_rate == (2, 2)\n+        ):\n+            # This case is not supported by the TF backend.\n+            return\n         # Test 2D conv.\n-        inputs_2d = np.arange(600, dtype=float).reshape([2, 10, 10, 3])\n+        if backend.config.image_data_format() == \"channels_last\":\n+            input_shape = (2, 10, 10, 3)\n+        else:\n+            input_shape = (2, 3, 10, 10)\n+        inputs_2d = np.arange(600, dtype=float).reshape(input_shape)\n         depthwise_kernel = np.arange(24, dtype=float).reshape([2, 2, 3, 2])\n         pointwise_kernel = np.arange(72, dtype=float).reshape([1, 1, 6, 12])\n \n         outputs = knn.separable_conv(\n-            inputs_2d, depthwise_kernel, pointwise_kernel, 1, padding=\"valid\"\n+            inputs_2d,\n+            depthwise_kernel,\n+            pointwise_kernel,\n+            strides,\n+            padding=padding,\n+            dilation_rate=dilation_rate,\n         )\n         # Depthwise followed by pointwise conv\n         expected_depthwise = np_depthwise_conv2d(\n             inputs_2d,\n             depthwise_kernel,\n             np.zeros(6),\n-            strides=1,\n-            padding=\"valid\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n+            strides=strides,\n+            padding=padding,\n+            data_format=backend.config.image_data_format(),\n+            dilation_rate=dilation_rate,\n         )\n         expected = np_conv2d(\n             expected_depthwise,\n             pointwise_kernel,\n             np.zeros(6 * 12),\n             strides=1,\n-            padding=\"valid\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n+            padding=padding,\n+            data_format=backend.config.image_data_format(),\n+            dilation_rate=dilation_rate,\n             groups=1,\n         )\n         self.assertAllClose(outputs, expected)\n \n-        outputs = knn.separable_conv(\n-            inputs_2d,\n-            depthwise_kernel,\n-            pointwise_kernel,\n-            (1, 1),\n-            padding=\"valid\",\n-        )\n-        self.assertAllClose(outputs, expected)\n-\n-        outputs = knn.separable_conv(\n-            inputs_2d, depthwise_kernel, pointwise_kernel, 2, padding=\"same\"\n-        )\n-        # Depthwise followed by pointwise conv\n-        expected_depthwise = np_depthwise_conv2d(\n-            inputs_2d,\n-            depthwise_kernel,\n-            np.zeros(6),\n-            strides=2,\n-            padding=\"same\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n-        )\n-        expected = np_conv2d(\n-            expected_depthwise,\n-            pointwise_kernel,\n-            np.zeros(6 * 12),\n-            strides=1,\n-            padding=\"same\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n-            groups=1,\n-        )\n-        self.assertAllClose(outputs, expected)\n-\n-        outputs = knn.separable_conv(\n-            inputs_2d,\n-            depthwise_kernel,\n-            pointwise_kernel,\n-            1,\n-            padding=\"same\",\n-            dilation_rate=(2, 2),\n-        )\n-        # Depthwise followed by pointwise conv\n-        expected_depthwise = np_depthwise_conv2d(\n-            inputs_2d,\n-            depthwise_kernel,\n-            np.zeros(6),\n-            strides=1,\n-            padding=\"same\",\n-            data_format=\"channels_last\",\n-            dilation_rate=(2, 2),\n-        )\n-        expected = np_conv2d(\n-            expected_depthwise,\n-            pointwise_kernel,\n-            np.zeros(6 * 12),\n-            strides=1,\n-            padding=\"same\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n-            groups=1,\n-        )\n-        self.assertAllClose(outputs, expected)\n-\n-    def test_conv_transpose_1d(self):\n-        inputs_1d = np.arange(24, dtype=float).reshape([2, 4, 3])\n+    @parameterized.product(padding=(\"valid\", \"same\"))\n+    def test_conv_transpose_1d(self, padding):\n+        if backend.config.image_data_format() == \"channels_last\":\n+            input_shape = (2, 4, 3)\n+        else:\n+            input_shape = (2, 3, 4)\n+        inputs_1d = np.arange(24, dtype=float).reshape(input_shape)\n         kernel = np.arange(30, dtype=float).reshape([2, 5, 3])\n-        outputs = knn.conv_transpose(inputs_1d, kernel, 2, padding=\"valid\")\n+        outputs = knn.conv_transpose(inputs_1d, kernel, 2, padding=padding)\n         expected = np_conv1d_transpose(\n             inputs_1d,\n             kernel,\n             bias_weights=np.zeros(5),\n             strides=2,\n             output_padding=None,\n-            padding=\"valid\",\n-            data_format=\"channels_last\",\n+            padding=padding,\n+            data_format=backend.config.image_data_format(),\n             dilation_rate=1,\n         )\n         self.assertAllClose(outputs, expected)\n \n-        outputs = knn.conv_transpose(inputs_1d, kernel, 2, padding=\"same\")\n-        expected = np_conv1d_transpose(\n-            inputs_1d,\n-            kernel,\n-            bias_weights=np.zeros(5),\n-            strides=2,\n-            output_padding=None,\n-            padding=\"same\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n-        )\n-        self.assertAllClose(outputs, expected)\n-\n-    def test_conv_transpose_2d(self):\n-        inputs_2d = np.arange(96, dtype=float).reshape([2, 4, 4, 3])\n+    @parameterized.product(strides=(2, (2, 2)), padding=(\"valid\", \"same\"))\n+    def test_conv_transpose_2d(self, strides, padding):\n+        if backend.config.image_data_format() == \"channels_last\":\n+            input_shape = (2, 4, 4, 3)\n+        else:\n+            input_shape = (2, 3, 4, 4)\n+        inputs_2d = np.arange(96, dtype=float).reshape(input_shape)\n         kernel = np.arange(60, dtype=float).reshape([2, 2, 5, 3])\n \n-        outputs = knn.conv_transpose(inputs_2d, kernel, (2, 2), padding=\"valid\")\n-        expected = np_conv2d_transpose(\n-            inputs_2d,\n-            kernel,\n-            bias_weights=np.zeros(5),\n-            strides=(2, 2),\n-            output_padding=None,\n-            padding=\"valid\",\n-            data_format=\"channels_last\",\n-            dilation_rate=1,\n+        outputs = knn.conv_transpose(\n+            inputs_2d, kernel, strides, padding=padding\n         )\n-        self.assertAllClose(outputs, expected)\n-\n-        outputs = knn.conv_transpose(inputs_2d, kernel, 2, padding=\"same\")\n         expected = np_conv2d_transpose(\n             inputs_2d,\n             kernel,\n             bias_weights=np.zeros(5),\n-            strides=2,\n+            strides=strides,\n             output_padding=None,\n-            padding=\"same\",\n-            data_format=\"channels_last\",\n+            padding=padding,\n+            data_format=backend.config.image_data_format(),\n             dilation_rate=1,\n         )\n         self.assertAllClose(outputs, expected)\n@@ -1498,3 +1606,4 @@ class NNOpsCorrectnessTest(testing.TestCase, parameterized.TestCase):\n             mean, variance = strategy.run(test_on_moments, args=(inputs,))\n             self.assertEqual(mean.values[0], 4.5)\n             self.assertEqual(variance.values[0], 8.75)\n+            self.assertEqual(variance.values[0], 8.75)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
