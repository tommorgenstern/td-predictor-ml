{"custom_id": "fastapi#280fe73c0398c912a38ffbf96e3897fc9cb78a5f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 26 | Lines Deleted: 401 | Files Changed: 5 | Hunks: 13 | Methods Changed: 40 | Complexity Δ (Sum/Max): -26/1 | Churn Δ: 427 | Churn Cumulative: 973 | Contributors (this commit): 7 | Commits (past 90d): 5 | Contributors (cumulative): 15 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,18 +1,37 @@\n+import importlib\n+\n import pytest\n+from fastapi import FastAPI\n from fastapi.testclient import TestClient\n from fastapi.websockets import WebSocketDisconnect\n \n-from docs_src.websockets.tutorial002 import app\n+from ...utils import needs_py39, needs_py310\n \n \n-def test_main():\n+@pytest.fixture(\n+    name=\"app\",\n+    params=[\n+        \"tutorial002\",\n+        pytest.param(\"tutorial002_py310\", marks=needs_py310),\n+        \"tutorial002_an\",\n+        pytest.param(\"tutorial002_an_py39\", marks=needs_py39),\n+        pytest.param(\"tutorial002_an_py310\", marks=needs_py310),\n+    ],\n+)\n+def get_app(request: pytest.FixtureRequest):\n+    mod = importlib.import_module(f\"docs_src.websockets.{request.param}\")\n+\n+    return mod.app\n+\n+\n+def test_main(app: FastAPI):\n     client = TestClient(app)\n     response = client.get(\"/\")\n     assert response.status_code == 200, response.text\n     assert b\"<!DOCTYPE html>\" in response.content\n \n \n-def test_websocket_with_cookie():\n+def test_websocket_with_cookie(app: FastAPI):\n     client = TestClient(app, cookies={\"session\": \"fakesession\"})\n     with pytest.raises(WebSocketDisconnect):\n         with client.websocket_connect(\"/items/foo/ws\") as websocket:\n@@ -30,7 +49,7 @@ def test_websocket_with_cookie():\n             assert data == f\"Message text was: {message}, for item ID: foo\"\n \n \n-def test_websocket_with_header():\n+def test_websocket_with_header(app: FastAPI):\n     client = TestClient(app)\n     with pytest.raises(WebSocketDisconnect):\n         with client.websocket_connect(\"/items/bar/ws?token=some-token\") as websocket:\n@@ -48,7 +67,7 @@ def test_websocket_with_header():\n             assert data == f\"Message text was: {message}, for item ID: bar\"\n \n \n-def test_websocket_with_header_and_query():\n+def test_websocket_with_header_and_query(app: FastAPI):\n     client = TestClient(app)\n     with pytest.raises(WebSocketDisconnect):\n         with client.websocket_connect(\"/items/2/ws?q=3&token=some-token\") as websocket:\n@@ -70,7 +89,7 @@ def test_websocket_with_header_and_query():\n             assert data == f\"Message text was: {message}, for item ID: 2\"\n \n \n-def test_websocket_no_credentials():\n+def test_websocket_no_credentials(app: FastAPI):\n     client = TestClient(app)\n     with pytest.raises(WebSocketDisconnect):\n         with client.websocket_connect(\"/items/foo/ws\"):\n@@ -79,7 +98,7 @@ def test_websocket_no_credentials():\n             )  # pragma: no cover\n \n \n-def test_websocket_invalid_data():\n+def test_websocket_invalid_data(app: FastAPI):\n     client = TestClient(app)\n     with pytest.raises(WebSocketDisconnect):\n         with client.websocket_connect(\"/items/foo/ws?q=bar&token=some-token\"):\n\n@@ -1,88 +0,0 @@\n-import pytest\n-from fastapi.testclient import TestClient\n-from fastapi.websockets import WebSocketDisconnect\n-\n-from docs_src.websockets.tutorial002_an import app\n-\n-\n-def test_main():\n-    client = TestClient(app)\n-    response = client.get(\"/\")\n-    assert response.status_code == 200, response.text\n-    assert b\"<!DOCTYPE html>\" in response.content\n-\n-\n-def test_websocket_with_cookie():\n-    client = TestClient(app, cookies={\"session\": \"fakesession\"})\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/foo/ws\") as websocket:\n-            message = \"Message one\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: fakesession\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: foo\"\n-            message = \"Message two\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: fakesession\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: foo\"\n-\n-\n-def test_websocket_with_header():\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/bar/ws?token=some-token\") as websocket:\n-            message = \"Message one\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: bar\"\n-            message = \"Message two\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: bar\"\n-\n-\n-def test_websocket_with_header_and_query():\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/2/ws?q=3&token=some-token\") as websocket:\n-            message = \"Message one\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == \"Query parameter q is: 3\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: 2\"\n-            message = \"Message two\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == \"Query parameter q is: 3\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: 2\"\n-\n-\n-def test_websocket_no_credentials():\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/foo/ws\"):\n-            pytest.fail(\n-                \"did not raise WebSocketDisconnect on __enter__\"\n-            )  # pragma: no cover\n-\n-\n-def test_websocket_invalid_data():\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/foo/ws?q=bar&token=some-token\"):\n-            pytest.fail(\n-                \"did not raise WebSocketDisconnect on __enter__\"\n-            )  # pragma: no cover\n\n@@ -1,102 +0,0 @@\n-import pytest\n-from fastapi import FastAPI\n-from fastapi.testclient import TestClient\n-from fastapi.websockets import WebSocketDisconnect\n-\n-from ...utils import needs_py310\n-\n-\n-@pytest.fixture(name=\"app\")\n-def get_app():\n-    from docs_src.websockets.tutorial002_an_py310 import app\n-\n-    return app\n-\n-\n-@needs_py310\n-def test_main(app: FastAPI):\n-    client = TestClient(app)\n-    response = client.get(\"/\")\n-    assert response.status_code == 200, response.text\n-    assert b\"<!DOCTYPE html>\" in response.content\n-\n-\n-@needs_py310\n-def test_websocket_with_cookie(app: FastAPI):\n-    client = TestClient(app, cookies={\"session\": \"fakesession\"})\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/foo/ws\") as websocket:\n-            message = \"Message one\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: fakesession\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: foo\"\n-            message = \"Message two\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: fakesession\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: foo\"\n-\n-\n-@needs_py310\n-def test_websocket_with_header(app: FastAPI):\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/bar/ws?token=some-token\") as websocket:\n-            message = \"Message one\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: bar\"\n-            message = \"Message two\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: bar\"\n-\n-\n-@needs_py310\n-def test_websocket_with_header_and_query(app: FastAPI):\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/2/ws?q=3&token=some-token\") as websocket:\n-            message = \"Message one\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == \"Query parameter q is: 3\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: 2\"\n-            message = \"Message two\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == \"Query parameter q is: 3\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: 2\"\n-\n-\n-@needs_py310\n-def test_websocket_no_credentials(app: FastAPI):\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/foo/ws\"):\n-            pytest.fail(\n-                \"did not raise WebSocketDisconnect on __enter__\"\n-            )  # pragma: no cover\n-\n-\n-@needs_py310\n-def test_websocket_invalid_data(app: FastAPI):\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/foo/ws?q=bar&token=some-token\"):\n-            pytest.fail(\n-                \"did not raise WebSocketDisconnect on __enter__\"\n-            )  # pragma: no cover\n\n@@ -1,102 +0,0 @@\n-import pytest\n-from fastapi import FastAPI\n-from fastapi.testclient import TestClient\n-from fastapi.websockets import WebSocketDisconnect\n-\n-from ...utils import needs_py39\n-\n-\n-@pytest.fixture(name=\"app\")\n-def get_app():\n-    from docs_src.websockets.tutorial002_an_py39 import app\n-\n-    return app\n-\n-\n-@needs_py39\n-def test_main(app: FastAPI):\n-    client = TestClient(app)\n-    response = client.get(\"/\")\n-    assert response.status_code == 200, response.text\n-    assert b\"<!DOCTYPE html>\" in response.content\n-\n-\n-@needs_py39\n-def test_websocket_with_cookie(app: FastAPI):\n-    client = TestClient(app, cookies={\"session\": \"fakesession\"})\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/foo/ws\") as websocket:\n-            message = \"Message one\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: fakesession\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: foo\"\n-            message = \"Message two\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: fakesession\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: foo\"\n-\n-\n-@needs_py39\n-def test_websocket_with_header(app: FastAPI):\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/bar/ws?token=some-token\") as websocket:\n-            message = \"Message one\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: bar\"\n-            message = \"Message two\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: bar\"\n-\n-\n-@needs_py39\n-def test_websocket_with_header_and_query(app: FastAPI):\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/2/ws?q=3&token=some-token\") as websocket:\n-            message = \"Message one\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == \"Query parameter q is: 3\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: 2\"\n-            message = \"Message two\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == \"Query parameter q is: 3\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: 2\"\n-\n-\n-@needs_py39\n-def test_websocket_no_credentials(app: FastAPI):\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/foo/ws\"):\n-            pytest.fail(\n-                \"did not raise WebSocketDisconnect on __enter__\"\n-            )  # pragma: no cover\n-\n-\n-@needs_py39\n-def test_websocket_invalid_data(app: FastAPI):\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/foo/ws?q=bar&token=some-token\"):\n-            pytest.fail(\n-                \"did not raise WebSocketDisconnect on __enter__\"\n-            )  # pragma: no cover\n\n@@ -1,102 +0,0 @@\n-import pytest\n-from fastapi import FastAPI\n-from fastapi.testclient import TestClient\n-from fastapi.websockets import WebSocketDisconnect\n-\n-from ...utils import needs_py310\n-\n-\n-@pytest.fixture(name=\"app\")\n-def get_app():\n-    from docs_src.websockets.tutorial002_py310 import app\n-\n-    return app\n-\n-\n-@needs_py310\n-def test_main(app: FastAPI):\n-    client = TestClient(app)\n-    response = client.get(\"/\")\n-    assert response.status_code == 200, response.text\n-    assert b\"<!DOCTYPE html>\" in response.content\n-\n-\n-@needs_py310\n-def test_websocket_with_cookie(app: FastAPI):\n-    client = TestClient(app, cookies={\"session\": \"fakesession\"})\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/foo/ws\") as websocket:\n-            message = \"Message one\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: fakesession\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: foo\"\n-            message = \"Message two\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: fakesession\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: foo\"\n-\n-\n-@needs_py310\n-def test_websocket_with_header(app: FastAPI):\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/bar/ws?token=some-token\") as websocket:\n-            message = \"Message one\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: bar\"\n-            message = \"Message two\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: bar\"\n-\n-\n-@needs_py310\n-def test_websocket_with_header_and_query(app: FastAPI):\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/2/ws?q=3&token=some-token\") as websocket:\n-            message = \"Message one\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == \"Query parameter q is: 3\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: 2\"\n-            message = \"Message two\"\n-            websocket.send_text(message)\n-            data = websocket.receive_text()\n-            assert data == \"Session cookie or query token value is: some-token\"\n-            data = websocket.receive_text()\n-            assert data == \"Query parameter q is: 3\"\n-            data = websocket.receive_text()\n-            assert data == f\"Message text was: {message}, for item ID: 2\"\n-\n-\n-@needs_py310\n-def test_websocket_no_credentials(app: FastAPI):\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/foo/ws\"):\n-            pytest.fail(\n-                \"did not raise WebSocketDisconnect on __enter__\"\n-            )  # pragma: no cover\n-\n-\n-@needs_py310\n-def test_websocket_invalid_data(app: FastAPI):\n-    client = TestClient(app)\n-    with pytest.raises(WebSocketDisconnect):\n-        with client.websocket_connect(\"/items/foo/ws?q=bar&token=some-token\"):\n-            pytest.fail(\n-                \"did not raise WebSocketDisconnect on __enter__\"\n-            )  # pragma: no cover\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#fe513719ea98abade167d8a89e92f600d9d8f0e5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 513 | Contributors (this commit): 2 | Commits (past 90d): 4 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -1,6 +1,6 @@\n \"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n \n-__version__ = \"0.115.6\"\n+__version__ = \"0.115.7\"\n \n from starlette import status as status\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#ff68d0894a7191f7dd107bd449e6bd40b3af1735", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 401 | Lines Deleted: 682 | Files Changed: 2 | Hunks: 2 | Methods Changed: 18 | Complexity Δ (Sum/Max): -15/33 | Churn Δ: 1083 | Churn Cumulative: 2271 | Contributors (this commit): 2 | Commits (past 90d): 2 | Contributors (cumulative): 3 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,682 +0,0 @@\n-import logging\n-import subprocess\n-import sys\n-from collections import Counter, defaultdict\n-from datetime import datetime, timedelta, timezone\n-from pathlib import Path\n-from typing import Any, Container, DefaultDict, Dict, List, Set, Union\n-\n-import httpx\n-import yaml\n-from github import Github\n-from pydantic import BaseModel, SecretStr\n-from pydantic_settings import BaseSettings\n-\n-github_graphql_url = \"https://api.github.com/graphql\"\n-questions_category_id = \"MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMyMDAxNDM0\"\n-\n-discussions_query = \"\"\"\n-query Q($after: String, $category_id: ID) {\n-  repository(name: \"fastapi\", owner: \"fastapi\") {\n-    discussions(first: 100, after: $after, categoryId: $category_id) {\n-      edges {\n-        cursor\n-        node {\n-          number\n-          author {\n-            login\n-            avatarUrl\n-            url\n-          }\n-          title\n-          createdAt\n-          comments(first: 100) {\n-            nodes {\n-              createdAt\n-              author {\n-                login\n-                avatarUrl\n-                url\n-              }\n-              isAnswer\n-              replies(first: 10) {\n-                nodes {\n-                  createdAt\n-                  author {\n-                    login\n-                    avatarUrl\n-                    url\n-                  }\n-                }\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\"\"\"\n-\n-\n-prs_query = \"\"\"\n-query Q($after: String) {\n-  repository(name: \"fastapi\", owner: \"fastapi\") {\n-    pullRequests(first: 100, after: $after) {\n-      edges {\n-        cursor\n-        node {\n-          number\n-          labels(first: 100) {\n-            nodes {\n-              name\n-            }\n-          }\n-          author {\n-            login\n-            avatarUrl\n-            url\n-          }\n-          title\n-          createdAt\n-          state\n-          comments(first: 100) {\n-            nodes {\n-              createdAt\n-              author {\n-                login\n-                avatarUrl\n-                url\n-              }\n-            }\n-          }\n-          reviews(first:100) {\n-            nodes {\n-              author {\n-                login\n-                avatarUrl\n-                url\n-              }\n-              state\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\"\"\"\n-\n-sponsors_query = \"\"\"\n-query Q($after: String) {\n-  user(login: \"fastapi\") {\n-    sponsorshipsAsMaintainer(first: 100, after: $after) {\n-      edges {\n-        cursor\n-        node {\n-          sponsorEntity {\n-            ... on Organization {\n-              login\n-              avatarUrl\n-              url\n-            }\n-            ... on User {\n-              login\n-              avatarUrl\n-              url\n-            }\n-          }\n-          tier {\n-            name\n-            monthlyPriceInDollars\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\"\"\"\n-\n-\n-class Author(BaseModel):\n-    login: str\n-    avatarUrl: str\n-    url: str\n-\n-\n-# Discussions\n-\n-\n-class CommentsNode(BaseModel):\n-    createdAt: datetime\n-    author: Union[Author, None] = None\n-\n-\n-class Replies(BaseModel):\n-    nodes: List[CommentsNode]\n-\n-\n-class DiscussionsCommentsNode(CommentsNode):\n-    replies: Replies\n-\n-\n-class Comments(BaseModel):\n-    nodes: List[CommentsNode]\n-\n-\n-class DiscussionsComments(BaseModel):\n-    nodes: List[DiscussionsCommentsNode]\n-\n-\n-class DiscussionsNode(BaseModel):\n-    number: int\n-    author: Union[Author, None] = None\n-    title: str\n-    createdAt: datetime\n-    comments: DiscussionsComments\n-\n-\n-class DiscussionsEdge(BaseModel):\n-    cursor: str\n-    node: DiscussionsNode\n-\n-\n-class Discussions(BaseModel):\n-    edges: List[DiscussionsEdge]\n-\n-\n-class DiscussionsRepository(BaseModel):\n-    discussions: Discussions\n-\n-\n-class DiscussionsResponseData(BaseModel):\n-    repository: DiscussionsRepository\n-\n-\n-class DiscussionsResponse(BaseModel):\n-    data: DiscussionsResponseData\n-\n-\n-# PRs\n-\n-\n-class LabelNode(BaseModel):\n-    name: str\n-\n-\n-class Labels(BaseModel):\n-    nodes: List[LabelNode]\n-\n-\n-class ReviewNode(BaseModel):\n-    author: Union[Author, None] = None\n-    state: str\n-\n-\n-class Reviews(BaseModel):\n-    nodes: List[ReviewNode]\n-\n-\n-class PullRequestNode(BaseModel):\n-    number: int\n-    labels: Labels\n-    author: Union[Author, None] = None\n-    title: str\n-    createdAt: datetime\n-    state: str\n-    comments: Comments\n-    reviews: Reviews\n-\n-\n-class PullRequestEdge(BaseModel):\n-    cursor: str\n-    node: PullRequestNode\n-\n-\n-class PullRequests(BaseModel):\n-    edges: List[PullRequestEdge]\n-\n-\n-class PRsRepository(BaseModel):\n-    pullRequests: PullRequests\n-\n-\n-class PRsResponseData(BaseModel):\n-    repository: PRsRepository\n-\n-\n-class PRsResponse(BaseModel):\n-    data: PRsResponseData\n-\n-\n-# Sponsors\n-\n-\n-class SponsorEntity(BaseModel):\n-    login: str\n-    avatarUrl: str\n-    url: str\n-\n-\n-class Tier(BaseModel):\n-    name: str\n-    monthlyPriceInDollars: float\n-\n-\n-class SponsorshipAsMaintainerNode(BaseModel):\n-    sponsorEntity: SponsorEntity\n-    tier: Tier\n-\n-\n-class SponsorshipAsMaintainerEdge(BaseModel):\n-    cursor: str\n-    node: SponsorshipAsMaintainerNode\n-\n-\n-class SponsorshipAsMaintainer(BaseModel):\n-    edges: List[SponsorshipAsMaintainerEdge]\n-\n-\n-class SponsorsUser(BaseModel):\n-    sponsorshipsAsMaintainer: SponsorshipAsMaintainer\n-\n-\n-class SponsorsResponseData(BaseModel):\n-    user: SponsorsUser\n-\n-\n-class SponsorsResponse(BaseModel):\n-    data: SponsorsResponseData\n-\n-\n-class Settings(BaseSettings):\n-    input_token: SecretStr\n-    github_repository: str\n-    httpx_timeout: int = 30\n-\n-\n-def get_graphql_response(\n-    *,\n-    settings: Settings,\n-    query: str,\n-    after: Union[str, None] = None,\n-    category_id: Union[str, None] = None,\n-) -> Dict[str, Any]:\n-    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n-    # category_id is only used by one query, but GraphQL allows unused variables, so\n-    # keep it here for simplicity\n-    variables = {\"after\": after, \"category_id\": category_id}\n-    response = httpx.post(\n-        github_graphql_url,\n-        headers=headers,\n-        timeout=settings.httpx_timeout,\n-        json={\"query\": query, \"variables\": variables, \"operationName\": \"Q\"},\n-    )\n-    if response.status_code != 200:\n-        logging.error(\n-            f\"Response was not 200, after: {after}, category_id: {category_id}\"\n-        )\n-        logging.error(response.text)\n-        raise RuntimeError(response.text)\n-    data = response.json()\n-    if \"errors\" in data:\n-        logging.error(f\"Errors in response, after: {after}, category_id: {category_id}\")\n-        logging.error(data[\"errors\"])\n-        logging.error(response.text)\n-        raise RuntimeError(response.text)\n-    return data\n-\n-\n-def get_graphql_question_discussion_edges(\n-    *,\n-    settings: Settings,\n-    after: Union[str, None] = None,\n-):\n-    data = get_graphql_response(\n-        settings=settings,\n-        query=discussions_query,\n-        after=after,\n-        category_id=questions_category_id,\n-    )\n-    graphql_response = DiscussionsResponse.model_validate(data)\n-    return graphql_response.data.repository.discussions.edges\n-\n-\n-def get_graphql_pr_edges(*, settings: Settings, after: Union[str, None] = None):\n-    data = get_graphql_response(settings=settings, query=prs_query, after=after)\n-    graphql_response = PRsResponse.model_validate(data)\n-    return graphql_response.data.repository.pullRequests.edges\n-\n-\n-def get_graphql_sponsor_edges(*, settings: Settings, after: Union[str, None] = None):\n-    data = get_graphql_response(settings=settings, query=sponsors_query, after=after)\n-    graphql_response = SponsorsResponse.model_validate(data)\n-    return graphql_response.data.user.sponsorshipsAsMaintainer.edges\n-\n-\n-class DiscussionExpertsResults(BaseModel):\n-    commenters: Counter\n-    last_month_commenters: Counter\n-    three_months_commenters: Counter\n-    six_months_commenters: Counter\n-    one_year_commenters: Counter\n-    authors: Dict[str, Author]\n-\n-\n-def get_discussion_nodes(settings: Settings) -> List[DiscussionsNode]:\n-    discussion_nodes: List[DiscussionsNode] = []\n-    discussion_edges = get_graphql_question_discussion_edges(settings=settings)\n-\n-    while discussion_edges:\n-        for discussion_edge in discussion_edges:\n-            discussion_nodes.append(discussion_edge.node)\n-        last_edge = discussion_edges[-1]\n-        discussion_edges = get_graphql_question_discussion_edges(\n-            settings=settings, after=last_edge.cursor\n-        )\n-    return discussion_nodes\n-\n-\n-def get_discussions_experts(\n-    discussion_nodes: List[DiscussionsNode],\n-) -> DiscussionExpertsResults:\n-    commenters = Counter()\n-    last_month_commenters = Counter()\n-    three_months_commenters = Counter()\n-    six_months_commenters = Counter()\n-    one_year_commenters = Counter()\n-    authors: Dict[str, Author] = {}\n-\n-    now = datetime.now(tz=timezone.utc)\n-    one_month_ago = now - timedelta(days=30)\n-    three_months_ago = now - timedelta(days=90)\n-    six_months_ago = now - timedelta(days=180)\n-    one_year_ago = now - timedelta(days=365)\n-\n-    for discussion in discussion_nodes:\n-        discussion_author_name = None\n-        if discussion.author:\n-            authors[discussion.author.login] = discussion.author\n-            discussion_author_name = discussion.author.login\n-        discussion_commentors: dict[str, datetime] = {}\n-        for comment in discussion.comments.nodes:\n-            if comment.author:\n-                authors[comment.author.login] = comment.author\n-                if comment.author.login != discussion_author_name:\n-                    author_time = discussion_commentors.get(\n-                        comment.author.login, comment.createdAt\n-                    )\n-                    discussion_commentors[comment.author.login] = max(\n-                        author_time, comment.createdAt\n-                    )\n-            for reply in comment.replies.nodes:\n-                if reply.author:\n-                    authors[reply.author.login] = reply.author\n-                    if reply.author.login != discussion_author_name:\n-                        author_time = discussion_commentors.get(\n-                            reply.author.login, reply.createdAt\n-                        )\n-                        discussion_commentors[reply.author.login] = max(\n-                            author_time, reply.createdAt\n-                        )\n-        for author_name, author_time in discussion_commentors.items():\n-            commenters[author_name] += 1\n-            if author_time > one_month_ago:\n-                last_month_commenters[author_name] += 1\n-            if author_time > three_months_ago:\n-                three_months_commenters[author_name] += 1\n-            if author_time > six_months_ago:\n-                six_months_commenters[author_name] += 1\n-            if author_time > one_year_ago:\n-                one_year_commenters[author_name] += 1\n-    discussion_experts_results = DiscussionExpertsResults(\n-        authors=authors,\n-        commenters=commenters,\n-        last_month_commenters=last_month_commenters,\n-        three_months_commenters=three_months_commenters,\n-        six_months_commenters=six_months_commenters,\n-        one_year_commenters=one_year_commenters,\n-    )\n-    return discussion_experts_results\n-\n-\n-def get_pr_nodes(settings: Settings) -> List[PullRequestNode]:\n-    pr_nodes: List[PullRequestNode] = []\n-    pr_edges = get_graphql_pr_edges(settings=settings)\n-\n-    while pr_edges:\n-        for edge in pr_edges:\n-            pr_nodes.append(edge.node)\n-        last_edge = pr_edges[-1]\n-        pr_edges = get_graphql_pr_edges(settings=settings, after=last_edge.cursor)\n-    return pr_nodes\n-\n-\n-class ContributorsResults(BaseModel):\n-    contributors: Counter\n-    commenters: Counter\n-    reviewers: Counter\n-    translation_reviewers: Counter\n-    authors: Dict[str, Author]\n-\n-\n-def get_contributors(pr_nodes: List[PullRequestNode]) -> ContributorsResults:\n-    contributors = Counter()\n-    commenters = Counter()\n-    reviewers = Counter()\n-    translation_reviewers = Counter()\n-    authors: Dict[str, Author] = {}\n-\n-    for pr in pr_nodes:\n-        author_name = None\n-        if pr.author:\n-            authors[pr.author.login] = pr.author\n-            author_name = pr.author.login\n-        pr_commentors: Set[str] = set()\n-        pr_reviewers: Set[str] = set()\n-        for comment in pr.comments.nodes:\n-            if comment.author:\n-                authors[comment.author.login] = comment.author\n-                if comment.author.login == author_name:\n-                    continue\n-                pr_commentors.add(comment.author.login)\n-        for author_name in pr_commentors:\n-            commenters[author_name] += 1\n-        for review in pr.reviews.nodes:\n-            if review.author:\n-                authors[review.author.login] = review.author\n-                pr_reviewers.add(review.author.login)\n-                for label in pr.labels.nodes:\n-                    if label.name == \"lang-all\":\n-                        translation_reviewers[review.author.login] += 1\n-                        break\n-        for reviewer in pr_reviewers:\n-            reviewers[reviewer] += 1\n-        if pr.state == \"MERGED\" and pr.author:\n-            contributors[pr.author.login] += 1\n-    return ContributorsResults(\n-        contributors=contributors,\n-        commenters=commenters,\n-        reviewers=reviewers,\n-        translation_reviewers=translation_reviewers,\n-        authors=authors,\n-    )\n-\n-\n-def get_individual_sponsors(settings: Settings):\n-    nodes: List[SponsorshipAsMaintainerNode] = []\n-    edges = get_graphql_sponsor_edges(settings=settings)\n-\n-    while edges:\n-        for edge in edges:\n-            nodes.append(edge.node)\n-        last_edge = edges[-1]\n-        edges = get_graphql_sponsor_edges(settings=settings, after=last_edge.cursor)\n-\n-    tiers: DefaultDict[float, Dict[str, SponsorEntity]] = defaultdict(dict)\n-    for node in nodes:\n-        tiers[node.tier.monthlyPriceInDollars][node.sponsorEntity.login] = (\n-            node.sponsorEntity\n-        )\n-    return tiers\n-\n-\n-def get_top_users(\n-    *,\n-    counter: Counter,\n-    authors: Dict[str, Author],\n-    skip_users: Container[str],\n-    min_count: int = 2,\n-):\n-    users = []\n-    for commenter, count in counter.most_common(50):\n-        if commenter in skip_users:\n-            continue\n-        if count >= min_count:\n-            author = authors[commenter]\n-            users.append(\n-                {\n-                    \"login\": commenter,\n-                    \"count\": count,\n-                    \"avatarUrl\": author.avatarUrl,\n-                    \"url\": author.url,\n-                }\n-            )\n-    return users\n-\n-\n-if __name__ == \"__main__\":\n-    logging.basicConfig(level=logging.INFO)\n-    settings = Settings()\n-    logging.info(f\"Using config: {settings.model_dump_json()}\")\n-    g = Github(settings.input_token.get_secret_value())\n-    repo = g.get_repo(settings.github_repository)\n-    discussion_nodes = get_discussion_nodes(settings=settings)\n-    experts_results = get_discussions_experts(discussion_nodes=discussion_nodes)\n-    pr_nodes = get_pr_nodes(settings=settings)\n-    contributors_results = get_contributors(pr_nodes=pr_nodes)\n-    authors = {**experts_results.authors, **contributors_results.authors}\n-    maintainers_logins = {\"tiangolo\"}\n-    bot_names = {\"codecov\", \"github-actions\", \"pre-commit-ci\", \"dependabot\"}\n-    maintainers = []\n-    for login in maintainers_logins:\n-        user = authors[login]\n-        maintainers.append(\n-            {\n-                \"login\": login,\n-                \"answers\": experts_results.commenters[login],\n-                \"prs\": contributors_results.contributors[login],\n-                \"avatarUrl\": user.avatarUrl,\n-                \"url\": user.url,\n-            }\n-        )\n-\n-    skip_users = maintainers_logins | bot_names\n-    experts = get_top_users(\n-        counter=experts_results.commenters,\n-        authors=authors,\n-        skip_users=skip_users,\n-    )\n-    last_month_experts = get_top_users(\n-        counter=experts_results.last_month_commenters,\n-        authors=authors,\n-        skip_users=skip_users,\n-    )\n-    three_months_experts = get_top_users(\n-        counter=experts_results.three_months_commenters,\n-        authors=authors,\n-        skip_users=skip_users,\n-    )\n-    six_months_experts = get_top_users(\n-        counter=experts_results.six_months_commenters,\n-        authors=authors,\n-        skip_users=skip_users,\n-    )\n-    one_year_experts = get_top_users(\n-        counter=experts_results.one_year_commenters,\n-        authors=authors,\n-        skip_users=skip_users,\n-    )\n-    top_contributors = get_top_users(\n-        counter=contributors_results.contributors,\n-        authors=authors,\n-        skip_users=skip_users,\n-    )\n-    top_reviewers = get_top_users(\n-        counter=contributors_results.reviewers,\n-        authors=authors,\n-        skip_users=skip_users,\n-    )\n-    top_translations_reviewers = get_top_users(\n-        counter=contributors_results.translation_reviewers,\n-        authors=authors,\n-        skip_users=skip_users,\n-    )\n-\n-    tiers = get_individual_sponsors(settings=settings)\n-    keys = list(tiers.keys())\n-    keys.sort(reverse=True)\n-    sponsors = []\n-    for key in keys:\n-        sponsor_group = []\n-        for login, sponsor in tiers[key].items():\n-            sponsor_group.append(\n-                {\"login\": login, \"avatarUrl\": sponsor.avatarUrl, \"url\": sponsor.url}\n-            )\n-        sponsors.append(sponsor_group)\n-\n-    people = {\n-        \"maintainers\": maintainers,\n-        \"experts\": experts,\n-        \"last_month_experts\": last_month_experts,\n-        \"three_months_experts\": three_months_experts,\n-        \"six_months_experts\": six_months_experts,\n-        \"one_year_experts\": one_year_experts,\n-        \"top_contributors\": top_contributors,\n-        \"top_reviewers\": top_reviewers,\n-        \"top_translations_reviewers\": top_translations_reviewers,\n-    }\n-    github_sponsors = {\n-        \"sponsors\": sponsors,\n-    }\n-    # For local development\n-    # people_path = Path(\"../../../../docs/en/data/people.yml\")\n-    people_path = Path(\"./docs/en/data/people.yml\")\n-    github_sponsors_path = Path(\"./docs/en/data/github_sponsors.yml\")\n-    people_old_content = people_path.read_text(encoding=\"utf-8\")\n-    github_sponsors_old_content = github_sponsors_path.read_text(encoding=\"utf-8\")\n-    new_people_content = yaml.dump(\n-        people, sort_keys=False, width=200, allow_unicode=True\n-    )\n-    new_github_sponsors_content = yaml.dump(\n-        github_sponsors, sort_keys=False, width=200, allow_unicode=True\n-    )\n-    if (\n-        people_old_content == new_people_content\n-        and github_sponsors_old_content == new_github_sponsors_content\n-    ):\n-        logging.info(\"The FastAPI People data hasn't changed, finishing.\")\n-        sys.exit(0)\n-    people_path.write_text(new_people_content, encoding=\"utf-8\")\n-    github_sponsors_path.write_text(new_github_sponsors_content, encoding=\"utf-8\")\n-    logging.info(\"Setting up GitHub Actions git user\")\n-    subprocess.run([\"git\", \"config\", \"user.name\", \"github-actions\"], check=True)\n-    subprocess.run(\n-        [\"git\", \"config\", \"user.email\", \"github-actions@github.com\"], check=True\n-    )\n-    branch_name = \"fastapi-people\"\n-    logging.info(f\"Creating a new branch {branch_name}\")\n-    subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n-    logging.info(\"Adding updated file\")\n-    subprocess.run(\n-        [\"git\", \"add\", str(people_path), str(github_sponsors_path)], check=True\n-    )\n-    logging.info(\"Committing updated file\")\n-    message = \"👥 Update FastAPI People\"\n-    result = subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n-    logging.info(\"Pushing branch\")\n-    subprocess.run([\"git\", \"push\", \"origin\", branch_name], check=True)\n-    logging.info(\"Creating PR\")\n-    pr = repo.create_pull(title=message, body=message, base=\"master\", head=branch_name)\n-    logging.info(f\"Created PR: {pr.number}\")\n-    logging.info(\"Finished\")\n\n@@ -0,0 +1,401 @@\n+import logging\n+import secrets\n+import subprocess\n+import time\n+from collections import Counter\n+from datetime import datetime, timedelta, timezone\n+from pathlib import Path\n+from typing import Any, Container, Union\n+\n+import httpx\n+import yaml\n+from github import Github\n+from pydantic import BaseModel, SecretStr\n+from pydantic_settings import BaseSettings\n+\n+github_graphql_url = \"https://api.github.com/graphql\"\n+questions_category_id = \"MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMyMDAxNDM0\"\n+\n+discussions_query = \"\"\"\n+query Q($after: String, $category_id: ID) {\n+  repository(name: \"fastapi\", owner: \"fastapi\") {\n+    discussions(first: 100, after: $after, categoryId: $category_id) {\n+      edges {\n+        cursor\n+        node {\n+          number\n+          author {\n+            login\n+            avatarUrl\n+            url\n+          }\n+          createdAt\n+          comments(first: 50) {\n+            totalCount\n+            nodes {\n+              createdAt\n+              author {\n+                login\n+                avatarUrl\n+                url\n+              }\n+              isAnswer\n+              replies(first: 10) {\n+                totalCount\n+                nodes {\n+                  createdAt\n+                  author {\n+                    login\n+                    avatarUrl\n+                    url\n+                  }\n+                }\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\"\"\"\n+\n+\n+class Author(BaseModel):\n+    login: str\n+    avatarUrl: str | None = None\n+    url: str | None = None\n+\n+\n+class CommentsNode(BaseModel):\n+    createdAt: datetime\n+    author: Union[Author, None] = None\n+\n+\n+class Replies(BaseModel):\n+    totalCount: int\n+    nodes: list[CommentsNode]\n+\n+\n+class DiscussionsCommentsNode(CommentsNode):\n+    replies: Replies\n+\n+\n+class DiscussionsComments(BaseModel):\n+    totalCount: int\n+    nodes: list[DiscussionsCommentsNode]\n+\n+\n+class DiscussionsNode(BaseModel):\n+    number: int\n+    author: Union[Author, None] = None\n+    title: str | None = None\n+    createdAt: datetime\n+    comments: DiscussionsComments\n+\n+\n+class DiscussionsEdge(BaseModel):\n+    cursor: str\n+    node: DiscussionsNode\n+\n+\n+class Discussions(BaseModel):\n+    edges: list[DiscussionsEdge]\n+\n+\n+class DiscussionsRepository(BaseModel):\n+    discussions: Discussions\n+\n+\n+class DiscussionsResponseData(BaseModel):\n+    repository: DiscussionsRepository\n+\n+\n+class DiscussionsResponse(BaseModel):\n+    data: DiscussionsResponseData\n+\n+\n+class Settings(BaseSettings):\n+    github_token: SecretStr\n+    github_repository: str\n+    httpx_timeout: int = 30\n+\n+\n+def get_graphql_response(\n+    *,\n+    settings: Settings,\n+    query: str,\n+    after: Union[str, None] = None,\n+    category_id: Union[str, None] = None,\n+) -> dict[str, Any]:\n+    headers = {\"Authorization\": f\"token {settings.github_token.get_secret_value()}\"}\n+    variables = {\"after\": after, \"category_id\": category_id}\n+    response = httpx.post(\n+        github_graphql_url,\n+        headers=headers,\n+        timeout=settings.httpx_timeout,\n+        json={\"query\": query, \"variables\": variables, \"operationName\": \"Q\"},\n+    )\n+    if response.status_code != 200:\n+        logging.error(\n+            f\"Response was not 200, after: {after}, category_id: {category_id}\"\n+        )\n+        logging.error(response.text)\n+        raise RuntimeError(response.text)\n+    data = response.json()\n+    if \"errors\" in data:\n+        logging.error(f\"Errors in response, after: {after}, category_id: {category_id}\")\n+        logging.error(data[\"errors\"])\n+        logging.error(response.text)\n+        raise RuntimeError(response.text)\n+    return data\n+\n+\n+def get_graphql_question_discussion_edges(\n+    *,\n+    settings: Settings,\n+    after: Union[str, None] = None,\n+) -> list[DiscussionsEdge]:\n+    data = get_graphql_response(\n+        settings=settings,\n+        query=discussions_query,\n+        after=after,\n+        category_id=questions_category_id,\n+    )\n+    graphql_response = DiscussionsResponse.model_validate(data)\n+    return graphql_response.data.repository.discussions.edges\n+\n+\n+class DiscussionExpertsResults(BaseModel):\n+    commenters: Counter[str]\n+    last_month_commenters: Counter[str]\n+    three_months_commenters: Counter[str]\n+    six_months_commenters: Counter[str]\n+    one_year_commenters: Counter[str]\n+    authors: dict[str, Author]\n+\n+\n+def get_discussion_nodes(settings: Settings) -> list[DiscussionsNode]:\n+    discussion_nodes: list[DiscussionsNode] = []\n+    discussion_edges = get_graphql_question_discussion_edges(settings=settings)\n+\n+    while discussion_edges:\n+        for discussion_edge in discussion_edges:\n+            discussion_nodes.append(discussion_edge.node)\n+        last_edge = discussion_edges[-1]\n+        # Handle GitHub secondary rate limits, requests per minute\n+        time.sleep(5)\n+        discussion_edges = get_graphql_question_discussion_edges(\n+            settings=settings, after=last_edge.cursor\n+        )\n+    return discussion_nodes\n+\n+\n+def get_discussions_experts(\n+    discussion_nodes: list[DiscussionsNode],\n+) -> DiscussionExpertsResults:\n+    commenters = Counter[str]()\n+    last_month_commenters = Counter[str]()\n+    three_months_commenters = Counter[str]()\n+    six_months_commenters = Counter[str]()\n+    one_year_commenters = Counter[str]()\n+    authors: dict[str, Author] = {}\n+\n+    now = datetime.now(tz=timezone.utc)\n+    one_month_ago = now - timedelta(days=30)\n+    three_months_ago = now - timedelta(days=90)\n+    six_months_ago = now - timedelta(days=180)\n+    one_year_ago = now - timedelta(days=365)\n+\n+    for discussion in discussion_nodes:\n+        discussion_author_name = None\n+        if discussion.author:\n+            authors[discussion.author.login] = discussion.author\n+            discussion_author_name = discussion.author.login\n+        discussion_commentors: dict[str, datetime] = {}\n+        for comment in discussion.comments.nodes:\n+            if comment.author:\n+                authors[comment.author.login] = comment.author\n+                if comment.author.login != discussion_author_name:\n+                    author_time = discussion_commentors.get(\n+                        comment.author.login, comment.createdAt\n+                    )\n+                    discussion_commentors[comment.author.login] = max(\n+                        author_time, comment.createdAt\n+                    )\n+            for reply in comment.replies.nodes:\n+                if reply.author:\n+                    authors[reply.author.login] = reply.author\n+                    if reply.author.login != discussion_author_name:\n+                        author_time = discussion_commentors.get(\n+                            reply.author.login, reply.createdAt\n+                        )\n+                        discussion_commentors[reply.author.login] = max(\n+                            author_time, reply.createdAt\n+                        )\n+        for author_name, author_time in discussion_commentors.items():\n+            commenters[author_name] += 1\n+            if author_time > one_month_ago:\n+                last_month_commenters[author_name] += 1\n+            if author_time > three_months_ago:\n+                three_months_commenters[author_name] += 1\n+            if author_time > six_months_ago:\n+                six_months_commenters[author_name] += 1\n+            if author_time > one_year_ago:\n+                one_year_commenters[author_name] += 1\n+    discussion_experts_results = DiscussionExpertsResults(\n+        authors=authors,\n+        commenters=commenters,\n+        last_month_commenters=last_month_commenters,\n+        three_months_commenters=three_months_commenters,\n+        six_months_commenters=six_months_commenters,\n+        one_year_commenters=one_year_commenters,\n+    )\n+    return discussion_experts_results\n+\n+\n+def get_top_users(\n+    *,\n+    counter: Counter[str],\n+    authors: dict[str, Author],\n+    skip_users: Container[str],\n+    min_count: int = 2,\n+) -> list[dict[str, Any]]:\n+    users: list[dict[str, Any]] = []\n+    for commenter, count in counter.most_common(50):\n+        if commenter in skip_users:\n+            continue\n+        if count >= min_count:\n+            author = authors[commenter]\n+            users.append(\n+                {\n+                    \"login\": commenter,\n+                    \"count\": count,\n+                    \"avatarUrl\": author.avatarUrl,\n+                    \"url\": author.url,\n+                }\n+            )\n+    return users\n+\n+\n+def get_users_to_write(\n+    *,\n+    counter: Counter[str],\n+    authors: dict[str, Author],\n+    min_count: int = 2,\n+) -> list[dict[str, Any]]:\n+    users: dict[str, Any] = {}\n+    users_list: list[dict[str, Any]] = []\n+    for user, count in counter.most_common(60):\n+        if count >= min_count:\n+            author = authors[user]\n+            user_data = {\n+                \"login\": user,\n+                \"count\": count,\n+                \"avatarUrl\": author.avatarUrl,\n+                \"url\": author.url,\n+            }\n+            users[user] = user_data\n+            users_list.append(user_data)\n+    return users_list\n+\n+\n+def update_content(*, content_path: Path, new_content: Any) -> bool:\n+    old_content = content_path.read_text(encoding=\"utf-8\")\n+\n+    new_content = yaml.dump(new_content, sort_keys=False, width=200, allow_unicode=True)\n+    if old_content == new_content:\n+        logging.info(f\"The content hasn't changed for {content_path}\")\n+        return False\n+    content_path.write_text(new_content, encoding=\"utf-8\")\n+    logging.info(f\"Updated {content_path}\")\n+    return True\n+\n+\n+def main() -> None:\n+    logging.basicConfig(level=logging.INFO)\n+    settings = Settings()\n+    logging.info(f\"Using config: {settings.model_dump_json()}\")\n+    g = Github(settings.github_token.get_secret_value())\n+    repo = g.get_repo(settings.github_repository)\n+\n+    discussion_nodes = get_discussion_nodes(settings=settings)\n+    experts_results = get_discussions_experts(discussion_nodes=discussion_nodes)\n+\n+    authors = experts_results.authors\n+    maintainers_logins = {\"tiangolo\"}\n+    maintainers = []\n+    for login in maintainers_logins:\n+        user = authors[login]\n+        maintainers.append(\n+            {\n+                \"login\": login,\n+                \"answers\": experts_results.commenters[login],\n+                \"avatarUrl\": user.avatarUrl,\n+                \"url\": user.url,\n+            }\n+        )\n+\n+    experts = get_users_to_write(\n+        counter=experts_results.commenters,\n+        authors=authors,\n+    )\n+    last_month_experts = get_users_to_write(\n+        counter=experts_results.last_month_commenters,\n+        authors=authors,\n+    )\n+    three_months_experts = get_users_to_write(\n+        counter=experts_results.three_months_commenters,\n+        authors=authors,\n+    )\n+    six_months_experts = get_users_to_write(\n+        counter=experts_results.six_months_commenters,\n+        authors=authors,\n+    )\n+    one_year_experts = get_users_to_write(\n+        counter=experts_results.one_year_commenters,\n+        authors=authors,\n+    )\n+\n+    people = {\n+        \"maintainers\": maintainers,\n+        \"experts\": experts,\n+        \"last_month_experts\": last_month_experts,\n+        \"three_months_experts\": three_months_experts,\n+        \"six_months_experts\": six_months_experts,\n+        \"one_year_experts\": one_year_experts,\n+    }\n+\n+    # For local development\n+    # people_path = Path(\"../docs/en/data/people.yml\")\n+    people_path = Path(\"./docs/en/data/people.yml\")\n+\n+    updated = update_content(content_path=people_path, new_content=people)\n+\n+    if not updated:\n+        logging.info(\"The data hasn't changed, finishing.\")\n+        return\n+\n+    logging.info(\"Setting up GitHub Actions git user\")\n+    subprocess.run([\"git\", \"config\", \"user.name\", \"github-actions\"], check=True)\n+    subprocess.run(\n+        [\"git\", \"config\", \"user.email\", \"github-actions@github.com\"], check=True\n+    )\n+    branch_name = f\"fastapi-people-experts-{secrets.token_hex(4)}\"\n+    logging.info(f\"Creating a new branch {branch_name}\")\n+    subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n+    logging.info(\"Adding updated file\")\n+    subprocess.run([\"git\", \"add\", str(people_path)], check=True)\n+    logging.info(\"Committing updated file\")\n+    message = \"👥 Update FastAPI People - Experts\"\n+    subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n+    logging.info(\"Pushing branch\")\n+    subprocess.run([\"git\", \"push\", \"origin\", branch_name], check=True)\n+    logging.info(\"Creating PR\")\n+    pr = repo.create_pull(title=message, body=message, base=\"master\", head=branch_name)\n+    logging.info(f\"Created PR: {pr.number}\")\n+    logging.info(\"Finished\")\n+\n+\n+if __name__ == \"__main__\":\n+    main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
