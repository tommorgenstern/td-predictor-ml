{"custom_id": "flask#414b30b2ec8ae365ca311b697d44578394371ff6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 1950 | Contributors (this commit): 16 | Commits (past 90d): 1 | Contributors (cumulative): 16 | DMM Complexity: None\n\nDIFF:\n@@ -26,7 +26,7 @@ intersphinx_mapping = {\n     \"jinja\": (\"https://jinja.palletsprojects.com/\", None),\n     \"itsdangerous\": (\"https://itsdangerous.palletsprojects.com/\", None),\n     \"sqlalchemy\": (\"https://docs.sqlalchemy.org/\", None),\n-    \"wtforms\": (\"https://wtforms.readthedocs.io/en/stable/\", None),\n+    \"wtforms\": (\"https://wtforms.readthedocs.io/\", None),\n     \"blinker\": (\"https://pythonhosted.org/blinker/\", None),\n }\n issues_github_path = \"pallets/flask\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#cf3089a8f82d50430da4cbe690c1ef11d30241ec", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 363 | Contributors (this commit): 3 | Commits (past 90d): 2 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -60,7 +60,7 @@ def find_best_app(script_info, module):\n         )\n \n     # Search for app factory functions.\n-    for attr_name in {\"create_app\", \"make_app\"}:\n+    for attr_name in (\"create_app\", \"make_app\"):\n         app_factory = getattr(module, attr_name, None)\n \n         if inspect.isfunction(app_factory):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#1f1b65a62576bc6a2f9cd27e9a725f0554fc70c7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 203 | Contributors (this commit): 3 | Commits (past 90d): 2 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -121,7 +121,7 @@ class Blueprint(Scaffold):\n         default.\n     :param url_defaults: A dict of default values that blueprint routes\n         will receive by default.\n-    :param root_path: By default, the blueprint will automatically this\n+    :param root_path: By default, the blueprint will automatically set this\n         based on ``import_name``. In certain situations this automatic\n         detection can fail, so the path can be specified manually\n         instead.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#5bfe236fb531045497396bc85ee5026c6c9c68eb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 365 | Contributors (this commit): 4 | Commits (past 90d): 3 | Contributors (cumulative): 4 | DMM Complexity: None\n\nDIFF:\n@@ -859,7 +859,7 @@ def run_command(\n def shell_command():\n     \"\"\"Run an interactive Python shell in the context of a given\n     Flask application.  The application will populate the default\n-    namespace of this shell according to it's configuration.\n+    namespace of this shell according to its configuration.\n \n     This is useful for executing small snippets of management code\n     without having to manually configure the application.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#8efea0ccbbf0985e0c3c001e5bd90b4912a18f54", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 29 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 8 | Methods Changed: 2 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 30 | Churn Cumulative: 5310 | Contributors (this commit): 47 | Commits (past 90d): 5 | Contributors (cumulative): 51 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,5 +1,6 @@\n import os\n import sys\n+import weakref\n from datetime import timedelta\n from itertools import chain\n from threading import Lock\n@@ -478,11 +479,14 @@ class Flask(Scaffold):\n             assert (\n                 bool(static_host) == host_matching\n             ), \"Invalid static_host/host_matching combination\"\n+            # Use a weakref to avoid creating a reference cycle between the app\n+            # and the view function (see #3761).\n+            self_ref = weakref.ref(self)\n             self.add_url_rule(\n                 f\"{self.static_url_path}/<path:filename>\",\n                 endpoint=\"static\",\n                 host=static_host,\n-                view_func=self.send_static_file,\n+                view_func=lambda **kw: self_ref().send_static_file(**kw),\n             )\n \n         # Set the name of the Click group in case someone wants to add\n\n@@ -1,8 +1,11 @@\n+import gc\n import re\n import sys\n import time\n import uuid\n+import weakref\n from datetime import datetime\n+from platform import python_implementation\n from threading import Thread\n \n import pytest\n@@ -16,6 +19,11 @@ from werkzeug.routing import BuildError\n import flask\n \n \n+require_cpython_gc = pytest.mark.skipif(\n+    python_implementation() != \"CPython\", reason=\"Requires CPython GC behavior\",\n+)\n+\n+\n def test_options_work(app, client):\n     @app.route(\"/\", methods=[\"GET\", \"POST\"])\n     def index():\n@@ -1970,3 +1978,19 @@ def test_max_cookie_size(app, client, recwarn):\n \n     client.get(\"/\")\n     assert len(recwarn) == 0\n+\n+\n+@require_cpython_gc\n+def test_app_freed_on_zero_refcount():\n+    # A Flask instance should not create a reference cycle that prevents CPython\n+    # from freeing it when all external references to it are released (see #3761).\n+    gc.disable()\n+    try:\n+        app = flask.Flask(__name__)\n+        assert app.view_functions[\"static\"]\n+        weak = weakref.ref(app)\n+        assert weak() is not None\n+        del app\n+        assert weak() is None\n+    finally:\n+        gc.enable()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#bdf7083cfdeef0e0bdd0bf6d4c23b26c92b52d95", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 205 | Contributors (this commit): 4 | Commits (past 90d): 3 | Contributors (cumulative): 4 | DMM Complexity: None\n\nDIFF:\n@@ -130,7 +130,7 @@ class Blueprint(Scaffold):\n     warn_on_modifications = False\n     _got_registered_once = False\n \n-    #: Blueprint local JSON decoder class to use.\n+    #: Blueprint local JSON encoder class to use.\n     #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_encoder`.\n     json_encoder = None\n     #: Blueprint local JSON decoder class to use.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#8c6baeedab60e0041317c2709df100dfd216c2ef", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 10 | Files Changed: 1 | Hunks: 6 | Methods Changed: 4 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 20 | Churn Cumulative: 3094 | Contributors (this commit): 38 | Commits (past 90d): 2 | Contributors (cumulative): 38 | DMM Complexity: 0.0\n\nDIFF:\n@@ -895,9 +895,9 @@ class TestStreaming:\n \n \n class TestSafeJoin:\n-    def test_safe_join(self):\n-        # Valid combinations of *args and expected joined paths.\n-        passing = (\n+    @pytest.mark.parametrize(\n+        \"args, expected\",\n+        (\n             ((\"a/b/c\",), \"a/b/c\"),\n             ((\"/\", \"a/\", \"b/\", \"c/\"), \"/a/b/c\"),\n             ((\"a\", \"b\", \"c\"), \"a/b/c\"),\n@@ -912,14 +912,14 @@ class TestSafeJoin:\n             # Base directory is always considered safe\n             ((\"../\", \"a/b/c\"), \"../a/b/c\"),\n             ((\"/..\",), \"/..\"),\n+        ),\n     )\n-\n-        for args, expected in passing:\n+    def test_safe_join(self, args, expected):\n         assert flask.safe_join(*args) == expected\n \n-    def test_safe_join_exceptions(self):\n-        # Should raise werkzeug.exceptions.NotFound on unsafe joins.\n-        failing = (\n+    @pytest.mark.parametrize(\n+        \"args\",\n+        (\n             # path.isabs and ``..'' checks\n             (\"/a\", \"b\", \"/c\"),\n             (\"/a\", \"../b/c\"),\n@@ -928,9 +928,9 @@ class TestSafeJoin:\n             (\"/a\", \"b/../b/../../c\"),\n             (\"/a\", \"b\", \"c/../..\"),\n             (\"/a\", \"b/../../c\"),\n+        ),\n     )\n-\n-        for args in failing:\n+    def test_safe_join_exceptions(self, args):\n         with pytest.raises(NotFound):\n             print(flask.safe_join(*args))\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#1035efc7d6e49a459ec2dcbfab9526a7347d6f2e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 1951 | Contributors (this commit): 16 | Commits (past 90d): 2 | Contributors (cumulative): 16 | DMM Complexity: None\n\nDIFF:\n@@ -18,6 +18,7 @@ extensions = [\n     \"sphinxcontrib.log_cabinet\",\n     \"pallets_sphinx_themes\",\n     \"sphinx_issues\",\n+    \"sphinx_tabs.tabs\",\n ]\n intersphinx_mapping = {\n     \"python\": (\"https://docs.python.org/3/\", None),\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#5d60cce2429e2c7e11e9acc5ea030464bf169f84", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 274 | Contributors (this commit): 7 | Commits (past 90d): 1 | Contributors (cumulative): 7 | DMM Complexity: None\n\nDIFF:\n@@ -239,7 +239,7 @@ def url_for(endpoint, **values):\n                 # Re-raise the BuildError, in context of original traceback.\n                 exc_type, exc_value, tb = sys.exc_info()\n                 if exc_value is error:\n-                    raise exc_type, exc_value, tb\n+                    raise exc_type(exc_value).with_traceback(tb)\n                 else:\n                     raise error\n             # url_for will use this result, instead of raising BuildError.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#1c6dc15420b21fc325833ab2955375e9736f2e74", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 24 | Contributors (this commit): 1 | Commits (past 90d): 1 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -90,7 +90,7 @@ class Request(RequestBase, JSONMixin):\n             attach_enctype_error_multidict(self)\n \n \n-class Response(ResponseBase, JSONMixin):\n+class Response(JSONMixin, ResponseBase):\n     \"\"\"The response object that is used by default in Flask.  Works like the\n     response object from Werkzeug but is set to have an HTML mimetype by\n     default.  Quite often you don't have to create this object yourself because\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#a0e2aca770c756d9f7de53339e2cf9067a52df11", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 402 | Lines Deleted: 380 | Files Changed: 2 | Hunks: 4 | Methods Changed: 84 | Complexity Δ (Sum/Max): 0/54 | Churn Δ: 782 | Churn Cumulative: 3876 | Contributors (this commit): 38 | Commits (past 90d): 3 | Contributors (cumulative): 39 | DMM Complexity: None\n\nDIFF:\n@@ -2,7 +2,6 @@ import datetime\n import io\n import os\n import sys\n-import uuid\n \n import pytest\n from werkzeug.datastructures import Range\n@@ -17,16 +16,6 @@ from flask.helpers import get_debug_flag\n from flask.helpers import get_env\n \n \n-def has_encoding(name):\n-    try:\n-        import codecs\n-\n-        codecs.lookup(name)\n-        return True\n-    except LookupError:\n-        return False\n-\n-\n class FakePath:\n     \"\"\"Fake object to represent a ``PathLike object``.\n \n@@ -41,375 +30,6 @@ class FakePath:\n         return self.path\n \n \n-class FixedOffset(datetime.tzinfo):\n-    \"\"\"Fixed offset in hours east from UTC.\n-\n-    This is a slight adaptation of the ``FixedOffset`` example found in\n-    https://docs.python.org/2.7/library/datetime.html.\n-    \"\"\"\n-\n-    def __init__(self, hours, name):\n-        self.__offset = datetime.timedelta(hours=hours)\n-        self.__name = name\n-\n-    def utcoffset(self, dt):\n-        return self.__offset\n-\n-    def tzname(self, dt):\n-        return self.__name\n-\n-    def dst(self, dt):\n-        return datetime.timedelta()\n-\n-\n-class TestJSON:\n-    @pytest.mark.parametrize(\"debug\", (True, False))\n-    def test_bad_request_debug_message(self, app, client, debug):\n-        app.config[\"DEBUG\"] = debug\n-        app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n-\n-        @app.route(\"/json\", methods=[\"POST\"])\n-        def post_json():\n-            flask.request.get_json()\n-            return None\n-\n-        rv = client.post(\"/json\", data=None, content_type=\"application/json\")\n-        assert rv.status_code == 400\n-        contains = b\"Failed to decode JSON object\" in rv.data\n-        assert contains == debug\n-\n-    def test_json_bad_requests(self, app, client):\n-        @app.route(\"/json\", methods=[\"POST\"])\n-        def return_json():\n-            return flask.jsonify(foo=str(flask.request.get_json()))\n-\n-        rv = client.post(\"/json\", data=\"malformed\", content_type=\"application/json\")\n-        assert rv.status_code == 400\n-\n-    def test_json_custom_mimetypes(self, app, client):\n-        @app.route(\"/json\", methods=[\"POST\"])\n-        def return_json():\n-            return flask.request.get_json()\n-\n-        rv = client.post(\"/json\", data='\"foo\"', content_type=\"application/x+json\")\n-        assert rv.data == b\"foo\"\n-\n-    @pytest.mark.parametrize(\n-        \"test_value,expected\", [(True, '\"\\\\u2603\"'), (False, '\"\\u2603\"')]\n-    )\n-    def test_json_as_unicode(self, test_value, expected, app, app_ctx):\n-\n-        app.config[\"JSON_AS_ASCII\"] = test_value\n-        rv = flask.json.dumps(\"\\N{SNOWMAN}\")\n-        assert rv == expected\n-\n-    def test_json_dump_to_file(self, app, app_ctx):\n-        test_data = {\"name\": \"Flask\"}\n-        out = io.StringIO()\n-\n-        flask.json.dump(test_data, out)\n-        out.seek(0)\n-        rv = flask.json.load(out)\n-        assert rv == test_data\n-\n-    @pytest.mark.parametrize(\n-        \"test_value\", [0, -1, 1, 23, 3.14, \"s\", \"longer string\", True, False, None]\n-    )\n-    def test_jsonify_basic_types(self, test_value, app, client):\n-        url = \"/jsonify_basic_types\"\n-        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n-        rv = client.get(url)\n-        assert rv.mimetype == \"application/json\"\n-        assert flask.json.loads(rv.data) == test_value\n-\n-    def test_jsonify_dicts(self, app, client):\n-        d = {\n-            \"a\": 0,\n-            \"b\": 23,\n-            \"c\": 3.14,\n-            \"d\": \"t\",\n-            \"e\": \"Hi\",\n-            \"f\": True,\n-            \"g\": False,\n-            \"h\": [\"test list\", 10, False],\n-            \"i\": {\"test\": \"dict\"},\n-        }\n-\n-        @app.route(\"/kw\")\n-        def return_kwargs():\n-            return flask.jsonify(**d)\n-\n-        @app.route(\"/dict\")\n-        def return_dict():\n-            return flask.jsonify(d)\n-\n-        for url in \"/kw\", \"/dict\":\n-            rv = client.get(url)\n-            assert rv.mimetype == \"application/json\"\n-            assert flask.json.loads(rv.data) == d\n-\n-    def test_jsonify_arrays(self, app, client):\n-        \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n-        a_list = [\n-            0,\n-            42,\n-            3.14,\n-            \"t\",\n-            \"hello\",\n-            True,\n-            False,\n-            [\"test list\", 2, False],\n-            {\"test\": \"dict\"},\n-        ]\n-\n-        @app.route(\"/args_unpack\")\n-        def return_args_unpack():\n-            return flask.jsonify(*a_list)\n-\n-        @app.route(\"/array\")\n-        def return_array():\n-            return flask.jsonify(a_list)\n-\n-        for url in \"/args_unpack\", \"/array\":\n-            rv = client.get(url)\n-            assert rv.mimetype == \"application/json\"\n-            assert flask.json.loads(rv.data) == a_list\n-\n-    def test_jsonify_date_types(self, app, client):\n-        \"\"\"Test jsonify with datetime.date and datetime.datetime types.\"\"\"\n-        test_dates = (\n-            datetime.datetime(1973, 3, 11, 6, 30, 45),\n-            datetime.date(1975, 1, 5),\n-        )\n-\n-        for i, d in enumerate(test_dates):\n-            url = f\"/datetest{i}\"\n-            app.add_url_rule(url, str(i), lambda val=d: flask.jsonify(x=val))\n-            rv = client.get(url)\n-            assert rv.mimetype == \"application/json\"\n-            assert flask.json.loads(rv.data)[\"x\"] == http_date(d.timetuple())\n-\n-    @pytest.mark.parametrize(\"tz\", ((\"UTC\", 0), (\"PST\", -8), (\"KST\", 9)))\n-    def test_jsonify_aware_datetimes(self, tz):\n-        \"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"\n-        tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n-        dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n-        gmt = FixedOffset(hours=0, name=\"GMT\")\n-        expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n-        assert flask.json.JSONEncoder().encode(dt) == expected\n-\n-    def test_jsonify_uuid_types(self, app, client):\n-        \"\"\"Test jsonify with uuid.UUID types\"\"\"\n-\n-        test_uuid = uuid.UUID(bytes=b\"\\xDE\\xAD\\xBE\\xEF\" * 4)\n-        url = \"/uuid_test\"\n-        app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n-\n-        rv = client.get(url)\n-\n-        rv_x = flask.json.loads(rv.data)[\"x\"]\n-        assert rv_x == str(test_uuid)\n-        rv_uuid = uuid.UUID(rv_x)\n-        assert rv_uuid == test_uuid\n-\n-    def test_json_attr(self, app, client):\n-        @app.route(\"/add\", methods=[\"POST\"])\n-        def add():\n-            json = flask.request.get_json()\n-            return str(json[\"a\"] + json[\"b\"])\n-\n-        rv = client.post(\n-            \"/add\",\n-            data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n-            content_type=\"application/json\",\n-        )\n-        assert rv.data == b\"3\"\n-\n-    def test_template_escaping(self, app, req_ctx):\n-        render = flask.render_template_string\n-        rv = flask.json.htmlsafe_dumps(\"</script>\")\n-        assert rv == '\"\\\\u003c/script\\\\u003e\"'\n-        rv = render('{{ \"</script>\"|tojson }}')\n-        assert rv == '\"\\\\u003c/script\\\\u003e\"'\n-        rv = render('{{ \"<\\0/script>\"|tojson }}')\n-        assert rv == '\"\\\\u003c\\\\u0000/script\\\\u003e\"'\n-        rv = render('{{ \"<!--<script>\"|tojson }}')\n-        assert rv == '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"'\n-        rv = render('{{ \"&\"|tojson }}')\n-        assert rv == '\"\\\\u0026\"'\n-        rv = render('{{ \"\\'\"|tojson }}')\n-        assert rv == '\"\\\\u0027\"'\n-        rv = render(\n-            \"<a ng-data='{{ data|tojson }}'></a>\", data={\"x\": [\"foo\", \"bar\", \"baz'\"]}\n-        )\n-        assert rv == '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'></a>'\n-\n-    def test_json_customization(self, app, client):\n-        class X:  # noqa: B903, for Python2 compatibility\n-            def __init__(self, val):\n-                self.val = val\n-\n-        class MyEncoder(flask.json.JSONEncoder):\n-            def default(self, o):\n-                if isinstance(o, X):\n-                    return f\"<{o.val}>\"\n-                return flask.json.JSONEncoder.default(self, o)\n-\n-        class MyDecoder(flask.json.JSONDecoder):\n-            def __init__(self, *args, **kwargs):\n-                kwargs.setdefault(\"object_hook\", self.object_hook)\n-                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n-\n-            def object_hook(self, obj):\n-                if len(obj) == 1 and \"_foo\" in obj:\n-                    return X(obj[\"_foo\"])\n-                return obj\n-\n-        app.json_encoder = MyEncoder\n-        app.json_decoder = MyDecoder\n-\n-        @app.route(\"/\", methods=[\"POST\"])\n-        def index():\n-            return flask.json.dumps(flask.request.get_json()[\"x\"])\n-\n-        rv = client.post(\n-            \"/\",\n-            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n-            content_type=\"application/json\",\n-        )\n-        assert rv.data == b'\"<42>\"'\n-\n-    def test_blueprint_json_customization(self, app, client):\n-        class X:\n-            __slots__ = (\"val\",)\n-\n-            def __init__(self, val):\n-                self.val = val\n-\n-        class MyEncoder(flask.json.JSONEncoder):\n-            def default(self, o):\n-                if isinstance(o, X):\n-                    return f\"<{o.val}>\"\n-\n-                return flask.json.JSONEncoder.default(self, o)\n-\n-        class MyDecoder(flask.json.JSONDecoder):\n-            def __init__(self, *args, **kwargs):\n-                kwargs.setdefault(\"object_hook\", self.object_hook)\n-                flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n-\n-            def object_hook(self, obj):\n-                if len(obj) == 1 and \"_foo\" in obj:\n-                    return X(obj[\"_foo\"])\n-\n-                return obj\n-\n-        bp = flask.Blueprint(\"bp\", __name__)\n-        bp.json_encoder = MyEncoder\n-        bp.json_decoder = MyDecoder\n-\n-        @bp.route(\"/bp\", methods=[\"POST\"])\n-        def index():\n-            return flask.json.dumps(flask.request.get_json()[\"x\"])\n-\n-        app.register_blueprint(bp)\n-\n-        rv = client.post(\n-            \"/bp\",\n-            data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n-            content_type=\"application/json\",\n-        )\n-        assert rv.data == b'\"<42>\"'\n-\n-    @pytest.mark.skipif(\n-        not has_encoding(\"euc-kr\"), reason=\"The euc-kr encoding is required.\"\n-    )\n-    def test_modified_url_encoding(self, app, client):\n-        class ModifiedRequest(flask.Request):\n-            url_charset = \"euc-kr\"\n-\n-        app.request_class = ModifiedRequest\n-        app.url_map.charset = \"euc-kr\"\n-\n-        @app.route(\"/\")\n-        def index():\n-            return flask.request.args[\"foo\"]\n-\n-        rv = client.get(\"/?foo=정상처리\".encode(\"euc-kr\"))\n-        assert rv.status_code == 200\n-        assert rv.data == \"정상처리\".encode()\n-\n-    def test_json_key_sorting(self, app, client):\n-        app.debug = True\n-\n-        assert app.config[\"JSON_SORT_KEYS\"]\n-        d = dict.fromkeys(range(20), \"foo\")\n-\n-        @app.route(\"/\")\n-        def index():\n-            return flask.jsonify(values=d)\n-\n-        rv = client.get(\"/\")\n-        lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n-        sorted_by_str = [\n-            \"{\",\n-            '\"values\": {',\n-            '\"0\": \"foo\",',\n-            '\"1\": \"foo\",',\n-            '\"10\": \"foo\",',\n-            '\"11\": \"foo\",',\n-            '\"12\": \"foo\",',\n-            '\"13\": \"foo\",',\n-            '\"14\": \"foo\",',\n-            '\"15\": \"foo\",',\n-            '\"16\": \"foo\",',\n-            '\"17\": \"foo\",',\n-            '\"18\": \"foo\",',\n-            '\"19\": \"foo\",',\n-            '\"2\": \"foo\",',\n-            '\"3\": \"foo\",',\n-            '\"4\": \"foo\",',\n-            '\"5\": \"foo\",',\n-            '\"6\": \"foo\",',\n-            '\"7\": \"foo\",',\n-            '\"8\": \"foo\",',\n-            '\"9\": \"foo\"',\n-            \"}\",\n-            \"}\",\n-        ]\n-        sorted_by_int = [\n-            \"{\",\n-            '\"values\": {',\n-            '\"0\": \"foo\",',\n-            '\"1\": \"foo\",',\n-            '\"2\": \"foo\",',\n-            '\"3\": \"foo\",',\n-            '\"4\": \"foo\",',\n-            '\"5\": \"foo\",',\n-            '\"6\": \"foo\",',\n-            '\"7\": \"foo\",',\n-            '\"8\": \"foo\",',\n-            '\"9\": \"foo\",',\n-            '\"10\": \"foo\",',\n-            '\"11\": \"foo\",',\n-            '\"12\": \"foo\",',\n-            '\"13\": \"foo\",',\n-            '\"14\": \"foo\",',\n-            '\"15\": \"foo\",',\n-            '\"16\": \"foo\",',\n-            '\"17\": \"foo\",',\n-            '\"18\": \"foo\",',\n-            '\"19\": \"foo\"',\n-            \"}\",\n-            \"}\",\n-        ]\n-\n-        try:\n-            assert lines == sorted_by_int\n-        except AssertionError:\n-            assert lines == sorted_by_str\n-\n-\n class PyBytesIO:\n     def __init__(self, *args, **kwargs):\n         self._io = io.BytesIO(*args, **kwargs)\n\n@@ -0,0 +1,402 @@\n+import datetime\n+import io\n+import uuid\n+\n+import pytest\n+from werkzeug.http import http_date\n+\n+import flask\n+\n+\n+@pytest.mark.parametrize(\"debug\", (True, False))\n+def test_bad_request_debug_message(app, client, debug):\n+    app.config[\"DEBUG\"] = debug\n+    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n+\n+    @app.route(\"/json\", methods=[\"POST\"])\n+    def post_json():\n+        flask.request.get_json()\n+        return None\n+\n+    rv = client.post(\"/json\", data=None, content_type=\"application/json\")\n+    assert rv.status_code == 400\n+    contains = b\"Failed to decode JSON object\" in rv.data\n+    assert contains == debug\n+\n+\n+def test_json_bad_requests(app, client):\n+    @app.route(\"/json\", methods=[\"POST\"])\n+    def return_json():\n+        return flask.jsonify(foo=str(flask.request.get_json()))\n+\n+    rv = client.post(\"/json\", data=\"malformed\", content_type=\"application/json\")\n+    assert rv.status_code == 400\n+\n+\n+def test_json_custom_mimetypes(app, client):\n+    @app.route(\"/json\", methods=[\"POST\"])\n+    def return_json():\n+        return flask.request.get_json()\n+\n+    rv = client.post(\"/json\", data='\"foo\"', content_type=\"application/x+json\")\n+    assert rv.data == b\"foo\"\n+\n+\n+@pytest.mark.parametrize(\n+    \"test_value,expected\", [(True, '\"\\\\u2603\"'), (False, '\"\\u2603\"')]\n+)\n+def test_json_as_unicode(test_value, expected, app, app_ctx):\n+\n+    app.config[\"JSON_AS_ASCII\"] = test_value\n+    rv = flask.json.dumps(\"\\N{SNOWMAN}\")\n+    assert rv == expected\n+\n+\n+def test_json_dump_to_file(app, app_ctx):\n+    test_data = {\"name\": \"Flask\"}\n+    out = io.StringIO()\n+\n+    flask.json.dump(test_data, out)\n+    out.seek(0)\n+    rv = flask.json.load(out)\n+    assert rv == test_data\n+\n+\n+@pytest.mark.parametrize(\n+    \"test_value\", [0, -1, 1, 23, 3.14, \"s\", \"longer string\", True, False, None]\n+)\n+def test_jsonify_basic_types(test_value, app, client):\n+    url = \"/jsonify_basic_types\"\n+    app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n+    rv = client.get(url)\n+    assert rv.mimetype == \"application/json\"\n+    assert flask.json.loads(rv.data) == test_value\n+\n+\n+def test_jsonify_dicts(app, client):\n+    d = {\n+        \"a\": 0,\n+        \"b\": 23,\n+        \"c\": 3.14,\n+        \"d\": \"t\",\n+        \"e\": \"Hi\",\n+        \"f\": True,\n+        \"g\": False,\n+        \"h\": [\"test list\", 10, False],\n+        \"i\": {\"test\": \"dict\"},\n+    }\n+\n+    @app.route(\"/kw\")\n+    def return_kwargs():\n+        return flask.jsonify(**d)\n+\n+    @app.route(\"/dict\")\n+    def return_dict():\n+        return flask.jsonify(d)\n+\n+    for url in \"/kw\", \"/dict\":\n+        rv = client.get(url)\n+        assert rv.mimetype == \"application/json\"\n+        assert flask.json.loads(rv.data) == d\n+\n+\n+def test_jsonify_arrays(app, client):\n+    \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n+    a_list = [\n+        0,\n+        42,\n+        3.14,\n+        \"t\",\n+        \"hello\",\n+        True,\n+        False,\n+        [\"test list\", 2, False],\n+        {\"test\": \"dict\"},\n+    ]\n+\n+    @app.route(\"/args_unpack\")\n+    def return_args_unpack():\n+        return flask.jsonify(*a_list)\n+\n+    @app.route(\"/array\")\n+    def return_array():\n+        return flask.jsonify(a_list)\n+\n+    for url in \"/args_unpack\", \"/array\":\n+        rv = client.get(url)\n+        assert rv.mimetype == \"application/json\"\n+        assert flask.json.loads(rv.data) == a_list\n+\n+\n+def test_jsonifytypes(app, client):\n+    \"\"\"Test jsonify with datetime.date and datetime.datetime types.\"\"\"\n+    test_dates = (\n+        datetime.datetime(1973, 3, 11, 6, 30, 45),\n+        datetime.date(1975, 1, 5),\n+    )\n+\n+    for i, d in enumerate(test_dates):\n+        url = f\"/datetest{i}\"\n+        app.add_url_rule(url, str(i), lambda val=d: flask.jsonify(x=val))\n+        rv = client.get(url)\n+        assert rv.mimetype == \"application/json\"\n+        assert flask.json.loads(rv.data)[\"x\"] == http_date(d.timetuple())\n+\n+\n+class FixedOffset(datetime.tzinfo):\n+    \"\"\"Fixed offset in hours east from UTC.\n+\n+    This is a slight adaptation of the ``FixedOffset`` example found in\n+    https://docs.python.org/2.7/library/datetime.html.\n+    \"\"\"\n+\n+    def __init__(self, hours, name):\n+        self.__offset = datetime.timedelta(hours=hours)\n+        self.__name = name\n+\n+    def utcoffset(self, dt):\n+        return self.__offset\n+\n+    def tzname(self, dt):\n+        return self.__name\n+\n+    def dst(self, dt):\n+        return datetime.timedelta()\n+\n+\n+@pytest.mark.parametrize(\"tz\", ((\"UTC\", 0), (\"PST\", -8), (\"KST\", 9)))\n+def test_jsonify_aware_datetimes(tz):\n+    \"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"\n+    tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n+    dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n+    gmt = FixedOffset(hours=0, name=\"GMT\")\n+    expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n+    assert flask.json.JSONEncoder().encode(dt) == expected\n+\n+\n+def test_jsonify_uuid_types(app, client):\n+    \"\"\"Test jsonify with uuid.UUID types\"\"\"\n+\n+    test_uuid = uuid.UUID(bytes=b\"\\xDE\\xAD\\xBE\\xEF\" * 4)\n+    url = \"/uuid_test\"\n+    app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n+\n+    rv = client.get(url)\n+\n+    rv_x = flask.json.loads(rv.data)[\"x\"]\n+    assert rv_x == str(test_uuid)\n+    rv_uuid = uuid.UUID(rv_x)\n+    assert rv_uuid == test_uuid\n+\n+\n+def test_json_attr(app, client):\n+    @app.route(\"/add\", methods=[\"POST\"])\n+    def add():\n+        json = flask.request.get_json()\n+        return str(json[\"a\"] + json[\"b\"])\n+\n+    rv = client.post(\n+        \"/add\",\n+        data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n+        content_type=\"application/json\",\n+    )\n+    assert rv.data == b\"3\"\n+\n+\n+def test_template_escaping(app, req_ctx):\n+    render = flask.render_template_string\n+    rv = flask.json.htmlsafe_dumps(\"</script>\")\n+    assert rv == '\"\\\\u003c/script\\\\u003e\"'\n+    rv = render('{{ \"</script>\"|tojson }}')\n+    assert rv == '\"\\\\u003c/script\\\\u003e\"'\n+    rv = render('{{ \"<\\0/script>\"|tojson }}')\n+    assert rv == '\"\\\\u003c\\\\u0000/script\\\\u003e\"'\n+    rv = render('{{ \"<!--<script>\"|tojson }}')\n+    assert rv == '\"\\\\u003c!--\\\\u003cscript\\\\u003e\"'\n+    rv = render('{{ \"&\"|tojson }}')\n+    assert rv == '\"\\\\u0026\"'\n+    rv = render('{{ \"\\'\"|tojson }}')\n+    assert rv == '\"\\\\u0027\"'\n+    rv = render(\n+        \"<a ng-data='{{ data|tojson }}'></a>\", data={\"x\": [\"foo\", \"bar\", \"baz'\"]}\n+    )\n+    assert rv == '<a ng-data=\\'{\"x\": [\"foo\", \"bar\", \"baz\\\\u0027\"]}\\'></a>'\n+\n+\n+def test_json_customization(app, client):\n+    class X:  # noqa: B903, for Python2 compatibility\n+        def __init__(self, val):\n+            self.val = val\n+\n+    class MyEncoder(flask.json.JSONEncoder):\n+        def default(self, o):\n+            if isinstance(o, X):\n+                return f\"<{o.val}>\"\n+            return flask.json.JSONEncoder.default(self, o)\n+\n+    class MyDecoder(flask.json.JSONDecoder):\n+        def __init__(self, *args, **kwargs):\n+            kwargs.setdefault(\"object_hook\", self.object_hook)\n+            flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n+\n+        def object_hook(self, obj):\n+            if len(obj) == 1 and \"_foo\" in obj:\n+                return X(obj[\"_foo\"])\n+            return obj\n+\n+    app.json_encoder = MyEncoder\n+    app.json_decoder = MyDecoder\n+\n+    @app.route(\"/\", methods=[\"POST\"])\n+    def index():\n+        return flask.json.dumps(flask.request.get_json()[\"x\"])\n+\n+    rv = client.post(\n+        \"/\",\n+        data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n+        content_type=\"application/json\",\n+    )\n+    assert rv.data == b'\"<42>\"'\n+\n+\n+def test_blueprint_json_customization(app, client):\n+    class X:\n+        __slots__ = (\"val\",)\n+\n+        def __init__(self, val):\n+            self.val = val\n+\n+    class MyEncoder(flask.json.JSONEncoder):\n+        def default(self, o):\n+            if isinstance(o, X):\n+                return f\"<{o.val}>\"\n+\n+            return flask.json.JSONEncoder.default(self, o)\n+\n+    class MyDecoder(flask.json.JSONDecoder):\n+        def __init__(self, *args, **kwargs):\n+            kwargs.setdefault(\"object_hook\", self.object_hook)\n+            flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n+\n+        def object_hook(self, obj):\n+            if len(obj) == 1 and \"_foo\" in obj:\n+                return X(obj[\"_foo\"])\n+\n+            return obj\n+\n+    bp = flask.Blueprint(\"bp\", __name__)\n+    bp.json_encoder = MyEncoder\n+    bp.json_decoder = MyDecoder\n+\n+    @bp.route(\"/bp\", methods=[\"POST\"])\n+    def index():\n+        return flask.json.dumps(flask.request.get_json()[\"x\"])\n+\n+    app.register_blueprint(bp)\n+\n+    rv = client.post(\n+        \"/bp\",\n+        data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n+        content_type=\"application/json\",\n+    )\n+    assert rv.data == b'\"<42>\"'\n+\n+\n+def _has_encoding(name):\n+    try:\n+        import codecs\n+\n+        codecs.lookup(name)\n+        return True\n+    except LookupError:\n+        return False\n+\n+\n+@pytest.mark.skipif(\n+    not _has_encoding(\"euc-kr\"), reason=\"The euc-kr encoding is required.\"\n+)\n+def test_modified_url_encoding(app, client):\n+    class ModifiedRequest(flask.Request):\n+        url_charset = \"euc-kr\"\n+\n+    app.request_class = ModifiedRequest\n+    app.url_map.charset = \"euc-kr\"\n+\n+    @app.route(\"/\")\n+    def index():\n+        return flask.request.args[\"foo\"]\n+\n+    rv = client.get(\"/?foo=정상처리\".encode(\"euc-kr\"))\n+    assert rv.status_code == 200\n+    assert rv.data == \"정상처리\".encode()\n+\n+\n+def test_json_key_sorting(app, client):\n+    app.debug = True\n+\n+    assert app.config[\"JSON_SORT_KEYS\"]\n+    d = dict.fromkeys(range(20), \"foo\")\n+\n+    @app.route(\"/\")\n+    def index():\n+        return flask.jsonify(values=d)\n+\n+    rv = client.get(\"/\")\n+    lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n+    sorted_by_str = [\n+        \"{\",\n+        '\"values\": {',\n+        '\"0\": \"foo\",',\n+        '\"1\": \"foo\",',\n+        '\"10\": \"foo\",',\n+        '\"11\": \"foo\",',\n+        '\"12\": \"foo\",',\n+        '\"13\": \"foo\",',\n+        '\"14\": \"foo\",',\n+        '\"15\": \"foo\",',\n+        '\"16\": \"foo\",',\n+        '\"17\": \"foo\",',\n+        '\"18\": \"foo\",',\n+        '\"19\": \"foo\",',\n+        '\"2\": \"foo\",',\n+        '\"3\": \"foo\",',\n+        '\"4\": \"foo\",',\n+        '\"5\": \"foo\",',\n+        '\"6\": \"foo\",',\n+        '\"7\": \"foo\",',\n+        '\"8\": \"foo\",',\n+        '\"9\": \"foo\"',\n+        \"}\",\n+        \"}\",\n+    ]\n+    sorted_by_int = [\n+        \"{\",\n+        '\"values\": {',\n+        '\"0\": \"foo\",',\n+        '\"1\": \"foo\",',\n+        '\"2\": \"foo\",',\n+        '\"3\": \"foo\",',\n+        '\"4\": \"foo\",',\n+        '\"5\": \"foo\",',\n+        '\"6\": \"foo\",',\n+        '\"7\": \"foo\",',\n+        '\"8\": \"foo\",',\n+        '\"9\": \"foo\",',\n+        '\"10\": \"foo\",',\n+        '\"11\": \"foo\",',\n+        '\"12\": \"foo\",',\n+        '\"13\": \"foo\",',\n+        '\"14\": \"foo\",',\n+        '\"15\": \"foo\",',\n+        '\"16\": \"foo\",',\n+        '\"17\": \"foo\",',\n+        '\"18\": \"foo\",',\n+        '\"19\": \"foo\"',\n+        \"}\",\n+        \"}\",\n+    ]\n+\n+    try:\n+        assert lines == sorted_by_int\n+    except AssertionError:\n+        assert lines == sorted_by_str\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#6def8a4a489ce1321a44bc1947c5c86620afdb3f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 10 | Churn Cumulative: 412 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -6,6 +6,7 @@ import pytest\n from werkzeug.http import http_date\n \n import flask\n+from flask import json\n \n \n @pytest.mark.parametrize(\"debug\", (True, False))\n@@ -400,3 +401,12 @@ def test_json_key_sorting(app, client):\n         assert lines == sorted_by_int\n     except AssertionError:\n         assert lines == sorted_by_str\n+\n+\n+def test_html_method():\n+    class ObjectWithHTML:\n+        def __html__(self):\n+            return \"<p>test</p>\"\n+\n+    result = json.dumps(ObjectWithHTML())\n+    assert result == '\"<p>test</p>\"'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#373f0dd82e68ab7cac7a77344e715dbe68faebd3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 7 | Files Changed: 3 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 12 | Churn Cumulative: 5080 | Contributors (this commit): 44 | Commits (past 90d): 6 | Contributors (cumulative): 47 | DMM Complexity: None\n\nDIFF:\n@@ -451,16 +451,14 @@ class Blueprint(Scaffold):\n         return decorator\n \n     def app_url_value_preprocessor(self, f):\n-        \"\"\"Same as :meth:`url_value_preprocessor` but application wide.\n-        \"\"\"\n+        \"\"\"Same as :meth:`url_value_preprocessor` but application wide.\"\"\"\n         self.record_once(\n             lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)\n         )\n         return f\n \n     def app_url_defaults(self, f):\n-        \"\"\"Same as :meth:`url_defaults` but application wide.\n-        \"\"\"\n+        \"\"\"Same as :meth:`url_defaults` but application wide.\"\"\"\n         self.record_once(\n             lambda s: s.app.url_default_functions.setdefault(None, []).append(f)\n         )\n\n@@ -32,8 +32,7 @@ def setupmethod(f):\n \n \n class Scaffold(_PackageBoundObject):\n-    \"\"\"A common base for class Flask and class Blueprint.\n-    \"\"\"\n+    \"\"\"A common base for class Flask and class Blueprint.\"\"\"\n \n     #: Skeleton local JSON decoder class to use.\n     #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_encoder`.\n\n@@ -20,7 +20,8 @@ import flask\n \n \n require_cpython_gc = pytest.mark.skipif(\n-    python_implementation() != \"CPython\", reason=\"Requires CPython GC behavior\",\n+    python_implementation() != \"CPython\",\n+    reason=\"Requires CPython GC behavior\",\n )\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#7a444c5dab97d640282ec8fc4838bef2c128273f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 34 | Lines Deleted: 26 | Files Changed: 2 | Hunks: 10 | Methods Changed: 4 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 60 | Churn Cumulative: 548 | Contributors (this commit): 1 | Commits (past 90d): 4 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,9 +1,11 @@\n from contextlib import contextmanager\n+from copy import copy\n \n import werkzeug.test\n from click.testing import CliRunner\n from werkzeug.test import Client\n from werkzeug.urls import url_parse\n+from werkzeug.wrappers import BaseRequest\n \n from . import _request_ctx_stack\n from .cli import ScriptInfo\n@@ -159,39 +161,45 @@ class FlaskClient(Client):\n             headers = resp.get_wsgi_headers(c.request.environ)\n             self.cookie_jar.extract_wsgi(c.request.environ, headers)\n \n-    def open(self, *args, **kwargs):\n-        as_tuple = kwargs.pop(\"as_tuple\", False)\n-        buffered = kwargs.pop(\"buffered\", False)\n-        follow_redirects = kwargs.pop(\"follow_redirects\", False)\n-\n-        if (\n-            not kwargs\n-            and len(args) == 1\n-            and isinstance(args[0], (werkzeug.test.EnvironBuilder, dict))\n+    def open(\n+        self, *args, as_tuple=False, buffered=False, follow_redirects=False, **kwargs\n     ):\n-            environ = self.environ_base.copy()\n+        # Same logic as super.open, but apply environ_base and preserve_context.\n+        request = None\n \n-            if isinstance(args[0], werkzeug.test.EnvironBuilder):\n-                environ.update(args[0].get_environ())\n-            else:\n-                environ.update(args[0])\n+        def copy_environ(other):\n+            return {\n+                **self.environ_base,\n+                **other,\n+                \"flask._preserve_context\": self.preserve_context,\n+            }\n \n-            environ[\"flask._preserve_context\"] = self.preserve_context\n-        else:\n-            kwargs.setdefault(\"environ_overrides\", {})[\n-                \"flask._preserve_context\"\n-            ] = self.preserve_context\n-            kwargs.setdefault(\"environ_base\", self.environ_base)\n+        if not kwargs and len(args) == 1:\n+            arg = args[0]\n+\n+            if isinstance(arg, werkzeug.test.EnvironBuilder):\n+                builder = copy(arg)\n+                builder.environ_base = copy_environ(builder.environ_base or {})\n+                request = builder.get_request()\n+            elif isinstance(arg, dict):\n+                request = EnvironBuilder.from_environ(\n+                    arg, app=self.application, environ_base=copy_environ({})\n+                ).get_request()\n+            elif isinstance(arg, BaseRequest):\n+                request = copy(arg)\n+                request.environ = copy_environ(request.environ)\n+\n+        if request is None:\n+            kwargs[\"environ_base\"] = copy_environ(kwargs.get(\"environ_base\", {}))\n             builder = EnvironBuilder(self.application, *args, **kwargs)\n \n             try:\n-                environ = builder.get_environ()\n+                request = builder.get_request()\n             finally:\n                 builder.close()\n \n-        return Client.open(\n-            self,\n-            environ,\n+        return super().open(\n+            request,\n             as_tuple=as_tuple,\n             buffered=buffered,\n             follow_redirects=follow_redirects,\n\n@@ -327,9 +327,9 @@ def test_modified_url_encoding(app, client):\n     def index():\n         return flask.request.args[\"foo\"]\n \n-    rv = client.get(\"/?foo=정상처리\".encode(\"euc-kr\"))\n+    rv = client.get(\"/\", query_string={\"foo\": \"정상처리\"}, charset=\"euc-kr\")\n     assert rv.status_code == 200\n-    assert rv.data == \"정상처리\".encode()\n+    assert rv.get_data(as_text=True) == \"정상처리\"\n \n \n def test_json_key_sorting(app, client):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#22987b68173e9bf56cc450cb7aeb93f5480a2660", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 18 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 21 | Churn Cumulative: 4541 | Contributors (this commit): 43 | Commits (past 90d): 4 | Contributors (cumulative): 45 | DMM Complexity: 1.0\n\nDIFF:\n@@ -351,12 +351,16 @@ class SecureCookieSessionInterface(SessionInterface):\n         name = self.get_cookie_name(app)\n         domain = self.get_cookie_domain(app)\n         path = self.get_cookie_path(app)\n+        secure = self.get_cookie_secure(app)\n+        samesite = self.get_cookie_samesite(app)\n \n         # If the session is modified to be empty, remove the cookie.\n         # If the session is empty, return without setting the cookie.\n         if not session:\n             if session.modified:\n-                response.delete_cookie(name, domain=domain, path=path)\n+                response.delete_cookie(\n+                    name, domain=domain, path=path, secure=secure, samesite=samesite\n+                )\n \n             return\n \n@@ -368,8 +372,6 @@ class SecureCookieSessionInterface(SessionInterface):\n             return\n \n         httponly = self.get_cookie_httponly(app)\n-        secure = self.get_cookie_secure(app)\n-        samesite = self.get_cookie_samesite(app)\n         expires = self.get_expiration_time(app, session)\n         val = self.get_signing_serializer(app).dumps(dict(session))\n         response.set_cookie(\n\n@@ -322,6 +322,19 @@ def test_session_using_session_settings(app, client):\n     assert \"httponly\" not in cookie\n     assert \"samesite\" in cookie\n \n+    @app.route(\"/clear\")\n+    def clear():\n+        flask.session.pop(\"testing\", None)\n+        return \"Goodbye World\"\n+\n+    rv = client.get(\"/clear\", \"http://www.example.com:8080/test/\")\n+    cookie = rv.headers[\"set-cookie\"].lower()\n+    assert \"session=;\" in cookie\n+    assert \"domain=.example.com\" in cookie\n+    assert \"path=/\" in cookie\n+    assert \"secure\" in cookie\n+    assert \"samesite\" in cookie\n+\n \n def test_session_using_samesite_attribute(app, client):\n     @app.route(\"/\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#dc11cdb4a4627b9f8c79e47e39aa7e1357151896", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 209 | Lines Deleted: 618 | Files Changed: 5 | Hunks: 75 | Methods Changed: 34 | Complexity Δ (Sum/Max): -56/1 | Churn Δ: 827 | Churn Cumulative: 7080 | Contributors (this commit): 54 | Commits (past 90d): 9 | Contributors (cumulative): 73 | DMM Complexity: 0.48120300751879697\n\nDIFF:\n@@ -55,10 +55,11 @@ from .wrappers import Response\n \n \n def _make_timedelta(value):\n-    if not isinstance(value, timedelta):\n-        return timedelta(seconds=value)\n+    if value is None or isinstance(value, timedelta):\n         return value\n \n+    return timedelta(seconds=value)\n+\n \n class Flask(Scaffold):\n     \"\"\"The flask object implements a WSGI application and acts as the central\n@@ -234,13 +235,16 @@ class Flask(Scaffold):\n         \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n     )\n \n-    #: A :class:`~datetime.timedelta` which is used as default cache_timeout\n-    #: for the :func:`send_file` functions. The default is 12 hours.\n+    #: A :class:`~datetime.timedelta` or number of seconds which is used\n+    #: as the default ``max_age`` for :func:`send_file`. The default is\n+    #: ``None``, which tells the browser to use conditional requests\n+    #: instead of a timed cache.\n     #:\n-    #: This attribute can also be configured from the config with the\n-    #: ``SEND_FILE_MAX_AGE_DEFAULT`` configuration key. This configuration\n-    #: variable can also be set with an integer value used as seconds.\n-    #: Defaults to ``timedelta(hours=12)``\n+    #: Configured with the :data:`SEND_FILE_MAX_AGE_DEFAULT`\n+    #: configuration key.\n+    #:\n+    #: .. versionchanged:: 2.0\n+    #:     Defaults to ``None`` instead of 12 hours.\n     send_file_max_age_default = ConfigAttribute(\n         \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n     )\n@@ -297,7 +301,7 @@ class Flask(Scaffold):\n             \"SESSION_COOKIE_SAMESITE\": None,\n             \"SESSION_REFRESH_EACH_REQUEST\": True,\n             \"MAX_CONTENT_LENGTH\": None,\n-            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n+            \"SEND_FILE_MAX_AGE_DEFAULT\": None,\n             \"TRAP_BAD_REQUEST_ERRORS\": None,\n             \"TRAP_HTTP_EXCEPTIONS\": False,\n             \"EXPLAIN_TEMPLATE_LOADING\": False,\n\n@@ -1,24 +1,16 @@\n-import io\n-import mimetypes\n import os\n import pkgutil\n-import posixpath\n import socket\n import sys\n-import unicodedata\n+import warnings\n from functools import update_wrapper\n from threading import RLock\n-from time import time\n-from zlib import adler32\n \n+import werkzeug.utils\n from jinja2 import FileSystemLoader\n-from werkzeug.datastructures import Headers\n-from werkzeug.exceptions import BadRequest\n from werkzeug.exceptions import NotFound\n-from werkzeug.exceptions import RequestedRangeNotSatisfiable\n from werkzeug.routing import BuildError\n from werkzeug.urls import url_quote\n-from werkzeug.wsgi import wrap_file\n \n from .globals import _app_ctx_stack\n from .globals import _request_ctx_stack\n@@ -444,49 +436,116 @@ def get_flashed_messages(with_categories=False, category_filter=()):\n     return flashes\n \n \n+def _prepare_send_file_kwargs(\n+    download_name=None,\n+    attachment_filename=None,\n+    max_age=None,\n+    cache_timeout=None,\n+    **kwargs,\n+):\n+    if attachment_filename is not None:\n+        warnings.warn(\n+            \"The 'attachment_filename' parameter has been renamed to 'download_name'.\"\n+            \" The old name will be removed in Flask 2.1.\",\n+            DeprecationWarning,\n+            stacklevel=3,\n+        )\n+        download_name = attachment_filename\n+\n+    if cache_timeout is not None:\n+        warnings.warn(\n+            \"The 'cache_timeout' parameter has been renamed to 'max_age'. The old name\"\n+            \" will be removed in Flask 2.1.\",\n+            DeprecationWarning,\n+            stacklevel=3,\n+        )\n+        max_age = cache_timeout\n+\n+    if max_age is None:\n+        max_age = current_app.get_send_file_max_age\n+\n+    kwargs.update(\n+        environ=request.environ,\n+        download_name=download_name,\n+        max_age=max_age,\n+        use_x_sendfile=current_app.use_x_sendfile,\n+        response_class=current_app.response_class,\n+        _root_path=current_app.root_path,\n+    )\n+    return kwargs\n+\n+\n def send_file(\n-    filename_or_fp,\n+    path_or_file,\n     mimetype=None,\n     as_attachment=False,\n+    download_name=None,\n     attachment_filename=None,\n+    conditional=True,\n     add_etags=True,\n-    cache_timeout=None,\n-    conditional=False,\n     last_modified=None,\n+    max_age=None,\n+    cache_timeout=None,\n ):\n-    \"\"\"Sends the contents of a file to the client.  This will use the\n-    most efficient method available and configured.  By default it will\n-    try to use the WSGI server's file_wrapper support.  Alternatively\n-    you can set the application's :attr:`~Flask.use_x_sendfile` attribute\n-    to ``True`` to directly emit an ``X-Sendfile`` header.  This however\n-    requires support of the underlying webserver for ``X-Sendfile``.\n+    \"\"\"Send the contents of a file to the client.\n \n-    By default it will try to guess the mimetype for you, but you can\n-    also explicitly provide one.  For extra security you probably want\n-    to send certain files as attachment (HTML for instance).  The mimetype\n-    guessing requires a `filename` or an `attachment_filename` to be\n-    provided.\n+    The first argument can be a file path or a file-like object. Paths\n+    are preferred in most cases because Werkzeug can manage the file and\n+    get extra information from the path. Passing a file-like object\n+    requires that the file is opened in binary mode, and is mostly\n+    useful when building a file in memory with :class:`io.BytesIO`.\n \n-    When passing a file-like object instead of a filename, only binary\n-    mode is supported (``open(filename, \"rb\")``, :class:`~io.BytesIO`,\n-    etc.). Text mode files and :class:`~io.StringIO` will raise a\n-    :exc:`ValueError`.\n+    Never pass file paths provided by a user. The path is assumed to be\n+    trusted, so a user could craft a path to access a file you didn't\n+    intend. Use :func:`send_from_directory` to safely serve\n+    user-requested paths from within a directory.\n \n-    ETags will also be attached automatically if a `filename` is provided. You\n-    can turn this off by setting `add_etags=False`.\n+    If the WSGI server sets a ``file_wrapper`` in ``environ``, it is\n+    used, otherwise Werkzeug's built-in wrapper is used. Alternatively,\n+    if the HTTP server supports ``X-Sendfile``, configuring Flask with\n+    ``USE_X_SENDFILE = True`` will tell the server to send the given\n+    path, which is much more efficient than reading it in Python.\n \n-    If `conditional=True` and `filename` is provided, this method will try to\n-    upgrade the response stream to support range requests.  This will allow\n-    the request to be answered with partial content response.\n+    :param path_or_file: The path to the file to send, relative to the\n+        current working directory if a relative path is given.\n+        Alternatively, a file-like object opened in binary mode. Make\n+        sure the file pointer is seeked to the start of the data.\n+    :param mimetype: The MIME type to send for the file. If not\n+        provided, it will try to detect it from the file name.\n+    :param as_attachment: Indicate to a browser that it should offer to\n+        save the file instead of displaying it.\n+    :param download_name: The default name browsers will use when saving\n+        the file. Defaults to the passed file name.\n+    :param conditional: Enable conditional and range responses based on\n+        request headers. Requires passing a file path and ``environ``.\n+    :param add_etags: Calculate an ETag for the file. Requires passing a\n+        file path.\n+    :param last_modified: The last modified time to send for the file,\n+        in seconds. If not provided, it will try to detect it from the\n+        file path.\n+    :param max_age: How long the client should cache the file, in\n+        seconds. If set, ``Cache-Control`` will be ``public``, otherwise\n+        it will be ``no-cache`` to prefer conditional caching.\n \n-    Please never pass filenames to this function from user sources;\n-    you should use :func:`send_from_directory` instead.\n+    .. versionchanged:: 2.0\n+        ``download_name`` replaces the ``attachment_filename``\n+        parameter. If ``as_attachment=False``, it is passed with\n+        ``Content-Disposition: inline`` instead.\n+\n+    .. versionchanged:: 2.0\n+        ``max_age`` replaces the ``cache_timeout`` parameter.\n+        ``conditional`` is enabled and ``max_age`` is not set by\n+        default.\n \n     .. versionchanged:: 2.0\n         Passing a file-like object that inherits from\n         :class:`~io.TextIOBase` will raise a :exc:`ValueError` rather\n         than sending an empty file.\n \n+    .. versionadded:: 2.0\n+        Moved the implementation to Werkzeug. This is now a wrapper to\n+        pass some Flask-specific arguments.\n+\n     .. versionchanged:: 1.1\n         ``filename`` may be a :class:`~os.PathLike` object.\n \n@@ -498,14 +557,13 @@ def send_file(\n         compatibility with WSGI servers.\n \n     .. versionchanged:: 1.0\n-        UTF-8 filenames, as specified in `RFC 2231`_, are supported.\n-\n-    .. _RFC 2231: https://tools.ietf.org/html/rfc2231#section-4\n+        UTF-8 filenames as specified in :rfc:`2231` are supported.\n \n     .. versionchanged:: 0.12\n         The filename is no longer automatically inferred from file\n-       objects. If you want to use automatic MIME and etag support, pass\n-       a filename via ``filename_or_fp`` or ``attachment_filename``.\n+        objects. If you want to use automatic MIME and etag support,\n+        pass a filename via ``filename_or_fp`` or\n+        ``attachment_filename``.\n \n     .. versionchanged:: 0.12\n         ``attachment_filename`` is preferred over ``filename`` for MIME\n@@ -518,240 +576,87 @@ def send_file(\n     .. versionchanged:: 0.7\n         MIME guessing and etag support for file-like objects was\n         deprecated because it was unreliable. Pass a filename if you are\n-       able to, otherwise attach an etag yourself. This functionality\n-       will be removed in Flask 1.0.\n+        able to, otherwise attach an etag yourself.\n \n-    .. versionadded:: 0.5\n+    .. versionchanged:: 0.5\n         The ``add_etags``, ``cache_timeout`` and ``conditional``\n         parameters were added. The default behavior is to add etags.\n \n     .. versionadded:: 0.2\n-\n-    :param filename_or_fp: The filename of the file to send, relative to\n-        :attr:`~Flask.root_path` if a relative path is specified.\n-        Alternatively, a file-like object opened in binary mode. Make\n-        sure the file pointer is seeked to the start of the data.\n-        ``X-Sendfile`` will only be used with filenames.\n-    :param mimetype: the mimetype of the file if provided. If a file path is\n-                     given, auto detection happens as fallback, otherwise an\n-                     error will be raised.\n-    :param as_attachment: set to ``True`` if you want to send this file with\n-                          a ``Content-Disposition: attachment`` header.\n-    :param attachment_filename: the filename for the attachment if it\n-                                differs from the file's filename.\n-    :param add_etags: set to ``False`` to disable attaching of etags.\n-    :param conditional: set to ``True`` to enable conditional responses.\n-\n-    :param cache_timeout: the timeout in seconds for the headers. When ``None``\n-                          (default), this value is set by\n-                          :meth:`~Flask.get_send_file_max_age` of\n-                          :data:`~flask.current_app`.\n-    :param last_modified: set the ``Last-Modified`` header to this value,\n-        a :class:`~datetime.datetime` or timestamp.\n-        If a file was passed, this overrides its mtime.\n     \"\"\"\n-    mtime = None\n-    fsize = None\n-\n-    if hasattr(filename_or_fp, \"__fspath__\"):\n-        filename_or_fp = os.fspath(filename_or_fp)\n-\n-    if isinstance(filename_or_fp, str):\n-        filename = filename_or_fp\n-        if not os.path.isabs(filename):\n-            filename = os.path.join(current_app.root_path, filename)\n-        file = None\n-        if attachment_filename is None:\n-            attachment_filename = os.path.basename(filename)\n-    else:\n-        file = filename_or_fp\n-        filename = None\n-\n-    if mimetype is None:\n-        if attachment_filename is not None:\n-            mimetype = (\n-                mimetypes.guess_type(attachment_filename)[0]\n-                or \"application/octet-stream\"\n+    return werkzeug.utils.send_file(\n+        **_prepare_send_file_kwargs(\n+            path_or_file=path_or_file,\n+            environ=request.environ,\n+            mimetype=mimetype,\n+            as_attachment=as_attachment,\n+            download_name=download_name,\n+            attachment_filename=attachment_filename,\n+            conditional=conditional,\n+            add_etags=add_etags,\n+            last_modified=last_modified,\n+            max_age=max_age,\n+            cache_timeout=cache_timeout,\n         )\n-\n-        if mimetype is None:\n-            raise ValueError(\n-                \"Unable to infer MIME-type because no filename is available. \"\n-                \"Please set either `attachment_filename`, pass a filepath to \"\n-                \"`filename_or_fp` or set your own MIME-type via `mimetype`.\"\n     )\n \n-    headers = Headers()\n-    if as_attachment:\n-        if attachment_filename is None:\n-            raise TypeError(\"filename unavailable, required for sending as attachment\")\n-\n-        if not isinstance(attachment_filename, str):\n-            attachment_filename = attachment_filename.decode(\"utf-8\")\n-\n-        try:\n-            attachment_filename = attachment_filename.encode(\"ascii\")\n-        except UnicodeEncodeError:\n-            quoted = url_quote(attachment_filename, safe=\"\")\n-            filenames = {\n-                \"filename\": unicodedata.normalize(\"NFKD\", attachment_filename).encode(\n-                    \"ascii\", \"ignore\"\n-                ),\n-                \"filename*\": f\"UTF-8''{quoted}\",\n-            }\n-        else:\n-            filenames = {\"filename\": attachment_filename}\n-\n-        headers.add(\"Content-Disposition\", \"attachment\", **filenames)\n-\n-    if current_app.use_x_sendfile and filename:\n-        if file is not None:\n-            file.close()\n-\n-        headers[\"X-Sendfile\"] = filename\n-        fsize = os.path.getsize(filename)\n-        data = None\n-    else:\n-        if file is None:\n-            file = open(filename, \"rb\")\n-            mtime = os.path.getmtime(filename)\n-            fsize = os.path.getsize(filename)\n-        elif isinstance(file, io.BytesIO):\n-            fsize = file.getbuffer().nbytes\n-        elif isinstance(file, io.TextIOBase):\n-            raise ValueError(\"Files must be opened in binary mode or use BytesIO.\")\n-\n-        data = wrap_file(request.environ, file)\n-\n-    if fsize is not None:\n-        headers[\"Content-Length\"] = fsize\n-\n-    rv = current_app.response_class(\n-        data, mimetype=mimetype, headers=headers, direct_passthrough=True\n-    )\n-\n-    if last_modified is not None:\n-        rv.last_modified = last_modified\n-    elif mtime is not None:\n-        rv.last_modified = mtime\n-\n-    rv.cache_control.public = True\n-    if cache_timeout is None:\n-        cache_timeout = current_app.get_send_file_max_age(filename)\n-    if cache_timeout is not None:\n-        rv.cache_control.max_age = cache_timeout\n-        rv.expires = int(time() + cache_timeout)\n-\n-    if add_etags and filename is not None:\n-        from warnings import warn\n-\n-        try:\n-            check = (\n-                adler32(\n-                    filename.encode(\"utf-8\") if isinstance(filename, str) else filename\n-                )\n-                & 0xFFFFFFFF\n-            )\n-            rv.set_etag(\n-                f\"{os.path.getmtime(filename)}-{os.path.getsize(filename)}-{check}\"\n-            )\n-        except OSError:\n-            warn(\n-                f\"Access {filename} failed, maybe it does not exist, so\"\n-                \" ignore etags in headers\",\n-                stacklevel=2,\n-            )\n-\n-    if conditional:\n-        try:\n-            rv = rv.make_conditional(request, accept_ranges=True, complete_length=fsize)\n-        except RequestedRangeNotSatisfiable:\n-            if file is not None:\n-                file.close()\n-            raise\n-        # make sure we don't send x-sendfile for servers that\n-        # ignore the 304 status code for x-sendfile.\n-        if rv.status_code == 304:\n-            rv.headers.pop(\"x-sendfile\", None)\n-    return rv\n-\n \n def safe_join(directory, *pathnames):\n-    \"\"\"Safely join `directory` and zero or more untrusted `pathnames`\n-    components.\n+    \"\"\"Safely join zero or more untrusted path components to a base\n+    directory to avoid escaping the base directory.\n \n-    Example usage::\n-\n-        @app.route('/wiki/<path:filename>')\n-        def wiki_page(filename):\n-            filename = safe_join(app.config['WIKI_FOLDER'], filename)\n-            with open(filename, 'rb') as fd:\n-                content = fd.read()  # Read and process the file content...\n-\n-    :param directory: the trusted base directory.\n-    :param pathnames: the untrusted pathnames relative to that directory.\n-    :raises: :class:`~werkzeug.exceptions.NotFound` if one or more passed\n-            paths fall out of its boundaries.\n+    :param directory: The trusted base directory.\n+    :param pathnames: The untrusted path components relative to the\n+        base directory.\n+    :return: A safe path, otherwise ``None``.\n     \"\"\"\n+    warnings.warn(\n+        \"'flask.helpers.safe_join' is deprecated and will be removed in\"\n+        \" 2.1. Use 'werkzeug.utils.safe_join' instead.\",\n+        DeprecationWarning,\n+        stacklevel=2,\n+    )\n+    path = werkzeug.utils.safe_join(directory, *pathnames)\n \n-    parts = [directory]\n-\n-    for filename in pathnames:\n-        if filename != \"\":\n-            filename = posixpath.normpath(filename)\n-\n-        if (\n-            any(sep in filename for sep in _os_alt_seps)\n-            or os.path.isabs(filename)\n-            or filename == \"..\"\n-            or filename.startswith(\"../\")\n-        ):\n+    if path is None:\n         raise NotFound()\n \n-        parts.append(filename)\n-\n-    return posixpath.join(*parts)\n+    return path\n \n \n-def send_from_directory(directory, filename, **options):\n-    \"\"\"Send a file from a given directory with :func:`send_file`.  This\n-    is a secure way to quickly expose static files from an upload folder\n-    or something similar.\n+def send_from_directory(directory, path, **kwargs):\n+    \"\"\"Send a file from within a directory using :func:`send_file`.\n \n-    Example usage::\n+    .. code-block:: python\n \n-        @app.route('/uploads/<path:filename>')\n-        def download_file(filename):\n-            return send_from_directory(app.config['UPLOAD_FOLDER'],\n-                                       filename, as_attachment=True)\n+        @app.route(\"/uploads/<path:name>\")\n+        def download_file(name):\n+            return send_from_directory(\n+                app.config['UPLOAD_FOLDER'], name, as_attachment=True\n+            )\n \n-    .. admonition:: Sending files and Performance\n+    This is a secure way to serve files from a folder, such as static\n+    files or uploads. Uses :func:`~werkzeug.security.safe_join` to\n+    ensure the path coming from the client is not maliciously crafted to\n+    point outside the specified directory.\n \n-       It is strongly recommended to activate either ``X-Sendfile`` support in\n-       your webserver or (if no authentication happens) to tell the webserver\n-       to serve files for the given path on its own without calling into the\n-       web application for improved performance.\n+    If the final path does not point to an existing regular file,\n+    raises a 404 :exc:`~werkzeug.exceptions.NotFound` error.\n+\n+    :param directory: The directory that ``path`` must be located under.\n+    :param path: The path to the file to send, relative to\n+        ``directory``.\n+    :param kwargs: Arguments to pass to :func:`send_file`.\n+\n+    .. versionadded:: 2.0\n+        Moved the implementation to Werkzeug. This is now a wrapper to\n+        pass some Flask-specific arguments.\n \n     .. versionadded:: 0.5\n-\n-    :param directory: the directory where all the files are stored.\n-    :param filename: the filename relative to that directory to\n-                     download.\n-    :param options: optional keyword arguments that are directly\n-                    forwarded to :func:`send_file`.\n     \"\"\"\n-    filename = os.fspath(filename)\n-    directory = os.fspath(directory)\n-    filename = safe_join(directory, filename)\n-    if not os.path.isabs(filename):\n-        filename = os.path.join(current_app.root_path, filename)\n-    try:\n-        if not os.path.isfile(filename):\n-            raise NotFound()\n-    except (TypeError, ValueError):\n-        raise BadRequest()\n-    options.setdefault(\"conditional\", True)\n-    return send_file(filename, **options)\n+    return werkzeug.utils.send_from_directory(\n+        directory, path, **_prepare_send_file_kwargs(**kwargs)\n+    )\n \n \n def get_root_path(import_name):\n@@ -1016,30 +921,25 @@ class _PackageBoundObject:\n             return FileSystemLoader(os.path.join(self.root_path, self.template_folder))\n \n     def get_send_file_max_age(self, filename):\n-        \"\"\"Provides default cache_timeout for the :func:`send_file` functions.\n+        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n+        value for a given file path if it wasn't passed.\n \n-        By default, this function returns ``SEND_FILE_MAX_AGE_DEFAULT`` from\n-        the configuration of :data:`~flask.current_app`.\n+        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n+        the configuration of :data:`~flask.current_app`. This defaults\n+        to ``None``, which tells the browser to use conditional requests\n+        instead of a timed cache, which is usually preferable.\n \n-        Static file functions such as :func:`send_from_directory` use this\n-        function, and :func:`send_file` calls this function on\n-        :data:`~flask.current_app` when the given cache_timeout is ``None``. If a\n-        cache_timeout is given in :func:`send_file`, that timeout is used;\n-        otherwise, this method is called.\n-\n-        This allows subclasses to change the behavior when sending files based\n-        on the filename.  For example, to set the cache timeout for .js files\n-        to 60 seconds::\n-\n-            class MyFlask(flask.Flask):\n-                def get_send_file_max_age(self, name):\n-                    if name.lower().endswith('.js'):\n-                        return 60\n-                    return flask.Flask.get_send_file_max_age(self, name)\n+        .. versionchanged:: 2.0\n+            The default configuration is ``None`` instead of 12 hours.\n \n         .. versionadded:: 0.9\n         \"\"\"\n-        return total_seconds(current_app.send_file_max_age_default)\n+        value = current_app.send_file_max_age_default\n+\n+        if value is None:\n+            return None\n+\n+        return total_seconds(value)\n \n     def send_static_file(self, filename):\n         \"\"\"Function used internally to send static files from the static\n@@ -1049,12 +949,11 @@ class _PackageBoundObject:\n         \"\"\"\n         if not self.has_static_folder:\n             raise RuntimeError(\"No static folder for this object\")\n-        # Ensure get_send_file_max_age is called in all cases.\n-        # Here, we ensure get_send_file_max_age is called for Blueprints.\n-        cache_timeout = self.get_send_file_max_age(filename)\n-        return send_from_directory(\n-            self.static_folder, filename, cache_timeout=cache_timeout\n-        )\n+\n+        # send_file only knows to call get_send_file_max_age on the app,\n+        # call it here so it works for blueprints too.\n+        max_age = self.get_send_file_max_age(filename)\n+        return send_from_directory(self.static_folder, filename, max_age=max_age)\n \n     def open_resource(self, resource, mode=\"rb\"):\n         \"\"\"Opens a resource from the application's resource folder.  To see\n\n@@ -222,7 +222,7 @@ def test_templates_and_static(test_apps):\n         assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"\n \n \n-def test_default_static_cache_timeout(app):\n+def test_default_static_max_age(app):\n     class MyBlueprint(flask.Blueprint):\n         def get_send_file_max_age(self, filename):\n             return 100\n\n@@ -1,15 +1,7 @@\n-import datetime\n import io\n import os\n-import sys\n \n import pytest\n-from werkzeug.datastructures import Range\n-from werkzeug.exceptions import BadRequest\n-from werkzeug.exceptions import NotFound\n-from werkzeug.http import http_date\n-from werkzeug.http import parse_cache_control_header\n-from werkzeug.http import parse_options_header\n \n import flask\n from flask.helpers import get_debug_flag\n@@ -39,278 +31,45 @@ class PyBytesIO:\n \n \n class TestSendfile:\n-    def test_send_file_regular(self, app, req_ctx):\n+    def test_send_file(self, app, req_ctx):\n         rv = flask.send_file(\"static/index.html\")\n         assert rv.direct_passthrough\n         assert rv.mimetype == \"text/html\"\n+\n         with app.open_resource(\"static/index.html\") as f:\n             rv.direct_passthrough = False\n             assert rv.data == f.read()\n+\n         rv.close()\n \n-    def test_send_file_xsendfile(self, app, req_ctx):\n-        app.use_x_sendfile = True\n-        rv = flask.send_file(\"static/index.html\")\n-        assert rv.direct_passthrough\n-        assert \"x-sendfile\" in rv.headers\n-        assert rv.headers[\"x-sendfile\"] == os.path.join(\n-            app.root_path, \"static/index.html\"\n-        )\n-        assert rv.mimetype == \"text/html\"\n-        rv.close()\n-\n-    def test_send_file_last_modified(self, app, client):\n-        last_modified = datetime.datetime(1999, 1, 1)\n-\n-        @app.route(\"/\")\n-        def index():\n-            return flask.send_file(\n-                io.BytesIO(b\"party like it's\"),\n-                last_modified=last_modified,\n-                mimetype=\"text/plain\",\n-            )\n-\n-        rv = client.get(\"/\")\n-        assert rv.last_modified == last_modified\n-\n-    def test_send_file_object_without_mimetype(self, app, req_ctx):\n-        with pytest.raises(ValueError) as excinfo:\n-            flask.send_file(io.BytesIO(b\"LOL\"))\n-        assert \"Unable to infer MIME-type\" in str(excinfo.value)\n-        assert \"no filename is available\" in str(excinfo.value)\n-\n-        flask.send_file(io.BytesIO(b\"LOL\"), attachment_filename=\"filename\")\n-\n-    @pytest.mark.parametrize(\n-        \"opener\",\n-        [\n-            lambda app: open(os.path.join(app.static_folder, \"index.html\"), \"rb\"),\n-            lambda app: io.BytesIO(b\"Test\"),\n-            lambda app: PyBytesIO(b\"Test\"),\n-        ],\n-    )\n-    @pytest.mark.usefixtures(\"req_ctx\")\n-    def test_send_file_object(self, app, opener):\n-        file = opener(app)\n-        app.use_x_sendfile = True\n-        rv = flask.send_file(file, mimetype=\"text/plain\")\n-        rv.direct_passthrough = False\n-        assert rv.data\n-        assert rv.mimetype == \"text/plain\"\n-        assert \"x-sendfile\" not in rv.headers\n-        rv.close()\n-\n-    @pytest.mark.parametrize(\n-        \"opener\",\n-        [\n-            lambda app: io.StringIO(\"Test\"),\n-            lambda app: open(os.path.join(app.static_folder, \"index.html\")),\n-        ],\n-    )\n-    @pytest.mark.usefixtures(\"req_ctx\")\n-    def test_send_file_text_fails(self, app, opener):\n-        file = opener(app)\n-\n-        with pytest.raises(ValueError):\n-            flask.send_file(file, mimetype=\"text/plain\")\n-\n-        file.close()\n-\n-    def test_send_file_pathlike(self, app, req_ctx):\n-        rv = flask.send_file(FakePath(\"static/index.html\"))\n-        assert rv.direct_passthrough\n-        assert rv.mimetype == \"text/html\"\n-        with app.open_resource(\"static/index.html\") as f:\n-            rv.direct_passthrough = False\n-            assert rv.data == f.read()\n-        rv.close()\n-\n-    @pytest.mark.skipif(\n-        not callable(getattr(Range, \"to_content_range_header\", None)),\n-        reason=\"not implemented within werkzeug\",\n-    )\n-    def test_send_file_range_request(self, app, client):\n-        @app.route(\"/\")\n-        def index():\n-            return flask.send_file(\"static/index.html\", conditional=True)\n-\n-        rv = client.get(\"/\", headers={\"Range\": \"bytes=4-15\"})\n-        assert rv.status_code == 206\n-        with app.open_resource(\"static/index.html\") as f:\n-            assert rv.data == f.read()[4:16]\n-        rv.close()\n-\n-        rv = client.get(\"/\", headers={\"Range\": \"bytes=4-\"})\n-        assert rv.status_code == 206\n-        with app.open_resource(\"static/index.html\") as f:\n-            assert rv.data == f.read()[4:]\n-        rv.close()\n-\n-        rv = client.get(\"/\", headers={\"Range\": \"bytes=4-1000\"})\n-        assert rv.status_code == 206\n-        with app.open_resource(\"static/index.html\") as f:\n-            assert rv.data == f.read()[4:]\n-        rv.close()\n-\n-        rv = client.get(\"/\", headers={\"Range\": \"bytes=-10\"})\n-        assert rv.status_code == 206\n-        with app.open_resource(\"static/index.html\") as f:\n-            assert rv.data == f.read()[-10:]\n-        rv.close()\n-\n-        rv = client.get(\"/\", headers={\"Range\": \"bytes=1000-\"})\n-        assert rv.status_code == 416\n-        rv.close()\n-\n-        rv = client.get(\"/\", headers={\"Range\": \"bytes=-\"})\n-        assert rv.status_code == 416\n-        rv.close()\n-\n-        rv = client.get(\"/\", headers={\"Range\": \"somethingsomething\"})\n-        assert rv.status_code == 416\n-        rv.close()\n-\n-        last_modified = datetime.datetime.utcfromtimestamp(\n-            os.path.getmtime(os.path.join(app.root_path, \"static/index.html\"))\n-        ).replace(microsecond=0)\n-\n-        rv = client.get(\n-            \"/\", headers={\"Range\": \"bytes=4-15\", \"If-Range\": http_date(last_modified)}\n-        )\n-        assert rv.status_code == 206\n-        rv.close()\n-\n-        rv = client.get(\n-            \"/\",\n-            headers={\n-                \"Range\": \"bytes=4-15\",\n-                \"If-Range\": http_date(datetime.datetime(1999, 1, 1)),\n-            },\n-        )\n-        assert rv.status_code == 200\n-        rv.close()\n-\n-    def test_send_file_range_request_bytesio(self, app, client):\n-        @app.route(\"/\")\n-        def index():\n-            file = io.BytesIO(b\"somethingsomething\")\n-            return flask.send_file(\n-                file, attachment_filename=\"filename\", conditional=True\n-            )\n-\n-        rv = client.get(\"/\", headers={\"Range\": \"bytes=4-15\"})\n-        assert rv.status_code == 206\n-        assert rv.data == b\"somethingsomething\"[4:16]\n-        rv.close()\n-\n-    def test_send_file_range_request_xsendfile_invalid(self, app, client):\n-        # https://github.com/pallets/flask/issues/2526\n-        app.use_x_sendfile = True\n-\n-        @app.route(\"/\")\n-        def index():\n-            return flask.send_file(\"static/index.html\", conditional=True)\n-\n-        rv = client.get(\"/\", headers={\"Range\": \"bytes=1000-\"})\n-        assert rv.status_code == 416\n-        rv.close()\n-\n-    def test_attachment(self, app, req_ctx):\n-        app = flask.Flask(__name__)\n-        with app.test_request_context():\n-            with open(os.path.join(app.root_path, \"static/index.html\"), \"rb\") as f:\n-                rv = flask.send_file(\n-                    f, as_attachment=True, attachment_filename=\"index.html\"\n-                )\n-                value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n-                assert value == \"attachment\"\n-                rv.close()\n-\n-        with open(os.path.join(app.root_path, \"static/index.html\"), \"rb\") as f:\n-            rv = flask.send_file(\n-                f, as_attachment=True, attachment_filename=\"index.html\"\n-            )\n-            value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n-            assert value == \"attachment\"\n-            assert options[\"filename\"] == \"index.html\"\n-            assert \"filename*\" not in rv.headers[\"Content-Disposition\"]\n-            rv.close()\n-\n-        rv = flask.send_file(\"static/index.html\", as_attachment=True)\n-        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n-        assert value == \"attachment\"\n-        assert options[\"filename\"] == \"index.html\"\n-        rv.close()\n-\n-        rv = flask.send_file(\n-            io.BytesIO(b\"Test\"),\n-            as_attachment=True,\n-            attachment_filename=\"index.txt\",\n-            add_etags=False,\n-        )\n-        assert rv.mimetype == \"text/plain\"\n-        value, options = parse_options_header(rv.headers[\"Content-Disposition\"])\n-        assert value == \"attachment\"\n-        assert options[\"filename\"] == \"index.txt\"\n-        rv.close()\n-\n-    @pytest.mark.usefixtures(\"req_ctx\")\n-    @pytest.mark.parametrize(\n-        (\"filename\", \"ascii\", \"utf8\"),\n-        (\n-            (\"index.html\", \"index.html\", False),\n-            (\n-                \"Ñandú／pingüino.txt\",\n-                '\"Nandu/pinguino.txt\"',\n-                \"%C3%91and%C3%BA%EF%BC%8Fping%C3%BCino.txt\",\n-            ),\n-            (\"Vögel.txt\", \"Vogel.txt\", \"V%C3%B6gel.txt\"),\n-            # \":/\" are not safe in filename* value\n-            (\"те:/ст\", '\":/\"', \"%D1%82%D0%B5%3A%2F%D1%81%D1%82\"),\n-        ),\n-    )\n-    def test_attachment_filename_encoding(self, filename, ascii, utf8):\n-        rv = flask.send_file(\n-            \"static/index.html\", as_attachment=True, attachment_filename=filename\n-        )\n-        rv.close()\n-        content_disposition = rv.headers[\"Content-Disposition\"]\n-        assert f\"filename={ascii}\" in content_disposition\n-        if utf8:\n-            assert f\"filename*=UTF-8''{utf8}\" in content_disposition\n-        else:\n-            assert \"filename*=UTF-8''\" not in content_disposition\n-\n     def test_static_file(self, app, req_ctx):\n-        # default cache timeout is 12 hours\n+        # Default max_age is None.\n \n         # Test with static file handler.\n         rv = app.send_static_file(\"index.html\")\n-        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n-        assert cc.max_age == 12 * 60 * 60\n+        assert rv.cache_control.max_age is None\n         rv.close()\n-        # Test again with direct use of send_file utility.\n+\n+        # Test with direct use of send_file.\n         rv = flask.send_file(\"static/index.html\")\n-        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n-        assert cc.max_age == 12 * 60 * 60\n+        assert rv.cache_control.max_age is None\n         rv.close()\n+\n         app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n \n         # Test with static file handler.\n         rv = app.send_static_file(\"index.html\")\n-        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n-        assert cc.max_age == 3600\n-        rv.close()\n-        # Test again with direct use of send_file utility.\n-        rv = flask.send_file(\"static/index.html\")\n-        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n-        assert cc.max_age == 3600\n+        assert rv.cache_control.max_age == 3600\n         rv.close()\n \n-        # Test with static file handler.\n+        # Test with direct use of send_file.\n+        rv = flask.send_file(\"static/index.html\")\n+        assert rv.cache_control.max_age == 3600\n+        rv.close()\n+\n+        # Test with pathlib.Path.\n         rv = app.send_static_file(FakePath(\"index.html\"))\n-        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n-        assert cc.max_age == 3600\n+        assert rv.cache_control.max_age == 3600\n         rv.close()\n \n         class StaticFileApp(flask.Flask):\n@@ -318,16 +77,16 @@ class TestSendfile:\n                 return 10\n \n         app = StaticFileApp(__name__)\n+\n         with app.test_request_context():\n             # Test with static file handler.\n             rv = app.send_static_file(\"index.html\")\n-            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n-            assert cc.max_age == 10\n+            assert rv.cache_control.max_age == 10\n             rv.close()\n-            # Test again with direct use of send_file utility.\n+\n+            # Test with direct use of send_file.\n             rv = flask.send_file(\"static/index.html\")\n-            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n-            assert cc.max_age == 10\n+            assert rv.cache_control.max_age == 10\n             rv.close()\n \n     def test_send_from_directory(self, app, req_ctx):\n@@ -339,28 +98,6 @@ class TestSendfile:\n         assert rv.data.strip() == b\"Hello Subdomain\"\n         rv.close()\n \n-    def test_send_from_directory_pathlike(self, app, req_ctx):\n-        app.root_path = os.path.join(\n-            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n-        )\n-        rv = flask.send_from_directory(FakePath(\"static\"), FakePath(\"hello.txt\"))\n-        rv.direct_passthrough = False\n-        assert rv.data.strip() == b\"Hello Subdomain\"\n-        rv.close()\n-\n-    def test_send_from_directory_null_character(self, app, req_ctx):\n-        app.root_path = os.path.join(\n-            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n-        )\n-\n-        if sys.version_info >= (3, 8):\n-            exception = NotFound\n-        else:\n-            exception = BadRequest\n-\n-        with pytest.raises(exception):\n-            flask.send_from_directory(\"static\", \"bad\\x00\")\n-\n \n class TestUrlFor:\n     def test_url_for_with_anchor(self, app, req_ctx):\n@@ -514,47 +251,6 @@ class TestStreaming:\n         assert rv.data == b\"flask\"\n \n \n-class TestSafeJoin:\n-    @pytest.mark.parametrize(\n-        \"args, expected\",\n-        (\n-            ((\"a/b/c\",), \"a/b/c\"),\n-            ((\"/\", \"a/\", \"b/\", \"c/\"), \"/a/b/c\"),\n-            ((\"a\", \"b\", \"c\"), \"a/b/c\"),\n-            ((\"/a\", \"b/c\"), \"/a/b/c\"),\n-            ((\"a/b\", \"X/../c\"), \"a/b/c\"),\n-            ((\"/a/b\", \"c/X/..\"), \"/a/b/c\"),\n-            # If last path is '' add a slash\n-            ((\"/a/b/c\", \"\"), \"/a/b/c/\"),\n-            # Preserve dot slash\n-            ((\"/a/b/c\", \"./\"), \"/a/b/c/.\"),\n-            ((\"a/b/c\", \"X/..\"), \"a/b/c/.\"),\n-            # Base directory is always considered safe\n-            ((\"../\", \"a/b/c\"), \"../a/b/c\"),\n-            ((\"/..\",), \"/..\"),\n-        ),\n-    )\n-    def test_safe_join(self, args, expected):\n-        assert flask.safe_join(*args) == expected\n-\n-    @pytest.mark.parametrize(\n-        \"args\",\n-        (\n-            # path.isabs and ``..'' checks\n-            (\"/a\", \"b\", \"/c\"),\n-            (\"/a\", \"../b/c\"),\n-            (\"/a\", \"..\", \"b/c\"),\n-            # Boundaries violations after path normalization\n-            (\"/a\", \"b/../b/../../c\"),\n-            (\"/a\", \"b\", \"c/../..\"),\n-            (\"/a\", \"b/../../c\"),\n-        ),\n-    )\n-    def test_safe_join_exceptions(self, args):\n-        with pytest.raises(NotFound):\n-            print(flask.safe_join(*args))\n-\n-\n class TestHelpers:\n     @pytest.mark.parametrize(\n         \"debug, expected_flag, expected_default_flag\",\n\n@@ -3,7 +3,6 @@ import platform\n import threading\n \n import pytest\n-from werkzeug.exceptions import NotFound\n \n import flask\n \n@@ -56,13 +55,6 @@ def test_memory_consumption():\n             fire()\n \n \n-def test_safe_join_toplevel_pardir():\n-    from flask.helpers import safe_join\n-\n-    with pytest.raises(NotFound):\n-        safe_join(\"/foo\", \"..\")\n-\n-\n def test_aborting(app):\n     class Foo(Exception):\n         whatever = 42\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
