{"custom_id": "fastapi#addfa89b0f750abc193f62be8e457fc487b842ee", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 268 | Lines Deleted: 221 | Files Changed: 9 | Hunks: 45 | Methods Changed: 25 | Complexity Δ (Sum/Max): 35/11 | Churn Δ: 489 | Churn Cumulative: 3155 | Contributors (this commit): 1 | Commits (past 90d): 24 | Contributors (cumulative): 9 | DMM Complexity: 1.0\n\nDIFF:\n@@ -8,7 +8,8 @@ from starlette.responses import JSONResponse\n \n \n from fastapi import routing\n-from fastapi.openapi.utils import get_swagger_ui_html, get_openapi, get_redoc_html\n+from fastapi.openapi.utils import get_openapi\n+from fastapi.openapi.docs import get_redoc_html, get_swagger_ui_html\n \n \n async def http_exception(request, exc: HTTPException):\n@@ -154,9 +155,11 @@ class FastAPI(Starlette):\n                 response_wrapper=response_wrapper,\n             )\n             return func\n-\n         return decorator\n     \n+    def include_router(self, router: \"APIRouter\", *, prefix=\"\"):\n+        self.router.include_router(router, prefix=prefix)\n+\n     def get(\n         self,\n         path: str,\n\n@@ -0,0 +1,78 @@\n+from starlette.responses import HTMLResponse\n+\n+def get_swagger_ui_html(*, openapi_url: str, title: str):\n+    return HTMLResponse(\n+        \"\"\"\n+    <! doctype html>\n+    <html>\n+    <head>\n+    <link type=\"text/css\" rel=\"stylesheet\" href=\"//unpkg.com/swagger-ui-dist@3/swagger-ui.css\">\n+    <title>\n+    \"\"\"\n+        + title\n+        + \"\"\"\n+    </title>\n+    </head>\n+    <body>\n+    <div id=\"swagger-ui\">\n+    </div>\n+    <script src=\"//unpkg.com/swagger-ui-dist@3/swagger-ui-bundle.js\"></script>\n+    <!-- `SwaggerUIBundle` is now available on the page -->\n+    <script>\n+            \n+    const ui = SwaggerUIBundle({\n+        url: '\"\"\"\n+        + openapi_url\n+        + \"\"\"',\n+        dom_id: '#swagger-ui',\n+        presets: [\n+        SwaggerUIBundle.presets.apis,\n+        SwaggerUIBundle.SwaggerUIStandalonePreset\n+        ],\n+        layout: \"BaseLayout\"\n+ \n+    })\n+    </script>\n+    </body>\n+    </html>\n+    \"\"\",\n+        media_type=\"text/html\",\n+    )\n+\n+\n+def get_redoc_html(*, openapi_url: str, title: str):\n+    return HTMLResponse(\n+        \"\"\"\n+    <!DOCTYPE html>\n+<html>\n+  <head>\n+    <title>\n+    \"\"\"\n+        + title\n+        + \"\"\"\n+    </title>\n+    <!-- needed for adaptive design -->\n+    <meta charset=\"utf-8\"/>\n+    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n+    <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n+\n+    <!--\n+    ReDoc doesn't change outer page styles\n+    -->\n+    <style>\n+      body {\n+        margin: 0;\n+        padding: 0;\n+      }\n+    </style>\n+  </head>\n+  <body>\n+    <redoc spec-url='\"\"\"\n+        + openapi_url\n+        + \"\"\"'></redoc>\n+    <script src=\"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\"> </script>\n+  </body>\n+</html>\n+    \"\"\",\n+        media_type=\"text/html\",\n+    )\n\n@@ -1,4 +1,8 @@\n-from typing import Any, Dict, Sequence, Type\n+from typing import Any, Dict, Sequence, Type, List\n+\n+from pydantic.fields import Field\n+from pydantic.schema import field_schema, get_model_name_map\n+from pydantic.utils import lenient_issubclass\n \n from starlette.responses import HTMLResponse, JSONResponse\n from starlette.routing import BaseRoute\n@@ -12,9 +16,7 @@ from fastapi.openapi.constants import REF_PREFIX, METHODS_WITH_BODY\n from fastapi.openapi.models import OpenAPI\n from fastapi.params import Body\n from fastapi.utils import get_flat_models_from_routes, get_model_definitions\n-from pydantic.fields import Field\n-from pydantic.schema import field_schema, get_model_name_map\n-from pydantic.utils import lenient_issubclass\n+\n \n validation_error_definition = {\n     \"title\": \"ValidationError\",\n@@ -49,57 +51,32 @@ def get_openapi_params(dependant: Dependant):\n         + flat_dependant.cookie_params\n     )\n \n-def get_openapi_path(*, route: BaseRoute, model_name_map: Dict[Type, str]):\n-    if not (route.include_in_schema and isinstance(route, routing.APIRoute)):\n-        return None\n-    path = {}\n-    security_schemes = {}\n-    definitions = {}\n-    for method in route.methods:\n-        operation: Dict[str, Any] = {}\n-        if route.tags:\n-            operation[\"tags\"] = route.tags\n-        if route.summary:\n-            operation[\"summary\"] = route.summary\n-        if route.description:\n-            operation[\"description\"] = route.description\n-        if route.operation_id:\n-            operation[\"operationId\"] = route.operation_id\n-        else:\n-            operation[\"operationId\"] = route.name\n-        if route.deprecated:\n-            operation[\"deprecated\"] = route.deprecated\n-        parameters = []\n-        flat_dependant = get_flat_dependant(route.dependant)\n+\n+def get_openapi_security_definitions(flat_dependant: Dependant):\n     security_definitions = {}\n+    operation_security = []\n     for security_requirement in flat_dependant.security_requirements:\n         security_definition = jsonable_encoder(\n-                security_requirement.security_scheme,\n-                exclude={\"scheme_name\"},\n+            security_requirement.security_scheme.model,\n             by_alias=True,\n             include_none=False,\n         )\n         security_name = (\n-                getattr(\n-                    security_requirement.security_scheme, \"scheme_name\", None\n-                )\n-                or security_requirement.security_scheme.__class__.__name__\n+            security_requirement.security_scheme.scheme_name\n+            \n         )\n         security_definitions[security_name] = security_definition\n-            operation.setdefault(\"security\", []).append(\n-                {security_name: security_requirement.scopes}\n-            )\n-        if security_definitions:\n-            security_schemes.update(\n-                security_definitions\n-            )\n-        all_route_params = get_openapi_params(route.dependant)\n+        operation_security.append({security_name: security_requirement.scopes})\n+    return security_definitions, operation_security\n+\n+\n+def get_openapi_operation_parameters(all_route_params: List[Field]):\n+    definitions: Dict[str, Dict] = {}\n+    parameters = []\n     for param in all_route_params:\n         if \"ValidationError\" not in definitions:\n             definitions[\"ValidationError\"] = validation_error_definition\n-                definitions[\n-                    \"HTTPValidationError\"\n-                ] = validation_error_response_definition\n+            definitions[\"HTTPValidationError\"] = validation_error_response_definition\n         parameter = {\n             \"name\": param.alias,\n             \"in\": param.schema.in_.value,\n@@ -111,16 +88,17 @@ def get_openapi_path(*, route: BaseRoute, model_name_map: Dict[Type, str]):\n         if param.schema.deprecated:\n             parameter[\"deprecated\"] = param.schema.deprecated\n         parameters.append(parameter)\n-        if parameters:\n-            operation[\"parameters\"] = parameters\n-        if method in METHODS_WITH_BODY:\n-            body_field = route.body_field\n-            if body_field:\n+    return definitions, parameters\n+\n+\n+def get_openapi_operation_request_body(\n+    *, body_field: Field, model_name_map: Dict[Type, str]\n+):\n+    if not body_field:\n+        return None\n     assert isinstance(body_field, Field)\n     body_schema, _ = field_schema(\n-                    body_field,\n-                    model_name_map=model_name_map,\n-                    ref_prefix=REF_PREFIX,\n+        body_field, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n     )\n     if isinstance(body_field.schema, Body):\n         request_media_type = body_field.schema.media_type\n@@ -131,9 +109,68 @@ def get_openapi_path(*, route: BaseRoute, model_name_map: Dict[Type, str]):\n     request_body_oai = {}\n     if required:\n         request_body_oai[\"required\"] = required\n-                request_body_oai[\"content\"] = {\n-                    request_media_type: {\"schema\": body_schema}\n-                }\n+    request_body_oai[\"content\"] = {request_media_type: {\"schema\": body_schema}}\n+    return request_body_oai\n+\n+\n+def generate_operation_id(*, route: routing.APIRoute, method: str):\n+    if route.operation_id:\n+        return route.operation_id\n+    path: str = route.path\n+    operation_id = route.name + path\n+    operation_id = operation_id.replace(\"{\", \"_\").replace(\"}\", \"_\").replace(\"/\", \"_\")\n+    operation_id = operation_id + \"_\" + method.lower()\n+    return operation_id\n+\n+\n+def generate_operation_summary(*, route: routing.APIRoute, method: str):\n+    if route.summary:\n+        return route.summary\n+    return method.title() + \" \" + route.name.replace(\"_\", \" \").title()\n+\n+def get_openapi_operation_metadata(*, route: BaseRoute, method: str):\n+    operation: Dict[str, Any] = {}\n+    if route.tags:\n+        operation[\"tags\"] = route.tags\n+    operation[\"summary\"] = generate_operation_summary(route=route, method=method)\n+    if route.description:\n+        operation[\"description\"] = route.description\n+    operation[\"operationId\"] = generate_operation_id(route=route, method=method)\n+    if route.deprecated:\n+        operation[\"deprecated\"] = route.deprecated\n+    return operation\n+\n+\n+def get_openapi_path(*, route: BaseRoute, model_name_map: Dict[Type, str]):\n+    if not (route.include_in_schema and isinstance(route, routing.APIRoute)):\n+        return None\n+    path = {}\n+    security_schemes: Dict[str, Any] = {}\n+    definitions: Dict[str, Any] = {}\n+    for method in route.methods:\n+        operation = get_openapi_operation_metadata(route=route, method=method)\n+        parameters: List[Dict] = []\n+        flat_dependant = get_flat_dependant(route.dependant)\n+        security_definitions, operation_security = get_openapi_security_definitions(\n+            flat_dependant=flat_dependant\n+        )\n+        if operation_security:\n+            operation.setdefault(\"security\", []).extend(operation_security)\n+        if security_definitions:\n+            security_schemes.update(security_definitions)\n+        all_route_params = get_openapi_params(route.dependant)\n+        validation_definitions, operation_parameters = get_openapi_operation_parameters(\n+            all_route_params=all_route_params\n+        )\n+        definitions.update(validation_definitions)\n+        parameters.extend(operation_parameters)\n+        if parameters:\n+            operation[\"parameters\"] = parameters\n+        if method in METHODS_WITH_BODY:\n+            request_body_oai = get_openapi_operation_request_body(\n+                body_field=route.body_field, model_name_map=model_name_map\n+            )\n+            if request_body_oai:\n                 operation[\"requestBody\"] = request_body_oai\n         response_code = str(route.response_code)\n         response_schema = {\"type\": \"string\"}\n@@ -206,75 +243,3 @@ def get_openapi(\n         output[\"components\"] = components\n     output[\"paths\"] = paths\n     return jsonable_encoder(OpenAPI(**output), by_alias=True, include_none=False)\n-\n-\n-def get_swagger_ui_html(*, openapi_url: str, title: str):\n-    return HTMLResponse(\n-        \"\"\"\n-    <! doctype html>\n-    <html>\n-    <head>\n-    <link type=\"text/css\" rel=\"stylesheet\" href=\"//unpkg.com/swagger-ui-dist@3/swagger-ui.css\">\n-    <title>\n-    \"\"\" + title + \"\"\"\n-    </title>\n-    </head>\n-    <body>\n-    <div id=\"swagger-ui\">\n-    </div>\n-    <script src=\"//unpkg.com/swagger-ui-dist@3/swagger-ui-bundle.js\"></script>\n-    <!-- `SwaggerUIBundle` is now available on the page -->\n-    <script>\n-            \n-    const ui = SwaggerUIBundle({\n-        url: '\"\"\"\n-        + openapi_url\n-        + \"\"\"',\n-        dom_id: '#swagger-ui',\n-        presets: [\n-        SwaggerUIBundle.presets.apis,\n-        SwaggerUIBundle.SwaggerUIStandalonePreset\n-        ],\n-        layout: \"BaseLayout\"\n- \n-    })\n-    </script>\n-    </body>\n-    </html>\n-    \"\"\",\n-        media_type=\"text/html\",\n-    )\n-\n-\n-def get_redoc_html(*, openapi_url: str, title: str):\n-    return HTMLResponse(\n-        \"\"\"\n-    <!DOCTYPE html>\n-<html>\n-  <head>\n-    <title>\n-    \"\"\" + title + \"\"\"\n-    </title>\n-    <!-- needed for adaptive design -->\n-    <meta charset=\"utf-8\"/>\n-    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n-    <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n-\n-    <!--\n-    ReDoc doesn't change outer page styles\n-    -->\n-    <style>\n-      body {\n-        margin: 0;\n-        padding: 0;\n-      }\n-    </style>\n-  </head>\n-  <body>\n-    <redoc spec-url='\"\"\" + openapi_url + \"\"\"'></redoc>\n-    <script src=\"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\"> </script>\n-  </body>\n-</html>\n-    \"\"\",\n-        media_type=\"text/html\",\n-    )\n\n@@ -2,6 +2,11 @@ import asyncio\n import inspect\n from typing import Callable, List, Type\n \n+from pydantic import BaseConfig, BaseModel, Schema\n+from pydantic.error_wrappers import ErrorWrapper, ValidationError\n+from pydantic.fields import Field\n+from pydantic.utils import lenient_issubclass\n+\n from starlette import routing\n from starlette.concurrency import run_in_threadpool\n from starlette.exceptions import HTTPException\n@@ -15,10 +20,6 @@ from fastapi import params\n from fastapi.dependencies.models import Dependant\n from fastapi.dependencies.utils import get_body_field, get_dependant, solve_dependencies\n from fastapi.encoders import jsonable_encoder\n-from pydantic import BaseConfig, BaseModel, Schema\n-from pydantic.error_wrappers import ErrorWrapper, ValidationError\n-from pydantic.fields import Field\n-from pydantic.utils import lenient_issubclass\n \n \n def serialize_response(*, field: Field = None, response):\n@@ -44,11 +45,12 @@ def get_app(\n     response_field: Type[Field] = None,\n ):\n     is_coroutine = dependant.call and asyncio.iscoroutinefunction(dependant.call)\n+    is_body_form = body_field and isinstance(body_field.schema, params.Form)\n \n     async def app(request: Request) -> Response:\n         body = None\n         if body_field:\n-            if isinstance(body_field.schema, params.Form):\n+            if is_body_form:\n                 raw_body = await request.form()\n                 body = {}\n                 for field, value in raw_body.items():\n@@ -127,12 +129,7 @@ class APIRoute(routing.Route):\n         response_code=200,\n         response_wrapper=JSONResponse,\n     ) -> None:\n-        # TODO define how to read and provide security params, and how to have them globally too\n-        # TODO implement dependencies and injection\n-        # TODO refactor code structure\n-        # TODO create testing\n-        # TODO testing coverage\n-        assert path.startswith(\"/\"), \"Routed paths must always start '/'\"\n+        assert path.startswith(\"/\"), \"Routed paths must always start with '/'\"\n         self.path = path\n         self.endpoint = endpoint\n         self.name = get_name(endpoint) if name is None else name\n@@ -260,6 +257,39 @@ class APIRouter(routing.Router):\n \n         return decorator\n \n+    def include_router(self, router: \"APIRouter\", *, prefix=\"\"):\n+        if prefix:\n+            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n+            assert not prefix.endswith(\n+                \"/\"\n+            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n+        for route in router.routes:\n+            if isinstance(route, APIRoute):\n+                self.add_api_route(\n+                    prefix + route.path,\n+                    route.endpoint,\n+                    methods=route.methods,\n+                    name=route.name,\n+                    include_in_schema=route.include_in_schema,\n+                    tags=route.tags,\n+                    summary=route.summary,\n+                    description=route.description,\n+                    operation_id=route.operation_id,\n+                    deprecated=route.deprecated,\n+                    response_type=route.response_type,\n+                    response_description=route.response_description,\n+                    response_code=route.response_code,\n+                    response_wrapper=route.response_wrapper,\n+                )\n+            elif isinstance(route, routing.Route):\n+                self.add_route(\n+                    prefix + route.path,\n+                    route.endpoint,\n+                    methods=route.methods,\n+                    name=route.name,\n+                    include_in_schema=route.include_in_schema,\n+                )\n+\n     def get(\n         self,\n         path: str,\n\n@@ -1,39 +1,34 @@\n-from enum import Enum\n-\n-from pydantic import Schema\n-\n from starlette.requests import Request\n \n-from .base import SecurityBase, Types\n-\n-class APIKeyIn(Enum):\n-    query = \"query\"\n-    header = \"header\"\n-    cookie = \"cookie\"\n-\n+from .base import SecurityBase\n+from fastapi.openapi.models import APIKeyIn, APIKey\n \n class APIKeyBase(SecurityBase):\n-    type_ = Schema(Types.apiKey, alias=\"type\")\n-    in_: str = Schema(..., alias=\"in\")\n-    name: str\n-\n+    pass\n \n class APIKeyQuery(APIKeyBase):\n-    in_ = Schema(APIKeyIn.query, alias=\"in\")\n+\n+    def __init__(self, *, name: str, scheme_name: str = None):\n+        self.model = APIKey(in_=APIKeyIn.query, name=name)\n+        self.scheme_name = scheme_name or self.__class__.__name__\n \n     async def __call__(self, requests: Request):\n-        return requests.query_params.get(self.name)\n+        return requests.query_params.get(self.model.name)\n \n \n class APIKeyHeader(APIKeyBase):\n-    in_ = Schema(APIKeyIn.header, alias=\"in\")\n+    def __init__(self, *, name: str, scheme_name: str = None):\n+        self.model = APIKey(in_=APIKeyIn.header, name=name)\n+        self.scheme_name = scheme_name or self.__class__.__name__\n \n     async def __call__(self, requests: Request):\n-        return requests.headers.get(self.name)\n+        return requests.headers.get(self.model.name)\n \n \n class APIKeyCookie(APIKeyBase):\n-    in_ = Schema(APIKeyIn.cookie, alias=\"in\")\n+    def __init__(self, *, name: str, scheme_name: str = None):\n+        self.model = APIKey(in_=APIKeyIn.cookie, name=name)\n+        self.scheme_name = scheme_name or self.__class__.__name__\n \n     async def __call__(self, requests: Request):\n-        return requests.cookies.get(self.name)\n+        return requests.cookies.get(self.model.name)\n\n@@ -1,16 +1,6 @@\n-from enum import Enum\n+from pydantic import BaseModel\n \n-from pydantic import BaseModel, Schema\n+from fastapi.openapi.models import SecurityBase as SecurityBaseModel\n \n-\n-class Types(Enum):\n-    apiKey = \"apiKey\"\n-    http = \"http\"\n-    oauth2 = \"oauth2\"\n-    openIdConnect = \"openIdConnect\"\n-\n-\n-class SecurityBase(BaseModel):\n-    scheme_name: str = None\n-    type_: Types = Schema(..., alias=\"type\")\n-    description: str = None\n+class SecurityBase:\n+    pass\n\n@@ -1,26 +1,40 @@\n-from pydantic import Schema\n-\n from starlette.requests import Request\n \n-from .base import SecurityBase, Types\n+from .base import SecurityBase\n+from fastapi.openapi.models import HTTPBase as HTTPBaseModel, HTTPBearer as HTTPBearerModel\n \n \n class HTTPBase(SecurityBase):\n-    type_ = Schema(Types.http, alias=\"type\")\n-    scheme: str\n+    def __init__(self, *, scheme: str, scheme_name: str = None):\n+        self.model = HTTPBaseModel(scheme=scheme)\n+        self.scheme_name = scheme_name or self.__class__.__name__\n \n     async def __call__(self, request: Request):\n         return request.headers.get(\"Authorization\")\n \n \n class HTTPBasic(HTTPBase):\n-    scheme = \"basic\"\n+    def __init__(self, *, scheme_name: str = None):\n+        self.model = HTTPBaseModel(scheme=\"basic\")\n+        self.scheme_name = scheme_name or self.__class__.__name__\n+    \n+    async def __call__(self, request: Request):\n+        return request.headers.get(\"Authorization\")\n \n \n class HTTPBearer(HTTPBase):\n-    scheme = \"bearer\"\n-    bearerFormat: str = None\n+    def __init__(self, *, bearerFormat: str = None, scheme_name: str = None):\n+        self.model = HTTPBearerModel(bearerFormat=bearerFormat)\n+        self.scheme_name = scheme_name or self.__class__.__name__\n+    \n+    async def __call__(self, request: Request):\n+        return request.headers.get(\"Authorization\")\n \n \n class HTTPDigest(HTTPBase):\n-    scheme = \"digest\"\n+    def __init__(self, *, scheme_name: str = None):\n+        self.model = HTTPBaseModel(scheme=\"digest\")\n+        self.scheme_name = scheme_name or self.__class__.__name__\n+    \n+    async def __call__(self, request: Request):\n+        return request.headers.get(\"Authorization\")\n\n@@ -1,43 +1,13 @@\n-from typing import Dict\n-\n-from pydantic import BaseModel, Schema\n-\n from starlette.requests import Request\n \n-from .base import SecurityBase, Types\n-\n-class OAuthFlow(BaseModel):\n-    refreshUrl: str = None\n-    scopes: Dict[str, str] = {}\n-\n-\n-class OAuthFlowImplicit(OAuthFlow):\n-    authorizationUrl: str\n-\n-\n-class OAuthFlowPassword(OAuthFlow):\n-    tokenUrl: str\n-\n-\n-class OAuthFlowClientCredentials(OAuthFlow):\n-    tokenUrl: str\n-\n-\n-class OAuthFlowAuthorizationCode(OAuthFlow):\n-    authorizationUrl: str\n-    tokenUrl: str\n-\n-\n-class OAuthFlows(BaseModel):\n-    implicit: OAuthFlowImplicit = None\n-    password: OAuthFlowPassword = None\n-    clientCredentials: OAuthFlowClientCredentials = None\n-    authorizationCode: OAuthFlowAuthorizationCode = None\n+from .base import SecurityBase\n+from fastapi.openapi.models import OAuth2 as OAuth2Model, OAuthFlows as OAuthFlowsModel\n \n \n class OAuth2(SecurityBase):\n-    type_ = Schema(Types.oauth2, alias=\"type\")\n-    flows: OAuthFlows\n+    def __init__(self, *, flows: OAuthFlowsModel = OAuthFlowsModel(), scheme_name: str = None):\n+        self.model = OAuth2Model(flows=flows)\n+        self.scheme_name = scheme_name or self.__class__.__name__\n     \n     async def __call__(self, request: Request):\n         return request.headers.get(\"Authorization\")\n\n@@ -1,11 +1,13 @@\n from starlette.requests import Request\n \n-from .base import SecurityBase, Types\n+from .base import SecurityBase\n+from fastapi.openapi.models import OpenIdConnect as OpenIdConnectModel\n \n \n class OpenIdConnect(SecurityBase):\n-    type_ = Types.openIdConnect\n-    openIdConnectUrl: str\n+    def __init__(self, *, openIdConnectUrl: str, scheme_name: str = None):\n+        self.model = OpenIdConnectModel(openIdConnectUrl=openIdConnectUrl)\n+        self.scheme_name = scheme_name or self.__class__.__name__\n     \n     async def __call__(self, request: Request):\n         return request.headers.get(\"Authorization\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#0e19c24014c96e241bd73bede2805e21fc20c9d8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 596 | Lines Deleted: 552 | Files Changed: 15 | Hunks: 291 | Methods Changed: 107 | Complexity Δ (Sum/Max): 1/2 | Churn Δ: 1148 | Churn Cumulative: 5451 | Contributors (this commit): 1 | Commits (past 90d): 46 | Contributors (cumulative): 15 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,19 +1,19 @@\n-from typing import Any, Callable, Dict, List, Type\n+from typing import Any, Callable, Dict, List, Optional, Type\n \n+from pydantic import BaseModel\n from starlette.applications import Starlette\n from starlette.exceptions import ExceptionMiddleware, HTTPException\n from starlette.middleware.errors import ServerErrorMiddleware\n from starlette.middleware.lifespan import LifespanMiddleware\n-from starlette.responses import JSONResponse\n-\n+from starlette.requests import Request\n+from starlette.responses import JSONResponse, Response\n \n from fastapi import routing\n-from fastapi.openapi.utils import get_openapi\n from fastapi.openapi.docs import get_redoc_html, get_swagger_ui_html\n+from fastapi.openapi.utils import get_openapi\n \n \n-async def http_exception(request, exc: HTTPException):\n-    print(exc)\n+async def http_exception(request: Request, exc: HTTPException) -> JSONResponse:\n     return JSONResponse({\"detail\": exc.detail}, status_code=exc.status_code)\n \n \n@@ -31,7 +31,7 @@ class FastAPI(Starlette):\n         **extra: Dict[str, Any],\n     ) -> None:\n         self._debug = debug\n-        self.router = routing.APIRouter()\n+        self.router: routing.APIRouter = routing.APIRouter()\n         self.exception_middleware = ExceptionMiddleware(self.router, debug=debug)\n         self.error_middleware = ServerErrorMiddleware(\n             self.exception_middleware, debug=debug\n@@ -56,33 +56,41 @@ class FastAPI(Starlette):\n \n         if self.swagger_ui_url or self.redoc_url:\n             assert self.openapi_url, \"The openapi_url is required for the docs\"\n+        self.openapi_schema: Optional[Dict[str, Any]] = None\n         self.setup()\n \n-    def setup(self):\n-        if self.openapi_url:\n-            self.add_route(\n-                self.openapi_url,\n-                lambda req: JSONResponse(\n-                    get_openapi(\n+    def openapi(self) -> Dict:\n+        if not self.openapi_schema:\n+            self.openapi_schema = get_openapi(\n                 title=self.title,\n                 version=self.version,\n                 openapi_version=self.openapi_version,\n                 description=self.description,\n                 routes=self.routes,\n             )\n-                ),\n+        return self.openapi_schema\n+\n+    def setup(self) -> None:\n+        if self.openapi_url:\n+            self.add_route(\n+                self.openapi_url,\n+                lambda req: JSONResponse(self.openapi()),\n                 include_in_schema=False,\n             )\n         if self.swagger_ui_url:\n             self.add_route(\n                 self.swagger_ui_url,\n-                lambda r: get_swagger_ui_html(openapi_url=self.openapi_url, title=self.title + \" - Swagger UI\"),\n+                lambda r: get_swagger_ui_html(\n+                    openapi_url=self.openapi_url, title=self.title + \" - Swagger UI\"\n+                ),\n                 include_in_schema=False,\n             )\n         if self.redoc_url:\n             self.add_route(\n                 self.redoc_url,\n-                lambda r: get_redoc_html(openapi_url=self.openapi_url, title=self.title + \" - ReDoc\"),\n+                lambda r: get_redoc_html(\n+                    openapi_url=self.openapi_url, title=self.title + \" - ReDoc\"\n+                ),\n                 include_in_schema=False,\n             )\n         self.add_exception_handler(HTTPException, http_exception)\n@@ -91,311 +99,322 @@ class FastAPI(Starlette):\n         self,\n         path: str,\n         endpoint: Callable,\n-        methods: List[str] = None,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n+        deprecated: bool = None,\n+        name: str = None,\n+        methods: List[str] = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n     ) -> None:\n         self.router.add_api_route(\n             path,\n             endpoint=endpoint,\n-            methods=methods,\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            methods=methods,\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def api_route(\n         self,\n         path: str,\n-        methods: List[str] = None,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n+        deprecated: bool = None,\n+        name: str = None,\n+        methods: List[str] = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n     ) -> Callable:\n         def decorator(func: Callable) -> Callable:\n             self.router.add_api_route(\n                 path,\n                 func,\n-                methods=methods,\n-                name=name,\n-                include_in_schema=include_in_schema,\n+                response_model=response_model,\n+                status_code=status_code,\n                 tags=tags or [],\n                 summary=summary,\n                 description=description,\n-                operation_id=operation_id,\n-                deprecated=deprecated,\n-                response_type=response_type,\n                 response_description=response_description,\n-                response_code=response_code,\n-                response_wrapper=response_wrapper,\n+                deprecated=deprecated,\n+                name=name,\n+                methods=methods,\n+                operation_id=operation_id,\n+                include_in_schema=include_in_schema,\n+                content_type=content_type,\n             )\n             return func\n+\n         return decorator\n \n-    def include_router(self, router: \"APIRouter\", *, prefix=\"\"):\n+    def include_router(self, router: routing.APIRouter, *, prefix: str = \"\") -> None:\n         self.router.include_router(router, prefix=prefix)\n \n     def get(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.router.get(\n-            path=path,\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            path,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def put(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.router.put(\n-            path=path,\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            path,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def post(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.router.post(\n-            path=path,\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            path,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def delete(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.router.delete(\n-            path=path,\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            path,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def options(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.router.options(\n-            path=path,\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            path,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def head(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.router.head(\n-            path=path,\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            path,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def patch(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.router.patch(\n-            path=path,\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            path,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def trace(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.router.trace(\n-            path=path,\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            path,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n\n@@ -1,14 +1,14 @@\n from typing import Any, Callable, Dict, List, Sequence, Tuple\n \n-from starlette.concurrency import run_in_threadpool\n-from starlette.requests import Request\n-\n-from fastapi.security.base import SecurityBase\n from pydantic import BaseConfig, Schema\n from pydantic.error_wrappers import ErrorWrapper\n from pydantic.errors import MissingError\n from pydantic.fields import Field, Required\n from pydantic.schema import get_annotation_from_schema\n+from starlette.concurrency import run_in_threadpool\n+from starlette.requests import Request\n+\n+from fastapi.security.base import SecurityBase\n \n param_supported_types = (str, int, float, bool)\n \n\n@@ -1,8 +1,14 @@\n import asyncio\n import inspect\n from copy import deepcopy\n-from typing import Any, Callable, Dict, List, Tuple\n+from typing import Any, Callable, Dict, List, Mapping, Sequence, Tuple, Type\n \n+from pydantic import BaseConfig, Schema, create_model\n+from pydantic.error_wrappers import ErrorWrapper\n+from pydantic.errors import MissingError\n+from pydantic.fields import Field, Required\n+from pydantic.schema import get_annotation_from_schema\n+from pydantic.utils import lenient_issubclass\n from starlette.concurrency import run_in_threadpool\n from starlette.requests import Request\n \n@@ -10,17 +16,11 @@ from fastapi import params\n from fastapi.dependencies.models import Dependant, SecurityRequirement\n from fastapi.security.base import SecurityBase\n from fastapi.utils import get_path_param_names\n-from pydantic import BaseConfig, Schema, create_model\n-from pydantic.error_wrappers import ErrorWrapper\n-from pydantic.errors import MissingError\n-from pydantic.fields import Field, Required\n-from pydantic.schema import get_annotation_from_schema\n-from pydantic.utils import lenient_issubclass\n \n param_supported_types = (str, int, float, bool)\n \n \n-def get_sub_dependant(*, param: inspect.Parameter, path: str):\n+def get_sub_dependant(*, param: inspect.Parameter, path: str) -> Dependant:\n     depends: params.Depends = param.default\n     if depends.dependency:\n         dependency = depends.dependency\n@@ -36,7 +36,7 @@ def get_sub_dependant(*, param: inspect.Parameter, path: str):\n     return sub_dependant\n \n \n-def get_flat_dependant(dependant: Dependant):\n+def get_flat_dependant(dependant: Dependant) -> Dependant:\n     flat_dependant = Dependant(\n         path_params=dependant.path_params.copy(),\n         query_params=dependant.query_params.copy(),\n@@ -58,7 +58,7 @@ def get_flat_dependant(dependant: Dependant):\n     return flat_dependant\n \n \n-def get_dependant(*, path: str, call: Callable, name: str = None):\n+def get_dependant(*, path: str, call: Callable, name: str = None) -> Dependant:\n     path_param_names = get_path_param_names(path)\n     endpoint_signature = inspect.signature(call)\n     signature_params = endpoint_signature.parameters\n@@ -73,9 +73,10 @@ def get_dependant(*, path: str, call: Callable, name: str = None):\n         if (\n             (param.default == param.empty) or isinstance(param.default, params.Path)\n         ) and (param_name in path_param_names):\n-            assert lenient_issubclass(\n-                param.annotation, param_supported_types\n-            ) or param.annotation == param.empty, f\"Path params must be of type str, int, float or boot: {param}\"\n+            assert (\n+                lenient_issubclass(param.annotation, param_supported_types)\n+                or param.annotation == param.empty\n+            ), f\"Path params must be of type str, int, float or boot: {param}\"\n             param = signature_params[param_name]\n             add_param_to_fields(\n                 param=param,\n@@ -109,9 +110,9 @@ def add_param_to_fields(\n     *,\n     param: inspect.Parameter,\n     dependant: Dependant,\n-    default_schema=params.Param,\n+    default_schema: Type[Schema] = params.Param,\n     force_type: params.ParamTypes = None,\n-):\n+) -> None:\n     default_value = Required\n     if not param.default == param.empty:\n         default_value = param.default\n@@ -125,15 +126,19 @@ def add_param_to_fields(\n     else:\n         schema = default_schema(default_value)\n     required = default_value == Required\n-    annotation = Any\n+    annotation: Type = Type[Any]\n     if not param.annotation == param.empty:\n         annotation = param.annotation\n     annotation = get_annotation_from_schema(annotation, schema)\n+    if not schema.alias and getattr(schema, \"alias_underscore_to_hyphen\", None):\n+        alias = param.name.replace(\"_\", \"-\")\n+    else:\n+        alias = schema.alias or param.name\n     field = Field(\n         name=param.name,\n         type_=annotation,\n         default=None if required else default_value,\n-        alias=schema.alias or param.name,\n+        alias=alias,\n         required=required,\n         model_config=BaseConfig(),\n         class_validators=[],\n@@ -152,7 +157,7 @@ def add_param_to_fields(\n         dependant.cookie_params.append(field)\n \n \n-def add_param_to_body_fields(*, param: inspect.Parameter, dependant: Dependant):\n+def add_param_to_body_fields(*, param: inspect.Parameter, dependant: Dependant) -> None:\n     default_value = Required\n     if not param.default == param.empty:\n         default_value = param.default\n@@ -176,7 +181,7 @@ def add_param_to_body_fields(*, param: inspect.Parameter, dependant: Dependant):\n     dependant.body_params.append(field)\n \n \n-def is_coroutine_callable(call: Callable = None):\n+def is_coroutine_callable(call: Callable = None) -> bool:\n     if not call:\n         return False\n     if inspect.isfunction(call):\n@@ -191,7 +196,7 @@ def is_coroutine_callable(call: Callable = None):\n \n async def solve_dependencies(\n     *, request: Request, dependant: Dependant, body: Dict[str, Any] = None\n-):\n+) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n     values: Dict[str, Any] = {}\n     errors: List[ErrorWrapper] = []\n     for sub_dependant in dependant.dependencies:\n@@ -200,13 +205,13 @@ async def solve_dependencies(\n         )\n         if sub_errors:\n             return {}, errors\n-        if sub_dependant.call and is_coroutine_callable(sub_dependant.call):\n+        assert sub_dependant.call is not None, \"sub_dependant.call must be a function\"\n+        if is_coroutine_callable(sub_dependant.call):\n             solved = await sub_dependant.call(**sub_values)\n         else:\n             solved = await run_in_threadpool(sub_dependant.call, **sub_values)\n-        values[\n-            sub_dependant.name\n-        ] = solved  # type: ignore # Sub-dependants always have a name\n+        assert sub_dependant.name is not None, \"Subdependants always have a name\"\n+        values[sub_dependant.name] = solved\n     path_values, path_errors = request_params_to_args(\n         dependant.path_params, request.path_params\n     )\n@@ -236,7 +241,7 @@ async def solve_dependencies(\n \n \n def request_params_to_args(\n-    required_params: List[Field], received_params: Dict[str, Any]\n+    required_params: Sequence[Field], received_params: Mapping[str, Any]\n ) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n     values = {}\n     errors = []\n@@ -250,9 +255,9 @@ def request_params_to_args(\n             else:\n                 values[field.name] = deepcopy(field.default)\n             continue\n-        v_, errors_ = field.validate(\n-            value, values, loc=(field.schema.in_.value, field.alias)\n-        )\n+        schema: params.Param = field.schema\n+        assert isinstance(schema, params.Param), \"Params must be subclasses of Param\"\n+        v_, errors_ = field.validate(value, values, loc=(schema.in_.value, field.alias))\n         if isinstance(errors_, ErrorWrapper):\n             errors.append(errors_)\n         elif isinstance(errors_, list):\n@@ -294,7 +299,7 @@ async def request_body_to_args(\n     return values, errors\n \n \n-def get_body_field(*, dependant: Dependant, name: str):\n+def get_body_field(*, dependant: Dependant, name: str) -> Field:\n     flat_dependant = get_flat_dependant(dependant)\n     if not flat_dependant.body_params:\n         return None\n@@ -308,7 +313,7 @@ def get_body_field(*, dependant: Dependant, name: str):\n         BodyModel.__fields__[f.name] = f\n     required = any(True for f in flat_dependant.body_params if f.required)\n     if any(isinstance(f.schema, params.File) for f in flat_dependant.body_params):\n-        BodySchema = params.File\n+        BodySchema: Type[params.Body] = params.File\n     elif any(isinstance(f.schema, params.Form) for f in flat_dependant.body_params):\n         BodySchema = params.Form\n     else:\n\n@@ -1,18 +1,18 @@\n from enum import Enum\n from types import GeneratorType\n-from typing import Set\n+from typing import Any, Set\n \n from pydantic import BaseModel\n from pydantic.json import pydantic_encoder\n \n \n def jsonable_encoder(\n-    obj,\n+    obj: Any,\n     include: Set[str] = None,\n     exclude: Set[str] = set(),\n     by_alias: bool = False,\n-    include_none=True,\n-):\n+    include_none: bool = True,\n+) -> Any:\n     if isinstance(obj, BaseModel):\n         return jsonable_encoder(\n             obj.dict(include=include, exclude=exclude, by_alias=by_alias),\n\n@@ -1,6 +1,7 @@\n from starlette.responses import HTMLResponse\n \n-def get_swagger_ui_html(*, openapi_url: str, title: str):\n+\n+def get_swagger_ui_html(*, openapi_url: str, title: str) -> HTMLResponse:\n     return HTMLResponse(\n         \"\"\"\n     <! doctype html>\n@@ -35,12 +36,11 @@ def get_swagger_ui_html(*, openapi_url: str, title: str):\n     </script>\n     </body>\n     </html>\n-    \"\"\",\n-        media_type=\"text/html\",\n+    \"\"\"\n     )\n \n \n-def get_redoc_html(*, openapi_url: str, title: str):\n+def get_redoc_html(*, openapi_url: str, title: str) -> HTMLResponse:\n     return HTMLResponse(\n         \"\"\"\n     <!DOCTYPE html>\n@@ -73,6 +73,5 @@ def get_redoc_html(*, openapi_url: str, title: str):\n     <script src=\"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\"> </script>\n   </body>\n </html>\n-    \"\"\",\n-        media_type=\"text/html\",\n+    \"\"\"\n     )\n\n@@ -7,13 +7,13 @@ from pydantic.types import UrlStr\n \n try:\n     import pydantic.types.EmailStr\n-    from pydantic.types import EmailStr\n+    from pydantic.types import EmailStr  # type: ignore\n except ImportError:\n     logging.warning(\n         \"email-validator not installed, email fields will be treated as str\"\n     )\n \n-    class EmailStr(str):\n+    class EmailStr(str):  # type: ignore\n         pass\n \n \n@@ -50,7 +50,7 @@ class Server(BaseModel):\n \n \n class Reference(BaseModel):\n-    ref: str = PSchema(..., alias=\"$ref\")\n+    ref: str = PSchema(..., alias=\"$ref\")  # type: ignore\n \n \n class Discriminator(BaseModel):\n@@ -72,28 +72,28 @@ class ExternalDocumentation(BaseModel):\n \n \n class SchemaBase(BaseModel):\n-    ref: Optional[str] = PSchema(None, alias=\"$ref\")\n+    ref: Optional[str] = PSchema(None, alias=\"$ref\")  # type: ignore\n     title: Optional[str] = None\n     multipleOf: Optional[float] = None\n     maximum: Optional[float] = None\n     exclusiveMaximum: Optional[float] = None\n     minimum: Optional[float] = None\n     exclusiveMinimum: Optional[float] = None\n-    maxLength: Optional[int] = PSchema(None, gte=0)\n-    minLength: Optional[int] = PSchema(None, gte=0)\n+    maxLength: Optional[int] = PSchema(None, gte=0)  # type: ignore\n+    minLength: Optional[int] = PSchema(None, gte=0)  # type: ignore\n     pattern: Optional[str] = None\n-    maxItems: Optional[int] = PSchema(None, gte=0)\n-    minItems: Optional[int] = PSchema(None, gte=0)\n+    maxItems: Optional[int] = PSchema(None, gte=0)  # type: ignore\n+    minItems: Optional[int] = PSchema(None, gte=0)  # type: ignore\n     uniqueItems: Optional[bool] = None\n-    maxProperties: Optional[int] = PSchema(None, gte=0)\n-    minProperties: Optional[int] = PSchema(None, gte=0)\n+    maxProperties: Optional[int] = PSchema(None, gte=0)  # type: ignore\n+    minProperties: Optional[int] = PSchema(None, gte=0)  # type: ignore\n     required: Optional[List[str]] = None\n     enum: Optional[List[str]] = None\n     type: Optional[str] = None\n     allOf: Optional[List[Any]] = None\n     oneOf: Optional[List[Any]] = None\n     anyOf: Optional[List[Any]] = None\n-    not_: Optional[List[Any]] = PSchema(None, alias=\"not\")\n+    not_: Optional[List[Any]] = PSchema(None, alias=\"not\")  # type: ignore\n     items: Optional[Any] = None\n     properties: Optional[Dict[str, Any]] = None\n     additionalProperties: Optional[Union[bool, Any]] = None\n@@ -114,7 +114,7 @@ class Schema(SchemaBase):\n     allOf: Optional[List[SchemaBase]] = None\n     oneOf: Optional[List[SchemaBase]] = None\n     anyOf: Optional[List[SchemaBase]] = None\n-    not_: Optional[List[SchemaBase]] = PSchema(None, alias=\"not\")\n+    not_: Optional[List[SchemaBase]] = PSchema(None, alias=\"not\")  # type: ignore\n     items: Optional[SchemaBase] = None\n     properties: Optional[Dict[str, SchemaBase]] = None\n     additionalProperties: Optional[Union[bool, SchemaBase]] = None\n@@ -144,7 +144,9 @@ class Encoding(BaseModel):\n \n \n class MediaType(BaseModel):\n-    schema_: Optional[Union[Schema, Reference]] = PSchema(None, alias=\"schema\")\n+    schema_: Optional[Union[Schema, Reference]] = PSchema(\n+        None, alias=\"schema\"\n+    )  # type: ignore\n     example: Optional[Any] = None\n     examples: Optional[Dict[str, Union[Example, Reference]]] = None\n     encoding: Optional[Dict[str, Encoding]] = None\n@@ -158,7 +160,9 @@ class ParameterBase(BaseModel):\n     style: Optional[str] = None\n     explode: Optional[bool] = None\n     allowReserved: Optional[bool] = None\n-    schema_: Optional[Union[Schema, Reference]] = PSchema(None, alias=\"schema\")\n+    schema_: Optional[Union[Schema, Reference]] = PSchema(\n+        None, alias=\"schema\"\n+    )  # type: ignore\n     example: Optional[Any] = None\n     examples: Optional[Dict[str, Union[Example, Reference]]] = None\n     # Serialization rules for more complex scenarios\n@@ -167,7 +171,7 @@ class ParameterBase(BaseModel):\n \n class Parameter(ParameterBase):\n     name: str\n-    in_: ParameterInType = PSchema(..., alias=\"in\")\n+    in_: ParameterInType = PSchema(..., alias=\"in\")  # type: ignore\n \n \n class Header(ParameterBase):\n@@ -222,7 +226,7 @@ class Operation(BaseModel):\n \n \n class PathItem(BaseModel):\n-    ref: Optional[str] = PSchema(None, alias=\"$ref\")\n+    ref: Optional[str] = PSchema(None, alias=\"$ref\")  # type: ignore\n     summary: Optional[str] = None\n     description: Optional[str] = None\n     get: Optional[Operation] = None\n@@ -250,7 +254,7 @@ class SecuritySchemeType(Enum):\n \n \n class SecurityBase(BaseModel):\n-    type_: SecuritySchemeType = PSchema(..., alias=\"type\")\n+    type_: SecuritySchemeType = PSchema(..., alias=\"type\")  # type: ignore\n     description: Optional[str] = None\n \n \n@@ -261,13 +265,13 @@ class APIKeyIn(Enum):\n \n \n class APIKey(SecurityBase):\n-    type_ = PSchema(SecuritySchemeType.apiKey, alias=\"type\")\n-    in_: APIKeyIn = PSchema(..., alias=\"in\")\n+    type_ = PSchema(SecuritySchemeType.apiKey, alias=\"type\")  # type: ignore\n+    in_: APIKeyIn = PSchema(..., alias=\"in\")  # type: ignore\n     name: str\n \n \n class HTTPBase(SecurityBase):\n-    type_ = PSchema(SecuritySchemeType.http, alias=\"type\")\n+    type_ = PSchema(SecuritySchemeType.http, alias=\"type\")  # type: ignore\n     scheme: str\n \n \n@@ -306,12 +310,12 @@ class OAuthFlows(BaseModel):\n \n \n class OAuth2(SecurityBase):\n-    type_ = PSchema(SecuritySchemeType.oauth2, alias=\"type\")\n+    type_ = PSchema(SecuritySchemeType.oauth2, alias=\"type\")  # type: ignore\n     flows: OAuthFlows\n \n \n class OpenIdConnect(SecurityBase):\n-    type_ = PSchema(SecuritySchemeType.openIdConnect, alias=\"type\")\n+    type_ = PSchema(SecuritySchemeType.openIdConnect, alias=\"type\")  # type: ignore\n     openIdConnectUrl: str\n \n \n\n@@ -1,23 +1,21 @@\n-from typing import Any, Dict, Sequence, Type, List\n+from typing import Any, Dict, List, Optional, Sequence, Tuple, Type\n \n from pydantic.fields import Field\n-from pydantic.schema import field_schema, get_model_name_map\n+from pydantic.schema import Schema, field_schema, get_model_name_map\n from pydantic.utils import lenient_issubclass\n-\n from starlette.responses import HTMLResponse, JSONResponse\n-from starlette.routing import BaseRoute\n+from starlette.routing import BaseRoute, Route\n from starlette.status import HTTP_422_UNPROCESSABLE_ENTITY\n \n from fastapi import routing\n from fastapi.dependencies.models import Dependant\n from fastapi.dependencies.utils import get_flat_dependant\n from fastapi.encoders import jsonable_encoder\n-from fastapi.openapi.constants import REF_PREFIX, METHODS_WITH_BODY\n+from fastapi.openapi.constants import METHODS_WITH_BODY, REF_PREFIX\n from fastapi.openapi.models import OpenAPI\n-from fastapi.params import Body\n+from fastapi.params import Body, Param\n from fastapi.utils import get_flat_models_from_routes, get_model_definitions\n \n-\n validation_error_definition = {\n     \"title\": \"ValidationError\",\n     \"type\": \"object\",\n@@ -42,7 +40,7 @@ validation_error_response_definition = {\n }\n \n \n-def get_openapi_params(dependant: Dependant):\n+def get_openapi_params(dependant: Dependant) -> List[Field]:\n     flat_dependant = get_flat_dependant(dependant)\n     return (\n         flat_dependant.path_params\n@@ -52,7 +50,7 @@ def get_openapi_params(dependant: Dependant):\n     )\n \n \n-def get_openapi_security_definitions(flat_dependant: Dependant):\n+def get_openapi_security_definitions(flat_dependant: Dependant) -> Tuple[Dict, List]:\n     security_definitions = {}\n     operation_security = []\n     for security_requirement in flat_dependant.security_requirements:\n@@ -61,59 +59,60 @@ def get_openapi_security_definitions(flat_dependant: Dependant):\n             by_alias=True,\n             include_none=False,\n         )\n-        security_name = (\n-            security_requirement.security_scheme.scheme_name\n-            \n-        )\n+        security_name = security_requirement.security_scheme.scheme_name\n         security_definitions[security_name] = security_definition\n         operation_security.append({security_name: security_requirement.scopes})\n     return security_definitions, operation_security\n \n \n-def get_openapi_operation_parameters(all_route_params: List[Field]):\n+def get_openapi_operation_parameters(\n+    all_route_params: Sequence[Field]\n+) -> Tuple[Dict[str, Dict], List[Dict[str, Any]]]:\n     definitions: Dict[str, Dict] = {}\n     parameters = []\n     for param in all_route_params:\n+        schema: Param = param.schema\n         if \"ValidationError\" not in definitions:\n             definitions[\"ValidationError\"] = validation_error_definition\n             definitions[\"HTTPValidationError\"] = validation_error_response_definition\n         parameter = {\n             \"name\": param.alias,\n-            \"in\": param.schema.in_.value,\n+            \"in\": schema.in_.value,\n             \"required\": param.required,\n             \"schema\": field_schema(param, model_name_map={})[0],\n         }\n-        if param.schema.description:\n-            parameter[\"description\"] = param.schema.description\n-        if param.schema.deprecated:\n-            parameter[\"deprecated\"] = param.schema.deprecated\n+        if schema.description:\n+            parameter[\"description\"] = schema.description\n+        if schema.deprecated:\n+            parameter[\"deprecated\"] = schema.deprecated\n         parameters.append(parameter)\n     return definitions, parameters\n \n \n def get_openapi_operation_request_body(\n     *, body_field: Field, model_name_map: Dict[Type, str]\n-):\n+) -> Optional[Dict]:\n     if not body_field:\n         return None\n     assert isinstance(body_field, Field)\n     body_schema, _ = field_schema(\n         body_field, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n     )\n-    if isinstance(body_field.schema, Body):\n-        request_media_type = body_field.schema.media_type\n+    schema: Schema = body_field.schema\n+    if isinstance(schema, Body):\n+        request_media_type = schema.media_type\n     else:\n         # Includes not declared media types (Schema)\n         request_media_type = \"application/json\"\n     required = body_field.required\n-    request_body_oai = {}\n+    request_body_oai: Dict[str, Any] = {}\n     if required:\n         request_body_oai[\"required\"] = required\n     request_body_oai[\"content\"] = {request_media_type: {\"schema\": body_schema}}\n     return request_body_oai\n \n \n-def generate_operation_id(*, route: routing.APIRoute, method: str):\n+def generate_operation_id(*, route: routing.APIRoute, method: str) -> str:\n     if route.operation_id:\n         return route.operation_id\n     path: str = route.path\n@@ -123,12 +122,13 @@ def generate_operation_id(*, route: routing.APIRoute, method: str):\n     return operation_id\n \n \n-def generate_operation_summary(*, route: routing.APIRoute, method: str):\n+def generate_operation_summary(*, route: routing.APIRoute, method: str) -> str:\n     if route.summary:\n         return route.summary\n     return method.title() + \" \" + route.name.replace(\"_\", \" \").title()\n \n-def get_openapi_operation_metadata(*, route: BaseRoute, method: str):\n+\n+def get_openapi_operation_metadata(*, route: routing.APIRoute, method: str) -> Dict:\n     operation: Dict[str, Any] = {}\n     if route.tags:\n         operation[\"tags\"] = route.tags\n@@ -141,12 +141,13 @@ def get_openapi_operation_metadata(*, route: BaseRoute, method: str):\n     return operation\n \n \n-def get_openapi_path(*, route: BaseRoute, model_name_map: Dict[Type, str]):\n-    if not (route.include_in_schema and isinstance(route, routing.APIRoute)):\n-        return None\n+def get_openapi_path(\n+    *, route: routing.APIRoute, model_name_map: Dict[Type, str]\n+) -> Tuple[Dict, Dict, Dict]:\n     path = {}\n     security_schemes: Dict[str, Any] = {}\n     definitions: Dict[str, Any] = {}\n+    assert route.methods is not None, \"Methods must be a list\"\n     for method in route.methods:\n         operation = get_openapi_operation_metadata(route=route, method=method)\n         parameters: List[Dict] = []\n@@ -172,10 +173,9 @@ def get_openapi_path(*, route: BaseRoute, model_name_map: Dict[Type, str]):\n             )\n             if request_body_oai:\n                 operation[\"requestBody\"] = request_body_oai\n-        response_code = str(route.response_code)\n+        status_code = str(route.status_code)\n         response_schema = {\"type\": \"string\"}\n-        if lenient_issubclass(route.response_wrapper, JSONResponse):\n-            response_media_type = \"application/json\"\n+        if lenient_issubclass(route.content_type, JSONResponse):\n             if route.response_field:\n                 response_schema, _ = field_schema(\n                     route.response_field,\n@@ -184,16 +184,9 @@ def get_openapi_path(*, route: BaseRoute, model_name_map: Dict[Type, str]):\n                 )\n             else:\n                 response_schema = {}\n-        elif lenient_issubclass(route.response_wrapper, HTMLResponse):\n-            response_media_type = \"text/html\"\n-        else:\n-            response_media_type = \"text/plain\"\n-        content = {response_media_type: {\"schema\": response_schema}}\n+        content = {route.content_type.media_type: {\"schema\": response_schema}}\n         operation[\"responses\"] = {\n-            response_code: {\n-                \"description\": route.response_description,\n-                \"content\": content,\n-            }\n+            status_code: {\"description\": route.response_description, \"content\": content}\n         }\n         if all_route_params or route.body_field:\n             operation[\"responses\"][str(HTTP_422_UNPROCESSABLE_ENTITY)] = {\n@@ -215,7 +208,7 @@ def get_openapi(\n     openapi_version: str = \"3.0.2\",\n     description: str = None,\n     routes: Sequence[BaseRoute]\n-):\n+) -> Dict:\n     info = {\"title\": title, \"version\": version}\n     if description:\n         info[\"description\"] = description\n@@ -228,13 +221,16 @@ def get_openapi(\n         flat_models=flat_models, model_name_map=model_name_map\n     )\n     for route in routes:\n+        if isinstance(route, routing.APIRoute):\n             result = get_openapi_path(route=route, model_name_map=model_name_map)\n             if result:\n                 path, security_schemes, path_definitions = result\n                 if path:\n                     paths.setdefault(route.path, {}).update(path)\n                 if security_schemes:\n-                components.setdefault(\"securitySchemes\", {}).update(security_schemes)\n+                    components.setdefault(\"securitySchemes\", {}).update(\n+                        security_schemes\n+                    )\n                 if path_definitions:\n                     definitions.update(path_definitions)\n     if definitions:\n\n@@ -1,5 +1,5 @@\n from enum import Enum\n-from typing import Sequence, Any, Dict\n+from typing import Any, Callable, Sequence\n \n from pydantic import Schema\n \n@@ -16,7 +16,7 @@ class Param(Schema):\n \n     def __init__(\n         self,\n-        default,\n+        default: Any,\n         *,\n         deprecated: bool = None,\n         alias: str = None,\n@@ -29,7 +29,7 @@ class Param(Schema):\n         min_length: int = None,\n         max_length: int = None,\n         regex: str = None,\n-        **extra: Dict[str, Any],\n+        **extra: Any,\n     ):\n         self.deprecated = deprecated\n         super().__init__(\n@@ -53,7 +53,7 @@ class Path(Param):\n \n     def __init__(\n         self,\n-        default,\n+        default: Any,\n         *,\n         deprecated: bool = None,\n         alias: str = None,\n@@ -66,7 +66,7 @@ class Path(Param):\n         min_length: int = None,\n         max_length: int = None,\n         regex: str = None,\n-        **extra: Dict[str, Any],\n+        **extra: Any,\n     ):\n         self.description = description\n         self.deprecated = deprecated\n@@ -92,7 +92,7 @@ class Query(Param):\n \n     def __init__(\n         self,\n-        default,\n+        default: Any,\n         *,\n         deprecated: bool = None,\n         alias: str = None,\n@@ -105,7 +105,7 @@ class Query(Param):\n         min_length: int = None,\n         max_length: int = None,\n         regex: str = None,\n-        **extra: Dict[str, Any],\n+        **extra: Any,\n     ):\n         self.description = description\n         self.deprecated = deprecated\n@@ -130,10 +130,11 @@ class Header(Param):\n \n     def __init__(\n         self,\n-        default,\n+        default: Any,\n         *,\n         deprecated: bool = None,\n         alias: str = None,\n+        alias_underscore_to_hyphen: bool = True,\n         title: str = None,\n         description: str = None,\n         gt: float = None,\n@@ -143,10 +144,11 @@ class Header(Param):\n         min_length: int = None,\n         max_length: int = None,\n         regex: str = None,\n-        **extra: Dict[str, Any],\n+        **extra: Any,\n     ):\n         self.description = description\n         self.deprecated = deprecated\n+        self.alias_underscore_to_hyphen = alias_underscore_to_hyphen\n         super().__init__(\n             default,\n             alias=alias,\n@@ -168,7 +170,7 @@ class Cookie(Param):\n \n     def __init__(\n         self,\n-        default,\n+        default: Any,\n         *,\n         deprecated: bool = None,\n         alias: str = None,\n@@ -181,7 +183,7 @@ class Cookie(Param):\n         min_length: int = None,\n         max_length: int = None,\n         regex: str = None,\n-        **extra: Dict[str, Any],\n+        **extra: Any,\n     ):\n         self.description = description\n         self.deprecated = deprecated\n@@ -204,9 +206,9 @@ class Cookie(Param):\n class Body(Schema):\n     def __init__(\n         self,\n-        default,\n+        default: Any,\n         *,\n-        embed=False,\n+        embed: bool = False,\n         media_type: str = \"application/json\",\n         alias: str = None,\n         title: str = None,\n@@ -218,7 +220,7 @@ class Body(Schema):\n         min_length: int = None,\n         max_length: int = None,\n         regex: str = None,\n-        **extra: Dict[str, Any],\n+        **extra: Any,\n     ):\n         self.embed = embed\n         self.media_type = media_type\n@@ -241,9 +243,9 @@ class Body(Schema):\n class Form(Body):\n     def __init__(\n         self,\n-        default,\n+        default: Any,\n         *,\n-        sub_key=False,\n+        sub_key: bool = False,\n         media_type: str = \"application/x-www-form-urlencoded\",\n         alias: str = None,\n         title: str = None,\n@@ -255,7 +257,7 @@ class Form(Body):\n         min_length: int = None,\n         max_length: int = None,\n         regex: str = None,\n-        **extra: Dict[str, Any],\n+        **extra: Any,\n     ):\n         super().__init__(\n             default,\n@@ -278,9 +280,9 @@ class Form(Body):\n class File(Form):\n     def __init__(\n         self,\n-        default,\n+        default: Any,\n         *,\n-        sub_key=False,\n+        sub_key: bool = False,\n         media_type: str = \"multipart/form-data\",\n         alias: str = None,\n         title: str = None,\n@@ -292,7 +294,7 @@ class File(Form):\n         min_length: int = None,\n         max_length: int = None,\n         regex: str = None,\n-        **extra: Dict[str, Any],\n+        **extra: Any,\n     ):\n         super().__init__(\n             default,\n@@ -313,11 +315,11 @@ class File(Form):\n \n \n class Depends:\n-    def __init__(self, dependency=None):\n+    def __init__(self, dependency: Callable = None):\n         self.dependency = dependency\n \n \n class Security(Depends):\n-    def __init__(self, dependency=None, scopes: Sequence[str] = None):\n+    def __init__(self, dependency: Callable = None, scopes: Sequence[str] = None):\n         self.scopes = scopes or []\n         super().__init__(dependency=dependency)\n\n@@ -1,12 +1,11 @@\n import asyncio\n import inspect\n-from typing import Callable, List, Type\n+from typing import Any, Callable, List, Optional, Type\n \n from pydantic import BaseConfig, BaseModel, Schema\n from pydantic.error_wrappers import ErrorWrapper, ValidationError\n from pydantic.fields import Field\n from pydantic.utils import lenient_issubclass\n-\n from starlette import routing\n from starlette.concurrency import run_in_threadpool\n from starlette.exceptions import HTTPException\n@@ -22,7 +21,7 @@ from fastapi.dependencies.utils import get_body_field, get_dependant, solve_depe\n from fastapi.encoders import jsonable_encoder\n \n \n-def serialize_response(*, field: Field = None, response):\n+def serialize_response(*, field: Field = None, response: Response) -> Any:\n     if field:\n         errors = []\n         value, errors_ = field.validate(response, {}, loc=(\"response\",))\n@@ -40,11 +39,12 @@ def serialize_response(*, field: Field = None, response):\n def get_app(\n     dependant: Dependant,\n     body_field: Field = None,\n-    response_code: str = 200,\n-    response_wrapper: Type[Response] = JSONResponse,\n-    response_field: Type[Field] = None,\n-):\n-    is_coroutine = dependant.call and asyncio.iscoroutinefunction(dependant.call)\n+    status_code: int = 200,\n+    content_type: Type[Response] = JSONResponse,\n+    response_field: Field = None,\n+) -> Callable:\n+    assert dependant.call is not None, \"dependant.call must me a function\"\n+    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n     is_body_form = body_field and isinstance(body_field.schema, params.Form)\n \n     async def app(request: Request) -> Response:\n@@ -69,6 +69,7 @@ def get_app(\n                 status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=errors_out.errors()\n             )\n         else:\n+            assert dependant.call is not None, \"dependant.call must me a function\"\n             if is_coroutine:\n                 raw_response = await dependant.call(**values)\n             else:\n@@ -76,32 +77,32 @@ def get_app(\n             if isinstance(raw_response, Response):\n                 return raw_response\n             if isinstance(raw_response, BaseModel):\n-                return response_wrapper(\n-                    content=jsonable_encoder(raw_response), status_code=response_code\n+                return content_type(\n+                    content=jsonable_encoder(raw_response), status_code=status_code\n                 )\n             errors = []\n             try:\n-                return response_wrapper(\n+                return content_type(\n                     content=serialize_response(\n                         field=response_field, response=raw_response\n                     ),\n-                    status_code=response_code,\n+                    status_code=status_code,\n                 )\n             except Exception as e:\n                 errors.append(e)\n             try:\n                 response = dict(raw_response)\n-                return response_wrapper(\n+                return content_type(\n                     content=serialize_response(field=response_field, response=response),\n-                    status_code=response_code,\n+                    status_code=status_code,\n                 )\n             except Exception as e:\n                 errors.append(e)\n             try:\n                 response = vars(raw_response)\n-                return response_wrapper(\n+                return content_type(\n                     content=serialize_response(field=response_field, response=response),\n-                    status_code=response_code,\n+                    status_code=status_code,\n                 )\n             except Exception as e:\n                 errors.append(e)\n@@ -116,43 +117,32 @@ class APIRoute(routing.Route):\n         path: str,\n         endpoint: Callable,\n         *,\n-        methods: List[str] = None,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n+        deprecated: bool = None,\n+        name: str = None,\n+        methods: List[str] = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n     ) -> None:\n         assert path.startswith(\"/\"), \"Routed paths must always start with '/'\"\n         self.path = path\n         self.endpoint = endpoint\n         self.name = get_name(endpoint) if name is None else name\n-        self.include_in_schema = include_in_schema\n-        self.tags = tags or []\n-        self.summary = summary\n-        self.description = description or self.endpoint.__doc__\n-        self.operation_id = operation_id\n-        self.deprecated = deprecated\n-        self.body_field: Field = None\n-        self.response_description = response_description\n-        self.response_code = response_code\n-        self.response_wrapper = response_wrapper\n-        self.response_field = None\n-        if response_type:\n+        self.response_model = response_model\n+        if self.response_model:\n             assert lenient_issubclass(\n-                response_wrapper, JSONResponse\n+                content_type, JSONResponse\n             ), \"To declare a type the response must be a JSON response\"\n-            self.response_type = response_type\n             response_name = \"Response_\" + self.name\n-            self.response_field = Field(\n+            self.response_field: Optional[Field] = Field(\n                 name=response_name,\n-                type_=self.response_type,\n+                type_=self.response_model,\n                 class_validators=[],\n                 default=None,\n                 required=False,\n@@ -160,25 +150,34 @@ class APIRoute(routing.Route):\n                 schema=Schema(None),\n             )\n         else:\n-            self.response_type = None\n+            self.response_field = None\n+        self.status_code = status_code\n+        self.tags = tags or []\n+        self.summary = summary\n+        self.description = description or self.endpoint.__doc__\n+        self.response_description = response_description\n+        self.deprecated = deprecated\n         if methods is None:\n             methods = [\"GET\"]\n         self.methods = methods\n+        self.operation_id = operation_id\n+        self.include_in_schema = include_in_schema\n+        self.content_type = content_type\n+\n         self.path_regex, self.path_format, self.param_convertors = self.compile_path(\n             path\n         )\n         assert inspect.isfunction(endpoint) or inspect.ismethod(\n             endpoint\n         ), f\"An endpoint must be a function or method\"\n-\n         self.dependant = get_dependant(path=path, call=self.endpoint)\n         self.body_field = get_body_field(dependant=self.dependant, name=self.name)\n         self.app = request_response(\n             get_app(\n                 dependant=self.dependant,\n                 body_field=self.body_field,\n-                response_code=self.response_code,\n-                response_wrapper=self.response_wrapper,\n+                status_code=self.status_code,\n+                content_type=self.content_type,\n                 response_field=self.response_field,\n             )\n         )\n@@ -189,75 +188,77 @@ class APIRouter(routing.Router):\n         self,\n         path: str,\n         endpoint: Callable,\n-        methods: List[str] = None,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n+        deprecated: bool = None,\n+        name: str = None,\n+        methods: List[str] = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n     ) -> None:\n         route = APIRoute(\n             path,\n             endpoint=endpoint,\n-            methods=methods,\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            methods=methods,\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n         self.routes.append(route)\n \n     def api_route(\n         self,\n         path: str,\n-        methods: List[str] = None,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n+        deprecated: bool = None,\n+        name: str = None,\n+        methods: List[str] = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n     ) -> Callable:\n         def decorator(func: Callable) -> Callable:\n             self.add_api_route(\n                 path,\n                 func,\n-                methods=methods,\n-                name=name,\n-                include_in_schema=include_in_schema,\n+                response_model=response_model,\n+                status_code=status_code,\n                 tags=tags or [],\n                 summary=summary,\n                 description=description,\n-                operation_id=operation_id,\n-                deprecated=deprecated,\n-                response_type=response_type,\n                 response_description=response_description,\n-                response_code=response_code,\n-                response_wrapper=response_wrapper,\n+                deprecated=deprecated,\n+                name=name,\n+                methods=methods,\n+                operation_id=operation_id,\n+                include_in_schema=include_in_schema,\n+                content_type=content_type,\n             )\n             return func\n \n         return decorator\n \n-    def include_router(self, router: \"APIRouter\", *, prefix=\"\"):\n+    def include_router(self, router: \"APIRouter\", *, prefix: str = \"\") -> None:\n         if prefix:\n             assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n             assert not prefix.endswith(\n@@ -268,18 +269,18 @@ class APIRouter(routing.Router):\n                 self.add_api_route(\n                     prefix + route.path,\n                     route.endpoint,\n-                    methods=route.methods,\n-                    name=route.name,\n-                    include_in_schema=route.include_in_schema,\n-                    tags=route.tags,\n+                    response_model=route.response_model,\n+                    status_code=route.status_code,\n+                    tags=route.tags or [],\n                     summary=route.summary,\n                     description=route.description,\n-                    operation_id=route.operation_id,\n-                    deprecated=route.deprecated,\n-                    response_type=route.response_type,\n                     response_description=route.response_description,\n-                    response_code=route.response_code,\n-                    response_wrapper=route.response_wrapper,\n+                    deprecated=route.deprecated,\n+                    name=route.name,\n+                    methods=route.methods,\n+                    operation_id=route.operation_id,\n+                    include_in_schema=route.include_in_schema,\n+                    content_type=route.content_type,\n                 )\n             elif isinstance(route, routing.Route):\n                 self.add_route(\n@@ -293,247 +294,255 @@ class APIRouter(routing.Router):\n     def get(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.api_route(\n             path=path,\n-            methods=[\"GET\"],\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            methods=[\"GET\"],\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def put(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.api_route(\n             path=path,\n-            methods=[\"PUT\"],\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            methods=[\"PUT\"],\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def post(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.api_route(\n             path=path,\n-            methods=[\"POST\"],\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            methods=[\"POST\"],\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def delete(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.api_route(\n             path=path,\n-            methods=[\"DELETE\"],\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            methods=[\"DELETE\"],\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def options(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.api_route(\n             path=path,\n-            methods=[\"OPTIONS\"],\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            methods=[\"OPTIONS\"],\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def head(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.api_route(\n             path=path,\n-            methods=[\"HEAD\"],\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            methods=[\"HEAD\"],\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def patch(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.api_route(\n             path=path,\n-            methods=[\"PATCH\"],\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            methods=[\"PATCH\"],\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n \n     def trace(\n         self,\n         path: str,\n-        name: str = None,\n-        include_in_schema: bool = True,\n+        *,\n+        response_model: Type[BaseModel] = None,\n+        status_code: int = 200,\n         tags: List[str] = None,\n         summary: str = None,\n         description: str = None,\n-        operation_id: str = None,\n-        deprecated: bool = None,\n-        response_type: Type = None,\n         response_description: str = \"Successful Response\",\n-        response_code=200,\n-        response_wrapper=JSONResponse,\n-    ):\n+        deprecated: bool = None,\n+        name: str = None,\n+        operation_id: str = None,\n+        include_in_schema: bool = True,\n+        content_type: Type[Response] = JSONResponse,\n+    ) -> Callable:\n         return self.api_route(\n             path=path,\n-            methods=[\"TRACE\"],\n-            name=name,\n-            include_in_schema=include_in_schema,\n+            response_model=response_model,\n+            status_code=status_code,\n             tags=tags or [],\n             summary=summary,\n             description=description,\n-            operation_id=operation_id,\n-            deprecated=deprecated,\n-            response_type=response_type,\n             response_description=response_description,\n-            response_code=response_code,\n-            response_wrapper=response_wrapper,\n+            deprecated=deprecated,\n+            name=name,\n+            methods=[\"TRACE\"],\n+            operation_id=operation_id,\n+            include_in_schema=include_in_schema,\n+            content_type=content_type,\n         )\n\n@@ -1,18 +1,19 @@\n from starlette.requests import Request\n \n-from .base import SecurityBase\n-from fastapi.openapi.models import APIKeyIn, APIKey\n+from fastapi.openapi.models import APIKey, APIKeyIn\n+from fastapi.security.base import SecurityBase\n+\n \n class APIKeyBase(SecurityBase):\n     pass\n \n-class APIKeyQuery(APIKeyBase):\n \n+class APIKeyQuery(APIKeyBase):\n     def __init__(self, *, name: str, scheme_name: str = None):\n         self.model = APIKey(in_=APIKeyIn.query, name=name)\n         self.scheme_name = scheme_name or self.__class__.__name__\n \n-    async def __call__(self, requests: Request):\n+    async def __call__(self, requests: Request) -> str:\n         return requests.query_params.get(self.model.name)\n \n \n@@ -21,7 +22,7 @@ class APIKeyHeader(APIKeyBase):\n         self.model = APIKey(in_=APIKeyIn.header, name=name)\n         self.scheme_name = scheme_name or self.__class__.__name__\n \n-    async def __call__(self, requests: Request):\n+    async def __call__(self, requests: Request) -> str:\n         return requests.headers.get(self.model.name)\n \n \n@@ -30,5 +31,5 @@ class APIKeyCookie(APIKeyBase):\n         self.model = APIKey(in_=APIKeyIn.cookie, name=name)\n         self.scheme_name = scheme_name or self.__class__.__name__\n \n-    async def __call__(self, requests: Request):\n+    async def __call__(self, requests: Request) -> str:\n         return requests.cookies.get(self.model.name)\n\n@@ -1,6 +1,6 @@\n-from pydantic import BaseModel\n-\n from fastapi.openapi.models import SecurityBase as SecurityBaseModel\n \n+\n class SecurityBase:\n-    pass\n+    model: SecurityBaseModel\n+    scheme_name: str\n\n@@ -1,7 +1,10 @@\n from starlette.requests import Request\n \n-from .base import SecurityBase\n-from fastapi.openapi.models import HTTPBase as HTTPBaseModel, HTTPBearer as HTTPBearerModel\n+from fastapi.openapi.models import (\n+    HTTPBase as HTTPBaseModel,\n+    HTTPBearer as HTTPBearerModel,\n+)\n+from fastapi.security.base import SecurityBase\n \n \n class HTTPBase(SecurityBase):\n@@ -9,7 +12,7 @@ class HTTPBase(SecurityBase):\n         self.model = HTTPBaseModel(scheme=scheme)\n         self.scheme_name = scheme_name or self.__class__.__name__\n \n-    async def __call__(self, request: Request):\n+    async def __call__(self, request: Request) -> str:\n         return request.headers.get(\"Authorization\")\n \n \n@@ -18,7 +21,7 @@ class HTTPBasic(HTTPBase):\n         self.model = HTTPBaseModel(scheme=\"basic\")\n         self.scheme_name = scheme_name or self.__class__.__name__\n \n-    async def __call__(self, request: Request):\n+    async def __call__(self, request: Request) -> str:\n         return request.headers.get(\"Authorization\")\n \n \n@@ -27,7 +30,7 @@ class HTTPBearer(HTTPBase):\n         self.model = HTTPBearerModel(bearerFormat=bearerFormat)\n         self.scheme_name = scheme_name or self.__class__.__name__\n \n-    async def __call__(self, request: Request):\n+    async def __call__(self, request: Request) -> str:\n         return request.headers.get(\"Authorization\")\n \n \n@@ -36,5 +39,5 @@ class HTTPDigest(HTTPBase):\n         self.model = HTTPBaseModel(scheme=\"digest\")\n         self.scheme_name = scheme_name or self.__class__.__name__\n \n-    async def __call__(self, request: Request):\n+    async def __call__(self, request: Request) -> str:\n         return request.headers.get(\"Authorization\")\n\n@@ -1,13 +1,15 @@\n from starlette.requests import Request\n \n-from .base import SecurityBase\n from fastapi.openapi.models import OAuth2 as OAuth2Model, OAuthFlows as OAuthFlowsModel\n+from fastapi.security.base import SecurityBase\n \n \n class OAuth2(SecurityBase):\n-    def __init__(self, *, flows: OAuthFlowsModel = OAuthFlowsModel(), scheme_name: str = None):\n+    def __init__(\n+        self, *, flows: OAuthFlowsModel = OAuthFlowsModel(), scheme_name: str = None\n+    ):\n         self.model = OAuth2Model(flows=flows)\n         self.scheme_name = scheme_name or self.__class__.__name__\n \n-    async def __call__(self, request: Request):\n+    async def __call__(self, request: Request) -> str:\n         return request.headers.get(\"Authorization\")\n\n@@ -1,7 +1,7 @@\n from starlette.requests import Request\n \n-from .base import SecurityBase\n from fastapi.openapi.models import OpenIdConnect as OpenIdConnectModel\n+from fastapi.security.base import SecurityBase\n \n \n class OpenIdConnect(SecurityBase):\n@@ -9,5 +9,5 @@ class OpenIdConnect(SecurityBase):\n         self.model = OpenIdConnectModel(openIdConnectUrl=openIdConnectUrl)\n         self.scheme_name = scheme_name or self.__class__.__name__\n \n-    async def __call__(self, request: Request):\n+    async def __call__(self, request: Request) -> str:\n         return request.headers.get(\"Authorization\")\n\n@@ -1,20 +1,24 @@\n import re\n-from typing import Dict, Sequence, Set, Type\n+from typing import Any, Dict, List, Sequence, Set, Type\n \n+from pydantic import BaseModel\n+from pydantic.fields import Field\n+from pydantic.schema import get_flat_models_from_fields, model_process_schema\n from starlette.routing import BaseRoute\n \n from fastapi import routing\n from fastapi.openapi.constants import REF_PREFIX\n-from pydantic import BaseModel\n-from pydantic.fields import Field\n-from pydantic.schema import get_flat_models_from_fields, model_process_schema\n \n \n-def get_flat_models_from_routes(routes: Sequence[BaseRoute]):\n-    body_fields_from_routes = []\n-    responses_from_routes = []\n+def get_flat_models_from_routes(\n+    routes: Sequence[Type[BaseRoute]]\n+) -> Set[Type[BaseModel]]:\n+    body_fields_from_routes: List[Field] = []\n+    responses_from_routes: List[Field] = []\n     for route in routes:\n-        if route.include_in_schema and isinstance(route, routing.APIRoute):\n+        if getattr(route, \"include_in_schema\", None) and isinstance(\n+            route, routing.APIRoute\n+        ):\n             if route.body_field:\n                 assert isinstance(\n                     route.body_field, Field\n@@ -30,7 +34,7 @@ def get_flat_models_from_routes(routes: Sequence[BaseRoute]):\n \n def get_model_definitions(\n     *, flat_models: Set[Type[BaseModel]], model_name_map: Dict[Type[BaseModel], str]\n-):\n+) -> Dict[str, Any]:\n     definitions: Dict[str, Dict] = {}\n     for model in flat_models:\n         m_schema, m_definitions = model_process_schema(\n@@ -42,5 +46,5 @@ def get_model_definitions(\n     return definitions\n \n \n-def get_path_param_names(path: str):\n+def get_path_param_names(path: str) -> Set[str]:\n     return {item.strip(\"{}\") for item in re.findall(\"{[^}]*}\", path)}\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
