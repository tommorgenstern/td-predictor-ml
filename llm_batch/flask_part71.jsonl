{"custom_id": "flask#d63c2bc4178b0a371ee53c9d94b73c7be3174c9d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 29 | Lines Deleted: 30 | Files Changed: 2 | Hunks: 7 | Methods Changed: 3 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 59 | Churn Cumulative: 7442 | Contributors (this commit): 97 | Commits (past 90d): 46 | Contributors (cumulative): 109 | DMM Complexity: 0.0\n\nDIFF:\n@@ -349,29 +349,38 @@ class Flask(_PackageBoundObject):\n     #: resources contained in the package.\n     root_path = None\n \n-    def __init__(self, import_name, static_path=None, static_url_path=None,\n-                 static_folder='static', static_host=None,\n-                 host_matching=False, template_folder='templates',\n-                 instance_path=None, instance_relative_config=False,\n-                 root_path=None):\n-        _PackageBoundObject.__init__(self, import_name,\n+    def __init__(\n+        self,\n+        import_name,\n+        static_url_path=None,\n+        static_folder='static',\n+        static_host=None,\n+        host_matching=False,\n+        template_folder='templates',\n+        instance_path=None,\n+        instance_relative_config=False,\n+        root_path=None\n+    ):\n+        _PackageBoundObject.__init__(\n+            self,\n+            import_name,\n             template_folder=template_folder,\n-                                     root_path=root_path)\n-        if static_path is not None:\n-            from warnings import warn\n-            warn(DeprecationWarning('static_path is now called '\n-                                    'static_url_path'), stacklevel=2)\n-            static_url_path = static_path\n+            root_path=root_path\n+        )\n \n         if static_url_path is not None:\n             self.static_url_path = static_url_path\n+\n         if static_folder is not None:\n             self.static_folder = static_folder\n+\n         if instance_path is None:\n             instance_path = self.auto_find_instance_path()\n         elif not os.path.isabs(instance_path):\n-            raise ValueError('If an instance path is provided it must be '\n-                             'absolute.  A relative path was given instead.')\n+            raise ValueError(\n+                'If an instance path is provided it must be absolute.'\n+                ' A relative path was given instead.'\n+            )\n \n         #: Holds the path to the instance folder.\n         #:\n@@ -547,9 +556,12 @@ class Flask(_PackageBoundObject):\n         # development). Also, Google App Engine stores static files somewhere\n         if self.has_static_folder:\n             assert bool(static_host) == host_matching, 'Invalid static_host/host_matching combination'\n-            self.add_url_rule(self.static_url_path + '/<path:filename>',\n-                              endpoint='static', host=static_host,\n-                              view_func=self.send_static_file)\n+            self.add_url_rule(\n+                self.static_url_path + '/<path:filename>',\n+                endpoint='static',\n+                host=static_host,\n+                view_func=self.send_static_file\n+            )\n \n         #: The click command line context for this application.  Commands\n         #: registered here show up in the :command:`flask` command once the\n\n@@ -1353,19 +1353,6 @@ def test_static_files(app, client):\n     rv.close()\n \n \n-def test_static_path_deprecated(recwarn):\n-    app = flask.Flask(__name__, static_path='/foo')\n-    recwarn.pop(DeprecationWarning)\n-\n-    app.testing = True\n-    rv = app.test_client().get('/foo/index.html')\n-    assert rv.status_code == 200\n-    rv.close()\n-\n-    with app.test_request_context():\n-        assert flask.url_for('static', filename='index.html') == '/foo/index.html'\n-\n-\n def test_static_url_path():\n     app = flask.Flask(__name__, static_url_path='/foo')\n     app.testing = True\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#723e6650048bc8097da20b23ebddcd4c0ad6bc61", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 45 | Files Changed: 3 | Hunks: 10 | Methods Changed: 4 | Complexity Δ (Sum/Max): -8/0 | Churn Δ: 60 | Churn Cumulative: 3479 | Contributors (this commit): 65 | Commits (past 90d): 18 | Contributors (cumulative): 79 | DMM Complexity: 0.21052631578947367\n\nDIFF:\n@@ -268,40 +268,40 @@ def url_for(endpoint, **values):\n     \"\"\"\n     appctx = _app_ctx_stack.top\n     reqctx = _request_ctx_stack.top\n+\n     if appctx is None:\n-        raise RuntimeError('Attempted to generate a URL without the '\n-                           'application context being pushed. This has to be '\n-                           'executed when application context is available.')\n+        raise RuntimeError(\n+            'Attempted to generate a URL without the application context being'\n+            ' pushed. This has to be executed when application context is'\n+            ' available.'\n+        )\n \n     # If request specific information is available we have some extra\n     # features that support \"relative\" URLs.\n     if reqctx is not None:\n         url_adapter = reqctx.url_adapter\n         blueprint_name = request.blueprint\n-        if not reqctx.request._is_old_module:\n+\n         if endpoint[:1] == '.':\n             if blueprint_name is not None:\n                 endpoint = blueprint_name + endpoint\n             else:\n                 endpoint = endpoint[1:]\n-        else:\n-            # TODO: get rid of this deprecated functionality in 1.0\n-            if '.' not in endpoint:\n-                if blueprint_name is not None:\n-                    endpoint = blueprint_name + '.' + endpoint\n-            elif endpoint.startswith('.'):\n-                endpoint = endpoint[1:]\n+\n         external = values.pop('_external', False)\n \n     # Otherwise go with the url adapter from the appctx and make\n     # the URLs external by default.\n     else:\n         url_adapter = appctx.url_adapter\n+\n         if url_adapter is None:\n-            raise RuntimeError('Application was not able to create a URL '\n-                               'adapter for request independent URL generation. '\n-                               'You might be able to fix this by setting '\n-                               'the SERVER_NAME config variable.')\n+            raise RuntimeError(\n+                'Application was not able to create a URL adapter for request'\n+                ' independent URL generation. You might be able to fix this by'\n+                ' setting the SERVER_NAME config variable.'\n+            )\n+\n         external = values.pop('_external', True)\n \n     anchor = values.pop('_anchor', None)\n\n@@ -141,10 +141,6 @@ class Request(RequestBase, JSONMixin):\n     #: something similar.\n     routing_exception = None\n \n-    # Switched by the request context until 1.0 to opt in deprecated\n-    # module functionality.\n-    _is_old_module = False\n-\n     @property\n     def max_content_length(self):\n         \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\"\n@@ -161,19 +157,6 @@ class Request(RequestBase, JSONMixin):\n         if self.url_rule is not None:\n             return self.url_rule.endpoint\n \n-    @property\n-    def module(self):\n-        \"\"\"The name of the current module if the request was dispatched\n-        to an actual module.  This is deprecated functionality, use blueprints\n-        instead.\n-        \"\"\"\n-        from warnings import warn\n-        warn(DeprecationWarning('modules were deprecated in favor of '\n-                                'blueprints.  Use request.blueprint '\n-                                'instead.'), stacklevel=2)\n-        if self._is_old_module:\n-            return self.blueprint\n-\n     @property\n     def blueprint(self):\n         \"\"\"The name of the current blueprint\"\"\"\n\n@@ -9,8 +9,6 @@\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n \n-import pytest\n-\n import flask\n \n \n@@ -26,14 +24,3 @@ class TestRequestDeprecation(object):\n \n         client.post('/', data='{\"spam\": 42}', content_type='application/json')\n         recwarn.pop(DeprecationWarning)\n-\n-    def test_request_module(self, recwarn, app, client):\n-        \"\"\"Request.module is deprecated\"\"\"\n-\n-        @app.route('/')\n-        def index():\n-            assert flask.request.module is None\n-            return 'OK'\n-\n-        client.get('/')\n-        recwarn.pop(DeprecationWarning)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#715a9a3e7bd65421c36428ba9d4a1ee06b98bbc1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 495 | Files Changed: 5 | Hunks: 5 | Methods Changed: 39 | Complexity Δ (Sum/Max): -87/0 | Churn Δ: 496 | Churn Cumulative: 1841 | Contributors (this commit): 32 | Commits (past 90d): 12 | Contributors (cumulative): 49 | DMM Complexity: 0.29045643153526973\n\nDIFF:\n@@ -1,29 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\"\"\"\n-    flask.ext\n-    ~~~~~~~~~\n-\n-    Redirect imports for extensions.  This module basically makes it possible\n-    for us to transition from flaskext.foo to flask_foo without having to\n-    force all extensions to upgrade at the same time.\n-\n-    When a user does ``from flask.ext.foo import bar`` it will attempt to\n-    import ``from flask_foo import bar`` first and when that fails it will\n-    try to import ``from flaskext.foo import bar``.\n-\n-    We're switching from namespace packages because it was just too painful for\n-    everybody involved.\n-\n-    :copyright: (c) 2015 by Armin Ronacher.\n-    :license: BSD, see LICENSE for more details.\n-\"\"\"\n-\n-\n-def setup():\n-    from ..exthook import ExtensionImporter\n-    importer = ExtensionImporter(['flask_%s', 'flaskext.%s'], __name__)\n-    importer.install()\n-\n-\n-setup()\n-del setup\n\n@@ -1,143 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\"\"\"\n-    flask.exthook\n-    ~~~~~~~~~~~~~\n-\n-    Redirect imports for extensions.  This module basically makes it possible\n-    for us to transition from flaskext.foo to flask_foo without having to\n-    force all extensions to upgrade at the same time.\n-\n-    When a user does ``from flask.ext.foo import bar`` it will attempt to\n-    import ``from flask_foo import bar`` first and when that fails it will\n-    try to import ``from flaskext.foo import bar``.\n-\n-    We're switching from namespace packages because it was just too painful for\n-    everybody involved.\n-\n-    This is used by `flask.ext`.\n-\n-    :copyright: (c) 2015 by Armin Ronacher.\n-    :license: BSD, see LICENSE for more details.\n-\"\"\"\n-import sys\n-import os\n-import warnings\n-from ._compat import reraise\n-\n-\n-class ExtDeprecationWarning(DeprecationWarning):\n-    pass\n-\n-warnings.simplefilter('always', ExtDeprecationWarning)\n-\n-\n-class ExtensionImporter(object):\n-    \"\"\"This importer redirects imports from this submodule to other locations.\n-    This makes it possible to transition from the old flaskext.name to the\n-    newer flask_name without people having a hard time.\n-    \"\"\"\n-\n-    def __init__(self, module_choices, wrapper_module):\n-        self.module_choices = module_choices\n-        self.wrapper_module = wrapper_module\n-        self.prefix = wrapper_module + '.'\n-        self.prefix_cutoff = wrapper_module.count('.') + 1\n-\n-    def __eq__(self, other):\n-        return self.__class__.__module__ == other.__class__.__module__ and \\\n-               self.__class__.__name__ == other.__class__.__name__ and \\\n-               self.wrapper_module == other.wrapper_module and \\\n-               self.module_choices == other.module_choices\n-\n-    def __ne__(self, other):\n-        return not self.__eq__(other)\n-\n-    def install(self):\n-        sys.meta_path[:] = [x for x in sys.meta_path if self != x] + [self]\n-\n-    def find_module(self, fullname, path=None):\n-        if fullname.startswith(self.prefix) and \\\n-           fullname != 'flask.ext.ExtDeprecationWarning':\n-            return self\n-\n-    def load_module(self, fullname):\n-        if fullname in sys.modules:\n-            return sys.modules[fullname]\n-\n-        modname = fullname.split('.', self.prefix_cutoff)[self.prefix_cutoff]\n-\n-        warnings.warn(\n-            \"Importing flask.ext.{x} is deprecated, use flask_{x} instead.\"\n-            .format(x=modname), ExtDeprecationWarning, stacklevel=2\n-        )\n-\n-        for path in self.module_choices:\n-            realname = path % modname\n-            try:\n-                __import__(realname)\n-            except ImportError:\n-                exc_type, exc_value, tb = sys.exc_info()\n-                # since we only establish the entry in sys.modules at the\n-                # very this seems to be redundant, but if recursive imports\n-                # happen we will call into the move import a second time.\n-                # On the second invocation we still don't have an entry for\n-                # fullname in sys.modules, but we will end up with the same\n-                # fake module name and that import will succeed since this\n-                # one already has a temporary entry in the modules dict.\n-                # Since this one \"succeeded\" temporarily that second\n-                # invocation now will have created a fullname entry in\n-                # sys.modules which we have to kill.\n-                sys.modules.pop(fullname, None)\n-\n-                # If it's an important traceback we reraise it, otherwise\n-                # we swallow it and try the next choice.  The skipped frame\n-                # is the one from __import__ above which we don't care about\n-                if self.is_important_traceback(realname, tb):\n-                    reraise(exc_type, exc_value, tb.tb_next)\n-                continue\n-            module = sys.modules[fullname] = sys.modules[realname]\n-            if '.' not in modname:\n-                setattr(sys.modules[self.wrapper_module], modname, module)\n-\n-            if realname.startswith('flaskext.'):\n-                warnings.warn(\n-                    \"Detected extension named flaskext.{x}, please rename it \"\n-                    \"to flask_{x}. The old form is deprecated.\"\n-                    .format(x=modname), ExtDeprecationWarning\n-                )\n-\n-            return module\n-        raise ImportError('No module named %s' % fullname)\n-\n-    def is_important_traceback(self, important_module, tb):\n-        \"\"\"Walks a traceback's frames and checks if any of the frames\n-        originated in the given important module.  If that is the case then we\n-        were able to import the module itself but apparently something went\n-        wrong when the module was imported.  (Eg: import of an import failed).\n-        \"\"\"\n-        while tb is not None:\n-            if self.is_important_frame(important_module, tb):\n-                return True\n-            tb = tb.tb_next\n-        return False\n-\n-    def is_important_frame(self, important_module, tb):\n-        \"\"\"Checks a single frame if it's important.\"\"\"\n-        g = tb.tb_frame.f_globals\n-        if '__name__' not in g:\n-            return False\n-\n-        module_name = g['__name__']\n-\n-        # Python 2.7 Behavior.  Modules are cleaned up late so the\n-        # name shows up properly here.  Success!\n-        if module_name == important_module:\n-            return True\n-\n-        # Some python versions will clean up modules so early that the\n-        # module name at that point is no longer set.  Try guessing from\n-        # the filename then.\n-        filename = os.path.abspath(tb.tb_frame.f_code.co_filename)\n-        test_string = os.path.sep + important_module.replace('.', os.path.sep)\n-        return test_string + '.py' in filename or \\\n-               test_string + os.path.sep + '__init__.py' in filename\n\n@@ -1,125 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\"\"\"\n-    flaskext_compat\n-    ~~~~~~~~~~~~~~~\n-\n-    Implements the ``flask.ext`` virtual package for versions of Flask\n-    older than 0.7.  This module is a noop if Flask 0.8 was detected.\n-\n-    Usage::\n-\n-        import flaskext_compat\n-        flaskext_compat.activate()\n-        from flask.ext import foo\n-\n-    :copyright: (c) 2015 by Armin Ronacher.\n-    :license: BSD, see LICENSE for more details.\n-\"\"\"\n-import types\n-import sys\n-import os\n-\n-\n-class ExtensionImporter(object):\n-    \"\"\"This importer redirects imports from this submodule to other locations.\n-    This makes it possible to transition from the old flaskext.name to the\n-    newer flask_name without people having a hard time.\n-    \"\"\"\n-\n-    def __init__(self, module_choices, wrapper_module):\n-        self.module_choices = module_choices\n-        self.wrapper_module = wrapper_module\n-        self.prefix = wrapper_module + '.'\n-        self.prefix_cutoff = wrapper_module.count('.') + 1\n-\n-    def __eq__(self, other):\n-        return self.__class__.__module__ == other.__class__.__module__ and \\\n-               self.__class__.__name__ == other.__class__.__name__ and \\\n-               self.wrapper_module == other.wrapper_module and \\\n-               self.module_choices == other.module_choices\n-\n-    def __ne__(self, other):\n-        return not self.__eq__(other)\n-\n-    def install(self):\n-        sys.meta_path[:] = [x for x in sys.meta_path if self != x] + [self]\n-\n-    def find_module(self, fullname, path=None):\n-        if fullname.startswith(self.prefix):\n-            return self\n-\n-    def load_module(self, fullname):\n-        if fullname in sys.modules:\n-            return sys.modules[fullname]\n-        modname = fullname.split('.', self.prefix_cutoff)[self.prefix_cutoff]\n-        for path in self.module_choices:\n-            realname = path % modname\n-            try:\n-                __import__(realname)\n-            except ImportError:\n-                exc_type, exc_value, tb = sys.exc_info()\n-                # since we only establish the entry in sys.modules at the\n-                # end this seems to be redundant, but if recursive imports\n-                # happen we will call into the move import a second time.\n-                # On the second invocation we still don't have an entry for\n-                # fullname in sys.modules, but we will end up with the same\n-                # fake module name and that import will succeed since this\n-                # one already has a temporary entry in the modules dict.\n-                # Since this one \"succeeded\" temporarily that second\n-                # invocation now will have created a fullname entry in\n-                # sys.modules which we have to kill.\n-                sys.modules.pop(fullname, None)\n-\n-                # If it's an important traceback we reraise it, otherwise\n-                # we swallow it and try the next choice.  The skipped frame\n-                # is the one from __import__ above which we don't care about.\n-                if self.is_important_traceback(realname, tb):\n-                    raise exc_type, exc_value, tb.tb_next\n-                continue\n-            module = sys.modules[fullname] = sys.modules[realname]\n-            if '.' not in modname:\n-                setattr(sys.modules[self.wrapper_module], modname, module)\n-            return module\n-        raise ImportError('No module named %s' % fullname)\n-\n-    def is_important_traceback(self, important_module, tb):\n-        \"\"\"Walks a traceback's frames and checks if any of the frames\n-        originated in the given important module.  If that is the case then we\n-        were able to import the module itself but apparently something went\n-        wrong when the module was imported.  (Eg: import of an import failed).\n-        \"\"\"\n-        while tb is not None:\n-            if self.is_important_frame(important_module, tb):\n-                return True\n-            tb = tb.tb_next\n-        return False\n-\n-    def is_important_frame(self, important_module, tb):\n-        \"\"\"Checks a single frame if it's important.\"\"\"\n-        g = tb.tb_frame.f_globals\n-        if '__name__' not in g:\n-            return False\n-\n-        module_name = g['__name__']\n-\n-        # Python 2.7 Behavior.  Modules are cleaned up late so the\n-        # name shows up properly here.  Success!\n-        if module_name == important_module:\n-            return True\n-\n-        # Some python versions will clean up modules so early that the\n-        # module name at that point is no longer set.  Try guessing from\n-        # the filename then.\n-        filename = os.path.abspath(tb.tb_frame.f_code.co_filename)\n-        test_string = os.path.sep + important_module.replace('.', os.path.sep)\n-        return test_string + '.py' in filename or \\\n-               test_string + os.path.sep + '__init__.py' in filename\n-\n-\n-def activate():\n-    import flask\n-    ext_module = types.ModuleType('flask.ext')\n-    ext_module.__path__ = []\n-    flask.ext = sys.modules['flask.ext'] = ext_module\n-    importer = ExtensionImporter(['flask_%s', 'flaskext.%s'], 'flask.ext')\n-    importer.install()\n\n@@ -64,7 +64,7 @@ setup(\n     description='A microframework based on Werkzeug, Jinja2 '\n                 'and good intentions',\n     long_description=__doc__,\n-    packages=['flask', 'flask.ext', 'flask.json'],\n+    packages=['flask', 'flask.json'],\n     include_package_data=True,\n     zip_safe=False,\n     platforms='any',\n\n@@ -1,197 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\"\"\"\n-    tests.ext\n-    ~~~~~~~~~~~~~~~~~~~\n-\n-    Tests the extension import thing.\n-\n-    :copyright: (c) 2015 by Armin Ronacher.\n-    :license: BSD, see LICENSE for more details.\n-\"\"\"\n-\n-import sys\n-import pytest\n-\n-try:\n-    from imp import reload as reload_module\n-except ImportError:\n-    reload_module = reload\n-\n-from flask._compat import PY2\n-\n-\n-@pytest.fixture(autouse=True)\n-def disable_extwarnings(recwarn):\n-    from flask.exthook import ExtDeprecationWarning\n-\n-    yield\n-\n-    assert set(w.category for w in recwarn.list) \\\n-        <= set([ExtDeprecationWarning])\n-    recwarn.clear()\n-\n-\n-@pytest.fixture(autouse=True)\n-def importhook_setup(monkeypatch):\n-    # we clear this out for various reasons.  The most important one is\n-    # that a real flaskext could be in there which would disable our\n-    # fake package.  Secondly we want to make sure that the flaskext\n-    # import hook does not break on reloading.\n-    for entry, value in list(sys.modules.items()):\n-        if (\n-            entry.startswith('flask.ext.') or\n-            entry.startswith('flask_') or\n-            entry.startswith('flaskext.') or\n-            entry == 'flaskext'\n-        ) and value is not None:\n-            monkeypatch.delitem(sys.modules, entry)\n-    from flask import ext\n-    reload_module(ext)\n-\n-    # reloading must not add more hooks\n-    import_hooks = 0\n-    for item in sys.meta_path:\n-        cls = type(item)\n-        if cls.__module__ == 'flask.exthook' and \\\n-           cls.__name__ == 'ExtensionImporter':\n-            import_hooks += 1\n-    assert import_hooks == 1\n-\n-    yield\n-\n-    from flask import ext\n-    for key in ext.__dict__:\n-        assert '.' not in key\n-\n-\n-@pytest.fixture\n-def newext_simple(modules_tmpdir):\n-    x = modules_tmpdir.join('flask_newext_simple.py')\n-    x.write('ext_id = \"newext_simple\"')\n-\n-\n-@pytest.fixture\n-def oldext_simple(modules_tmpdir):\n-    flaskext = modules_tmpdir.mkdir('flaskext')\n-    flaskext.join('__init__.py').write('\\n')\n-    flaskext.join('oldext_simple.py').write('ext_id = \"oldext_simple\"')\n-\n-\n-@pytest.fixture\n-def newext_package(modules_tmpdir):\n-    pkg = modules_tmpdir.mkdir('flask_newext_package')\n-    pkg.join('__init__.py').write('ext_id = \"newext_package\"')\n-    pkg.join('submodule.py').write('def test_function():\\n    return 42\\n')\n-\n-\n-@pytest.fixture\n-def oldext_package(modules_tmpdir):\n-    flaskext = modules_tmpdir.mkdir('flaskext')\n-    flaskext.join('__init__.py').write('\\n')\n-    oldext = flaskext.mkdir('oldext_package')\n-    oldext.join('__init__.py').write('ext_id = \"oldext_package\"')\n-    oldext.join('submodule.py').write('def test_function():\\n'\n-                                      '    return 42')\n-\n-\n-@pytest.fixture\n-def flaskext_broken(modules_tmpdir):\n-    ext = modules_tmpdir.mkdir('flask_broken')\n-    ext.join('b.py').write('\\n')\n-    ext.join('__init__.py').write('import flask.ext.broken.b\\n'\n-                                  'import missing_module')\n-\n-\n-def test_flaskext_new_simple_import_normal(newext_simple):\n-    from flask.ext.newext_simple import ext_id\n-    assert ext_id == 'newext_simple'\n-\n-\n-def test_flaskext_new_simple_import_module(newext_simple):\n-    from flask.ext import newext_simple\n-    assert newext_simple.ext_id == 'newext_simple'\n-    assert newext_simple.__name__ == 'flask_newext_simple'\n-\n-\n-def test_flaskext_new_package_import_normal(newext_package):\n-    from flask.ext.newext_package import ext_id\n-    assert ext_id == 'newext_package'\n-\n-\n-def test_flaskext_new_package_import_module(newext_package):\n-    from flask.ext import newext_package\n-    assert newext_package.ext_id == 'newext_package'\n-    assert newext_package.__name__ == 'flask_newext_package'\n-\n-\n-def test_flaskext_new_package_import_submodule_function(newext_package):\n-    from flask.ext.newext_package.submodule import test_function\n-    assert test_function() == 42\n-\n-\n-def test_flaskext_new_package_import_submodule(newext_package):\n-    from flask.ext.newext_package import submodule\n-    assert submodule.__name__ == 'flask_newext_package.submodule'\n-    assert submodule.test_function() == 42\n-\n-\n-def test_flaskext_old_simple_import_normal(oldext_simple):\n-    from flask.ext.oldext_simple import ext_id\n-    assert ext_id == 'oldext_simple'\n-\n-\n-def test_flaskext_old_simple_import_module(oldext_simple):\n-    from flask.ext import oldext_simple\n-    assert oldext_simple.ext_id == 'oldext_simple'\n-    assert oldext_simple.__name__ == 'flaskext.oldext_simple'\n-\n-\n-def test_flaskext_old_package_import_normal(oldext_package):\n-    from flask.ext.oldext_package import ext_id\n-    assert ext_id == 'oldext_package'\n-\n-\n-def test_flaskext_old_package_import_module(oldext_package):\n-    from flask.ext import oldext_package\n-    assert oldext_package.ext_id == 'oldext_package'\n-    assert oldext_package.__name__ == 'flaskext.oldext_package'\n-\n-\n-def test_flaskext_old_package_import_submodule(oldext_package):\n-    from flask.ext.oldext_package import submodule\n-    assert submodule.__name__ == 'flaskext.oldext_package.submodule'\n-    assert submodule.test_function() == 42\n-\n-\n-def test_flaskext_old_package_import_submodule_function(oldext_package):\n-    from flask.ext.oldext_package.submodule import test_function\n-    assert test_function() == 42\n-\n-\n-def test_flaskext_broken_package_no_module_caching(flaskext_broken):\n-    for x in range(2):\n-        with pytest.raises(ImportError):\n-            import flask.ext.broken\n-\n-\n-def test_no_error_swallowing(flaskext_broken):\n-    with pytest.raises(ImportError) as excinfo:\n-        import flask.ext.broken\n-    # python3.6 raises a subclass of ImportError: 'ModuleNotFoundError'\n-    assert issubclass(excinfo.type, ImportError)\n-    if PY2:\n-        message = 'No module named missing_module'\n-    else:\n-        message = 'No module named \\'missing_module\\''\n-    assert str(excinfo.value) == message\n-    assert excinfo.tb.tb_frame.f_globals is globals()\n-\n-    # reraise() adds a second frame so we need to skip that one too.\n-    # On PY3 we even have another one :(\n-    next = excinfo.tb.tb_next.tb_next\n-    if not PY2:\n-        next = next.tb_next\n-\n-    import os.path\n-    assert os.path.join('flask_broken', '__init__.py') in \\\n-        next.tb_frame.f_code.co_filename\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#e0cd80c6bff0d5ca3720f2f8dcac21274827caa5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 298 | Files Changed: 1 | Hunks: 1 | Methods Changed: 19 | Complexity Δ (Sum/Max): -81/0 | Churn Δ: 298 | Churn Cumulative: 858 | Contributors (this commit): 7 | Commits (past 90d): 1 | Contributors (cumulative): 7 | DMM Complexity: 0.3217821782178218\n\nDIFF:\n@@ -1,298 +0,0 @@\n-#!/usr/bin/env python\n-# -*- coding: utf-8 -*-\n-\"\"\"\n-    flask-07-upgrade\n-    ~~~~~~~~~~~~~~~~\n-\n-    This command line script scans a whole application tree and attempts to\n-    output a unified diff with all the changes that are necessary to easily\n-    upgrade the application to 0.7 and to not yield deprecation warnings.\n-\n-    This will also attempt to find `after_request` functions that don't modify\n-    the response and appear to be better suited for `teardown_request`.\n-\n-    This application is indeed an incredible hack, but because what it\n-    attempts to accomplish is impossible to do statically it tries to support\n-    the most common patterns at least.  The diff it generates should be\n-    hand reviewed and not applied blindly without making backups.\n-\n-    :copyright: (c) Copyright 2015 by Armin Ronacher.\n-    :license: see LICENSE for more details.\n-\"\"\"\n-from __future__ import print_function\n-import re\n-import os\n-import inspect\n-import difflib\n-import posixpath\n-from optparse import OptionParser\n-\n-try:\n-    import ast\n-except ImportError:\n-    ast = None\n-\n-\n-TEMPLATE_LOOKAHEAD = 4096\n-\n-_app_re_part = r'((?:[a-zA-Z_][a-zA-Z0-9_]*app)|app|application)'\n-_string_re_part = r\"('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\" \\\n-                  r'|\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")'\n-\n-_from_import_re = re.compile(r'^\\s*from flask import\\s+')\n-_url_for_re = re.compile(r'\\b(url_for\\()(%s)' % _string_re_part)\n-_render_template_re = re.compile(r'\\b(render_template\\()(%s)' % _string_re_part)\n-_after_request_re = re.compile(r'((?:@\\S+\\.(?:app_)?))(after_request)(\\b\\s*$)(?m)')\n-_module_constructor_re = re.compile(r'([a-zA-Z0-9_][a-zA-Z0-9_]*)\\s*=\\s*Module'\n-                                    r'\\(__name__\\s*(?:,\\s*(?:name\\s*=\\s*)?(%s))?' %\n-                                    _string_re_part)\n-_error_handler_re = re.compile(r'%s\\.error_handlers\\[\\s*(\\d+)\\s*\\]' % _app_re_part)\n-_mod_route_re = re.compile(r'@([a-zA-Z0-9_][a-zA-Z0-9_]*)\\.route')\n-_blueprint_related = [\n-    (re.compile(r'request\\.module'), 'request.blueprint'),\n-    (re.compile(r'register_module'), 'register_blueprint'),\n-    (re.compile(r'%s\\.modules' % _app_re_part), '\\\\1.blueprints')\n-]\n-\n-\n-def make_diff(filename, old, new):\n-    for line in difflib.unified_diff(old.splitlines(), new.splitlines(),\n-                     posixpath.normpath(posixpath.join('a', filename)),\n-                     posixpath.normpath(posixpath.join('b', filename)),\n-                     lineterm=''):\n-        print(line)\n-\n-\n-def looks_like_teardown_function(node):\n-    returns = [x for x in ast.walk(node) if isinstance(x, ast.Return)]\n-    if len(returns) != 1:\n-        return\n-    return_def = returns[0]\n-    resp_name = node.args.args[0]\n-    if not isinstance(return_def.value, ast.Name) or \\\n-       return_def.value.id != resp_name.id:\n-        return\n-\n-    for body_node in node.body:\n-        for child in ast.walk(body_node):\n-            if isinstance(child, ast.Name) and \\\n-               child.id == resp_name.id:\n-                if child is not return_def.value:\n-                    return\n-\n-    return resp_name.id\n-\n-\n-def fix_url_for(contents, module_declarations=None):\n-    if module_declarations is None:\n-        skip_module_test = True\n-    else:\n-        skip_module_test = False\n-        mapping = dict(module_declarations)\n-    annotated_lines = []\n-\n-    def make_line_annotations():\n-        if not annotated_lines:\n-            last_index = 0\n-            for line in contents.splitlines(True):\n-                last_index += len(line)\n-                annotated_lines.append((last_index, line))\n-\n-    def backtrack_module_name(call_start):\n-        make_line_annotations()\n-        for idx, (line_end, line) in enumerate(annotated_lines):\n-            if line_end > call_start:\n-                for _, line in reversed(annotated_lines[:idx]):\n-                    match = _mod_route_re.search(line)\n-                    if match is not None:\n-                        shortname = match.group(1)\n-                        return mapping.get(shortname)\n-\n-    def handle_match(match):\n-        if not skip_module_test:\n-            modname = backtrack_module_name(match.start())\n-            if modname is None:\n-                return match.group(0)\n-        prefix = match.group(1)\n-        endpoint = ast.literal_eval(match.group(2))\n-        if endpoint.startswith('.'):\n-            endpoint = endpoint[1:]\n-        elif '.' not in endpoint:\n-            endpoint = '.' + endpoint\n-        else:\n-            return match.group(0)\n-        return prefix + repr(endpoint)\n-    return _url_for_re.sub(handle_match, contents)\n-\n-\n-def fix_teardown_funcs(contents):\n-\n-    def is_return_line(line):\n-        args = line.strip().split()\n-        return args and args[0] == 'return'\n-\n-    def fix_single(match, lines, lineno):\n-        if not lines[lineno + 1].startswith('def'):\n-            return\n-        block_lines = inspect.getblock(lines[lineno + 1:])\n-        func_code = ''.join(block_lines)\n-        if func_code[0].isspace():\n-            node = ast.parse('if 1:\\n' + func_code).body[0].body\n-        else:\n-            node = ast.parse(func_code).body[0]\n-        response_param_name = looks_like_teardown_function(node)\n-        if response_param_name is None:\n-            return\n-        before = lines[:lineno]\n-        decorator = [match.group(1) +\n-                     match.group(2).replace('after_', 'teardown_') +\n-                     match.group(3)]\n-        body = [line.replace(response_param_name, 'exception')\n-                for line in block_lines if\n-                not is_return_line(line)]\n-        after = lines[lineno + len(block_lines) + 1:]\n-        return before + decorator + body + after\n-\n-    content_lines = contents.splitlines(True)\n-    while 1:\n-        found_one = False\n-        for idx, line in enumerate(content_lines):\n-            match = _after_request_re.match(line)\n-            if match is None:\n-                continue\n-            new_content_lines = fix_single(match, content_lines, idx)\n-            if new_content_lines is not None:\n-                content_lines = new_content_lines\n-                break\n-        else:\n-            break\n-\n-    return ''.join(content_lines)\n-\n-\n-def get_module_autoname(filename):\n-    directory, filename = os.path.split(filename)\n-    if filename != '__init__.py':\n-        return os.path.splitext(filename)[0]\n-    return os.path.basename(directory)\n-\n-\n-def rewrite_from_imports(prefix, fromlist, lineiter):\n-    import_block = [prefix, fromlist]\n-    if fromlist[0] == '(' and fromlist[-1] != ')':\n-        for line in lineiter:\n-            import_block.append(line)\n-            if line.rstrip().endswith(')'):\n-                break\n-    elif fromlist[-1] == '\\\\':\n-        for line in lineiter:\n-            import_block.append(line)\n-            if line.rstrip().endswith('\\\\'):\n-                break\n-\n-    return ''.join(import_block).replace('Module', 'Blueprint')\n-\n-\n-def rewrite_blueprint_imports(contents):\n-    new_file = []\n-    lineiter = iter(contents.splitlines(True))\n-    for line in lineiter:\n-        match = _from_import_re.search(line)\n-        if match is not None:\n-            new_file.extend(rewrite_from_imports(match.group(),\n-                                                 line[match.end():],\n-                                                 lineiter))\n-        else:\n-            new_file.append(line)\n-    return ''.join(new_file)\n-\n-\n-def rewrite_for_blueprints(contents, filename):\n-    modules_declared = []\n-    def handle_match(match):\n-        target = match.group(1)\n-        name_param = match.group(2)\n-        if name_param is None:\n-            modname = get_module_autoname(filename)\n-        else:\n-            modname = ast.literal_eval(name_param)\n-        modules_declared.append((target, modname))\n-        return '%s = %s' % (target, 'Blueprint(%r, __name__' % modname)\n-    new_contents = _module_constructor_re.sub(handle_match, contents)\n-\n-    if modules_declared:\n-        new_contents = rewrite_blueprint_imports(new_contents)\n-\n-    for pattern, replacement in _blueprint_related:\n-        new_contents = pattern.sub(replacement, new_contents)\n-    return new_contents, dict(modules_declared)\n-\n-\n-def upgrade_python_file(filename, contents, teardown):\n-    new_contents = contents\n-    if teardown:\n-        new_contents = fix_teardown_funcs(new_contents)\n-    new_contents, modules = rewrite_for_blueprints(new_contents, filename)\n-    new_contents = fix_url_for(new_contents, modules)\n-    new_contents = _error_handler_re.sub('\\\\1.error_handler_spec[None][\\\\2]',\n-                                         new_contents)\n-    make_diff(filename, contents, new_contents)\n-\n-\n-def upgrade_template_file(filename, contents):\n-    new_contents = fix_url_for(contents, None)\n-    make_diff(filename, contents, new_contents)\n-\n-\n-def walk_path(path):\n-    this_file = os.path.realpath(__file__).rstrip('c')\n-    for dirpath, dirnames, filenames in os.walk(path):\n-        dirnames[:] = [x for x in dirnames if not x.startswith('.')]\n-        for filename in filenames:\n-            filename = os.path.join(dirpath, filename)\n-            if os.path.realpath(filename) == this_file:\n-                continue\n-            if filename.endswith('.py'):\n-                yield filename, 'python'\n-            # skip files that are diffs.  These might be false positives\n-            # when run multiple times.\n-            elif not filename.endswith(('.diff', '.patch', '.udiff')):\n-                with open(filename) as f:\n-                    contents = f.read(TEMPLATE_LOOKAHEAD)\n-                if '{% for' or '{% if' or '{{ url_for' in contents:\n-                    yield filename, 'template'\n-\n-\n-def scan_path(path=None, teardown=True):\n-    for filename, type in walk_path(path):\n-        with open(filename) as f:\n-            contents = f.read()\n-        if type == 'python':\n-            upgrade_python_file(filename, contents, teardown)\n-        elif type == 'template':\n-            upgrade_template_file(filename, contents)\n-\n-\n-def main():\n-    \"\"\"Entrypoint\"\"\"\n-    parser = OptionParser(usage='%prog [options] [paths]')\n-    parser.add_option('-T', '--no-teardown-detection', dest='no_teardown',\n-                      action='store_true', help='Do not attempt to '\n-                      'detect teardown function rewrites.')\n-    parser.add_option('-b', '--bundled-templates', dest='bundled_tmpl',\n-                      action='store_true', help='Indicate to the system '\n-                      'that templates are bundled with modules.  Default '\n-                      'is auto detect.')\n-    options, args = parser.parse_args()\n-    if not args:\n-        args = ['.']\n-\n-    if ast is None:\n-        parser.error('Python 2.6 or later is required to run the upgrade script.')\n-\n-    for path in args:\n-        scan_path(path, teardown=not options.no_teardown)\n-\n-\n-if __name__ == '__main__':\n-    main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#5bc0d15359b73afcb324eb696f9caeb362efa7cc", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 34 | Files Changed: 2 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 34 | Churn Cumulative: 1236 | Contributors (this commit): 25 | Commits (past 90d): 9 | Contributors (cumulative): 29 | DMM Complexity: 0.0\n\nDIFF:\n@@ -8,8 +8,6 @@\n     :copyright: (c) 2015 by Armin Ronacher.\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n-from warnings import warn\n-\n from werkzeug.exceptions import BadRequest\n from werkzeug.wrappers import Request as RequestBase, Response as ResponseBase\n \n@@ -44,13 +42,7 @@ class JSONMixin(object):\n         \"\"\"This will contain the parsed JSON data if the mimetype indicates\n         JSON (:mimetype:`application/json`, see :meth:`is_json`), otherwise it\n         will be ``None``.\n-\n-        .. deprecated:: 1.0\n-            Use :meth:`get_json` instead.\n         \"\"\"\n-        warn(DeprecationWarning(\n-            \"'json' is deprecated. Use 'get_json()' instead.\"\n-        ), stacklevel=2)\n         return self.get_json()\n \n     def _get_data_for_json(self, cache):\n\n@@ -1,26 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\"\"\"\n-    tests.deprecations\n-    ~~~~~~~~~~~~~~~~~~\n-\n-    Tests deprecation support. Not used currently.\n-\n-    :copyright: (c) 2015 by Armin Ronacher.\n-    :license: BSD, see LICENSE for more details.\n-\"\"\"\n-\n-import flask\n-\n-\n-class TestRequestDeprecation(object):\n-    def test_request_json(self, recwarn, app, client):\n-        \"\"\"Request.json is deprecated\"\"\"\n-\n-        @app.route('/', methods=['POST'])\n-        def index():\n-            assert flask.request.json == {'spam': 42}\n-            print(flask.request.json)\n-            return 'OK'\n-\n-        client.post('/', data='{\"spam\": 42}', content_type='application/json')\n-        recwarn.pop(DeprecationWarning)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#4f30cb7c57c4b5d74ba98953f59670a647623f7a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 7 | Churn Cumulative: 1926 | Contributors (this commit): 25 | Commits (past 90d): 18 | Contributors (cumulative): 25 | DMM Complexity: 0.0\n\nDIFF:\n@@ -203,9 +203,10 @@ def locate_app(script_info, app_id, raise_if_not_found=True):\n             )\n         elif raise_if_not_found:\n             raise NoAppException(\n-                'The file/path provided (%s) does not appear to exist. Please'\n-                ' verify the path is correct. If app is not on PYTHONPATH,'\n-                ' ensure the extension is .py.'.format(module=module)\n+                'The file/path provided ({module}) does not appear to exist.'\n+                ' Please verify the path is correct. If app is not on'\n+                ' PYTHONPATH, ensure the extension is .py.'.format(\n+                    module=module)\n             )\n         else:\n             return\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#465922e5f1cb76cf669a38afe25facde2176b9f0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 14 | Lines Deleted: 49 | Files Changed: 9 | Hunks: 31 | Methods Changed: 28 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 63 | Churn Cumulative: 9771 | Contributors (this commit): 107 | Commits (past 90d): 69 | Contributors (cumulative): 149 | DMM Complexity: 0.0\n\nDIFF:\n@@ -22,7 +22,7 @@ def create_app(config=None):\n     app.config.update(dict(\n         DATABASE=os.path.join(app.root_path, 'flaskr.db'),\n         DEBUG=True,\n-        SECRET_KEY='development key',\n+        SECRET_KEY=b'_5#y2L\"F4Q8z\\n\\xec]/',\n         USERNAME='admin',\n         PASSWORD='default'\n     ))\n\n@@ -22,7 +22,7 @@ from werkzeug import check_password_hash, generate_password_hash\n DATABASE = '/tmp/minitwit.db'\n PER_PAGE = 30\n DEBUG = True\n-SECRET_KEY = 'development key'\n+SECRET_KEY = b'_5#y2L\"F4Q8z\\n\\xec]/'\n \n # create our little application :)\n app = Flask('minitwit')\n\n@@ -225,7 +225,7 @@ class Flask(_PackageBoundObject):\n     #: when you want to use the secure cookie for instance.\n     #:\n     #: This attribute can also be configured from the config with the\n-    #: ``SECRET_KEY`` configuration key.  Defaults to ``None``.\n+    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.\n     secret_key = ConfigAttribute('SECRET_KEY')\n \n     #: The secure cookie uses this for the name of the session cookie.\n\n@@ -18,12 +18,7 @@ from flask import Flask as _Flask\n \n class Flask(_Flask):\n     testing = True\n-    secret_key = __name__\n-\n-    def make_response(self, rv):\n-        if rv is None:\n-            rv = ''\n-        return super(Flask, self).make_response(rv)\n+    secret_key = 'test key'\n \n \n @pytest.fixture\n\n@@ -220,8 +220,6 @@ def test_endpoint_decorator(app, client):\n \n \n def test_session(app, client):\n-    app.secret_key = 'testkey'\n-\n     @app.route('/set', methods=['POST'])\n     def set():\n         flask.session['value'] = flask.request.form['value']\n@@ -237,7 +235,6 @@ def test_session(app, client):\n \n def test_session_using_server_name(app, client):\n     app.config.update(\n-        SECRET_KEY='foo',\n         SERVER_NAME='example.com'\n     )\n \n@@ -253,7 +250,6 @@ def test_session_using_server_name(app, client):\n \n def test_session_using_server_name_and_port(app, client):\n     app.config.update(\n-        SECRET_KEY='foo',\n         SERVER_NAME='example.com:8080'\n     )\n \n@@ -269,7 +265,6 @@ def test_session_using_server_name_and_port(app, client):\n \n def test_session_using_server_name_port_and_path(app, client):\n     app.config.update(\n-        SECRET_KEY='foo',\n         SERVER_NAME='example.com:8080',\n         APPLICATION_ROOT='/foo'\n     )\n@@ -297,7 +292,6 @@ def test_session_using_application_root(app, client):\n \n     app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, '/bar')\n     app.config.update(\n-        SECRET_KEY='foo',\n         APPLICATION_ROOT='/bar'\n     )\n \n@@ -312,7 +306,6 @@ def test_session_using_application_root(app, client):\n \n def test_session_using_session_settings(app, client):\n     app.config.update(\n-        SECRET_KEY='foo',\n         SERVER_NAME='www.example.com:8080',\n         APPLICATION_ROOT='/test',\n         SESSION_COOKIE_DOMAIN='.example.com',\n@@ -336,7 +329,6 @@ def test_session_using_session_settings(app, client):\n \n def test_session_localhost_warning(recwarn, app, client):\n     app.config.update(\n-        SECRET_KEY='testing',\n         SERVER_NAME='localhost:5000',\n     )\n \n@@ -353,7 +345,6 @@ def test_session_localhost_warning(recwarn, app, client):\n \n def test_session_ip_warning(recwarn, app, client):\n     app.config.update(\n-        SECRET_KEY='testing',\n         SERVER_NAME='127.0.0.1:5000',\n     )\n \n@@ -368,8 +359,8 @@ def test_session_ip_warning(recwarn, app, client):\n     assert 'cookie domain is an IP' in str(w.message)\n \n \n-def test_missing_session():\n-    app = flask.Flask(__name__)\n+def test_missing_session(app):\n+    app.secret_key = None\n \n     def expect_exception(f, *args, **kwargs):\n         e = pytest.raises(RuntimeError, f, *args, **kwargs)\n@@ -383,7 +374,6 @@ def test_missing_session():\n \n def test_session_expiration(app, client):\n     permanent = True\n-    app.secret_key = 'testkey'\n \n     @app.route('/')\n     def index():\n@@ -415,8 +405,6 @@ def test_session_expiration(app, client):\n \n \n def test_session_stored_last(app, client):\n-    app.secret_key = 'development-key'\n-\n     @app.after_request\n     def modify_session(response):\n         flask.session['foo'] = 42\n@@ -431,7 +419,6 @@ def test_session_stored_last(app, client):\n \n \n def test_session_special_types(app, client):\n-    app.secret_key = 'development-key'\n     now = datetime.utcnow().replace(microsecond=0)\n     the_uuid = uuid.uuid4()\n \n@@ -463,7 +450,6 @@ def test_session_special_types(app, client):\n \n \n def test_session_cookie_setting(app):\n-    app.secret_key = 'dev key'\n     is_permanent = True\n \n     @app.route('/bump')\n@@ -505,8 +491,6 @@ def test_session_cookie_setting(app):\n \n \n def test_session_vary_cookie(app, client):\n-    app.secret_key = 'testkey'\n-\n     @app.route('/set')\n     def set_session():\n         flask.session['test'] = 'test'\n@@ -562,8 +546,6 @@ def test_session_vary_cookie(app, client):\n \n \n def test_flashes(app, req_ctx):\n-    app.secret_key = 'testkey'\n-\n     assert not flask.session.modified\n     flask.flash('Zap')\n     flask.session.modified = False\n@@ -579,8 +561,6 @@ def test_extended_flashing(app):\n     # in the view functions will cause a 500 response to the test client\n     # instead of propagating exceptions.\n \n-    app.secret_key = 'testkey'\n-\n     @app.route('/')\n     def index():\n         flask.flash(u'Hello World')\n\n@@ -19,11 +19,11 @@ import pytest\n \n # config keys used for the TestConfig\n TEST_KEY = 'foo'\n-SECRET_KEY = 'devkey'\n+SECRET_KEY = 'config'\n \n \n def common_object_test(app):\n-    assert app.secret_key == 'devkey'\n+    assert app.secret_key == 'config'\n     assert app.config['TEST_KEY'] == 'foo'\n     assert 'TestConfig' not in app.config\n \n@@ -50,21 +50,21 @@ def test_config_from_json():\n def test_config_from_mapping():\n     app = flask.Flask(__name__)\n     app.config.from_mapping({\n-        'SECRET_KEY': 'devkey',\n+        'SECRET_KEY': 'config',\n         'TEST_KEY': 'foo'\n     })\n     common_object_test(app)\n \n     app = flask.Flask(__name__)\n     app.config.from_mapping([\n-        ('SECRET_KEY', 'devkey'),\n+        ('SECRET_KEY', 'config'),\n         ('TEST_KEY', 'foo')\n     ])\n     common_object_test(app)\n \n     app = flask.Flask(__name__)\n     app.config.from_mapping(\n-        SECRET_KEY='devkey',\n+        SECRET_KEY='config',\n         TEST_KEY='foo'\n     )\n     common_object_test(app)\n@@ -81,7 +81,8 @@ def test_config_from_class():\n         TEST_KEY = 'foo'\n \n     class Test(Base):\n-        SECRET_KEY = 'devkey'\n+        SECRET_KEY = 'config'\n+\n     app = flask.Flask(__name__)\n     app.config.from_object(Test)\n     common_object_test(app)\n\n@@ -157,10 +157,7 @@ def test_appcontext_signals():\n         flask.appcontext_popped.disconnect(record_pop, app)\n \n \n-def test_flash_signal():\n-    app = flask.Flask(__name__)\n-    app.config['SECRET_KEY'] = 'secret'\n-\n+def test_flash_signal(app):\n     @app.route('/')\n     def index():\n         flask.flash('This is a flash message', category='notice')\n\n@@ -52,8 +52,6 @@ def test_request_less_rendering(app, app_ctx):\n \n \n def test_standard_context(app, client):\n-    app.secret_key = 'development key'\n-\n     @app.route('/')\n     def index():\n         flask.g.foo = 23\n\n@@ -107,8 +107,6 @@ def test_blueprint_with_subdomain(app, client):\n \n \n def test_redirect_keep_session(app, client, app_ctx):\n-    app.secret_key = 'testing'\n-\n     @app.route('/', methods=['GET', 'POST'])\n     def index():\n         if flask.request.method == 'POST':\n@@ -139,8 +137,6 @@ def test_redirect_keep_session(app, client, app_ctx):\n \n \n def test_session_transactions(app, client):\n-    app.secret_key = 'testing'\n-\n     @app.route('/')\n     def index():\n         return text_type(flask.session['foo'])\n@@ -169,8 +165,6 @@ def test_session_transactions_no_null_sessions():\n \n \n def test_session_transactions_keep_context(app, client, req_ctx):\n-    app.secret_key = 'testing'\n-\n     rv = client.get('/')\n     req = flask.request._get_current_object()\n     assert req is not None\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
