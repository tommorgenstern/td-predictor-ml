{"custom_id": "flask#bfd67764fb48311e6a7ddcc85244726d70af677b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 50 | Lines Deleted: 30 | Files Changed: 2 | Hunks: 24 | Methods Changed: 26 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 80 | Churn Cumulative: 383 | Contributors (this commit): 1 | Commits (past 90d): 9 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -52,6 +52,9 @@ class Blueprint(_PackageBoundObject):\n     .. versionadded:: 0.7\n     \"\"\"\n \n+    warn_on_modifications = False\n+    _got_registered_once = False\n+\n     def __init__(self, name, import_name, static_folder=None,\n                  static_url_path=None, url_prefix=None,\n                  subdomain=None):\n@@ -64,14 +67,29 @@ class Blueprint(_PackageBoundObject):\n         self.deferred_functions = []\n         self.view_functions = {}\n \n-    def _record(self, func):\n+    def record(self, func):\n+        \"\"\"Registers a function that is called when the blueprint is\n+        registered on the application.  This function is called with the\n+        state as argument as returned by the :meth:`make_setup_state`\n+        method.\n+        \"\"\"\n+        if self._got_registered_once and self.warn_on_modifications:\n+            from warnings import warn\n+            warn(Warning('The blueprint was already registered once '\n+                         'but is getting modified now.  These changes '\n+                         'will not show up.'))\n         self.deferred_functions.append(func)\n \n-    def _record_once(self, func):\n+    def record_once(self, func):\n+        \"\"\"Works like :meth:`record` but wraps the function in another\n+        function that will ensure the function is only called once.  If the\n+        blueprint is registered a second time on the application, the\n+        function passed is not called.\n+        \"\"\"\n         def wrapper(state):\n             if state.first_registration:\n                 func(state)\n-        return self._record(update_wrapper(wrapper, func))\n+        return self.record(update_wrapper(wrapper, func))\n \n     def make_setup_state(self, app, options, first_registration=False):\n         return BlueprintSetupState(self, app, options, first_registration)\n@@ -83,6 +101,7 @@ class Blueprint(_PackageBoundObject):\n         :func:`~flask.Flask.register_blueprint` are directly forwarded to this\n         method in the `options` dictionary.\n         \"\"\"\n+        self._got_registered_once = True\n         state = self.make_setup_state(app, options, first_registration)\n         if self.has_static_folder:\n             state.add_url_rule(self.static_url_path + '/<path:filename>',\n@@ -105,7 +124,7 @@ class Blueprint(_PackageBoundObject):\n         \"\"\"Like :meth:`Flask.add_url_rule` but for a module.  The endpoint for\n         the :func:`url_for` function is prefixed with the name of the module.\n         \"\"\"\n-        self._record(lambda s:\n+        self.record(lambda s:\n             s.add_url_rule(rule, endpoint, view_func, **options))\n \n     def endpoint(self, endpoint):\n@@ -118,7 +137,7 @@ class Blueprint(_PackageBoundObject):\n         def decorator(f):\n             def register_endpoint(state):\n                 state.app.view_functions[endpoint] = f\n-            self._record_once(register_endpoint)\n+            self.record_once(register_endpoint)\n             return f\n         return decorator\n \n@@ -127,7 +146,7 @@ class Blueprint(_PackageBoundObject):\n         is only executed before each request that is handled by a function of\n         that module.\n         \"\"\"\n-        self._record_once(lambda s: s.app.before_request_funcs\n+        self.record_once(lambda s: s.app.before_request_funcs\n             .setdefault(self.name, []).append(f))\n         return f\n \n@@ -135,7 +154,7 @@ class Blueprint(_PackageBoundObject):\n         \"\"\"Like :meth:`Flask.before_request`.  Such a function is executed\n         before each request, even if outside of a module.\n         \"\"\"\n-        self._record_once(lambda s: s.app.before_request_funcs\n+        self.record_once(lambda s: s.app.before_request_funcs\n             .setdefault(None, []).append(f))\n         return f\n \n@@ -144,7 +163,7 @@ class Blueprint(_PackageBoundObject):\n         is only executed after each request that is handled by a function of\n         that module.\n         \"\"\"\n-        self._record_once(lambda s: s.app.after_request_funcs\n+        self.record_once(lambda s: s.app.after_request_funcs\n             .setdefault(self.name, []).append(f))\n         return f\n \n@@ -152,7 +171,7 @@ class Blueprint(_PackageBoundObject):\n         \"\"\"Like :meth:`Flask.after_request` but for a module.  Such a function\n         is executed after each request, even if outside of the module.\n         \"\"\"\n-        self._record_once(lambda s: s.app.after_request_funcs\n+        self.record_once(lambda s: s.app.after_request_funcs\n             .setdefault(None, []).append(f))\n         return f\n \n@@ -160,7 +179,7 @@ class Blueprint(_PackageBoundObject):\n         \"\"\"Like :meth:`Flask.context_processor` but for a module.  This\n         function is only executed for requests handled by a module.\n         \"\"\"\n-        self._record_once(lambda s: s.app.template_context_processors\n+        self.record_once(lambda s: s.app.template_context_processors\n             .setdefault(self.name, []).append(f))\n         return f\n \n@@ -168,7 +187,7 @@ class Blueprint(_PackageBoundObject):\n         \"\"\"Like :meth:`Flask.context_processor` but for a module.  Such a\n         function is executed each request, even if outside of the module.\n         \"\"\"\n-        self._record_once(lambda s: s.app.template_context_processors\n+        self.record_once(lambda s: s.app.template_context_processors\n             .setdefault(None, []).append(f))\n         return f\n \n@@ -177,7 +196,7 @@ class Blueprint(_PackageBoundObject):\n         handler is used for all requests, even if outside of the module.\n         \"\"\"\n         def decorator(f):\n-            self._record_once(lambda s: s.app.errorhandler(code)(f))\n+            self.record_once(lambda s: s.app.errorhandler(code)(f))\n             return f\n         return decorator\n \n@@ -186,7 +205,7 @@ class Blueprint(_PackageBoundObject):\n         blueprint.  It's called before the view functions are called and\n         can modify the url values provided.\n         \"\"\"\n-        self._record_once(lambda s: s.app.url_value_preprocessors\n+        self.record_once(lambda s: s.app.url_value_preprocessors\n             .setdefault(self.name, []).append(f))\n         return f\n \n@@ -195,21 +214,21 @@ class Blueprint(_PackageBoundObject):\n         with the endpoint and values and should update the values passed\n         in place.\n         \"\"\"\n-        self._record_once(lambda s: s.app.url_default_functions\n+        self.record_once(lambda s: s.app.url_default_functions\n             .setdefault(self.name, []).append(f))\n         return f\n \n     def app_url_value_preprocessor(self, f):\n         \"\"\"Same as :meth:`url_value_preprocessor` but application wide.\n         \"\"\"\n-        self._record_once(lambda s: s.app.url_value_preprocessor\n+        self.record_once(lambda s: s.app.url_value_preprocessor\n             .setdefault(self.name, []).append(f))\n         return f\n \n     def app_url_defaults(self, f):\n         \"\"\"Same as :meth:`url_defaults` but application wide.\n         \"\"\"\n-        self._record_once(lambda s: s.app.url_default_functions\n+        self.record_once(lambda s: s.app.url_default_functions\n             .setdefault(None, []).append(f))\n         return f\n \n@@ -227,7 +246,7 @@ class Blueprint(_PackageBoundObject):\n         .. versionadded:: 0.7\n         \"\"\"\n         def decorator(f):\n-            self._record_once(lambda s: s.app._register_error_handler(\n+            self.record_once(lambda s: s.app._register_error_handler(\n                 self.name, code_or_exception, f))\n             return f\n         return decorator\n\n@@ -1,19 +1,10 @@\n-from flask import Flask, Module\n+from flask import Flask, Module, render_template\n \n \n mod = Module(__name__)\n mod2 = Module(__name__, 'testmod2')\n mod3 = Module(__name__, name='somemod', subdomain='meh')\n \n-app = Flask(__name__)\n-app.register_module(mod)\n-app.register_module(mod2)\n-\n-\n-def handle_404(error):\n-    return 'Testing', 404\n-app.error_handlers[404] = handle_404\n-\n \n @app.after_request\n def after_request(response):\n@@ -27,10 +18,20 @@ def index():\n \n \n @mod2.route('/')\n-def index():\n+def mod2_index():\n     return render_template('testmod2/index.html')\n \n \n-@mod2.route('/')\n-def index():\n+@mod3.route('/')\n+def mod3_index():\n     return render_template('something-else/index.html')\n+\n+\n+app = Flask(__name__)\n+app.register_module(mod)\n+app.register_module(mod2)\n+\n+\n+def handle_404(error):\n+    return 'Testing', 404\n+app.error_handlers[404] = handle_404\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#3d6e3e48ad2445c80761c930ddfbe0ce24be3eb3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 20 | Lines Deleted: 20 | Files Changed: 1 | Hunks: 13 | Methods Changed: 11 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 40 | Churn Cumulative: 360 | Contributors (this commit): 2 | Commits (past 90d): 6 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -112,8 +112,8 @@ class Blueprint(_PackageBoundObject):\n             deferred(state)\n \n     def route(self, rule, **options):\n-        \"\"\"Like :meth:`Flask.route` but for a module.  The endpoint for the\n-        :func:`url_for` function is prefixed with the name of the module.\n+        \"\"\"Like :meth:`Flask.route` but for a blueprint.  The endpoint for the\n+        :func:`url_for` function is prefixed with the name of the blueprint.\n         \"\"\"\n         def decorator(f):\n             self.add_url_rule(rule, f.__name__, f, **options)\n@@ -121,15 +121,15 @@ class Blueprint(_PackageBoundObject):\n         return decorator\n \n     def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n-        \"\"\"Like :meth:`Flask.add_url_rule` but for a module.  The endpoint for\n-        the :func:`url_for` function is prefixed with the name of the module.\n+        \"\"\"Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for\n+        the :func:`url_for` function is prefixed with the name of the blueprint.\n         \"\"\"\n         self.record(lambda s:\n             s.add_url_rule(rule, endpoint, view_func, **options))\n \n     def endpoint(self, endpoint):\n-        \"\"\"Like :meth:`Flask.endpoint` but for a module.  This does not\n-        prefix the endpoint with the module name, this has to be done\n+        \"\"\"Like :meth:`Flask.endpoint` but for a blueprint.  This does not\n+        prefix the endpoint with the blueprint name, this has to be done\n         explicitly by the user of this method.  If the endpoint is prefixed\n         with a `.` it will be registered to the current blueprint, otherwise\n         it's an application independent endpoint.\n@@ -142,9 +142,9 @@ class Blueprint(_PackageBoundObject):\n         return decorator\n \n     def before_request(self, f):\n-        \"\"\"Like :meth:`Flask.before_request` but for a module.  This function\n+        \"\"\"Like :meth:`Flask.before_request` but for a blueprint.  This function\n         is only executed before each request that is handled by a function of\n-        that module.\n+        that blueprint.\n         \"\"\"\n         self.record_once(lambda s: s.app.before_request_funcs\n             .setdefault(self.name, []).append(f))\n@@ -152,48 +152,48 @@ class Blueprint(_PackageBoundObject):\n \n     def before_app_request(self, f):\n         \"\"\"Like :meth:`Flask.before_request`.  Such a function is executed\n-        before each request, even if outside of a module.\n+        before each request, even if outside of a blueprint.\n         \"\"\"\n         self.record_once(lambda s: s.app.before_request_funcs\n             .setdefault(None, []).append(f))\n         return f\n \n     def after_request(self, f):\n-        \"\"\"Like :meth:`Flask.after_request` but for a module.  This function\n+        \"\"\"Like :meth:`Flask.after_request` but for a blueprint.  This function\n         is only executed after each request that is handled by a function of\n-        that module.\n+        that blueprint.\n         \"\"\"\n         self.record_once(lambda s: s.app.after_request_funcs\n             .setdefault(self.name, []).append(f))\n         return f\n \n     def after_app_request(self, f):\n-        \"\"\"Like :meth:`Flask.after_request` but for a module.  Such a function\n-        is executed after each request, even if outside of the module.\n+        \"\"\"Like :meth:`Flask.after_request` but for a blueprint.  Such a function\n+        is executed after each request, even if outside of the blueprint.\n         \"\"\"\n         self.record_once(lambda s: s.app.after_request_funcs\n             .setdefault(None, []).append(f))\n         return f\n \n     def context_processor(self, f):\n-        \"\"\"Like :meth:`Flask.context_processor` but for a module.  This\n-        function is only executed for requests handled by a module.\n+        \"\"\"Like :meth:`Flask.context_processor` but for a blueprint.  This\n+        function is only executed for requests handled by a blueprint.\n         \"\"\"\n         self.record_once(lambda s: s.app.template_context_processors\n             .setdefault(self.name, []).append(f))\n         return f\n \n     def app_context_processor(self, f):\n-        \"\"\"Like :meth:`Flask.context_processor` but for a module.  Such a\n-        function is executed each request, even if outside of the module.\n+        \"\"\"Like :meth:`Flask.context_processor` but for a blueprint.  Such a\n+        function is executed each request, even if outside of the blueprint.\n         \"\"\"\n         self.record_once(lambda s: s.app.template_context_processors\n             .setdefault(None, []).append(f))\n         return f\n \n     def app_errorhandler(self, code):\n-        \"\"\"Like :meth:`Flask.errorhandler` but for a module.  This\n-        handler is used for all requests, even if outside of the module.\n+        \"\"\"Like :meth:`Flask.errorhandler` but for a blueprint.  This\n+        handler is used for all requests, even if outside of the blueprint.\n         \"\"\"\n         def decorator(f):\n             self.record_once(lambda s: s.app.errorhandler(code)(f))\n@@ -210,7 +210,7 @@ class Blueprint(_PackageBoundObject):\n         return f\n \n     def url_defaults(self, f):\n-        \"\"\"Callback function for URL defaults for this module.  It's called\n+        \"\"\"Callback function for URL defaults for this blueprint.  It's called\n         with the endpoint and values and should update the values passed\n         in place.\n         \"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#abe1378caec759cc8c6fc0afeaad248677c4420f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 53 | Lines Deleted: 57 | Files Changed: 6 | Hunks: 17 | Methods Changed: 18 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 110 | Churn Cumulative: 5958 | Contributors (this commit): 24 | Commits (past 90d): 46 | Contributors (cumulative): 45 | DMM Complexity: 1.0\n\nDIFF:\n@@ -206,8 +206,9 @@ class Flask(_PackageBoundObject):\n     test_client_class = None\n \n     def __init__(self, import_name, static_path=None, static_url_path=None,\n-                 static_folder='static'):\n-        _PackageBoundObject.__init__(self, import_name)\n+                 static_folder='static', template_folder='templates'):\n+        _PackageBoundObject.__init__(self, import_name,\n+                                     template_folder=template_folder)\n         if static_path is not None:\n             from warnings import warn\n             warn(DeprecationWarning('static_path is now called '\n@@ -456,7 +457,7 @@ class Flask(_PackageBoundObject):\n         rv.filters['tojson'] = _tojson_filter\n         return rv\n \n-    def create_jinja_loader(self):\n+    def create_global_jinja_loader(self):\n         \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n         override just the loader and keeping the rest unchanged.\n \n\n@@ -56,9 +56,9 @@ class Blueprint(_PackageBoundObject):\n     _got_registered_once = False\n \n     def __init__(self, name, import_name, static_folder=None,\n-                 static_url_path=None, url_prefix=None,\n-                 subdomain=None):\n-        _PackageBoundObject.__init__(self, import_name)\n+                 static_url_path=None, template_folder=None,\n+                 url_prefix=None, subdomain=None):\n+        _PackageBoundObject.__init__(self, import_name, template_folder)\n         self.name = name\n         self.url_prefix = url_prefix\n         self.subdomain = subdomain\n\n@@ -485,13 +485,15 @@ class locked_cached_property(object):\n \n class _PackageBoundObject(object):\n \n-    template_folder = 'templates'\n-\n-    def __init__(self, import_name):\n+    def __init__(self, import_name, template_folder=None):\n         #: The name of the package or module.  Do not change this once\n         #: it was set by the constructor.\n         self.import_name = import_name\n \n+        #: location of the templates.  `None` if templates should not be\n+        #: exposed.\n+        self.template_folder = template_folder\n+\n         #: Where is the app root located?\n         self.root_path = _get_package_path(self.import_name)\n \n@@ -544,8 +546,7 @@ class _PackageBoundObject(object):\n         \"\"\"\n         if not self.has_static_folder:\n             raise RuntimeError('No static folder for this object')\n-        return send_from_directory(os.path.join(self.root_path, 'static'),\n-                                   filename)\n+        return send_from_directory(self.static_folder, filename)\n \n     def open_resource(self, resource):\n         \"\"\"Opens a resource from the application's resource folder.  To see\n\n@@ -11,7 +11,6 @@\n \n import os\n \n-from .helpers import _PackageBoundObject, _endpoint_from_view_func\n from .blueprints import Blueprint\n \n \n@@ -37,7 +36,7 @@ class Module(Blueprint):\n                 'does not point to a submodule'\n             name = import_name.rsplit('.', 1)[1]\n         Blueprint.__init__(self, name, import_name, url_prefix=url_prefix,\n-                           subdomain=subdomain)\n+                           subdomain=subdomain, template_folder='templates')\n \n         if os.path.isdir(os.path.join(self.root_path, 'static')):\n             self._static_folder = 'static'\n\n@@ -38,69 +38,64 @@ class Environment(BaseEnvironment):\n \n     def __init__(self, app, **options):\n         if 'loader' not in options:\n-            options['loader'] = app.create_jinja_loader()\n+            options['loader'] = app.create_global_jinja_loader()\n         BaseEnvironment.__init__(self, **options)\n         self.app = app\n \n-    def join_path(self, template, parent):\n-        if template and template[0] == ':':\n-            template = parent.split(':', 1)[0] + template\n-        return template\n-\n \n class DispatchingJinjaLoader(BaseLoader):\n     \"\"\"A loader that looks for templates in the application and all\n-    the module folders.\n+    the blueprint folders.\n     \"\"\"\n \n     def __init__(self, app):\n         self.app = app\n \n     def get_source(self, environment, template):\n-        # newstyle template support.  blueprints are explicit and no further\n-        # magic is involved.  If the template cannot be loaded by the\n-        # blueprint loader it just gives up, no further steps involved.\n-        if ':' in template:\n-            blueprint_name, local_template = template.split(':', 1)\n-            local_template = posixpath.normpath(local_template)\n-            blueprint = self.app.blueprints.get(blueprint_name)\n-            if blueprint is None:\n-                raise TemplateNotFound(template)\n-            loader = blueprint.jinja_loader\n-            if loader is not None:\n-                return loader.get_source(environment, local_template)\n-\n-        # if modules are enabled we call into the old style template lookup\n-        # and try that before we go with the real deal.\n-        loader = None\n+        for loader, local_name in self._iter_loaders(template):\n             try:\n-            module, name = posixpath.normpath(template).split('/', 1)\n-            blueprint = self.app.blueprints[module]\n-            if blueprint_is_module(blueprint):\n-                loader = blueprint.jinja_loader\n-        except (ValueError, KeyError, TemplateNotFound):\n-            pass\n-        try:\n-            if loader is not None:\n-                return loader.get_source(environment, name)\n+                return loader.get_source(environment, local_name)\n             except TemplateNotFound:\n                 pass\n \n-        # at the very last, load templates from the environment\n-        return self.app.jinja_loader.get_source(environment, template)\n+        raise TemplateNotFound(template)\n+\n+    def _iter_loaders(self, template):\n+        loader = self.app.jinja_loader\n+        if loader is not None:\n+            yield loader, template\n+\n+        # old style module based loaders in case we are dealing with a\n+        # blueprint that is an old style module\n+        try:\n+            module, local_name = posixpath.normpath(template).split('/', 1)\n+            blueprint = self.app.blueprints[module]\n+            if blueprint_is_module(blueprint):\n+                loader = blueprint.jinja_loader\n+                if loader is not None:\n+                    yield loader, local_name\n+        except (ValueError, KeyError):\n+            pass\n+\n+        for blueprint in self.app.blueprints.itervalues():\n+            loader = blueprint.jinja_loader\n+            if loader is not None:\n+                yield loader, template\n \n     def list_templates(self):\n-        result = set(self.app.jinja_loader.list_templates())\n-\n-        for name, module in self.app.modules.iteritems():\n-            if module.jinja_loader is not None:\n-                for template in module.jinja_loader.list_templates():\n-                    result.add('%s/%s' % (name, template))\n+        result = set()\n+        loader = self.app.jinja_loader\n+        if loader is not None:\n+            result.update(loader.list_templates())\n \n         for name, blueprint in self.app.blueprints.iteritems():\n-            if blueprint.jinja_loader is not None:\n-                for template in blueprint.jinja_loader.list_templates():\n-                    result.add('%s:%s' % (name, template))\n+            loader = blueprint.jinja_loader\n+            if loader is not None:\n+                for template in loader.list_templates():\n+                    prefix = ''\n+                    if not blueprint_is_module(blueprint):\n+                        prefix = name + '/'\n+                    result.add(prefix + template)\n \n         return list(result)\n \n\n@@ -992,7 +992,7 @@ class TemplatingTestCase(unittest.TestCase):\n \n     def test_custom_template_loader(self):\n         class MyFlask(flask.Flask):\n-            def create_jinja_loader(self):\n+            def create_global_jinja_loader(self):\n                 from jinja2 import DictLoader\n                 return DictLoader({'index.html': 'Hello Custom World!'})\n         app = MyFlask(__name__)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#62d91d67f3b96ce7412d747ab3dd60a3aecc8276", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 7 | Churn Cumulative: 2006 | Contributors (this commit): 12 | Commits (past 90d): 16 | Contributors (cumulative): 12 | DMM Complexity: None\n\nDIFF:\n@@ -459,7 +459,12 @@ class Flask(_PackageBoundObject):\n \n     def create_global_jinja_loader(self):\n         \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n-        override just the loader and keeping the rest unchanged.\n+        override just the loader and keeping the rest unchanged.  It's\n+        discouraged to override this function.  Instead one should override\n+        the :meth:`create_jinja_loader` function instead.\n+\n+        The global loader dispatches between the loaders of the application\n+        and the individual blueprints.\n \n         .. versionadded:: 0.7\n         \"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#e17e74d3a74b5d32a622587b2b9da9840bf3a7e0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 36 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 8 | Methods Changed: 7 | Complexity Δ (Sum/Max): 5/3 | Churn Δ: 39 | Churn Cumulative: 2374 | Contributors (this commit): 12 | Commits (past 90d): 18 | Contributors (cumulative): 13 | DMM Complexity: 1.0\n\nDIFF:\n@@ -9,7 +9,6 @@\n     :copyright: (c) 2011 by Armin Ronacher.\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n-import os\n from functools import update_wrapper\n \n from .helpers import _PackageBoundObject, _endpoint_from_view_func\n@@ -36,14 +35,24 @@ class BlueprintSetupState(object):\n             url_prefix = self.blueprint.url_prefix\n         self.url_prefix = url_prefix\n \n+        self.url_defaults = dict(self.blueprint.url_defaults)\n+        self.url_defaults.update(self.options.get('url_defaults', ()))\n+\n     def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n+        \"\"\"A helper method to register a rule (and optionally a view function)\n+        to the application.  The endpoint is automatically prefixed with the\n+        blueprint's name.\n+        \"\"\"\n         if self.url_prefix:\n             rule = self.url_prefix + rule\n         options.setdefault('subdomain', self.subdomain)\n         if endpoint is None:\n             endpoint = _endpoint_from_view_func(view_func)\n+        defaults = self.url_defaults\n+        if 'defaults' in options:\n+            defaults = dict(defaults, **options.pop('defaults'))\n         self.app.add_url_rule(rule, '%s.%s' % (self.blueprint.name, endpoint),\n-                              view_func, **options)\n+                              view_func, defaults=defaults, **options)\n \n \n class Blueprint(_PackageBoundObject):\n@@ -57,7 +66,7 @@ class Blueprint(_PackageBoundObject):\n \n     def __init__(self, name, import_name, static_folder=None,\n                  static_url_path=None, template_folder=None,\n-                 url_prefix=None, subdomain=None):\n+                 url_prefix=None, subdomain=None, url_defaults=None):\n         _PackageBoundObject.__init__(self, import_name, template_folder)\n         self.name = name\n         self.url_prefix = url_prefix\n@@ -66,6 +75,9 @@ class Blueprint(_PackageBoundObject):\n         self.static_url_path = static_url_path\n         self.deferred_functions = []\n         self.view_functions = {}\n+        if url_defaults is None:\n+            url_defaults = {}\n+        self.url_defaults = url_defaults\n \n     def record(self, func):\n         \"\"\"Registers a function that is called when the blueprint is\n\n@@ -1272,6 +1272,27 @@ class BlueprintTestCase(unittest.TestCase):\n         assert c.get('/backend-no').data == 'backend says no'\n         assert c.get('/what-is-a-sideend').data == 'application itself says no'\n \n+    def test_blueprint_url_definitions(self):\n+        bp = flask.Blueprint('test', __name__)\n+\n+        @bp.route('/foo', defaults={'baz': 42})\n+        def foo(bar, baz):\n+            return '%s/%d' % (bar, baz)\n+\n+        @bp.route('/bar')\n+        def bar(bar):\n+            return unicode(bar)\n+\n+        app = flask.Flask(__name__)\n+        app.register_blueprint(bp, url_prefix='/1', url_defaults={'bar': 23})\n+        app.register_blueprint(bp, url_prefix='/2', url_defaults={'bar': 19})\n+\n+        c = app.test_client()\n+        self.assertEqual(c.get('/1/foo').data, u'23/42')\n+        self.assertEqual(c.get('/2/foo').data, u'19/42')\n+        self.assertEqual(c.get('/1/bar').data, u'23')\n+        self.assertEqual(c.get('/2/bar').data, u'19')\n+\n \n class SendfileTestCase(unittest.TestCase):\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#37fab7888744b23f62f678614656b686bb046379", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 61 | Lines Deleted: 3 | Files Changed: 5 | Hunks: 7 | Methods Changed: 6 | Complexity Δ (Sum/Max): 5/2 | Churn Δ: 64 | Churn Cumulative: 2054 | Contributors (this commit): 11 | Commits (past 90d): 15 | Contributors (cumulative): 15 | DMM Complexity: 1.0\n\nDIFF:\n@@ -0,0 +1,7 @@\n+from flask import Flask\n+\n+app = Flask(__name__)\n+from moduleapp.apps.admin import admin\n+from moduleapp.apps.frontend import frontend\n+app.register_blueprint(admin)\n+app.register_blueprint(frontend)\n\n\n@@ -0,0 +1,13 @@\n+from flask import Blueprint, render_template\n+\n+admin = Blueprint(__name__, url_prefix='/admin')\n+\n+\n+@admin.route('/')\n+def index():\n+    return render_template('admin/index.html')\n+\n+\n+@admin.route('/index2')\n+def index2():\n+    return render_template('./admin/index.html')\n\n@@ -0,0 +1,8 @@\n+from flask import Blueprint, render_template\n+\n+frontend = Blueprint(__name__)\n+\n+\n+@frontend.route('/')\n+def index():\n+    return render_template('frontend/index.html')\n\n@@ -433,7 +433,7 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n     def test_teardown_request_handler_debug_mode(self):\n         called = []\n         app = flask.Flask(__name__)\n-        app.debug = True\n+        app.testing = True\n         @app.teardown_request\n         def teardown_request(exc):\n             called.append(True)\n@@ -819,7 +819,7 @@ class JSONTestCase(unittest.TestCase):\n \n     def test_json_body_encoding(self):\n         app = flask.Flask(__name__)\n-        app.debug = True\n+        app.testing = True\n         @app.route('/')\n         def index():\n             return flask.request.json\n@@ -1139,7 +1139,7 @@ class ModuleTestCase(unittest.TestCase):\n \n     def test_templates_and_static(self):\n         app = moduleapp\n-        app.debug = True\n+        app.testing = True\n         c = app.test_client()\n \n         rv = c.get('/')\n@@ -1293,6 +1293,36 @@ class BlueprintTestCase(unittest.TestCase):\n         self.assertEqual(c.get('/1/bar').data, u'23')\n         self.assertEqual(c.get('/2/bar').data, u'19')\n \n+    def test_templates_and_static(self):\n+        from blueprintapp import app\n+        c = app.test_client()\n+\n+        rv = c.get('/')\n+        assert rv.data == 'Hello from the Frontend'\n+        rv = c.get('/admin/')\n+        assert rv.data == 'Hello from the Admin'\n+        rv = c.get('/admin/index2')\n+        assert rv.data == 'Hello from the Admin'\n+        rv = c.get('/admin/static/test.txt')\n+        assert rv.data.strip() == 'Admin File'\n+        rv = c.get('/admin/static/css/test.css')\n+        assert rv.data.strip() == '/* nested file */'\n+\n+        with app.test_request_context():\n+            assert flask.url_for('admin.static', filename='test.txt') \\\n+                == '/admin/static/test.txt'\n+\n+        with app.test_request_context():\n+            try:\n+                flask.render_template('missing.html')\n+            except TemplateNotFound, e:\n+                assert e.name == 'missing.html'\n+            else:\n+                assert 0, 'expected exception'\n+\n+        with flask.Flask(__name__).test_request_context():\n+            assert flask.render_template('nested/nested.txt') == 'I\\'m nested'\n+\n \n class SendfileTestCase(unittest.TestCase):\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#0fcbe0a47895a1d1106b50420fe696e04520b621", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 69 | Files Changed: 1 | Hunks: 11 | Methods Changed: 12 | Complexity Δ (Sum/Max): -20/0 | Churn Δ: 75 | Churn Cumulative: 482 | Contributors (this commit): 1 | Commits (past 90d): 13 | Contributors (cumulative): 1 | DMM Complexity: 0.5087719298245614\n\nDIFF:\n@@ -21,7 +21,6 @@\n \"\"\"\n import re\n import os\n-import sys\n import inspect\n import difflib\n import posixpath\n@@ -177,37 +176,7 @@ def rewrite_blueprint_imports(contents):\n     return ''.join(new_file)\n \n \n-def rewrite_render_template_calls(contents, module_declarations):\n-    mapping = dict(module_declarations)\n-    annotated_lines = []\n-\n-    def make_line_annotations():\n-        if not annotated_lines:\n-            last_index = 0\n-            for line in contents.splitlines(True):\n-                last_index += len(line)\n-                annotated_lines.append((last_index, line))\n-\n-    def backtrack_module_name(call_start):\n-        make_line_annotations()\n-        for idx, (line_end, line) in enumerate(annotated_lines):\n-            if line_end > call_start:\n-                for _, line in reversed(annotated_lines[:idx]):\n-                    match = _mod_route_re.search(line)\n-                    if match is not None:\n-                        shortname = match.group(1)\n-                        return mapping.get(shortname)\n-\n-    def handle_match(match):\n-        template_name = ast.literal_eval(match.group(2))\n-        modname = backtrack_module_name(match.start())\n-        if modname is not None and template_name.startswith(modname + '/'):\n-            template_name = modname + ':' + template_name[len(modname) + 1:]\n-        return match.group(1) + repr(template_name)\n-    return _render_template_re.sub(handle_match, contents)\n-\n-\n-def rewrite_for_blueprints(contents, filename, template_bundles=False):\n+def rewrite_for_blueprints(contents, filename):\n     modules_declared = []\n     def handle_match(match):\n         target = match.group(1)\n@@ -222,21 +191,17 @@ def rewrite_for_blueprints(contents, filename, template_bundles=False):\n \n     if modules_declared:\n         new_contents = rewrite_blueprint_imports(new_contents)\n-        if template_bundles:\n-            new_contents = rewrite_render_template_calls(new_contents,\n-                                                         modules_declared)\n \n     for pattern, replacement in _blueprint_related:\n         new_contents = pattern.sub(replacement, new_contents)\n     return new_contents\n \n \n-def upgrade_python_file(filename, contents, teardown, template_bundles):\n+def upgrade_python_file(filename, contents, teardown):\n     new_contents = fix_url_for(contents)\n     if teardown:\n         new_contents = fix_teardown_funcs(new_contents)\n-    new_contents = rewrite_for_blueprints(new_contents, filename,\n-                                          template_bundles)\n+    new_contents = rewrite_for_blueprints(new_contents, filename)\n     new_contents = _error_handler_re.sub('\\\\1.error_handler_spec[None][\\\\2]',\n                                          new_contents)\n     make_diff(filename, contents, new_contents)\n@@ -266,32 +231,16 @@ def walk_path(path):\n                     yield filename, 'template'\n \n \n-def scan_path(path=None, teardown=True, template_bundles=True):\n+def scan_path(path=None, teardown=True):\n     for filename, type in walk_path(path):\n         with open(filename) as f:\n             contents = f.read()\n         if type == 'python':\n-            upgrade_python_file(filename, contents, teardown,\n-                                template_bundles)\n+            upgrade_python_file(filename, contents, teardown)\n         elif type == 'template':\n             upgrade_template_file(filename, contents)\n \n \n-def autodetect_template_bundles(paths):\n-    folders_with_templates = set()\n-    for path in paths:\n-        for filename, type in walk_path(path):\n-            if type == 'template':\n-                fullpath = filename.replace(os.path.sep, '/')\n-                index = fullpath.find('/templates/')\n-                if index >= 0:\n-                    folder = fullpath[:index]\n-                else:\n-                    folder = posixpath.dirname(fullpath)\n-                folders_with_templates.add(folder)\n-    return len(folders_with_templates) > 1\n-\n-\n def main():\n     \"\"\"Entrypoint\"\"\"\n     parser = OptionParser(usage='%prog [options] [paths]')\n@@ -302,10 +251,6 @@ def main():\n                       action='store_true', help='Indicate to the system '\n                       'that templates are bundled with modules.  Default '\n                       'is auto detect.')\n-    parser.add_option('-B', '--no-bundled-templates', dest='no_bundled_tmpl',\n-                      action='store_true', help='Indicate to the system '\n-                      'that templates are not bundled with modules.  '\n-                      'Default is auto detect')\n     options, args = parser.parse_args()\n     if not args:\n         args = ['.']\n@@ -315,16 +260,8 @@ def main():\n                      'The runtime requirements for Flask 0.7 however are still '\n                      'Python 2.5.')\n \n-    if options.no_bundled_tmpl:\n-        template_bundles = False\n-    elif options.bundled_tmpl:\n-        template_bundles = True\n-    else:\n-        template_bundles = autodetect_template_bundles(args)\n-\n     for path in args:\n-        scan_path(path, teardown=not options.no_teardown,\n-                  template_bundles=template_bundles)\n+        scan_path(path, teardown=not options.no_teardown)\n \n \n if __name__ == '__main__':\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#86175054d63df56c4f3c79108d363ef5e127e440", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 31 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 11 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 35 | Churn Cumulative: 419 | Contributors (this commit): 2 | Commits (past 90d): 9 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -16,25 +16,46 @@ from .helpers import _PackageBoundObject, _endpoint_from_view_func\n \n class BlueprintSetupState(object):\n     \"\"\"Temporary holder object for registering a blueprint with the\n-    application.\n+    application.  An instance of this class is created by the\n+    :meth:`~flask.Blueprint.make_setup_state` method and later passed\n+    to all register callback functions.\n     \"\"\"\n \n     def __init__(self, blueprint, app, options, first_registration):\n+        #: a reference to the current application\n         self.app = app\n+\n+        #: a reference to the blurprint that created this setup state.\n         self.blueprint = blueprint\n+\n+        #: a dictionary with all options that were passed to the\n+        #: :meth:`~flask.Flask.register_blueprint` method.\n         self.options = options\n+\n+        #: as blueprints can be registered multiple times with the\n+        #: application and not everything wants to be registered\n+        #: multiple times on it, this attribute can be used to figure\n+        #: out if the blueprint was registered in the past already.\n         self.first_registration = first_registration\n \n         subdomain = self.options.get('subdomain')\n         if subdomain is None:\n             subdomain = self.blueprint.subdomain\n+\n+        #: The subdomain that the blueprint should be active for, `None`\n+        #: otherwise.\n         self.subdomain = subdomain\n \n         url_prefix = self.options.get('url_prefix')\n         if url_prefix is None:\n             url_prefix = self.blueprint.url_prefix\n+\n+        #: The prefix that should be used for all URLs defined on the\n+        #: blueprint.\n         self.url_prefix = url_prefix\n \n+        #: A dictionary with URL defaults that is added to each and every\n+        #: URL that was defined with the blueprint.\n         self.url_defaults = dict(self.blueprint.url_defaults)\n         self.url_defaults.update(self.options.get('url_defaults', ()))\n \n@@ -56,7 +77,11 @@ class BlueprintSetupState(object):\n \n \n class Blueprint(_PackageBoundObject):\n-    \"\"\"Represents a blueprint.\n+    \"\"\"Represents a blueprint.  A blueprint is an object that records\n+    functions that will be called with the\n+    :class:`~flask.blueprint.BlueprintSetupState` later to register functions\n+    or other things on the main application.  See :ref:`blueprints` for more\n+    information.\n \n     .. versionadded:: 0.7\n     \"\"\"\n@@ -104,6 +129,10 @@ class Blueprint(_PackageBoundObject):\n         return self.record(update_wrapper(wrapper, func))\n \n     def make_setup_state(self, app, options, first_registration=False):\n+        \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n+        object that is later passed to the register callback functions.\n+        Subclasses can override this to return a subclass of the setup state.\n+        \"\"\"\n         return BlueprintSetupState(self, app, options, first_registration)\n \n     def register(self, app, options, first_registration=False):\n@@ -254,8 +283,6 @@ class Blueprint(_PackageBoundObject):\n \n         Otherwise works as the :meth:`~flask.Flask.errorhandler` decorator\n         of the :class:`~flask.Flask` object.\n-\n-        .. versionadded:: 0.7\n         \"\"\"\n         def decorator(f):\n             self.record_once(lambda s: s.app._register_error_handler(\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#7e55b5084ddbaeeadd8358b216f36e7706c79199", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 101 | Contributors (this commit): 2 | Commits (past 90d): 1 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -19,6 +19,7 @@ class FlaskrTestCase(unittest.TestCase):\n     def setUp(self):\n         \"\"\"Before each test, set up a blank database\"\"\"\n         self.db_fd, flaskr.app.config['DATABASE'] = tempfile.mkstemp()\n+        flaskr.app.config['TESTING'] = True\n         self.app = flaskr.app.test_client()\n         flaskr.init_db()\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#0e98a080976f39e20aa6f18e8a335aa23d9334f7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): -32/0 | Churn Δ: 8 | Churn Cumulative: 2014 | Contributors (this commit): 12 | Commits (past 90d): 16 | Contributors (cumulative): 12 | DMM Complexity: None\n\nDIFF:\n@@ -200,6 +200,12 @@ class Flask(_PackageBoundObject):\n         'MAX_CONTENT_LENGTH':                   None\n     })\n \n+    #: The rule object to use for URL rules created.  This is used by\n+    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n+    #:\n+    #: .. versionadded:: 0.7\n+    url_rule_class = Rule\n+\n     #: the test client that is used with when `test_client` is used.\n     #:\n     #: .. versionadded:: 0.7\n@@ -573,7 +579,7 @@ class Flask(_PackageBoundObject):\n         if 'OPTIONS' not in methods:\n             methods = tuple(methods) + ('OPTIONS',)\n             provide_automatic_options = True\n-        rule = Rule(rule, methods=methods, **options)\n+        rule = self.url_rule_class(rule, methods=methods, **options)\n         rule.provide_automatic_options = provide_automatic_options\n         self.url_map.add(rule)\n         if view_func is not None:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ab6bac111c9fa551ae0b6386a2cd6a13b45c26c7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 12 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 18 | Churn Cumulative: 209 | Contributors (this commit): 3 | Commits (past 90d): 3 | Contributors (cumulative): 3 | DMM Complexity: 1.0\n\nDIFF:\n@@ -90,12 +90,7 @@ class RequestContext(object):\n         self.flashes = None\n         self.session = None\n \n-        try:\n-            url_rule, self.request.view_args = \\\n-                self.url_adapter.match(return_rule=True)\n-            self.request.url_rule = url_rule\n-        except HTTPException, e:\n-            self.request.routing_exception = e\n+        self.match_request()\n \n         # Support for deprecated functionality.  This is doing away with\n         # Flask 1.0\n@@ -107,6 +102,17 @@ class RequestContext(object):\n             if bp is not None and blueprint_is_module(bp):\n                 self.request._is_old_module = True\n \n+    def match_request(self):\n+        \"\"\"Can be overridden by a subclass to hook into the matching\n+        of the request.\n+        \"\"\"\n+        try:\n+            url_rule, self.request.view_args = \\\n+                self.url_adapter.match(return_rule=True)\n+            self.request.url_rule = url_rule\n+        except HTTPException, e:\n+            self.request.routing_exception = e\n+\n     def push(self):\n         \"\"\"Binds the request context to the current context.\"\"\"\n         _request_ctx_stack.push(self)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#3d146548c7e687b1938c66df12082a1ab037c75d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 140 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 2 | Methods Changed: 14 | Complexity Δ (Sum/Max): 25/25 | Churn Δ: 140 | Churn Cumulative: 292 | Contributors (this commit): 3 | Commits (past 90d): 5 | Contributors (cumulative): 4 | DMM Complexity: 0.7439024390243902\n\nDIFF:\n@@ -10,6 +10,8 @@\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n \n+__version__ = '0.7'\n+\n # utilities we import from Werkzeug and Jinja2 that are unused\n # in the module but are exported as public interface.\n from werkzeug import abort, redirect\n\n@@ -0,0 +1,138 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+    make-release\n+    ~~~~~~~~~~~~\n+\n+    Helper script that performs a release.  Does pretty much everything\n+    automatically for us.\n+\n+    :copyright: (c) 2011 by Armin Ronacher.\n+    :license: BSD, see LICENSE for more details.\n+\"\"\"\n+import sys\n+import os\n+import re\n+from datetime import datetime, date\n+from subprocess import Popen, PIPE\n+\n+\n+def parse_changelog():\n+    with open('CHANGES') as f:\n+        lineiter = iter(f)\n+        for line in lineiter:\n+            match = re.search('^Version\\s+(.*)', line.strip())\n+            if match is None:\n+                continue\n+            length = len(match.group(1))\n+            version = match.group(1).strip()\n+            if lineiter.next().count('-') != len(match.group(0)):\n+                continue\n+            while 1:\n+                change_info = lineiter.next().strip()\n+                if change_info:\n+                    break\n+\n+            match = re.match(r'^released on (\\w+\\s+\\d+\\w+\\s+\\d+)'\n+                             r'(?:, codename (.*))?(?i)', change_info)\n+            if match is None:\n+                continue\n+\n+            datestr, codename = match.groups()\n+            return version, parse_date(datestr), codename\n+\n+\n+def parse_date(string):\n+    string = string.replace('th ', ' ').replace('nd ', ' ') \\\n+                   .replace('rd ', ' ').replace('st ', ' ')\n+    return datetime.strptime(string, '%B %d %Y')\n+\n+\n+def set_filename_version(filename, version_number, pattern):\n+    changed = []\n+    def inject_version(match):\n+        before, old, after = match.groups()\n+        changed.append(True)\n+        return before + version_number + after\n+    with open(filename) as f:\n+        contents = re.sub(r\"^(\\s*%s\\s*=\\s*')(.+?)(')(?sm)\" % pattern,\n+                          inject_version, f.read())\n+\n+    if not changed:\n+        fail('Could not find %s in %s', pattern, filename)\n+\n+    with open(filename, 'w') as f:\n+        f.write(contents)\n+\n+\n+def set_init_version(version):\n+    info('Setting __init__.py version to %s', version)\n+    set_filename_version('flask/__init__.py', version, '__version__')\n+\n+\n+def set_setup_version(version):\n+    info('Setting setup.py version to %s', version)\n+    set_filename_version('setup.py', version, 'version')\n+\n+\n+def build_and_upload():\n+    Popen([sys.executable, 'setup.py', 'sdist', 'release']).wait()\n+\n+\n+def fail(message, *args):\n+    print >> sys.stderr, 'Error:', message % args\n+    sys.exit(1)\n+\n+\n+def info(message, *args):\n+    print >> sys.stderr, message % args\n+\n+\n+def get_git_tags():\n+    return set(Popen(['git', 'tag'], stdout=PIPE).communicate()[0].splitlines())\n+\n+\n+def git_is_clean():\n+    return Popen(['git', 'diff', '--quiet']).wait() == 0\n+\n+\n+def make_git_commit(message, *args):\n+    message = message % args\n+    Popen(['git', 'commit', '-am', message]).wait()\n+\n+\n+def make_git_tag(tag):\n+    info('Tagging \"%s\"', tag)\n+    Popen(['git', 'tag', tag]).wait()\n+\n+\n+def main():\n+    os.chdir(os.path.join(os.path.dirname(__file__), '..'))\n+\n+    rv = parse_changelog()\n+    if rv is None:\n+        fail('Could not parse changelog')\n+\n+    version, release_date, codename = rv\n+\n+    info('Releasing %s (codename %s, release date %s)',\n+         version, codename, release_date.strftime('%d/%m/%Y'))\n+    tags = get_git_tags()\n+\n+    if version in tags:\n+        fail('Version \"%s\" is already tagged', version)\n+    if release_date.date() != date.today():\n+        fail('Release date is not today (%s != %s)')\n+\n+    if not git_is_clean():\n+        fail('You have uncommitted changes in git')\n+\n+    set_init_version(version)\n+    set_setup_version(version)\n+    make_git_commit('Bump version number to %s', version)\n+    make_git_tag(version)\n+    build_and_upload()\n+\n+\n+if __name__ == '__main__':\n+    main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
