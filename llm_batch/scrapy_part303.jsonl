{"custom_id": "scrapy#e662762e6ab2f53ff2e31e21f34c078590f65aa9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 35 | Lines Deleted: 11 | Files Changed: 2 | Hunks: 13 | Methods Changed: 6 | Complexity Δ (Sum/Max): 6/6 | Churn Δ: 46 | Churn Cumulative: 2480 | Contributors (this commit): 2 | Commits (past 90d): 50 | Contributors (cumulative): 4 | DMM Complexity: 0.8666666666666667\n\nDIFF:\n@@ -2,16 +2,18 @@ import ipaddress\n import itertools\n import logging\n from collections import deque\n-from typing import Dict, List, Optional\n+from ipaddress import IPv4Address, IPv6Address\n+from typing import Dict, List, Optional, Union\n \n from h2.config import H2Configuration\n from h2.connection import H2Connection\n from h2.errors import ErrorCodes\n from h2.events import (\n-    Event, DataReceived, ResponseReceived, SettingsAcknowledged,\n-    StreamEnded, StreamReset, WindowUpdated\n+    Event, ConnectionTerminated, DataReceived, ResponseReceived,\n+    SettingsAcknowledged, StreamEnded, StreamReset, UnknownFrameReceived,\n+    WindowUpdated\n )\n-from h2.exceptions import ProtocolError\n+from h2.exceptions import H2Error, ProtocolError\n from twisted.internet.defer import Deferred\n from twisted.internet.error import TimeoutError\n from twisted.internet.interfaces import IHandshakeListener, IProtocolNegotiationFactory\n@@ -30,7 +32,7 @@ from scrapy.settings import Settings\n logger = logging.getLogger(__name__)\n \n \n-class InvalidNegotiatedProtocol(ProtocolError):\n+class InvalidNegotiatedProtocol(H2Error):\n \n     def __init__(self, negotiated_protocol: str) -> None:\n         self.negotiated_protocol = negotiated_protocol\n@@ -39,6 +41,15 @@ class InvalidNegotiatedProtocol(ProtocolError):\n         return f'InvalidHostname: Expected h2 as negotiated protocol, received {self.negotiated_protocol}'\n \n \n+class RemoteTerminatedConnection(H2Error):\n+    def __init__(self, remote_ip_address: Optional[Union[IPv4Address, IPv6Address]], event: ConnectionTerminated):\n+        self.remote_ip_address = remote_ip_address\n+        self.terminate_event = event\n+\n+    def __str__(self) -> str:\n+        return f'RemoteTerminatedConnection: Received GOAWAY frame from {self.remote_ip_address}'\n+\n+\n @implementer(IHandshakeListener)\n class H2ClientProtocol(Protocol, TimeoutMixin):\n     IDLE_TIMEOUT = 240\n@@ -194,8 +205,12 @@ class H2ClientProtocol(Protocol, TimeoutMixin):\n     def handshakeCompleted(self):\n         \"\"\"We close the connection with InvalidNegotiatedProtocol exception\n         when the connection was not made via h2 protocol\"\"\"\n+        negotiated_protocol = self.transport.negotiatedProtocol\n+        if type(negotiated_protocol) is bytes:\n             negotiated_protocol = str(self.transport.negotiatedProtocol, 'utf-8')\n         if negotiated_protocol != 'h2':\n+            # Here we have not initiated the connection yet\n+            # So, no need to send a GOAWAY frame to the remote\n             self._lose_connection_with_error([InvalidNegotiatedProtocol(negotiated_protocol)])\n \n     def dataReceived(self, data: bytes) -> None:\n@@ -231,7 +246,9 @@ class H2ClientProtocol(Protocol, TimeoutMixin):\n         self.conn.close_connection(error_code=error_code)\n         self._write_to_transport()\n \n-        self._lose_connection_with_error([TimeoutError(\"Hello\")])\n+        self._lose_connection_with_error([\n+            TimeoutError(f\"Connection was IDLE for more than {self.IDLE_TIMEOUT}s\")\n+        ])\n \n     def connectionLost(self, reason: Failure = connectionDone) -> None:\n         \"\"\"Called by Twisted when the transport connection is lost.\n@@ -267,7 +284,9 @@ class H2ClientProtocol(Protocol, TimeoutMixin):\n             events -- A list of events that the remote peer triggered by sending data\n         \"\"\"\n         for event in events:\n-            if isinstance(event, DataReceived):\n+            if isinstance(event, ConnectionTerminated):\n+                self.connection_terminated(event)\n+            elif isinstance(event, DataReceived):\n                 self.data_received(event)\n             elif isinstance(event, ResponseReceived):\n                 self.response_received(event)\n@@ -279,10 +298,15 @@ class H2ClientProtocol(Protocol, TimeoutMixin):\n                 self.window_updated(event)\n             elif isinstance(event, SettingsAcknowledged):\n                 self.settings_acknowledged(event)\n-            else:\n-                logger.debug('Received unhandled event {}'.format(event))\n+            elif isinstance(event, UnknownFrameReceived):\n+                logger.debug(f'UnknownFrameReceived: frame={event.frame}')\n \n     # Event handler functions starts here\n+    def connection_terminated(self, event: ConnectionTerminated) -> None:\n+        self._lose_connection_with_error([\n+            RemoteTerminatedConnection(self.metadata['ip_address'], event)\n+        ])\n+\n     def data_received(self, event: DataReceived) -> None:\n         self.streams[event.stream_id].receive_data(event.data, event.flow_controlled_length)\n \n\n@@ -5,7 +5,7 @@ from typing import List, Optional, Tuple, TYPE_CHECKING\n from urllib.parse import urlparse\n \n from h2.errors import ErrorCodes\n-from h2.exceptions import StreamClosedError\n+from h2.exceptions import H2Error, StreamClosedError\n from hpack import HeaderTuple\n from twisted.internet.defer import Deferred, CancelledError\n from twisted.internet.error import ConnectionClosed\n@@ -32,7 +32,7 @@ class InactiveStreamClosed(ConnectionClosed):\n         self.request = request\n \n \n-class InvalidHostname(Exception):\n+class InvalidHostname(H2Error):\n \n     def __init__(self, request: Request, expected_hostname: str, expected_netloc: str) -> None:\n         self.request = request\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#38496a00b7d2bcfa9d435551409e2c44007d168d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 836 | Lines Deleted: 822 | Files Changed: 8 | Hunks: 36 | Methods Changed: 153 | Complexity Δ (Sum/Max): -53/79 | Churn Δ: 1658 | Churn Cumulative: 3968 | Contributors (this commit): 53 | Commits (past 90d): 27 | Contributors (cumulative): 107 | DMM Complexity: 0.46534653465346537\n\nDIFF:\n@@ -284,6 +284,7 @@ intersphinx_mapping = {\n     'attrs': ('https://www.attrs.org/en/stable/', None),\n     'coverage': ('https://coverage.readthedocs.io/en/stable', None),\n     'cssselect': ('https://cssselect.readthedocs.io/en/latest', None),\n+    'itemloaders': ('https://itemloaders.readthedocs.io/en/latest/', None),\n     'pytest': ('https://docs.pytest.org/en/latest', None),\n     'python': ('https://docs.python.org/3', None),\n     'sphinx': ('https://www.sphinx-doc.org/en/master', None),\n@@ -305,3 +306,15 @@ hoverxref_role_types = {\n     \"ref\": \"tooltip\",\n }\n hoverxref_roles = ['command', 'reqmeta', 'setting', 'signal']\n+\n+\n+def setup(app):\n+    app.connect('autodoc-skip-member', maybe_skip_member)\n+\n+\n+def maybe_skip_member(app, what, name, obj, skip, options):\n+    if not skip:\n+        # autodocs was generating a text \"alias of\" for the following members\n+        # https://github.com/sphinx-doc/sphinx/issues/4422\n+        return name in {'default_item_class', 'default_selector_class'}\n+    return skip\n\n@@ -3,217 +3,86 @@ Item Loader\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n-\n-from itemadapter import ItemAdapter\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n+    A user-friendly abstraction to populate an :ref:`item <topics-items>` with data\n+    by applying :ref:`field processors <topics-loaders-processors>` to scraped data.\n+    When instantiated with a ``selector`` or a ``response`` it supports\n+    data extraction from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: scrapy.item.Item\n+\n+    :param selector: The selector to extract data from, when using the\n+        :meth:`add_xpath`, :meth:`add_css`, :meth:`replace_xpath`, or\n+        :meth:`replace_css` method.\n+    :type selector: :class:`~scrapy.selector.Selector` object\n+\n+    :param response: The response used to construct the selector using the\n+        :attr:`default_selector_class`, unless the selector argument is given,\n+        in which case this argument is ignored.\n+    :type response: :class:`~scrapy.http.Response` object\n+\n+    If no item is given, one is instantiated automatically using the class in\n+    :attr:`default_item_class`.\n+\n+    The item, selector, response and remaining keyword arguments are\n+    assigned to the Loader context (accessible through the :attr:`context` attribute).\n+\n+    .. attribute:: item\n+\n+        The item object being parsed by this Item Loader.\n+        This is mostly used as a property so, when attempting to override this\n+        value, you may want to check out :attr:`default_item_class` first.\n+\n+    .. attribute:: context\n+\n+        The currently active :ref:`Context <loaders-context>` of this Item Loader.\n+\n+    .. attribute:: default_item_class\n+\n+        An :ref:`item <topics-items>` class (or factory), used to instantiate\n+        items when not given in the ``__init__`` method.\n+\n+    .. attribute:: default_input_processor\n+\n+        The default input processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_output_processor\n+\n+        The default output processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_selector_class\n+\n+        The class used to construct the :attr:`selector` of this\n+        :class:`ItemLoader`, if only a response is given in the ``__init__`` method.\n+        If a selector is given in the ``__init__`` method this attribute is ignored.\n+        This attribute is sometimes overridden in subclasses.\n+\n+    .. attribute:: selector\n+\n+        The :class:`~scrapy.selector.Selector` object to extract data from.\n+        It's either the selector given in the ``__init__`` method or one created from\n+        the response given in the ``__init__`` method using the\n+        :attr:`default_selector_class`. This attribute is meant to be\n+        read-only.\n     \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n-\n-\n-class ItemLoader:\n \n     default_item_class = Item\n-    default_input_processor = Identity()\n-    default_output_processor = Identity()\n     default_selector_class = Selector\n \n     def __init__(self, item=None, selector=None, response=None, parent=None, **context):\n         if selector is None and response is not None:\n             selector = self.default_selector_class(response)\n-        self.selector = selector\n-        context.update(selector=selector, response=response)\n-        if item is None:\n-            item = self.default_item_class()\n-        self.context = context\n-        self.parent = parent\n-        self._local_item = context['item'] = item\n-        self._local_values = defaultdict(list)\n-        # values from initial item\n-        for field_name, value in ItemAdapter(item).items():\n-            self._values[field_name] += arg_to_iter(value)\n-\n-    @property\n-    def _values(self):\n-        if self.parent is not None:\n-            return self.parent._values\n-        else:\n-            return self._local_values\n-\n-    @property\n-    def item(self):\n-        if self.parent is not None:\n-            return self.parent.item\n-        else:\n-            return self._local_item\n-\n-    def nested_xpath(self, xpath, **context):\n-        selector = self.selector.xpath(xpath)\n-        context.update(selector=selector)\n-        subloader = self.__class__(\n-            item=self.item, parent=self, **context\n-        )\n-        return subloader\n-\n-    def nested_css(self, css, **context):\n-        selector = self.selector.css(css)\n-        context.update(selector=selector)\n-        subloader = self.__class__(\n-            item=self.item, parent=self, **context\n-        )\n-        return subloader\n-\n-    def add_value(self, field_name, value, *processors, **kw):\n-        value = self.get_value(value, *processors, **kw)\n-        if value is None:\n-            return\n-        if not field_name:\n-            for k, v in value.items():\n-                self._add_value(k, v)\n-        else:\n-            self._add_value(field_name, value)\n-\n-    def replace_value(self, field_name, value, *processors, **kw):\n-        value = self.get_value(value, *processors, **kw)\n-        if value is None:\n-            return\n-        if not field_name:\n-            for k, v in value.items():\n-                self._replace_value(k, v)\n-        else:\n-            self._replace_value(field_name, value)\n-\n-    def _add_value(self, field_name, value):\n-        value = arg_to_iter(value)\n-        processed_value = self._process_input_value(field_name, value)\n-        if processed_value:\n-            self._values[field_name] += arg_to_iter(processed_value)\n-\n-    def _replace_value(self, field_name, value):\n-        self._values.pop(field_name, None)\n-        self._add_value(field_name, value)\n-\n-    def get_value(self, value, *processors, **kw):\n-        regex = kw.get('re', None)\n-        if regex:\n-            value = arg_to_iter(value)\n-            value = flatten(extract_regex(regex, x) for x in value)\n-\n-        for proc in processors:\n-            if value is None:\n-                break\n-            _proc = proc\n-            proc = wrap_loader_context(proc, self.context)\n-            try:\n-                value = proc(value)\n-            except Exception as e:\n-                raise ValueError(\"Error with processor %s value=%r error='%s: %s'\" %\n-                                 (_proc.__class__.__name__, value,\n-                                  type(e).__name__, str(e)))\n-        return value\n-\n-    def load_item(self):\n-        adapter = ItemAdapter(self.item)\n-        for field_name in tuple(self._values):\n-            value = self.get_output_value(field_name)\n-            if value is not None:\n-                adapter[field_name] = value\n-        return adapter.item\n-\n-    def get_output_value(self, field_name):\n-        proc = self.get_output_processor(field_name)\n-        proc = wrap_loader_context(proc, self.context)\n-        try:\n-            return proc(self._values[field_name])\n-        except Exception as e:\n-            raise ValueError(\"Error with output processor: field=%r value=%r error='%s: %s'\" %\n-                             (field_name, self._values[field_name], type(e).__name__, str(e)))\n-\n-    def get_collected_values(self, field_name):\n-        return self._values[field_name]\n-\n-    def get_input_processor(self, field_name):\n-        proc = getattr(self, '%s_in' % field_name, None)\n-        if not proc:\n-            proc = self._get_item_field_attr(field_name, 'input_processor',\n-                                             self.default_input_processor)\n-        return unbound_method(proc)\n-\n-    def get_output_processor(self, field_name):\n-        proc = getattr(self, '%s_out' % field_name, None)\n-        if not proc:\n-            proc = self._get_item_field_attr(field_name, 'output_processor',\n-                                             self.default_output_processor)\n-        return unbound_method(proc)\n-\n-    def _process_input_value(self, field_name, value):\n-        proc = self.get_input_processor(field_name)\n-        _proc = proc\n-        proc = wrap_loader_context(proc, self.context)\n-        try:\n-            return proc(value)\n-        except Exception as e:\n-            raise ValueError(\n-                \"Error with input processor %s: field=%r value=%r \"\n-                \"error='%s: %s'\" % (_proc.__class__.__name__, field_name,\n-                                    value, type(e).__name__, str(e)))\n-\n-    def _get_item_field_attr(self, field_name, key, default=None):\n-        field_meta = ItemAdapter(self.item).get_field_meta(field_name)\n-        return field_meta.get(key, default)\n-\n-    def _check_selector_method(self):\n-        if self.selector is None:\n-            raise RuntimeError(\"To use XPath or CSS selectors, \"\n-                               \"%s must be instantiated with a selector \"\n-                               \"or a response\" % self.__class__.__name__)\n-\n-    def add_xpath(self, field_name, xpath, *processors, **kw):\n-        values = self._get_xpathvalues(xpath, **kw)\n-        self.add_value(field_name, values, *processors, **kw)\n-\n-    def replace_xpath(self, field_name, xpath, *processors, **kw):\n-        values = self._get_xpathvalues(xpath, **kw)\n-        self.replace_value(field_name, values, *processors, **kw)\n-\n-    def get_xpath(self, xpath, *processors, **kw):\n-        values = self._get_xpathvalues(xpath, **kw)\n-        return self.get_value(values, *processors, **kw)\n-\n-    def _get_xpathvalues(self, xpaths, **kw):\n-        self._check_selector_method()\n-        xpaths = arg_to_iter(xpaths)\n-        return flatten(self.selector.xpath(xpath).getall() for xpath in xpaths)\n-\n-    def add_css(self, field_name, css, *processors, **kw):\n-        values = self._get_cssvalues(css, **kw)\n-        self.add_value(field_name, values, *processors, **kw)\n-\n-    def replace_css(self, field_name, css, *processors, **kw):\n-        values = self._get_cssvalues(css, **kw)\n-        self.replace_value(field_name, values, *processors, **kw)\n-\n-    def get_css(self, css, *processors, **kw):\n-        values = self._get_cssvalues(css, **kw)\n-        return self.get_value(values, *processors, **kw)\n-\n-    def _get_cssvalues(self, csss, **kw):\n-        self._check_selector_method()\n-        csss = arg_to_iter(csss)\n-        return flatten(self.selector.css(css).getall() for css in csss)\n+        context.update(response=response)\n+        super().__init__(item=item, selector=selector, parent=parent, **context)\n\n@@ -1,14 +1,21 @@\n \"\"\"Common functions used in Item Loaders code\"\"\"\n \n-from functools import partial\n-from scrapy.utils.python import get_func_args\n+import warnings\n+\n+from itemloaders import common\n+\n+from scrapy.utils.deprecate import ScrapyDeprecationWarning\n \n \n def wrap_loader_context(function, context):\n     \"\"\"Wrap functions that receive loader_context to contain the context\n     \"pre-loaded\" and expose a interface that receives only one argument\n     \"\"\"\n-    if 'loader_context' in get_func_args(function):\n-        return partial(function, loader_context=context)\n-    else:\n-        return function\n+    warnings.warn(\n+        \"scrapy.loader.common.wrap_loader_context has moved to a new library.\"\n+        \"Please update your reference to itemloaders.common.wrap_loader_context\",\n+        ScrapyDeprecationWarning,\n+        stacklevel=2\n+    )\n+\n+    return common.wrap_loader_context(function, context)\n\n@@ -3,102 +3,19 @@ This module provides some commonly used processors for Item Loaders.\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import ChainMap\n+from itemloaders import processors\n \n-from scrapy.utils.misc import arg_to_iter\n-from scrapy.loader.common import wrap_loader_context\n+from scrapy.utils.deprecate import create_deprecated_class\n \n \n-class MapCompose:\n+MapCompose = create_deprecated_class('MapCompose', processors.MapCompose)\n \n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.default_loader_context = default_loader_context\n+Compose = create_deprecated_class('Compose', processors.Compose)\n \n-    def __call__(self, value, loader_context=None):\n-        values = arg_to_iter(value)\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            next_values = []\n-            for v in values:\n-                try:\n-                    next_values += arg_to_iter(func(v))\n-                except Exception as e:\n-                    raise ValueError(\"Error in MapCompose with \"\n-                                     \"%s value=%r error='%s: %s'\" %\n-                                     (str(func), value, type(e).__name__,\n-                                      str(e)))\n-            values = next_values\n-        return values\n+TakeFirst = create_deprecated_class('TakeFirst', processors.TakeFirst)\n \n+Identity = create_deprecated_class('Identity', processors.Identity)\n \n-class Compose:\n+SelectJmes = create_deprecated_class('SelectJmes', processors.SelectJmes)\n \n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.stop_on_none = default_loader_context.get('stop_on_none', True)\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            if value is None and self.stop_on_none:\n-                break\n-            try:\n-                value = func(value)\n-            except Exception as e:\n-                raise ValueError(\"Error in Compose with \"\n-                                 \"%s value=%r error='%s: %s'\" %\n-                                 (str(func), value, type(e).__name__, str(e)))\n-        return value\n-\n-\n-class TakeFirst:\n-\n-    def __call__(self, values):\n-        for value in values:\n-            if value is not None and value != '':\n-                return value\n-\n-\n-class Identity:\n-\n-    def __call__(self, values):\n-        return values\n-\n-\n-class SelectJmes:\n-    \"\"\"\n-        Query the input string for the jmespath (given at instantiation),\n-        and return the answer\n-        Requires : jmespath(https://github.com/jmespath/jmespath)\n-        Note: SelectJmes accepts only one input element at a time.\n-    \"\"\"\n-    def __init__(self, json_path):\n-        self.json_path = json_path\n-        import jmespath\n-        self.compiled_path = jmespath.compile(self.json_path)\n-\n-    def __call__(self, value):\n-        \"\"\"Query value for the jmespath query and return answer\n-        :param value: a data structure (dict, list) to extract from\n-        :return: Element extracted according to jmespath query\n-        \"\"\"\n-        return self.compiled_path.search(value)\n-\n-\n-class Join:\n-\n-    def __init__(self, separator=u' '):\n-        self.separator = separator\n-\n-    def __call__(self, values):\n-        return self.separator.join(values)\n+Join = create_deprecated_class('Join', processors.Join)\n\n@@ -15,6 +15,7 @@ from w3lib.html import replace_entities\n from scrapy.utils.datatypes import LocalWeakReferencedCache\n from scrapy.utils.python import flatten, to_unicode\n from scrapy.item import _BaseItem\n+from scrapy.utils.deprecate import ScrapyDeprecationWarning\n \n \n _ITERABLE_SINGLE_VALUES = dict, _BaseItem, str, bytes\n@@ -86,6 +87,11 @@ def extract_regex(regex, text, encoding='utf-8'):\n     * if the regex contains multiple numbered groups, all those will be returned (flattened)\n     * if the regex doesn't contain any group the entire regex matching is returned\n     \"\"\"\n+    warnings.warn(\n+        \"scrapy.utils.misc.extract_regex has moved to parsel.utils.extract_regex.\",\n+        ScrapyDeprecationWarning,\n+        stacklevel=2\n+    )\n \n     if isinstance(regex, str):\n         regex = re.compile(regex, re.UNICODE)\n\n@@ -71,6 +71,7 @@ setup(\n         'Twisted>=17.9.0',\n         'cryptography>=2.0',\n         'cssselect>=0.9.1',\n+        'itemloaders>=1.0.1',\n         'lxml>=3.5.0',\n         'parsel>=1.5.0',\n         'PyDispatcher>=2.0.5',\n\n@@ -1,14 +1,12 @@\n-from functools import partial\n import unittest\n \n import attr\n from itemadapter import ItemAdapter\n+from itemloaders.processors import Compose, Identity, MapCompose, TakeFirst\n \n from scrapy.http import HtmlResponse\n from scrapy.item import Item, Field\n from scrapy.loader import ItemLoader\n-from scrapy.loader.processors import (Compose, Identity, Join,\n-                                      MapCompose, SelectJmes, TakeFirst)\n from scrapy.selector import Selector\n \n \n@@ -69,6 +67,10 @@ def processor_with_args(value, other=None, loader_context=None):\n \n class BasicItemLoaderTest(unittest.TestCase):\n \n+    def test_add_value_on_unknown_field(self):\n+        il = TestItemLoader()\n+        self.assertRaises(KeyError, il.add_value, 'wrong_field', [u'lala', u'lolo'])\n+\n     def test_load_item_using_default_loader(self):\n         i = TestItem()\n         i['summary'] = u'lala'\n@@ -85,391 +87,6 @@ class BasicItemLoaderTest(unittest.TestCase):\n         item = il.load_item()\n         self.assertEqual(item['name'], [u'Marta'])\n \n-    def test_load_item_ignore_none_field_values(self):\n-        def validate_sku(value):\n-            # Let's assume a SKU is only digits.\n-            if value.isdigit():\n-                return value\n-\n-        class MyLoader(ItemLoader):\n-            name_out = Compose(lambda vs: vs[0])  # take first which allows empty values\n-            price_out = Compose(TakeFirst(), float)\n-            sku_out = Compose(TakeFirst(), validate_sku)\n-\n-        valid_fragment = u'SKU: 1234'\n-        invalid_fragment = u'SKU: not available'\n-        sku_re = 'SKU: (.+)'\n-\n-        il = MyLoader(item={})\n-        # Should not return \"sku: None\".\n-        il.add_value('sku', [invalid_fragment], re=sku_re)\n-        # Should not ignore empty values.\n-        il.add_value('name', u'')\n-        il.add_value('price', [u'0'])\n-        self.assertEqual(il.load_item(), {\n-            'name': u'',\n-            'price': 0.0,\n-        })\n-\n-        il.replace_value('sku', [valid_fragment], re=sku_re)\n-        self.assertEqual(il.load_item()['sku'], u'1234')\n-\n-    def test_self_referencing_loader(self):\n-        class MyLoader(ItemLoader):\n-            url_out = TakeFirst()\n-\n-            def img_url_out(self, values):\n-                return (self.get_output_value('url') or '') + values[0]\n-\n-        il = MyLoader(item={})\n-        il.add_value('url', 'http://example.com/')\n-        il.add_value('img_url', '1234.png')\n-        self.assertEqual(il.load_item(), {\n-            'url': 'http://example.com/',\n-            'img_url': 'http://example.com/1234.png',\n-        })\n-\n-        il = MyLoader(item={})\n-        il.add_value('img_url', '1234.png')\n-        self.assertEqual(il.load_item(), {\n-            'img_url': '1234.png',\n-        })\n-\n-    def test_add_value(self):\n-        il = TestItemLoader()\n-        il.add_value('name', u'marta')\n-        self.assertEqual(il.get_collected_values('name'), [u'Marta'])\n-        self.assertEqual(il.get_output_value('name'), [u'Marta'])\n-        il.add_value('name', u'pepe')\n-        self.assertEqual(il.get_collected_values('name'), [u'Marta', u'Pepe'])\n-        self.assertEqual(il.get_output_value('name'), [u'Marta', u'Pepe'])\n-\n-        # test add object value\n-        il.add_value('summary', {'key': 1})\n-        self.assertEqual(il.get_collected_values('summary'), [{'key': 1}])\n-\n-        il.add_value(None, u'Jim', lambda x: {'name': x})\n-        self.assertEqual(il.get_collected_values('name'), [u'Marta', u'Pepe', u'Jim'])\n-\n-    def test_add_zero(self):\n-        il = NameItemLoader()\n-        il.add_value('name', 0)\n-        self.assertEqual(il.get_collected_values('name'), [0])\n-\n-    def test_replace_value(self):\n-        il = TestItemLoader()\n-        il.replace_value('name', u'marta')\n-        self.assertEqual(il.get_collected_values('name'), [u'Marta'])\n-        self.assertEqual(il.get_output_value('name'), [u'Marta'])\n-        il.replace_value('name', u'pepe')\n-        self.assertEqual(il.get_collected_values('name'), [u'Pepe'])\n-        self.assertEqual(il.get_output_value('name'), [u'Pepe'])\n-\n-        il.replace_value(None, u'Jim', lambda x: {'name': x})\n-        self.assertEqual(il.get_collected_values('name'), [u'Jim'])\n-\n-    def test_get_value(self):\n-        il = NameItemLoader()\n-        self.assertEqual(u'FOO', il.get_value([u'foo', u'bar'], TakeFirst(), str.upper))\n-        self.assertEqual([u'foo', u'bar'], il.get_value([u'name:foo', u'name:bar'], re=u'name:(.*)$'))\n-        self.assertEqual(u'foo', il.get_value([u'name:foo', u'name:bar'], TakeFirst(), re=u'name:(.*)$'))\n-\n-        il.add_value('name', [u'name:foo', u'name:bar'], TakeFirst(), re=u'name:(.*)$')\n-        self.assertEqual([u'foo'], il.get_collected_values('name'))\n-        il.replace_value('name', u'name:bar', re=u'name:(.*)$')\n-        self.assertEqual([u'bar'], il.get_collected_values('name'))\n-\n-    def test_iter_on_input_processor_input(self):\n-        class NameFirstItemLoader(NameItemLoader):\n-            name_in = TakeFirst()\n-\n-        il = NameFirstItemLoader()\n-        il.add_value('name', u'marta')\n-        self.assertEqual(il.get_collected_values('name'), [u'marta'])\n-        il = NameFirstItemLoader()\n-        il.add_value('name', [u'marta', u'jose'])\n-        self.assertEqual(il.get_collected_values('name'), [u'marta'])\n-\n-        il = NameFirstItemLoader()\n-        il.replace_value('name', u'marta')\n-        self.assertEqual(il.get_collected_values('name'), [u'marta'])\n-        il = NameFirstItemLoader()\n-        il.replace_value('name', [u'marta', u'jose'])\n-        self.assertEqual(il.get_collected_values('name'), [u'marta'])\n-\n-        il = NameFirstItemLoader()\n-        il.add_value('name', u'marta')\n-        il.add_value('name', [u'jose', u'pedro'])\n-        self.assertEqual(il.get_collected_values('name'), [u'marta', u'jose'])\n-\n-    def test_map_compose_filter(self):\n-        def filter_world(x):\n-            return None if x == 'world' else x\n-\n-        proc = MapCompose(filter_world, str.upper)\n-        self.assertEqual(proc(['hello', 'world', 'this', 'is', 'scrapy']),\n-                         ['HELLO', 'THIS', 'IS', 'SCRAPY'])\n-\n-    def test_map_compose_filter_multil(self):\n-        class TestItemLoader(NameItemLoader):\n-            name_in = MapCompose(lambda v: v.title(), lambda v: v[:-1])\n-\n-        il = TestItemLoader()\n-        il.add_value('name', u'marta')\n-        self.assertEqual(il.get_output_value('name'), [u'Mart'])\n-        item = il.load_item()\n-        self.assertEqual(item['name'], [u'Mart'])\n-\n-    def test_default_input_processor(self):\n-        il = DefaultedItemLoader()\n-        il.add_value('name', u'marta')\n-        self.assertEqual(il.get_output_value('name'), [u'mart'])\n-\n-    def test_inherited_default_input_processor(self):\n-        class InheritDefaultedItemLoader(DefaultedItemLoader):\n-            pass\n-\n-        il = InheritDefaultedItemLoader()\n-        il.add_value('name', u'marta')\n-        self.assertEqual(il.get_output_value('name'), [u'mart'])\n-\n-    def test_input_processor_inheritance(self):\n-        class ChildItemLoader(TestItemLoader):\n-            url_in = MapCompose(lambda v: v.lower())\n-\n-        il = ChildItemLoader()\n-        il.add_value('url', u'HTTP://scrapy.ORG')\n-        self.assertEqual(il.get_output_value('url'), [u'http://scrapy.org'])\n-        il.add_value('name', u'marta')\n-        self.assertEqual(il.get_output_value('name'), [u'Marta'])\n-\n-        class ChildChildItemLoader(ChildItemLoader):\n-            url_in = MapCompose(lambda v: v.upper())\n-            summary_in = MapCompose(lambda v: v)\n-\n-        il = ChildChildItemLoader()\n-        il.add_value('url', u'http://scrapy.org')\n-        self.assertEqual(il.get_output_value('url'), [u'HTTP://SCRAPY.ORG'])\n-        il.add_value('name', u'marta')\n-        self.assertEqual(il.get_output_value('name'), [u'Marta'])\n-\n-    def test_empty_map_compose(self):\n-        class IdentityDefaultedItemLoader(DefaultedItemLoader):\n-            name_in = MapCompose()\n-\n-        il = IdentityDefaultedItemLoader()\n-        il.add_value('name', u'marta')\n-        self.assertEqual(il.get_output_value('name'), [u'marta'])\n-\n-    def test_identity_input_processor(self):\n-        class IdentityDefaultedItemLoader(DefaultedItemLoader):\n-            name_in = Identity()\n-\n-        il = IdentityDefaultedItemLoader()\n-        il.add_value('name', u'marta')\n-        self.assertEqual(il.get_output_value('name'), [u'marta'])\n-\n-    def test_extend_custom_input_processors(self):\n-        class ChildItemLoader(TestItemLoader):\n-            name_in = MapCompose(TestItemLoader.name_in, str.swapcase)\n-\n-        il = ChildItemLoader()\n-        il.add_value('name', u'marta')\n-        self.assertEqual(il.get_output_value('name'), [u'mARTA'])\n-\n-    def test_extend_default_input_processors(self):\n-        class ChildDefaultedItemLoader(DefaultedItemLoader):\n-            name_in = MapCompose(DefaultedItemLoader.default_input_processor, str.swapcase)\n-\n-        il = ChildDefaultedItemLoader()\n-        il.add_value('name', u'marta')\n-        self.assertEqual(il.get_output_value('name'), [u'MART'])\n-\n-    def test_output_processor_using_function(self):\n-        il = TestItemLoader()\n-        il.add_value('name', [u'mar', u'ta'])\n-        self.assertEqual(il.get_output_value('name'), [u'Mar', u'Ta'])\n-\n-        class TakeFirstItemLoader(TestItemLoader):\n-            name_out = u\" \".join\n-\n-        il = TakeFirstItemLoader()\n-        il.add_value('name', [u'mar', u'ta'])\n-        self.assertEqual(il.get_output_value('name'), u'Mar Ta')\n-\n-    def test_output_processor_error(self):\n-        class TestItemLoader(ItemLoader):\n-            default_item_class = TestItem\n-            name_out = MapCompose(float)\n-\n-        il = TestItemLoader()\n-        il.add_value('name', [u'$10'])\n-        try:\n-            float(u'$10')\n-        except Exception as e:\n-            expected_exc_str = str(e)\n-\n-        exc = None\n-        try:\n-            il.load_item()\n-        except Exception as e:\n-            exc = e\n-        assert isinstance(exc, ValueError)\n-        s = str(exc)\n-        assert 'name' in s, s\n-        assert '$10' in s, s\n-        assert 'ValueError' in s, s\n-        assert expected_exc_str in s, s\n-\n-    def test_output_processor_using_classes(self):\n-        il = TestItemLoader()\n-        il.add_value('name', [u'mar', u'ta'])\n-        self.assertEqual(il.get_output_value('name'), [u'Mar', u'Ta'])\n-\n-        class TakeFirstItemLoader(TestItemLoader):\n-            name_out = Join()\n-\n-        il = TakeFirstItemLoader()\n-        il.add_value('name', [u'mar', u'ta'])\n-        self.assertEqual(il.get_output_value('name'), u'Mar Ta')\n-\n-        class TakeFirstItemLoader(TestItemLoader):\n-            name_out = Join(\"<br>\")\n-\n-        il = TakeFirstItemLoader()\n-        il.add_value('name', [u'mar', u'ta'])\n-        self.assertEqual(il.get_output_value('name'), u'Mar<br>Ta')\n-\n-    def test_default_output_processor(self):\n-        il = TestItemLoader()\n-        il.add_value('name', [u'mar', u'ta'])\n-        self.assertEqual(il.get_output_value('name'), [u'Mar', u'Ta'])\n-\n-        class LalaItemLoader(TestItemLoader):\n-            default_output_processor = Identity()\n-\n-        il = LalaItemLoader()\n-        il.add_value('name', [u'mar', u'ta'])\n-        self.assertEqual(il.get_output_value('name'), [u'Mar', u'Ta'])\n-\n-    def test_loader_context_on_declaration(self):\n-        class ChildItemLoader(TestItemLoader):\n-            url_in = MapCompose(processor_with_args, key=u'val')\n-\n-        il = ChildItemLoader()\n-        il.add_value('url', u'text')\n-        self.assertEqual(il.get_output_value('url'), ['val'])\n-        il.replace_value('url', u'text2')\n-        self.assertEqual(il.get_output_value('url'), ['val'])\n-\n-    def test_loader_context_on_instantiation(self):\n-        class ChildItemLoader(TestItemLoader):\n-            url_in = MapCompose(processor_with_args)\n-\n-        il = ChildItemLoader(key=u'val')\n-        il.add_value('url', u'text')\n-        self.assertEqual(il.get_output_value('url'), ['val'])\n-        il.replace_value('url', u'text2')\n-        self.assertEqual(il.get_output_value('url'), ['val'])\n-\n-    def test_loader_context_on_assign(self):\n-        class ChildItemLoader(TestItemLoader):\n-            url_in = MapCompose(processor_with_args)\n-\n-        il = ChildItemLoader()\n-        il.context['key'] = u'val'\n-        il.add_value('url', u'text')\n-        self.assertEqual(il.get_output_value('url'), ['val'])\n-        il.replace_value('url', u'text2')\n-        self.assertEqual(il.get_output_value('url'), ['val'])\n-\n-    def test_item_passed_to_input_processor_functions(self):\n-        def processor(value, loader_context):\n-            return loader_context['item']['name']\n-\n-        class ChildItemLoader(TestItemLoader):\n-            url_in = MapCompose(processor)\n-\n-        it = TestItem(name='marta')\n-        il = ChildItemLoader(item=it)\n-        il.add_value('url', u'text')\n-        self.assertEqual(il.get_output_value('url'), ['marta'])\n-        il.replace_value('url', u'text2')\n-        self.assertEqual(il.get_output_value('url'), ['marta'])\n-\n-    def test_add_value_on_unknown_field(self):\n-        il = TestItemLoader()\n-        self.assertRaises(KeyError, il.add_value, 'wrong_field', [u'lala', u'lolo'])\n-\n-    def test_compose_processor(self):\n-        class TestItemLoader(NameItemLoader):\n-            name_out = Compose(lambda v: v[0], lambda v: v.title(), lambda v: v[:-1])\n-\n-        il = TestItemLoader()\n-        il.add_value('name', [u'marta', u'other'])\n-        self.assertEqual(il.get_output_value('name'), u'Mart')\n-        item = il.load_item()\n-        self.assertEqual(item['name'], u'Mart')\n-\n-    def test_partial_processor(self):\n-        def join(values, sep=None, loader_context=None, ignored=None):\n-            if sep is not None:\n-                return sep.join(values)\n-            elif loader_context and 'sep' in loader_context:\n-                return loader_context['sep'].join(values)\n-            else:\n-                return ''.join(values)\n-\n-        class TestItemLoader(NameItemLoader):\n-            name_out = Compose(partial(join, sep='+'))\n-            url_out = Compose(partial(join, loader_context={'sep': '.'}))\n-            summary_out = Compose(partial(join, ignored='foo'))\n-\n-        il = TestItemLoader()\n-        il.add_value('name', [u'rabbit', u'hole'])\n-        il.add_value('url', [u'rabbit', u'hole'])\n-        il.add_value('summary', [u'rabbit', u'hole'])\n-        item = il.load_item()\n-        self.assertEqual(item['name'], u'rabbit+hole')\n-        self.assertEqual(item['url'], u'rabbit.hole')\n-        self.assertEqual(item['summary'], u'rabbithole')\n-\n-    def test_error_input_processor(self):\n-        class TestItem(Item):\n-            name = Field()\n-\n-        class TestItemLoader(ItemLoader):\n-            default_item_class = TestItem\n-            name_in = MapCompose(float)\n-\n-        il = TestItemLoader()\n-        self.assertRaises(ValueError, il.add_value, 'name',\n-                          [u'marta', u'other'])\n-\n-    def test_error_output_processor(self):\n-        class TestItem(Item):\n-            name = Field()\n-\n-        class TestItemLoader(ItemLoader):\n-            default_item_class = TestItem\n-            name_out = Compose(Join(), float)\n-\n-        il = TestItemLoader()\n-        il.add_value('name', u'marta')\n-        with self.assertRaises(ValueError):\n-            il.load_item()\n-\n-    def test_error_processor_as_argument(self):\n-        class TestItem(Item):\n-            name = Field()\n-\n-        class TestItemLoader(ItemLoader):\n-            default_item_class = TestItem\n-\n-        il = TestItemLoader()\n-        self.assertRaises(ValueError, il.add_value, 'name',\n-                          [u'marta', u'other'], Compose(float))\n-\n \n class InitializationTestMixin:\n \n@@ -587,41 +204,6 @@ class BaseNoInputReprocessingLoader(ItemLoader):\n     title_out = TakeFirst()\n \n \n-class NoInputReprocessingDictLoader(BaseNoInputReprocessingLoader):\n-    default_item_class = dict\n-\n-\n-class NoInputReprocessingFromDictTest(unittest.TestCase):\n-    \"\"\"\n-    Loaders initialized from loaded items must not reprocess fields (dict instances)\n-    \"\"\"\n-    def test_avoid_reprocessing_with_initial_values_single(self):\n-        il = NoInputReprocessingDictLoader(item=dict(title='foo'))\n-        il_loaded = il.load_item()\n-        self.assertEqual(il_loaded, dict(title='foo'))\n-        self.assertEqual(NoInputReprocessingDictLoader(item=il_loaded).load_item(), dict(title='foo'))\n-\n-    def test_avoid_reprocessing_with_initial_values_list(self):\n-        il = NoInputReprocessingDictLoader(item=dict(title=['foo', 'bar']))\n-        il_loaded = il.load_item()\n-        self.assertEqual(il_loaded, dict(title='foo'))\n-        self.assertEqual(NoInputReprocessingDictLoader(item=il_loaded).load_item(), dict(title='foo'))\n-\n-    def test_avoid_reprocessing_without_initial_values_single(self):\n-        il = NoInputReprocessingDictLoader()\n-        il.add_value('title', 'foo')\n-        il_loaded = il.load_item()\n-        self.assertEqual(il_loaded, dict(title='FOO'))\n-        self.assertEqual(NoInputReprocessingDictLoader(item=il_loaded).load_item(), dict(title='FOO'))\n-\n-    def test_avoid_reprocessing_without_initial_values_list(self):\n-        il = NoInputReprocessingDictLoader()\n-        il.add_value('title', ['foo', 'bar'])\n-        il_loaded = il.load_item()\n-        self.assertEqual(il_loaded, dict(title='FOO'))\n-        self.assertEqual(NoInputReprocessingDictLoader(item=il_loaded).load_item(), dict(title='FOO'))\n-\n-\n class NoInputReprocessingItem(Item):\n     title = Field()\n \n@@ -661,25 +243,6 @@ class NoInputReprocessingFromItemTest(unittest.TestCase):\n         self.assertEqual(NoInputReprocessingItemLoader(item=il_loaded).load_item(), {'title': 'FOO'})\n \n \n-class TestOutputProcessorDict(unittest.TestCase):\n-    def test_output_processor(self):\n-\n-        class TempDict(dict):\n-            def __init__(self, *args, **kwargs):\n-                super(TempDict, self).__init__(self, *args, **kwargs)\n-                self.setdefault('temp', 0.3)\n-\n-        class TempLoader(ItemLoader):\n-            default_item_class = TempDict\n-            default_input_processor = Identity()\n-            default_output_processor = Compose(TakeFirst())\n-\n-        loader = TempLoader()\n-        item = loader.load_item()\n-        self.assertIsInstance(item, TempDict)\n-        self.assertEqual(dict(item), {'temp': 0.3})\n-\n-\n class TestOutputProcessorItem(unittest.TestCase):\n     def test_output_processor(self):\n \n@@ -701,49 +264,6 @@ class TestOutputProcessorItem(unittest.TestCase):\n         self.assertEqual(dict(item), {'temp': 0.3})\n \n \n-class ProcessorsTest(unittest.TestCase):\n-\n-    def test_take_first(self):\n-        proc = TakeFirst()\n-        self.assertEqual(proc([None, '', 'hello', 'world']), 'hello')\n-        self.assertEqual(proc([None, '', 0, 'hello', 'world']), 0)\n-\n-    def test_identity(self):\n-        proc = Identity()\n-        self.assertEqual(proc([None, '', 'hello', 'world']),\n-                         [None, '', 'hello', 'world'])\n-\n-    def test_join(self):\n-        proc = Join()\n-        self.assertRaises(TypeError, proc, [None, '', 'hello', 'world'])\n-        self.assertEqual(proc(['', 'hello', 'world']), u' hello world')\n-        self.assertEqual(proc(['hello', 'world']), u'hello world')\n-        self.assertIsInstance(proc(['hello', 'world']), str)\n-\n-    def test_compose(self):\n-        proc = Compose(lambda v: v[0], str.upper)\n-        self.assertEqual(proc(['hello', 'world']), 'HELLO')\n-        proc = Compose(str.upper)\n-        self.assertEqual(proc(None), None)\n-        proc = Compose(str.upper, stop_on_none=False)\n-        self.assertRaises(ValueError, proc, None)\n-        proc = Compose(str.upper, lambda x: x + 1)\n-        self.assertRaises(ValueError, proc, 'hello')\n-\n-    def test_mapcompose(self):\n-        def filter_world(x):\n-            return None if x == 'world' else x\n-        proc = MapCompose(filter_world, str.upper)\n-        self.assertEqual(proc([u'hello', u'world', u'this', u'is', u'scrapy']),\n-                         [u'HELLO', u'THIS', u'IS', u'SCRAPY'])\n-        proc = MapCompose(filter_world, str.upper)\n-        self.assertEqual(proc(None), [])\n-        proc = MapCompose(filter_world, str.upper)\n-        self.assertRaises(ValueError, proc, [1])\n-        proc = MapCompose(filter_world, lambda x: x + 1)\n-        self.assertRaises(ValueError, proc, 'hello')\n-\n-\n class SelectortemLoaderTest(unittest.TestCase):\n     response = HtmlResponse(url=\"\", encoding='utf-8', body=b\"\"\"\n     <html>\n@@ -921,6 +441,7 @@ class SubselectorLoaderTest(unittest.TestCase):\n \n     def test_nested_xpath(self):\n         l = NestedItemLoader(response=self.response)\n+\n         nl = l.nested_xpath(\"//header\")\n         nl.add_xpath('name', 'div/text()')\n         nl.add_css('name_div', '#id')\n@@ -998,31 +519,6 @@ class SubselectorLoaderTest(unittest.TestCase):\n         self.assertEqual(item['image'], [u'/images/logo.png'])\n \n \n-class SelectJmesTestCase(unittest.TestCase):\n-    test_list_equals = {\n-        'simple': ('foo.bar', {\"foo\": {\"bar\": \"baz\"}}, \"baz\"),\n-        'invalid': ('foo.bar.baz', {\"foo\": {\"bar\": \"baz\"}}, None),\n-        'top_level': ('foo', {\"foo\": {\"bar\": \"baz\"}}, {\"bar\": \"baz\"}),\n-        'double_vs_single_quote_string': ('foo.bar', {\"foo\": {\"bar\": \"baz\"}}, \"baz\"),\n-        'dict': (\n-            'foo.bar[*].name',\n-            {\"foo\": {\"bar\": [{\"name\": \"one\"}, {\"name\": \"two\"}]}},\n-            ['one', 'two']\n-        ),\n-        'list': ('[1]', [1, 2], 2)\n-    }\n-\n-    def test_output(self):\n-        for l in self.test_list_equals:\n-            expr, test_list, expected = self.test_list_equals[l]\n-            test = SelectJmes(expr)(test_list)\n-            self.assertEqual(\n-                test,\n-                expected,\n-                msg='test \"{}\" got {} expected {}'.format(l, test, expected)\n-            )\n-\n-\n # Functions as processors\n \n def function_processor_strip(iterable):\n@@ -1044,12 +540,6 @@ class FunctionProcessorItemLoader(ItemLoader):\n     default_item_class = FunctionProcessorItem\n \n \n-class FunctionProcessorDictLoader(ItemLoader):\n-    default_item_class = dict\n-    foo_in = function_processor_strip\n-    foo_out = function_processor_upper\n-\n-\n class FunctionProcessorTestCase(unittest.TestCase):\n \n     def test_processor_defined_in_item(self):\n@@ -1061,15 +551,6 @@ class FunctionProcessorTestCase(unittest.TestCase):\n             {'foo': ['BAR', 'ASDF', 'QWERTY']}\n         )\n \n-    def test_processor_defined_in_item_loader(self):\n-        lo = FunctionProcessorDictLoader()\n-        lo.add_value('foo', '  bar  ')\n-        lo.add_value('foo', ['  asdf  ', '  qwerty  '])\n-        self.assertEqual(\n-            dict(lo.load_item()),\n-            {'foo': ['BAR', 'ASDF', 'QWERTY']}\n-        )\n-\n \n if __name__ == \"__main__\":\n     unittest.main()\n\n@@ -0,0 +1,720 @@\n+\"\"\"\n+These tests are kept as references from the ones that were ported to a itemloaders library.\n+Once we remove the references from scrapy, we can remove these tests.\n+\"\"\"\n+\n+import unittest\n+import warnings\n+from functools import partial\n+\n+from itemloaders.processors import (Compose, Identity, Join,\n+                                    MapCompose, SelectJmes, TakeFirst)\n+\n+from scrapy.item import Item, Field\n+from scrapy.loader import ItemLoader\n+from scrapy.loader.common import wrap_loader_context\n+from scrapy.utils.deprecate import ScrapyDeprecationWarning\n+from scrapy.utils.misc import extract_regex\n+\n+\n+# test items\n+class NameItem(Item):\n+    name = Field()\n+\n+\n+class TestItem(NameItem):\n+    url = Field()\n+    summary = Field()\n+\n+\n+# test item loaders\n+class NameItemLoader(ItemLoader):\n+    default_item_class = TestItem\n+\n+\n+class TestItemLoader(NameItemLoader):\n+    name_in = MapCompose(lambda v: v.title())\n+\n+\n+class DefaultedItemLoader(NameItemLoader):\n+    default_input_processor = MapCompose(lambda v: v[:-1])\n+\n+\n+# test processors\n+def processor_with_args(value, other=None, loader_context=None):\n+    if 'key' in loader_context:\n+        return loader_context['key']\n+    return value\n+\n+\n+class BasicItemLoaderTest(unittest.TestCase):\n+\n+    def test_load_item_using_default_loader(self):\n+        i = TestItem()\n+        i['summary'] = u'lala'\n+        il = ItemLoader(item=i)\n+        il.add_value('name', u'marta')\n+        item = il.load_item()\n+        assert item is i\n+        self.assertEqual(item['summary'], [u'lala'])\n+        self.assertEqual(item['name'], [u'marta'])\n+\n+    def test_load_item_using_custom_loader(self):\n+        il = TestItemLoader()\n+        il.add_value('name', u'marta')\n+        item = il.load_item()\n+        self.assertEqual(item['name'], [u'Marta'])\n+\n+    def test_load_item_ignore_none_field_values(self):\n+        def validate_sku(value):\n+            # Let's assume a SKU is only digits.\n+            if value.isdigit():\n+                return value\n+\n+        class MyLoader(ItemLoader):\n+            name_out = Compose(lambda vs: vs[0])  # take first which allows empty values\n+            price_out = Compose(TakeFirst(), float)\n+            sku_out = Compose(TakeFirst(), validate_sku)\n+\n+        valid_fragment = u'SKU: 1234'\n+        invalid_fragment = u'SKU: not available'\n+        sku_re = 'SKU: (.+)'\n+\n+        il = MyLoader(item={})\n+        # Should not return \"sku: None\".\n+        il.add_value('sku', [invalid_fragment], re=sku_re)\n+        # Should not ignore empty values.\n+        il.add_value('name', u'')\n+        il.add_value('price', [u'0'])\n+        self.assertEqual(il.load_item(), {\n+            'name': u'',\n+            'price': 0.0,\n+        })\n+\n+        il.replace_value('sku', [valid_fragment], re=sku_re)\n+        self.assertEqual(il.load_item()['sku'], u'1234')\n+\n+    def test_self_referencing_loader(self):\n+        class MyLoader(ItemLoader):\n+            url_out = TakeFirst()\n+\n+            def img_url_out(self, values):\n+                return (self.get_output_value('url') or '') + values[0]\n+\n+        il = MyLoader(item={})\n+        il.add_value('url', 'http://example.com/')\n+        il.add_value('img_url', '1234.png')\n+        self.assertEqual(il.load_item(), {\n+            'url': 'http://example.com/',\n+            'img_url': 'http://example.com/1234.png',\n+        })\n+\n+        il = MyLoader(item={})\n+        il.add_value('img_url', '1234.png')\n+        self.assertEqual(il.load_item(), {\n+            'img_url': '1234.png',\n+        })\n+\n+    def test_add_value(self):\n+        il = TestItemLoader()\n+        il.add_value('name', u'marta')\n+        self.assertEqual(il.get_collected_values('name'), [u'Marta'])\n+        self.assertEqual(il.get_output_value('name'), [u'Marta'])\n+        il.add_value('name', u'pepe')\n+        self.assertEqual(il.get_collected_values('name'), [u'Marta', u'Pepe'])\n+        self.assertEqual(il.get_output_value('name'), [u'Marta', u'Pepe'])\n+\n+        # test add object value\n+        il.add_value('summary', {'key': 1})\n+        self.assertEqual(il.get_collected_values('summary'), [{'key': 1}])\n+\n+        il.add_value(None, u'Jim', lambda x: {'name': x})\n+        self.assertEqual(il.get_collected_values('name'), [u'Marta', u'Pepe', u'Jim'])\n+\n+    def test_add_zero(self):\n+        il = NameItemLoader()\n+        il.add_value('name', 0)\n+        self.assertEqual(il.get_collected_values('name'), [0])\n+\n+    def test_replace_value(self):\n+        il = TestItemLoader()\n+        il.replace_value('name', u'marta')\n+        self.assertEqual(il.get_collected_values('name'), [u'Marta'])\n+        self.assertEqual(il.get_output_value('name'), [u'Marta'])\n+        il.replace_value('name', u'pepe')\n+        self.assertEqual(il.get_collected_values('name'), [u'Pepe'])\n+        self.assertEqual(il.get_output_value('name'), [u'Pepe'])\n+\n+        il.replace_value(None, u'Jim', lambda x: {'name': x})\n+        self.assertEqual(il.get_collected_values('name'), [u'Jim'])\n+\n+    def test_get_value(self):\n+        il = NameItemLoader()\n+        self.assertEqual(u'FOO', il.get_value([u'foo', u'bar'], TakeFirst(), str.upper))\n+        self.assertEqual([u'foo', u'bar'], il.get_value([u'name:foo', u'name:bar'], re=u'name:(.*)$'))\n+        self.assertEqual(u'foo', il.get_value([u'name:foo', u'name:bar'], TakeFirst(), re=u'name:(.*)$'))\n+\n+        il.add_value('name', [u'name:foo', u'name:bar'], TakeFirst(), re=u'name:(.*)$')\n+        self.assertEqual([u'foo'], il.get_collected_values('name'))\n+        il.replace_value('name', u'name:bar', re=u'name:(.*)$')\n+        self.assertEqual([u'bar'], il.get_collected_values('name'))\n+\n+    def test_iter_on_input_processor_input(self):\n+        class NameFirstItemLoader(NameItemLoader):\n+            name_in = TakeFirst()\n+\n+        il = NameFirstItemLoader()\n+        il.add_value('name', u'marta')\n+        self.assertEqual(il.get_collected_values('name'), [u'marta'])\n+        il = NameFirstItemLoader()\n+        il.add_value('name', [u'marta', u'jose'])\n+        self.assertEqual(il.get_collected_values('name'), [u'marta'])\n+\n+        il = NameFirstItemLoader()\n+        il.replace_value('name', u'marta')\n+        self.assertEqual(il.get_collected_values('name'), [u'marta'])\n+        il = NameFirstItemLoader()\n+        il.replace_value('name', [u'marta', u'jose'])\n+        self.assertEqual(il.get_collected_values('name'), [u'marta'])\n+\n+        il = NameFirstItemLoader()\n+        il.add_value('name', u'marta')\n+        il.add_value('name', [u'jose', u'pedro'])\n+        self.assertEqual(il.get_collected_values('name'), [u'marta', u'jose'])\n+\n+    def test_map_compose_filter(self):\n+        def filter_world(x):\n+            return None if x == 'world' else x\n+\n+        proc = MapCompose(filter_world, str.upper)\n+        self.assertEqual(proc(['hello', 'world', 'this', 'is', 'scrapy']),\n+                         ['HELLO', 'THIS', 'IS', 'SCRAPY'])\n+\n+    def test_map_compose_filter_multil(self):\n+        class TestItemLoader(NameItemLoader):\n+            name_in = MapCompose(lambda v: v.title(), lambda v: v[:-1])\n+\n+        il = TestItemLoader()\n+        il.add_value('name', u'marta')\n+        self.assertEqual(il.get_output_value('name'), [u'Mart'])\n+        item = il.load_item()\n+        self.assertEqual(item['name'], [u'Mart'])\n+\n+    def test_default_input_processor(self):\n+        il = DefaultedItemLoader()\n+        il.add_value('name', u'marta')\n+        self.assertEqual(il.get_output_value('name'), [u'mart'])\n+\n+    def test_inherited_default_input_processor(self):\n+        class InheritDefaultedItemLoader(DefaultedItemLoader):\n+            pass\n+\n+        il = InheritDefaultedItemLoader()\n+        il.add_value('name', u'marta')\n+        self.assertEqual(il.get_output_value('name'), [u'mart'])\n+\n+    def test_input_processor_inheritance(self):\n+        class ChildItemLoader(TestItemLoader):\n+            url_in = MapCompose(lambda v: v.lower())\n+\n+        il = ChildItemLoader()\n+        il.add_value('url', u'HTTP://scrapy.ORG')\n+        self.assertEqual(il.get_output_value('url'), [u'http://scrapy.org'])\n+        il.add_value('name', u'marta')\n+        self.assertEqual(il.get_output_value('name'), [u'Marta'])\n+\n+        class ChildChildItemLoader(ChildItemLoader):\n+            url_in = MapCompose(lambda v: v.upper())\n+            summary_in = MapCompose(lambda v: v)\n+\n+        il = ChildChildItemLoader()\n+        il.add_value('url', u'http://scrapy.org')\n+        self.assertEqual(il.get_output_value('url'), [u'HTTP://SCRAPY.ORG'])\n+        il.add_value('name', u'marta')\n+        self.assertEqual(il.get_output_value('name'), [u'Marta'])\n+\n+    def test_empty_map_compose(self):\n+        class IdentityDefaultedItemLoader(DefaultedItemLoader):\n+            name_in = MapCompose()\n+\n+        il = IdentityDefaultedItemLoader()\n+        il.add_value('name', u'marta')\n+        self.assertEqual(il.get_output_value('name'), [u'marta'])\n+\n+    def test_identity_input_processor(self):\n+        class IdentityDefaultedItemLoader(DefaultedItemLoader):\n+            name_in = Identity()\n+\n+        il = IdentityDefaultedItemLoader()\n+        il.add_value('name', u'marta')\n+        self.assertEqual(il.get_output_value('name'), [u'marta'])\n+\n+    def test_extend_custom_input_processors(self):\n+        class ChildItemLoader(TestItemLoader):\n+            name_in = MapCompose(TestItemLoader.name_in, str.swapcase)\n+\n+        il = ChildItemLoader()\n+        il.add_value('name', u'marta')\n+        self.assertEqual(il.get_output_value('name'), [u'mARTA'])\n+\n+    def test_extend_default_input_processors(self):\n+        class ChildDefaultedItemLoader(DefaultedItemLoader):\n+            name_in = MapCompose(DefaultedItemLoader.default_input_processor, str.swapcase)\n+\n+        il = ChildDefaultedItemLoader()\n+        il.add_value('name', u'marta')\n+        self.assertEqual(il.get_output_value('name'), [u'MART'])\n+\n+    def test_output_processor_using_function(self):\n+        il = TestItemLoader()\n+        il.add_value('name', [u'mar', u'ta'])\n+        self.assertEqual(il.get_output_value('name'), [u'Mar', u'Ta'])\n+\n+        class TakeFirstItemLoader(TestItemLoader):\n+            name_out = u\" \".join\n+\n+        il = TakeFirstItemLoader()\n+        il.add_value('name', [u'mar', u'ta'])\n+        self.assertEqual(il.get_output_value('name'), u'Mar Ta')\n+\n+    def test_output_processor_error(self):\n+        class TestItemLoader(ItemLoader):\n+            default_item_class = TestItem\n+            name_out = MapCompose(float)\n+\n+        il = TestItemLoader()\n+        il.add_value('name', [u'$10'])\n+        try:\n+            float(u'$10')\n+        except Exception as e:\n+            expected_exc_str = str(e)\n+\n+        exc = None\n+        try:\n+            il.load_item()\n+        except Exception as e:\n+            exc = e\n+        assert isinstance(exc, ValueError)\n+        s = str(exc)\n+        assert 'name' in s, s\n+        assert '$10' in s, s\n+        assert 'ValueError' in s, s\n+        assert expected_exc_str in s, s\n+\n+    def test_output_processor_using_classes(self):\n+        il = TestItemLoader()\n+        il.add_value('name', [u'mar', u'ta'])\n+        self.assertEqual(il.get_output_value('name'), [u'Mar', u'Ta'])\n+\n+        class TakeFirstItemLoader(TestItemLoader):\n+            name_out = Join()\n+\n+        il = TakeFirstItemLoader()\n+        il.add_value('name', [u'mar', u'ta'])\n+        self.assertEqual(il.get_output_value('name'), u'Mar Ta')\n+\n+        class TakeFirstItemLoader(TestItemLoader):\n+            name_out = Join(\"<br>\")\n+\n+        il = TakeFirstItemLoader()\n+        il.add_value('name', [u'mar', u'ta'])\n+        self.assertEqual(il.get_output_value('name'), u'Mar<br>Ta')\n+\n+    def test_default_output_processor(self):\n+        il = TestItemLoader()\n+        il.add_value('name', [u'mar', u'ta'])\n+        self.assertEqual(il.get_output_value('name'), [u'Mar', u'Ta'])\n+\n+        class LalaItemLoader(TestItemLoader):\n+            default_output_processor = Identity()\n+\n+        il = LalaItemLoader()\n+        il.add_value('name', [u'mar', u'ta'])\n+        self.assertEqual(il.get_output_value('name'), [u'Mar', u'Ta'])\n+\n+    def test_loader_context_on_declaration(self):\n+        class ChildItemLoader(TestItemLoader):\n+            url_in = MapCompose(processor_with_args, key=u'val')\n+\n+        il = ChildItemLoader()\n+        il.add_value('url', u'text')\n+        self.assertEqual(il.get_output_value('url'), ['val'])\n+        il.replace_value('url', u'text2')\n+        self.assertEqual(il.get_output_value('url'), ['val'])\n+\n+    def test_loader_context_on_instantiation(self):\n+        class ChildItemLoader(TestItemLoader):\n+            url_in = MapCompose(processor_with_args)\n+\n+        il = ChildItemLoader(key=u'val')\n+        il.add_value('url', u'text')\n+        self.assertEqual(il.get_output_value('url'), ['val'])\n+        il.replace_value('url', u'text2')\n+        self.assertEqual(il.get_output_value('url'), ['val'])\n+\n+    def test_loader_context_on_assign(self):\n+        class ChildItemLoader(TestItemLoader):\n+            url_in = MapCompose(processor_with_args)\n+\n+        il = ChildItemLoader()\n+        il.context['key'] = u'val'\n+        il.add_value('url', u'text')\n+        self.assertEqual(il.get_output_value('url'), ['val'])\n+        il.replace_value('url', u'text2')\n+        self.assertEqual(il.get_output_value('url'), ['val'])\n+\n+    def test_item_passed_to_input_processor_functions(self):\n+        def processor(value, loader_context):\n+            return loader_context['item']['name']\n+\n+        class ChildItemLoader(TestItemLoader):\n+            url_in = MapCompose(processor)\n+\n+        it = TestItem(name='marta')\n+        il = ChildItemLoader(item=it)\n+        il.add_value('url', u'text')\n+        self.assertEqual(il.get_output_value('url'), ['marta'])\n+        il.replace_value('url', u'text2')\n+        self.assertEqual(il.get_output_value('url'), ['marta'])\n+\n+    def test_compose_processor(self):\n+        class TestItemLoader(NameItemLoader):\n+            name_out = Compose(lambda v: v[0], lambda v: v.title(), lambda v: v[:-1])\n+\n+        il = TestItemLoader()\n+        il.add_value('name', [u'marta', u'other'])\n+        self.assertEqual(il.get_output_value('name'), u'Mart')\n+        item = il.load_item()\n+        self.assertEqual(item['name'], u'Mart')\n+\n+    def test_partial_processor(self):\n+        def join(values, sep=None, loader_context=None, ignored=None):\n+            if sep is not None:\n+                return sep.join(values)\n+            elif loader_context and 'sep' in loader_context:\n+                return loader_context['sep'].join(values)\n+            else:\n+                return ''.join(values)\n+\n+        class TestItemLoader(NameItemLoader):\n+            name_out = Compose(partial(join, sep='+'))\n+            url_out = Compose(partial(join, loader_context={'sep': '.'}))\n+            summary_out = Compose(partial(join, ignored='foo'))\n+\n+        il = TestItemLoader()\n+        il.add_value('name', [u'rabbit', u'hole'])\n+        il.add_value('url', [u'rabbit', u'hole'])\n+        il.add_value('summary', [u'rabbit', u'hole'])\n+        item = il.load_item()\n+        self.assertEqual(item['name'], u'rabbit+hole')\n+        self.assertEqual(item['url'], u'rabbit.hole')\n+        self.assertEqual(item['summary'], u'rabbithole')\n+\n+    def test_error_input_processor(self):\n+        class TestItem(Item):\n+            name = Field()\n+\n+        class TestItemLoader(ItemLoader):\n+            default_item_class = TestItem\n+            name_in = MapCompose(float)\n+\n+        il = TestItemLoader()\n+        self.assertRaises(ValueError, il.add_value, 'name',\n+                          [u'marta', u'other'])\n+\n+    def test_error_output_processor(self):\n+        class TestItem(Item):\n+            name = Field()\n+\n+        class TestItemLoader(ItemLoader):\n+            default_item_class = TestItem\n+            name_out = Compose(Join(), float)\n+\n+        il = TestItemLoader()\n+        il.add_value('name', u'marta')\n+        with self.assertRaises(ValueError):\n+            il.load_item()\n+\n+    def test_error_processor_as_argument(self):\n+        class TestItem(Item):\n+            name = Field()\n+\n+        class TestItemLoader(ItemLoader):\n+            default_item_class = TestItem\n+\n+        il = TestItemLoader()\n+        self.assertRaises(ValueError, il.add_value, 'name',\n+                          [u'marta', u'other'], Compose(float))\n+\n+\n+class InitializationFromDictTest(unittest.TestCase):\n+\n+    item_class = dict\n+\n+    def test_keep_single_value(self):\n+        \"\"\"Loaded item should contain values from the initial item\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo']})\n+\n+    def test_keep_list(self):\n+        \"\"\"Loaded item should contain values from the initial item\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'bar']})\n+\n+    def test_add_value_singlevalue_singlevalue(self):\n+        \"\"\"Values added after initialization should be appended\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        il.add_value('name', 'bar')\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'bar']})\n+\n+    def test_add_value_singlevalue_list(self):\n+        \"\"\"Values added after initialization should be appended\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        il.add_value('name', ['item', 'loader'])\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'item', 'loader']})\n+\n+    def test_add_value_list_singlevalue(self):\n+        \"\"\"Values added after initialization should be appended\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        il.add_value('name', 'qwerty')\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'bar', 'qwerty']})\n+\n+    def test_add_value_list_list(self):\n+        \"\"\"Values added after initialization should be appended\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        il.add_value('name', ['item', 'loader'])\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'bar', 'item', 'loader']})\n+\n+    def test_get_output_value_singlevalue(self):\n+        \"\"\"Getting output value must not remove value from item\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        self.assertEqual(il.get_output_value('name'), ['foo'])\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(loaded_item, dict({'name': ['foo']}))\n+\n+    def test_get_output_value_list(self):\n+        \"\"\"Getting output value must not remove value from item\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        self.assertEqual(il.get_output_value('name'), ['foo', 'bar'])\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(loaded_item, dict({'name': ['foo', 'bar']}))\n+\n+    def test_values_single(self):\n+        \"\"\"Values from initial item must be added to loader._values\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        self.assertEqual(il._values.get('name'), ['foo'])\n+\n+    def test_values_list(self):\n+        \"\"\"Values from initial item must be added to loader._values\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        self.assertEqual(il._values.get('name'), ['foo', 'bar'])\n+\n+\n+class BaseNoInputReprocessingLoader(ItemLoader):\n+    title_in = MapCompose(str.upper)\n+    title_out = TakeFirst()\n+\n+\n+class NoInputReprocessingDictLoader(BaseNoInputReprocessingLoader):\n+    default_item_class = dict\n+\n+\n+class NoInputReprocessingFromDictTest(unittest.TestCase):\n+    \"\"\"\n+    Loaders initialized from loaded items must not reprocess fields (dict instances)\n+    \"\"\"\n+    def test_avoid_reprocessing_with_initial_values_single(self):\n+        il = NoInputReprocessingDictLoader(item=dict(title='foo'))\n+        il_loaded = il.load_item()\n+        self.assertEqual(il_loaded, dict(title='foo'))\n+        self.assertEqual(NoInputReprocessingDictLoader(item=il_loaded).load_item(), dict(title='foo'))\n+\n+    def test_avoid_reprocessing_with_initial_values_list(self):\n+        il = NoInputReprocessingDictLoader(item=dict(title=['foo', 'bar']))\n+        il_loaded = il.load_item()\n+        self.assertEqual(il_loaded, dict(title='foo'))\n+        self.assertEqual(NoInputReprocessingDictLoader(item=il_loaded).load_item(), dict(title='foo'))\n+\n+    def test_avoid_reprocessing_without_initial_values_single(self):\n+        il = NoInputReprocessingDictLoader()\n+        il.add_value('title', 'foo')\n+        il_loaded = il.load_item()\n+        self.assertEqual(il_loaded, dict(title='FOO'))\n+        self.assertEqual(NoInputReprocessingDictLoader(item=il_loaded).load_item(), dict(title='FOO'))\n+\n+    def test_avoid_reprocessing_without_initial_values_list(self):\n+        il = NoInputReprocessingDictLoader()\n+        il.add_value('title', ['foo', 'bar'])\n+        il_loaded = il.load_item()\n+        self.assertEqual(il_loaded, dict(title='FOO'))\n+        self.assertEqual(NoInputReprocessingDictLoader(item=il_loaded).load_item(), dict(title='FOO'))\n+\n+\n+class TestOutputProcessorDict(unittest.TestCase):\n+    def test_output_processor(self):\n+\n+        class TempDict(dict):\n+            def __init__(self, *args, **kwargs):\n+                super(TempDict, self).__init__(self, *args, **kwargs)\n+                self.setdefault('temp', 0.3)\n+\n+        class TempLoader(ItemLoader):\n+            default_item_class = TempDict\n+            default_input_processor = Identity()\n+            default_output_processor = Compose(TakeFirst())\n+\n+        loader = TempLoader()\n+        item = loader.load_item()\n+        self.assertIsInstance(item, TempDict)\n+        self.assertEqual(dict(item), {'temp': 0.3})\n+\n+\n+class ProcessorsTest(unittest.TestCase):\n+\n+    def test_take_first(self):\n+        proc = TakeFirst()\n+        self.assertEqual(proc([None, '', 'hello', 'world']), 'hello')\n+        self.assertEqual(proc([None, '', 0, 'hello', 'world']), 0)\n+\n+    def test_identity(self):\n+        proc = Identity()\n+        self.assertEqual(proc([None, '', 'hello', 'world']),\n+                         [None, '', 'hello', 'world'])\n+\n+    def test_join(self):\n+        proc = Join()\n+        self.assertRaises(TypeError, proc, [None, '', 'hello', 'world'])\n+        self.assertEqual(proc(['', 'hello', 'world']), u' hello world')\n+        self.assertEqual(proc(['hello', 'world']), u'hello world')\n+        self.assertIsInstance(proc(['hello', 'world']), str)\n+\n+    def test_compose(self):\n+        proc = Compose(lambda v: v[0], str.upper)\n+        self.assertEqual(proc(['hello', 'world']), 'HELLO')\n+        proc = Compose(str.upper)\n+        self.assertEqual(proc(None), None)\n+        proc = Compose(str.upper, stop_on_none=False)\n+        self.assertRaises(ValueError, proc, None)\n+        proc = Compose(str.upper, lambda x: x + 1)\n+        self.assertRaises(ValueError, proc, 'hello')\n+\n+    def test_mapcompose(self):\n+        def filter_world(x):\n+            return None if x == 'world' else x\n+        proc = MapCompose(filter_world, str.upper)\n+        self.assertEqual(proc([u'hello', u'world', u'this', u'is', u'scrapy']),\n+                         [u'HELLO', u'THIS', u'IS', u'SCRAPY'])\n+        proc = MapCompose(filter_world, str.upper)\n+        self.assertEqual(proc(None), [])\n+        proc = MapCompose(filter_world, str.upper)\n+        self.assertRaises(ValueError, proc, [1])\n+        proc = MapCompose(filter_world, lambda x: x + 1)\n+        self.assertRaises(ValueError, proc, 'hello')\n+\n+\n+class SelectJmesTestCase(unittest.TestCase):\n+    test_list_equals = {\n+        'simple': ('foo.bar', {\"foo\": {\"bar\": \"baz\"}}, \"baz\"),\n+        'invalid': ('foo.bar.baz', {\"foo\": {\"bar\": \"baz\"}}, None),\n+        'top_level': ('foo', {\"foo\": {\"bar\": \"baz\"}}, {\"bar\": \"baz\"}),\n+        'double_vs_single_quote_string': ('foo.bar', {\"foo\": {\"bar\": \"baz\"}}, \"baz\"),\n+        'dict': (\n+            'foo.bar[*].name',\n+            {\"foo\": {\"bar\": [{\"name\": \"one\"}, {\"name\": \"two\"}]}},\n+            ['one', 'two']\n+        ),\n+        'list': ('[1]', [1, 2], 2)\n+    }\n+\n+    def test_output(self):\n+        for tl in self.test_list_equals:\n+            expr, test_list, expected = self.test_list_equals[tl]\n+            test = SelectJmes(expr)(test_list)\n+            self.assertEqual(\n+                test,\n+                expected,\n+                msg='test \"{}\" got {} expected {}'.format(tl, test, expected)\n+            )\n+\n+\n+# Functions as processors\n+\n+def function_processor_strip(iterable):\n+    return [x.strip() for x in iterable]\n+\n+\n+def function_processor_upper(iterable):\n+    return [x.upper() for x in iterable]\n+\n+\n+class FunctionProcessorItem(Item):\n+    foo = Field(\n+        input_processor=function_processor_strip,\n+        output_processor=function_processor_upper,\n+    )\n+\n+\n+class FunctionProcessorDictLoader(ItemLoader):\n+    default_item_class = dict\n+    foo_in = function_processor_strip\n+    foo_out = function_processor_upper\n+\n+\n+class FunctionProcessorTestCase(unittest.TestCase):\n+\n+    def test_processor_defined_in_item_loader(self):\n+        lo = FunctionProcessorDictLoader()\n+        lo.add_value('foo', '  bar  ')\n+        lo.add_value('foo', ['  asdf  ', '  qwerty  '])\n+        self.assertEqual(\n+            dict(lo.load_item()),\n+            {'foo': ['BAR', 'ASDF', 'QWERTY']}\n+        )\n+\n+\n+class DeprecatedUtilityFunctionsTestCase(unittest.TestCase):\n+\n+    def test_deprecated_wrap_loader_context(self):\n+        def function(*args):\n+            return None\n+\n+        with warnings.catch_warnings(record=True) as w:\n+            wrap_loader_context(function, context=dict())\n+\n+            assert len(w) == 1\n+            assert issubclass(w[0].category, ScrapyDeprecationWarning)\n+\n+    def test_deprecated_extract_regex(self):\n+        with warnings.catch_warnings(record=True) as w:\n+            extract_regex(r'\\w+', 'this is a test')\n+\n+            assert len(w) == 1\n+            assert issubclass(w[0].category, ScrapyDeprecationWarning)\n+\n+\n+if __name__ == \"__main__\":\n+    unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
