{"custom_id": "keras#b1e47f7741cf526cb3381c4944f20582f368ba27", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 1059 | Contributors (this commit): 7 | Commits (past 90d): 12 | Contributors (cumulative): 7 | DMM Complexity: None\n\nDIFF:\n@@ -47,7 +47,6 @@ def test_merge():\n         actual_output_shape = model.predict(inputs).shape\n         assert expected_output_shape == actual_output_shape\n \n-\n     # test lambda with output_shape lambda\n     input_a = Input(shape=input_shapes[0][1:])\n     input_b = Input(shape=input_shapes[1][1:])\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#a7156b8c2776dd4d50530cc01ac76cc0039c9447", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 146 | Contributors (this commit): 3 | Commits (past 90d): 4 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -2,7 +2,7 @@\n \n We build a custom activation layer called 'Antirectifier',\n which modifies the shape of the tensor that passes through it.\n-We need to specify two methods: `output_shape` and `get_output`.\n+We need to specify two methods: `get_output_shape_for` and `call`.\n \n Note that the same result can also be achieved via a Lambda layer.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#7f93747602352758fb7df7be451c2cb69d8e7dad", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 7 | Churn Cumulative: 1712 | Contributors (this commit): 21 | Commits (past 90d): 37 | Contributors (cumulative): 21 | DMM Complexity: None\n\nDIFF:\n@@ -1021,10 +1021,3 @@ def random_binomial(shape, p=0.0, dtype=_FLOATX, seed=None):\n         seed = np.random.randint(10e6)\n     rng = RandomStreams(seed=seed)\n     return rng.binomial(shape, p=p, dtype=dtype)\n-\n-'''\n-more TODO:\n-\n-tensordot -> soon to be introduced in TF\n-batched_tensordot -> reimplement\n-'''\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#00e9d5b21979002558f27d070720b822e7d7a6ce", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 6 | Churn Cumulative: 24 | Contributors (this commit): 2 | Commits (past 90d): 3 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -22,6 +22,8 @@ high_weight = 5\n max_train_samples = 5000\n max_test_samples = 1000\n \n+\n+def get_data():\n     # the data, shuffled and split between tran and test sets\n     (X_train, y_train), (X_test, y_test) = mnist.load_data()\n     X_train = X_train.reshape(60000, 784)[:max_train_samples]\n@@ -36,6 +38,8 @@ Y_train = np_utils.to_categorical(y_train, nb_classes)\n     Y_test = np_utils.to_categorical(y_test, nb_classes)\n     test_ids = np.where(y_test == np.array(weighted_class))[0]\n \n+    return (X_train, Y_train), (X_test, Y_test), test_ids\n+\n \n def create_model(weight_reg=None, activity_reg=None):\n     model = Sequential()\n@@ -48,6 +52,7 @@ def create_model(weight_reg=None, activity_reg=None):\n \n \n def test_W_reg():\n+    (X_train, Y_train), (X_test, Y_test), test_ids = get_data()\n     for reg in [regularizers.l1(),\n                 regularizers.l2(),\n                 regularizers.l1l2()]:\n@@ -59,6 +64,7 @@ def test_W_reg():\n \n \n def test_A_reg():\n+    (X_train, Y_train), (X_test, Y_test), test_ids = get_data()\n     for reg in [regularizers.activity_l1(), regularizers.activity_l2()]:\n         model = create_model(activity_reg=reg)\n         model.compile(loss='categorical_crossentropy', optimizer='rmsprop')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#1f4084870bb81e939ac5e0c646f0dd6f0cae19d9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 109 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 3 | Methods Changed: 14 | Complexity Δ (Sum/Max): 15/11 | Churn Δ: 110 | Churn Cumulative: 130 | Contributors (this commit): 3 | Commits (past 90d): 5 | Contributors (cumulative): 4 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,3 +1,4 @@\n+import numpy as np\n from . import backend as K\n \n \n@@ -12,7 +13,70 @@ def categorical_accuracy(y_true, y_pred):\n \n def sparse_categorical_accuracy(y_true, y_pred):\n     return K.mean(K.equal(K.max(y_true, axis=-1),\n-                          K.argmax(y_pred, axis=-1)))\n+                          K.cast(K.argmax(y_pred, axis=-1), K.floatx())))\n+\n+\n+def mean_squared_error(y_true, y_pred):\n+    return K.mean(K.square(y_pred - y_true))\n+\n+\n+def mean_absolute_error(y_true, y_pred):\n+    return K.mean(K.abs(y_pred - y_true))\n+\n+\n+def mean_absolute_percentage_error(y_true, y_pred):\n+    diff = K.abs((y_true - y_pred) / K.clip(K.abs(y_true), K.epsilon(), np.inf))\n+    return 100. * K.mean(diff)\n+\n+\n+def mean_squared_logarithmic_error(y_true, y_pred):\n+    first_log = K.log(K.clip(y_pred, K.epsilon(), np.inf) + 1.)\n+    second_log = K.log(K.clip(y_true, K.epsilon(), np.inf) + 1.)\n+    return K.mean(K.square(first_log - second_log))\n+\n+\n+def squared_hinge(y_true, y_pred):\n+    return K.mean(K.square(K.maximum(1. - y_true * y_pred, 0.)))\n+\n+\n+def hinge(y_true, y_pred):\n+    return K.mean(K.maximum(1. - y_true * y_pred, 0.))\n+\n+\n+def categorical_crossentropy(y_true, y_pred):\n+    '''Expects a binary class matrix instead of a vector of scalar classes.\n+    '''\n+    return K.mean(K.categorical_crossentropy(y_pred, y_true))\n+\n+\n+def sparse_categorical_crossentropy(y_true, y_pred):\n+    '''expects an array of integer classes.\n+    Note: labels shape must have the same number of dimensions as output shape.\n+    If you get a shape error, add a length-1 dimension to labels.\n+    '''\n+    return K.mean(K.sparse_categorical_crossentropy(y_pred, y_true))\n+\n+\n+def binary_crossentropy(y_true, y_pred):\n+    return K.mean(K.binary_crossentropy(y_pred, y_true))\n+\n+\n+def poisson(y_true, y_pred):\n+    return K.mean(y_pred - y_true * K.log(y_pred + K.epsilon()))\n+\n+\n+def cosine_proximity(y_true, y_pred):\n+    y_true = K.l2_normalize(y_true, axis=-1)\n+    y_pred = K.l2_normalize(y_pred, axis=-1)\n+    return -K.mean(y_true * y_pred)\n+\n+\n+# aliases\n+mse = MSE = mean_squared_error\n+mae = MAE = mean_absolute_error\n+mape = MAPE = mean_absolute_percentage_error\n+msle = MSLE = mean_squared_logarithmic_error\n+cosine = cosine_proximity\n \n \n from .utils.generic_utils import get_from_module\n\n@@ -0,0 +1,44 @@\n+import pytest\n+import numpy as np\n+\n+from keras import metrics\n+from keras import backend as K\n+\n+all_metrics = [\n+    metrics.binary_accuracy,\n+    metrics.categorical_accuracy,\n+    metrics.mean_squared_error,\n+    metrics.mean_absolute_error,\n+    metrics.mean_absolute_percentage_error,\n+    metrics.mean_squared_logarithmic_error,\n+    metrics.squared_hinge,\n+    metrics.hinge,\n+    metrics.categorical_crossentropy,\n+    metrics.binary_crossentropy,\n+    metrics.poisson,\n+    metrics.cosine_proximity,\n+]\n+\n+all_sparse_metrics = [\n+    metrics.sparse_categorical_accuracy,\n+    metrics.sparse_categorical_crossentropy,\n+]\n+\n+\n+def test_metrics():\n+    y_a = K.variable(np.random.random((6, 7)))\n+    y_b = K.variable(np.random.random((6, 7)))\n+    for metric in all_metrics:\n+        output = metric(y_a, y_b)\n+        assert K.eval(output).shape == ()\n+\n+\n+def test_sparse_metrics():\n+    for metric in all_sparse_metrics:\n+        y_a = K.variable(np.random.randint(0, 7, (6,)), dtype=K.floatx())\n+        y_b = K.variable(np.random.random((6, 7)), dtype=K.floatx())\n+        assert K.eval(metric(y_a, y_b)).shape == ()\n+\n+\n+if __name__ == \"__main__\":\n+    pytest.main([__file__])\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#39051ef3ca9a9eedca58c8ea1b80ce5627d44ee5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 7 | Churn Cumulative: 7565 | Contributors (this commit): 44 | Commits (past 90d): 39 | Contributors (cumulative): 44 | DMM Complexity: 1.0\n\nDIFF:\n@@ -8,11 +8,15 @@ from .engine.topology import get_source_inputs, Node\n from .legacy.models import Graph\n \n \n+def model_from_config(config, custom_objects={}):\n+    from keras.utils.layer_utils import layer_from_config\n+    return layer_from_config(config, custom_objects=custom_objects)\n+\n+\n def model_from_yaml(yaml_string, custom_objects={}):\n     '''Parses a yaml model configuration file\n     and returns a model instance.\n     '''\n-    # TODO: legacy support?\n     import yaml\n     from keras.utils.layer_utils import layer_from_config\n     config = yaml.load(yaml_string)\n@@ -23,7 +27,6 @@ def model_from_json(json_string, custom_objects={}):\n     '''Parses a JSON model configuration file\n     and returns a model instance.\n     '''\n-    # TODO: legacy support?\n     import json\n     from keras.utils.layer_utils import layer_from_config\n     config = json.loads(json_string)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#6fb4e0e441859c1e69cdc2a7e322272a7d816e7d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 20 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 2 | Methods Changed: 4 | Complexity Δ (Sum/Max): 4/2 | Churn Δ: 20 | Churn Cumulative: 3286 | Contributors (this commit): 26 | Commits (past 90d): 76 | Contributors (cumulative): 38 | DMM Complexity: 1.0\n\nDIFF:\n@@ -424,6 +424,18 @@ def minimum(x, y):\n     return tf.minimum(x, y)\n \n \n+def sin(x):\n+    '''Computes sin of x element-wise.\n+    '''\n+    return tf.sin(x)\n+\n+\n+def cos(x)\n+    '''Computes cos of x element-wise.\n+    '''\n+    return tf.cos(x)\n+\n+\n # SHAPE OPERATIONS\n \n def concatenate(tensors, axis=-1):\n\n@@ -265,6 +265,14 @@ def minimum(x, y):\n     return T.minimum(x, y)\n \n \n+def sin(x):\n+    return T.sin(x)\n+\n+\n+def cos(x)\n+    return T.cos(x)\n+\n+\n # SHAPE OPERATIONS\n \n def concatenate(tensors, axis=-1):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#18841fa58de4f45eb64311ee513d16247ae96077", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 3290 | Contributors (this commit): 26 | Commits (past 90d): 78 | Contributors (cumulative): 38 | DMM Complexity: 0.0\n\nDIFF:\n@@ -430,7 +430,7 @@ def sin(x):\n     return tf.sin(x)\n \n \n-def cos(x)\n+def cos(x):\n     '''Computes cos of x element-wise.\n     '''\n     return tf.cos(x)\n\n@@ -269,7 +269,7 @@ def sin(x):\n     return T.sin(x)\n \n \n-def cos(x)\n+def cos(x):\n     return T.cos(x)\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#ed365e94fd461995d1834f61663cf95615e6996c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 6 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 14 | Churn Cumulative: 1817 | Contributors (this commit): 7 | Commits (past 90d): 27 | Contributors (cumulative): 7 | DMM Complexity: 0.0\n\nDIFF:\n@@ -424,7 +424,7 @@ def generator_queue(generator, max_q_size=10,\n class Model(Container):\n \n     def compile(self, optimizer, loss, metrics=[], loss_weights=None,\n-                sample_weight_mode=None, **kwargs):\n+                sample_weight_mode=None, multi_target_loss=False, **kwargs):\n         '''Configures the model for training.\n \n         # Arguments\n@@ -446,6 +446,7 @@ class Model(Container):\n                 If the model has multiple outputs, you can use a different\n                 `sample_weight_mode` on each output by passing a\n                 dictionary or a list of modes.\n+            multi_target_loss: add each target's loss function as a metric\n             kwargs: when using the Theano backend, these arguments\n                 are passed into K.function. Ignored for Tensorflow backend.\n         '''\n@@ -571,6 +572,10 @@ class Model(Container):\n             name = self.output_names[i]\n             self.targets.append(K.placeholder(ndim=len(shape), name=name + '_target'))\n \n+        # prepare metrics\n+        self.metrics_names = ['loss']\n+        self.metrics = []\n+\n         # compute total loss\n         total_loss = None\n         for i in range(len(self.outputs)):\n@@ -582,17 +587,18 @@ class Model(Container):\n             loss_weight = loss_weights_list[i]\n             output_loss = loss_weight * weighted_loss(y_true, y_pred,\n                                                       sample_weight, mask)\n+            if multi_target_loss:\n+                self.metrics.append(output_loss)\n+                self.metrics_names.append('loss_'+self.output_names[i])\n             if total_loss is None:\n                 total_loss = output_loss\n             else:\n                 total_loss += output_loss\n+\n         # add regularization penalties to the loss\n         for r in self.regularizers:\n             total_loss = r(total_loss)\n \n-        # prepare metrics\n-        self.metrics_names = ['loss']\n-        self.metrics = []\n         # list of same size as output_names.\n         # contains tuples (metrics for output, names of metrics)\n         nested_metrics = collect_metrics(metrics, self.output_names)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#344437c491a1823e8b9deab9f8d90002f3285021", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 5 | Churn Cumulative: 412 | Contributors (this commit): 8 | Commits (past 90d): 3 | Contributors (cumulative): 8 | DMM Complexity: 0.0\n\nDIFF:\n@@ -29,14 +29,17 @@ def model_to_dot(model, show_shapes=False):\n         if show_shapes:\n             # Build the label that will actually contain a table with the\n             # input/output\n+            try:\n                 outputlabels = str(layer.output_shape)\n+            except:\n+                outputlabels = 'multiple'\n             if hasattr(layer, 'input_shape'):\n                 inputlabels = str(layer.input_shape)\n             elif hasattr(layer, 'input_shapes'):\n                 inputlabels = ', '.join(\n                     [str(ishape) for ishape in layer.input_shapes])\n             else:\n-                inputlabels = ''\n+                inputlabels = 'multiple'\n             label = '%s\\n|{input:|output:}|{{%s}|{%s}}' % (label, inputlabels, outputlabels)\n \n         node = pydot.Node(layer_id, label=label)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#de8d0defcde21ef35571d4641f22d6fd38bf7f0a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 1077 | Contributors (this commit): 13 | Commits (past 90d): 6 | Contributors (cumulative): 13 | DMM Complexity: None\n\nDIFF:\n@@ -118,7 +118,6 @@ class SGD(Optimizer):\n \n         # momentum\n         self.weights = [K.variable(np.zeros(K.get_value(p).shape)) for p in params]\n-        \n         for p, g, m in zip(params, grads, self.weights):\n             v = self.momentum * m - lr * g  # velocity\n             self.updates.append((m, v))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#4e547a31ed8ddf04f8963187c3384d66c0ea4a7f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 21 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 6 | Methods Changed: 3 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 24 | Churn Cumulative: 1592 | Contributors (this commit): 16 | Commits (past 90d): 40 | Contributors (cumulative): 16 | DMM Complexity: 1.0\n\nDIFF:\n@@ -27,20 +27,33 @@ def set_learning_phase(value):\n \n \n def get_session():\n-    '''Returns the TF session in use by the backend.\n+    '''Returns the TF session to be used by the backend.\n+\n+    If a default TensorFlow session is available, we will return it.\n+\n+    Else, we will return the global Keras session.\n+\n+    If no global Keras session exists at this point:\n+    we will create a new global session.\n+\n+    Note that you can manually set the global session\n+    via `K.set_session(sess)`.\n     '''\n     global _SESSION\n+    if tf.get_default_session() is not None:\n+        return tf.get_default_session()\n     if _SESSION is None:\n         if not os.environ.get('OMP_NUM_THREADS'):\n             _SESSION = tf.Session(config=tf.ConfigProto(allow_soft_placement=True))\n         else:\n             nb_thread = int(os.environ.get('OMP_NUM_THREADS'))\n-            _SESSION = tf.Session(config=tf.ConfigProto(intra_op_parallelism_threads=nb_thread, allow_soft_placement=True))\n+            _SESSION = tf.Session(config=tf.ConfigProto(intra_op_parallelism_threads=nb_thread,\n+                                                        allow_soft_placement=True))\n     return _SESSION\n \n \n def set_session(session):\n-    '''Sets the TF session.\n+    '''Sets the global TF session.\n     '''\n     global _SESSION\n     _SESSION = session\n@@ -60,7 +73,12 @@ def variable(value, dtype=_FLOATX, name=None):\n         Tensor variable instance.\n     '''\n     v = tf.Variable(np.asarray(value, dtype=dtype), name=name)\n+    try:\n         get_session().run(v.initializer)\n+    except:\n+        warnings.warn('Could not automatically initialize variable, '\n+                      'make sure you do it manually (e.g. via '\n+                      '`tf.initialize_all_variables()`).')\n     return v\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#bfbdbb05bc349257e0ac0eef186f7bdb91a89e17", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 16 | Churn Cumulative: 63 | Contributors (this commit): 3 | Commits (past 90d): 5 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -1 +1,17 @@\n+from __future__ import absolute_import\r\n __version__ = '1.0.1'\r\n+from . import backend\r\n+from . import datasets\r\n+from . import engine\r\n+from . import layers\r\n+from . import preprocessing\r\n+from . import utils\r\n+from . import wrappers\r\n+from . import callbacks\r\n+from . import constraints\r\n+from . import initializations\r\n+from . import metrics\r\n+from . import models\r\n+from . import objectives\r\n+from . import optimizers\r\n+from . import regularizers\r\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#9abb6ef7231c547966971ed9923cbba6732ebfa7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 10 | Churn Cumulative: 1602 | Contributors (this commit): 16 | Commits (past 90d): 41 | Contributors (cumulative): 16 | DMM Complexity: 1.0\n\nDIFF:\n@@ -73,12 +73,20 @@ def variable(value, dtype=_FLOATX, name=None):\n         Tensor variable instance.\n     '''\n     v = tf.Variable(np.asarray(value, dtype=dtype), name=name)\n+    if tf.get_default_graph() is get_session().graph:\n         try:\n             get_session().run(v.initializer)\n-    except:\n+        except tf.errors.InvalidArgumentError:\n             warnings.warn('Could not automatically initialize variable, '\n                           'make sure you do it manually (e.g. via '\n                           '`tf.initialize_all_variables()`).')\n+    else:\n+        warnings.warn('The default TensorFlow graph is not the graph '\n+                      'associated with the TensorFlow session currently '\n+                      'registered with Keras, and as such Keras '\n+                      'was not able to automatically initialize a variable. '\n+                      'You should consider registering the proper session '\n+                      'with Keras via `K.set_session(sess)`.')\n     return v\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#b001e36f189219faf0da82ce96a748912ce46212", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 5 | Files Changed: 1 | Hunks: 9 | Methods Changed: 5 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 21 | Churn Cumulative: 10323 | Contributors (this commit): 44 | Commits (past 90d): 44 | Contributors (cumulative): 44 | DMM Complexity: 0.5\n\nDIFF:\n@@ -551,6 +551,9 @@ class Dense(Layer):\n         input_dim: dimensionality of the input (integer).\n             This argument (or alternatively, the keyword argument `input_shape`)\n             is required when using this layer as the first layer in a model.\n+        bias: boolean\n+            Default True;\n+            Setting it to False will remove the bias (b) from all calculations.\n \n     # Input shape\n         2D tensor with shape: `(nb_samples, input_dim)`.\n@@ -560,7 +563,7 @@ class Dense(Layer):\n     '''\n     def __init__(self, output_dim, init='glorot_uniform', activation='linear', weights=None,\n                  W_regularizer=None, b_regularizer=None, activity_regularizer=None,\n-                 W_constraint=None, b_constraint=None, input_dim=None, **kwargs):\n+                 W_constraint=None, b_constraint=None, input_dim=None, bias=True, **kwargs):\n         self.init = initializations.get(init)\n         self.activation = activations.get(activation)\n         self.output_dim = output_dim\n@@ -573,6 +576,7 @@ class Dense(Layer):\n         self.W_constraint = constraints.get(W_constraint)\n         self.b_constraint = constraints.get(b_constraint)\n         \n+        self.bias = bias\n         self.initial_weights = weights\n         self.input_spec = [InputSpec(ndim=2)]\n \n@@ -588,16 +592,19 @@ class Dense(Layer):\n \n         self.W = self.init((input_dim, self.output_dim),\n                            name='{}_W'.format(self.name))\n+        if self.bias:\n             self.b = K.zeros((self.output_dim,),\n                              name='{}_b'.format(self.name))\n             self.trainable_weights = [self.W, self.b]\n+        else:\n+            self.trainable_weights = [self.W]\n \n         self.regularizers = []\n         if self.W_regularizer:\n             self.W_regularizer.set_param(self.W)\n             self.regularizers.append(self.W_regularizer)\n \n-        if self.b_regularizer:\n+        if self.b_regularizer and self.bias:\n             self.b_regularizer.set_param(self.b)\n             self.regularizers.append(self.b_regularizer)\n \n@@ -608,7 +615,7 @@ class Dense(Layer):\n         self.constraints = {}\n         if self.W_constraint:\n             self.constraints[self.W] = self.W_constraint\n-        if self.b_constraint:\n+        if self.b_constraint and self.bias:\n             self.constraints[self.b] = self.b_constraint\n \n         if self.initial_weights is not None:\n@@ -616,7 +623,10 @@ class Dense(Layer):\n             del self.initial_weights\n \n     def call(self, x, mask=None):\n-        return self.activation(K.dot(x, self.W) + self.b)\n+        output = K.dot(x, self.W)\n+        if self.bias:\n+            output += self.b\n+        return self.activation(output)\n \n     def get_output_shape_for(self, input_shape):\n         assert input_shape and len(input_shape) == 2\n@@ -631,7 +641,8 @@ class Dense(Layer):\n                   'activity_regularizer': self.activity_regularizer.get_config() if self.activity_regularizer else None,\n                   'W_constraint': self.W_constraint.get_config() if self.W_constraint else None,\n                   'b_constraint': self.b_constraint.get_config() if self.b_constraint else None,\n-                  'input_dim': self.input_dim}\n+                  'input_dim': self.input_dim,\n+                  'bias': self.bias}\n         base_config = super(Dense, self).get_config()\n         return dict(list(base_config.items()) + list(config.items()))\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#f26ce6e2368ce3b314642c2e02da18e0d5358cb2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 190 | Lines Deleted: 85 | Files Changed: 2 | Hunks: 41 | Methods Changed: 25 | Complexity Δ (Sum/Max): 16/16 | Churn Δ: 275 | Churn Cumulative: 1114 | Contributors (this commit): 12 | Commits (past 90d): 21 | Contributors (cumulative): 16 | DMM Complexity: 0.011111111111111112\n\nDIFF:\n@@ -6,40 +6,99 @@ from __future__ import absolute_import\n \n import numpy as np\n import re\n-from scipy import ndimage\n from scipy import linalg\n-\n+import scipy.ndimage as ndi\n+from six.moves import range\n from os import listdir\n from os.path import isfile, join\n-import math\n-from six.moves import range\n import threading\n \n+def random_rotation(x, rg, row_index=1, col_index=2, channel_index=0,\n+                    fill_mode='nearest', cval=0.):\n+    theta = np.pi / 180 * np.random.uniform(-rg, rg)\n+    rotation_matrix = np.array([[np.cos(theta), -np.sin(theta), 0],\n+                                [np.sin(theta), np.cos(theta), 0],\n+                                [0, 0, 1]])\n \n-def random_rotation(x, rg, fill_mode='nearest',\n-                    cval=0., axes=(1, 2)):\n-    angle = np.random.uniform(-rg, rg)\n-    x = ndimage.interpolation.rotate(x, angle,\n-                                     axes=axes,\n-                                     reshape=False,\n-                                     mode=fill_mode,\n-                                     cval=cval)\n+    h, w = x.shape[row_index], x.shape[col_index]\n+    transform_matrix = transform_matrix_offset_center(rotation_matrix, h, w)\n+    x = apply_transform(x, transform_matrix, channel_index, fill_mode, cval)\n     return x\n \n+def random_shift(x, wrg, hrg, row_index=1, col_index=2, channel_index=0,\n+                 fill_mode='nearest', cval=0.):\n+    h, w = x.shape[row_index], x.shape[col_index]\n+    tx = np.random.uniform(-hrg, hrg) * h\n+    ty = np.random.uniform(-wrg, wrg) * w\n+    translation_matrix = np.array([[1, 0, tx],\n+                                   [0, 1, ty],\n+                                   [0, 0, 1]])\n \n-def random_shift(x, wrg, hrg, fill_mode='nearest',\n-                 cval=0., row_index=1, col_index=2):\n-    shift_x = shift_y = 0\n-    if wrg:\n-        shift_x = np.random.uniform(-wrg, wrg) * x.shape[col_index]\n-    if hrg:\n-        shift_y = np.random.uniform(-hrg, hrg) * x.shape[row_index]\n-    x = ndimage.interpolation.shift(x, (0, shift_y, shift_x),\n-                                    order=0,\n-                                    mode=fill_mode,\n-                                    cval=cval)\n+    transform_matrix = translation_matrix # no need to do offset\n+    x = apply_transform(x, transform_matrix, channel_index, fill_mode, cval)\n     return x\n \n+def random_shear(x, intensity, row_index=1, col_index=2, channel_index=0,\n+                 fill_mode='nearest', cval=0.):\n+    shear = np.random.uniform(-intensity, intensity)\n+    shear_matrix = np.array([[1, -np.sin(shear), 0],\n+                             [0, np.cos(shear), 0],\n+                             [0, 0, 1]])\n+\n+    h, w = x.shape[row_index], x.shape[col_index]\n+    transform_matrix = transform_matrix_offset_center(shear_matrix, h, w)\n+    x = apply_transform(x, transform_matrix, channel_index, fill_mode, cval)\n+    return x\n+\n+def random_zoom(x, zoom_range, row_index=1, col_index=2, channel_index=0,\n+                fill_mode='nearest', cval=0.):\n+    if len(zoom_range) != 2:\n+        raise Exception('zoom_range should be a sequence of two. '\n+                        'Received arg: ', zoom_range)\n+\n+    if zoom_range[0] == 1 and zoom_range[1] == 1:\n+        zx, zy = 1, 1\n+    else:\n+        zx, zy = np.random.uniform(zoom_range[0], zoom_range[1], 2)\n+    zoom_matrix = np.array([[zx, 0, 0],\n+                            [0, zy, 0],\n+                            [0, 0, 1]])\n+\n+    h, w = x.shape[row_index], x.shape[col_index]\n+    transform_matrix = transform_matrix_offset_center(zoom_matrix, h, w)\n+    x = apply_transform(x, transform_matrix, channel_index, fill_mode, cval)\n+    return x\n+\n+def random_barrel_transform(x, intensity):\n+    # TODO\n+    pass\n+\n+def random_channel_shift(x, intensity, channel_index=0):\n+    x = np.rollaxis(x, channel_index, 0)\n+    min_x, max_x = np.min(x), np.max(x)\n+    channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n+                      for x_channel in x]\n+    x = np.stack(channel_images, axis=0)\n+    x = np.rollaxis(x, 0, channel_index+1)\n+    return x\n+\n+def transform_matrix_offset_center(matrix, x, y):\n+    o_x = float(x) / 2 + 0.5\n+    o_y = float(y) / 2 + 0.5\n+    offset_matrix = np.array([[1, 0, o_x], [0, 1, o_y], [0, 0, 1]])\n+    reset_matrix = np.array([[1, 0, -o_x], [0, 1, -o_y], [0, 0, 1]])\n+    transform_matrix = np.dot(np.dot(offset_matrix, matrix), reset_matrix)\n+    return transform_matrix\n+\n+def apply_transform(x, transform_matrix, channel_index=0, fill_mode='nearest', cval=0.):\n+    x = np.rollaxis(x, channel_index, 0)\n+    final_affine_matrix = transform_matrix[:2,:2]\n+    final_offset = transform_matrix[:2,2]\n+    channel_images = [ndi.interpolation.affine_transform(x_channel, final_affine_matrix,\n+                      final_offset, order=0, mode=fill_mode, cval=cval) for x_channel in x]\n+    x = np.stack(channel_images, axis=0)\n+    x = np.rollaxis(x, 0, channel_index+1)\n+    return x\n \n def flip_axis(x, axis):\n     x = np.asarray(x).swapaxes(axis, 0)\n@@ -47,40 +106,9 @@ def flip_axis(x, axis):\n     x = x.swapaxes(0, axis)\n     return x\n \n-\n-def random_barrel_transform(x, intensity):\n-    # TODO\n-    pass\n-\n-\n-def random_shear(x, intensity, fill_mode='nearest', cval=0.):\n-    shear = np.random.uniform(-intensity, intensity)\n-    shear_matrix = np.array([[1.0, -math.sin(shear), 0.0],\n-                            [0.0, math.cos(shear), 0.0],\n-                            [0.0, 0.0, 1.0]])\n-    x = ndimage.interpolation.affine_transform(x, shear_matrix,\n-                                               mode=fill_mode,\n-                                               order=3,\n-                                               cval=cval)\n-    return x\n-\n-\n-def random_channel_shift(x, rg):\n-    # TODO\n-    pass\n-\n-\n-def random_zoom(x, rg, fill_mode='nearest', cval=0.):\n-    zoom_w = np.random.uniform(1.-rg, 1.)\n-    zoom_h = np.random.uniform(1.-rg, 1.)\n-    x = ndimage.interpolation.zoom(x, zoom=(1., zoom_w, zoom_h),\n-                                   mode=fill_mode,\n-                                   cval=cval)\n-    return x  # shape of result will be different from shape of input!\n-\n-\n-def array_to_img(x, scale=True):\n+def array_to_img(x, dim_ordering='th', scale=True):\n     from PIL import Image\n+    if dim_ordering == 'th':\n         x = x.transpose(1, 2, 0)\n     if scale:\n         x += max(-np.min(x), 0)\n@@ -89,22 +117,30 @@ def array_to_img(x, scale=True):\n     if x.shape[2] == 3:\n         # RGB\n         return Image.fromarray(x.astype('uint8'), 'RGB')\n-    else:\n+    elif x.shape[2] == 1:\n         # grayscale\n         return Image.fromarray(x[:, :, 0].astype('uint8'), 'L')\n+    else:\n+        raise Exception('Unsupported channel number: ', x.shape[2])\n \n-\n-def img_to_array(img):\n+# only used by tests/keras/preprocessing/test_image.py to convert PIL.Image to numpy array\n+def img_to_array(img, dim_ordering='th'):\n+    if dim_ordering not in ['th', 'tf']:\n+        raise Exception('Unknown dim_ordering: ', dim_ordering)\n+    # image has dim_ordering (height, width, channel)\n     x = np.asarray(img, dtype='float32')\n     if len(x.shape) == 3:\n-        # RGB: height, width, channel -> channel, height, width\n+        if dim_ordering == 'th':\n             x = x.transpose(2, 0, 1)\n-    else:\n-        # grayscale: height, width -> channel, height, width\n+    elif len(x.shape) == 2:\n+        if dim_ordering == 'th':\n             x = x.reshape((1, x.shape[0], x.shape[1]))\n+        else:\n+            x = x.reshape((x.shape[0], x.shape[1], 1))\n+    else:\n+        raise Exception('Unsupported image shape: ', x.shape)\n     return x\n \n-\n def load_img(path, grayscale=False):\n     from PIL import Image\n     img = Image.open(path)\n@@ -114,7 +150,6 @@ def load_img(path, grayscale=False):\n         img = img.convert('RGB')\n     return img\n \n-\n def list_pictures(directory, ext='jpg|jpeg|bmp|png'):\n     return [join(directory, f) for f in listdir(directory)\n             if isfile(join(directory, f)) and re.match('([\\w]+\\.(?:' + ext + '))', f)]\n@@ -134,6 +169,15 @@ class ImageDataGenerator(object):\n         width_shift_range: fraction of total width.\n         height_shift_range: fraction of total height.\n         shear_range: shear intensity (shear angle in radians).\n+        zoom_range: amount of zoom. if scalar z, zoom will be randomly picked \n+            in the range [1-z, 1+z]. A sequence of two can be passed instead \n+            to select this range.\n+        channel_shift_range: shift range for each channels.\n+        fill_mode: points outside the boundaries are filled according to the \n+            given mode ('constant', 'nearest', 'reflect' or 'wrap'). Default \n+            is 'nearest'.\n+        cval: value used for points outside the boundaries when fill_mode is\n+            'constant'. Default is 0.\n         horizontal_flip: whether to randomly flip images horizontally.\n         vertical_flip: whether to randomly flip images vertically.\n         dim_ordering: 'th' or 'tf'. In 'th' mode, the channels dimension\n@@ -149,6 +193,10 @@ class ImageDataGenerator(object):\n                  width_shift_range=0.,\n                  height_shift_range=0.,\n                  shear_range=0.,\n+                 zoom_range=0.,\n+                 channel_shift_range=0.,\n+                 fill_mode='nearest',\n+                 cval=0.,\n                  horizontal_flip=False,\n                  vertical_flip=False,\n                  dim_ordering='th'):\n@@ -157,9 +205,11 @@ class ImageDataGenerator(object):\n         self.std = None\n         self.principal_components = None\n         self.lock = threading.Lock()\n+\n         if dim_ordering not in {'tf', 'th'}:\n-            raise Exception('dim_ordering should be \"tf\" (channel after row and \\\n-            column) or \"th\" (channel before row and column). Received arg: ', dim_ordering)\n+            raise Exception('dim_ordering should be \"tf\" (channel after row and '\n+                            'column) or \"th\" (channel before row and column). '\n+                            'Received arg: ', dim_ordering)\n         self.dim_ordering = dim_ordering\n         if dim_ordering == \"th\":\n             self.channel_index = 1\n@@ -170,6 +220,14 @@ class ImageDataGenerator(object):\n             self.row_index = 1\n             self.col_index = 2\n \n+        if np.isscalar(zoom_range):\n+            self.zoom_range = [1 - zoom_range, 1 + zoom_range]\n+        elif len(zoom_range) == 2:\n+            self.zoom_range = [zoom_range[0], zoom_range[1]]\n+        else:\n+            raise Exception('zoom_range should be scalar or sequence of two. '\n+                            'Receive arg: ', zoom_range)\n+\n         self.batch_index = 0\n         self.total_batches_seen = 0\n \n@@ -230,7 +288,7 @@ class ImageDataGenerator(object):\n             bX[i] = x\n         if self.save_to_dir:\n             for i in range(current_batch_size):\n-                img = array_to_img(bX[i], scale=True)\n+                img = array_to_img(bX[i], self.dim_ordering, scale=True)\n                 img.save(self.save_to_dir + '/' + self.save_prefix + '_' + str(current_index + i) + '.' + self.save_format)\n         bY = self.y[index_array]\n         return bX, bY\n@@ -240,10 +298,12 @@ class ImageDataGenerator(object):\n         return self.next()\n \n     def standardize(self, x):\n+        # x is a single image, so it doesn't have image number at index 0\n+        img_channel_index = self.channel_index - 1\n         if self.samplewise_center:\n-            x -= np.mean(x, axis=self.channel_index, keepdims=True)\n+            x -= np.mean(x, axis=img_channel_index, keepdims=True)\n         if self.samplewise_std_normalization:\n-            x /= (np.std(x, axis=self.channel_index, keepdims=True) + 1e-7)\n+            x /= (np.std(x, axis=img_channel_index, keepdims=True) + 1e-7)\n \n         if self.featurewise_center:\n             x -= self.mean\n@@ -259,27 +319,68 @@ class ImageDataGenerator(object):\n \n     def random_transform(self, x):\n         # x is a single image, so it doesn't have image number at index 0\n-        img_col_index = self.col_index - 1\n         img_row_index = self.row_index - 1\n+        img_col_index = self.col_index - 1\n+        img_channel_index = self.channel_index - 1\n \n+        # use composition of homographies to generate final transform that needs to be applied\n         if self.rotation_range:\n-            x = random_rotation(x, self.rotation_range,\n-                                axes=(img_row_index, img_col_index))\n-        if self.width_shift_range or self.height_shift_range:\n-            x = random_shift(x, self.width_shift_range, self.height_shift_range,\n-                             row_index=img_row_index, col_index=img_col_index)\n+            theta = np.pi/180*np.random.uniform(-self.rotation_range, self.rotation_range)\n+        else:\n+            theta = 0\n+        rotation_matrix = np.array([[np.cos(theta), -np.sin(theta), 0],\n+                                    [np.sin(theta), np.cos(theta), 0],\n+                                    [0, 0, 1]])\n+        \n+        if self.height_shift_range:\n+            tx = np.random.uniform(-self.height_shift_range, self.height_shift_range) * x.shape[img_row_index]\n+        else:\n+            tx = 0\n+\n+        if self.width_shift_range:\n+            ty = np.random.uniform(-self.width_shift_range, self.width_shift_range) * x.shape[img_col_index]\n+        else:\n+            ty = 0\n+        translation_matrix = np.array([[1, 0, tx],\n+                                       [0, 1, ty],\n+                                       [0, 0, 1]])\n+\n+        if self.shear_range:\n+            shear = np.random.uniform(-self.shear_range, self.shear_range)\n+        else:\n+            shear = 0\n+        shear_matrix = np.array([[1, -np.sin(shear), 0],\n+                                 [0, np.cos(shear), 0],\n+                                 [0, 0, 1]])\n+\n+        if self.zoom_range[0] == 1 and self.zoom_range[1] == 1:\n+            zx, zy = 1, 1\n+        else:\n+            zx, zy = np.random.uniform(self.zoom_range[0], self.zoom_range[1], 2)\n+        zoom_matrix = np.array([[zx, 0, 0],\n+                                [0, zy, 0],\n+                                [0, 0, 1]])\n+\n+        transform_matrix = np.dot(np.dot(np.dot(rotation_matrix, translation_matrix), shear_matrix), zoom_matrix)\n+\n+        h, w = x.shape[img_row_index], x.shape[img_col_index]\n+        transform_matrix = transform_matrix_offset_center(transform_matrix, h, w)\n+        x = apply_transform(x, transform_matrix, img_channel_index, fill_mode=self.fill_mode, cval=self.cval)\n+\n+        if self.channel_shift_range != 0:\n+            x = random_channel_shift(x, self.channel_shift_range, img_channel_index)\n+\n         if self.horizontal_flip:\n             if np.random.random() < 0.5:\n                 x = flip_axis(x, img_col_index)\n+\n         if self.vertical_flip:\n             if np.random.random() < 0.5:\n                 x = flip_axis(x, img_row_index)\n-        if self.shear_range:\n-            x = random_shear(x, self.shear_range)\n+        \n         # TODO:\n-        # zoom\n+        # channel-wise normalization\n         # barrel/fisheye\n-        # channel shifting\n         return x\n \n     def fit(self, X,\n@@ -301,14 +402,13 @@ class ImageDataGenerator(object):\n             aX = np.zeros(tuple([rounds * X.shape[0]] + list(X.shape)[1:]))\n             for r in range(rounds):\n                 for i in range(X.shape[0]):\n-                    img = array_to_img(X[i])\n-                    img = self.random_transform(img)\n-                    aX[i + r * X.shape[0]] = img_to_array(img)\n+                    aX[i + r * X.shape[0]] = self.random_transform(X[i])\n             X = aX\n \n         if self.featurewise_center:\n             self.mean = np.mean(X, axis=0)\n             X -= self.mean\n+\n         if self.featurewise_std_normalization:\n             self.std = np.std(X, axis=0)\n             X /= (self.std + 1e-7)\n@@ -323,7 +423,6 @@ class ImageDataGenerator(object):\n class GraphImageDataGenerator(ImageDataGenerator):\n     '''Example of how to build a generator for a Graph model\n     '''\n-\n     def next(self):\n         bX, bY = super(GraphImageDataGenerator, self).next()\n         return {'input': bX, 'output': bY}\n\n@@ -44,9 +44,13 @@ def test_image_data_generator():\n             samplewise_std_normalization=True,\n             zca_whitening=True,\n             rotation_range=90.,\n-            width_shift_range=10.,\n-            height_shift_range=10.,\n+            width_shift_range=0.1,\n+            height_shift_range=0.1,\n             shear_range=0.5,\n+            zoom_range=0.2,\n+            channel_shift_range=0.,\n+            fill_mode='nearest',\n+            cval=0.5,\n             horizontal_flip=True,\n             vertical_flip=True)\n         generator.fit(images, augment=True)\n@@ -76,6 +80,8 @@ def test_img_flip():\n             width_shift_range=0,\n             height_shift_range=0,\n             shear_range=0,\n+            zoom_range=0,\n+            channel_shift_range=0,\n             horizontal_flip=True,\n             vertical_flip=False,\n             dim_ordering=dim_ordering).flow(x, [1])\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#c9f7d970e97d5af3f92a96cac75554aaf4261337", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 20 | Lines Deleted: 9 | Files Changed: 1 | Hunks: 20 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 29 | Churn Cumulative: 820 | Contributors (this commit): 11 | Commits (past 90d): 16 | Contributors (cumulative): 11 | DMM Complexity: 0.0\n\nDIFF:\n@@ -9,10 +9,10 @@ import re\n from scipy import linalg\n import scipy.ndimage as ndi\n from six.moves import range\n-from os import listdir\n-from os.path import isfile, join\n+import os\n import threading\n \n+\n def random_rotation(x, rg, row_index=1, col_index=2, channel_index=0,\n                     fill_mode='nearest', cval=0.):\n     theta = np.pi / 180 * np.random.uniform(-rg, rg)\n@@ -25,6 +25,7 @@ def random_rotation(x, rg, row_index=1, col_index=2, channel_index=0,\n     x = apply_transform(x, transform_matrix, channel_index, fill_mode, cval)\n     return x\n \n+\n def random_shift(x, wrg, hrg, row_index=1, col_index=2, channel_index=0,\n                  fill_mode='nearest', cval=0.):\n     h, w = x.shape[row_index], x.shape[col_index]\n@@ -38,6 +39,7 @@ def random_shift(x, wrg, hrg, row_index=1, col_index=2, channel_index=0,\n     x = apply_transform(x, transform_matrix, channel_index, fill_mode, cval)\n     return x\n \n+\n def random_shear(x, intensity, row_index=1, col_index=2, channel_index=0,\n                  fill_mode='nearest', cval=0.):\n     shear = np.random.uniform(-intensity, intensity)\n@@ -50,6 +52,7 @@ def random_shear(x, intensity, row_index=1, col_index=2, channel_index=0,\n     x = apply_transform(x, transform_matrix, channel_index, fill_mode, cval)\n     return x\n \n+\n def random_zoom(x, zoom_range, row_index=1, col_index=2, channel_index=0,\n                 fill_mode='nearest', cval=0.):\n     if len(zoom_range) != 2:\n@@ -69,10 +72,12 @@ def random_zoom(x, zoom_range, row_index=1, col_index=2, channel_index=0,\n     x = apply_transform(x, transform_matrix, channel_index, fill_mode, cval)\n     return x\n \n+\n def random_barrel_transform(x, intensity):\n     # TODO\n     pass\n \n+\n def random_channel_shift(x, intensity, channel_index=0):\n     x = np.rollaxis(x, channel_index, 0)\n     min_x, max_x = np.min(x), np.max(x)\n@@ -82,6 +87,7 @@ def random_channel_shift(x, intensity, channel_index=0):\n     x = np.rollaxis(x, 0, channel_index+1)\n     return x\n \n+\n def transform_matrix_offset_center(matrix, x, y):\n     o_x = float(x) / 2 + 0.5\n     o_y = float(y) / 2 + 0.5\n@@ -90,6 +96,7 @@ def transform_matrix_offset_center(matrix, x, y):\n     transform_matrix = np.dot(np.dot(offset_matrix, matrix), reset_matrix)\n     return transform_matrix\n \n+\n def apply_transform(x, transform_matrix, channel_index=0, fill_mode='nearest', cval=0.):\n     x = np.rollaxis(x, channel_index, 0)\n     final_affine_matrix = transform_matrix[:2, :2]\n@@ -100,12 +107,14 @@ def apply_transform(x, transform_matrix, channel_index=0, fill_mode='nearest', c\n     x = np.rollaxis(x, 0, channel_index+1)\n     return x\n \n+\n def flip_axis(x, axis):\n     x = np.asarray(x).swapaxes(axis, 0)\n     x = x[::-1, ...]\n     x = x.swapaxes(0, axis)\n     return x\n \n+\n def array_to_img(x, dim_ordering='th', scale=True):\n     from PIL import Image\n     if dim_ordering == 'th':\n@@ -123,6 +132,7 @@ def array_to_img(x, dim_ordering='th', scale=True):\n     else:\n         raise Exception('Unsupported channel number: ', x.shape[2])\n \n+\n # only used by tests/keras/preprocessing/test_image.py to convert PIL.Image to numpy array\n def img_to_array(img, dim_ordering='th'):\n     if dim_ordering not in ['th', 'tf']:\n@@ -141,6 +151,7 @@ def img_to_array(img, dim_ordering='th'):\n         raise Exception('Unsupported image shape: ', x.shape)\n     return x\n \n+\n def load_img(path, grayscale=False):\n     from PIL import Image\n     img = Image.open(path)\n@@ -150,9 +161,10 @@ def load_img(path, grayscale=False):\n         img = img.convert('RGB')\n     return img\n \n+\n def list_pictures(directory, ext='jpg|jpeg|bmp|png'):\n-    return [join(directory, f) for f in listdir(directory)\n-            if isfile(join(directory, f)) and re.match('([\\w]+\\.(?:' + ext + '))', f)]\n+    return [os.path.join(directory, f) for f in os.listdir(directory)\n+            if os.path.isfile(os.path.join(directory, f)) and re.match('([\\w]+\\.(?:' + ext + '))', f)]\n \n \n class ImageDataGenerator(object):\n@@ -289,7 +301,7 @@ class ImageDataGenerator(object):\n         if self.save_to_dir:\n             for i in range(current_batch_size):\n                 img = array_to_img(bX[i], self.dim_ordering, scale=True)\n-                img.save(self.save_to_dir + '/' + self.save_prefix + '_' + str(current_index + i) + '.' + self.save_format)\n+                img.save(os.path.join(self.save_to_dir, self.save_prefix + '_' + str(current_index + i) + '.' + self.save_format))\n         bY = self.y[index_array]\n         return bX, bY\n \n@@ -331,7 +343,6 @@ class ImageDataGenerator(object):\n         rotation_matrix = np.array([[np.cos(theta), -np.sin(theta), 0],\n                                     [np.sin(theta), np.cos(theta), 0],\n                                     [0, 0, 1]])\n-        \n         if self.height_shift_range:\n             tx = np.random.uniform(-self.height_shift_range, self.height_shift_range) * x.shape[img_row_index]\n         else:\n@@ -341,10 +352,10 @@ class ImageDataGenerator(object):\n             ty = np.random.uniform(-self.width_shift_range, self.width_shift_range) * x.shape[img_col_index]\n         else:\n             ty = 0\n+\n         translation_matrix = np.array([[1, 0, tx],\n                                        [0, 1, ty],\n                                        [0, 0, 1]])\n-\n         if self.shear_range:\n             shear = np.random.uniform(-self.shear_range, self.shear_range)\n         else:\n@@ -365,8 +376,8 @@ class ImageDataGenerator(object):\n \n         h, w = x.shape[img_row_index], x.shape[img_col_index]\n         transform_matrix = transform_matrix_offset_center(transform_matrix, h, w)\n-        x = apply_transform(x, transform_matrix, img_channel_index, fill_mode=self.fill_mode, cval=self.cval)\n-\n+        x = apply_transform(x, transform_matrix, img_channel_index,\n+                            fill_mode=self.fill_mode, cval=self.cval)\n         if self.channel_shift_range != 0:\n             x = random_channel_shift(x, self.channel_shift_range, img_channel_index)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
