{"custom_id": "flask#61fbae866478c19ea5f5c3b9b571a4fad0ba7e5c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 151 | Contributors (this commit): 2 | Commits (past 90d): 3 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -8,6 +8,8 @@ from flask import Flask\n from flask import request\n from flask.helpers import run_async\n \n+pytest.importorskip(\"asgiref\")\n+\n \n class AppError(Exception):\n     pass\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#dc3e9c0cc36b7945431454ea1543da4e33023bb2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 12 | Lines Deleted: 10 | Files Changed: 3 | Hunks: 6 | Methods Changed: 5 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 22 | Churn Cumulative: 2534 | Contributors (this commit): 18 | Commits (past 90d): 22 | Contributors (cumulative): 24 | DMM Complexity: None\n\nDIFF:\n@@ -1520,12 +1520,13 @@ class Flask(Scaffold):\n         return False\n \n     def ensure_sync(self, func):\n-        \"\"\"Ensure that the returned function is sync and calls the async func.\n+        \"\"\"Ensure that the function is synchronous for WSGI workers.\n+        Plain ``def`` functions are returned as-is. ``async def``\n+        functions are wrapped to run and wait for the response.\n+\n+        Override this method to change how the app runs async views.\n \n         .. versionadded:: 2.0\n-\n-        Override if you wish to change how asynchronous functions are\n-        run.\n         \"\"\"\n         if iscoroutinefunction(func):\n             return run_async(func)\n\n@@ -475,8 +475,8 @@ class Blueprint(Scaffold):\n         \"\"\"Ensure the function is synchronous.\n \n         Override if you would like custom async to sync behaviour in\n-        this blueprint. Otherwise :meth:`~flask.Flask..ensure_sync` is\n-        used.\n+        this blueprint. Otherwise the app's\n+        :meth:`~flask.Flask.ensure_sync` is used.\n \n         .. versionadded:: 2.0\n         \"\"\"\n\n@@ -742,9 +742,10 @@ def run_async(func):\n             \"Install Flask with the 'async' extra in order to use async views.\"\n         )\n \n+    # Check that Werkzeug isn't using its fallback ContextVar class.\n     if ContextVar.__module__ == \"werkzeug.local\":\n         raise RuntimeError(\n-            \"async cannot be used with this combination of Python & Greenlet versions\"\n+            \"Async cannot be used with this combination of Python & Greenlet versions.\"\n         )\n \n     @wraps(func)\n@@ -763,9 +764,9 @@ def run_async(func):\n         async def inner(*a, **k):\n             \"\"\"This restores the context before awaiting the func.\n \n-            This is required as the func must be awaited within the\n-            context. Simply calling func (as per the\n-            copy_current_xxx_context functions) doesn't work as the\n+            This is required as the function must be awaited within the\n+            context. Only calling ``func`` (as per the\n+            ``copy_current_xxx_context`` functions) doesn't work as the\n             with block will close before the coroutine is awaited.\n             \"\"\"\n             if ctx is not None:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#6d5ccdefe29292974d0bb8e1d80dcd1a06f28368", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 17 | Churn Cumulative: 1057 | Contributors (this commit): 11 | Commits (past 90d): 13 | Contributors (cumulative): 11 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,8 +1,9 @@\n+import functools\n+import inspect\n import os\n import sys\n import weakref\n from datetime import timedelta\n-from inspect import iscoroutinefunction\n from itertools import chain\n from threading import Lock\n \n@@ -56,6 +57,20 @@ from .wrappers import Request\n from .wrappers import Response\n \n \n+if sys.version_info >= (3, 8):\n+    iscoroutinefunction = inspect.iscoroutinefunction\n+else:\n+\n+    def iscoroutinefunction(func):\n+        while inspect.ismethod(func):\n+            func = func.__func__\n+\n+        while isinstance(func, functools.partial):\n+            func = func.func\n+\n+        return inspect.iscoroutinefunction(func)\n+\n+\n def _make_timedelta(value):\n     if value is None or isinstance(value, timedelta):\n         return value\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#f92e820b4bf357e9792d08ce398802715a63eafe", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 108 | Lines Deleted: 36 | Files Changed: 3 | Hunks: 19 | Methods Changed: 22 | Complexity Δ (Sum/Max): 15/9 | Churn Δ: 144 | Churn Cumulative: 3089 | Contributors (this commit): 22 | Commits (past 90d): 21 | Contributors (cumulative): 28 | DMM Complexity: 0.4576271186440678\n\nDIFF:\n@@ -723,8 +723,8 @@ class Flask(Scaffold):\n         funcs = self.template_context_processors[None]\n         reqctx = _request_ctx_stack.top\n         if reqctx is not None:\n-            bp = reqctx.request.blueprint\n-            if bp is not None and bp in self.template_context_processors:\n+            for bp in self._request_blueprints():\n+                if bp in self.template_context_processors:\n                     funcs = chain(funcs, self.template_context_processors[bp])\n         orig_ctx = context.copy()\n         for func in funcs:\n@@ -987,21 +987,7 @@ class Flask(Scaffold):\n \n         .. versionadded:: 0.7\n         \"\"\"\n-        first_registration = False\n-\n-        if blueprint.name in self.blueprints:\n-            assert self.blueprints[blueprint.name] is blueprint, (\n-                \"A name collision occurred between blueprints\"\n-                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n-                f\" Both share the same name {blueprint.name!r}.\"\n-                f\" Blueprints that are created on the fly need unique\"\n-                f\" names.\"\n-            )\n-        else:\n-            self.blueprints[blueprint.name] = blueprint\n-            first_registration = True\n-\n-        blueprint.register(self, options, first_registration)\n+        blueprint.register(self, options)\n \n     def iter_blueprints(self):\n         \"\"\"Iterates over all blueprints by the order they were registered.\n@@ -1235,12 +1221,8 @@ class Flask(Scaffold):\n         \"\"\"\n         exc_class, code = self._get_exc_class_and_code(type(e))\n \n-        for name, c in (\n-            (request.blueprint, code),\n-            (None, code),\n-            (request.blueprint, None),\n-            (None, None),\n-        ):\n+        for c in [code, None]:\n+            for name in chain(self._request_blueprints(), [None]):\n                 handler_map = self.error_handler_spec[name][c]\n \n                 if not handler_map:\n@@ -1749,16 +1731,16 @@ class Flask(Scaffold):\n         further request handling is stopped.\n         \"\"\"\n \n-        bp = _request_ctx_stack.top.request.blueprint\n-\n         funcs = self.url_value_preprocessors[None]\n-        if bp is not None and bp in self.url_value_preprocessors:\n+        for bp in self._request_blueprints():\n+            if bp in self.url_value_preprocessors:\n                 funcs = chain(funcs, self.url_value_preprocessors[bp])\n         for func in funcs:\n             func(request.endpoint, request.view_args)\n \n         funcs = self.before_request_funcs[None]\n-        if bp is not None and bp in self.before_request_funcs:\n+        for bp in self._request_blueprints():\n+            if bp in self.before_request_funcs:\n                 funcs = chain(funcs, self.before_request_funcs[bp])\n         for func in funcs:\n             rv = func()\n@@ -1779,9 +1761,9 @@ class Flask(Scaffold):\n                  instance of :attr:`response_class`.\n         \"\"\"\n         ctx = _request_ctx_stack.top\n-        bp = ctx.request.blueprint\n         funcs = ctx._after_request_functions\n-        if bp is not None and bp in self.after_request_funcs:\n+        for bp in self._request_blueprints():\n+            if bp in self.after_request_funcs:\n                 funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n         if None in self.after_request_funcs:\n             funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n@@ -1815,8 +1797,8 @@ class Flask(Scaffold):\n         if exc is _sentinel:\n             exc = sys.exc_info()[1]\n         funcs = reversed(self.teardown_request_funcs[None])\n-        bp = _request_ctx_stack.top.request.blueprint\n-        if bp is not None and bp in self.teardown_request_funcs:\n+        for bp in self._request_blueprints():\n+            if bp in self.teardown_request_funcs:\n                 funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n         for func in funcs:\n             func(exc)\n@@ -1985,3 +1967,9 @@ class Flask(Scaffold):\n         wrapped to apply middleware.\n         \"\"\"\n         return self.wsgi_app(environ, start_response)\n+\n+    def _request_blueprints(self):\n+        if _request_ctx_stack.top.request.blueprint is None:\n+            return []\n+        else:\n+            return reversed(_request_ctx_stack.top.request.blueprint.split(\".\"))\n\n@@ -45,6 +45,8 @@ class BlueprintSetupState:\n         #: blueprint.\n         self.url_prefix = url_prefix\n \n+        self.name_prefix = self.options.get(\"name_prefix\", \"\")\n+\n         #: A dictionary with URL defaults that is added to each and every\n         #: URL that was defined with the blueprint.\n         self.url_defaults = dict(self.blueprint.url_values_defaults)\n@@ -68,7 +70,7 @@ class BlueprintSetupState:\n             defaults = dict(defaults, **options.pop(\"defaults\"))\n         self.app.add_url_rule(\n             rule,\n-            f\"{self.blueprint.name}.{endpoint}\",\n+            f\"{self.name_prefix}{self.blueprint.name}.{endpoint}\",\n             view_func,\n             defaults=defaults,\n             **options,\n@@ -168,6 +170,7 @@ class Blueprint(Scaffold):\n \n         self.url_values_defaults = url_defaults\n         self.cli_group = cli_group\n+        self._blueprints = []\n \n     def _is_setup_finished(self):\n         return self.warn_on_modifications and self._got_registered_once\n@@ -210,7 +213,16 @@ class Blueprint(Scaffold):\n         \"\"\"\n         return BlueprintSetupState(self, app, options, first_registration)\n \n-    def register(self, app, options, first_registration=False):\n+    def register_blueprint(self, blueprint, **options):\n+        \"\"\"Register a :class:`~flask.Blueprint` on this blueprint. Keyword\n+        arguments passed to this method will override the defaults set\n+        on the blueprint.\n+\n+        .. versionadded:: 2.0\n+        \"\"\"\n+        self._blueprints.append((blueprint, options))\n+\n+    def register(self, app, options):\n         \"\"\"Called by :meth:`Flask.register_blueprint` to register all\n         views and callbacks registered on the blueprint with the\n         application. Creates a :class:`.BlueprintSetupState` and calls\n@@ -223,6 +235,20 @@ class Blueprint(Scaffold):\n         :param first_registration: Whether this is the first time this\n             blueprint has been registered on the application.\n         \"\"\"\n+        first_registration = False\n+\n+        if self.name in app.blueprints:\n+            assert app.blueprints[self.name] is self, (\n+                \"A name collision occurred between blueprints\"\n+                f\" {self!r} and {app.blueprints[self.name]!r}.\"\n+                f\" Both share the same name {self.name!r}.\"\n+                f\" Blueprints that are created on the fly need unique\"\n+                f\" names.\"\n+            )\n+        else:\n+            app.blueprints[self.name] = self\n+            first_registration = True\n+\n         self._got_registered_once = True\n         state = self.make_setup_state(app, options, first_registration)\n \n@@ -278,11 +304,9 @@ class Blueprint(Scaffold):\n         for deferred in self.deferred_functions:\n             deferred(state)\n \n-        if not self.cli.commands:\n-            return\n-\n         cli_resolved_group = options.get(\"cli_group\", self.cli_group)\n \n+        if self.cli.commands:\n             if cli_resolved_group is None:\n                 app.cli.commands.update(self.cli.commands)\n             elif cli_resolved_group is _sentinel:\n@@ -292,6 +316,17 @@ class Blueprint(Scaffold):\n                 self.cli.name = cli_resolved_group\n                 app.cli.add_command(self.cli)\n \n+        for blueprint, bp_options in self._blueprints:\n+            url_prefix = options.get(\"url_prefix\", \"\")\n+            if \"url_prefix\" in bp_options:\n+                url_prefix = (\n+                    url_prefix.rstrip(\"/\") + \"/\" + bp_options[\"url_prefix\"].lstrip(\"/\")\n+                )\n+\n+            bp_options[\"url_prefix\"] = url_prefix\n+            bp_options[\"name_prefix\"] = options.get(\"name_prefix\", \"\") + self.name + \".\"\n+            blueprint.register(app, bp_options)\n+\n     def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n         \"\"\"Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for\n         the :func:`url_for` function is prefixed with the name of the blueprint.\n\n@@ -850,3 +850,52 @@ def test_app_url_processors(app, client):\n \n     assert client.get(\"/de/\").data == b\"/de/about\"\n     assert client.get(\"/de/about\").data == b\"/de/\"\n+\n+\n+def test_nested_blueprint(app, client):\n+    parent = flask.Blueprint(\"parent\", __name__)\n+    child = flask.Blueprint(\"child\", __name__)\n+    grandchild = flask.Blueprint(\"grandchild\", __name__)\n+\n+    @parent.errorhandler(403)\n+    def forbidden(e):\n+        return \"Parent no\", 403\n+\n+    @parent.route(\"/\")\n+    def parent_index():\n+        return \"Parent yes\"\n+\n+    @parent.route(\"/no\")\n+    def parent_no():\n+        flask.abort(403)\n+\n+    @child.route(\"/\")\n+    def child_index():\n+        return \"Child yes\"\n+\n+    @child.route(\"/no\")\n+    def child_no():\n+        flask.abort(403)\n+\n+    @grandchild.errorhandler(403)\n+    def grandchild_forbidden(e):\n+        return \"Grandchild no\", 403\n+\n+    @grandchild.route(\"/\")\n+    def grandchild_index():\n+        return \"Grandchild yes\"\n+\n+    @grandchild.route(\"/no\")\n+    def grandchild_no():\n+        flask.abort(403)\n+\n+    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n+    parent.register_blueprint(child, url_prefix=\"/child\")\n+    app.register_blueprint(parent, url_prefix=\"/parent\")\n+\n+    assert client.get(\"/parent/\").data == b\"Parent yes\"\n+    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n+    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n+    assert client.get(\"/parent/no\").data == b\"Parent no\"\n+    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n+    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#32272da9ac6e16fa22d3401b2d995d5bf3db9492", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 18 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 18 | Churn Cumulative: 396 | Contributors (this commit): 4 | Commits (past 90d): 3 | Contributors (cumulative): 4 | DMM Complexity: 1.0\n\nDIFF:\n@@ -887,6 +887,24 @@ def shell_command():\n \n     ctx.update(app.make_shell_context())\n \n+    # Site, customize, or startup script can set a hook to call when\n+    # entering interactive mode. The default one sets up readline with\n+    # tab and history completion.\n+    interactive_hook = getattr(sys, \"__interactivehook__\", None)\n+\n+    if interactive_hook is not None:\n+        try:\n+            import readline\n+            from rlcompleter import Completer\n+        except ImportError:\n+            pass\n+        else:\n+            # rlcompleter uses __main__.__dict__ by default, which is\n+            # flask.__main__. Use the shell context instead.\n+            readline.set_completer(Completer(ctx).complete)\n+\n+        interactive_hook()\n+\n     code.interact(banner=banner, local=ctx)\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#8ab4967703c2f5c500174f46b672d80e32f55d85", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 26 | Lines Deleted: 23 | Files Changed: 4 | Hunks: 16 | Methods Changed: 8 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 49 | Churn Cumulative: 3239 | Contributors (this commit): 12 | Commits (past 90d): 20 | Contributors (cumulative): 18 | DMM Complexity: 0.6666666666666666\n\nDIFF:\n@@ -98,7 +98,7 @@ def call_factory(script_info, app_factory, args=None, kwargs=None):\n     if \"script_info\" in sig.parameters:\n         warnings.warn(\n             \"The 'script_info' argument is deprecated and will not be\"\n-            \" passed to the app factory function in 2.1.\",\n+            \" passed to the app factory function in Flask 2.1.\",\n             DeprecationWarning,\n         )\n         kwargs[\"script_info\"] = script_info\n@@ -110,7 +110,8 @@ def call_factory(script_info, app_factory, args=None, kwargs=None):\n     ):\n         warnings.warn(\n             \"Script info is deprecated and will not be passed as the\"\n-            \" single argument to the app factory function in 2.1.\",\n+            \" single argument to the app factory function in Flask\"\n+            \" 2.1.\",\n             DeprecationWarning,\n         )\n         args.append(script_info)\n\n@@ -446,8 +446,9 @@ def _prepare_send_file_kwargs(\n ):\n     if attachment_filename is not None:\n         warnings.warn(\n-            \"The 'attachment_filename' parameter has been renamed to 'download_name'.\"\n-            \" The old name will be removed in Flask 2.1.\",\n+            \"The 'attachment_filename' parameter has been renamed to\"\n+            \" 'download_name'. The old name will be removed in Flask\"\n+            \" 2.1.\",\n             DeprecationWarning,\n             stacklevel=3,\n         )\n@@ -455,8 +456,8 @@ def _prepare_send_file_kwargs(\n \n     if cache_timeout is not None:\n         warnings.warn(\n-            \"The 'cache_timeout' parameter has been renamed to 'max_age'. The old name\"\n-            \" will be removed in Flask 2.1.\",\n+            \"The 'cache_timeout' parameter has been renamed to\"\n+            \" 'max_age'. The old name will be removed in Flask 2.1.\",\n             DeprecationWarning,\n             stacklevel=3,\n         )\n@@ -464,8 +465,8 @@ def _prepare_send_file_kwargs(\n \n     if add_etags is not None:\n         warnings.warn(\n-            \"The 'add_etags' parameter has been renamed to 'etag'. The old name will be\"\n-            \" removed in Flask 2.1.\",\n+            \"The 'add_etags' parameter has been renamed to 'etag'. The\"\n+            \" old name will be removed in Flask 2.1.\",\n             DeprecationWarning,\n             stacklevel=3,\n         )\n@@ -549,7 +550,7 @@ def send_file(\n         ``conditional`` is enabled and ``max_age`` is not set by\n         default.\n \n-    .. versionchanged:: 2.0.0\n+    .. versionchanged:: 2.0\n         ``etag`` replaces the ``add_etags`` parameter. It can be a\n         string to use instead of generating one.\n \n@@ -629,7 +630,7 @@ def safe_join(directory, *pathnames):\n     \"\"\"\n     warnings.warn(\n         \"'flask.helpers.safe_join' is deprecated and will be removed in\"\n-        \" 2.1. Use 'werkzeug.utils.safe_join' instead.\",\n+        \" Flask 2.1. Use 'werkzeug.utils.safe_join' instead.\",\n         DeprecationWarning,\n         stacklevel=2,\n     )\n\n@@ -103,7 +103,7 @@ def dumps(obj, app=None, **kwargs):\n     :param kwargs: Extra arguments passed to :func:`json.dumps`.\n \n     .. versionchanged:: 2.0\n-        ``encoding`` is deprecated and will be removed in 2.1.\n+        ``encoding`` is deprecated and will be removed in Flask 2.1.\n \n     .. versionchanged:: 1.0.3\n         ``app`` can be passed directly, rather than requiring an app\n@@ -115,7 +115,7 @@ def dumps(obj, app=None, **kwargs):\n \n     if encoding is not None:\n         warnings.warn(\n-            \"'encoding' is deprecated and will be removed in 2.1.\",\n+            \"'encoding' is deprecated and will be removed in Flask 2.1.\",\n             DeprecationWarning,\n             stacklevel=2,\n         )\n@@ -140,7 +140,7 @@ def dump(obj, fp, app=None, **kwargs):\n \n     .. versionchanged:: 2.0\n         Writing to a binary file, and the ``encoding`` argument, is\n-        deprecated and will be removed in 2.1.\n+        deprecated and will be removed in Flask 2.1.\n     \"\"\"\n     _dump_arg_defaults(kwargs, app=app)\n     encoding = kwargs.pop(\"encoding\", None)\n@@ -155,7 +155,7 @@ def dump(obj, fp, app=None, **kwargs):\n     if show_warning:\n         warnings.warn(\n             \"Writing to a binary file, and the 'encoding' argument, is\"\n-            \" deprecated and will be removed in 2.1.\",\n+            \" deprecated and will be removed in Flask 2.1.\",\n             DeprecationWarning,\n             stacklevel=2,\n         )\n@@ -175,8 +175,8 @@ def loads(s, app=None, **kwargs):\n     :param kwargs: Extra arguments passed to :func:`json.loads`.\n \n     .. versionchanged:: 2.0\n-        ``encoding`` is deprecated and will be removed in 2.1. The data\n-        must be a string or UTF-8 bytes.\n+        ``encoding`` is deprecated and will be removed in Flask 2.1. The\n+        data must be a string or UTF-8 bytes.\n \n     .. versionchanged:: 1.0.3\n         ``app`` can be passed directly, rather than requiring an app\n@@ -187,8 +187,8 @@ def loads(s, app=None, **kwargs):\n \n     if encoding is not None:\n         warnings.warn(\n-            \"'encoding' is deprecated and will be removed in 2.1. The\"\n-            \" data must be a string or UTF-8 bytes.\",\n+            \"'encoding' is deprecated and will be removed in Flask 2.1.\"\n+            \" The data must be a string or UTF-8 bytes.\",\n             DeprecationWarning,\n             stacklevel=2,\n         )\n@@ -211,16 +211,17 @@ def load(fp, app=None, **kwargs):\n     :param kwargs: Extra arguments passed to :func:`json.load`.\n \n     .. versionchanged:: 2.0\n-        ``encoding`` is deprecated and will be removed in 2.1. The file\n-        must be text mode, or binary mode with UTF-8 bytes.\n+        ``encoding`` is deprecated and will be removed in Flask 2.1. The\n+        file must be text mode, or binary mode with UTF-8 bytes.\n     \"\"\"\n     _load_arg_defaults(kwargs, app=app)\n     encoding = kwargs.pop(\"encoding\", None)\n \n     if encoding is not None:\n         warnings.warn(\n-            \"'encoding' is deprecated and will be removed in 2.1. The\"\n-            \" file must be text mode, or binary mode with UTF-8 bytes.\",\n+            \"'encoding' is deprecated and will be removed in Flask 2.1.\"\n+            \" The file must be text mode, or binary mode with UTF-8\"\n+            \" bytes.\",\n             DeprecationWarning,\n             stacklevel=2,\n         )\n\n@@ -56,7 +56,7 @@ class Scaffold:\n         are relative to. Typically not set, it is discovered based on\n         the ``import_name``.\n \n-    .. versionadded:: 2.0.0\n+    .. versionadded:: 2.0\n     \"\"\"\n \n     name: str\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#5a7a4ab4c5eed63a23762e09b7e6a739375ad0f0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 19 | Lines Deleted: 20 | Files Changed: 1 | Hunks: 5 | Methods Changed: 5 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 39 | Churn Cumulative: 1161 | Contributors (this commit): 8 | Commits (past 90d): 7 | Contributors (cumulative): 8 | DMM Complexity: 0.0\n\nDIFF:\n@@ -18,10 +18,6 @@ from .globals import request\n from .globals import session\n from .signals import message_flashed\n \n-# sentinel\n-_missing = object()\n-\n-\n # what separators does this operating system provide that are not a slash?\n # this is used by the send_from_directory function to ensure that nobody is\n # able to access files from outside the filesystem.\n@@ -677,30 +673,33 @@ def send_from_directory(directory, path, **kwargs):\n     )\n \n \n-class locked_cached_property:\n-    \"\"\"A decorator that converts a function into a lazy property.  The\n-    function wrapped is called the first time to retrieve the result\n-    and then that calculated result is used the next time you access\n-    the value.  Works like the one in Werkzeug but has a lock for\n-    thread safety.\n+class locked_cached_property(werkzeug.utils.cached_property):\n+    \"\"\"A :func:`property` that is only evaluated once. Like\n+    :class:`werkzeug.utils.cached_property` except access uses a lock\n+    for thread safety.\n+\n+    .. versionchanged:: 2.0\n+        Inherits from Werkzeug's ``cached_property`` (and ``property``).\n     \"\"\"\n \n-    def __init__(self, func, name=None, doc=None):\n-        self.__name__ = name or func.__name__\n-        self.__module__ = func.__module__\n-        self.__doc__ = doc or func.__doc__\n-        self.func = func\n+    def __init__(self, fget, name=None, doc=None):\n+        super().__init__(fget, name=name, doc=doc)\n         self.lock = RLock()\n \n     def __get__(self, obj, type=None):\n         if obj is None:\n             return self\n+\n         with self.lock:\n-            value = obj.__dict__.get(self.__name__, _missing)\n-            if value is _missing:\n-                value = self.func(obj)\n-                obj.__dict__[self.__name__] = value\n-            return value\n+            return super().__get__(obj, type=type)\n+\n+    def __set__(self, obj, value):\n+        with self.lock:\n+            super().__set__(obj, value)\n+\n+    def __delete__(self, obj):\n+        with self.lock:\n+            super().__delete__(obj)\n \n \n def total_seconds(td):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#85b430a3669191ee0d092393f98c0dae47218cab", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 13 | Churn Cumulative: 1247 | Contributors (this commit): 10 | Commits (past 90d): 9 | Contributors (cumulative): 11 | DMM Complexity: 1.0\n\nDIFF:\n@@ -709,7 +709,17 @@ def total_seconds(td):\n \n     :returns: number of seconds\n     :rtype: int\n+\n+    .. deprecated:: 2.0\n+        Will be removed in Flask 2.1. Use\n+        :meth:`timedelta.total_seconds` instead.\n     \"\"\"\n+    warnings.warn(\n+        \"'total_seconds' is deprecated and will be removed in Flask\"\n+        \" 2.1. Use 'timedelta.total_seconds' instead.\",\n+        DeprecationWarning,\n+        stacklevel=2,\n+    )\n     return td.days * 60 * 60 * 24 + td.seconds\n \n \n\n@@ -8,7 +8,6 @@ from itsdangerous import URLSafeTimedSerializer\n from werkzeug.datastructures import CallbackDict\n \n from .helpers import is_ip\n-from .helpers import total_seconds\n from .json.tag import TaggedJSONSerializer\n \n \n@@ -340,7 +339,7 @@ class SecureCookieSessionInterface(SessionInterface):\n         val = request.cookies.get(self.get_cookie_name(app))\n         if not val:\n             return self.session_class()\n-        max_age = total_seconds(app.permanent_session_lifetime)\n+        max_age = int(app.permanent_session_lifetime.total_seconds())\n         try:\n             data = s.loads(val, max_age=max_age)\n             return self.session_class(data)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ec27677f956859fb91c87c4ec7e2766873e67bc0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 7 | Churn Cumulative: 1178 | Contributors (this commit): 8 | Commits (past 90d): 9 | Contributors (cumulative): 8 | DMM Complexity: None\n\nDIFF:\n@@ -18,13 +18,6 @@ from .globals import request\n from .globals import session\n from .signals import message_flashed\n \n-# what separators does this operating system provide that are not a slash?\n-# this is used by the send_from_directory function to ensure that nobody is\n-# able to access files from outside the filesystem.\n-_os_alt_seps = list(\n-    sep for sep in [os.path.sep, os.path.altsep] if sep not in (None, \"/\")\n-)\n-\n \n def get_env():\n     \"\"\"Get the environment the app is running in, indicated by the\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#5c6a0f0c121297362b4c78e4240dd8445b9d9f12", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 1 | Files Changed: 3 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 6 | Churn Cumulative: 2442 | Contributors (this commit): 16 | Commits (past 90d): 29 | Contributors (cumulative): 21 | DMM Complexity: 0.5\n\nDIFF:\n@@ -1048,6 +1048,8 @@ class Flask(Scaffold):\n         self.url_map.add(rule)\n         if view_func is not None:\n             old_func = self.view_functions.get(endpoint)\n+            if getattr(old_func, \"_flask_sync_wrapper\", False):\n+                old_func = old_func.__wrapped__\n             if old_func is not None and old_func != view_func:\n                 raise AssertionError(\n                     \"View function mapping is overwriting an existing\"\n\n@@ -780,4 +780,5 @@ def run_async(func):\n \n         return async_to_sync(inner)(*args, **kwargs)\n \n+    outer._flask_sync_wrapper = True\n     return outer\n\n@@ -24,6 +24,7 @@ def _async_app():\n     app = Flask(__name__)\n \n     @app.route(\"/\", methods=[\"GET\", \"POST\"])\n+    @app.route(\"/home\", methods=[\"GET\", \"POST\"])\n     async def index():\n         await asyncio.sleep(0)\n         return request.method\n@@ -57,7 +58,7 @@ def _async_app():\n \n \n @pytest.mark.skipif(sys.version_info < (3, 7), reason=\"requires Python >= 3.7\")\n-@pytest.mark.parametrize(\"path\", [\"/\", \"/bp/\"])\n+@pytest.mark.parametrize(\"path\", [\"/\", \"/home\", \"/bp/\"])\n def test_async_route(path, async_app):\n     test_client = async_app.test_client()\n     response = test_client.get(path)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#07000942dacaeffa84d9db57ea42570fcfb0395e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 8 | Churn Cumulative: 867 | Contributors (this commit): 31 | Commits (past 90d): 2 | Contributors (cumulative): 31 | DMM Complexity: None\n\nDIFF:\n@@ -4,10 +4,10 @@ from setuptools import setup\n setup(\n     name=\"Flask\",\n     install_requires=[\n-        \"Werkzeug>=0.15\",\n-        \"Jinja2>=2.10.1\",\n-        \"itsdangerous>=0.24\",\n-        \"click>=5.1\",\n+        \"Werkzeug>=2.0.0rc4\",\n+        \"Jinja2>=3.0.0rc1\",\n+        \"itsdangerous>=2.0.0rc2\",\n+        \"click>=8.0.0rc1\",\n     ],\n     extras_require={\n         \"async\": [\"asgiref>=3.2\"],\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#7df5db7b0c78b0588f82f2148b51461f94320b90", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 132 | Contributors (this commit): 1 | Commits (past 90d): 1 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -43,4 +43,4 @@ from .signals import template_rendered\n from .templating import render_template\n from .templating import render_template_string\n \n-__version__ = \"2.0.0.dev\"\n+__version__ = \"2.0.0rc1\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#77237093da25438c88b0a74c374a397d4bf823eb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 817 | Lines Deleted: 459 | Files Changed: 19 | Hunks: 441 | Methods Changed: 494 | Complexity Δ (Sum/Max): -3/0 | Churn Δ: 1276 | Churn Cumulative: 6987 | Contributors (this commit): 31 | Commits (past 90d): 68 | Contributors (cumulative): 71 | DMM Complexity: 0.8479241877256317\n\nDIFF:\n@@ -1,11 +1,14 @@\n import functools\n import inspect\n+import logging\n import os\n import sys\n+import typing as t\n import weakref\n from datetime import timedelta\n from itertools import chain\n from threading import Lock\n+from types import TracebackType\n \n from werkzeug.datastructures import Headers\n from werkzeug.datastructures import ImmutableDict\n@@ -15,6 +18,7 @@ from werkzeug.exceptions import HTTPException\n from werkzeug.exceptions import InternalServerError\n from werkzeug.routing import BuildError\n from werkzeug.routing import Map\n+from werkzeug.routing import MapAdapter\n from werkzeug.routing import RequestRedirect\n from werkzeug.routing import RoutingException\n from werkzeug.routing import Rule\n@@ -53,15 +57,30 @@ from .signals import request_started\n from .signals import request_tearing_down\n from .templating import DispatchingJinjaLoader\n from .templating import Environment\n+from .typing import AfterRequestCallable\n+from .typing import BeforeRequestCallable\n+from .typing import ErrorHandlerCallable\n+from .typing import ResponseReturnValue\n+from .typing import TeardownCallable\n+from .typing import TemplateContextProcessorCallable\n+from .typing import TemplateFilterCallable\n+from .typing import TemplateGlobalCallable\n+from .typing import TemplateTestCallable\n+from .typing import URLDefaultCallable\n+from .typing import URLValuePreprocessorCallable\n from .wrappers import Request\n from .wrappers import Response\n \n+if t.TYPE_CHECKING:\n+    from .blueprints import Blueprint\n+    from .testing import FlaskClient\n+    from .testing import FlaskCliRunner\n \n if sys.version_info >= (3, 8):\n     iscoroutinefunction = inspect.iscoroutinefunction\n else:\n \n-    def iscoroutinefunction(func):\n+    def iscoroutinefunction(func: t.Any) -> bool:\n         while inspect.ismethod(func):\n             func = func.__func__\n \n@@ -71,7 +90,7 @@ else:\n         return inspect.iscoroutinefunction(func)\n \n \n-def _make_timedelta(value):\n+def _make_timedelta(value: t.Optional[timedelta]) -> t.Optional[timedelta]:\n     if value is None or isinstance(value, timedelta):\n         return value\n \n@@ -295,7 +314,7 @@ class Flask(Scaffold):\n     #:     This is a ``dict`` instead of an ``ImmutableDict`` to allow\n     #:     easier configuration.\n     #:\n-    jinja_options = {}\n+    jinja_options: dict = {}\n \n     #: Default configuration parameters.\n     default_config = ImmutableDict(\n@@ -347,7 +366,7 @@ class Flask(Scaffold):\n     #: the test client that is used with when `test_client` is used.\n     #:\n     #: .. versionadded:: 0.7\n-    test_client_class = None\n+    test_client_class: t.Optional[t.Type[\"FlaskClient\"]] = None\n \n     #: The :class:`~click.testing.CliRunner` subclass, by default\n     #: :class:`~flask.testing.FlaskCliRunner` that is used by\n@@ -355,7 +374,7 @@ class Flask(Scaffold):\n     #: Flask app object as the first argument.\n     #:\n     #: .. versionadded:: 1.0\n-    test_cli_runner_class = None\n+    test_cli_runner_class: t.Optional[t.Type[\"FlaskCliRunner\"]] = None\n \n     #: the session interface to use.  By default an instance of\n     #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n@@ -365,16 +384,16 @@ class Flask(Scaffold):\n \n     def __init__(\n         self,\n-        import_name,\n-        static_url_path=None,\n-        static_folder=\"static\",\n-        static_host=None,\n-        host_matching=False,\n-        subdomain_matching=False,\n-        template_folder=\"templates\",\n-        instance_path=None,\n-        instance_relative_config=False,\n-        root_path=None,\n+        import_name: str,\n+        static_url_path: t.Optional[str] = None,\n+        static_folder: t.Optional[str] = \"static\",\n+        static_host: t.Optional[str] = None,\n+        host_matching: bool = False,\n+        subdomain_matching: bool = False,\n+        template_folder: t.Optional[str] = \"templates\",\n+        instance_path: t.Optional[str] = None,\n+        instance_relative_config: bool = False,\n+        root_path: t.Optional[str] = None,\n     ):\n         super().__init__(\n             import_name=import_name,\n@@ -409,14 +428,16 @@ class Flask(Scaffold):\n         #: tried.\n         #:\n         #: .. versionadded:: 0.9\n-        self.url_build_error_handlers = []\n+        self.url_build_error_handlers: t.List[\n+            t.Callable[[Exception, str, dict], str]\n+        ] = []\n \n         #: A list of functions that will be called at the beginning of the\n         #: first request to this instance. To register a function, use the\n         #: :meth:`before_first_request` decorator.\n         #:\n         #: .. versionadded:: 0.8\n-        self.before_first_request_funcs = []\n+        self.before_first_request_funcs: t.List[BeforeRequestCallable] = []\n \n         #: A list of functions that are called when the application context\n         #: is destroyed.  Since the application context is also torn down\n@@ -424,13 +445,13 @@ class Flask(Scaffold):\n         #: from databases.\n         #:\n         #: .. versionadded:: 0.9\n-        self.teardown_appcontext_funcs = []\n+        self.teardown_appcontext_funcs: t.List[TeardownCallable] = []\n \n         #: A list of shell context processor functions that should be run\n         #: when a shell context is created.\n         #:\n         #: .. versionadded:: 0.11\n-        self.shell_context_processors = []\n+        self.shell_context_processors: t.List[t.Callable[[], t.Dict[str, t.Any]]] = []\n \n         #: Maps registered blueprint names to blueprint objects. The\n         #: dict retains the order the blueprints were registered in.\n@@ -438,7 +459,7 @@ class Flask(Scaffold):\n         #: not track how often they were attached.\n         #:\n         #: .. versionadded:: 0.7\n-        self.blueprints = {}\n+        self.blueprints: t.Dict[str, \"Blueprint\"] = {}\n \n         #: a place where extensions can store application specific state.  For\n         #: example this is where an extension could store database engines and\n@@ -449,7 +470,7 @@ class Flask(Scaffold):\n         #: ``'foo'``.\n         #:\n         #: .. versionadded:: 0.7\n-        self.extensions = {}\n+        self.extensions: dict = {}\n \n         #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n         #: this to change the routing converters after the class was created\n@@ -492,18 +513,18 @@ class Flask(Scaffold):\n                 f\"{self.static_url_path}/<path:filename>\",\n                 endpoint=\"static\",\n                 host=static_host,\n-                view_func=lambda **kw: self_ref().send_static_file(**kw),\n+                view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n             )\n \n         # Set the name of the Click group in case someone wants to add\n         # the app's commands to another CLI tool.\n         self.cli.name = self.name\n \n-    def _is_setup_finished(self):\n+    def _is_setup_finished(self) -> bool:\n         return self.debug and self._got_first_request\n \n     @locked_cached_property\n-    def name(self):\n+    def name(self) -> str:  # type: ignore\n         \"\"\"The name of the application.  This is usually the import name\n         with the difference that it's guessed from the run file if the\n         import name is main.  This name is used as a display name when\n@@ -520,7 +541,7 @@ class Flask(Scaffold):\n         return self.import_name\n \n     @property\n-    def propagate_exceptions(self):\n+    def propagate_exceptions(self) -> bool:\n         \"\"\"Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration\n         value in case it's set, otherwise a sensible default is returned.\n \n@@ -532,7 +553,7 @@ class Flask(Scaffold):\n         return self.testing or self.debug\n \n     @property\n-    def preserve_context_on_exception(self):\n+    def preserve_context_on_exception(self) -> bool:\n         \"\"\"Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION``\n         configuration value in case it's set, otherwise a sensible default\n         is returned.\n@@ -545,7 +566,7 @@ class Flask(Scaffold):\n         return self.debug\n \n     @locked_cached_property\n-    def logger(self):\n+    def logger(self) -> logging.Logger:\n         \"\"\"A standard Python :class:`~logging.Logger` for the app, with\n         the same name as :attr:`name`.\n \n@@ -572,7 +593,7 @@ class Flask(Scaffold):\n         return create_logger(self)\n \n     @locked_cached_property\n-    def jinja_env(self):\n+    def jinja_env(self) -> Environment:\n         \"\"\"The Jinja environment used to load templates.\n \n         The environment is created the first time this property is\n@@ -582,7 +603,7 @@ class Flask(Scaffold):\n         return self.create_jinja_environment()\n \n     @property\n-    def got_first_request(self):\n+    def got_first_request(self) -> bool:\n         \"\"\"This attribute is set to ``True`` if the application started\n         handling the first request.\n \n@@ -590,7 +611,7 @@ class Flask(Scaffold):\n         \"\"\"\n         return self._got_first_request\n \n-    def make_config(self, instance_relative=False):\n+    def make_config(self, instance_relative: bool = False) -> Config:\n         \"\"\"Used to create the config attribute by the Flask constructor.\n         The `instance_relative` parameter is passed in from the constructor\n         of Flask (there named `instance_relative_config`) and indicates if\n@@ -607,7 +628,7 @@ class Flask(Scaffold):\n         defaults[\"DEBUG\"] = get_debug_flag()\n         return self.config_class(root_path, defaults)\n \n-    def auto_find_instance_path(self):\n+    def auto_find_instance_path(self) -> str:\n         \"\"\"Tries to locate the instance path if it was not provided to the\n         constructor of the application class.  It will basically calculate\n         the path to a folder named ``instance`` next to your main file or\n@@ -620,7 +641,7 @@ class Flask(Scaffold):\n             return os.path.join(package_path, \"instance\")\n         return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n \n-    def open_instance_resource(self, resource, mode=\"rb\"):\n+    def open_instance_resource(self, resource: str, mode: str = \"rb\") -> t.IO[t.AnyStr]:\n         \"\"\"Opens a resource from the application's instance folder\n         (:attr:`instance_path`).  Otherwise works like\n         :meth:`open_resource`.  Instance resources can also be opened for\n@@ -633,7 +654,7 @@ class Flask(Scaffold):\n         return open(os.path.join(self.instance_path, resource), mode)\n \n     @property\n-    def templates_auto_reload(self):\n+    def templates_auto_reload(self) -> bool:\n         \"\"\"Reload templates when they are changed. Used by\n         :meth:`create_jinja_environment`.\n \n@@ -648,10 +669,10 @@ class Flask(Scaffold):\n         return rv if rv is not None else self.debug\n \n     @templates_auto_reload.setter\n-    def templates_auto_reload(self, value):\n+    def templates_auto_reload(self, value: bool) -> None:\n         self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n \n-    def create_jinja_environment(self):\n+    def create_jinja_environment(self) -> Environment:\n         \"\"\"Create the Jinja environment based on :attr:`jinja_options`\n         and the various Jinja-related methods of the app. Changing\n         :attr:`jinja_options` after this will have no effect. Also adds\n@@ -683,10 +704,10 @@ class Flask(Scaffold):\n             session=session,\n             g=g,\n         )\n-        rv.policies[\"json.dumps_function\"] = json.dumps\n+        rv.policies[\"json.dumps_function\"] = json.dumps  # type: ignore\n         return rv\n \n-    def create_global_jinja_loader(self):\n+    def create_global_jinja_loader(self) -> DispatchingJinjaLoader:\n         \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n         override just the loader and keeping the rest unchanged.  It's\n         discouraged to override this function.  Instead one should override\n@@ -699,7 +720,7 @@ class Flask(Scaffold):\n         \"\"\"\n         return DispatchingJinjaLoader(self)\n \n-    def select_jinja_autoescape(self, filename):\n+    def select_jinja_autoescape(self, filename: str) -> bool:\n         \"\"\"Returns ``True`` if autoescaping should be active for the given\n         template name. If no template name is given, returns `True`.\n \n@@ -709,7 +730,7 @@ class Flask(Scaffold):\n             return True\n         return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n \n-    def update_template_context(self, context):\n+    def update_template_context(self, context: dict) -> None:\n         \"\"\"Update the template context with some commonly used variables.\n         This injects request, session, config and g into the template\n         context as well as everything template context processors want\n@@ -720,7 +741,9 @@ class Flask(Scaffold):\n         :param context: the context as a dictionary that is updated in place\n                         to add extra variables.\n         \"\"\"\n-        funcs = self.template_context_processors[None]\n+        funcs: t.Iterable[\n+            TemplateContextProcessorCallable\n+        ] = self.template_context_processors[None]\n         reqctx = _request_ctx_stack.top\n         if reqctx is not None:\n             for bp in self._request_blueprints():\n@@ -734,7 +757,7 @@ class Flask(Scaffold):\n         # existing views.\n         context.update(orig_ctx)\n \n-    def make_shell_context(self):\n+    def make_shell_context(self) -> dict:\n         \"\"\"Returns the shell context for an interactive shell for this\n         application.  This runs all the registered shell context\n         processors.\n@@ -758,7 +781,7 @@ class Flask(Scaffold):\n     env = ConfigAttribute(\"ENV\")\n \n     @property\n-    def debug(self):\n+    def debug(self) -> bool:\n         \"\"\"Whether debug mode is enabled. When using ``flask run`` to start\n         the development server, an interactive debugger will be shown for\n         unhandled exceptions, and the server will be reloaded when code\n@@ -775,11 +798,18 @@ class Flask(Scaffold):\n         return self.config[\"DEBUG\"]\n \n     @debug.setter\n-    def debug(self, value):\n+    def debug(self, value: bool) -> None:\n         self.config[\"DEBUG\"] = value\n         self.jinja_env.auto_reload = self.templates_auto_reload\n \n-    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n+    def run(\n+        self,\n+        host: t.Optional[str] = None,\n+        port: t.Optional[int] = None,\n+        debug: t.Optional[bool] = None,\n+        load_dotenv: bool = True,\n+        **options: t.Any,\n+    ) -> None:\n         \"\"\"Runs the application on a local development server.\n \n         Do not use ``run()`` in a production setting. It is not intended to\n@@ -887,14 +917,14 @@ class Flask(Scaffold):\n         from werkzeug.serving import run_simple\n \n         try:\n-            run_simple(host, port, self, **options)\n+            run_simple(t.cast(str, host), port, self, **options)\n         finally:\n             # reset the first request information if the development server\n             # reset normally.  This makes it possible to restart the server\n             # without reloader and that stuff from an interactive shell.\n             self._got_first_request = False\n \n-    def test_client(self, use_cookies=True, **kwargs):\n+    def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> \"FlaskClient\":\n         \"\"\"Creates a test client for this application.  For information\n         about unit testing head over to :doc:`/testing`.\n \n@@ -947,10 +977,12 @@ class Flask(Scaffold):\n         \"\"\"\n         cls = self.test_client_class\n         if cls is None:\n-            from .testing import FlaskClient as cls\n-        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n+            from .testing import FlaskClient as cls  # type: ignore\n+        return cls(  # type: ignore\n+            self, self.response_class, use_cookies=use_cookies, **kwargs\n+        )\n \n-    def test_cli_runner(self, **kwargs):\n+    def test_cli_runner(self, **kwargs: t.Any) -> \"FlaskCliRunner\":\n         \"\"\"Create a CLI runner for testing CLI commands.\n         See :ref:`testing-cli`.\n \n@@ -963,12 +995,12 @@ class Flask(Scaffold):\n         cls = self.test_cli_runner_class\n \n         if cls is None:\n-            from .testing import FlaskCliRunner as cls\n+            from .testing import FlaskCliRunner as cls  # type: ignore\n \n-        return cls(self, **kwargs)\n+        return cls(self, **kwargs)  # type: ignore\n \n     @setupmethod\n-    def register_blueprint(self, blueprint, **options):\n+    def register_blueprint(self, blueprint: \"Blueprint\", **options: t.Any) -> None:\n         \"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n         arguments passed to this method will override the defaults set on the\n         blueprint.\n@@ -989,7 +1021,7 @@ class Flask(Scaffold):\n         \"\"\"\n         blueprint.register(self, options)\n \n-    def iter_blueprints(self):\n+    def iter_blueprints(self) -> t.ValuesView[\"Blueprint\"]:\n         \"\"\"Iterates over all blueprints by the order they were registered.\n \n         .. versionadded:: 0.11\n@@ -999,14 +1031,14 @@ class Flask(Scaffold):\n     @setupmethod\n     def add_url_rule(\n         self,\n-        rule,\n-        endpoint=None,\n-        view_func=None,\n-        provide_automatic_options=None,\n-        **options,\n-    ):\n+        rule: str,\n+        endpoint: t.Optional[str] = None,\n+        view_func: t.Optional[t.Callable] = None,\n+        provide_automatic_options: t.Optional[bool] = None,\n+        **options: t.Any,\n+    ) -> None:\n         if endpoint is None:\n-            endpoint = _endpoint_from_view_func(view_func)\n+            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n         options[\"endpoint\"] = endpoint\n         methods = options.pop(\"methods\", None)\n \n@@ -1043,13 +1075,13 @@ class Flask(Scaffold):\n         methods |= required_methods\n \n         rule = self.url_rule_class(rule, methods=methods, **options)\n-        rule.provide_automatic_options = provide_automatic_options\n+        rule.provide_automatic_options = provide_automatic_options  # type: ignore\n \n         self.url_map.add(rule)\n         if view_func is not None:\n             old_func = self.view_functions.get(endpoint)\n             if getattr(old_func, \"_flask_sync_wrapper\", False):\n-                old_func = old_func.__wrapped__\n+                old_func = old_func.__wrapped__  # type: ignore\n             if old_func is not None and old_func != view_func:\n                 raise AssertionError(\n                     \"View function mapping is overwriting an existing\"\n@@ -1058,7 +1090,7 @@ class Flask(Scaffold):\n             self.view_functions[endpoint] = self.ensure_sync(view_func)\n \n     @setupmethod\n-    def template_filter(self, name=None):\n+    def template_filter(self, name: t.Optional[str] = None) -> t.Callable:\n         \"\"\"A decorator that is used to register custom template filter.\n         You can specify a name for the filter, otherwise the function\n         name will be used. Example::\n@@ -1071,14 +1103,16 @@ class Flask(Scaffold):\n                      function name will be used.\n         \"\"\"\n \n-        def decorator(f):\n+        def decorator(f: TemplateFilterCallable) -> TemplateFilterCallable:\n             self.add_template_filter(f, name=name)\n             return f\n \n         return decorator\n \n     @setupmethod\n-    def add_template_filter(self, f, name=None):\n+    def add_template_filter(\n+        self, f: TemplateFilterCallable, name: t.Optional[str] = None\n+    ) -> None:\n         \"\"\"Register a custom template filter.  Works exactly like the\n         :meth:`template_filter` decorator.\n \n@@ -1088,7 +1122,7 @@ class Flask(Scaffold):\n         self.jinja_env.filters[name or f.__name__] = f\n \n     @setupmethod\n-    def template_test(self, name=None):\n+    def template_test(self, name: t.Optional[str] = None) -> t.Callable:\n         \"\"\"A decorator that is used to register custom template test.\n         You can specify a name for the test, otherwise the function\n         name will be used. Example::\n@@ -1108,14 +1142,16 @@ class Flask(Scaffold):\n                      function name will be used.\n         \"\"\"\n \n-        def decorator(f):\n+        def decorator(f: TemplateTestCallable) -> TemplateTestCallable:\n             self.add_template_test(f, name=name)\n             return f\n \n         return decorator\n \n     @setupmethod\n-    def add_template_test(self, f, name=None):\n+    def add_template_test(\n+        self, f: TemplateTestCallable, name: t.Optional[str] = None\n+    ) -> None:\n         \"\"\"Register a custom template test.  Works exactly like the\n         :meth:`template_test` decorator.\n \n@@ -1127,7 +1163,7 @@ class Flask(Scaffold):\n         self.jinja_env.tests[name or f.__name__] = f\n \n     @setupmethod\n-    def template_global(self, name=None):\n+    def template_global(self, name: t.Optional[str] = None) -> t.Callable:\n         \"\"\"A decorator that is used to register a custom template global function.\n         You can specify a name for the global function, otherwise the function\n         name will be used. Example::\n@@ -1142,14 +1178,16 @@ class Flask(Scaffold):\n                      function name will be used.\n         \"\"\"\n \n-        def decorator(f):\n+        def decorator(f: TemplateGlobalCallable) -> TemplateGlobalCallable:\n             self.add_template_global(f, name=name)\n             return f\n \n         return decorator\n \n     @setupmethod\n-    def add_template_global(self, f, name=None):\n+    def add_template_global(\n+        self, f: TemplateGlobalCallable, name: t.Optional[str] = None\n+    ) -> None:\n         \"\"\"Register a custom template global function. Works exactly like the\n         :meth:`template_global` decorator.\n \n@@ -1161,7 +1199,7 @@ class Flask(Scaffold):\n         self.jinja_env.globals[name or f.__name__] = f\n \n     @setupmethod\n-    def before_first_request(self, f):\n+    def before_first_request(self, f: BeforeRequestCallable) -> BeforeRequestCallable:\n         \"\"\"Registers a function to be run before the first request to this\n         instance of the application.\n \n@@ -1174,7 +1212,7 @@ class Flask(Scaffold):\n         return f\n \n     @setupmethod\n-    def teardown_appcontext(self, f):\n+    def teardown_appcontext(self, f: TeardownCallable) -> TeardownCallable:\n         \"\"\"Registers a function to be called when the application context\n         ends.  These functions are typically also called when the request\n         context is popped.\n@@ -1207,7 +1245,7 @@ class Flask(Scaffold):\n         return f\n \n     @setupmethod\n-    def shell_context_processor(self, f):\n+    def shell_context_processor(self, f: t.Callable) -> t.Callable:\n         \"\"\"Registers a shell context processor function.\n \n         .. versionadded:: 0.11\n@@ -1215,7 +1253,7 @@ class Flask(Scaffold):\n         self.shell_context_processors.append(f)\n         return f\n \n-    def _find_error_handler(self, e):\n+    def _find_error_handler(self, e: Exception) -> t.Optional[ErrorHandlerCallable]:\n         \"\"\"Return a registered error handler for an exception in this order:\n         blueprint handler for a specific code, app handler for a specific code,\n         blueprint handler for an exception class, app handler for an exception\n@@ -1235,8 +1273,11 @@ class Flask(Scaffold):\n \n                     if handler is not None:\n                         return handler\n+        return None\n \n-    def handle_http_exception(self, e):\n+    def handle_http_exception(\n+        self, e: HTTPException\n+    ) -> t.Union[HTTPException, ResponseReturnValue]:\n         \"\"\"Handles an HTTP exception.  By default this will invoke the\n         registered error handlers and fall back to returning the\n         exception as response.\n@@ -1269,7 +1310,7 @@ class Flask(Scaffold):\n             return e\n         return handler(e)\n \n-    def trap_http_exception(self, e):\n+    def trap_http_exception(self, e: Exception) -> bool:\n         \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n         this will return ``False`` for all exceptions except for a bad request\n         key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\n@@ -1304,7 +1345,9 @@ class Flask(Scaffold):\n \n         return False\n \n-    def handle_user_exception(self, e):\n+    def handle_user_exception(\n+        self, e: Exception\n+    ) -> t.Union[HTTPException, ResponseReturnValue]:\n         \"\"\"This method is called whenever an exception occurs that\n         should be handled. A special case is :class:`~werkzeug\n         .exceptions.HTTPException` which is forwarded to the\n@@ -1334,7 +1377,7 @@ class Flask(Scaffold):\n \n         return handler(e)\n \n-    def handle_exception(self, e):\n+    def handle_exception(self, e: Exception) -> Response:\n         \"\"\"Handle an exception that did not have an error handler\n         associated with it, or that was raised from an error handler.\n         This always causes a 500 ``InternalServerError``.\n@@ -1374,6 +1417,7 @@ class Flask(Scaffold):\n             raise e\n \n         self.log_exception(exc_info)\n+        server_error: t.Union[InternalServerError, ResponseReturnValue]\n         server_error = InternalServerError(original_exception=e)\n         handler = self._find_error_handler(server_error)\n \n@@ -1382,7 +1426,12 @@ class Flask(Scaffold):\n \n         return self.finalize_request(server_error, from_error_handler=True)\n \n-    def log_exception(self, exc_info):\n+    def log_exception(\n+        self,\n+        exc_info: t.Union[\n+            t.Tuple[type, BaseException, TracebackType], t.Tuple[None, None, None]\n+        ],\n+    ) -> None:\n         \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n         if debugging is disabled and right before the handler is called.\n         The default implementation logs the exception as error on the\n@@ -1394,7 +1443,7 @@ class Flask(Scaffold):\n             f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n         )\n \n-    def raise_routing_exception(self, request):\n+    def raise_routing_exception(self, request: Request) -> t.NoReturn:\n         \"\"\"Exceptions that are recording during routing are reraised with\n         this method.  During debug we are not reraising redirect requests\n         for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising\n@@ -1407,13 +1456,13 @@ class Flask(Scaffold):\n             or not isinstance(request.routing_exception, RequestRedirect)\n             or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n         ):\n-            raise request.routing_exception\n+            raise request.routing_exception  # type: ignore\n \n         from .debughelpers import FormDataRoutingRedirect\n \n         raise FormDataRoutingRedirect(request)\n \n-    def dispatch_request(self):\n+    def dispatch_request(self) -> ResponseReturnValue:\n         \"\"\"Does the request dispatching.  Matches the URL and returns the\n         return value of the view or error handler.  This does not have to\n         be a response object.  In order to convert the return value to a\n@@ -1437,7 +1486,7 @@ class Flask(Scaffold):\n         # otherwise dispatch to the handler for that endpoint\n         return self.view_functions[rule.endpoint](**req.view_args)\n \n-    def full_dispatch_request(self):\n+    def full_dispatch_request(self) -> Response:\n         \"\"\"Dispatches the request and on top of that performs request\n         pre and postprocessing as well as HTTP exception catching and\n         error handling.\n@@ -1454,7 +1503,11 @@ class Flask(Scaffold):\n             rv = self.handle_user_exception(e)\n         return self.finalize_request(rv)\n \n-    def finalize_request(self, rv, from_error_handler=False):\n+    def finalize_request(\n+        self,\n+        rv: t.Union[ResponseReturnValue, HTTPException],\n+        from_error_handler: bool = False,\n+    ) -> Response:\n         \"\"\"Given the return value from a view function this finalizes\n         the request by converting it into a response and invoking the\n         postprocessing functions.  This is invoked for both normal\n@@ -1479,7 +1532,7 @@ class Flask(Scaffold):\n             )\n         return response\n \n-    def try_trigger_before_first_request_functions(self):\n+    def try_trigger_before_first_request_functions(self) -> None:\n         \"\"\"Called before each request and will ensure that it triggers\n         the :attr:`before_first_request_funcs` and only exactly once per\n         application instance (which means process usually).\n@@ -1495,7 +1548,7 @@ class Flask(Scaffold):\n                 func()\n             self._got_first_request = True\n \n-    def make_default_options_response(self):\n+    def make_default_options_response(self) -> Response:\n         \"\"\"This method is called to create the default ``OPTIONS`` response.\n         This can be changed through subclassing to change the default\n         behavior of ``OPTIONS`` responses.\n@@ -1508,7 +1561,7 @@ class Flask(Scaffold):\n         rv.allow.update(methods)\n         return rv\n \n-    def should_ignore_error(self, error):\n+    def should_ignore_error(self, error: t.Optional[BaseException]) -> bool:\n         \"\"\"This is called to figure out if an error should be ignored\n         or not as far as the teardown system is concerned.  If this\n         function returns ``True`` then the teardown handlers will not be\n@@ -1518,7 +1571,7 @@ class Flask(Scaffold):\n         \"\"\"\n         return False\n \n-    def ensure_sync(self, func):\n+    def ensure_sync(self, func: t.Callable) -> t.Callable:\n         \"\"\"Ensure that the function is synchronous for WSGI workers.\n         Plain ``def`` functions are returned as-is. ``async def``\n         functions are wrapped to run and wait for the response.\n@@ -1532,7 +1585,7 @@ class Flask(Scaffold):\n \n         return func\n \n-    def make_response(self, rv):\n+    def make_response(self, rv: ResponseReturnValue) -> Response:\n         \"\"\"Convert the return value from a view function to an instance of\n         :attr:`response_class`.\n \n@@ -1620,7 +1673,7 @@ class Flask(Scaffold):\n                 # evaluate a WSGI callable, or coerce a different response\n                 # class to the correct type\n                 try:\n-                    rv = self.response_class.force_type(rv, request.environ)\n+                    rv = self.response_class.force_type(rv, request.environ)  # type: ignore  # noqa: B950\n                 except TypeError as e:\n                     raise TypeError(\n                         f\"{e}\\nThe view function did not return a valid\"\n@@ -1636,10 +1689,11 @@ class Flask(Scaffold):\n                     f\" callable, but it was a {type(rv).__name__}.\"\n                 )\n \n+        rv = t.cast(Response, rv)\n         # prefer the status if it was provided\n         if status is not None:\n             if isinstance(status, (str, bytes, bytearray)):\n-                rv.status = status\n+                rv.status = status  # type: ignore\n             else:\n                 rv.status_code = status\n \n@@ -1649,7 +1703,9 @@ class Flask(Scaffold):\n \n         return rv\n \n-    def create_url_adapter(self, request):\n+    def create_url_adapter(\n+        self, request: t.Optional[Request]\n+    ) -> t.Optional[MapAdapter]:\n         \"\"\"Creates a URL adapter for the given request. The URL adapter\n         is created at a point where the request context is not yet set\n         up so the request is passed explicitly.\n@@ -1687,21 +1743,25 @@ class Flask(Scaffold):\n                 url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n             )\n \n-    def inject_url_defaults(self, endpoint, values):\n+        return None\n+\n+    def inject_url_defaults(self, endpoint: str, values: dict) -> None:\n         \"\"\"Injects the URL defaults for the given endpoint directly into\n         the values dictionary passed.  This is used internally and\n         automatically called on URL building.\n \n         .. versionadded:: 0.7\n         \"\"\"\n-        funcs = self.url_default_functions[None]\n+        funcs: t.Iterable[URLDefaultCallable] = self.url_default_functions[None]\n         if \".\" in endpoint:\n             bp = endpoint.rsplit(\".\", 1)[0]\n             funcs = chain(funcs, self.url_default_functions[bp])\n         for func in funcs:\n             func(endpoint, values)\n \n-    def handle_url_build_error(self, error, endpoint, values):\n+    def handle_url_build_error(\n+        self, error: Exception, endpoint: str, values: dict\n+    ) -> str:\n         \"\"\"Handle :class:`~werkzeug.routing.BuildError` on\n         :meth:`url_for`.\n         \"\"\"\n@@ -1722,7 +1782,7 @@ class Flask(Scaffold):\n \n         raise error\n \n-    def preprocess_request(self):\n+    def preprocess_request(self) -> t.Optional[ResponseReturnValue]:\n         \"\"\"Called before the request is dispatched. Calls\n         :attr:`url_value_preprocessors` registered with the app and the\n         current blueprint (if any). Then calls :attr:`before_request_funcs`\n@@ -1733,14 +1793,16 @@ class Flask(Scaffold):\n         further request handling is stopped.\n         \"\"\"\n \n-        funcs = self.url_value_preprocessors[None]\n+        funcs: t.Iterable[URLValuePreprocessorCallable] = self.url_value_preprocessors[\n+            None\n+        ]\n         for bp in self._request_blueprints():\n             if bp in self.url_value_preprocessors:\n                 funcs = chain(funcs, self.url_value_preprocessors[bp])\n         for func in funcs:\n             func(request.endpoint, request.view_args)\n \n-        funcs = self.before_request_funcs[None]\n+        funcs: t.Iterable[BeforeRequestCallable] = self.before_request_funcs[None]\n         for bp in self._request_blueprints():\n             if bp in self.before_request_funcs:\n                 funcs = chain(funcs, self.before_request_funcs[bp])\n@@ -1749,7 +1811,9 @@ class Flask(Scaffold):\n             if rv is not None:\n                 return rv\n \n-    def process_response(self, response):\n+        return None\n+\n+    def process_response(self, response: Response) -> Response:\n         \"\"\"Can be overridden in order to modify the response object\n         before it's sent to the WSGI server.  By default this will\n         call all the :meth:`after_request` decorated functions.\n@@ -1763,7 +1827,7 @@ class Flask(Scaffold):\n                  instance of :attr:`response_class`.\n         \"\"\"\n         ctx = _request_ctx_stack.top\n-        funcs = ctx._after_request_functions\n+        funcs: t.Iterable[AfterRequestCallable] = ctx._after_request_functions\n         for bp in self._request_blueprints():\n             if bp in self.after_request_funcs:\n                 funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n@@ -1775,7 +1839,9 @@ class Flask(Scaffold):\n             self.session_interface.save_session(self, ctx.session, response)\n         return response\n \n-    def do_teardown_request(self, exc=_sentinel):\n+    def do_teardown_request(\n+        self, exc: t.Optional[BaseException] = _sentinel  # type: ignore\n+    ) -> None:\n         \"\"\"Called after the request is dispatched and the response is\n         returned, right before the request context is popped.\n \n@@ -1798,7 +1864,9 @@ class Flask(Scaffold):\n         \"\"\"\n         if exc is _sentinel:\n             exc = sys.exc_info()[1]\n-        funcs = reversed(self.teardown_request_funcs[None])\n+        funcs: t.Iterable[TeardownCallable] = reversed(\n+            self.teardown_request_funcs[None]\n+        )\n         for bp in self._request_blueprints():\n             if bp in self.teardown_request_funcs:\n                 funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n@@ -1806,7 +1874,9 @@ class Flask(Scaffold):\n             func(exc)\n         request_tearing_down.send(self, exc=exc)\n \n-    def do_teardown_appcontext(self, exc=_sentinel):\n+    def do_teardown_appcontext(\n+        self, exc: t.Optional[BaseException] = _sentinel  # type: ignore\n+    ) -> None:\n         \"\"\"Called right before the application context is popped.\n \n         When handling a request, the application context is popped\n@@ -1827,7 +1897,7 @@ class Flask(Scaffold):\n             func(exc)\n         appcontext_tearing_down.send(self, exc=exc)\n \n-    def app_context(self):\n+    def app_context(self) -> AppContext:\n         \"\"\"Create an :class:`~flask.ctx.AppContext`. Use as a ``with``\n         block to push the context, which will make :data:`current_app`\n         point at this application.\n@@ -1848,7 +1918,7 @@ class Flask(Scaffold):\n         \"\"\"\n         return AppContext(self)\n \n-    def request_context(self, environ):\n+    def request_context(self, environ: dict) -> RequestContext:\n         \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n         WSGI environment. Use a ``with`` block to push the context,\n         which will make :data:`request` point at this request.\n@@ -1864,7 +1934,7 @@ class Flask(Scaffold):\n         \"\"\"\n         return RequestContext(self, environ)\n \n-    def test_request_context(self, *args, **kwargs):\n+    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n         \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n         environment created from the given values. This is mostly useful\n         during testing, where you may want to run a function that uses\n@@ -1920,7 +1990,7 @@ class Flask(Scaffold):\n         finally:\n             builder.close()\n \n-    def wsgi_app(self, environ, start_response):\n+    def wsgi_app(self, environ: dict, start_response: t.Callable) -> t.Any:\n         \"\"\"The actual WSGI application. This is not implemented in\n         :meth:`__call__` so that middlewares can be applied without\n         losing a reference to the app object. Instead of doing this::\n@@ -1946,7 +2016,7 @@ class Flask(Scaffold):\n             start the response.\n         \"\"\"\n         ctx = self.request_context(environ)\n-        error = None\n+        error: t.Optional[BaseException] = None\n         try:\n             try:\n                 ctx.push()\n@@ -1963,14 +2033,14 @@ class Flask(Scaffold):\n                 error = None\n             ctx.auto_pop(error)\n \n-    def __call__(self, environ, start_response):\n+    def __call__(self, environ: dict, start_response: t.Callable) -> t.Any:\n         \"\"\"The WSGI server calls the Flask application object as the\n         WSGI application. This calls :meth:`wsgi_app`, which can be\n         wrapped to apply middleware.\n         \"\"\"\n         return self.wsgi_app(environ, start_response)\n \n-    def _request_blueprints(self):\n+    def _request_blueprints(self) -> t.Iterable[str]:\n         if _request_ctx_stack.top.request.blueprint is None:\n             return []\n         else:\n\n@@ -1,9 +1,25 @@\n+import typing as t\n from collections import defaultdict\n from functools import update_wrapper\n \n from .scaffold import _endpoint_from_view_func\n from .scaffold import _sentinel\n from .scaffold import Scaffold\n+from .typing import AfterRequestCallable\n+from .typing import BeforeRequestCallable\n+from .typing import ErrorHandlerCallable\n+from .typing import TeardownCallable\n+from .typing import TemplateContextProcessorCallable\n+from .typing import TemplateFilterCallable\n+from .typing import TemplateGlobalCallable\n+from .typing import TemplateTestCallable\n+from .typing import URLDefaultCallable\n+from .typing import URLValuePreprocessorCallable\n+\n+if t.TYPE_CHECKING:\n+    from .app import Flask\n+\n+DeferredSetupFunction = t.Callable[[\"BlueprintSetupState\"], t.Callable]\n \n \n class BlueprintSetupState:\n@@ -13,7 +29,13 @@ class BlueprintSetupState:\n     to all register callback functions.\n     \"\"\"\n \n-    def __init__(self, blueprint, app, options, first_registration):\n+    def __init__(\n+        self,\n+        blueprint: \"Blueprint\",\n+        app: \"Flask\",\n+        options: t.Any,\n+        first_registration: bool,\n+    ) -> None:\n         #: a reference to the current application\n         self.app = app\n \n@@ -52,7 +74,13 @@ class BlueprintSetupState:\n         self.url_defaults = dict(self.blueprint.url_values_defaults)\n         self.url_defaults.update(self.options.get(\"url_defaults\", ()))\n \n-    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n+    def add_url_rule(\n+        self,\n+        rule: str,\n+        endpoint: t.Optional[str] = None,\n+        view_func: t.Optional[t.Callable] = None,\n+        **options: t.Any,\n+    ) -> None:\n         \"\"\"A helper method to register a rule (and optionally a view function)\n         to the application.  The endpoint is automatically prefixed with the\n         blueprint's name.\n@@ -64,7 +92,7 @@ class BlueprintSetupState:\n                 rule = self.url_prefix\n         options.setdefault(\"subdomain\", self.subdomain)\n         if endpoint is None:\n-            endpoint = _endpoint_from_view_func(view_func)\n+            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n         defaults = self.url_defaults\n         if \"defaults\" in options:\n             defaults = dict(defaults, **options.pop(\"defaults\"))\n@@ -142,16 +170,16 @@ class Blueprint(Scaffold):\n \n     def __init__(\n         self,\n-        name,\n-        import_name,\n-        static_folder=None,\n-        static_url_path=None,\n-        template_folder=None,\n-        url_prefix=None,\n-        subdomain=None,\n-        url_defaults=None,\n-        root_path=None,\n-        cli_group=_sentinel,\n+        name: str,\n+        import_name: str,\n+        static_folder: t.Optional[str] = None,\n+        static_url_path: t.Optional[str] = None,\n+        template_folder: t.Optional[str] = None,\n+        url_prefix: t.Optional[str] = None,\n+        subdomain: t.Optional[str] = None,\n+        url_defaults: t.Optional[dict] = None,\n+        root_path: t.Optional[str] = None,\n+        cli_group: t.Optional[str] = _sentinel,  # type: ignore\n     ):\n         super().__init__(\n             import_name=import_name,\n@@ -163,19 +191,19 @@ class Blueprint(Scaffold):\n         self.name = name\n         self.url_prefix = url_prefix\n         self.subdomain = subdomain\n-        self.deferred_functions = []\n+        self.deferred_functions: t.List[DeferredSetupFunction] = []\n \n         if url_defaults is None:\n             url_defaults = {}\n \n         self.url_values_defaults = url_defaults\n         self.cli_group = cli_group\n-        self._blueprints = []\n+        self._blueprints: t.List[t.Tuple[\"Blueprint\", dict]] = []\n \n-    def _is_setup_finished(self):\n+    def _is_setup_finished(self) -> bool:\n         return self.warn_on_modifications and self._got_registered_once\n \n-    def record(self, func):\n+    def record(self, func: t.Callable) -> None:\n         \"\"\"Registers a function that is called when the blueprint is\n         registered on the application.  This function is called with the\n         state as argument as returned by the :meth:`make_setup_state`\n@@ -193,27 +221,29 @@ class Blueprint(Scaffold):\n             )\n         self.deferred_functions.append(func)\n \n-    def record_once(self, func):\n+    def record_once(self, func: t.Callable) -> None:\n         \"\"\"Works like :meth:`record` but wraps the function in another\n         function that will ensure the function is only called once.  If the\n         blueprint is registered a second time on the application, the\n         function passed is not called.\n         \"\"\"\n \n-        def wrapper(state):\n+        def wrapper(state: BlueprintSetupState) -> None:\n             if state.first_registration:\n                 func(state)\n \n         return self.record(update_wrapper(wrapper, func))\n \n-    def make_setup_state(self, app, options, first_registration=False):\n+    def make_setup_state(\n+        self, app: \"Flask\", options: dict, first_registration: bool = False\n+    ) -> BlueprintSetupState:\n         \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n         object that is later passed to the register callback functions.\n         Subclasses can override this to return a subclass of the setup state.\n         \"\"\"\n         return BlueprintSetupState(self, app, options, first_registration)\n \n-    def register_blueprint(self, blueprint, **options):\n+    def register_blueprint(self, blueprint: \"Blueprint\", **options: t.Any) -> None:\n         \"\"\"Register a :class:`~flask.Blueprint` on this blueprint. Keyword\n         arguments passed to this method will override the defaults set\n         on the blueprint.\n@@ -222,7 +252,7 @@ class Blueprint(Scaffold):\n         \"\"\"\n         self._blueprints.append((blueprint, options))\n \n-    def register(self, app, options):\n+    def register(self, app: \"Flask\", options: dict) -> None:\n         \"\"\"Called by :meth:`Flask.register_blueprint` to register all\n         views and callbacks registered on the blueprint with the\n         application. Creates a :class:`.BlueprintSetupState` and calls\n@@ -327,7 +357,13 @@ class Blueprint(Scaffold):\n             bp_options[\"name_prefix\"] = options.get(\"name_prefix\", \"\") + self.name + \".\"\n             blueprint.register(app, bp_options)\n \n-    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n+    def add_url_rule(\n+        self,\n+        rule: str,\n+        endpoint: t.Optional[str] = None,\n+        view_func: t.Optional[t.Callable] = None,\n+        **options: t.Any,\n+    ) -> None:\n         \"\"\"Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for\n         the :func:`url_for` function is prefixed with the name of the blueprint.\n         \"\"\"\n@@ -339,7 +375,7 @@ class Blueprint(Scaffold):\n             ), \"Blueprint view function name should not contain dots\"\n         self.record(lambda s: s.add_url_rule(rule, endpoint, view_func, **options))\n \n-    def app_template_filter(self, name=None):\n+    def app_template_filter(self, name: t.Optional[str] = None) -> t.Callable:\n         \"\"\"Register a custom template filter, available application wide.  Like\n         :meth:`Flask.template_filter` but for a blueprint.\n \n@@ -347,13 +383,15 @@ class Blueprint(Scaffold):\n                      function name will be used.\n         \"\"\"\n \n-        def decorator(f):\n+        def decorator(f: TemplateFilterCallable) -> TemplateFilterCallable:\n             self.add_app_template_filter(f, name=name)\n             return f\n \n         return decorator\n \n-    def add_app_template_filter(self, f, name=None):\n+    def add_app_template_filter(\n+        self, f: TemplateFilterCallable, name: t.Optional[str] = None\n+    ) -> None:\n         \"\"\"Register a custom template filter, available application wide.  Like\n         :meth:`Flask.add_template_filter` but for a blueprint.  Works exactly\n         like the :meth:`app_template_filter` decorator.\n@@ -362,12 +400,12 @@ class Blueprint(Scaffold):\n                      function name will be used.\n         \"\"\"\n \n-        def register_template(state):\n+        def register_template(state: BlueprintSetupState) -> None:\n             state.app.jinja_env.filters[name or f.__name__] = f\n \n         self.record_once(register_template)\n \n-    def app_template_test(self, name=None):\n+    def app_template_test(self, name: t.Optional[str] = None) -> t.Callable:\n         \"\"\"Register a custom template test, available application wide.  Like\n         :meth:`Flask.template_test` but for a blueprint.\n \n@@ -377,13 +415,15 @@ class Blueprint(Scaffold):\n                      function name will be used.\n         \"\"\"\n \n-        def decorator(f):\n+        def decorator(f: TemplateTestCallable) -> TemplateTestCallable:\n             self.add_app_template_test(f, name=name)\n             return f\n \n         return decorator\n \n-    def add_app_template_test(self, f, name=None):\n+    def add_app_template_test(\n+        self, f: TemplateTestCallable, name: t.Optional[str] = None\n+    ) -> None:\n         \"\"\"Register a custom template test, available application wide.  Like\n         :meth:`Flask.add_template_test` but for a blueprint.  Works exactly\n         like the :meth:`app_template_test` decorator.\n@@ -394,12 +434,12 @@ class Blueprint(Scaffold):\n                      function name will be used.\n         \"\"\"\n \n-        def register_template(state):\n+        def register_template(state: BlueprintSetupState) -> None:\n             state.app.jinja_env.tests[name or f.__name__] = f\n \n         self.record_once(register_template)\n \n-    def app_template_global(self, name=None):\n+    def app_template_global(self, name: t.Optional[str] = None) -> t.Callable:\n         \"\"\"Register a custom template global, available application wide.  Like\n         :meth:`Flask.template_global` but for a blueprint.\n \n@@ -409,13 +449,15 @@ class Blueprint(Scaffold):\n                      function name will be used.\n         \"\"\"\n \n-        def decorator(f):\n+        def decorator(f: TemplateGlobalCallable) -> TemplateGlobalCallable:\n             self.add_app_template_global(f, name=name)\n             return f\n \n         return decorator\n \n-    def add_app_template_global(self, f, name=None):\n+    def add_app_template_global(\n+        self, f: TemplateGlobalCallable, name: t.Optional[str] = None\n+    ) -> None:\n         \"\"\"Register a custom template global, available application wide.  Like\n         :meth:`Flask.add_template_global` but for a blueprint.  Works exactly\n         like the :meth:`app_template_global` decorator.\n@@ -426,12 +468,12 @@ class Blueprint(Scaffold):\n                      function name will be used.\n         \"\"\"\n \n-        def register_template(state):\n+        def register_template(state: BlueprintSetupState) -> None:\n             state.app.jinja_env.globals[name or f.__name__] = f\n \n         self.record_once(register_template)\n \n-    def before_app_request(self, f):\n+    def before_app_request(self, f: BeforeRequestCallable) -> BeforeRequestCallable:\n         \"\"\"Like :meth:`Flask.before_request`.  Such a function is executed\n         before each request, even if outside of a blueprint.\n         \"\"\"\n@@ -442,7 +484,9 @@ class Blueprint(Scaffold):\n         )\n         return f\n \n-    def before_app_first_request(self, f):\n+    def before_app_first_request(\n+        self, f: BeforeRequestCallable\n+    ) -> BeforeRequestCallable:\n         \"\"\"Like :meth:`Flask.before_first_request`.  Such a function is\n         executed before the first request to the application.\n         \"\"\"\n@@ -451,7 +495,7 @@ class Blueprint(Scaffold):\n         )\n         return f\n \n-    def after_app_request(self, f):\n+    def after_app_request(self, f: AfterRequestCallable) -> AfterRequestCallable:\n         \"\"\"Like :meth:`Flask.after_request` but for a blueprint.  Such a function\n         is executed after each request, even if outside of the blueprint.\n         \"\"\"\n@@ -462,7 +506,7 @@ class Blueprint(Scaffold):\n         )\n         return f\n \n-    def teardown_app_request(self, f):\n+    def teardown_app_request(self, f: TeardownCallable) -> TeardownCallable:\n         \"\"\"Like :meth:`Flask.teardown_request` but for a blueprint.  Such a\n         function is executed when tearing down each request, even if outside of\n         the blueprint.\n@@ -472,7 +516,9 @@ class Blueprint(Scaffold):\n         )\n         return f\n \n-    def app_context_processor(self, f):\n+    def app_context_processor(\n+        self, f: TemplateContextProcessorCallable\n+    ) -> TemplateContextProcessorCallable:\n         \"\"\"Like :meth:`Flask.context_processor` but for a blueprint.  Such a\n         function is executed each request, even if outside of the blueprint.\n         \"\"\"\n@@ -481,32 +527,34 @@ class Blueprint(Scaffold):\n         )\n         return f\n \n-    def app_errorhandler(self, code):\n+    def app_errorhandler(self, code: t.Union[t.Type[Exception], int]) -> t.Callable:\n         \"\"\"Like :meth:`Flask.errorhandler` but for a blueprint.  This\n         handler is used for all requests, even if outside of the blueprint.\n         \"\"\"\n \n-        def decorator(f):\n+        def decorator(f: ErrorHandlerCallable) -> ErrorHandlerCallable:\n             self.record_once(lambda s: s.app.errorhandler(code)(f))\n             return f\n \n         return decorator\n \n-    def app_url_value_preprocessor(self, f):\n+    def app_url_value_preprocessor(\n+        self, f: URLValuePreprocessorCallable\n+    ) -> URLValuePreprocessorCallable:\n         \"\"\"Same as :meth:`url_value_preprocessor` but application wide.\"\"\"\n         self.record_once(\n             lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)\n         )\n         return f\n \n-    def app_url_defaults(self, f):\n+    def app_url_defaults(self, f: URLDefaultCallable) -> URLDefaultCallable:\n         \"\"\"Same as :meth:`url_defaults` but application wide.\"\"\"\n         self.record_once(\n             lambda s: s.app.url_default_functions.setdefault(None, []).append(f)\n         )\n         return f\n \n-    def ensure_sync(self, f):\n+    def ensure_sync(self, f: t.Callable) -> t.Callable:\n         \"\"\"Ensure the function is synchronous.\n \n         Override if you would like custom async to sync behaviour in\n\n@@ -27,7 +27,7 @@ except ImportError:\n try:\n     import ssl\n except ImportError:\n-    ssl = None\n+    ssl = None  # type: ignore\n \n \n class NoAppException(click.UsageError):\n@@ -860,7 +860,7 @@ def run_command(\n \n @click.command(\"shell\", short_help=\"Run a shell in the app context.\")\n @with_appcontext\n-def shell_command():\n+def shell_command() -> None:\n     \"\"\"Run an interactive Python shell in the context of a given\n     Flask application.  The application will populate the default\n     namespace of this shell according to its configuration.\n@@ -877,7 +877,7 @@ def shell_command():\n         f\"App: {app.import_name} [{app.env}]\\n\"\n         f\"Instance: {app.instance_path}\"\n     )\n-    ctx = {}\n+    ctx: dict = {}\n \n     # Support the regular Python interpreter startup script if someone\n     # is using it.\n@@ -922,7 +922,7 @@ def shell_command():\n )\n @click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n @with_appcontext\n-def routes_command(sort, all_methods):\n+def routes_command(sort: str, all_methods: bool) -> None:\n     \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n \n     rules = list(current_app.url_map.iter_rules())\n@@ -935,9 +935,12 @@ def routes_command(sort, all_methods):\n     if sort in (\"endpoint\", \"rule\"):\n         rules = sorted(rules, key=attrgetter(sort))\n     elif sort == \"methods\":\n-        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n \n-    rule_methods = [\", \".join(sorted(rule.methods - ignored_methods)) for rule in rules]\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n \n     headers = (\"Endpoint\", \"Methods\", \"Rule\")\n     widths = (\n@@ -975,7 +978,7 @@ debug mode.\n )\n \n \n-def main():\n+def main() -> None:\n     # TODO omit sys.argv once https://github.com/pallets/click/issues/536 is fixed\n     cli.main(args=sys.argv[1:])\n \n\n@@ -1,6 +1,7 @@\n import errno\n import os\n import types\n+import typing as t\n \n from werkzeug.utils import import_string\n \n@@ -8,11 +9,11 @@ from werkzeug.utils import import_string\n class ConfigAttribute:\n     \"\"\"Makes an attribute forward to the config\"\"\"\n \n-    def __init__(self, name, get_converter=None):\n+    def __init__(self, name: str, get_converter: t.Optional[t.Callable] = None) -> None:\n         self.__name__ = name\n         self.get_converter = get_converter\n \n-    def __get__(self, obj, type=None):\n+    def __get__(self, obj: t.Any, owner: t.Any = None) -> t.Any:\n         if obj is None:\n             return self\n         rv = obj.config[self.__name__]\n@@ -20,7 +21,7 @@ class ConfigAttribute:\n             rv = self.get_converter(rv)\n         return rv\n \n-    def __set__(self, obj, value):\n+    def __set__(self, obj: t.Any, value: t.Any) -> None:\n         obj.config[self.__name__] = value\n \n \n@@ -68,11 +69,11 @@ class Config(dict):\n     :param defaults: an optional dictionary of default values\n     \"\"\"\n \n-    def __init__(self, root_path, defaults=None):\n+    def __init__(self, root_path: str, defaults: t.Optional[dict] = None) -> None:\n         dict.__init__(self, defaults or {})\n         self.root_path = root_path\n \n-    def from_envvar(self, variable_name, silent=False):\n+    def from_envvar(self, variable_name: str, silent: bool = False) -> bool:\n         \"\"\"Loads a configuration from an environment variable pointing to\n         a configuration file.  This is basically just a shortcut with nicer\n         error messages for this line of code::\n@@ -96,7 +97,7 @@ class Config(dict):\n             )\n         return self.from_pyfile(rv, silent=silent)\n \n-    def from_pyfile(self, filename, silent=False):\n+    def from_pyfile(self, filename: str, silent: bool = False) -> bool:\n         \"\"\"Updates the values in the config from a Python file.  This function\n         behaves as if the file was imported as module with the\n         :meth:`from_object` function.\n@@ -124,7 +125,7 @@ class Config(dict):\n         self.from_object(d)\n         return True\n \n-    def from_object(self, obj):\n+    def from_object(self, obj: t.Union[object, str]) -> None:\n         \"\"\"Updates the values from the given object.  An object can be of one\n         of the following two types:\n \n@@ -162,7 +163,12 @@ class Config(dict):\n             if key.isupper():\n                 self[key] = getattr(obj, key)\n \n-    def from_file(self, filename, load, silent=False):\n+    def from_file(\n+        self,\n+        filename: str,\n+        load: t.Callable[[t.IO[t.Any]], t.Mapping],\n+        silent: bool = False,\n+    ) -> bool:\n         \"\"\"Update the values in the config from a file that is loaded\n         using the ``load`` parameter. The loaded data is passed to the\n         :meth:`from_mapping` method.\n@@ -196,30 +202,26 @@ class Config(dict):\n \n         return self.from_mapping(obj)\n \n-    def from_mapping(self, *mapping, **kwargs):\n+    def from_mapping(\n+        self, mapping: t.Optional[t.Mapping[str, t.Any]] = None, **kwargs: t.Any\n+    ) -> bool:\n         \"\"\"Updates the config like :meth:`update` ignoring items with non-upper\n         keys.\n \n         .. versionadded:: 0.11\n         \"\"\"\n-        mappings = []\n-        if len(mapping) == 1:\n-            if hasattr(mapping[0], \"items\"):\n-                mappings.append(mapping[0].items())\n-            else:\n-                mappings.append(mapping[0])\n-        elif len(mapping) > 1:\n-            raise TypeError(\n-                f\"expected at most 1 positional argument, got {len(mapping)}\"\n-            )\n-        mappings.append(kwargs.items())\n-        for mapping in mappings:\n-            for (key, value) in mapping:\n+        mappings: t.Dict[str, t.Any] = {}\n+        if mapping is not None:\n+            mappings.update(mapping)\n+        mappings.update(kwargs)\n+        for key, value in mappings.items():\n             if key.isupper():\n                 self[key] = value\n         return True\n \n-    def get_namespace(self, namespace, lowercase=True, trim_namespace=True):\n+    def get_namespace(\n+        self, namespace: str, lowercase: bool = True, trim_namespace: bool = True\n+    ) -> t.Dict[str, t.Any]:\n         \"\"\"Returns a dictionary containing a subset of configuration options\n         that match the specified namespace/prefix. Example usage::\n \n@@ -260,5 +262,5 @@ class Config(dict):\n             rv[key] = v\n         return rv\n \n-    def __repr__(self):\n+    def __repr__(self) -> str:\n         return f\"<{type(self).__name__} {dict.__repr__(self)}>\"\n\n@@ -1,5 +1,7 @@\n import sys\n+import typing as t\n from functools import update_wrapper\n+from types import TracebackType\n \n from werkzeug.exceptions import HTTPException\n \n@@ -7,6 +9,12 @@ from .globals import _app_ctx_stack\n from .globals import _request_ctx_stack\n from .signals import appcontext_popped\n from .signals import appcontext_pushed\n+from .typing import AfterRequestCallable\n+\n+if t.TYPE_CHECKING:\n+    from .app import Flask\n+    from .sessions import SessionMixin\n+    from .wrappers import Request\n \n \n # a singleton sentinel value for parameter defaults\n@@ -33,7 +41,7 @@ class _AppCtxGlobals:\n         .. versionadded:: 0.10\n     \"\"\"\n \n-    def get(self, name, default=None):\n+    def get(self, name: str, default: t.Optional[t.Any] = None) -> t.Any:\n         \"\"\"Get an attribute by name, or a default value. Like\n         :meth:`dict.get`.\n \n@@ -44,7 +52,7 @@ class _AppCtxGlobals:\n         \"\"\"\n         return self.__dict__.get(name, default)\n \n-    def pop(self, name, default=_sentinel):\n+    def pop(self, name: str, default: t.Any = _sentinel) -> t.Any:\n         \"\"\"Get and remove an attribute by name. Like :meth:`dict.pop`.\n \n         :param name: Name of attribute to pop.\n@@ -58,7 +66,7 @@ class _AppCtxGlobals:\n         else:\n             return self.__dict__.pop(name, default)\n \n-    def setdefault(self, name, default=None):\n+    def setdefault(self, name: str, default: t.Any = None) -> t.Any:\n         \"\"\"Get the value of an attribute if it is present, otherwise\n         set and return a default value. Like :meth:`dict.setdefault`.\n \n@@ -70,20 +78,20 @@ class _AppCtxGlobals:\n         \"\"\"\n         return self.__dict__.setdefault(name, default)\n \n-    def __contains__(self, item):\n+    def __contains__(self, item: t.Any) -> bool:\n         return item in self.__dict__\n \n-    def __iter__(self):\n+    def __iter__(self) -> t.Iterator:\n         return iter(self.__dict__)\n \n-    def __repr__(self):\n+    def __repr__(self) -> str:\n         top = _app_ctx_stack.top\n         if top is not None:\n             return f\"<flask.g of {top.app.name!r}>\"\n         return object.__repr__(self)\n \n \n-def after_this_request(f):\n+def after_this_request(f: AfterRequestCallable) -> AfterRequestCallable:\n     \"\"\"Executes a function after this request.  This is useful to modify\n     response objects.  The function is passed the response object and has\n     to return the same or a new one.\n@@ -108,7 +116,7 @@ def after_this_request(f):\n     return f\n \n \n-def copy_current_request_context(f):\n+def copy_current_request_context(f: t.Callable) -> t.Callable:\n     \"\"\"A helper function that decorates a function to retain the current\n     request context.  This is useful when working with greenlets.  The moment\n     the function is decorated a copy of the request context is created and\n@@ -148,7 +156,7 @@ def copy_current_request_context(f):\n     return update_wrapper(wrapper, f)\n \n \n-def has_request_context():\n+def has_request_context() -> bool:\n     \"\"\"If you have code that wants to test if a request context is there or\n     not this function can be used.  For instance, you may want to take advantage\n     of request information if the request object is available, but fail\n@@ -180,7 +188,7 @@ def has_request_context():\n     return _request_ctx_stack.top is not None\n \n \n-def has_app_context():\n+def has_app_context() -> bool:\n     \"\"\"Works like :func:`has_request_context` but for the application\n     context.  You can also just do a boolean check on the\n     :data:`current_app` object instead.\n@@ -199,7 +207,7 @@ class AppContext:\n     context.\n     \"\"\"\n \n-    def __init__(self, app):\n+    def __init__(self, app: \"Flask\") -> None:\n         self.app = app\n         self.url_adapter = app.create_url_adapter(None)\n         self.g = app.app_ctx_globals_class()\n@@ -208,13 +216,13 @@ class AppContext:\n         # but there a basic \"refcount\" is enough to track them.\n         self._refcnt = 0\n \n-    def push(self):\n+    def push(self) -> None:\n         \"\"\"Binds the app context to the current context.\"\"\"\n         self._refcnt += 1\n         _app_ctx_stack.push(self)\n         appcontext_pushed.send(self.app)\n \n-    def pop(self, exc=_sentinel):\n+    def pop(self, exc: t.Optional[BaseException] = _sentinel) -> None:  # type: ignore\n         \"\"\"Pops the app context.\"\"\"\n         try:\n             self._refcnt -= 1\n@@ -227,11 +235,13 @@ class AppContext:\n         assert rv is self, f\"Popped wrong app context.  ({rv!r} instead of {self!r})\"\n         appcontext_popped.send(self.app)\n \n-    def __enter__(self):\n+    def __enter__(self) -> \"AppContext\":\n         self.push()\n         return self\n \n-    def __exit__(self, exc_type, exc_value, tb):\n+    def __exit__(\n+        self, exc_type: type, exc_value: BaseException, tb: TracebackType\n+    ) -> None:\n         self.pop(exc_value)\n \n \n@@ -265,7 +275,13 @@ class RequestContext:\n     that situation, otherwise your unittests will leak memory.\n     \"\"\"\n \n-    def __init__(self, app, environ, request=None, session=None):\n+    def __init__(\n+        self,\n+        app: \"Flask\",\n+        environ: dict,\n+        request: t.Optional[\"Request\"] = None,\n+        session: t.Optional[\"SessionMixin\"] = None,\n+    ) -> None:\n         self.app = app\n         if request is None:\n             request = app.request_class(environ)\n@@ -282,7 +298,7 @@ class RequestContext:\n         # other request contexts.  Now only if the last level is popped we\n         # get rid of them.  Additionally if an application context is missing\n         # one is created implicitly so for each level we add this information\n-        self._implicit_app_ctx_stack = []\n+        self._implicit_app_ctx_stack: t.List[t.Optional[\"AppContext\"]] = []\n \n         # indicator if the context was preserved.  Next time another context\n         # is pushed the preserved context is popped.\n@@ -295,17 +311,17 @@ class RequestContext:\n         # Functions that should be executed after the request on the response\n         # object.  These will be called before the regular \"after_request\"\n         # functions.\n-        self._after_request_functions = []\n+        self._after_request_functions: t.List[AfterRequestCallable] = []\n \n     @property\n-    def g(self):\n+    def g(self) -> AppContext:\n         return _app_ctx_stack.top.g\n \n     @g.setter\n-    def g(self, value):\n+    def g(self, value: AppContext) -> None:\n         _app_ctx_stack.top.g = value\n \n-    def copy(self):\n+    def copy(self) -> \"RequestContext\":\n         \"\"\"Creates a copy of this request context with the same request object.\n         This can be used to move a request context to a different greenlet.\n         Because the actual request object is the same this cannot be used to\n@@ -325,17 +341,17 @@ class RequestContext:\n             session=self.session,\n         )\n \n-    def match_request(self):\n+    def match_request(self) -> None:\n         \"\"\"Can be overridden by a subclass to hook into the matching\n         of the request.\n         \"\"\"\n         try:\n-            result = self.url_adapter.match(return_rule=True)\n-            self.request.url_rule, self.request.view_args = result\n+            result = self.url_adapter.match(return_rule=True)  # type: ignore\n+            self.request.url_rule, self.request.view_args = result  # type: ignore\n         except HTTPException as e:\n             self.request.routing_exception = e\n \n-    def push(self):\n+    def push(self) -> None:\n         \"\"\"Binds the request context to the current context.\"\"\"\n         # If an exception occurs in debug mode or if context preservation is\n         # activated under exception situations exactly one context stays\n@@ -375,7 +391,7 @@ class RequestContext:\n             if self.session is None:\n                 self.session = session_interface.make_null_session(self.app)\n \n-    def pop(self, exc=_sentinel):\n+    def pop(self, exc: t.Optional[BaseException] = _sentinel) -> None:  # type: ignore\n         \"\"\"Pops the request context and unbinds it by doing that.  This will\n         also trigger the execution of functions registered by the\n         :meth:`~flask.Flask.teardown_request` decorator.\n@@ -414,20 +430,22 @@ class RequestContext:\n                 rv is self\n             ), f\"Popped wrong request context. ({rv!r} instead of {self!r})\"\n \n-    def auto_pop(self, exc):\n+    def auto_pop(self, exc: t.Optional[BaseException]) -> None:\n         if self.request.environ.get(\"flask._preserve_context\") or (\n             exc is not None and self.app.preserve_context_on_exception\n         ):\n             self.preserved = True\n-            self._preserved_exc = exc\n+            self._preserved_exc = exc  # type: ignore\n         else:\n             self.pop(exc)\n \n-    def __enter__(self):\n+    def __enter__(self) -> \"RequestContext\":\n         self.push()\n         return self\n \n-    def __exit__(self, exc_type, exc_value, tb):\n+    def __exit__(\n+        self, exc_type: type, exc_value: BaseException, tb: TracebackType\n+    ) -> None:\n         # do not pop the request stack if we are in debug mode and an\n         # exception happened.  This will allow the debugger to still\n         # access the request object in the interactive shell.  Furthermore\n@@ -435,7 +453,7 @@ class RequestContext:\n         # See flask.testing for how this works.\n         self.auto_pop(exc_value)\n \n-    def __repr__(self):\n+    def __repr__(self) -> str:\n         return (\n             f\"<{type(self).__name__} {self.request.url!r}\"\n             f\" [{self.request.method}] of {self.app.name}>\"\n\n@@ -1,4 +1,5 @@\n import os\n+import typing as t\n from warnings import warn\n \n from .app import Flask\n@@ -92,7 +93,7 @@ def attach_enctype_error_multidict(request):\n     request.files.__class__ = newcls\n \n \n-def _dump_loader_info(loader):\n+def _dump_loader_info(loader) -> t.Generator:\n     yield f\"class: {type(loader).__module__}.{type(loader).__name__}\"\n     for key, value in sorted(loader.__dict__.items()):\n         if key.startswith(\"_\"):\n@@ -109,7 +110,7 @@ def _dump_loader_info(loader):\n         yield f\"{key}: {value!r}\"\n \n \n-def explain_template_loading_attempts(app, template, attempts):\n+def explain_template_loading_attempts(app: Flask, template, attempts) -> None:\n     \"\"\"This should help developers understand what failed\"\"\"\n     info = [f\"Locating template {template!r}:\"]\n     total_found = 0\n@@ -157,7 +158,7 @@ def explain_template_loading_attempts(app, template, attempts):\n     app.logger.info(\"\\n\".join(info))\n \n \n-def explain_ignored_app_run():\n+def explain_ignored_app_run() -> None:\n     if os.environ.get(\"WERKZEUG_RUN_MAIN\") != \"true\":\n         warn(\n             Warning(\n\n@@ -1,8 +1,14 @@\n+import typing as t\n from functools import partial\n \n from werkzeug.local import LocalProxy\n from werkzeug.local import LocalStack\n \n+if t.TYPE_CHECKING:\n+    from .app import Flask\n+    from .ctx import AppContext\n+    from .sessions import SessionMixin\n+    from .wrappers import Request\n \n _request_ctx_err_msg = \"\"\"\\\n Working outside of request context.\n@@ -45,7 +51,7 @@ def _find_app():\n # context locals\n _request_ctx_stack = LocalStack()\n _app_ctx_stack = LocalStack()\n-current_app = LocalProxy(_find_app)\n-request = LocalProxy(partial(_lookup_req_object, \"request\"))\n-session = LocalProxy(partial(_lookup_req_object, \"session\"))\n-g = LocalProxy(partial(_lookup_app_object, \"g\"))\n+current_app: \"Flask\" = LocalProxy(_find_app)  # type: ignore\n+request: \"Request\" = LocalProxy(partial(_lookup_req_object, \"request\"))  # type: ignore\n+session: \"SessionMixin\" = LocalProxy(partial(_lookup_req_object, \"session\"))  # type: ignore # noqa: B950\n+g: \"AppContext\" = LocalProxy(partial(_lookup_app_object, \"g\"))  # type: ignore\n\n@@ -1,6 +1,8 @@\n import os\n import socket\n+import typing as t\n import warnings\n+from datetime import timedelta\n from functools import update_wrapper\n from functools import wraps\n from threading import RLock\n@@ -18,8 +20,11 @@ from .globals import request\n from .globals import session\n from .signals import message_flashed\n \n+if t.TYPE_CHECKING:\n+    from .wrappers import Response\n \n-def get_env():\n+\n+def get_env() -> str:\n     \"\"\"Get the environment the app is running in, indicated by the\n     :envvar:`FLASK_ENV` environment variable. The default is\n     ``'production'``.\n@@ -27,7 +32,7 @@ def get_env():\n     return os.environ.get(\"FLASK_ENV\") or \"production\"\n \n \n-def get_debug_flag():\n+def get_debug_flag() -> bool:\n     \"\"\"Get whether debug mode should be enabled for the app, indicated\n     by the :envvar:`FLASK_DEBUG` environment variable. The default is\n     ``True`` if :func:`.get_env` returns ``'development'``, or ``False``\n@@ -41,7 +46,7 @@ def get_debug_flag():\n     return val.lower() not in (\"0\", \"false\", \"no\")\n \n \n-def get_load_dotenv(default=True):\n+def get_load_dotenv(default: bool = True) -> bool:\n     \"\"\"Get whether the user has disabled loading dotenv files by setting\n     :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load the\n     files.\n@@ -56,7 +61,9 @@ def get_load_dotenv(default=True):\n     return val.lower() in (\"0\", \"false\", \"no\")\n \n \n-def stream_with_context(generator_or_function):\n+def stream_with_context(\n+    generator_or_function: t.Union[t.Generator, t.Callable]\n+) -> t.Generator:\n     \"\"\"Request contexts disappear when the response is started on the server.\n     This is done for efficiency reasons and to make it less likely to encounter\n     memory leaks with badly written WSGI middlewares.  The downside is that if\n@@ -91,16 +98,16 @@ def stream_with_context(generator_or_function):\n     .. versionadded:: 0.9\n     \"\"\"\n     try:\n-        gen = iter(generator_or_function)\n+        gen = iter(generator_or_function)  # type: ignore\n     except TypeError:\n \n-        def decorator(*args, **kwargs):\n-            gen = generator_or_function(*args, **kwargs)\n+        def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:\n+            gen = generator_or_function(*args, **kwargs)  # type: ignore\n             return stream_with_context(gen)\n \n-        return update_wrapper(decorator, generator_or_function)\n+        return update_wrapper(decorator, generator_or_function)  # type: ignore\n \n-    def generator():\n+    def generator() -> t.Generator:\n         ctx = _request_ctx_stack.top\n         if ctx is None:\n             raise RuntimeError(\n@@ -120,7 +127,7 @@ def stream_with_context(generator_or_function):\n                 yield from gen\n             finally:\n                 if hasattr(gen, \"close\"):\n-                    gen.close()\n+                    gen.close()  # type: ignore\n \n     # The trick is to start the generator.  Then the code execution runs until\n     # the first dummy None is yielded at which point the context was already\n@@ -131,7 +138,7 @@ def stream_with_context(generator_or_function):\n     return wrapped_g\n \n \n-def make_response(*args):\n+def make_response(*args: t.Any) -> \"Response\":\n     \"\"\"Sometimes it is necessary to set additional headers in a view.  Because\n     views do not have to return response objects but can return a value that\n     is converted into a response object by Flask itself, it becomes tricky to\n@@ -180,7 +187,7 @@ def make_response(*args):\n     return current_app.make_response(args)\n \n \n-def url_for(endpoint, **values):\n+def url_for(endpoint: str, **values: t.Any) -> str:\n     \"\"\"Generates a URL to the given endpoint with the method provided.\n \n     Variable arguments that are unknown to the target endpoint are appended\n@@ -331,7 +338,7 @@ def url_for(endpoint, **values):\n     return rv\n \n \n-def get_template_attribute(template_name, attribute):\n+def get_template_attribute(template_name: str, attribute: str) -> t.Any:\n     \"\"\"Loads a macro (or variable) a template exports.  This can be used to\n     invoke a macro from within Python code.  If you for example have a\n     template named :file:`_cider.html` with the following contents:\n@@ -353,7 +360,7 @@ def get_template_attribute(template_name, attribute):\n     return getattr(current_app.jinja_env.get_template(template_name).module, attribute)\n \n \n-def flash(message, category=\"message\"):\n+def flash(message: str, category: str = \"message\") -> None:\n     \"\"\"Flashes a message to the next request.  In order to remove the\n     flashed message from the session and to display it to the user,\n     the template has to call :func:`get_flashed_messages`.\n@@ -379,11 +386,15 @@ def flash(message, category=\"message\"):\n     flashes.append((category, message))\n     session[\"_flashes\"] = flashes\n     message_flashed.send(\n-        current_app._get_current_object(), message=message, category=category\n+        current_app._get_current_object(),  # type: ignore\n+        message=message,\n+        category=category,\n     )\n \n \n-def get_flashed_messages(with_categories=False, category_filter=()):\n+def get_flashed_messages(\n+    with_categories: bool = False, category_filter: t.Iterable[str] = ()\n+) -> t.Union[t.List[str], t.List[t.Tuple[str, str]]]:\n     \"\"\"Pulls all flashed messages from the session and returns them.\n     Further calls in the same request to the function will return\n     the same messages.  By default just the messages are returned,\n@@ -608,7 +619,7 @@ def send_file(\n     )\n \n \n-def safe_join(directory, *pathnames):\n+def safe_join(directory: str, *pathnames: str) -> str:\n     \"\"\"Safely join zero or more untrusted path components to a base\n     directory to avoid escaping the base directory.\n \n@@ -631,7 +642,7 @@ def safe_join(directory, *pathnames):\n     return path\n \n \n-def send_from_directory(directory, path, **kwargs):\n+def send_from_directory(directory: str, path: str, **kwargs: t.Any) -> \"Response\":\n     \"\"\"Send a file from within a directory using :func:`send_file`.\n \n     .. code-block:: python\n@@ -661,7 +672,7 @@ def send_from_directory(directory, path, **kwargs):\n \n     .. versionadded:: 0.5\n     \"\"\"\n-    return werkzeug.utils.send_from_directory(\n+    return werkzeug.utils.send_from_directory(  # type: ignore\n         directory, path, **_prepare_send_file_kwargs(**kwargs)\n     )\n \n@@ -675,27 +686,32 @@ class locked_cached_property(werkzeug.utils.cached_property):\n         Inherits from Werkzeug's ``cached_property`` (and ``property``).\n     \"\"\"\n \n-    def __init__(self, fget, name=None, doc=None):\n+    def __init__(\n+        self,\n+        fget: t.Callable[[t.Any], t.Any],\n+        name: t.Optional[str] = None,\n+        doc: t.Optional[str] = None,\n+    ) -> None:\n         super().__init__(fget, name=name, doc=doc)\n         self.lock = RLock()\n \n-    def __get__(self, obj, type=None):\n+    def __get__(self, obj: object, type: type = None) -> t.Any:  # type: ignore\n         if obj is None:\n             return self\n \n         with self.lock:\n             return super().__get__(obj, type=type)\n \n-    def __set__(self, obj, value):\n+    def __set__(self, obj: object, value: t.Any) -> None:\n         with self.lock:\n             super().__set__(obj, value)\n \n-    def __delete__(self, obj):\n+    def __delete__(self, obj: object) -> None:\n         with self.lock:\n             super().__delete__(obj)\n \n \n-def total_seconds(td):\n+def total_seconds(td: timedelta) -> int:\n     \"\"\"Returns the total seconds from a timedelta object.\n \n     :param timedelta td: the timedelta to be converted in seconds\n@@ -716,7 +732,7 @@ def total_seconds(td):\n     return td.days * 60 * 60 * 24 + td.seconds\n \n \n-def is_ip(value):\n+def is_ip(value: str) -> bool:\n     \"\"\"Determine if the given string is an IP address.\n \n     :param value: value to check\n@@ -736,7 +752,7 @@ def is_ip(value):\n     return False\n \n \n-def run_async(func):\n+def run_async(func: t.Callable[..., t.Coroutine]) -> t.Callable[..., t.Any]:\n     \"\"\"Return a sync function that will run the coroutine function *func*.\"\"\"\n     try:\n         from asgiref.sync import async_to_sync\n@@ -752,7 +768,7 @@ def run_async(func):\n         )\n \n     @wraps(func)\n-    def outer(*args, **kwargs):\n+    def outer(*args: t.Any, **kwargs: t.Any) -> t.Any:\n         \"\"\"This function grabs the current context for the inner function.\n \n         This is similar to the copy_current_xxx_context functions in the\n@@ -764,7 +780,7 @@ def run_async(func):\n             ctx = _request_ctx_stack.top.copy()\n \n         @wraps(func)\n-        async def inner(*a, **k):\n+        async def inner(*a: t.Any, **k: t.Any) -> t.Any:\n             \"\"\"This restores the context before awaiting the func.\n \n             This is required as the function must be awaited within the\n@@ -780,5 +796,5 @@ def run_async(func):\n \n         return async_to_sync(inner)(*args, **kwargs)\n \n-    outer._flask_sync_wrapper = True\n+    outer._flask_sync_wrapper = True  # type: ignore\n     return outer\n\n@@ -1,20 +1,25 @@\n import io\n import json as _json\n+import typing as t\n import uuid\n import warnings\n from datetime import date\n \n-from jinja2.utils import htmlsafe_json_dumps as _jinja_htmlsafe_dumps\n+from jinja2.utils import htmlsafe_json_dumps as _jinja_htmlsafe_dumps  # type: ignore\n from werkzeug.http import http_date\n \n from ..globals import current_app\n from ..globals import request\n \n+if t.TYPE_CHECKING:\n+    from ..app import Flask\n+    from ..wrappers import Response\n+\n try:\n     import dataclasses\n except ImportError:\n     # Python < 3.7\n-    dataclasses = None\n+    dataclasses = None  # type: ignore\n \n \n class JSONEncoder(_json.JSONEncoder):\n@@ -34,7 +39,7 @@ class JSONEncoder(_json.JSONEncoder):\n     :attr:`flask.Blueprint.json_encoder` to override the default.\n     \"\"\"\n \n-    def default(self, o):\n+    def default(self, o: t.Any) -> t.Any:\n         \"\"\"Convert ``o`` to a JSON serializable type. See\n         :meth:`json.JSONEncoder.default`. Python does not support\n         overriding how basic types like ``str`` or ``list`` are\n@@ -48,7 +53,7 @@ class JSONEncoder(_json.JSONEncoder):\n             return dataclasses.asdict(o)\n         if hasattr(o, \"__html__\"):\n             return str(o.__html__())\n-        return super().default(self, o)\n+        return super().default(o)\n \n \n class JSONDecoder(_json.JSONDecoder):\n@@ -62,14 +67,19 @@ class JSONDecoder(_json.JSONDecoder):\n     \"\"\"\n \n \n-def _dump_arg_defaults(kwargs, app=None):\n+def _dump_arg_defaults(\n+    kwargs: t.Dict[str, t.Any], app: t.Optional[\"Flask\"] = None\n+) -> None:\n     \"\"\"Inject default arguments for dump functions.\"\"\"\n     if app is None:\n         app = current_app\n \n     if app:\n-        bp = app.blueprints.get(request.blueprint) if request else None\n-        cls = bp.json_encoder if bp and bp.json_encoder else app.json_encoder\n+        cls = app.json_encoder\n+        bp = app.blueprints.get(request.blueprint) if request else None  # type: ignore\n+        if bp is not None and bp.json_encoder is not None:\n+            cls = bp.json_encoder\n+\n         kwargs.setdefault(\"cls\", cls)\n         kwargs.setdefault(\"ensure_ascii\", app.config[\"JSON_AS_ASCII\"])\n         kwargs.setdefault(\"sort_keys\", app.config[\"JSON_SORT_KEYS\"])\n@@ -78,20 +88,25 @@ def _dump_arg_defaults(kwargs, app=None):\n         kwargs.setdefault(\"cls\", JSONEncoder)\n \n \n-def _load_arg_defaults(kwargs, app=None):\n+def _load_arg_defaults(\n+    kwargs: t.Dict[str, t.Any], app: t.Optional[\"Flask\"] = None\n+) -> None:\n     \"\"\"Inject default arguments for load functions.\"\"\"\n     if app is None:\n         app = current_app\n \n     if app:\n-        bp = app.blueprints.get(request.blueprint) if request else None\n-        cls = bp.json_decoder if bp and bp.json_decoder else app.json_decoder\n+        cls = app.json_decoder\n+        bp = app.blueprints.get(request.blueprint) if request else None  # type: ignore\n+        if bp is not None and bp.json_decoder is not None:\n+            cls = bp.json_decoder\n+\n         kwargs.setdefault(\"cls\", cls)\n     else:\n         kwargs.setdefault(\"cls\", JSONDecoder)\n \n \n-def dumps(obj, app=None, **kwargs):\n+def dumps(obj: t.Any, app: t.Optional[\"Flask\"] = None, **kwargs: t.Any) -> str:\n     \"\"\"Serialize an object to a string of JSON.\n \n     Takes the same arguments as the built-in :func:`json.dumps`, with\n@@ -121,12 +136,14 @@ def dumps(obj, app=None, **kwargs):\n         )\n \n         if isinstance(rv, str):\n-            return rv.encode(encoding)\n+            return rv.encode(encoding)  # type: ignore\n \n     return rv\n \n \n-def dump(obj, fp, app=None, **kwargs):\n+def dump(\n+    obj: t.Any, fp: t.IO[str], app: t.Optional[\"Flask\"] = None, **kwargs: t.Any\n+) -> None:\n     \"\"\"Serialize an object to JSON written to a file object.\n \n     Takes the same arguments as the built-in :func:`json.dump`, with\n@@ -150,7 +167,7 @@ def dump(obj, fp, app=None, **kwargs):\n         fp.write(\"\")\n     except TypeError:\n         show_warning = True\n-        fp = io.TextIOWrapper(fp, encoding or \"utf-8\")\n+        fp = io.TextIOWrapper(fp, encoding or \"utf-8\")  # type: ignore\n \n     if show_warning:\n         warnings.warn(\n@@ -163,7 +180,7 @@ def dump(obj, fp, app=None, **kwargs):\n     _json.dump(obj, fp, **kwargs)\n \n \n-def loads(s, app=None, **kwargs):\n+def loads(s: str, app: t.Optional[\"Flask\"] = None, **kwargs: t.Any) -> t.Any:\n     \"\"\"Deserialize an object from a string of JSON.\n \n     Takes the same arguments as the built-in :func:`json.loads`, with\n@@ -199,7 +216,7 @@ def loads(s, app=None, **kwargs):\n     return _json.loads(s, **kwargs)\n \n \n-def load(fp, app=None, **kwargs):\n+def load(fp: t.IO[str], app: t.Optional[\"Flask\"] = None, **kwargs: t.Any) -> t.Any:\n     \"\"\"Deserialize an object from JSON read from a file object.\n \n     Takes the same arguments as the built-in :func:`json.load`, with\n@@ -227,12 +244,12 @@ def load(fp, app=None, **kwargs):\n         )\n \n         if isinstance(fp.read(0), bytes):\n-            fp = io.TextIOWrapper(fp, encoding)\n+            fp = io.TextIOWrapper(fp, encoding)  # type: ignore\n \n     return _json.load(fp, **kwargs)\n \n \n-def htmlsafe_dumps(obj, **kwargs):\n+def htmlsafe_dumps(obj: t.Any, **kwargs: t.Any) -> str:\n     \"\"\"Serialize an object to a string of JSON with :func:`dumps`, then\n     replace HTML-unsafe characters with Unicode escapes and mark the\n     result safe with :class:`~markupsafe.Markup`.\n@@ -256,7 +273,7 @@ def htmlsafe_dumps(obj, **kwargs):\n     return _jinja_htmlsafe_dumps(obj, dumps=dumps, **kwargs)\n \n \n-def htmlsafe_dump(obj, fp, **kwargs):\n+def htmlsafe_dump(obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n     \"\"\"Serialize an object to JSON written to a file object, replacing\n     HTML-unsafe characters with Unicode escapes. See\n     :func:`htmlsafe_dumps` and :func:`dumps`.\n@@ -264,7 +281,7 @@ def htmlsafe_dump(obj, fp, **kwargs):\n     fp.write(htmlsafe_dumps(obj, **kwargs))\n \n \n-def jsonify(*args, **kwargs):\n+def jsonify(*args: t.Any, **kwargs: t.Any) -> \"Response\":\n     \"\"\"Serialize data to JSON and wrap it in a :class:`~flask.Response`\n     with the :mimetype:`application/json` mimetype.\n \n\n@@ -40,6 +40,7 @@ be processed before ``dict``.\n \n     app.session_interface.serializer.register(TagOrderedDict, index=0)\n \"\"\"\n+import typing as t\n from base64 import b64decode\n from base64 import b64encode\n from datetime import datetime\n@@ -60,27 +61,27 @@ class JSONTag:\n \n     #: The tag to mark the serialized object with. If ``None``, this tag is\n     #: only used as an intermediate step during tagging.\n-    key = None\n+    key: t.Optional[str] = None\n \n-    def __init__(self, serializer):\n+    def __init__(self, serializer: \"TaggedJSONSerializer\") -> None:\n         \"\"\"Create a tagger for the given serializer.\"\"\"\n         self.serializer = serializer\n \n-    def check(self, value):\n+    def check(self, value: t.Any) -> bool:\n         \"\"\"Check if the given value should be tagged by this tag.\"\"\"\n         raise NotImplementedError\n \n-    def to_json(self, value):\n+    def to_json(self, value: t.Any) -> t.Any:\n         \"\"\"Convert the Python object to an object that is a valid JSON type.\n         The tag will be added later.\"\"\"\n         raise NotImplementedError\n \n-    def to_python(self, value):\n+    def to_python(self, value: t.Any) -> t.Any:\n         \"\"\"Convert the JSON representation back to the correct type. The tag\n         will already be removed.\"\"\"\n         raise NotImplementedError\n \n-    def tag(self, value):\n+    def tag(self, value: t.Any) -> t.Any:\n         \"\"\"Convert the value to a valid JSON type and add the tag structure\n         around it.\"\"\"\n         return {self.key: self.to_json(value)}\n@@ -96,18 +97,18 @@ class TagDict(JSONTag):\n     __slots__ = ()\n     key = \" di\"\n \n-    def check(self, value):\n+    def check(self, value: t.Any) -> bool:\n         return (\n             isinstance(value, dict)\n             and len(value) == 1\n             and next(iter(value)) in self.serializer.tags\n         )\n \n-    def to_json(self, value):\n+    def to_json(self, value: t.Any) -> t.Any:\n         key = next(iter(value))\n         return {f\"{key}__\": self.serializer.tag(value[key])}\n \n-    def to_python(self, value):\n+    def to_python(self, value: t.Any) -> t.Any:\n         key = next(iter(value))\n         return {key[:-2]: value[key]}\n \n@@ -115,10 +116,10 @@ class TagDict(JSONTag):\n class PassDict(JSONTag):\n     __slots__ = ()\n \n-    def check(self, value):\n+    def check(self, value: t.Any) -> bool:\n         return isinstance(value, dict)\n \n-    def to_json(self, value):\n+    def to_json(self, value: t.Any) -> t.Any:\n         # JSON objects may only have string keys, so don't bother tagging the\n         # key here.\n         return {k: self.serializer.tag(v) for k, v in value.items()}\n@@ -130,23 +131,23 @@ class TagTuple(JSONTag):\n     __slots__ = ()\n     key = \" t\"\n \n-    def check(self, value):\n+    def check(self, value: t.Any) -> bool:\n         return isinstance(value, tuple)\n \n-    def to_json(self, value):\n+    def to_json(self, value: t.Any) -> t.Any:\n         return [self.serializer.tag(item) for item in value]\n \n-    def to_python(self, value):\n+    def to_python(self, value: t.Any) -> t.Any:\n         return tuple(value)\n \n \n class PassList(JSONTag):\n     __slots__ = ()\n \n-    def check(self, value):\n+    def check(self, value: t.Any) -> bool:\n         return isinstance(value, list)\n \n-    def to_json(self, value):\n+    def to_json(self, value: t.Any) -> t.Any:\n         return [self.serializer.tag(item) for item in value]\n \n     tag = to_json\n@@ -156,13 +157,13 @@ class TagBytes(JSONTag):\n     __slots__ = ()\n     key = \" b\"\n \n-    def check(self, value):\n+    def check(self, value: t.Any) -> bool:\n         return isinstance(value, bytes)\n \n-    def to_json(self, value):\n+    def to_json(self, value: t.Any) -> t.Any:\n         return b64encode(value).decode(\"ascii\")\n \n-    def to_python(self, value):\n+    def to_python(self, value: t.Any) -> t.Any:\n         return b64decode(value)\n \n \n@@ -174,13 +175,13 @@ class TagMarkup(JSONTag):\n     __slots__ = ()\n     key = \" m\"\n \n-    def check(self, value):\n+    def check(self, value: t.Any) -> bool:\n         return callable(getattr(value, \"__html__\", None))\n \n-    def to_json(self, value):\n+    def to_json(self, value: t.Any) -> t.Any:\n         return str(value.__html__())\n \n-    def to_python(self, value):\n+    def to_python(self, value: t.Any) -> t.Any:\n         return Markup(value)\n \n \n@@ -188,13 +189,13 @@ class TagUUID(JSONTag):\n     __slots__ = ()\n     key = \" u\"\n \n-    def check(self, value):\n+    def check(self, value: t.Any) -> bool:\n         return isinstance(value, UUID)\n \n-    def to_json(self, value):\n+    def to_json(self, value: t.Any) -> t.Any:\n         return value.hex\n \n-    def to_python(self, value):\n+    def to_python(self, value: t.Any) -> t.Any:\n         return UUID(value)\n \n \n@@ -202,13 +203,13 @@ class TagDateTime(JSONTag):\n     __slots__ = ()\n     key = \" d\"\n \n-    def check(self, value):\n+    def check(self, value: t.Any) -> bool:\n         return isinstance(value, datetime)\n \n-    def to_json(self, value):\n+    def to_json(self, value: t.Any) -> t.Any:\n         return http_date(value)\n \n-    def to_python(self, value):\n+    def to_python(self, value: t.Any) -> t.Any:\n         return parse_date(value)\n \n \n@@ -242,14 +243,19 @@ class TaggedJSONSerializer:\n         TagDateTime,\n     ]\n \n-    def __init__(self):\n-        self.tags = {}\n-        self.order = []\n+    def __init__(self) -> None:\n+        self.tags: t.Dict[str, JSONTag] = {}\n+        self.order: t.List[JSONTag] = []\n \n         for cls in self.default_tags:\n             self.register(cls)\n \n-    def register(self, tag_class, force=False, index=None):\n+    def register(\n+        self,\n+        tag_class: t.Type[JSONTag],\n+        force: bool = False,\n+        index: t.Optional[int] = None,\n+    ) -> None:\n         \"\"\"Register a new tag with this serializer.\n \n         :param tag_class: tag class to register. Will be instantiated with this\n@@ -277,7 +283,7 @@ class TaggedJSONSerializer:\n         else:\n             self.order.insert(index, tag)\n \n-    def tag(self, value):\n+    def tag(self, value: t.Any) -> t.Dict[str, t.Any]:\n         \"\"\"Convert a value to a tagged representation if necessary.\"\"\"\n         for tag in self.order:\n             if tag.check(value):\n@@ -285,7 +291,7 @@ class TaggedJSONSerializer:\n \n         return value\n \n-    def untag(self, value):\n+    def untag(self, value: t.Dict[str, t.Any]) -> t.Any:\n         \"\"\"Convert a tagged representation back to the original type.\"\"\"\n         if len(value) != 1:\n             return value\n@@ -297,10 +303,10 @@ class TaggedJSONSerializer:\n \n         return self.tags[key].to_python(value[key])\n \n-    def dumps(self, value):\n+    def dumps(self, value: t.Any) -> str:\n         \"\"\"Tag the value and dump it to a compact JSON string.\"\"\"\n         return dumps(self.tag(value), separators=(\",\", \":\"))\n \n-    def loads(self, value):\n+    def loads(self, value: str) -> t.Any:\n         \"\"\"Load data from a JSON string and deserialized any tagged objects.\"\"\"\n         return loads(value, object_hook=self.untag)\n\n@@ -1,13 +1,17 @@\n import logging\n import sys\n+import typing as t\n \n from werkzeug.local import LocalProxy\n \n from .globals import request\n \n+if t.TYPE_CHECKING:\n+    from .app import Flask\n+\n \n @LocalProxy\n-def wsgi_errors_stream():\n+def wsgi_errors_stream() -> t.TextIO:\n     \"\"\"Find the most appropriate error stream for the application. If a request\n     is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n \n@@ -19,7 +23,7 @@ def wsgi_errors_stream():\n     return request.environ[\"wsgi.errors\"] if request else sys.stderr\n \n \n-def has_level_handler(logger):\n+def has_level_handler(logger: logging.Logger) -> bool:\n     \"\"\"Check if there is a handler in the logging chain that will handle the\n     given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n     \"\"\"\n@@ -33,20 +37,20 @@ def has_level_handler(logger):\n         if not current.propagate:\n             break\n \n-        current = current.parent\n+        current = current.parent  # type: ignore\n \n     return False\n \n \n #: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n #: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\n-default_handler = logging.StreamHandler(wsgi_errors_stream)\n+default_handler = logging.StreamHandler(wsgi_errors_stream)  # type: ignore\n default_handler.setFormatter(\n     logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n )\n \n \n-def create_logger(app):\n+def create_logger(app: \"Flask\") -> logging.Logger:\n     \"\"\"Get the Flask app's logger and configure it if needed.\n \n     The logger name will be the same as\n\n@@ -2,8 +2,11 @@ import importlib.util\n import os\n import pkgutil\n import sys\n+import typing as t\n from collections import defaultdict\n from functools import update_wrapper\n+from json import JSONDecoder\n+from json import JSONEncoder\n \n from jinja2 import FileSystemLoader\n from werkzeug.exceptions import default_exceptions\n@@ -14,17 +17,28 @@ from .globals import current_app\n from .helpers import locked_cached_property\n from .helpers import send_from_directory\n from .templating import _default_template_ctx_processor\n+from .typing import AfterRequestCallable\n+from .typing import AppOrBlueprintKey\n+from .typing import BeforeRequestCallable\n+from .typing import ErrorHandlerCallable\n+from .typing import TeardownCallable\n+from .typing import TemplateContextProcessorCallable\n+from .typing import URLDefaultCallable\n+from .typing import URLValuePreprocessorCallable\n+\n+if t.TYPE_CHECKING:\n+    from .wrappers import Response\n \n # a singleton sentinel value for parameter defaults\n _sentinel = object()\n \n \n-def setupmethod(f):\n+def setupmethod(f: t.Callable) -> t.Callable:\n     \"\"\"Wraps a method so that it performs a check in debug mode if the\n     first request was already handled.\n     \"\"\"\n \n-    def wrapper_func(self, *args, **kwargs):\n+    def wrapper_func(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\n         if self._is_setup_finished():\n             raise AssertionError(\n                 \"A setup function was called after the first request \"\n@@ -60,24 +74,24 @@ class Scaffold:\n     \"\"\"\n \n     name: str\n-    _static_folder = None\n-    _static_url_path = None\n+    _static_folder: t.Optional[str] = None\n+    _static_url_path: t.Optional[str] = None\n \n     #: JSON encoder class used by :func:`flask.json.dumps`. If a\n     #: blueprint sets this, it will be used instead of the app's value.\n-    json_encoder = None\n+    json_encoder: t.Optional[t.Type[JSONEncoder]] = None\n \n     #: JSON decoder class used by :func:`flask.json.loads`. If a\n     #: blueprint sets this, it will be used instead of the app's value.\n-    json_decoder = None\n+    json_decoder: t.Optional[t.Type[JSONDecoder]] = None\n \n     def __init__(\n         self,\n-        import_name,\n-        static_folder=None,\n-        static_url_path=None,\n-        template_folder=None,\n-        root_path=None,\n+        import_name: str,\n+        static_folder: t.Optional[str] = None,\n+        static_url_path: t.Optional[str] = None,\n+        template_folder: t.Optional[str] = None,\n+        root_path: t.Optional[str] = None,\n     ):\n         #: The name of the package or module that this object belongs\n         #: to. Do not change this once it is set by the constructor.\n@@ -110,7 +124,7 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.view_functions = {}\n+        self.view_functions: t.Dict[str, t.Callable] = {}\n \n         #: A data structure of registered error handlers, in the format\n         #: ``{scope: {code: {class: handler}}}```. The ``scope`` key is\n@@ -125,7 +139,10 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.error_handler_spec = defaultdict(lambda: defaultdict(dict))\n+        self.error_handler_spec: t.Dict[\n+            AppOrBlueprintKey,\n+            t.Dict[t.Optional[int], t.Dict[t.Type[Exception], ErrorHandlerCallable]],\n+        ] = defaultdict(lambda: defaultdict(dict))\n \n         #: A data structure of functions to call at the beginning of\n         #: each request, in the format ``{scope: [functions]}``. The\n@@ -137,7 +154,9 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.before_request_funcs = defaultdict(list)\n+        self.before_request_funcs: t.Dict[\n+            AppOrBlueprintKey, t.List[BeforeRequestCallable]\n+        ] = defaultdict(list)\n \n         #: A data structure of functions to call at the end of each\n         #: request, in the format ``{scope: [functions]}``. The\n@@ -149,7 +168,9 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.after_request_funcs = defaultdict(list)\n+        self.after_request_funcs: t.Dict[\n+            AppOrBlueprintKey, t.List[AfterRequestCallable]\n+        ] = defaultdict(list)\n \n         #: A data structure of functions to call at the end of each\n         #: request even if an exception is raised, in the format\n@@ -162,7 +183,9 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.teardown_request_funcs = defaultdict(list)\n+        self.teardown_request_funcs: t.Dict[\n+            AppOrBlueprintKey, t.List[TeardownCallable]\n+        ] = defaultdict(list)\n \n         #: A data structure of functions to call to pass extra context\n         #: values when rendering templates, in the format\n@@ -175,9 +198,9 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.template_context_processors = defaultdict(\n-            list, {None: [_default_template_ctx_processor]}\n-        )\n+        self.template_context_processors: t.Dict[\n+            AppOrBlueprintKey, t.List[TemplateContextProcessorCallable]\n+        ] = defaultdict(list, {None: [_default_template_ctx_processor]})\n \n         #: A data structure of functions to call to modify the keyword\n         #: arguments passed to the view function, in the format\n@@ -190,7 +213,10 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.url_value_preprocessors = defaultdict(list)\n+        self.url_value_preprocessors: t.Dict[\n+            AppOrBlueprintKey,\n+            t.List[URLValuePreprocessorCallable],\n+        ] = defaultdict(list)\n \n         #: A data structure of functions to call to modify the keyword\n         #: arguments when generating URLs, in the format\n@@ -203,31 +229,35 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.url_default_functions = defaultdict(list)\n+        self.url_default_functions: t.Dict[\n+            AppOrBlueprintKey, t.List[URLDefaultCallable]\n+        ] = defaultdict(list)\n \n-    def __repr__(self):\n+    def __repr__(self) -> str:\n         return f\"<{type(self).__name__} {self.name!r}>\"\n \n-    def _is_setup_finished(self):\n+    def _is_setup_finished(self) -> bool:\n         raise NotImplementedError\n \n     @property\n-    def static_folder(self):\n+    def static_folder(self) -> t.Optional[str]:\n         \"\"\"The absolute path to the configured static folder. ``None``\n         if no static folder is set.\n         \"\"\"\n         if self._static_folder is not None:\n             return os.path.join(self.root_path, self._static_folder)\n+        else:\n+            return None\n \n     @static_folder.setter\n-    def static_folder(self, value):\n+    def static_folder(self, value: t.Optional[str]) -> None:\n         if value is not None:\n             value = os.fspath(value).rstrip(r\"\\/\")\n \n         self._static_folder = value\n \n     @property\n-    def has_static_folder(self):\n+    def has_static_folder(self) -> bool:\n         \"\"\"``True`` if :attr:`static_folder` is set.\n \n         .. versionadded:: 0.5\n@@ -235,7 +265,7 @@ class Scaffold:\n         return self.static_folder is not None\n \n     @property\n-    def static_url_path(self):\n+    def static_url_path(self) -> t.Optional[str]:\n         \"\"\"The URL prefix that the static route will be accessible from.\n \n         If it was not configured during init, it is derived from\n@@ -248,14 +278,16 @@ class Scaffold:\n             basename = os.path.basename(self.static_folder)\n             return f\"/{basename}\".rstrip(\"/\")\n \n+        return None\n+\n     @static_url_path.setter\n-    def static_url_path(self, value):\n+    def static_url_path(self, value: t.Optional[str]) -> None:\n         if value is not None:\n             value = value.rstrip(\"/\")\n \n         self._static_url_path = value\n \n-    def get_send_file_max_age(self, filename):\n+    def get_send_file_max_age(self, filename: str) -> t.Optional[int]:\n         \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n         value for a given file path if it wasn't passed.\n \n@@ -276,7 +308,7 @@ class Scaffold:\n \n         return int(value.total_seconds())\n \n-    def send_static_file(self, filename):\n+    def send_static_file(self, filename: str) -> \"Response\":\n         \"\"\"The view function used to serve files from\n         :attr:`static_folder`. A route is automatically registered for\n         this view at :attr:`static_url_path` if :attr:`static_folder` is\n@@ -290,10 +322,12 @@ class Scaffold:\n         # send_file only knows to call get_send_file_max_age on the app,\n         # call it here so it works for blueprints too.\n         max_age = self.get_send_file_max_age(filename)\n-        return send_from_directory(self.static_folder, filename, max_age=max_age)\n+        return send_from_directory(\n+            t.cast(str, self.static_folder), filename, max_age=max_age\n+        )\n \n     @locked_cached_property\n-    def jinja_loader(self):\n+    def jinja_loader(self) -> t.Optional[FileSystemLoader]:\n         \"\"\"The Jinja loader for this object's templates. By default this\n         is a class :class:`jinja2.loaders.FileSystemLoader` to\n         :attr:`template_folder` if it is set.\n@@ -302,8 +336,10 @@ class Scaffold:\n         \"\"\"\n         if self.template_folder is not None:\n             return FileSystemLoader(os.path.join(self.root_path, self.template_folder))\n+        else:\n+            return None\n \n-    def open_resource(self, resource, mode=\"rb\"):\n+    def open_resource(self, resource: str, mode: str = \"rb\") -> t.IO[t.AnyStr]:\n         \"\"\"Open a resource file relative to :attr:`root_path` for\n         reading.\n \n@@ -326,48 +362,48 @@ class Scaffold:\n \n         return open(os.path.join(self.root_path, resource), mode)\n \n-    def _method_route(self, method, rule, options):\n+    def _method_route(self, method: str, rule: str, options: dict) -> t.Callable:\n         if \"methods\" in options:\n             raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n \n         return self.route(rule, methods=[method], **options)\n \n-    def get(self, rule, **options):\n+    def get(self, rule: str, **options: t.Any) -> t.Callable:\n         \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n \n         .. versionadded:: 2.0\n         \"\"\"\n         return self._method_route(\"GET\", rule, options)\n \n-    def post(self, rule, **options):\n+    def post(self, rule: str, **options: t.Any) -> t.Callable:\n         \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n \n         .. versionadded:: 2.0\n         \"\"\"\n         return self._method_route(\"POST\", rule, options)\n \n-    def put(self, rule, **options):\n+    def put(self, rule: str, **options: t.Any) -> t.Callable:\n         \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n \n         .. versionadded:: 2.0\n         \"\"\"\n         return self._method_route(\"PUT\", rule, options)\n \n-    def delete(self, rule, **options):\n+    def delete(self, rule: str, **options: t.Any) -> t.Callable:\n         \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n \n         .. versionadded:: 2.0\n         \"\"\"\n         return self._method_route(\"DELETE\", rule, options)\n \n-    def patch(self, rule, **options):\n+    def patch(self, rule: str, **options: t.Any) -> t.Callable:\n         \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n \n         .. versionadded:: 2.0\n         \"\"\"\n         return self._method_route(\"PATCH\", rule, options)\n \n-    def route(self, rule, **options):\n+    def route(self, rule: str, **options: t.Any) -> t.Callable:\n         \"\"\"Decorate a view function to register it with the given URL\n         rule and options. Calls :meth:`add_url_rule`, which has more\n         details about the implementation.\n@@ -391,7 +427,7 @@ class Scaffold:\n             :class:`~werkzeug.routing.Rule` object.\n         \"\"\"\n \n-        def decorator(f):\n+        def decorator(f: t.Callable) -> t.Callable:\n             endpoint = options.pop(\"endpoint\", None)\n             self.add_url_rule(rule, endpoint, f, **options)\n             return f\n@@ -401,12 +437,12 @@ class Scaffold:\n     @setupmethod\n     def add_url_rule(\n         self,\n-        rule,\n-        endpoint=None,\n-        view_func=None,\n-        provide_automatic_options=None,\n-        **options,\n-    ):\n+        rule: str,\n+        endpoint: t.Optional[str] = None,\n+        view_func: t.Optional[t.Callable] = None,\n+        provide_automatic_options: t.Optional[bool] = None,\n+        **options: t.Any,\n+    ) -> t.Callable:\n         \"\"\"Register a rule for routing incoming requests and building\n         URLs. The :meth:`route` decorator is a shortcut to call this\n         with the ``view_func`` argument. These are equivalent:\n@@ -466,7 +502,7 @@ class Scaffold:\n         \"\"\"\n         raise NotImplementedError\n \n-    def endpoint(self, endpoint):\n+    def endpoint(self, endpoint: str) -> t.Callable:\n         \"\"\"Decorate a view function to register it for the given\n         endpoint. Used if a rule is added without a ``view_func`` with\n         :meth:`add_url_rule`.\n@@ -490,7 +526,7 @@ class Scaffold:\n         return decorator\n \n     @setupmethod\n-    def before_request(self, f):\n+    def before_request(self, f: BeforeRequestCallable) -> BeforeRequestCallable:\n         \"\"\"Register a function to run before each request.\n \n         For example, this can be used to open a database connection, or\n@@ -512,7 +548,7 @@ class Scaffold:\n         return f\n \n     @setupmethod\n-    def after_request(self, f):\n+    def after_request(self, f: AfterRequestCallable) -> AfterRequestCallable:\n         \"\"\"Register a function to run after each request to this object.\n \n         The function is called with the response object, and must return\n@@ -528,7 +564,7 @@ class Scaffold:\n         return f\n \n     @setupmethod\n-    def teardown_request(self, f):\n+    def teardown_request(self, f: TeardownCallable) -> TeardownCallable:\n         \"\"\"Register a function to be run at the end of each request,\n         regardless of whether there was an exception or not.  These functions\n         are executed when the request context is popped, even if not an\n@@ -567,13 +603,17 @@ class Scaffold:\n         return f\n \n     @setupmethod\n-    def context_processor(self, f):\n+    def context_processor(\n+        self, f: TemplateContextProcessorCallable\n+    ) -> TemplateContextProcessorCallable:\n         \"\"\"Registers a template context processor function.\"\"\"\n         self.template_context_processors[None].append(f)\n         return f\n \n     @setupmethod\n-    def url_value_preprocessor(self, f):\n+    def url_value_preprocessor(\n+        self, f: URLValuePreprocessorCallable\n+    ) -> URLValuePreprocessorCallable:\n         \"\"\"Register a URL value preprocessor function for all view\n         functions in the application. These functions will be called before the\n         :meth:`before_request` functions.\n@@ -590,7 +630,7 @@ class Scaffold:\n         return f\n \n     @setupmethod\n-    def url_defaults(self, f):\n+    def url_defaults(self, f: URLDefaultCallable) -> URLDefaultCallable:\n         \"\"\"Callback function for URL defaults for all view functions of the\n         application.  It's called with the endpoint and values and should\n         update the values passed in place.\n@@ -599,7 +639,9 @@ class Scaffold:\n         return f\n \n     @setupmethod\n-    def errorhandler(self, code_or_exception):\n+    def errorhandler(\n+        self, code_or_exception: t.Union[t.Type[Exception], int]\n+    ) -> t.Callable:\n         \"\"\"Register a function to handle errors by code or exception class.\n \n         A decorator that is used to register a function given an\n@@ -629,14 +671,18 @@ class Scaffold:\n                                   an arbitrary exception\n         \"\"\"\n \n-        def decorator(f):\n+        def decorator(f: ErrorHandlerCallable) -> ErrorHandlerCallable:\n             self.register_error_handler(code_or_exception, f)\n             return f\n \n         return decorator\n \n     @setupmethod\n-    def register_error_handler(self, code_or_exception, f):\n+    def register_error_handler(\n+        self,\n+        code_or_exception: t.Union[t.Type[Exception], int],\n+        f: ErrorHandlerCallable,\n+    ) -> None:\n         \"\"\"Alternative error attach function to the :meth:`errorhandler`\n         decorator that is more straightforward to use for non decorator\n         usage.\n@@ -662,7 +708,9 @@ class Scaffold:\n         self.error_handler_spec[None][code][exc_class] = self.ensure_sync(f)\n \n     @staticmethod\n-    def _get_exc_class_and_code(exc_class_or_code):\n+    def _get_exc_class_and_code(\n+        exc_class_or_code: t.Union[t.Type[Exception], int]\n+    ) -> t.Tuple[t.Type[Exception], t.Optional[int]]:\n         \"\"\"Get the exception class being handled. For HTTP status codes\n         or ``HTTPException`` subclasses, return both the exception and\n         status code.\n@@ -670,6 +718,7 @@ class Scaffold:\n         :param exc_class_or_code: Any exception class, or an HTTP status\n             code as an integer.\n         \"\"\"\n+        exc_class: t.Type[Exception]\n         if isinstance(exc_class_or_code, int):\n             exc_class = default_exceptions[exc_class_or_code]\n         else:\n@@ -684,11 +733,11 @@ class Scaffold:\n         else:\n             return exc_class, None\n \n-    def ensure_sync(self, func):\n+    def ensure_sync(self, func: t.Callable) -> t.Callable:\n         raise NotImplementedError()\n \n \n-def _endpoint_from_view_func(view_func):\n+def _endpoint_from_view_func(view_func: t.Callable) -> str:\n     \"\"\"Internal helper that returns the default endpoint for a given\n     function.  This always is the function name.\n     \"\"\"\n@@ -696,7 +745,7 @@ def _endpoint_from_view_func(view_func):\n     return view_func.__name__\n \n \n-def get_root_path(import_name):\n+def get_root_path(import_name: str) -> str:\n     \"\"\"Find the root path of a package, or the path that contains a\n     module. If it cannot be found, returns the current working\n     directory.\n@@ -721,7 +770,7 @@ def get_root_path(import_name):\n         return os.getcwd()\n \n     if hasattr(loader, \"get_filename\"):\n-        filepath = loader.get_filename(import_name)\n+        filepath = loader.get_filename(import_name)  # type: ignore\n     else:\n         # Fall back to imports.\n         __import__(import_name)\n@@ -822,7 +871,7 @@ def _find_package_path(root_mod_name):\n     return package_path\n \n \n-def find_package(import_name):\n+def find_package(import_name: str):\n     \"\"\"Find the prefix that a package is installed under, and the path\n     that it would be imported from.\n \n\n@@ -1,4 +1,5 @@\n import hashlib\n+import typing as t\n import warnings\n from collections.abc import MutableMapping\n from datetime import datetime\n@@ -10,17 +11,21 @@ from werkzeug.datastructures import CallbackDict\n from .helpers import is_ip\n from .json.tag import TaggedJSONSerializer\n \n+if t.TYPE_CHECKING:\n+    from .app import Flask\n+    from .wrappers import Request, Response\n+\n \n class SessionMixin(MutableMapping):\n     \"\"\"Expands a basic dictionary with session attributes.\"\"\"\n \n     @property\n-    def permanent(self):\n+    def permanent(self) -> bool:\n         \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n         return self.get(\"_permanent\", False)\n \n     @permanent.setter\n-    def permanent(self, value):\n+    def permanent(self, value: bool) -> None:\n         self[\"_permanent\"] = bool(value)\n \n     #: Some implementations can detect whether a session is newly\n@@ -61,22 +66,22 @@ class SecureCookieSession(CallbackDict, SessionMixin):\n     #: different users.\n     accessed = False\n \n-    def __init__(self, initial=None):\n-        def on_update(self):\n+    def __init__(self, initial: t.Any = None) -> None:\n+        def on_update(self) -> None:\n             self.modified = True\n             self.accessed = True\n \n         super().__init__(initial, on_update)\n \n-    def __getitem__(self, key):\n+    def __getitem__(self, key: str) -> t.Any:\n         self.accessed = True\n         return super().__getitem__(key)\n \n-    def get(self, key, default=None):\n+    def get(self, key: str, default: t.Any = None) -> t.Any:\n         self.accessed = True\n         return super().get(key, default)\n \n-    def setdefault(self, key, default=None):\n+    def setdefault(self, key: str, default: t.Any = None) -> t.Any:\n         self.accessed = True\n         return super().setdefault(key, default)\n \n@@ -87,14 +92,14 @@ class NullSession(SecureCookieSession):\n     but fail on setting.\n     \"\"\"\n \n-    def _fail(self, *args, **kwargs):\n+    def _fail(self, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:\n         raise RuntimeError(\n             \"The session is unavailable because no secret \"\n             \"key was set.  Set the secret_key on the \"\n             \"application to something unique and secret.\"\n         )\n \n-    __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail\n+    __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail  # type: ignore # noqa: B950\n     del _fail\n \n \n@@ -141,7 +146,7 @@ class SessionInterface:\n     #: .. versionadded:: 0.10\n     pickle_based = False\n \n-    def make_null_session(self, app):\n+    def make_null_session(self, app: \"Flask\") -> NullSession:\n         \"\"\"Creates a null session which acts as a replacement object if the\n         real session support could not be loaded due to a configuration\n         error.  This mainly aids the user experience because the job of the\n@@ -153,7 +158,7 @@ class SessionInterface:\n         \"\"\"\n         return self.null_session_class()\n \n-    def is_null_session(self, obj):\n+    def is_null_session(self, obj: object) -> bool:\n         \"\"\"Checks if a given object is a null session.  Null sessions are\n         not asked to be saved.\n \n@@ -162,14 +167,14 @@ class SessionInterface:\n         \"\"\"\n         return isinstance(obj, self.null_session_class)\n \n-    def get_cookie_name(self, app):\n+    def get_cookie_name(self, app: \"Flask\") -> str:\n         \"\"\"Returns the name of the session cookie.\n \n         Uses ``app.session_cookie_name`` which is set to ``SESSION_COOKIE_NAME``\n         \"\"\"\n         return app.session_cookie_name\n \n-    def get_cookie_domain(self, app):\n+    def get_cookie_domain(self, app: \"Flask\") -> t.Optional[str]:\n         \"\"\"Returns the domain that should be set for the session cookie.\n \n         Uses ``SESSION_COOKIE_DOMAIN`` if it is configured, otherwise\n@@ -227,7 +232,7 @@ class SessionInterface:\n         app.config[\"SESSION_COOKIE_DOMAIN\"] = rv\n         return rv\n \n-    def get_cookie_path(self, app):\n+    def get_cookie_path(self, app: \"Flask\") -> str:\n         \"\"\"Returns the path for which the cookie should be valid.  The\n         default implementation uses the value from the ``SESSION_COOKIE_PATH``\n         config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n@@ -235,27 +240,29 @@ class SessionInterface:\n         \"\"\"\n         return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]\n \n-    def get_cookie_httponly(self, app):\n+    def get_cookie_httponly(self, app: \"Flask\") -> bool:\n         \"\"\"Returns True if the session cookie should be httponly.  This\n         currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n         config var.\n         \"\"\"\n         return app.config[\"SESSION_COOKIE_HTTPONLY\"]\n \n-    def get_cookie_secure(self, app):\n+    def get_cookie_secure(self, app: \"Flask\") -> bool:\n         \"\"\"Returns True if the cookie should be secure.  This currently\n         just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n         \"\"\"\n         return app.config[\"SESSION_COOKIE_SECURE\"]\n \n-    def get_cookie_samesite(self, app):\n+    def get_cookie_samesite(self, app: \"Flask\") -> str:\n         \"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n         ``SameSite`` attribute. This currently just returns the value of\n         the :data:`SESSION_COOKIE_SAMESITE` setting.\n         \"\"\"\n         return app.config[\"SESSION_COOKIE_SAMESITE\"]\n \n-    def get_expiration_time(self, app, session):\n+    def get_expiration_time(\n+        self, app: \"Flask\", session: SessionMixin\n+    ) -> t.Optional[datetime]:\n         \"\"\"A helper method that returns an expiration date for the session\n         or ``None`` if the session is linked to the browser session.  The\n         default implementation returns now + the permanent session\n@@ -263,8 +270,9 @@ class SessionInterface:\n         \"\"\"\n         if session.permanent:\n             return datetime.utcnow() + app.permanent_session_lifetime\n+        return None\n \n-    def should_set_cookie(self, app, session):\n+    def should_set_cookie(self, app: \"Flask\", session: SessionMixin) -> bool:\n         \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n         should be set for this session cookie for this response. If the session\n         has been modified, the cookie is set. If the session is permanent and\n@@ -280,7 +288,9 @@ class SessionInterface:\n             session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n         )\n \n-    def open_session(self, app, request):\n+    def open_session(\n+        self, app: \"Flask\", request: \"Request\"\n+    ) -> t.Optional[SessionMixin]:\n         \"\"\"This method has to be implemented and must either return ``None``\n         in case the loading failed because of a configuration error or an\n         instance of a session object which implements a dictionary like\n@@ -288,7 +298,9 @@ class SessionInterface:\n         \"\"\"\n         raise NotImplementedError()\n \n-    def save_session(self, app, session, response):\n+    def save_session(\n+        self, app: \"Flask\", session: SessionMixin, response: \"Response\"\n+    ) -> None:\n         \"\"\"This is called for actual sessions returned by :meth:`open_session`\n         at the end of the request.  This is still called during a request\n         context so if you absolutely need access to the request you can do\n@@ -319,7 +331,9 @@ class SecureCookieSessionInterface(SessionInterface):\n     serializer = session_json_serializer\n     session_class = SecureCookieSession\n \n-    def get_signing_serializer(self, app):\n+    def get_signing_serializer(\n+        self, app: \"Flask\"\n+    ) -> t.Optional[URLSafeTimedSerializer]:\n         if not app.secret_key:\n             return None\n         signer_kwargs = dict(\n@@ -332,7 +346,9 @@ class SecureCookieSessionInterface(SessionInterface):\n             signer_kwargs=signer_kwargs,\n         )\n \n-    def open_session(self, app, request):\n+    def open_session(\n+        self, app: \"Flask\", request: \"Request\"\n+    ) -> t.Optional[SecureCookieSession]:\n         s = self.get_signing_serializer(app)\n         if s is None:\n             return None\n@@ -346,7 +362,9 @@ class SecureCookieSessionInterface(SessionInterface):\n         except BadSignature:\n             return self.session_class()\n \n-    def save_session(self, app, session, response):\n+    def save_session(\n+        self, app: \"Flask\", session: SessionMixin, response: \"Response\"\n+    ) -> None:\n         name = self.get_cookie_name(app)\n         domain = self.get_cookie_domain(app)\n         path = self.get_cookie_path(app)\n@@ -372,10 +390,10 @@ class SecureCookieSessionInterface(SessionInterface):\n \n         httponly = self.get_cookie_httponly(app)\n         expires = self.get_expiration_time(app, session)\n-        val = self.get_signing_serializer(app).dumps(dict(session))\n+        val = self.get_signing_serializer(app).dumps(dict(session))  # type: ignore\n         response.set_cookie(\n             name,\n-            val,\n+            val,  # type: ignore\n             expires=expires,\n             httponly=httponly,\n             domain=domain,\n\n@@ -1,3 +1,5 @@\n+import typing as t\n+\n try:\n     from blinker import Namespace\n \n@@ -5,8 +7,8 @@ try:\n except ImportError:\n     signals_available = False\n \n-    class Namespace:\n-        def signal(self, name, doc=None):\n+    class Namespace:  # type: ignore\n+        def signal(self, name: str, doc: t.Optional[str] = None) -> \"_FakeSignal\":\n             return _FakeSignal(name, doc)\n \n     class _FakeSignal:\n@@ -16,14 +18,14 @@ except ImportError:\n         will just ignore the arguments and do nothing instead.\n         \"\"\"\n \n-        def __init__(self, name, doc=None):\n+        def __init__(self, name: str, doc: t.Optional[str] = None) -> None:\n             self.name = name\n             self.__doc__ = doc\n \n-        def send(self, *args, **kwargs):\n+        def send(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\n             pass\n \n-        def _fail(self, *args, **kwargs):\n+        def _fail(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\n             raise RuntimeError(\n                 \"Signalling support is unavailable because the blinker\"\n                 \" library is not installed.\"\n\n@@ -1,5 +1,8 @@\n+import typing as t\n+\n from jinja2 import BaseLoader\n from jinja2 import Environment as BaseEnvironment\n+from jinja2 import Template\n from jinja2 import TemplateNotFound\n \n from .globals import _app_ctx_stack\n@@ -7,8 +10,12 @@ from .globals import _request_ctx_stack\n from .signals import before_render_template\n from .signals import template_rendered\n \n+if t.TYPE_CHECKING:\n+    from .app import Flask\n+    from .scaffold import Scaffold\n \n-def _default_template_ctx_processor():\n+\n+def _default_template_ctx_processor() -> t.Dict[str, t.Any]:\n     \"\"\"Default template context processor.  Injects `request`,\n     `session` and `g`.\n     \"\"\"\n@@ -29,7 +36,7 @@ class Environment(BaseEnvironment):\n     name of the blueprint to referenced templates if necessary.\n     \"\"\"\n \n-    def __init__(self, app, **options):\n+    def __init__(self, app: \"Flask\", **options: t.Any) -> None:\n         if \"loader\" not in options:\n             options[\"loader\"] = app.create_global_jinja_loader()\n         BaseEnvironment.__init__(self, **options)\n@@ -41,15 +48,19 @@ class DispatchingJinjaLoader(BaseLoader):\n     the blueprint folders.\n     \"\"\"\n \n-    def __init__(self, app):\n+    def __init__(self, app: \"Flask\") -> None:\n         self.app = app\n \n-    def get_source(self, environment, template):\n+    def get_source(\n+        self, environment: Environment, template: str\n+    ) -> t.Tuple[str, t.Optional[str], t.Callable]:\n         if self.app.config[\"EXPLAIN_TEMPLATE_LOADING\"]:\n             return self._get_source_explained(environment, template)\n         return self._get_source_fast(environment, template)\n \n-    def _get_source_explained(self, environment, template):\n+    def _get_source_explained(\n+        self, environment: Environment, template: str\n+    ) -> t.Tuple[str, t.Optional[str], t.Callable]:\n         attempts = []\n         trv = None\n \n@@ -70,7 +81,9 @@ class DispatchingJinjaLoader(BaseLoader):\n             return trv\n         raise TemplateNotFound(template)\n \n-    def _get_source_fast(self, environment, template):\n+    def _get_source_fast(\n+        self, environment: Environment, template: str\n+    ) -> t.Tuple[str, t.Optional[str], t.Callable]:\n         for _srcobj, loader in self._iter_loaders(template):\n             try:\n                 return loader.get_source(environment, template)\n@@ -78,7 +91,9 @@ class DispatchingJinjaLoader(BaseLoader):\n                 continue\n         raise TemplateNotFound(template)\n \n-    def _iter_loaders(self, template):\n+    def _iter_loaders(\n+        self, template: str\n+    ) -> t.Generator[t.Tuple[\"Scaffold\", BaseLoader], None, None]:\n         loader = self.app.jinja_loader\n         if loader is not None:\n             yield self.app, loader\n@@ -88,7 +103,7 @@ class DispatchingJinjaLoader(BaseLoader):\n             if loader is not None:\n                 yield blueprint, loader\n \n-    def list_templates(self):\n+    def list_templates(self) -> t.List[str]:\n         result = set()\n         loader = self.app.jinja_loader\n         if loader is not None:\n@@ -103,7 +118,7 @@ class DispatchingJinjaLoader(BaseLoader):\n         return list(result)\n \n \n-def _render(template, context, app):\n+def _render(template: Template, context: dict, app: \"Flask\") -> str:\n     \"\"\"Renders the template and fires the signal\"\"\"\n \n     before_render_template.send(app, template=template, context=context)\n@@ -112,7 +127,9 @@ def _render(template, context, app):\n     return rv\n \n \n-def render_template(template_name_or_list, **context):\n+def render_template(\n+    template_name_or_list: t.Union[str, t.List[str]], **context: t.Any\n+) -> str:\n     \"\"\"Renders a template from the template folder with the given\n     context.\n \n@@ -131,7 +148,7 @@ def render_template(template_name_or_list, **context):\n     )\n \n \n-def render_template_string(source, **context):\n+def render_template_string(source: str, **context: t.Any) -> str:\n     \"\"\"Renders a template from the given template source string\n     with the given context. Template variables will be autoescaped.\n \n\n@@ -1,5 +1,7 @@\n+import typing as t\n from contextlib import contextmanager\n from copy import copy\n+from types import TracebackType\n \n import werkzeug.test\n from click.testing import CliRunner\n@@ -10,6 +12,11 @@ from werkzeug.wrappers import Request as BaseRequest\n from . import _request_ctx_stack\n from .cli import ScriptInfo\n from .json import dumps as json_dumps\n+from .sessions import SessionMixin\n+\n+if t.TYPE_CHECKING:\n+    from .app import Flask\n+    from .wrappers import Response\n \n \n class EnvironBuilder(werkzeug.test.EnvironBuilder):\n@@ -36,14 +43,14 @@ class EnvironBuilder(werkzeug.test.EnvironBuilder):\n \n     def __init__(\n         self,\n-        app,\n-        path=\"/\",\n-        base_url=None,\n-        subdomain=None,\n-        url_scheme=None,\n-        *args,\n-        **kwargs,\n-    ):\n+        app: \"Flask\",\n+        path: str = \"/\",\n+        base_url: t.Optional[str] = None,\n+        subdomain: t.Optional[str] = None,\n+        url_scheme: t.Optional[str] = None,\n+        *args: t.Any,\n+        **kwargs: t.Any,\n+    ) -> None:\n         assert not (base_url or subdomain or url_scheme) or (\n             base_url is not None\n         ) != bool(\n@@ -74,7 +81,7 @@ class EnvironBuilder(werkzeug.test.EnvironBuilder):\n         self.app = app\n         super().__init__(path, base_url, *args, **kwargs)\n \n-    def json_dumps(self, obj, **kwargs):\n+    def json_dumps(self, obj: t.Any, **kwargs: t.Any) -> str:  # type: ignore\n         \"\"\"Serialize ``obj`` to a JSON-formatted string.\n \n         The serialization will be configured according to the config associated\n@@ -99,9 +106,10 @@ class FlaskClient(Client):\n     Basic usage is outlined in the :doc:`/testing` chapter.\n     \"\"\"\n \n+    application: \"Flask\"\n     preserve_context = False\n \n-    def __init__(self, *args, **kwargs):\n+    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n         super().__init__(*args, **kwargs)\n         self.environ_base = {\n             \"REMOTE_ADDR\": \"127.0.0.1\",\n@@ -109,7 +117,9 @@ class FlaskClient(Client):\n         }\n \n     @contextmanager\n-    def session_transaction(self, *args, **kwargs):\n+    def session_transaction(\n+        self, *args: t.Any, **kwargs: t.Any\n+    ) -> t.Generator[SessionMixin, None, None]:\n         \"\"\"When used in combination with a ``with`` statement this opens a\n         session transaction.  This can be used to modify the session that\n         the test client uses.  Once the ``with`` block is left the session is\n@@ -161,9 +171,14 @@ class FlaskClient(Client):\n             headers = resp.get_wsgi_headers(c.request.environ)\n             self.cookie_jar.extract_wsgi(c.request.environ, headers)\n \n-    def open(\n-        self, *args, as_tuple=False, buffered=False, follow_redirects=False, **kwargs\n-    ):\n+    def open(  # type: ignore\n+        self,\n+        *args: t.Any,\n+        as_tuple: bool = False,\n+        buffered: bool = False,\n+        follow_redirects: bool = False,\n+        **kwargs: t.Any,\n+    ) -> \"Response\":\n         # Same logic as super.open, but apply environ_base and preserve_context.\n         request = None\n \n@@ -198,20 +213,22 @@ class FlaskClient(Client):\n             finally:\n                 builder.close()\n \n-        return super().open(\n+        return super().open(  # type: ignore\n             request,\n             as_tuple=as_tuple,\n             buffered=buffered,\n             follow_redirects=follow_redirects,\n         )\n \n-    def __enter__(self):\n+    def __enter__(self) -> \"FlaskClient\":\n         if self.preserve_context:\n             raise RuntimeError(\"Cannot nest client invocations\")\n         self.preserve_context = True\n         return self\n \n-    def __exit__(self, exc_type, exc_value, tb):\n+    def __exit__(\n+        self, exc_type: type, exc_value: BaseException, tb: TracebackType\n+    ) -> None:\n         self.preserve_context = False\n \n         # Normally the request context is preserved until the next\n@@ -233,11 +250,13 @@ class FlaskCliRunner(CliRunner):\n     :meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.\n     \"\"\"\n \n-    def __init__(self, app, **kwargs):\n+    def __init__(self, app: \"Flask\", **kwargs: t.Any) -> None:\n         self.app = app\n         super().__init__(**kwargs)\n \n-    def invoke(self, cli=None, args=None, **kwargs):\n+    def invoke(  # type: ignore\n+        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any\n+    ) -> t.Any:\n         \"\"\"Invokes a CLI command in an isolated environment. See\n         :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for\n         full method documentation. See :ref:`testing-cli` for examples.\n\n@@ -0,0 +1,46 @@\n+import typing as t\n+\n+\n+if t.TYPE_CHECKING:\n+    from werkzeug.datastructures import Headers  # noqa: F401\n+    from wsgiref.types import WSGIApplication  # noqa: F401\n+    from .wrappers import Response  # noqa: F401\n+\n+# The possible types that are directly convertible or are a Response object.\n+ResponseValue = t.Union[\n+    \"Response\",\n+    t.AnyStr,\n+    t.Dict[str, t.Any],  # any jsonify-able dict\n+    t.Generator[t.AnyStr, None, None],\n+]\n+StatusCode = int\n+\n+# the possible types for an individual HTTP header\n+HeaderName = str\n+HeaderValue = t.Union[str, t.List[str], t.Tuple[str, ...]]\n+\n+# the possible types for HTTP headers\n+HeadersValue = t.Union[\n+    \"Headers\", t.Dict[HeaderName, HeaderValue], t.List[t.Tuple[HeaderName, HeaderValue]]\n+]\n+\n+# The possible types returned by a route function.\n+ResponseReturnValue = t.Union[\n+    ResponseValue,\n+    t.Tuple[ResponseValue, HeadersValue],\n+    t.Tuple[ResponseValue, StatusCode],\n+    t.Tuple[ResponseValue, StatusCode, HeadersValue],\n+    \"WSGIApplication\",\n+]\n+\n+AppOrBlueprintKey = t.Optional[str]  # The App key is None, whereas blueprints are named\n+AfterRequestCallable = t.Callable[[\"Response\"], \"Response\"]\n+BeforeRequestCallable = t.Callable[[], None]\n+ErrorHandlerCallable = t.Callable[[Exception], ResponseReturnValue]\n+TeardownCallable = t.Callable[[t.Optional[BaseException]], \"Response\"]\n+TemplateContextProcessorCallable = t.Callable[[], t.Dict[str, t.Any]]\n+TemplateFilterCallable = t.Callable[[t.Any], str]\n+TemplateGlobalCallable = t.Callable[[], t.Any]\n+TemplateTestCallable = t.Callable[[t.Any], bool]\n+URLDefaultCallable = t.Callable[[str, dict], None]\n+URLValuePreprocessorCallable = t.Callable[[t.Optional[str], t.Optional[dict]], None]\n\n@@ -1,4 +1,7 @@\n+import typing as t\n+\n from .globals import request\n+from .typing import ResponseReturnValue\n \n \n http_method_funcs = frozenset(\n@@ -39,10 +42,10 @@ class View:\n     \"\"\"\n \n     #: A list of methods this view can handle.\n-    methods = None\n+    methods: t.Optional[t.List[str]] = None\n \n     #: Setting this disables or force-enables the automatic options handling.\n-    provide_automatic_options = None\n+    provide_automatic_options: t.Optional[bool] = None\n \n     #: The canonical way to decorate class-based views is to decorate the\n     #: return value of as_view().  However since this moves parts of the\n@@ -53,9 +56,9 @@ class View:\n     #: view function is created the result is automatically decorated.\n     #:\n     #: .. versionadded:: 0.8\n-    decorators = ()\n+    decorators: t.List[t.Callable] = []\n \n-    def dispatch_request(self):\n+    def dispatch_request(self) -> ResponseReturnValue:\n         \"\"\"Subclasses have to override this method to implement the\n         actual view function code.  This method is called with all\n         the arguments from the URL rule.\n@@ -63,7 +66,9 @@ class View:\n         raise NotImplementedError()\n \n     @classmethod\n-    def as_view(cls, name, *class_args, **class_kwargs):\n+    def as_view(\n+        cls, name: str, *class_args: t.Any, **class_kwargs: t.Any\n+    ) -> t.Callable:\n         \"\"\"Converts the class into an actual view function that can be used\n         with the routing system.  Internally this generates a function on the\n         fly which will instantiate the :class:`View` on each request and call\n@@ -73,8 +78,8 @@ class View:\n         constructor of the class.\n         \"\"\"\n \n-        def view(*args, **kwargs):\n-            self = view.view_class(*class_args, **class_kwargs)\n+        def view(*args: t.Any, **kwargs: t.Any) -> ResponseReturnValue:\n+            self = view.view_class(*class_args, **class_kwargs)  # type: ignore\n             return self.dispatch_request(*args, **kwargs)\n \n         if cls.decorators:\n@@ -88,12 +93,12 @@ class View:\n         # view this thing came from, secondly it's also used for instantiating\n         # the view class so you can actually replace it with something else\n         # for testing purposes and debugging.\n-        view.view_class = cls\n+        view.view_class = cls  # type: ignore\n         view.__name__ = name\n         view.__doc__ = cls.__doc__\n         view.__module__ = cls.__module__\n-        view.methods = cls.methods\n-        view.provide_automatic_options = cls.provide_automatic_options\n+        view.methods = cls.methods  # type: ignore\n+        view.provide_automatic_options = cls.provide_automatic_options  # type: ignore\n         return view\n \n \n@@ -140,7 +145,7 @@ class MethodView(View, metaclass=MethodViewType):\n         app.add_url_rule('/counter', view_func=CounterAPI.as_view('counter'))\n     \"\"\"\n \n-    def dispatch_request(self, *args, **kwargs):\n+    def dispatch_request(self, *args: t.Any, **kwargs: t.Any) -> ResponseReturnValue:\n         meth = getattr(self, request.method.lower(), None)\n \n         # If the request method is HEAD and we don't have a handler for it\n\n@@ -1,3 +1,5 @@\n+import typing as t\n+\n from werkzeug.exceptions import BadRequest\n from werkzeug.wrappers import Request as RequestBase\n from werkzeug.wrappers import Response as ResponseBase\n@@ -5,6 +7,9 @@ from werkzeug.wrappers import Response as ResponseBase\n from . import json\n from .globals import current_app\n \n+if t.TYPE_CHECKING:\n+    from werkzeug.routing import Rule\n+\n \n class Request(RequestBase):\n     \"\"\"The request object used by default in Flask.  Remembers the\n@@ -31,26 +36,28 @@ class Request(RequestBase):\n     #: because the request was never internally bound.\n     #:\n     #: .. versionadded:: 0.6\n-    url_rule = None\n+    url_rule: t.Optional[\"Rule\"] = None\n \n     #: A dict of view arguments that matched the request.  If an exception\n     #: happened when matching, this will be ``None``.\n-    view_args = None\n+    view_args: t.Optional[t.Dict[str, t.Any]] = None\n \n     #: If matching the URL failed, this is the exception that will be\n     #: raised / was raised as part of the request handling.  This is\n     #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n     #: something similar.\n-    routing_exception = None\n+    routing_exception: t.Optional[Exception] = None\n \n     @property\n-    def max_content_length(self):\n+    def max_content_length(self) -> t.Optional[int]:  # type: ignore\n         \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\"\n         if current_app:\n             return current_app.config[\"MAX_CONTENT_LENGTH\"]\n+        else:\n+            return None\n \n     @property\n-    def endpoint(self):\n+    def endpoint(self) -> t.Optional[str]:\n         \"\"\"The endpoint that matched the request.  This in combination with\n         :attr:`view_args` can be used to reconstruct the same or a\n         modified URL.  If an exception happened when matching, this will\n@@ -58,14 +65,18 @@ class Request(RequestBase):\n         \"\"\"\n         if self.url_rule is not None:\n             return self.url_rule.endpoint\n+        else:\n+            return None\n \n     @property\n-    def blueprint(self):\n+    def blueprint(self) -> t.Optional[str]:\n         \"\"\"The name of the current blueprint\"\"\"\n         if self.url_rule and \".\" in self.url_rule.endpoint:\n             return self.url_rule.endpoint.rsplit(\".\", 1)[0]\n+        else:\n+            return None\n \n-    def _load_form_data(self):\n+    def _load_form_data(self) -> None:\n         RequestBase._load_form_data(self)\n \n         # In debug mode we're replacing the files multidict with an ad-hoc\n@@ -80,7 +91,7 @@ class Request(RequestBase):\n \n             attach_enctype_error_multidict(self)\n \n-    def on_json_loading_failed(self, e):\n+    def on_json_loading_failed(self, e: Exception) -> t.NoReturn:\n         if current_app and current_app.debug:\n             raise BadRequest(f\"Failed to decode JSON object: {e}\")\n \n@@ -110,7 +121,7 @@ class Response(ResponseBase):\n     json_module = json\n \n     @property\n-    def max_cookie_size(self):\n+    def max_cookie_size(self) -> int:  # type: ignore\n         \"\"\"Read-only view of the :data:`MAX_COOKIE_SIZE` config key.\n \n         See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
