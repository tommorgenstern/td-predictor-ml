{"custom_id": "requests#c48cf2bba8aafa50ae5cd77e7ab4bb476dca086c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 4 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 2657 | Contributors (this commit): 8 | Commits (past 90d): 9 | Contributors (cumulative): 8 | DMM Complexity: None\n\nDIFF:\n@@ -19,11 +19,11 @@ __license__ = 'ISC'\n __copyright__ = 'Copyright 2011 Kenneth Reitz'\n \n \n-from models import HTTPError, Request, Response\n from api import *\n+from config import settings\n from exceptions import *\n+from models import HTTPError, Request, Response\n from sessions import session\n from status_codes import codes\n-from config import settings\n \n import utils\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#df66fa7975dd359c97161848a175122a5406ee06", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 24 | Files Changed: 2 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 13/13 | Churn Δ: 26 | Churn Cumulative: 2578 | Contributors (this commit): 18 | Commits (past 90d): 105 | Contributors (cumulative): 24 | DMM Complexity: 0.9166666666666666\n\nDIFF:\n@@ -67,28 +67,6 @@ def request(method, url,\n         timeout=timeout or config.settings.timeout,\n         allow_redirects=allow_redirects,\n         proxies=proxies or config.settings.proxies,\n-        method = method,\n-        url = url,\n-        data = data,\n-        params = params,\n-        headers = headers,\n-        cookiejar = cookies,\n-        files = files,\n-        auth = auth,\n-        timeout = timeout or config.settings.timeout,\n-        allow_redirects = allow_redirects,\n-        proxies = proxies or config.settings.proxies\n-        method=method,\n-        url=url,\n-        data=data,\n-        params=params,\n-        headers=headers,\n-        cookiejar=cookies,\n-        files=files,\n-        auth=auth,\n-        timeout=timeout or config.settings.timeout,\n-        allow_redirects=allow_redirects,\n-        proxies=proxies or config.settings.proxies,\n     )\n \n     # Arguments manipulation hook.\n\n@@ -184,12 +184,12 @@ class Request(object):\n \n                 # if self.cookiejar:\n \n-                    response.cookies = dict_from_cookiejar(self.cookiejar)\n+                    # response.cookies = dict_from_cookiejar(self.cookiejar)\n \n \n                     # response.cookies = dict_from_cookiejar(self.cookiejar)\n \n-                    response.cookies = dict_from_cookiejar(self.cookiejar)\n+                    # response.cookies = dict_from_cookiejar(self.cookiejar)\n \n             except AttributeError:\n                 pass\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#37ed9116b7081ff2b1542af7bdb2857f3ca63661", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 41 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 41 | Churn Cumulative: 122 | Contributors (this commit): 2 | Commits (past 90d): 1 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -1,41 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-    requests.async\n-    ~~~~~~~~~~~~~~\n-\n-    This module implements the main Requests system, after monkey-patching\n-    the urllib2 module with eventlet or gevent..\n-\n-    :copyright: (c) 2011 by Kenneth Reitz.\n-    :license: ISC, see LICENSE for more details.\n-\"\"\"\n-\n-\n-from __future__ import absolute_import\n-\n-import urllib\n-import urllib2\n-\n-from urllib2 import HTTPError\n-\n-\n-try:\n-    import eventlet\n-    eventlet.monkey_patch()\n-except ImportError:\n-    pass\n-\n-if not 'eventlet' in locals():\n-    try:\n-        from gevent import monkey\n-        monkey.patch_all()\n-    except ImportError:\n-        pass\n-\n-\n-if not 'eventlet' in locals():\n-    raise ImportError('No Async adaptations of urllib2 found!')\n-\n-\n-from .core import *\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#33df9d1bf2cf24bf46af0d079a3f4884816dd9e6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 142 | Files Changed: 1 | Hunks: 1 | Methods Changed: 8 | Complexity Δ (Sum/Max): -25/0 | Churn Δ: 142 | Churn Cumulative: 342 | Contributors (this commit): 2 | Commits (past 90d): 5 | Contributors (cumulative): 2 | DMM Complexity: 0.31343283582089554\n\nDIFF:\n@@ -1,142 +0,0 @@\n-#-*- coding: utf-8 -*-\n-\n-\"\"\"\n-requests.monkeys\n-~~~~~~~~~~~~~~~~\n-\n-Urllib2 Monkey patches.\n-\n-\"\"\"\n-\n-import re\n-import urllib2\n-\n-\n-class Request(urllib2.Request):\n-    \"\"\"Hidden wrapper around the urllib2.Request object. Allows for manual\n-    setting of HTTP methods.\n-    \"\"\"\n-\n-    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):\n-        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)\n-        self.method = method\n-\n-    def get_method(self):\n-        if self.method:\n-            return self.method\n-\n-        return urllib2.Request.get_method(self)\n-\n-\n-class HTTPRedirectHandler(urllib2.HTTPRedirectHandler):\n-    \"\"\"HTTP Redirect handler.\"\"\"\n-    def http_error_301(self, req, fp, code, msg, headers):\n-        pass\n-\n-    http_error_302 = http_error_303 = http_error_307 = http_error_301\n-\n-\n-class HTTPBasicAuthHandler(urllib2.HTTPBasicAuthHandler):\n-    \"\"\"HTTP Basic Auth Handler with authentication loop fixes.\"\"\"\n-\n-    def __init__(self, *args, **kwargs):\n-        urllib2.HTTPBasicAuthHandler.__init__(self, *args, **kwargs)\n-        self.retried_req = None\n-        self.retried = 0\n-\n-    def reset_retry_count(self):\n-        # Python 2.6.5 will call this on 401 or 407 errors and thus loop\n-        # forever. We disable reset_retry_count completely and reset in\n-        # http_error_auth_reqed instead.\n-        pass\n-\n-    def http_error_auth_reqed(self, auth_header, host, req, headers):\n-        # Reset the retry counter once for each request.\n-        if req is not self.retried_req:\n-            self.retried_req = req\n-            self.retried = 0\n-\n-        return urllib2.HTTPBasicAuthHandler.http_error_auth_reqed(\n-            self, auth_header, host, req, headers\n-        )\n-\n-\n-class HTTPForcedBasicAuthHandler(HTTPBasicAuthHandler):\n-    \"\"\"HTTP Basic Auth Handler with forced Authentication.\"\"\"\n-\n-    auth_header = 'Authorization'\n-    rx = re.compile('(?:.*,)*[ \\t]*([^ \\t]+)[ \\t]+'\n-                    'realm=([\"\\'])(.*?)\\\\2', re.I)\n-\n-    def __init__(self, *args, **kwargs):\n-        HTTPBasicAuthHandler.__init__(self, *args, **kwargs)\n-\n-    def http_error_401(self, req, fp, code, msg, headers):\n-        url = req.get_full_url()\n-        response = self._http_error_auth_reqed('www-authenticate', url, req, headers)\n-        self.reset_retry_count()\n-        return response\n-\n-    http_error_404 = http_error_401\n-\n-    def _http_error_auth_reqed(self, authreq, host, req, headers):\n-\n-        authreq = headers.get(authreq, None)\n-\n-        if self.retried > 5:\n-            # retry sending the username:password 5 times before failing.\n-            raise urllib2.HTTPError(req.get_full_url(), 401, \"basic auth failed\",\n-                            headers, None)\n-        else:\n-            self.retried += 1\n-\n-        if authreq:\n-\n-            mo = self.rx.search(authreq)\n-\n-            if mo:\n-                scheme, quote, realm = mo.groups()\n-\n-                if scheme.lower() == 'basic':\n-                    response = self.retry_http_basic_auth(host, req, realm)\n-\n-                    if response and response.code not in (401, 404):\n-                        self.retried = 0\n-                    return response\n-        else:\n-            response = self.retry_http_basic_auth(host, req, 'Realm')\n-\n-            if response and response.code not in (401, 404):\n-                self.retried = 0\n-            return response\n-\n-\n-class HTTPDigestAuthHandler(urllib2.HTTPDigestAuthHandler):\n-\n-    def __init__(self, *args, **kwargs):\n-        urllib2.HTTPDigestAuthHandler.__init__(self, *args, **kwargs)\n-        self.retried_req = None\n-\n-    def reset_retry_count(self):\n-        # Python 2.6.5 will call this on 401 or 407 errors and thus loop\n-        # forever. We disable reset_retry_count completely and reset in\n-        # http_error_auth_reqed instead.\n-        pass\n-\n-    def http_error_auth_reqed(self, auth_header, host, req, headers):\n-        # Reset the retry counter once for each request.\n-        if req is not self.retried_req:\n-            self.retried_req = req\n-            self.retried = 0\n-        # In python < 2.5 AbstractDigestAuthHandler raises a ValueError if\n-        # it doesn't know about the auth type requested. This can happen if\n-        # somebody is using BasicAuth and types a bad password.\n-\n-        try:\n-            return urllib2.HTTPDigestAuthHandler.http_error_auth_reqed(\n-                        self, auth_header, host, req, headers)\n-        except ValueError, inst:\n-            arg = inst.args[0]\n-            if arg.startswith(\"AbstractDigestAuthHandler doesn't know \"):\n-                return\n-            raise\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#182f92ab2602658802724d1204feade7a7117994", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 134 | Lines Deleted: 127 | Files Changed: 3 | Hunks: 36 | Methods Changed: 7 | Complexity Δ (Sum/Max): -16/13 | Churn Δ: 261 | Churn Cumulative: 5394 | Contributors (this commit): 23 | Commits (past 90d): 128 | Contributors (cumulative): 31 | DMM Complexity: 1.0\n\nDIFF:\n@@ -22,7 +22,7 @@ __copyright__ = 'Copyright 2011 Kenneth Reitz'\n from api import *\n from config import settings\n from exceptions import *\n-from models import HTTPError, Request, Response\n+from models import Request, Response\n from sessions import session\n from status_codes import codes\n \n\n@@ -11,8 +11,6 @@ import urllib2\n import socket\n import zlib\n \n-\n-from urllib2 import HTTPError\n from urlparse import urlparse, urlunparse, urljoin\n from datetime import datetime\n \n@@ -22,7 +20,7 @@ from .packages import urllib3\n \n from .config import settings\n from .structures import CaseInsensitiveDict\n-from .utils import dict_from_cookiejar, get_unicode_from_response, stream_decode_response_unicode, decode_gzip, stream_decode_gzip\n+from .utils import *\n from .status_codes import codes\n from .exceptions import RequestException, Timeout, URLRequired, TooManyRedirects\n \n@@ -74,8 +72,10 @@ class Request(object):\n         # Dictionary mapping protocol to the URL of the proxy (e.g. {'http': 'foo.bar:3128'})\n         self.proxies = proxies\n \n-        self.data, self._enc_data = self._encode_params(data)\n-        self.params, self._enc_params = self._encode_params(params)\n+        self.data = data\n+        self._enc_data = encode_params(data)\n+        self.params = params\n+        self._enc_params = encode_params(params)\n \n         #: :class:`Response <Response>` instance, containing\n         #: content and metadata of HTTP Response, once :attr:`sent <send>`.\n@@ -277,66 +277,7 @@ class Request(object):\n         # Give Response some context.\n         self.response.request = self\n \n-    @staticmethod\n-    def _encode_params(data):\n-        \"\"\"Encode parameters in a piece of data.\n \n-        If the data supplied is a dictionary, encodes each parameter in it, and\n-        returns a list of tuples containing the encoded parameters, and a urlencoded\n-        version of that.\n-\n-        Otherwise, assumes the data is already encoded appropriately, and\n-        returns it twice.\n-        \"\"\"\n-\n-        if hasattr(data, 'items'):\n-            result = []\n-            for k, vs in data.items():\n-                for v in isinstance(vs, list) and vs or [vs]:\n-                    result.append((k.encode('utf-8') if isinstance(k, unicode) else k,\n-                                   v.encode('utf-8') if isinstance(v, unicode) else v)\n-                    )\n-            return (result, urllib.urlencode(result, doseq=True))\n-\n-        else:\n-            return data, data\n-\n-    def _build_url(self):\n-        \"\"\"Build the actual URL to use.\"\"\"\n-\n-        # Support for unicode domain names and paths.\n-        (scheme, netloc, path, params, query, fragment) = urlparse(self.url)\n-\n-        # International Domain Name\n-        netloc = netloc.encode('idna')\n-\n-        # Encode the path to to utf-8.\n-        if isinstance(path, unicode):\n-            path = path.encode('utf-8')\n-\n-        # URL-encode the path.\n-        path = urllib.quote(path, safe=\"%/:=&?~#+!$,;'@()*[]\")\n-\n-        # Turn it back into a bytestring.\n-        self.url = str(urlunparse([scheme, netloc, path, params, query, fragment]))\n-        self.url = str(urlunparse(\n-          [scheme, netloc, path, params, query, fragment]\n-         ))\n-\n-        # Query Parameters?\n-        if self._enc_params:\n-\n-            # If query parameters already exist in the URL, append.\n-            if urlparse(self.url).query:\n-                return '%s&%s' % (self.url, self._enc_params)\n-\n-            # Otherwise, have at it.\n-            else:\n-                return '%s?%s' % (self.url, self._enc_params)\n-\n-        else:\n-            # Kosher URL.\n-            return self.url\n \n     def send(self, connection=None, anyway=False):\n         \"\"\"Sends the shit.\"\"\"\n@@ -345,8 +286,9 @@ class Request(object):\n         self._checks()\n \n         # Build the final URL.\n-        url = self._build_url()\n+        url = build_url(self.url, self.params)\n \n+        print url\n         # Setup Files.\n         if self.files:\n             pass\n@@ -367,8 +309,7 @@ class Request(object):\n             try:\n                 # Create a new HTTP connection, since one wasn't passed in.\n                 if not connection:\n-                    connection = urllib3.connection_from_url(url,\n-                        timeout=self.timeout)\n+                    connection = urllib3.connection_from_url(url, timeout=self.timeout)\n \n                     # One-off request. Delay fetching the content until needed.\n                     do_block = False\n@@ -384,7 +325,8 @@ class Request(object):\n                     headers=self.headers,\n                     redirect=False,\n                     assert_same_host=False,\n-                    block=do_block\n+                    preload_content=do_block\n+                    # block=do_block\n                 )\n \n                 # Extract cookies.\n@@ -412,87 +354,87 @@ class Request(object):\n \n \n \n-    def old_send(self, anyway=False):\n-        \"\"\"Sends the request. Returns True of successful, false if not.\n-        If there was an HTTPError during transmission,\n-        self.response.status_code will contain the HTTPError code.\n+    # def old_send(self, anyway=False):\n+    #     \"\"\"Sends the request. Returns True of successful, false if not.\n+    #     If there was an HTTPError during transmission,\n+    #     self.response.status_code will contain the HTTPError code.\n \n-        Once a request is successfully sent, `sent` will equal True.\n+    #     Once a request is successfully sent, `sent` will equal True.\n \n-        :param anyway: If True, request will be sent, even if it has\n-        already been sent.\n-        \"\"\"\n+    #     :param anyway: If True, request will be sent, even if it has\n+    #     already been sent.\n+    #     \"\"\"\n \n-        self._checks()\n+    #     self._checks()\n \n-        # Logging\n-        if settings.verbose:\n-            settings.verbose.write('%s   %s   %s\\n' % (\n-                datetime.now().isoformat(), self.method, self.url\n-            ))\n+    #     # Logging\n+    #     if settings.verbose:\n+    #         settings.verbose.write('%s   %s   %s\\n' % (\n+    #             datetime.now().isoformat(), self.method, self.url\n+    #         ))\n \n-        url = self._build_url()\n-        if self.method in ('GET', 'HEAD', 'DELETE'):\n-            req = _Request(url, method=self.method)\n-        else:\n+    #     url = self._build_url()\n+    #     if self.method in ('GET', 'HEAD', 'DELETE'):\n+    #         req = _Request(url, method=self.method)\n+    #     else:\n \n-            if self.files:\n-                register_openers()\n+    #         if self.files:\n+    #             register_openers()\n \n-                if self.data:\n-                    self.files.update(self.data)\n+    #             if self.data:\n+    #                 self.files.update(self.data)\n \n-                datagen, headers = multipart_encode(self.files)\n-                req = _Request(url, data=datagen, headers=headers, method=self.method)\n+    #             datagen, headers = multipart_encode(self.files)\n+    #             req = _Request(url, data=datagen, headers=headers, method=self.method)\n \n-            else:\n-                req = _Request(url, data=self._enc_data, method=self.method)\n+    #         else:\n+    #             req = _Request(url, data=self._enc_data, method=self.method)\n \n-        if self.headers:\n-            for k, v in self.headers.iteritems():\n-                req.add_header(k, v)\n+    #     if self.headers:\n+    #         for k, v in self.headers.iteritems():\n+    #             req.add_header(k, v)\n \n-        if not self.sent or anyway:\n+    #     if not self.sent or anyway:\n \n-            try:\n-                opener = self._get_opener()\n-                try:\n+    #         try:\n+    #             opener = self._get_opener()\n+    #             try:\n \n-                    resp = opener(req, timeout=self.timeout)\n+    #                 resp = opener(req, timeout=self.timeout)\n \n-                except TypeError, err:\n-                    # timeout argument is new since Python v2.6\n-                    if not 'timeout' in str(err):\n-                        raise\n+    #             except TypeError, err:\n+    #                 # timeout argument is new since Python v2.6\n+    #                 if not 'timeout' in str(err):\n+    #                     raise\n \n-                    if settings.timeout_fallback:\n-                        # fall-back and use global socket timeout (This is not thread-safe!)\n-                        old_timeout = socket.getdefaulttimeout()\n-                        socket.setdefaulttimeout(self.timeout)\n+    #                 if settings.timeout_fallback:\n+    #                     # fall-back and use global socket timeout (This is not thread-safe!)\n+    #                     old_timeout = socket.getdefaulttimeout()\n+    #                     socket.setdefaulttimeout(self.timeout)\n \n-                    resp = opener(req)\n+    #                 resp = opener(req)\n \n-                    if settings.timeout_fallback:\n-                        # restore gobal timeout\n-                        socket.setdefaulttimeout(old_timeout)\n+    #                 if settings.timeout_fallback:\n+    #                     # restore gobal timeout\n+    #                     socket.setdefaulttimeout(old_timeout)\n \n-                if self.cookiejar is not None:\n-                    self.cookiejar.extract_cookies(resp, req)\n+    #             if self.cookiejar is not None:\n+    #                 self.cookiejar.extract_cookies(resp, req)\n \n-            except (urllib2.HTTPError, urllib2.URLError), why:\n-                if hasattr(why, 'reason'):\n-                    if isinstance(why.reason, socket.timeout):\n-                        why = Timeout(why)\n+    #         except (urllib2.HTTPError, urllib2.URLError), why:\n+    #             if hasattr(why, 'reason'):\n+    #                 if isinstance(why.reason, socket.timeout):\n+    #                     why = Timeout(why)\n \n-                self._build_response(why, is_error=True)\n+    #             self._build_response(why, is_error=True)\n \n-            else:\n-                self._build_response(resp)\n-                self.response.ok = True\n+    #         else:\n+    #             self._build_response(resp)\n+    #             self.response.ok = True\n \n-        self.sent = self.response.ok\n+    #     self.sent = self.response.ok\n \n-        return self.sent\n+    #     return self.sent\n \n \n class Response(object):\n\n@@ -13,7 +13,72 @@ import cgi\n import codecs\n import cookielib\n import re\n+import urllib\n import zlib\n+from urlparse import urlparse, urlunparse, urljoin\n+\n+\n+def encode_params(params):\n+    \"\"\"Encode parameters in a piece of data.\n+\n+    If the data supplied is a dictionary, encodes each parameter in it, and\n+    returns a list of tuples containing the encoded parameters, and a urlencoded\n+    version of that.\n+\n+    Otherwise, assumes the data is already encoded appropriately, and\n+    returns it twice.\n+    \"\"\"\n+\n+    if hasattr(params, 'items'):\n+        result = []\n+        for k, vs in params.items():\n+            for v in isinstance(vs, list) and vs or [vs]:\n+                result.append((k.encode('utf-8') if isinstance(k, unicode) else k,\n+                               v.encode('utf-8') if isinstance(v, unicode) else v)\n+                )\n+        return urllib.urlencode(result, doseq=True)\n+\n+    else:\n+        return params\n+\n+def build_url(url, params):\n+    \"\"\"Build the actual URL to use.\"\"\"\n+\n+\n+    # Support for unicode domain names and paths.\n+    (scheme, netloc, path, params, query, fragment) = urlparse(url)\n+\n+    # International Domain Name\n+    netloc = netloc.encode('idna')\n+\n+    # Encode the path to to utf-8.\n+    if isinstance(path, unicode):\n+        path = path.encode('utf-8')\n+\n+    # URL-encode the path.\n+    path = urllib.quote(path, safe=\"%/:=&?~#+!$,;'@()*[]\")\n+\n+    # Turn it back into a bytestring.\n+    url = str(urlunparse([scheme, netloc, path, params, query, fragment]))\n+    url = str(urlunparse(\n+      [scheme, netloc, path, params, query, fragment]\n+     ))\n+\n+    # Query Parameters?\n+    if params:\n+        params = encode_params(params)\n+\n+        # If query parameters already exist in the URL, append.\n+        if urlparse(url).query:\n+            return '%s&%s' % (url, params)\n+\n+        # Otherwise, have at it.\n+        else:\n+            return '%s?%s' % (url, params)\n+\n+    else:\n+        # Kosher URL.\n+        return url\n \n \n def header_expand(headers):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#0b22bc9b4243808628e417959a4ada0d803ae515", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 7 | Files Changed: 2 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 12 | Churn Cumulative: 2784 | Contributors (this commit): 18 | Commits (past 90d): 108 | Contributors (cumulative): 24 | DMM Complexity: 0.0\n\nDIFF:\n@@ -61,7 +61,7 @@ def request(method, url,\n         data=data,\n         params=params,\n         headers=headers,\n-        cookiejar=cookies,\n+        cookies=cookies,\n         files=files,\n         auth=auth,\n         timeout=timeout or config.settings.timeout,\n\n@@ -35,7 +35,7 @@ class Request(object):\n \n     def __init__(self,\n         url=None, headers=dict(), files=None, method=None, data=dict(),\n-        params=dict(), auth=None, cookiejar=None, timeout=None, redirect=False,\n+        params=dict(), auth=None, cookies=None, timeout=None, redirect=False,\n         allow_redirects=False, proxies=None):\n \n         #: Float describ the timeout of the request.\n@@ -90,7 +90,7 @@ class Request(object):\n         self.auth = auth\n \n         #: CookieJar to attach to :class:`Request <Request>`.\n-        self.cookiejar = cookiejar\n+        self.cookies = cookies\n \n         #: True if Request has been sent.\n         self.sent = False\n@@ -298,10 +298,8 @@ class Request(object):\n             pass\n \n         # Setup cookies.\n-        # elif self.cookies:\n-            # pass\n-\n-        # req = _Request(url, data=self._enc_data, method=self.method)\n+        elif self.cookies:\n+            pass\n \n         # Only send the Request if new or forced.\n         if (anyway) or (not self.sent):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#5287b8cd9f1eca624b57cb03ad5d1fb2db41bf9e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 42 | Lines Deleted: 246 | Files Changed: 2 | Hunks: 25 | Methods Changed: 21 | Complexity Δ (Sum/Max): -43/0 | Churn Δ: 288 | Churn Cumulative: 3033 | Contributors (this commit): 18 | Commits (past 90d): 121 | Contributors (cumulative): 23 | DMM Complexity: 0.6067415730337079\n\nDIFF:\n@@ -81,13 +81,13 @@ class Request(object):\n         #: content and metadata of HTTP Response, once :attr:`sent <send>`.\n         self.response = Response()\n \n-        if isinstance(auth, (list, tuple)):\n-            auth = AuthObject(*auth)\n-        if not auth:\n-            auth = auth_manager.get_auth(self.url)\n+        # if isinstance(auth, (list, tuple)):\n+        #     auth = AuthObject(*auth)\n+        # if not auth:\n+        #     auth = auth_manager.get_auth(self.url)\n \n         #: :class:`AuthObject` to attach to :class:`Request <Request>`.\n-        self.auth = auth\n+        # self.auth = auth\n \n         #: CookieJar to attach to :class:`Request <Request>`.\n         self.cookies = cookies\n@@ -180,7 +180,15 @@ class Request(object):\n \n             try:\n                 response.headers = CaseInsensitiveDict(getattr(resp, 'headers', None))\n-                response.raw = resp._raw\n+                response.raw = resp\n+                # print dir(self.response.raw)\n+                # print self\n+\n+                # print (response.raw)\n+                # print dir(response.raw)\n+                # print response.raw.sock.read()\n+                # print '------'\n+\n \n                 # if self.cookiejar:\n \n@@ -323,7 +331,8 @@ class Request(object):\n                     headers=self.headers,\n                     redirect=False,\n                     assert_same_host=False,\n-                    preload_content=do_block\n+                    # preload_content=True\n+                    preload_content=False\n                     # block=do_block\n                 )\n \n@@ -342,6 +351,7 @@ class Request(object):\n                 print why\n \n             else:\n+                # self.response = Response.from_urllib3()\n                 self._build_response(r)\n                 self.response.ok = True\n \n@@ -351,90 +361,6 @@ class Request(object):\n         return self.sent\n \n \n-\n-    # def old_send(self, anyway=False):\n-    #     \"\"\"Sends the request. Returns True of successful, false if not.\n-    #     If there was an HTTPError during transmission,\n-    #     self.response.status_code will contain the HTTPError code.\n-\n-    #     Once a request is successfully sent, `sent` will equal True.\n-\n-    #     :param anyway: If True, request will be sent, even if it has\n-    #     already been sent.\n-    #     \"\"\"\n-\n-    #     self._checks()\n-\n-    #     # Logging\n-    #     if settings.verbose:\n-    #         settings.verbose.write('%s   %s   %s\\n' % (\n-    #             datetime.now().isoformat(), self.method, self.url\n-    #         ))\n-\n-    #     url = self._build_url()\n-    #     if self.method in ('GET', 'HEAD', 'DELETE'):\n-    #         req = _Request(url, method=self.method)\n-    #     else:\n-\n-    #         if self.files:\n-    #             register_openers()\n-\n-    #             if self.data:\n-    #                 self.files.update(self.data)\n-\n-    #             datagen, headers = multipart_encode(self.files)\n-    #             req = _Request(url, data=datagen, headers=headers, method=self.method)\n-\n-    #         else:\n-    #             req = _Request(url, data=self._enc_data, method=self.method)\n-\n-    #     if self.headers:\n-    #         for k, v in self.headers.iteritems():\n-    #             req.add_header(k, v)\n-\n-    #     if not self.sent or anyway:\n-\n-    #         try:\n-    #             opener = self._get_opener()\n-    #             try:\n-\n-    #                 resp = opener(req, timeout=self.timeout)\n-\n-    #             except TypeError, err:\n-    #                 # timeout argument is new since Python v2.6\n-    #                 if not 'timeout' in str(err):\n-    #                     raise\n-\n-    #                 if settings.timeout_fallback:\n-    #                     # fall-back and use global socket timeout (This is not thread-safe!)\n-    #                     old_timeout = socket.getdefaulttimeout()\n-    #                     socket.setdefaulttimeout(self.timeout)\n-\n-    #                 resp = opener(req)\n-\n-    #                 if settings.timeout_fallback:\n-    #                     # restore gobal timeout\n-    #                     socket.setdefaulttimeout(old_timeout)\n-\n-    #             if self.cookiejar is not None:\n-    #                 self.cookiejar.extract_cookies(resp, req)\n-\n-    #         except (urllib2.HTTPError, urllib2.URLError), why:\n-    #             if hasattr(why, 'reason'):\n-    #                 if isinstance(why.reason, socket.timeout):\n-    #                     why = Timeout(why)\n-\n-    #             self._build_response(why, is_error=True)\n-\n-    #         else:\n-    #             self._build_response(resp)\n-    #             self.response.ok = True\n-\n-    #     self.sent = self.response.ok\n-\n-    #     return self.sent\n-\n-\n class Response(object):\n     \"\"\"The core :class:`Response <Response>` object.\n \n@@ -501,13 +427,17 @@ class Response(object):\n                     break\n                 yield chunk\n             self._content_consumed = True\n-        gen = generate()\n+        gen = generate\n+\n         if 'gzip' in self.headers.get('content-encoding', ''):\n             gen = stream_decode_gzip(gen)\n+\n         if decode_unicode is None:\n             decode_unicode = settings.decode_unicode\n+\n         if decode_unicode:\n             gen = stream_decode_response_unicode(gen, self)\n+\n         return gen\n \n \n@@ -526,7 +456,18 @@ class Response(object):\n \n         # Read the contents.\n         # print self.raw.__dict__\n-        self._content = self.raw.read() or self._response.data\n+\n+        # print\n+        # print '~'\n+        # # print self.raw\n+        # print self.raw.getresponse()\n+        # print dir(self.raw)\n+        # print\n+        # print\n+        # print\n+\n+         # self.raw.read() or\n+        self._content = self.raw.read()\n         # print self.raw.__dict__\n \n         # Decode GZip'd content.\n@@ -543,6 +484,7 @@ class Response(object):\n         self._content_consumed = True\n         return self._content\n \n+\n     def raise_for_status(self):\n         \"\"\"Raises stored :class:`HTTPError` or :class:`URLError`,\n         if one occured.\n@@ -562,139 +504,6 @@ class Response(object):\n             raise Exception('500 yo')\n \n \n-class AuthManager(object):\n-    \"\"\"Requests Authentication Manager.\"\"\"\n-\n-    def __new__(cls):\n-        singleton = cls.__dict__.get('__singleton__')\n-        if singleton is not None:\n-            return singleton\n-\n-        cls.__singleton__ = singleton = object.__new__(cls)\n-\n-        return singleton\n-\n-    def __init__(self):\n-        self.passwd = {}\n-        self._auth = {}\n-\n-    def __repr__(self):\n-        return '<AuthManager [%s]>' % (self.method)\n-\n-    def add_auth(self, uri, auth):\n-        \"\"\"Registers AuthObject to AuthManager.\"\"\"\n-\n-        uri = self.reduce_uri(uri, False)\n-\n-        # try to make it an AuthObject\n-        if not isinstance(auth, AuthObject):\n-            try:\n-                auth = AuthObject(*auth)\n-            except TypeError:\n-                pass\n-\n-        self._auth[uri] = auth\n-\n-    def add_password(self, realm, uri, user, passwd):\n-        \"\"\"Adds password to AuthManager.\"\"\"\n-        # uri could be a single URI or a sequence\n-        if isinstance(uri, basestring):\n-            uri = [uri]\n-\n-        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])\n-\n-        if reduced_uri not in self.passwd:\n-            self.passwd[reduced_uri] = {}\n-        self.passwd[reduced_uri] = (user, passwd)\n-\n-    def find_user_password(self, realm, authuri):\n-        for uris, authinfo in self.passwd.iteritems():\n-            reduced_authuri = self.reduce_uri(authuri, False)\n-            for uri in uris:\n-                if self.is_suburi(uri, reduced_authuri):\n-                    return authinfo\n-\n-        return (None, None)\n-\n-    def get_auth(self, uri):\n-        (in_domain, in_path) = self.reduce_uri(uri, False)\n-\n-        for domain, path, authority in (\n-            (i[0][0], i[0][1], i[1]) for i in self._auth.iteritems()\n-        ):\n-            if in_domain == domain:\n-                if path in in_path:\n-                    return authority\n-\n-    def reduce_uri(self, uri, default_port=True):\n-        \"\"\"Accept authority or URI and extract only the authority and path.\"\"\"\n-\n-        # note HTTP URLs do not have a userinfo component\n-        parts = urllib2.urlparse.urlsplit(uri)\n-\n-        if parts[1]:\n-            # URI\n-            scheme = parts[0]\n-            authority = parts[1]\n-            path = parts[2] or '/'\n-        else:\n-            # host or host:port\n-            scheme = None\n-            authority = uri\n-            path = '/'\n-\n-        host, port = urllib2.splitport(authority)\n-\n-        if default_port and port is None and scheme is not None:\n-            dport = {\"http\": 80,\n-                     \"https\": 443,\n-                     }.get(scheme)\n-            if dport is not None:\n-                authority = \"%s:%d\" % (host, dport)\n-\n-        return authority, path\n-\n-    def is_suburi(self, base, test):\n-        \"\"\"Check if test is below base in a URI tree\n-\n-        Both args must be URIs in reduced form.\n-        \"\"\"\n-        if base == test:\n-            return True\n-        if base[0] != test[0]:\n-            return False\n-        common = urllib2.posixpath.commonprefix((base[1], test[1]))\n-        if len(common) == len(base[1]):\n-            return True\n-        return False\n-\n-    def empty(self):\n-        self.passwd = {}\n-\n-    def remove(self, uri, realm=None):\n-        # uri could be a single URI or a sequence\n-        if isinstance(uri, basestring):\n-            uri = [uri]\n-\n-        for default_port in True, False:\n-            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])\n-            del self.passwd[reduced_uri][realm]\n-\n-    def __contains__(self, uri):\n-        # uri could be a single URI or a sequence\n-        if isinstance(uri, basestring):\n-            uri = [uri]\n-\n-        uri = tuple([self.reduce_uri(u, False) for u in uri])\n-\n-        if uri in self.passwd:\n-            return True\n-\n-        return False\n-\n-auth_manager = AuthManager()\n-\n-\n class AuthObject(object):\n     \"\"\"The :class:`AuthObject` is a simple HTTP Authentication token.\n \n\n@@ -41,43 +41,31 @@ def encode_params(params):\n     else:\n         return params\n \n-def build_url(url, params):\n+\n+def build_url(url, query_params):\n     \"\"\"Build the actual URL to use.\"\"\"\n \n-\n     # Support for unicode domain names and paths.\n-    (scheme, netloc, path, params, query, fragment) = urlparse(url)\n-\n-    # International Domain Name\n+    scheme, netloc, path, params, query, fragment = urlparse(url)\n     netloc = netloc.encode('idna')\n \n-    # Encode the path to to utf-8.\n     if isinstance(path, unicode):\n        path = path.encode('utf-8')\n \n-    # URL-encode the path.\n     path = urllib.quote(path, safe=\"%/:=&?~#+!$,;'@()*[]\")\n \n-    # Turn it back into a bytestring.\n-    url = str(urlunparse([scheme, netloc, path, params, query, fragment]))\n     url = str(urlunparse(\n      [scheme, netloc, path, params, query, fragment]\n     ))\n \n-    # Query Parameters?\n-    if params:\n-        params = encode_params(params)\n+    query_params = encode_params(query_params)\n \n-        # If query parameters already exist in the URL, append.\n+    if query_params:\n        if urlparse(url).query:\n-            return '%s&%s' % (url, params)\n-\n-        # Otherwise, have at it.\n+           return '%s&%s' % (url, query_params)\n        else:\n-            return '%s?%s' % (url, params)\n-\n+           return '%s?%s' % (url, query_params)\n     else:\n-        # Kosher URL.\n        return url\n \n \n@@ -137,7 +125,6 @@ def dict_from_cookiejar(cj):\n     for _, cookies in cj._cookies.items():\n         for _, cookies in cookies.items():\n             for cookie in cookies.values():\n-                # print cookie\n                 cookie_dict[cookie.name] = cookie.value\n \n     return cookie_dict\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#8565053c9355f3760403d41038cc73c5662e2ba9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 6 | Files Changed: 2 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 15 | Churn Cumulative: 3048 | Contributors (this commit): 18 | Commits (past 90d): 123 | Contributors (cumulative): 23 | DMM Complexity: 0.0\n\nDIFF:\n@@ -332,8 +332,8 @@ class Request(object):\n                     redirect=False,\n                     assert_same_host=False,\n                     # preload_content=True\n-                    preload_content=False\n-                    # block=do_block\n+                    # preload_content=False\n+                    preload_content=do_block\n                 )\n \n                 # Extract cookies.\n@@ -467,7 +467,7 @@ class Response(object):\n         # print\n \n         # self.raw.read() or\n-        self._content = self.raw.read()\n+        self._content = self.raw.read() or self.raw.data\n         # print self.raw.__dict__\n \n         # Decode GZip'd content.\n\n@@ -15,7 +15,7 @@ import cookielib\n import re\n import urllib\n import zlib\n-from urlparse import urlparse, urlunparse, urljoin\n+from urlparse import urlparse, urlunparse\n \n \n def encode_params(params):\n@@ -33,8 +33,11 @@ def encode_params(params):\n         result = []\n         for k, vs in params.items():\n             for v in isinstance(vs, list) and vs or [vs]:\n-                result.append((k.encode('utf-8') if isinstance(k, unicode) else k,\n-                               v.encode('utf-8') if isinstance(v, unicode) else v)\n+                result.append(\n+                    (\n+                        k.encode('utf-8') if isinstance(k, unicode) else k,\n+                        v.encode('utf-8') if isinstance(v, unicode) else v\n+                    )\n                 )\n         return urllib.urlencode(result, doseq=True)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#bd2b0c45baba6ab6b4fabcf5d7588a63db1865bd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 115 | Files Changed: 1 | Hunks: 6 | Methods Changed: 6 | Complexity Δ (Sum/Max): -14/0 | Churn Δ: 115 | Churn Cumulative: 2515 | Contributors (this commit): 17 | Commits (past 90d): 88 | Contributors (cumulative): 17 | DMM Complexity: 0.7894736842105263\n\nDIFF:\n@@ -81,11 +81,6 @@ class Request(object):\n         #: content and metadata of HTTP Response, once :attr:`sent <send>`.\n         self.response = Response()\n \n-        # if isinstance(auth, (list, tuple)):\n-        #     auth = AuthObject(*auth)\n-        # if not auth:\n-        #     auth = auth_manager.get_auth(self.url)\n-\n         #: :class:`AuthObject` to attach to :class:`Request <Request>`.\n         # self.auth = auth\n \n@@ -120,54 +115,6 @@ class Request(object):\n         if not self.url:\n             raise URLRequired\n \n-    def _get_opener(self):\n-        \"\"\"Creates appropriate opener object for urllib2.\"\"\"\n-\n-        _handlers = []\n-\n-        if self.cookiejar is not None:\n-            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))\n-\n-        if self.auth:\n-            if not isinstance(self.auth.handler,\n-                (urllib2.AbstractBasicAuthHandler,\n-                urllib2.AbstractDigestAuthHandler)):\n-\n-                # TODO: REMOVE THIS COMPLETELY\n-                auth_manager.add_password(\n-                    self.auth.realm, self.url,\n-                    self.auth.username,\n-                    self.auth.password)\n-\n-                self.auth.handler = self.auth.handler(auth_manager)\n-                auth_manager.add_auth(self.url, self.auth)\n-\n-            _handlers.append(self.auth.handler)\n-\n-        if self.proxies:\n-            _handlers.append(urllib2.ProxyHandler(self.proxies))\n-\n-        _handlers.append(HTTPRedirectHandler)\n-\n-        if not _handlers:\n-            return urllib2.urlopen\n-\n-        if self.data or self.files:\n-            _handlers.extend(get_handlers())\n-\n-        opener = urllib2.build_opener(*_handlers)\n-\n-        if self.headers:\n-            # Allow default headers in the opener to be overloaded\n-            normal_keys = [k.capitalize() for k in self.headers]\n-            for key, val in opener.addheaders[:]:\n-                if key not in normal_keys:\n-                    continue\n-                # Remove it, we have a value to take its place\n-                opener.addheaders.remove((key, val))\n-\n-        return opener.open\n-\n     def _build_response(self, resp, is_error=False):\n         \"\"\"Build internal :class:`Response <Response>` object\n         from given response.\n@@ -181,23 +128,6 @@ class Request(object):\n             try:\n                 response.headers = CaseInsensitiveDict(getattr(resp, 'headers', None))\n                 response.raw = resp\n-                # print dir(self.response.raw)\n-                # print self\n-\n-                # print (response.raw)\n-                # print dir(response.raw)\n-                # print response.raw.sock.read()\n-                # print '------'\n-\n-\n-                # if self.cookiejar:\n-\n-                    # response.cookies = dict_from_cookiejar(self.cookiejar)\n-\n-\n-                    # response.cookies = dict_from_cookiejar(self.cookiejar)\n-\n-                    # response.cookies = dict_from_cookiejar(self.cookiejar)\n \n             except AttributeError:\n                 pass\n@@ -455,20 +385,7 @@ class Response(object):\n                 'The content for this response was already consumed')\n \n         # Read the contents.\n-        # print self.raw.__dict__\n-\n-        # print\n-        # print '~'\n-        # # print self.raw\n-        # print self.raw.getresponse()\n-        # print dir(self.raw)\n-        # print\n-        # print\n-        # print\n-\n-        # self.raw.read() or\n         self._content = self.raw.read() or self.raw.data\n-        # print self.raw.__dict__\n \n         # Decode GZip'd content.\n         if 'gzip' in self.headers.get('content-encoding', ''):\n@@ -502,35 +419,3 @@ class Response(object):\n \n         elif (self.status_code >= 500) and (self.status_code < 600):\n             raise Exception('500 yo')\n-\n-\n-class AuthObject(object):\n-    \"\"\"The :class:`AuthObject` is a simple HTTP Authentication token.\n-\n-    When given to a Requests function, it enables Basic HTTP Authentication\n-    for that Request. You can also enable Authorization for domain realms\n-    with AutoAuth. See AutoAuth for more details.\n-\n-    :param username: Username to authenticate with.\n-    :param password: Password for given username.\n-    :param realm: (optional) the realm this auth applies to\n-    :param handler: (optional) basic || digest || proxy_basic || proxy_digest\n-    \"\"\"\n-\n-    _handlers = {\n-        # 'basic': HTTPBasicAuthHandler,\n-        # 'forced_basic': HTTPForcedBasicAuthHandler,\n-        # 'digest': HTTPDigestAuthHandler,\n-        # 'proxy_basic': urllib2.ProxyBasicAuthHandler,\n-        # 'proxy_digest': urllib2.ProxyDigestAuthHandler\n-    }\n-\n-    def __init__(self, username, password, handler='forced_basic', realm=None):\n-        self.username = username\n-        self.password = password\n-        self.realm = realm\n-\n-        if isinstance(handler, basestring):\n-            self.handler = self._handlers.get(handler.lower(), HTTPForcedBasicAuthHandler)\n-        else:\n-            self.handler = handler\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#9488af5a42bb02913d99e2255cd53f2ad7c860e9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 8 | Churn Cumulative: 3174 | Contributors (this commit): 18 | Commits (past 90d): 113 | Contributors (cumulative): 24 | DMM Complexity: 1.0\n\nDIFF:\n@@ -12,7 +12,7 @@ This module impliments the Requests API.\n \"\"\"\n \n import config\n-from .models import Request, Response, AuthObject\n+from .models import Request, Response\n from .status_codes import codes\n from .hooks import dispatch_hook\n from .utils import cookiejar_from_dict, header_expand\n\n@@ -82,7 +82,7 @@ class Request(object):\n         self.response = Response()\n \n         #: :class:`AuthObject` to attach to :class:`Request <Request>`.\n-        # self.auth = auth\n+        self.auth = auth\n \n         #: CookieJar to attach to :class:`Request <Request>`.\n         self.cookies = cookies\n@@ -161,7 +161,7 @@ class Request(object):\n             ):\n \n                 # We already redirected. Don't keep it alive.\n-                r.raw.close()\n+                # r.raw.close()\n \n                 # Woah, this is getting crazy.\n                 if len(history) >= settings.max_redirects:\n@@ -196,7 +196,7 @@ class Request(object):\n                 # Create the new Request.\n                 request = Request(\n                     url, self.headers, self.files, method,\n-                    self.data, self.params, self.auth, self.cookiejar,\n+                    self.data, self.params, self.auth, self.cookies,\n \n                     # Flag as part of a redirect loop.\n                     redirect=True\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#dc7b4e7d32e45494d43d37c3d7c61032211b83ca", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 41 | Lines Deleted: 29 | Files Changed: 3 | Hunks: 15 | Methods Changed: 10 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 70 | Churn Cumulative: 2868 | Contributors (this commit): 18 | Commits (past 90d): 115 | Contributors (cumulative): 24 | DMM Complexity: 0.25\n\nDIFF:\n@@ -8,8 +8,6 @@ This module provides the Requests settings feature set.\n \n settings parameters:\n \n-TODO: Verify!!!\n-TODO: Make sure format is acceptabl/cool\n - :base_headers: - Sets default User-Agent to `python-requests.org`\n - :accept_gzip:  - Whether or not to accept gzip-compressed data\n - :proxies: - http proxies?\n@@ -18,29 +16,29 @@ TODO: Make sure format is acceptabl/cool\n - :max_redirects: - maximum number of allowed redirects?\n - :decode_unicode: - whether or not to accept unicode?\n \n-Used globally\n-\n \"\"\"\n \n+def merge_configs(config, default_config=None):\n+    \"\"\"Merge two given configurations.\"\"\"\n \n-class Settings(object):\n+    # Use the module-level defaults, if none is given.\n+    if default_config is None:\n+        default_config = config.copy()\n \n-    def __init__(self, **kwargs):\n-        super(Settings, self).__init__()\n+    d = default_config.copy()\n+    d.update(config)\n \n-    def __getattribute__(self, key):\n-        return object.__getattribute__(self, key)\n+    return d\n+\n+# Module-level defaults.\n+config = dict()\n+\n+config['base_headers'] = {'User-Agent': 'python-requests.org'}\n+config['accept_gzip'] = True\n+config['proxies'] = {}\n+config['verbose'] = None\n+config['timeout'] = None\n+config['max_redirects'] = 30\n+config['decode_unicode'] = True\n \n \n-settings = Settings()\n-\n-settings.base_headers = {'User-Agent': 'python-requests.org'}\n-settings.accept_gzip = True\n-settings.proxies = None\n-settings.verbose = None\n-settings.timeout = None\n-settings.max_redirects = 30\n-settings.decode_unicode = True\n-\n-#: Use socket.setdefaulttimeout() as fallback?\n-settings.timeout_fallback = True\n\n@@ -160,6 +160,10 @@ class Request(object):\n                 (self.allow_redirects))\n             ):\n \n+                # print r.headers['location']\n+                # print dir(r.raw._original_response.fp)\n+                # print '--'\n+\n                 # We already redirected. Don't keep it alive.\n                 # r.raw.close()\n \n@@ -195,8 +199,15 @@ class Request(object):\n \n                 # Create the new Request.\n                 request = Request(\n-                    url, self.headers, self.files, method,\n-                    self.data, self.params, self.auth, self.cookies,\n+                    url=url,\n+                    headers=self.headers,\n+                    files=self.files,\n+                    method=method,\n+                    data=self.data,\n+                    # params=self.params,\n+                    params=None,\n+                    auth=self.auth,\n+                    cookies=self.cookies,\n \n                     # Flag as part of a redirect loop.\n                     redirect=True\n@@ -272,6 +283,7 @@ class Request(object):\n \n             # except (urllib2.HTTPError, urllib2.URLError), why:\n             except Exception, why:\n+                print why.__dict__\n                 # if hasattr(why, 'reason'):\n                 #     if isinstance(why.reason, socket.timeout):\n                 #         why = Timeout(why)\n\n@@ -18,12 +18,16 @@ from .utils import add_dict_to_cookiejar\n class Session(object):\n     \"\"\"A Requests session.\"\"\"\n \n-    __attrs__ = ['headers', 'cookies', 'auth', 'timeout', 'proxies', 'hooks']\n+    __attrs__ = [\n+        'headers', 'cookies', 'auth', 'timeout', 'proxies', 'hooks',\n+        'config'\n+    ]\n \n     def __init__(self, **kwargs):\n \n         # Set up a CookieJar to be used by default\n         self.cookies = cookielib.FileCookieJar()\n+        self.config = kwargs.get('config') or dict()\n \n         # Map args from kwargs to instance-local variables\n         map(lambda k, v: (k in self.__attrs__) and setattr(self, k, v),\n@@ -39,7 +43,6 @@ class Session(object):\n         return self\n \n     def __exit__(self, *args):\n-        # print args\n         pass\n \n     def _map_api_methods(self):\n@@ -50,8 +53,8 @@ class Session(object):\n \n         def pass_args(func):\n             def wrapper_func(*args, **kwargs):\n-                inst_attrs = dict((k, v) for k, v in self.__dict__.iteritems()\n-                        if k in self.__attrs__)\n+                inst_attrs = dict((k, v) for k, v in self.__dict__.iteritems() if k in self.__attrs__)\n+\n                 # Combine instance-local values with kwargs values, with\n                 # priority to values in kwargs\n                 kwargs = dict(inst_attrs.items() + kwargs.items())\n@@ -70,8 +73,7 @@ class Session(object):\n             return wrapper_func\n \n         # Map and decorate each function available in requests.api\n-        map(lambda fn: setattr(self, fn, pass_args(getattr(api, fn))),\n-                api.__all__)\n+        map(lambda fn: setattr(self, fn, pass_args(getattr(api, fn))), api.__all__)\n \n \n def session(**kwargs):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
