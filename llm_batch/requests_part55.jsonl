{"custom_id": "requests#c6183d273c50a5ab50d00315597cd842543af6e1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 7099 | Contributors (this commit): 89 | Commits (past 90d): 32 | Contributors (cumulative): 89 | DMM Complexity: None\n\nDIFF:\n@@ -574,7 +574,6 @@ class Response(BaseResponse):\n \n         header = self.headers['link']\n \n-        # l = MultiDict()\n         l = {}\n \n         if header:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#ed360dcaf5af53a37b01c96bd50b3e91f0d6ac37", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 1169 | Contributors (this commit): 23 | Commits (past 90d): 7 | Contributors (cumulative): 23 | DMM Complexity: None\n\nDIFF:\n@@ -19,7 +19,7 @@ from .utils import header_expand, from_key_val_list\n from .packages.urllib3.poolmanager import PoolManager\n \n \n-from adapters import HTTPAdapter\n+from .adapters import HTTPAdapter\n \n def merge_kwargs(local_kwarg, default_kwarg):\n     \"\"\"Merges kwarg dictionaries.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#73ca21ed8ca1078ac1f165875fa3a8c3260c3dff", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 7595 | Contributors (this commit): 90 | Commits (past 90d): 34 | Contributors (cumulative): 90 | DMM Complexity: None\n\nDIFF:\n@@ -295,7 +295,7 @@ class PreparedRequest(RequestMixin):\n         \"\"\"Prepares the given HTTP headers.\"\"\"\n \n         if headers:\n-            self.headers = CaseInsensitiveDict(self.headers)\n+            self.headers = CaseInsensitiveDict(headers)\n         else:\n             self.headers = CaseInsensitiveDict()\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#7ec0170a006e46144a924ae8e7e62d577e2195f7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 8 | Churn Cumulative: 7611 | Contributors (this commit): 90 | Commits (past 90d): 36 | Contributors (cumulative): 90 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1048,10 +1048,14 @@ class Response(BaseResponse):\n             # a best guess).\n             encoding = guess_json_utf(self.content)\n             if encoding is not None:\n+                try:\n                     return json.loads(self.content.decode(encoding))\n-\n+                except (ValueError, UnicodeDecodeError):\n+                    pass\n+        try:\n             return json.loads(self.text or self.content)\n-\n+        except ValueError:\n+            return None\n \n     @property\n     def links(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#898079f7e2d4e9cf4a67a9824b98ae2193545ad0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 7638 | Contributors (this commit): 90 | Commits (past 90d): 38 | Contributors (cumulative): 90 | DMM Complexity: None\n\nDIFF:\n@@ -48,7 +48,6 @@ log = logging.getLogger(__name__)\n \n \n class RequestMixin(object):\n-    \"\"\"docstring for RequestMixin\"\"\"\n \n     @property\n     def path_url(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#d15365bf4fd34c3a09956f35a2992cfef27a75d0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 12 | Files Changed: 1 | Hunks: 6 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 13 | Churn Cumulative: 7651 | Contributors (this commit): 90 | Commits (past 90d): 39 | Contributors (cumulative): 90 | DMM Complexity: 0.0\n\nDIFF:\n@@ -171,14 +171,9 @@ class Request(object):\n         self.params = params\n         self.auth = auth\n         self.cookies = cookies\n-        # self.timeout = timeout\n-        # TODO: move to attached\n         self.allow_redirects = allow_redirects\n         self.proxies = proxies\n         self.hooks = hooks\n-        # self.prefetch = prefetch\n-        # self.verify = verify\n-        # self.cert = cert\n \n     def __repr__(self):\n         return '<Request [%s]>' % (self.method)\n@@ -186,6 +181,7 @@ class Request(object):\n     def prepare(self):\n         \"\"\"Constructs a PreparedRequest and returns it.\"\"\"\n         p = PreparedRequest()\n+\n         p.prepare_method(self.method)\n         p.prepare_url(self.url, self.params)\n         p.prepare_headers(self.headers)\n@@ -193,7 +189,6 @@ class Request(object):\n         p.prepare_auth(self.auth)\n         p.prepare_body(self.data, self.files)\n \n-\n         return p\n \n \n@@ -209,15 +204,9 @@ class PreparedRequest(RequestMixin):\n         self.body = None\n         self.params = None\n         self.auth = None\n-        # self.cookies = None\n-        self.timeout = None\n-        # TODO: move to attached\n         self.allow_redirects = None\n         self.proxies = None\n         self.hooks = None\n-        # self.prefetch = None\n-        # self.verify = None\n-        # self.cert = None\n \n     def __repr__(self):\n         return '<PreparedRequest [%s]>' % (self.method)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#42a206e5d32c878d7fee04849adc7ef8991fbacf", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 7657 | Contributors (this commit): 90 | Commits (past 90d): 40 | Contributors (cumulative): 90 | DMM Complexity: None\n\nDIFF:\n@@ -145,7 +145,7 @@ class RequestMixin(object):\n \n \n class Request(object):\n-    \"\"\"A user-created Request object.\"\"\"\n+    \"\"\"A user-created :class:`Request <Request>` object.\"\"\"\n     def __init__(self,\n         method=None,\n         url=None,\n@@ -193,9 +193,7 @@ class Request(object):\n \n \n class PreparedRequest(RequestMixin):\n-    \"\"\"The :class:`Request <Request>` object. It carries out all functionality\n-    of Requests. Recommended interface is with the Requests functions.\n-    \"\"\"\n+    \"\"\"The :class:`PreparedRequest <PreparedRequest>` object.\"\"\"\n \n     def __init__(self):\n         self.method = None\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4a01272fb3a56d718c82305e40d967dc0318bd32", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 127 | Lines Deleted: 623 | Files Changed: 4 | Hunks: 9 | Methods Changed: 15 | Complexity Δ (Sum/Max): -56/21 | Churn Δ: 750 | Churn Cumulative: 10591 | Contributors (this commit): 102 | Commits (past 90d): 62 | Contributors (cumulative): 124 | DMM Complexity: 0.7979274611398963\n\nDIFF:\n@@ -1,4 +1,127 @@\n \n+    def old_request(self, method, url,\n+        params=None,\n+        data=None,\n+        headers=None,\n+        cookies=None,\n+        files=None,\n+        auth=None,\n+        timeout=None,\n+        allow_redirects=True,\n+        proxies=None,\n+        hooks=None,\n+        return_response=True,\n+        config=None,\n+        prefetch=None,\n+        verify=None,\n+        cert=None):\n+\n+        \"\"\"Constructs and sends a :class:`Request <Request>`.\n+        Returns :class:`Response <Response>` object.\n+\n+        :param method: method for the new :class:`Request` object.\n+        :param url: URL for the new :class:`Request` object.\n+        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.\n+        :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.\n+        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n+        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n+        :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n+        :param auth: (optional) Auth tuple or callable to enable Basic/Digest/Custom HTTP Auth.\n+        :param timeout: (optional) Float describing the timeout of the request.\n+        :param allow_redirects: (optional) Boolean. Set to True by default.\n+        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n+        :param return_response: (optional) If False, an un-sent Request object will returned.\n+        :param config: (optional) A configuration dictionary. See ``request.defaults`` for allowed keys and their default values.\n+        :param prefetch: (optional) whether to immediately download the response content. Defaults to ``True``.\n+        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n+        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n+        \"\"\"\n+\n+        method = str(method).upper()\n+\n+        # Default empty dicts for dict params.\n+        data = [] if data is None else data\n+        files = [] if files is None else files\n+        headers = {} if headers is None else headers\n+        params = {} if params is None else params\n+        hooks = {} if hooks is None else hooks\n+        prefetch = prefetch if prefetch is not None else self.prefetch\n+\n+        # use session's hooks as defaults\n+        for key, cb in list(self.hooks.items()):\n+            hooks.setdefault(key, cb)\n+\n+        # Expand header values.\n+        if headers:\n+            for k, v in list(headers.items() or {}):\n+                headers[k] = header_expand(v)\n+\n+        args = dict(\n+            method=method,\n+            url=url,\n+            data=data,\n+            params=from_key_val_list(params),\n+            headers=from_key_val_list(headers),\n+            cookies=cookies,\n+            files=files,\n+            auth=auth,\n+            hooks=from_key_val_list(hooks),\n+            timeout=timeout,\n+            allow_redirects=allow_redirects,\n+            proxies=from_key_val_list(proxies),\n+            config=from_key_val_list(config),\n+            prefetch=prefetch,\n+            verify=verify,\n+            cert=cert,\n+            _poolmanager=self.poolmanager\n+        )\n+\n+        # merge session cookies into passed-in ones\n+        dead_cookies = None\n+        # passed-in cookies must become a CookieJar:\n+        if not isinstance(cookies, cookielib.CookieJar):\n+            args['cookies'] = cookiejar_from_dict(cookies)\n+            # support unsetting cookies that have been passed in with None values\n+            # this is only meaningful when `cookies` is a dict ---\n+            # for a real CookieJar, the client should use session.cookies.clear()\n+            if cookies is not None:\n+                dead_cookies = [name for name in cookies if cookies[name] is None]\n+        # merge the session's cookies into the passed-in cookies:\n+        for cookie in self.cookies:\n+            args['cookies'].set_cookie(cookie)\n+        # remove the unset cookies from the jar we'll be using with the current request\n+        # (but not from the session's own store of cookies):\n+        if dead_cookies is not None:\n+            for name in dead_cookies:\n+                remove_cookie_by_name(args['cookies'], name)\n+\n+        # Merge local kwargs with session kwargs.\n+        for attr in self.__attrs__:\n+            # we already merged cookies:\n+            if attr == 'cookies':\n+                continue\n+\n+            session_val = getattr(self, attr, None)\n+            local_val = args.get(attr)\n+            args[attr] = merge_kwargs(local_val, session_val)\n+\n+        # Arguments manipulation hook.\n+        args = dispatch_hook('args', args['hooks'], args)\n+\n+        # Create the (empty) response.\n+        r = Request(**args)\n+\n+        # Give the response some context.\n+        r.session = self\n+\n+        # Don't send if asked nicely.\n+        if not return_response:\n+            return r\n+\n+        # Send the HTTP Request.\n+        return self._send_request(r, **args)\n+\n+\n class OldRequest(object):\n     \"\"\"The :class:`Request <Request>` object. It carries out all functionality\n     of Requests. Recommended interface is with the Requests functions.\n\n@@ -38,7 +38,7 @@ class MockRequest(object):\n         return self.type\n \n     def get_host(self):\n-        return urlparse(self._r.full_url).netloc\n+        return urlparse(self._r.url).netloc\n \n     def get_origin_req_host(self):\n         if self._r.response.history:\n@@ -48,7 +48,7 @@ class MockRequest(object):\n             return self.get_host()\n \n     def get_full_url(self):\n-        return self._r.full_url\n+        return self._r.url\n \n     def is_unverifiable(self):\n         # unverifiable == redirected\n\n@@ -11,7 +11,6 @@ import os\n import socket\n import collections\n import logging\n-from copy import deepcopy\n \n from datetime import datetime\n from io import BytesIO\n@@ -319,9 +318,8 @@ class PreparedRequest(RequestMixin):\n \n         self.body = body\n \n-\n-\n     def prepare_auth(self, auth):\n+        \"\"\"Prepares the given HTTP auth data.\"\"\"\n         if auth:\n             if isinstance(auth, tuple) and len(auth) == 2:\n                 # special-case basic HTTP auth\n@@ -334,6 +332,7 @@ class PreparedRequest(RequestMixin):\n             self.__dict__.update(r.__dict__)\n \n     def prepare_cookies(self, cookies):\n+        \"\"\"Prepares the given HTTP cookie data.\"\"\"\n \n         if isinstance(cookies, cookielib.CookieJar):\n             cookies = cookies\n@@ -346,500 +345,6 @@ class PreparedRequest(RequestMixin):\n                 self.headers['Cookie'] = cookie_header\n \n \n-\n-class OldRequest(object):\n-    \"\"\"The :class:`Request <Request>` object. It carries out all functionality\n-    of Requests. Recommended interface is with the Requests functions.\n-    \"\"\"\n-\n-    def __init__(self,\n-        url=None,\n-        headers=dict(),\n-        files=None,\n-        method=None,\n-        data=dict(),\n-        params=dict(),\n-        auth=None,\n-        cookies=None,\n-        timeout=None,\n-        redirect=False,\n-        allow_redirects=False,\n-        proxies=None,\n-        hooks=None,\n-        config=None,\n-        prefetch=True,\n-        _poolmanager=None,\n-        verify=None,\n-        session=None,\n-        cert=None):\n-\n-        #: Dictionary of configurations for this request.\n-        self.config = dict(config or [])\n-\n-        #: Float describes the timeout of the request.\n-        #  (Use socket.setdefaulttimeout() as fallback)\n-        self.timeout = timeout\n-\n-        # URL\n-\n-        #: Dictionary of HTTP Headers to attach to the :class:`Request <Request>`.\n-        self.headers = dict(headers or [])\n-\n-        #: Dictionary of files to multipart upload (``{filename: content}``).\n-        self.files = None\n-\n-        #: HTTP Method to use.\n-        self.method = method\n-\n-        #: Dictionary, bytes or file stream of request body data to attach to the\n-        #: :class:`Request <Request>`.\n-        self.data = None\n-\n-        #: Dictionary of querystring data to attach to the\n-        #: :class:`Request <Request>`. The dictionary values can be lists for representing\n-        #: multivalued query parameters.\n-        self.params = None\n-\n-        #: True if :class:`Request <Request>` is part of a redirect chain (disables history\n-        #: and HTTPError storage).\n-        self.redirect = redirect\n-\n-        #: Set to True if full redirects are allowed (e.g. re-POST-ing of data at new ``Location``)\n-        self.allow_redirects = allow_redirects\n-\n-        # Dictionary mapping protocol to the URL of the proxy (e.g. {'http': 'foo.bar:3128'})\n-        self.proxies = dict(proxies or [])\n-\n-        for proxy_type, uri_ref in list(self.proxies.items()):\n-            if not uri_ref:\n-                del self.proxies[proxy_type]\n-\n-        # If no proxies are given, allow configuration by environment variables\n-        # HTTP_PROXY and HTTPS_PROXY.\n-        if not self.proxies and self.config.get('trust_env'):\n-            self.proxies = get_environ_proxies(self.url)\n-\n-        self.data = data\n-        self.params = params\n-        self.files = files\n-\n-        #: :class:`Response <Response>` instance, containing\n-        #: content and metadata of HTTP Response, once :attr:`sent <send>`.\n-        self.response = Response()\n-\n-        #: Authentication tuple or object to attach to :class:`Request <Request>`.\n-        self.auth = auth\n-\n-        # #: CookieJar to attach to :class:`Request <Request>`.\n-        # if isinstance(cookies, cookielib.CookieJar):\n-        #     self.cookies = cookies\n-        # else:\n-        #     self.cookies = cookiejar_from_dict(cookies)\n-\n-        #: True if Request has been sent.\n-        self.sent = False\n-\n-        #: Event-handling hooks.\n-        self.hooks = {}\n-\n-        for event in HOOKS:\n-            self.hooks[event] = []\n-\n-        hooks = hooks or {}\n-\n-        for (k, v) in list(hooks.items()):\n-            self.register_hook(event=k, hook=v)\n-\n-        #: Session.\n-        self.session = session\n-\n-        #: SSL Verification.\n-        self.verify = verify\n-\n-        #: SSL Certificate\n-        self.cert = cert\n-\n-        #: Prefetch response content\n-        self.prefetch = prefetch\n-\n-        # if headers:\n-        #     headers = CaseInsensitiveDict(self.headers)\n-        # else:\n-        #     headers = CaseInsensitiveDict()\n-\n-        # Add configured base headers.\n-        for (k, v) in list(self.config.get('base_headers', {}).items()):\n-            if k not in headers:\n-                headers[k] = v\n-\n-        self.headers = headers\n-        self._poolmanager = _poolmanager\n-\n-    def __repr__(self):\n-        return '<Request [%s]>' % (self.method)\n-\n-    def _build_response(self, resp):\n-        \"\"\"Build internal :class:`Response <Response>` object\n-        from given response.\n-        \"\"\"\n-\n-        def build(resp):\n-\n-            response = Response()\n-\n-            # Pass settings over.\n-            response.config = self.config\n-\n-            if resp:\n-\n-                # Fallback to None if there's no status_code, for whatever reason.\n-                # response.status_code = getattr(resp, 'status', None)\n-\n-                # Make headers case-insensitive.\n-                # response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))\n-\n-                # Set encoding.\n-                # response.encoding = get_encoding_from_headers(response.headers)\n-\n-                # Add new cookies from the server.\n-                extract_cookies_to_jar(self.cookies, self, resp)\n-\n-                # Save cookies in Response.\n-                response.cookies = self.cookies\n-\n-                # Save cookies in Session.\n-                for cookie in self.cookies:\n-                    self.session.cookies.set_cookie(cookie)\n-\n-                # No exceptions were harmed in the making of this request.\n-                response.error = getattr(resp, 'error', None)\n-\n-            # Save original response for later.\n-            response.raw = resp\n-            if isinstance(self.full_url, bytes):\n-                response.url = self.full_url.decode('utf-8')\n-            else:\n-                response.url = self.full_url\n-\n-            return response\n-\n-        history = []\n-\n-        r = build(resp)\n-        # TODO: session level shit\n-        if r.status_code in REDIRECT_STATI and not self.redirect:\n-\n-            while (('location' in r.headers and r.status_code in REDIRECT_STATI) and\n-                   ((r.status_code is codes.see_other) or (self.allow_redirects))):\n-\n-                r.content  # Consume socket so it can be released\n-\n-                if not len(history) < self.config.get('max_redirects'):\n-                    raise TooManyRedirects()\n-\n-                # Release the connection back into the pool.\n-                r.raw.release_conn()\n-\n-                history.append(r)\n-\n-                url = r.headers['location']\n-                data = self.data\n-                files = self.files\n-\n-                # Handle redirection without scheme (see: RFC 1808 Section 4)\n-                if url.startswith('//'):\n-                    parsed_rurl = urlparse(r.url)\n-                    url = '%s:%s' % (parsed_rurl.scheme, url)\n-\n-                # Facilitate non-RFC2616-compliant 'location' headers\n-                # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n-                if not urlparse(url).netloc:\n-                    url = urljoin(r.url,\n-                                  # Compliant with RFC3986, we percent\n-                                  # encode the url.\n-                                  requote_uri(url))\n-\n-                # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n-                if r.status_code is codes.see_other:\n-                    method = 'GET'\n-                    data = None\n-                    files = None\n-                else:\n-                    method = self.method\n-\n-                # Do what the browsers do, despite standards...\n-                if r.status_code in (codes.moved, codes.found) and self.method == 'POST':\n-                    method = 'GET'\n-                    data = None\n-                    files = None\n-\n-                if (r.status_code == 303) and self.method != 'HEAD':\n-                    method = 'GET'\n-                    data = None\n-                    files = None\n-\n-                # Remove the cookie headers that were sent.\n-                headers = self.headers\n-                try:\n-                    del headers['Cookie']\n-                except KeyError:\n-                    pass\n-\n-                request = Request(\n-                    url=url,\n-                    headers=headers,\n-                    files=files,\n-                    method=method,\n-                    params=self.session.params,\n-                    auth=self.auth,\n-                    cookies=self.cookies,\n-                    redirect=True,\n-                    data=data,\n-                    config=self.config,\n-                    timeout=self.timeout,\n-                    _poolmanager=self._poolmanager,\n-                    proxies=self.proxies,\n-                    verify=self.verify,\n-                    session=self.session,\n-                    cert=self.cert,\n-                    prefetch=self.prefetch\n-                )\n-\n-                request.send()\n-                r = request.response\n-\n-            r.history = history\n-\n-        self.response = r\n-        self.response.request = self\n-\n-\n-    def register_hook(self, event, hook):\n-        \"\"\"Properly register a hook.\"\"\"\n-        if isinstance(hook, collections.Callable):\n-            self.hooks[event].append(hook)\n-        elif hasattr(hook, '__iter__'):\n-            self.hooks[event].extend(h for h in hook if isinstance(h, collections.Callable))\n-\n-    def deregister_hook(self, event, hook):\n-        \"\"\"Deregister a previously registered hook.\n-        Returns True if the hook existed, False if not.\n-        \"\"\"\n-\n-        try:\n-            self.hooks[event].remove(hook)\n-            return True\n-        except ValueError:\n-            return False\n-\n-    def send(self, anyway=False, prefetch=None):\n-        \"\"\"Sends the request. Returns True if successful, False if not.\n-        If there was an HTTPError during transmission,\n-        self.response.status_code will contain the HTTPError code.\n-\n-        Once a request is successfully sent, `sent` will equal True.\n-\n-        :param anyway: If True, request will be sent, even if it has\n-        already been sent.\n-\n-        :param prefetch: If not None, will override the request's own setting\n-        for prefetch.\n-        \"\"\"\n-\n-        # Build the URL\n-        url = self.full_url\n-\n-        # Pre-request hook.\n-        r = dispatch_hook('pre_request', self.hooks, self)\n-        self.__dict__.update(r.__dict__)\n-\n-        # Logging\n-        log.info('Sending %s: %s' % (self, url))\n-\n-        # Use .netrc auth if none was provided.\n-        if not self.auth and self.config.get('trust_env'):\n-            self.auth = get_netrc_auth(url)\n-\n-        # if self.auth:\n-        #     if isinstance(self.auth, tuple) and len(self.auth) == 2:\n-        #         # special-case basic HTTP auth\n-        #         self.auth = HTTPBasicAuth(*self.auth)\n-\n-        #     # Allow auth to make its changes.\n-        #     r = self.auth(self)\n-\n-        #     # Update self to reflect the auth changes.\n-        #     self.__dict__.update(r.__dict__)\n-\n-        # # Nottin' on you.\n-        # body = None\n-        # content_type = None\n-\n-        # # Multi-part file uploads.\n-        # if self.files:\n-        #     (body, content_type) = self._encode_files(self.files)\n-        # else:\n-        #     if self.data:\n-\n-        #         body = self._encode_params(self.data)\n-        #         if isinstance(self.data, str) or isinstance(self.data, builtin_str) or hasattr(self.data, 'read'):\n-        #             content_type = None\n-        #         else:\n-        #             content_type = 'application/x-www-form-urlencoded'\n-\n-        # self.headers['Content-Length'] = '0'\n-        # if hasattr(body, 'seek') and hasattr(body, 'tell'):\n-        #     body.seek(0, 2)\n-        #     self.headers['Content-Length'] = str(body.tell())\n-        #     body.seek(0, 0)\n-        # elif body is not None:\n-        #     self.headers['Content-Length'] = str(len(body))\n-\n-        # # Add content-type if it wasn't explicitly provided.\n-        # if (content_type) and (not 'content-type' in self.headers):\n-        #     self.headers['Content-Type'] = content_type\n-\n-        _p = urlparse(url)\n-        no_proxy = filter(lambda x: x.strip(), self.proxies.get('no', '').split(','))\n-        proxy = self.proxies.get(_p.scheme)\n-\n-        if proxy and not any(map(_p.hostname.endswith, no_proxy)):\n-            conn = poolmanager.ProxyManager(self.get_connection_for_url(proxy))\n-            _proxy = urlparse(proxy)\n-            if '@' in _proxy.netloc:\n-                auth, url = _proxy.netloc.split('@', 1)\n-                self.proxy_auth = HTTPProxyAuth(*auth.split(':', 1))\n-                r = self.proxy_auth(self)\n-                self.__dict__.update(r.__dict__)\n-        else:\n-            conn = self.get_connection_for_url(url)\n-\n-        if not self.config.get('keep_alive'):\n-            self.headers['Connection'] = 'close'\n-\n-        # if url.startswith('https') and self.verify:\n-\n-        #     cert_loc = None\n-\n-        #     # Allow self-specified cert location.\n-        #     if self.verify is not True:\n-        #         cert_loc = self.verify\n-\n-        #     # Look for configuration.\n-        #     if not cert_loc and self.config.get('trust_env'):\n-        #         cert_loc = os.environ.get('REQUESTS_CA_BUNDLE')\n-\n-        #     # Curl compatibility.\n-        #     if not cert_loc and self.config.get('trust_env'):\n-        #         cert_loc = os.environ.get('CURL_CA_BUNDLE')\n-\n-        #     if not cert_loc:\n-        #         cert_loc = DEFAULT_CA_BUNDLE_PATH\n-\n-        #     if not cert_loc:\n-        #         raise Exception(\"Could not find a suitable SSL CA certificate bundle.\")\n-\n-        #     conn.cert_reqs = 'CERT_REQUIRED'\n-        #     conn.ca_certs = cert_loc\n-        # else:\n-        #     conn.cert_reqs = 'CERT_NONE'\n-        #     conn.ca_certs = None\n-\n-        # if self.cert:\n-        #     if len(self.cert) == 2:\n-        #         conn.cert_file = self.cert[0]\n-        #         conn.key_file = self.cert[1]\n-        #     else:\n-        #         conn.cert_file = self.cert\n-\n-        if not self.sent or anyway:\n-\n-            # Skip if 'cookie' header is explicitly set.\n-            # if 'cookie' not in self.headers:\n-            #     cookie_header = get_cookie_header(self.cookies, self)\n-            #     if cookie_header is not None:\n-            #         self.headers['Cookie'] = cookie_header\n-\n-            # Pre-send hook.\n-            r = dispatch_hook('pre_send', self.hooks, self)\n-            self.__dict__.update(r.__dict__)\n-\n-            # catch urllib3 exceptions and throw Requests exceptions\n-            # try:\n-            #     # Send the request.\n-            #     r = conn.urlopen(\n-            #         method=self.method,\n-            #         url=self.path_url,\n-            #         body=body,\n-            #         headers=self.headers,\n-            #         redirect=False,\n-            #         assert_same_host=False,\n-            #         preload_content=False,\n-            #         decode_content=False,\n-            #         retries=self.config.get('max_retries', 0),\n-            #         timeout=self.timeout,\n-            #     )\n-            #     self.sent = True\n-\n-            # except socket.error as sockerr:\n-            #     raise ConnectionError(sockerr)\n-\n-            # except MaxRetryError as e:\n-            #     raise ConnectionError(e)\n-\n-            # except (_SSLError, _HTTPError) as e:\n-            #     if isinstance(e, _SSLError):\n-            #         raise SSLError(e)\n-            #     elif isinstance(e, TimeoutError):\n-            #         raise Timeout(e)\n-            #     else:\n-            #         raise Timeout('Request timed out.')\n-\n-            # build_response can throw TooManyRedirects\n-            self._build_response(r)\n-\n-            # Response manipulation hook.\n-            self.response = dispatch_hook('response', self.hooks, self.response)\n-\n-            # Post-request hook.\n-            r = dispatch_hook('post_request', self.hooks, self)\n-            self.__dict__.update(r.__dict__)\n-\n-            # If prefetch is True, mark content as consumed.\n-            if prefetch is None:\n-                prefetch = self.prefetch\n-            if prefetch:\n-                # Save the response.\n-                self.response.content\n-\n-            return self.sent\n-\n-    def get_connection_for_url(self, url):\n-        # Check to see if keep_alive is allowed.\n-        try:\n-            if self.config.get('keep_alive'):\n-                conn = self._poolmanager.connection_from_url(url)\n-            else:\n-                conn = connectionpool.connection_from_url(url)\n-            return conn\n-        except LocationParseError as e:\n-            raise InvalidURL(e)\n-\n-    def prepare(self):\n-        return deepcopy(self)\n-\n-\n-# class BaseResponse(object):\n-#     \"\"\"The basic Respone\"\"\"\n-#     def __init__(self):\n-#         self.url = None\n-#         self.status_code = None\n-#         self.reason = None\n-#         self.headers = None\n-#         self.data = None\n-#         self.body = None\n-\n-\n class Response(object):\n     \"\"\"The core :class:`Response <Response>` object. All\n     :class:`Request <Request>` objects contain a\n\n@@ -169,130 +169,6 @@ class Session(object):\n         return self.send(prep)\n \n \n-\n-\n-    def old_request(self, method, url,\n-        params=None,\n-        data=None,\n-        headers=None,\n-        cookies=None,\n-        files=None,\n-        auth=None,\n-        timeout=None,\n-        allow_redirects=True,\n-        proxies=None,\n-        hooks=None,\n-        return_response=True,\n-        config=None,\n-        prefetch=None,\n-        verify=None,\n-        cert=None):\n-\n-        \"\"\"Constructs and sends a :class:`Request <Request>`.\n-        Returns :class:`Response <Response>` object.\n-\n-        :param method: method for the new :class:`Request` object.\n-        :param url: URL for the new :class:`Request` object.\n-        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.\n-        :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.\n-        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n-        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n-        :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n-        :param auth: (optional) Auth tuple or callable to enable Basic/Digest/Custom HTTP Auth.\n-        :param timeout: (optional) Float describing the timeout of the request.\n-        :param allow_redirects: (optional) Boolean. Set to True by default.\n-        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n-        :param return_response: (optional) If False, an un-sent Request object will returned.\n-        :param config: (optional) A configuration dictionary. See ``request.defaults`` for allowed keys and their default values.\n-        :param prefetch: (optional) whether to immediately download the response content. Defaults to ``True``.\n-        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n-        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n-        \"\"\"\n-\n-        method = str(method).upper()\n-\n-        # Default empty dicts for dict params.\n-        data = [] if data is None else data\n-        files = [] if files is None else files\n-        headers = {} if headers is None else headers\n-        params = {} if params is None else params\n-        hooks = {} if hooks is None else hooks\n-        prefetch = prefetch if prefetch is not None else self.prefetch\n-\n-        # use session's hooks as defaults\n-        for key, cb in list(self.hooks.items()):\n-            hooks.setdefault(key, cb)\n-\n-        # Expand header values.\n-        if headers:\n-            for k, v in list(headers.items() or {}):\n-                headers[k] = header_expand(v)\n-\n-        args = dict(\n-            method=method,\n-            url=url,\n-            data=data,\n-            params=from_key_val_list(params),\n-            headers=from_key_val_list(headers),\n-            cookies=cookies,\n-            files=files,\n-            auth=auth,\n-            hooks=from_key_val_list(hooks),\n-            timeout=timeout,\n-            allow_redirects=allow_redirects,\n-            proxies=from_key_val_list(proxies),\n-            config=from_key_val_list(config),\n-            prefetch=prefetch,\n-            verify=verify,\n-            cert=cert,\n-            _poolmanager=self.poolmanager\n-        )\n-\n-        # merge session cookies into passed-in ones\n-        dead_cookies = None\n-        # passed-in cookies must become a CookieJar:\n-        if not isinstance(cookies, cookielib.CookieJar):\n-            args['cookies'] = cookiejar_from_dict(cookies)\n-            # support unsetting cookies that have been passed in with None values\n-            # this is only meaningful when `cookies` is a dict ---\n-            # for a real CookieJar, the client should use session.cookies.clear()\n-            if cookies is not None:\n-                dead_cookies = [name for name in cookies if cookies[name] is None]\n-        # merge the session's cookies into the passed-in cookies:\n-        for cookie in self.cookies:\n-            args['cookies'].set_cookie(cookie)\n-        # remove the unset cookies from the jar we'll be using with the current request\n-        # (but not from the session's own store of cookies):\n-        if dead_cookies is not None:\n-            for name in dead_cookies:\n-                remove_cookie_by_name(args['cookies'], name)\n-\n-        # Merge local kwargs with session kwargs.\n-        for attr in self.__attrs__:\n-            # we already merged cookies:\n-            if attr == 'cookies':\n-                continue\n-\n-            session_val = getattr(self, attr, None)\n-            local_val = args.get(attr)\n-            args[attr] = merge_kwargs(local_val, session_val)\n-\n-        # Arguments manipulation hook.\n-        args = dispatch_hook('args', args['hooks'], args)\n-\n-        # Create the (empty) response.\n-        r = Request(**args)\n-\n-        # Give the response some context.\n-        r.session = self\n-\n-        # Don't send if asked nicely.\n-        if not return_response:\n-            return r\n-\n-        # Send the HTTP Request.\n-        return self._send_request(r, **args)\n-\n     def get(self, url, **kwargs):\n         \"\"\"Sends a GET request. Returns :class:`Response` object.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#0bee888f73ea5c32547e6d684ad778f6fd0edeb0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 118 | Lines Deleted: 12 | Files Changed: 2 | Hunks: 14 | Methods Changed: 12 | Complexity Δ (Sum/Max): 13/12 | Churn Δ: 130 | Churn Cumulative: 9581 | Contributors (this commit): 98 | Commits (past 90d): 52 | Contributors (cumulative): 113 | DMM Complexity: 0.16279069767441862\n\nDIFF:\n@@ -575,3 +575,6 @@ class Response(object):\n             http_error = HTTPError(http_error_msg)\n             http_error.response = self\n             raise http_error\n+\n+    def close(self):\n+        return self.raw.release_conn()\n\n@@ -18,9 +18,16 @@ from .hooks import dispatch_hook\n from .utils import header_expand, from_key_val_list\n from .packages.urllib3.poolmanager import PoolManager\n \n-\n+from .compat import urlparse, urljoin\n from .adapters import HTTPAdapter\n \n+from .utils import requote_uri\n+\n+from .status_codes import codes\n+REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n+\n+\n+\n def merge_kwargs(local_kwarg, default_kwarg):\n     \"\"\"Merges kwarg dictionaries.\n \n@@ -55,7 +62,89 @@ def merge_kwargs(local_kwarg, default_kwarg):\n     return kwargs\n \n \n-class Session(object):\n+\n+class SessionMixin(object):\n+\n+    def resolve_redirects(self, resp, req, prefetch=True, timeout=None, verify=True, cert=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n+        print resp\n+        print req\n+        print resp.headers['location']\n+        print resp.status_code\n+\n+        # ((resp.status_code is codes.see_other))\n+        while (('location' in resp.headers and resp.status_code in REDIRECT_STATI)):\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            # if not len(history) < self.config.get('max_redirects'):\n+                # raise TooManyRedirects()\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            # history.append(r)\n+\n+            url = resp.headers['location']\n+\n+            # Handle redirection without scheme (see: RFC 1808 Section 4)\n+            if url.startswith('//'):\n+                parsed_rurl = urlparse(resp.url)\n+                url = '%s:%s' % (parsed_rurl.scheme, url)\n+\n+            # Facilitate non-RFC2616-compliant 'location' headers\n+            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n+            if not urlparse(url).netloc:\n+                url = urljoin(resp.url,\n+                              # Compliant with RFC3986, we percent\n+                              # encode the url.\n+                              requote_uri(url))\n+\n+            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n+            if resp.status_code is codes.see_other:\n+                method = 'GET'\n+            else:\n+                method = req.method\n+\n+            # Do what the browsers do, despite standards...\n+            if resp.status_code in (codes.moved, codes.found) and req.method == 'POST':\n+                method = 'GET'\n+\n+            if (resp.status_code == 303) and req.method != 'HEAD':\n+                method = 'GET'\n+\n+            # Remove the cookie headers that were sent.\n+            # headers = req.headers\n+            # try:\n+            #     del headers['Cookie']\n+            # except KeyError:\n+            #     pass\n+\n+            resp = self.request(\n+                    url=url,\n+                    method=method,\n+                    params=req.params,\n+                    auth=req.auth,\n+                    cookies=req.cookies,\n+                    allow_redirects=False,\n+                    prefetch=prefetch,\n+                    timeout=timeout,\n+                    verify=verify,\n+                    cert=cert\n+                )\n+\n+            yield resp\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+class Session(SessionMixin):\n     \"\"\"A Requests session.\"\"\"\n \n     __attrs__ = [\n@@ -166,7 +255,21 @@ class Session(object):\n \n         # TODO: prepare cookies.\n \n-        return self.send(prep)\n+        resp = self.send(prep)\n+\n+        if allow_redirects:\n+            gen = self.resolve_redirects(resp, req, prefetch, timeout, verify, cert)\n+\n+            history = [r for r in gen]\n+\n+            print history\n+\n+        return resp\n+\n+\n+\n+\n+\n \n \n     def get(self, url, **kwargs):\n@@ -177,7 +280,7 @@ class Session(object):\n         \"\"\"\n \n         kwargs.setdefault('allow_redirects', True)\n-        return self.request('get', url, **kwargs)\n+        return self.request('GET', url, **kwargs)\n \n     def options(self, url, **kwargs):\n         \"\"\"Sends a OPTIONS request. Returns :class:`Response` object.\n@@ -187,7 +290,7 @@ class Session(object):\n         \"\"\"\n \n         kwargs.setdefault('allow_redirects', True)\n-        return self.request('options', url, **kwargs)\n+        return self.request('OPTIONS', url, **kwargs)\n \n     def head(self, url, **kwargs):\n         \"\"\"Sends a HEAD request. Returns :class:`Response` object.\n@@ -197,7 +300,7 @@ class Session(object):\n         \"\"\"\n \n         kwargs.setdefault('allow_redirects', False)\n-        return self.request('head', url, **kwargs)\n+        return self.request('HEAD', url, **kwargs)\n \n     def post(self, url, data=None, **kwargs):\n         \"\"\"Sends a POST request. Returns :class:`Response` object.\n@@ -207,7 +310,7 @@ class Session(object):\n         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n         \"\"\"\n \n-        return self.request('post', url, data=data, **kwargs)\n+        return self.request('POST', url, data=data, **kwargs)\n \n     def put(self, url, data=None, **kwargs):\n         \"\"\"Sends a PUT request. Returns :class:`Response` object.\n@@ -217,7 +320,7 @@ class Session(object):\n         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n         \"\"\"\n \n-        return self.request('put', url, data=data, **kwargs)\n+        return self.request('PUT', url, data=data, **kwargs)\n \n     def patch(self, url, data=None, **kwargs):\n         \"\"\"Sends a PATCH request. Returns :class:`Response` object.\n@@ -227,7 +330,7 @@ class Session(object):\n         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n         \"\"\"\n \n-        return self.request('patch', url,  data=data, **kwargs)\n+        return self.request('PATCH', url,  data=data, **kwargs)\n \n     def delete(self, url, **kwargs):\n         \"\"\"Sends a DELETE request. Returns :class:`Response` object.\n@@ -236,12 +339,12 @@ class Session(object):\n         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n         \"\"\"\n \n-        return self.request('delete', url, **kwargs)\n+        return self.request('DELETE', url, **kwargs)\n \n-    def send(self, request):\n+    def send(self, request, prefetch=True, timeout=None, verify=True, cert=None):\n         \"\"\"Send a given PreparedRequest.\"\"\"\n         adapter = HTTPAdapter()\n-        r = adapter.send(request)\n+        r = adapter.send(request, prefetch, timeout, verify, cert)\n         return r\n \n     def __getstate__(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#0d183c41a9ea3afd22e789932d43c7c111eb8ef5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 13 | Churn Cumulative: 1435 | Contributors (this commit): 23 | Commits (past 90d): 11 | Contributors (cumulative): 23 | DMM Complexity: 1.0\n\nDIFF:\n@@ -68,10 +68,6 @@ class SessionMixin(object):\n     def resolve_redirects(self, resp, req, prefetch=True, timeout=None, verify=True, cert=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n-        print resp\n-        print req\n-        print resp.headers['location']\n-        print resp.status_code\n \n         # ((resp.status_code is codes.see_other))\n         while (('location' in resp.headers and resp.status_code in REDIRECT_STATI)):\n@@ -257,12 +253,15 @@ class Session(SessionMixin):\n \n         resp = self.send(prep)\n \n-        if allow_redirects:\n+        # Redirect generator.\n         gen = self.resolve_redirects(resp, req, prefetch, timeout, verify, cert)\n \n-            history = [r for r in gen]\n+        history = [r for r in gen] if allow_redirects else []\n \n-            print history\n+        if history:\n+            history.insert(0, resp)\n+            resp = history.pop()\n+            resp.history = history\n \n         return resp\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#d5572ac13f0508711bf6e1f67689941ffa8692c1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 5 | Files Changed: 1 | Hunks: 5 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 9 | Churn Cumulative: 1444 | Contributors (this commit): 23 | Commits (past 90d): 12 | Contributors (cumulative): 23 | DMM Complexity: None\n\nDIFF:\n@@ -253,24 +253,23 @@ class Session(SessionMixin):\n \n         resp = self.send(prep)\n \n-        # Redirect generator.\n+        # Redirect resolving generator.\n         gen = self.resolve_redirects(resp, req, prefetch, timeout, verify, cert)\n \n+        # Resolve redirects if allowed.\n         history = [r for r in gen] if allow_redirects else []\n \n+        # Shuffle things around if there's history.\n         if history:\n             history.insert(0, resp)\n             resp = history.pop()\n-            resp.history = history\n+            resp.history = tuple(history)\n \n         return resp\n \n \n \n \n-\n-\n-\n     def get(self, url, **kwargs):\n         \"\"\"Sends a GET request. Returns :class:`Response` object.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#7fc93788953d07bbd8aced1877acd156a8626acd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 5 | Churn Cumulative: 8164 | Contributors (this commit): 90 | Commits (past 90d): 43 | Contributors (cumulative): 90 | DMM Complexity: 1.0\n\nDIFF:\n@@ -542,6 +542,11 @@ class Response(object):\n         except ValueError:\n             return None\n \n+    def iter_json(self):\n+        for line in self.iter_lines():\n+            if line: # filter out keep-alive new lines\n+                yield json.loads(line)\n+\n     @property\n     def links(self):\n         \"\"\"Returns the parsed header links of the response, if any.\"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
