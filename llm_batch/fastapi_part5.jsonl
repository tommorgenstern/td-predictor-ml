{"custom_id": "fastapi#f539217b5bd2362f76071eab55a8c82b5d7cc2da", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 15 | Churn Cumulative: 15 | Contributors (this commit): 1 | Commits (past 90d): 1 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -0,0 +1,15 @@\n+#%%\n+from pathlib import Path\n+from string import digits\n+\n+\n+#%%\n+directory = Path(\"../docs/tutorial/src\")\n+output_directory = Path(\"../docs/tutorial/out\")\n+files = sorted([Path(f) for f in directory.iterdir()])\n+for i, f in enumerate(files):\n+    f: Path\n+    index = str(i + 1).zfill(2)\n+    new_name = output_directory / f\"tutorial{index}.py\"\n+    print(new_name)\n+    f.rename(new_name)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#d9fbead646896380039812a039e54d1eeddd600f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 17 | Files Changed: 5 | Hunks: 8 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 21 | Churn Cumulative: 1602 | Contributors (this commit): 2 | Commits (past 90d): 25 | Contributors (cumulative): 6 | DMM Complexity: None\n\nDIFF:\n@@ -1,13 +1,7 @@\n-from typing import Any, Callable, Dict, List, Sequence, Tuple\n+from typing import Callable, List, Sequence\n \n from fastapi.security.base import SecurityBase\n-from pydantic import BaseConfig, Schema\n-from pydantic.error_wrappers import ErrorWrapper\n-from pydantic.errors import MissingError\n-from pydantic.fields import Field, Required\n-from pydantic.schema import get_annotation_from_schema\n-from starlette.concurrency import run_in_threadpool\n-from starlette.requests import Request\n+from pydantic.fields import Field\n \n param_supported_types = (str, int, float, bool)\n \n\n@@ -6,7 +6,6 @@ from pydantic import BaseModel, Schema as PSchema\n from pydantic.types import UrlStr\n \n try:\n-    import email_validator\n     from pydantic.types import EmailStr  # type: ignore\n except ImportError:\n     logging.warning(\n\n@@ -11,8 +11,8 @@ from fastapi.utils import get_flat_models_from_routes, get_model_definitions\n from pydantic.fields import Field\n from pydantic.schema import Schema, field_schema, get_model_name_map\n from pydantic.utils import lenient_issubclass\n-from starlette.responses import HTMLResponse, JSONResponse\n-from starlette.routing import BaseRoute, Route\n+from starlette.responses import JSONResponse\n+from starlette.routing import BaseRoute\n from starlette.status import HTTP_422_UNPROCESSABLE_ENTITY\n \n validation_error_definition = {\n\n@@ -1,6 +1,3 @@\n-from typing import Optional\n-\n-import fastapi\n from fastapi import (\n     Body,\n     Cookie,\n@@ -20,10 +17,8 @@ from fastapi.security import (\n     OAuth2PasswordRequestForm,\n )\n from pydantic import BaseModel\n-from starlette.exceptions import HTTPException\n from starlette.responses import HTMLResponse, JSONResponse, PlainTextResponse\n from starlette.status import HTTP_202_ACCEPTED\n-from starlette.testclient import TestClient\n \n from .endpoints.a import router as router_a\n from .endpoints.b import router as router_b\n\n@@ -1,4 +1,3 @@\n-import pytest\n from starlette.testclient import TestClient\n \n from .main import app\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#b0d62b3410d6c6a52eb19167c864872e58bed912", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 163 | Lines Deleted: 231 | Files Changed: 60 | Hunks: 126 | Methods Changed: 27 | Complexity Δ (Sum/Max): 13/6 | Churn Δ: 394 | Churn Cumulative: 2542 | Contributors (this commit): 1 | Commits (past 90d): 165 | Contributors (cumulative): 60 | DMM Complexity: 0.0\n\nDIFF:\n@@ -2,6 +2,7 @@ from fastapi import FastAPI\n \n app = FastAPI()\n \n+\n @app.get(\"/\")\n async def root():\n     return {\"message\": \"Hello World\"}\n\n@@ -2,6 +2,7 @@ from fastapi import FastAPI\n \n app = FastAPI()\n \n+\n @app.get(\"/items/{item_id}\")\n async def read_item(item_id):\n     return {\"item_id\": item_id}\n\n@@ -2,6 +2,7 @@ from fastapi import FastAPI\n \n app = FastAPI()\n \n+\n @app.get(\"/items/{item_id}\")\n async def read_item(item_id: int):\n     return {\"item_id\": item_id}\n\n@@ -1,8 +1,10 @@\n-from fastapi import FastAPI\n from uuid import UUID\n \n+from fastapi import FastAPI\n+\n app = FastAPI()\n \n+\n @app.get(\"/items/{item_id}\")\n async def read_item(item_id: UUID):\n     return {\"item_id\": item_id}\n\n@@ -2,11 +2,8 @@ from fastapi import FastAPI\n \n app = FastAPI()\n \n-fake_items_db = [\n-    {\"item_name\": \"Foo\"},\n-    {\"item_name\": \"Bar\"},\n-    {\"item_name\": \"Baz\"},\n-]\n+fake_items_db = [{\"item_name\": \"Foo\"}, {\"item_name\": \"Bar\"}, {\"item_name\": \"Baz\"}]\n+\n \n @app.get(\"/items/\")\n async def read_item(skip: int = 0, limit: int = 100):\n\n@@ -1,8 +1,8 @@\n from fastapi import FastAPI\n-from fastapi import FastAPI\n \n app = FastAPI()\n \n+\n @app.get(\"/items/{item_id}\")\n async def read_item(item_id: str, q: str = None):\n     if q:\n\n@@ -2,11 +2,14 @@ from fastapi import FastAPI\n \n app = FastAPI()\n \n+\n @app.get(\"/items/{item_id}\")\n async def read_item(item_id: str, q: str = None, short: bool = False):\n     item = {\"item_id\": item_id}\n     if q:\n         item.update({\"q\": q})\n     if not short:\n-        item.update({\"description\": \"This is an amazing item that has a long description\"})\n+        item.update(\n+            {\"description\": \"This is an amazing item that has a long description\"}\n+        )\n     return item\n\n@@ -2,11 +2,16 @@ from fastapi import FastAPI\n \n app = FastAPI()\n \n+\n @app.get(\"/users/{user_id}/items/{item_id}\")\n-async def read_user_item(user_id: int, item_id: str, q: str = None, short: bool = False):\n+async def read_user_item(\n+    user_id: int, item_id: str, q: str = None, short: bool = False\n+):\n     item = {\"item_id\": item_id, \"owner_id\": user_id}\n     if q:\n         item.update({\"q\": q})\n     if not short:\n-        item.update({\"description\": \"This is an amazing item that has a long description\"})\n+        item.update(\n+            {\"description\": \"This is an amazing item that has a long description\"}\n+        )\n     return item\n\n@@ -2,11 +2,16 @@ from fastapi import FastAPI\n \n app = FastAPI()\n \n+\n @app.get(\"/users/{user_id}/items/{item_id}\")\n-async def read_user_item(user_id: int, item_id: str, needy: str, q: str = None, short: bool = False):\n+async def read_user_item(\n+    user_id: int, item_id: str, needy: str, q: str = None, short: bool = False\n+):\n     item = {\"item_id\": item_id, \"owner_id\": user_id, \"needy\": needy}\n     if q:\n         item.update({\"q\": q})\n     if not short:\n-        item.update({\"description\": \"This is an amazing item that has a long description\"})\n+        item.update(\n+            {\"description\": \"This is an amazing item that has a long description\"}\n+        )\n     return item\n\n@@ -1,6 +1,7 @@\n from fastapi import FastAPI\n from pydantic import BaseModel\n \n+\n class Item(BaseModel):\n     name: str\n     description: str = None\n@@ -10,6 +11,7 @@ class Item(BaseModel):\n \n app = FastAPI()\n \n+\n @app.post(\"/items/\")\n async def create_item(item: Item):\n     return item\n\n@@ -1,6 +1,7 @@\n from fastapi import FastAPI\n from pydantic import BaseModel\n \n+\n class Item(BaseModel):\n     name: str\n     description: str = None\n@@ -10,6 +11,7 @@ class Item(BaseModel):\n \n app = FastAPI()\n \n+\n @app.post(\"/items/\")\n async def create_item(item: Item):\n     item_dict = item.dict()\n\n@@ -1,6 +1,7 @@\n from fastapi import FastAPI\n from pydantic import BaseModel\n \n+\n class Item(BaseModel):\n     name: str\n     description: str = None\n@@ -10,6 +11,7 @@ class Item(BaseModel):\n \n app = FastAPI()\n \n+\n @app.put(\"/items/{item_id}\")\n async def create_item(item_id: int, item: Item):\n     return {\"item_id\": item_id, **item.dict()}\n\n@@ -1,6 +1,7 @@\n from fastapi import FastAPI\n from pydantic import BaseModel\n \n+\n class Item(BaseModel):\n     name: str\n     description: str = None\n@@ -10,6 +11,7 @@ class Item(BaseModel):\n \n app = FastAPI()\n \n+\n @app.put(\"/items/{item_id}\")\n async def create_item(item_id: int, item: Item, q: str = None):\n     result = {\"item_id\": item_id, **item.dict()}\n\n@@ -4,7 +4,9 @@ app = FastAPI()\n \n \n @app.get(\"/items/\")\n-async def read_items(q: str = Query(None, min_length=3, max_length=50, regex=\"^fixedquery$\")):\n+async def read_items(\n+    q: str = Query(None, min_length=3, max_length=50, regex=\"^fixedquery$\")\n+):\n     results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]}\n     if q:\n         results.update({\"q\": q})\n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Query, Path\n+from fastapi import FastAPI, Path, Query\n \n app = FastAPI()\n \n\n@@ -1,12 +1,11 @@\n-from fastapi import FastAPI, Query, Path\n+from fastapi import FastAPI, Path\n \n app = FastAPI()\n \n \n @app.get(\"/items/{item_id}\")\n async def read_items(\n-    q: str,\n-    item_id: int = Path(..., title=\"The ID of the item to get\"),\n+    q: str, item_id: int = Path(..., title=\"The ID of the item to get\")\n ):\n     results = {\"item_id\": item_id}\n     if q:\n\n@@ -1,13 +1,11 @@\n-from fastapi import FastAPI, Query, Path\n+from fastapi import FastAPI, Path\n \n app = FastAPI()\n \n \n @app.get(\"/items/{item_id}\")\n async def read_items(\n-    *,\n-    item_id: int = Path(..., title=\"The ID of the item to get\"),\n-    q: str,\n+    *, item_id: int = Path(..., title=\"The ID of the item to get\"), q: str\n ):\n     results = {\"item_id\": item_id}\n     if q:\n\n@@ -1,13 +1,11 @@\n-from fastapi import FastAPI, Query, Path\n+from fastapi import FastAPI, Path\n \n app = FastAPI()\n \n \n @app.get(\"/items/{item_id}\")\n async def read_items(\n-    *,\n-    item_id: int = Path(..., title=\"The ID of the item to get\", ge=1),\n-    q: str,\n+    *, item_id: int = Path(..., title=\"The ID of the item to get\", ge=1), q: str\n ):\n     results = {\"item_id\": item_id}\n     if q:\n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Query, Path\n+from fastapi import FastAPI, Path\n \n app = FastAPI()\n \n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Query, Path\n+from fastapi import FastAPI, Path, Query\n \n app = FastAPI()\n \n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Query, Path\n+from fastapi import FastAPI, Path\n from pydantic import BaseModel\n \n app = FastAPI()\n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Query, Path\n+from fastapi import FastAPI\n from pydantic import BaseModel\n \n app = FastAPI()\n@@ -17,11 +17,6 @@ class User(BaseModel):\n \n \n @app.put(\"/items/{item_id}\")\n-async def update_item(\n-    *,\n-    item_id: int,\n-    item: Item,\n-    user: User,\n-):\n+async def update_item(*, item_id: int, item: Item, user: User):\n     results = {\"item_id\": item_id, \"item\": item, \"user\": user}\n     return results\n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Query, Path, Body\n+from fastapi import Body, FastAPI\n from pydantic import BaseModel\n \n app = FastAPI()\n@@ -18,11 +18,12 @@ class User(BaseModel):\n \n @app.put(\"/items/{item_id}\")\n async def update_item(\n-    *,\n-    item_id: int,\n-    item: Item,\n-    user: User,\n-    access_token: str = Body(...),\n+    *, item_id: int, item: Item, user: User, access_token: str = Body(...)\n ):\n-    results = {\"item_id\": item_id, \"item\": item, \"user\": user, \"access_token\": access_token}\n+    results = {\n+        \"item_id\": item_id,\n+        \"item\": item,\n+        \"user\": user,\n+        \"access_token\": access_token,\n+    }\n     return results\n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Query, Path, Body\n+from fastapi import Body, FastAPI\n from pydantic import BaseModel\n \n app = FastAPI()\n@@ -25,7 +25,12 @@ async def update_item(\n     access_token: str = Body(...),\n     q: str = None,\n ):\n-    results = {\"item_id\": item_id, \"item\": item, \"user\": user, \"access_token\": access_token}\n+    results = {\n+        \"item_id\": item_id,\n+        \"item\": item,\n+        \"user\": user,\n+        \"access_token\": access_token,\n+    }\n     if q:\n         results.update({\"q\": q})\n     return results\n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Query, Path, Body\n+from fastapi import Body, FastAPI\n from pydantic import BaseModel\n \n app = FastAPI()\n@@ -12,10 +12,6 @@ class Item(BaseModel):\n \n \n @app.put(\"/items/{item_id}\")\n-async def update_item(\n-    *,\n-    item_id: int,\n-    item: Item = Body(..., embed=True),\n-):\n+async def update_item(*, item_id: int, item: Item = Body(..., embed=True)):\n     results = {\"item_id\": item_id, \"item\": item}\n     return results\n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Query, Path, Body\n+from fastapi import Body, FastAPI\n from pydantic import BaseModel, Schema\n \n app = FastAPI()\n@@ -12,10 +12,6 @@ class Item(BaseModel):\n \n \n @app.put(\"/items/{item_id}\")\n-async def update_item(\n-    *,\n-    item_id: int,\n-    item: Item = Body(..., embed=True),\n-):\n+async def update_item(*, item_id: int, item: Item = Body(..., embed=True)):\n     results = {\"item_id\": item_id, \"item\": item}\n     return results\n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Query, Path, Body\n+from fastapi import FastAPI\n from pydantic import BaseModel\n \n app = FastAPI()\n@@ -13,10 +13,6 @@ class Item(BaseModel):\n \n \n @app.put(\"/items/{item_id}\")\n-async def update_item(\n-    *,\n-    item_id: int,\n-    item: Item,\n-):\n+async def update_item(*, item_id: int, item: Item):\n     results = {\"item_id\": item_id, \"item\": item}\n     return results\n\n@@ -1,7 +1,8 @@\n-from fastapi import Body, FastAPI, Path, Query\n-from pydantic import BaseModel\n from typing import List\n \n+from fastapi import FastAPI\n+from pydantic import BaseModel\n+\n app = FastAPI()\n \n \n@@ -14,10 +15,6 @@ class Item(BaseModel):\n \n \n @app.put(\"/items/{item_id}\")\n-async def update_item(\n-    *,\n-    item_id: int,\n-    item: Item,\n-):\n+async def update_item(*, item_id: int, item: Item):\n     results = {\"item_id\": item_id, \"item\": item}\n     return results\n\n@@ -1,7 +1,8 @@\n-from fastapi import Body, FastAPI, Path, Query\n-from pydantic import BaseModel\n from typing import Set\n \n+from fastapi import FastAPI\n+from pydantic import BaseModel\n+\n app = FastAPI()\n \n \n@@ -14,10 +15,6 @@ class Item(BaseModel):\n \n \n @app.put(\"/items/{item_id}\")\n-async def update_item(\n-    *,\n-    item_id: int,\n-    item: Item,\n-):\n+async def update_item(*, item_id: int, item: Item):\n     results = {\"item_id\": item_id, \"item\": item}\n     return results\n\n@@ -1,7 +1,8 @@\n-from fastapi import Body, FastAPI, Path, Query\n-from pydantic import BaseModel\n from typing import Set\n \n+from fastapi import FastAPI\n+from pydantic import BaseModel\n+\n app = FastAPI()\n \n \n@@ -20,10 +21,6 @@ class Item(BaseModel):\n \n \n @app.put(\"/items/{item_id}\")\n-async def update_item(\n-    *,\n-    item_id: int,\n-    item: Item,\n-):\n+async def update_item(*, item_id: int, item: Item):\n     results = {\"item_id\": item_id, \"item\": item}\n     return results\n\n@@ -1,7 +1,8 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from typing import Set\n+\n+from fastapi import FastAPI\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n-from typing import Set\n \n app = FastAPI()\n \n@@ -21,10 +22,6 @@ class Item(BaseModel):\n \n \n @app.put(\"/items/{item_id}\")\n-async def update_item(\n-    *,\n-    item_id: int,\n-    item: Item,\n-):\n+async def update_item(*, item_id: int, item: Item):\n     results = {\"item_id\": item_id, \"item\": item}\n     return results\n\n@@ -1,7 +1,8 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from typing import List, Set\n+\n+from fastapi import FastAPI\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n-from typing import Set, List\n \n app = FastAPI()\n \n@@ -21,10 +22,6 @@ class Item(BaseModel):\n \n \n @app.put(\"/items/{item_id}\")\n-async def update_item(\n-    *,\n-    item_id: int,\n-    item: Item,\n-):\n+async def update_item(*, item_id: int, item: Item):\n     results = {\"item_id\": item_id, \"item\": item}\n     return results\n\n@@ -1,7 +1,8 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from typing import List, Set\n+\n+from fastapi import FastAPI\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n-from typing import Set, List\n \n app = FastAPI()\n \n\n@@ -1,7 +1,8 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from typing import List\n+\n+from fastapi import FastAPI\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n-from typing import Set, List\n \n app = FastAPI()\n \n\n@@ -1,7 +1,4 @@\n-from fastapi import FastAPI, Cookie\n-from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from typing import Set, List\n+from fastapi import Cookie, FastAPI\n \n app = FastAPI()\n \n\n@@ -1,7 +1,4 @@\n from fastapi import FastAPI, Header\n-from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from typing import Set, List\n \n app = FastAPI()\n \n\n@@ -1,7 +1,4 @@\n from fastapi import FastAPI, Header\n-from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from typing import Set, List\n \n app = FastAPI()\n \n\n@@ -1,7 +1,7 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from typing import Set\n+\n+from fastapi import FastAPI\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from typing import Set, List\n \n app = FastAPI()\n \n\n@@ -1,7 +1,6 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from fastapi import FastAPI\n from pydantic import BaseModel\n from pydantic.types import EmailStr\n-from typing import Set, List\n \n app = FastAPI()\n \n@@ -13,7 +12,6 @@ class UserIn(BaseModel):\n     full_name: str = None\n \n \n-\n # Don't do this in production!\n @app.post(\"/user/\", response_model=UserIn)\n async def create_user(*, user: UserIn):\n\n@@ -1,7 +1,6 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from fastapi import FastAPI\n from pydantic import BaseModel\n from pydantic.types import EmailStr\n-from typing import Set, List\n \n app = FastAPI()\n \n\n@@ -1,8 +1,6 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from fastapi import FastAPI\n from pydantic import BaseModel\n from pydantic.types import EmailStr\n-from typing import Set, List\n-from uuid import UUID, uuid4\n \n app = FastAPI()\n \n@@ -37,6 +35,7 @@ def fake_save_user(user_in: UserIn):\n     print(\"User saved! ..not really\")\n     return user_in_db\n \n+\n @app.post(\"/user/\", response_model=UserOut)\n async def create_user(*, user_in: UserIn):\n     user_saved = fake_save_user(user_in)\n\n@@ -1,15 +1,16 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from fastapi import FastAPI\n from pydantic import BaseModel\n from pydantic.types import EmailStr\n-from typing import Set, List\n \n app = FastAPI()\n \n+\n class UserBase(BaseModel):\n     username: str\n     email: EmailStr\n     full_name: str = None\n \n+\n class UserIn(UserBase):\n     password: str\n \n@@ -17,6 +18,7 @@ class UserIn(UserBase):\n class UserOut(UserBase):\n     pass\n \n+\n class UserInDB(UserBase):\n     hashed_password: str\n \n@@ -31,6 +33,7 @@ def fake_save_user(user_in: UserIn):\n     print(\"User saved! ..not really\")\n     return user_in_db\n \n+\n @app.post(\"/user/\", response_model=UserOut)\n async def create_user(*, user_in: UserIn):\n     user_saved = fake_save_user(user_in)\n\n@@ -1,7 +1,4 @@\n-from fastapi import Body, FastAPI, Path, Query, Form\n-from pydantic import BaseModel\n-from pydantic.types import EmailStr\n-from typing import Set, List\n+from fastapi import FastAPI, Form\n \n app = FastAPI()\n \n\n@@ -1,7 +1,4 @@\n-from fastapi import Body, FastAPI, Path, Query, File\n-from pydantic import BaseModel\n-from pydantic.types import EmailStr\n-from typing import Set, List\n+from fastapi import FastAPI, File\n \n app = FastAPI()\n \n\n@@ -1,7 +1,4 @@\n-from fastapi import Body, FastAPI, Path, Query, File, Form\n-from pydantic import BaseModel\n-from pydantic.types import EmailStr\n-from typing import Set, List\n+from fastapi import FastAPI, File, Form\n \n app = FastAPI()\n \n\n@@ -1,8 +1,8 @@\n-from fastapi import Body, FastAPI, Path, Query\n-from starlette.status import HTTP_201_CREATED\n+from typing import Set\n+\n+from fastapi import FastAPI\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from typing import Set, List\n+from starlette.status import HTTP_201_CREATED\n \n app = FastAPI()\n \n\n@@ -1,8 +1,7 @@\n-from fastapi import Body, FastAPI, Path, Query\n-from starlette.status import HTTP_201_CREATED\n+from typing import Set\n+\n+from fastapi import FastAPI\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from typing import Set, List\n \n app = FastAPI()\n \n\n@@ -1,8 +1,7 @@\n-from fastapi import Body, FastAPI, Path, Query\n-from starlette.status import HTTP_201_CREATED\n+from typing import Set\n+\n+from fastapi import FastAPI\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from typing import Set, List\n \n app = FastAPI()\n \n\n@@ -1,8 +1,7 @@\n-from fastapi import Body, FastAPI, Path, Query\n-from starlette.status import HTTP_201_CREATED\n+from typing import Set\n+\n+from fastapi import FastAPI\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from typing import Set, List\n \n app = FastAPI()\n \n\n@@ -1,8 +1,7 @@\n-from fastapi import Body, FastAPI, Path, Query\n-from starlette.status import HTTP_201_CREATED\n+from typing import Set\n+\n+from fastapi import FastAPI\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from typing import Set, List\n \n app = FastAPI()\n \n@@ -15,7 +14,12 @@ class Item(BaseModel):\n     tags: Set[str] = []\n \n \n-@app.post(\"/items/\", response_model=Item, summary=\"Create an item\", response_description=\"The created item\")\n+@app.post(\n+    \"/items/\",\n+    response_model=Item,\n+    summary=\"Create an item\",\n+    response_description=\"The created item\",\n+)\n async def create_item(*, item: Item):\n     \"\"\"\n     Create an item with all the information:\n\n@@ -1,9 +1,4 @@\n-from typing import List, Set\n-\n-from fastapi import Body, FastAPI, Path, Query\n-from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n+from fastapi import FastAPI\n \n app = FastAPI()\n \n\n@@ -1,9 +1,4 @@\n-from typing import List, Set\n-\n-from fastapi import Body, FastAPI, Path, Query\n-from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n+from fastapi import FastAPI\n \n app = FastAPI()\n \n\n@@ -1,9 +1,4 @@\n-from typing import List, Set\n-\n-from fastapi import Body, FastAPI, Path, Query\n-from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n+from fastapi import FastAPI\n \n app = FastAPI()\n \n\n@@ -1,9 +1,4 @@\n-from typing import List, Set\n-\n-from fastapi import Body, FastAPI, Path, Query\n-from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n+from fastapi import FastAPI\n from starlette.responses import UJSONResponse\n \n app = FastAPI()\n\n@@ -1,9 +1,4 @@\n-from typing import List, Set\n-\n-from fastapi import Body, FastAPI, Path, Query\n-from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n+from fastapi import FastAPI\n from starlette.responses import HTMLResponse\n \n app = FastAPI()\n\n@@ -1,10 +1,5 @@\n-from typing import List, Set\n-\n-from fastapi import Body, FastAPI, Path, Query, Depends\n+from fastapi import Depends, FastAPI\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n-from starlette.responses import HTMLResponse\n \n app = FastAPI()\n \n\n@@ -1,10 +1,7 @@\n-from typing import List, Set\n+from typing import List\n \n-from fastapi import Body, FastAPI, Path, Query, Depends, Cookie\n+from fastapi import Cookie, Depends, FastAPI\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n-from starlette.responses import HTMLResponse\n \n app = FastAPI()\n \n@@ -30,6 +27,8 @@ async def get_tracked_interests(track_code: str = Cookie(None)):\n \n \n @app.get(\"/interests/\")\n-async def read_interests(tracked_interests: InterestsTracker = Depends(get_tracked_interests)):\n+async def read_interests(\n+    tracked_interests: InterestsTracker = Depends(get_tracked_interests)\n+):\n     response = {\"interests\": tracked_interests.interests}\n     return response\n\n@@ -1,11 +1,8 @@\n-from typing import List, Set\n-\n-from fastapi import Body, FastAPI, Path, Query, Depends, Cookie\n-from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n-from starlette.responses import HTMLResponse\n from random import choice\n+from typing import List\n+\n+from fastapi import Cookie, Depends, FastAPI\n+from pydantic import BaseModel\n \n app = FastAPI()\n \n@@ -21,6 +18,7 @@ fake_tracked_users_db = {\n     \"Baz\": {\"track_code\": \"Baz\", \"interests\": [\"gaming\", \"virtual reality\"]},\n }\n \n+\n async def get_tracked_interests(track_code: str = Cookie(None)):\n     if track_code in fake_tracked_users_db:\n         track_dict = fake_tracked_users_db[track_code]\n@@ -28,6 +26,7 @@ async def get_tracked_interests(track_code: str = Cookie(None)):\n         return track\n     return None\n \n+\n class ComplexTracker:\n     def __init__(self, tracker: InterestsTracker = Depends(get_tracked_interests)):\n         self.tracker = tracker\n@@ -39,7 +38,9 @@ class ComplexTracker:\n         \"\"\"\n         if self.tracker.interests:\n             return choice(self.tracker.interests)\n-        return choice([\"sports\", \"movies\", \"food\", \"shows\", \"gaming\", \"virtual reality\"])\n+        return choice(\n+            [\"sports\", \"movies\", \"food\", \"shows\", \"gaming\", \"virtual reality\"]\n+        )\n \n \n @app.get(\"/suggested-category\")\n\n@@ -1,17 +1,8 @@\n-from typing import List, Set\n+from fastapi import FastAPI\n \n-from fastapi import Body, FastAPI, Path, Query, Depends, Cookie\n-from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n-from starlette.responses import HTMLResponse\n-from random import choice\n-\n-from sqlalchemy import create_engine\n-from sqlalchemy.orm import scoped_session, sessionmaker\n-from sqlalchemy import Column, Integer, DateTime, String, Boolean, ForeignKey\n+from sqlalchemy import Boolean, Column, Integer, String, create_engine\n from sqlalchemy.ext.declarative import declarative_base, declared_attr\n-\n+from sqlalchemy.orm import scoped_session, sessionmaker\n \n # SQLAlchemy specific code, as with any other app\n \n@@ -22,6 +13,7 @@ SQLALCHEMY_DATABASE_URI = \"postgresql://user:password@postgresserver/db\"\n # automatic __tablename__ attributes. So you don't have to declare them.\n # So, your models will behave very similarly to, for example, Flask-SQLAlchemy\n \n+\n class CustomBase:\n     # Generate __tablename__ automatically\n     @declared_attr\n@@ -49,6 +41,7 @@ db_session = scoped_session(\n def get_user(username, db_session):\n     return db_session.query(User).filter(User.id == username).first()\n \n+\n # FastAPI specific code\n app = FastAPI()\n \n\n@@ -1,21 +1,12 @@\n-from typing import List, Set\n-\n-from fastapi import Body, FastAPI, Path, Query, Depends, Cookie\n-from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n-from starlette.responses import HTMLResponse\n-from random import choice\n-\n-from typing import List, Optional, Union\n+from typing import Optional\n \n+from fastapi import FastAPI\n from pydantic import BaseModel\n \n from app.models.config import USERPROFILE_DOC_TYPE\n-from app.models.role import RoleEnum\n+from couchbase import LOCKMODE_WAIT\n from couchbase.bucket import Bucket\n from couchbase.cluster import Cluster, PasswordAuthenticator\n-from couchbase import LOCKMODE_WAIT\n \n \n def get_bucket():\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#f9c876802f17f8d7f04444fe1477bf42a04dcdaf", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 5 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 14 | Churn Cumulative: 1359 | Contributors (this commit): 1 | Commits (past 90d): 7 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -24,9 +24,9 @@ class FastAPI(Starlette):\n         title: str = \"Fast API\",\n         description: str = \"\",\n         version: str = \"0.1.0\",\n-        openapi_url: str = \"/openapi.json\",\n-        swagger_ui_url: str = \"/docs\",\n-        redoc_url: str = \"/redoc\",\n+        openapi_url: Optional[str] = \"/openapi.json\",\n+        docs_url: Optional[str] = \"/docs\",\n+        redoc_url: Optional[str] = \"/redoc\",\n         **extra: Dict[str, Any],\n     ) -> None:\n         self._debug = debug\n@@ -43,7 +43,7 @@ class FastAPI(Starlette):\n         self.description = description\n         self.version = version\n         self.openapi_url = openapi_url\n-        self.swagger_ui_url = swagger_ui_url\n+        self.docs_url = docs_url\n         self.redoc_url = redoc_url\n         self.extra = extra\n \n@@ -53,7 +53,7 @@ class FastAPI(Starlette):\n             assert self.title, \"A title must be provided for OpenAPI, e.g.: 'My API'\"\n             assert self.version, \"A version must be provided for OpenAPI, e.g.: '2.1.0'\"\n \n-        if self.swagger_ui_url or self.redoc_url:\n+        if self.docs_url or self.redoc_url:\n             assert self.openapi_url, \"The openapi_url is required for the docs\"\n         self.openapi_schema: Optional[Dict[str, Any]] = None\n         self.setup()\n@@ -76,9 +76,9 @@ class FastAPI(Starlette):\n                 lambda req: JSONResponse(self.openapi()),\n                 include_in_schema=False,\n             )\n-        if self.swagger_ui_url:\n+        if self.docs_url:\n             self.add_route(\n-                self.swagger_ui_url,\n+                self.docs_url,\n                 lambda r: get_swagger_ui_html(\n                     openapi_url=self.openapi_url, title=self.title + \" - Swagger UI\"\n                 ),\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#9febe9af2a4ff28988cb686a40120d277c6ed3fb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 41 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 42 | Churn Cumulative: 192 | Contributors (this commit): 1 | Commits (past 90d): 7 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -19,7 +19,42 @@ class OAuth2PasswordRequestData(BaseModel):\n \n \n class OAuth2PasswordRequestForm(BaseModel):\n-    grant_type: str = Schema(..., regex=\"password\")  # it must have the value \"password\"\n+    \"\"\"\n+    This is not a \"Security\" model. Use it as request Body. As in:\n+\n+        @app.post(\"/login\")\n+        def login(form_data: Oauth2PasswordRequestForm):\n+            data = form_data.parse()\n+            print(data.username)\n+            print(data.password)\n+            for scope in data.scope:\n+                print(scope)\n+            if data.client_id:\n+                print(data.client_id)\n+            if data.client_secret:\n+                print(data.client_secret)\n+            return data\n+\n+    \n+    It creates the following Form request parameters in your endpoint:\n+\n+    grant_type: the OAuth2 spec says it is required and MUST be the fixed string \"password\".\n+        Nevertheless, this model is permissive and allows not passing it. If you want to enforce it,\n+        use instead the OAuth2PasswordRequestFormStrict model.\n+    username: username string. The OAuth2 spec requires the exact field name \"username\".\n+    password: password string. The OAuth2 spec requires the exact field name \"password\".\n+    scope: Optional string. Several scopes (each one a string) separated by spaces. E.g.\n+        \"items:read items:write users:read profile openid\"\n+    client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n+        using HTTP Basic auth, as: client_id:client_secret\n+    client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n+        using HTTP Basic auth, as: client_id:client_secret\n+    \n+\n+    It has the method parse() that returns a model with all the same data and the scopes extracted as a list of strings.\n+    \"\"\"\n+\n+    grant_type: str = Schema(None, regex=\"password\")\n     username: str\n     password: str\n     scope: str = \"\"\n@@ -38,6 +73,11 @@ class OAuth2PasswordRequestForm(BaseModel):\n         )\n \n \n+class OAuth2PasswordRequestFormStrict(OAuth2PasswordRequestForm):\n+    # The OAuth2 spec says it MUST have the value \"password\"\n+    grant_type: str = Schema(..., regex=\"password\")\n+\n+\n class OAuth2(SecurityBase):\n     def __init__(\n         self, *, flows: OAuthFlowsModel = OAuthFlowsModel(), scheme_name: str = None\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#abe695ba9ac8f02cda7481cb601ee1ea20a9e5d8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 417 | Lines Deleted: 0 | Files Changed: 13 | Hunks: 12 | Methods Changed: 34 | Complexity Δ (Sum/Max): 47/17 | Churn Δ: 417 | Churn Cumulative: 417 | Contributors (this commit): 1 | Commits (past 90d): 13 | Contributors (cumulative): 13 | DMM Complexity: 1.0\n\nDIFF:\n\n@@ -0,0 +1,29 @@\n+from fastapi import Body, FastAPI\n+from pydantic import BaseModel, Schema\n+\n+app = FastAPI()\n+\n+\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+\n+\n+@app.put(\"/items/{item_id}\")\n+async def update_item(\n+    *,\n+    item_id: int,\n+    item: Item = Body(\n+        ...,\n+        example={\n+            \"name\": \"Foo\",\n+            \"description\": \"A very nice Item\",\n+            \"price\": 35.4,\n+            \"tax\": 3.2,\n+        },\n+    )\n+):\n+    results = {\"item_id\": item_id, \"item\": item}\n+    return results\n\n@@ -0,0 +1,57 @@\n+from typing import Optional\n+\n+from fastapi import FastAPI\n+from pydantic import BaseModel\n+\n+from app.models.config import USERPROFILE_DOC_TYPE\n+from couchbase import LOCKMODE_WAIT\n+from couchbase.bucket import Bucket\n+from couchbase.cluster import Cluster, PasswordAuthenticator\n+\n+\n+def get_bucket():\n+    cluster = Cluster(\"couchbase://couchbasehost:8091\")\n+    authenticator = PasswordAuthenticator(\"username\", \"password\")\n+    cluster.authenticate(authenticator)\n+    bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT)\n+    return bucket\n+\n+\n+class User(BaseModel):\n+    username: str\n+    email: Optional[str] = None\n+    full_name: Optional[str] = None\n+    disabled: Optional[bool] = None\n+\n+\n+class UserInDB(User):\n+    type: str = USERPROFILE_DOC_TYPE\n+    hashed_password: str\n+\n+    class Meta:\n+        key: Optional[str] = None\n+\n+\n+def get_user_doc_id(username):\n+    return f\"userprofile::{username}\"\n+\n+\n+def get_user(bucket: Bucket, username: str):\n+    doc_id = get_user_doc_id(username)\n+    result = bucket.get(doc_id, quiet=True)\n+    if not result.value:\n+        return None\n+    user = UserInDB(**result.value)\n+    user.Meta.key = result.key\n+    return user\n+\n+\n+# FastAPI specific code\n+app = FastAPI()\n+\n+\n+@app.get(\"/users/{username}\")\n+def read_user(username: str):\n+    bucket = get_bucket()\n+    user = get_user(bucket=bucket, username=username)\n+    return user\n\n@@ -0,0 +1,11 @@\n+from fastapi import FastAPI, Security\n+from fastapi.security import OAuth2PasswordBearer\n+\n+app = FastAPI()\n+\n+oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/token\")\n+\n+\n+@app.get(\"/items/\")\n+async def read_items(token: str = Security(oauth2_scheme)):\n+    return {\"token\": token}\n\n@@ -0,0 +1,32 @@\n+from typing import Optional\n+\n+from fastapi import Depends, FastAPI, Security\n+from fastapi.security import OAuth2PasswordBearer\n+from pydantic import BaseModel\n+\n+app = FastAPI()\n+\n+oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/token\")\n+\n+\n+class User(BaseModel):\n+    username: str\n+    email: Optional[str] = None\n+    full_name: Optional[str] = None\n+    disabled: Optional[bool] = None\n+\n+\n+def fake_decode_token(token):\n+    return User(\n+        username=token + \"fakedecoded\", email=\"john@example.com\", full_name=\"John Doe\"\n+    )\n+\n+\n+async def get_current_user(token: str = Security(oauth2_scheme)):\n+    user = fake_decode_token(token)\n+    return user\n+\n+\n+@app.get(\"/users/me\")\n+async def read_users_me(current_user: User = Depends(get_current_user)):\n+    return current_user\n\n@@ -0,0 +1,80 @@\n+from typing import Optional\n+\n+from fastapi import Depends, FastAPI, Security\n+from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\n+from pydantic import BaseModel\n+from starlette.exceptions import HTTPException\n+\n+fake_users_db = {\n+    \"johndoe\": {\n+        \"username\": \"johndoe\",\n+        \"full_name\": \"John Doe\",\n+        \"email\": \"johndoe@example.com\",\n+        \"password_hash\": \"fakehashedsecret\",\n+    }\n+}\n+\n+app = FastAPI()\n+\n+\n+def fake_hash_password(password: str):\n+    return \"fakehashed\" + password\n+\n+\n+oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/token\")\n+\n+\n+class User(BaseModel):\n+    username: str\n+    email: Optional[str] = None\n+    full_name: Optional[str] = None\n+    disabled: Optional[bool] = None\n+\n+\n+class UserInDB(User):\n+    hashed_password: str\n+\n+\n+def get_user(db, username: str):\n+    if username in db:\n+        user_dict = db[username]\n+        return UserInDB(**user_dict)\n+\n+\n+def fake_decode_token(token):\n+    # This doesn't provide any security at all\n+    # Check the next version\n+    user = get_user(fake_users_db, token)\n+    return user\n+\n+\n+async def get_current_user(token: str = Security(oauth2_scheme)):\n+    user = fake_decode_token(token)\n+    if not user:\n+        raise HTTPException(status_code=400, detail=\"Inactive user\")\n+    return user\n+\n+\n+async def get_current_active_user(current_user: User = Depends(get_current_user)):\n+    if not current_user.disabled:\n+        raise HTTPException(status_code=400, detail=\"Inactive user\")\n+    return current_user\n+\n+\n+@app.post(\"/token\")\n+async def login(form_data: OAuth2PasswordRequestForm):\n+    data = form_data.parse()\n+    user_dict = fake_users_db[data.username]\n+    user = UserInDB(**user_dict)\n+    if not user:\n+        raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n+    hashed_password = fake_hash_password(data.password)\n+    if not hashed_password == user.hashed_password:\n+        raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n+\n+    return {\"access_token\": user.username, \"token_type\": \"bearer\"}\n+\n+\n+@app.get(\"/users/me\")\n+async def read_users_me(current_user: User = Depends(get_current_active_user)):\n+    return current_user\n\n@@ -0,0 +1,132 @@\n+from datetime import datetime, timedelta\n+from typing import Optional\n+\n+import jwt\n+from fastapi import Depends, FastAPI, Security\n+from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\n+from jwt import PyJWTError\n+from passlib.context import CryptContext\n+from pydantic import BaseModel\n+from starlette.exceptions import HTTPException\n+from starlette.status import HTTP_403_FORBIDDEN\n+\n+# to get a string like this run:\n+# openssl rand -hex 32\n+SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\"\n+ALGORITHM = \"HS256\"\n+TOKEN_SUBJECT = \"access\"\n+ACCESS_TOKEN_EXPIRE_MINUTES = 30\n+\n+\n+fake_users_db = {\n+    \"johndoe\": {\n+        \"username\": \"johndoe\",\n+        \"full_name\": \"John Doe\",\n+        \"email\": \"johndoe@example.com\",\n+        \"password_hash\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\",\n+    }\n+}\n+\n+\n+class Token(BaseModel):\n+    access_token: str\n+    token_type: str\n+\n+\n+class TokenPayload(BaseModel):\n+    username: str = None\n+\n+\n+class User(BaseModel):\n+    username: str\n+    email: Optional[str] = None\n+    full_name: Optional[str] = None\n+    disabled: Optional[bool] = None\n+\n+\n+class UserInDB(User):\n+    hashed_password: str\n+\n+\n+pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n+\n+oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/token\")\n+\n+app = FastAPI()\n+\n+\n+def verify_password(plain_password, hashed_password):\n+    return pwd_context.verify(plain_password, hashed_password)\n+\n+\n+def get_password_hash(password):\n+    return pwd_context.hash(password)\n+\n+\n+def get_user(db, username: str):\n+    if username in db:\n+        user_dict = db[username]\n+        return UserInDB(**user_dict)\n+\n+\n+def authenticate_user(fake_db, username: str, password: str):\n+    user = get_user(fake_db, username)\n+    if not user:\n+        return False\n+    if not verify_password(password, user.hashed_password):\n+        return False\n+    return user\n+\n+\n+def create_access_token(*, data: dict, expires_delta: timedelta = None):\n+    to_encode = data.copy()\n+    if expires_delta:\n+        expire = datetime.utcnow() + expires_delta\n+    else:\n+        expire = datetime.utcnow() + timedelta(minutes=15)\n+    to_encode.update({\"exp\": expire, \"sub\": TOKEN_SUBJECT})\n+    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n+    return encoded_jwt\n+\n+\n+async def get_current_user(token: str = Security(oauth2_scheme)):\n+    try:\n+        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n+        token_data = TokenPayload(**payload)\n+    except PyJWTError:\n+        raise HTTPException(\n+            status_code=HTTP_403_FORBIDDEN, detail=\"Could not validate credentials\"\n+        )\n+    user = get_user(fake_users_db, username=token_data.username)\n+    return user\n+\n+\n+async def get_current_active_user(current_user: User = Depends(get_current_user)):\n+    if not current_user.disabled:\n+        raise HTTPException(status_code=400, detail=\"Inactive user\")\n+    return current_user\n+\n+\n+@app.post(\"/token\", response_model=Token)\n+async def route_login_access_token(form_data: OAuth2PasswordRequestForm):\n+    data = form_data.parse()\n+    user = authenticate_user(fake_users_db, data.username, data.password)\n+    if not user:\n+        raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n+    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n+    return {\n+        \"access_token\": create_access_token(\n+            data={\"username\": data.username}, expires_delta=access_token_expires\n+        ),\n+        \"token_type\": \"bearer\",\n+    }\n+\n+\n+@app.get(\"/users/me\", response_model=User)\n+async def read_users_me(current_user: User = Depends(get_current_active_user)):\n+    return current_user\n+\n+\n+@app.get(\"/users/me/items/\")\n+async def read_own_items(current_user: User = Depends(get_current_active_user)):\n+    return [{\"item_id\": \"Foo\", \"owner\": current_user.username}]\n\n@@ -0,0 +1,18 @@\n+from fastapi import APIRouter\n+\n+router = APIRouter()\n+\n+\n+@router.get(\"/users/\")\n+async def read_users():\n+    return [{\"username\": \"Foo\"}, {\"username\": \"Bar\"}]\n+\n+\n+@router.get(\"/users/{username}\")\n+async def read_user(username: str):\n+    return {\"username\": username}\n+\n+\n+@router.get(\"/users/me\")\n+async def read_user_me():\n+    return {\"username\": \"fakecurrentuser\"}\n\n@@ -0,0 +1,13 @@\n+from fastapi import APIRouter\n+\n+router = APIRouter()\n+\n+\n+@router.get(\"/\")\n+async def read_items():\n+    return [{\"name\": \"Item Foo\"}, {\"name\": \"item Bar\"}]\n+\n+\n+@router.get(\"/{item_id}\")\n+async def read_item(item_id: str):\n+    return {\"name\": \"Fake Specific Item\", \"item_id\": item_id}\n\n@@ -0,0 +1,9 @@\n+from fastapi import FastAPI\n+\n+from .tutorial74 import router as users_router\n+from .tutorial75 import router as items_router\n+\n+app = FastAPI()\n+\n+app.include_router(users_router)\n+app.include_router(items_router, prefix=\"/items\")\n\n@@ -0,0 +1,12 @@\n+from fastapi import FastAPI\n+\n+app = FastAPI(\n+    title=\"My Super Project\",\n+    description=\"This is a very fancy project, with auto docs for the API and everything\",\n+    version=\"2.5.0\",\n+)\n+\n+\n+@app.get(\"/items/\")\n+async def read_items():\n+    return [{\"name\": \"Foo\"}]\n\n@@ -0,0 +1,10 @@\n+from fastapi import FastAPI\n+\n+app = FastAPI(\n+    title=\"My Super Project\", version=\"2.5.0\", openapi_url=\"/api/v1/openapi.json\"\n+)\n+\n+\n+@app.get(\"/items/\")\n+async def read_items():\n+    return [{\"name\": \"Foo\"}]\n\n@@ -0,0 +1,14 @@\n+from fastapi import FastAPI\n+\n+app = FastAPI(\n+    title=\"My Super Project\",\n+    version=\"2.5.0\",\n+    openapi_url=\"/api/v1/openapi.json\",\n+    docs_url=\"/api/v1/docs\",\n+    redoc_url=None,\n+)\n+\n+\n+@app.get(\"/items/\")\n+async def read_items():\n+    return [{\"name\": \"Foo\"}]\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#ec7bec32ba952b32633634112c3ff15f6bd228e3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 48 | Files Changed: 3 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 51 | Churn Cumulative: 95 | Contributors (this commit): 1 | Commits (past 90d): 6 | Contributors (cumulative): 3 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,17 +0,0 @@\n-from fastapi import Body, FastAPI\n-from pydantic import BaseModel, Schema\n-\n-app = FastAPI()\n-\n-\n-class Item(BaseModel):\n-    name: str\n-    description: str = Schema(None, title=\"The description of the item\", max_length=300)\n-    price: float = Schema(..., gt=0, description=\"The price must be greater than zero\")\n-    tax: float = None\n-\n-\n-@app.put(\"/items/{item_id}\")\n-async def update_item(*, item_id: int, item: Item = Body(..., embed=True)):\n-    results = {\"item_id\": item_id, \"item\": item}\n-    return results\n\n@@ -1,29 +0,0 @@\n-from fastapi import Body, FastAPI\n-from pydantic import BaseModel, Schema\n-\n-app = FastAPI()\n-\n-\n-class Item(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    tax: float = None\n-\n-\n-@app.put(\"/items/{item_id}\")\n-async def update_item(\n-    *,\n-    item_id: int,\n-    item: Item = Body(\n-        ...,\n-        example={\n-            \"name\": \"Foo\",\n-            \"description\": \"A very nice Item\",\n-            \"price\": 35.4,\n-            \"tax\": 3.2,\n-        },\n-    )\n-):\n-    results = {\"item_id\": item_id, \"item\": item}\n-    return results\n\n@@ -4,8 +4,9 @@ from string import digits\n \n \n #%%\n-directory = Path(\"../docs/tutorial/src\")\n-output_directory = Path(\"../docs/tutorial/out\")\n+directory = Path(\"./docs/tutorial/src\")\n+output_directory = Path(\"./docs/tutorial/out\")\n+output_directory.mkdir(exist_ok=True)\n files = sorted([Path(f) for f in directory.iterdir()])\n for i, f in enumerate(files):\n     f: Path\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "fastapi#400a4a99afac7ac5990f935c68b99bfe30cedf3e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 311 | Lines Deleted: 322 | Files Changed: 35 | Hunks: 80 | Methods Changed: 58 | Complexity Δ (Sum/Max): -4/3 | Churn Δ: 633 | Churn Cumulative: 2417 | Contributors (this commit): 1 | Commits (past 90d): 130 | Contributors (cumulative): 35 | DMM Complexity: 0.0\n\nDIFF:\n@@ -0,0 +1,17 @@\n+from fastapi import Body, FastAPI\n+from pydantic import BaseModel, Schema\n+\n+app = FastAPI()\n+\n+\n+class Item(BaseModel):\n+    name: str\n+    description: str = Schema(None, title=\"The description of the item\", max_length=300)\n+    price: float = Schema(..., gt=0, description=\"The price must be greater than zero\")\n+    tax: float = None\n+\n+\n+@app.put(\"/items/{item_id}\")\n+async def update_item(*, item_id: int, item: Item = Body(..., embed=True)):\n+    results = {\"item_id\": item_id, \"item\": item}\n+    return results\n\n@@ -1,5 +1,5 @@\n-from fastapi import FastAPI\n-from pydantic import BaseModel\n+from fastapi import Body, FastAPI\n+from pydantic import BaseModel, Schema\n \n app = FastAPI()\n \n@@ -9,10 +9,21 @@ class Item(BaseModel):\n     description: str = None\n     price: float\n     tax: float = None\n-    tags: list = []\n \n \n @app.put(\"/items/{item_id}\")\n-async def update_item(*, item_id: int, item: Item):\n+async def update_item(\n+    *,\n+    item_id: int,\n+    item: Item = Body(\n+        ...,\n+        example={\n+            \"name\": \"Foo\",\n+            \"description\": \"A very nice Item\",\n+            \"price\": 35.4,\n+            \"tax\": 3.2,\n+        },\n+    )\n+):\n     results = {\"item_id\": item_id, \"item\": item}\n     return results\n\n@@ -1,5 +1,3 @@\n-from typing import List\n-\n from fastapi import FastAPI\n from pydantic import BaseModel\n \n@@ -11,7 +9,7 @@ class Item(BaseModel):\n     description: str = None\n     price: float\n     tax: float = None\n-    tags: List[str] = []\n+    tags: list = []\n \n \n @app.put(\"/items/{item_id}\")\n\n@@ -1,4 +1,4 @@\n-from typing import Set\n+from typing import List\n \n from fastapi import FastAPI\n from pydantic import BaseModel\n@@ -11,7 +11,7 @@ class Item(BaseModel):\n     description: str = None\n     price: float\n     tax: float = None\n-    tags: Set[str] = []\n+    tags: List[str] = []\n \n \n @app.put(\"/items/{item_id}\")\n\n@@ -6,18 +6,12 @@ from pydantic import BaseModel\n app = FastAPI()\n \n \n-class Image(BaseModel):\n-    url: str\n-    name: str\n-\n-\n class Item(BaseModel):\n     name: str\n     description: str = None\n     price: float\n     tax: float = None\n     tags: Set[str] = []\n-    image: Image = None\n \n \n @app.put(\"/items/{item_id}\")\n\n@@ -2,13 +2,12 @@ from typing import Set\n \n from fastapi import FastAPI\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n \n app = FastAPI()\n \n \n class Image(BaseModel):\n-    url: UrlStr\n+    url: str\n     name: str\n \n \n\n@@ -1,4 +1,4 @@\n-from typing import List, Set\n+from typing import Set\n \n from fastapi import FastAPI\n from pydantic import BaseModel\n@@ -18,7 +18,7 @@ class Item(BaseModel):\n     price: float\n     tax: float = None\n     tags: Set[str] = []\n-    image: List[Image] = None\n+    image: Image = None\n \n \n @app.put(\"/items/{item_id}\")\n\n@@ -21,13 +21,7 @@ class Item(BaseModel):\n     image: List[Image] = None\n \n \n-class Offer(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    items: List[Item]\n-\n-\n-@app.post(\"/offers/\")\n-async def create_offer(*, offer: Offer):\n-    return offer\n+@app.put(\"/items/{item_id}\")\n+async def update_item(*, item_id: int, item: Item):\n+    results = {\"item_id\": item_id, \"item\": item}\n+    return results\n\n@@ -1,4 +1,4 @@\n-from typing import List\n+from typing import List, Set\n \n from fastapi import FastAPI\n from pydantic import BaseModel\n@@ -12,6 +12,22 @@ class Image(BaseModel):\n     name: str\n \n \n-@app.post(\"/images/multiple/\")\n-async def create_multiple_images(*, images: List[Image]):\n-    return images\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+    tags: Set[str] = []\n+    image: List[Image] = None\n+\n+\n+class Offer(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    items: List[Item]\n+\n+\n+@app.post(\"/offers/\")\n+async def create_offer(*, offer: Offer):\n+    return offer\n\n@@ -1,8 +1,17 @@\n-from fastapi import Cookie, FastAPI\n+from typing import List\n+\n+from fastapi import FastAPI\n+from pydantic import BaseModel\n+from pydantic.types import UrlStr\n \n app = FastAPI()\n \n \n-@app.get(\"/items/\")\n-async def read_items(*, ads_id: str = Cookie(None)):\n-    return {\"ads_id\": ads_id}\n+class Image(BaseModel):\n+    url: UrlStr\n+    name: str\n+\n+\n+@app.post(\"/images/multiple/\")\n+async def create_multiple_images(*, images: List[Image]):\n+    return images\n\n@@ -1,8 +1,8 @@\n-from fastapi import FastAPI, Header\n+from fastapi import Cookie, FastAPI\n \n app = FastAPI()\n \n \n @app.get(\"/items/\")\n-async def read_items(*, accept_encoding: str = Header(None)):\n-    return {\"Accept-Encoding\": accept_encoding}\n+async def read_items(*, ads_id: str = Cookie(None)):\n+    return {\"ads_id\": ads_id}\n\n@@ -4,5 +4,5 @@ app = FastAPI()\n \n \n @app.get(\"/items/\")\n-async def read_items(*, strange_header: str = Header(None, convert_underscores=False)):\n-    return {\"strange_header\": strange_header}\n+async def read_items(*, accept_encoding: str = Header(None)):\n+    return {\"Accept-Encoding\": accept_encoding}\n\n@@ -1,19 +1,8 @@\n-from typing import Set\n-\n-from fastapi import FastAPI\n-from pydantic import BaseModel\n+from fastapi import FastAPI, Header\n \n app = FastAPI()\n \n \n-class Item(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    tax: float = None\n-    tags: Set[str] = []\n-\n-\n-@app.post(\"/items/\", response_model=Item)\n-async def create_item(*, item: Item):\n-    return item\n+@app.get(\"/items/\")\n+async def read_items(*, strange_header: str = Header(None, convert_underscores=False)):\n+    return {\"strange_header\": strange_header}\n\n@@ -1,18 +1,19 @@\n+from typing import Set\n+\n from fastapi import FastAPI\n from pydantic import BaseModel\n-from pydantic.types import EmailStr\n \n app = FastAPI()\n \n \n-class UserIn(BaseModel):\n-    username: str\n-    password: str\n-    email: EmailStr\n-    full_name: str = None\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+    tags: Set[str] = []\n \n \n-# Don't do this in production!\n-@app.post(\"/user/\", response_model=UserIn)\n-async def create_user(*, user: UserIn):\n-    return user\n+@app.post(\"/items/\", response_model=Item)\n+async def create_item(*, item: Item):\n+    return item\n\n@@ -12,12 +12,7 @@ class UserIn(BaseModel):\n     full_name: str = None\n \n \n-class UserOut(BaseModel):\n-    username: str\n-    email: EmailStr\n-    full_name: str = None\n-\n-\n-@app.post(\"/user/\", response_model=UserOut)\n+# Don't do this in production!\n+@app.post(\"/user/\", response_model=UserIn)\n async def create_user(*, user: UserIn):\n     return user\n\n@@ -18,25 +18,6 @@ class UserOut(BaseModel):\n     full_name: str = None\n \n \n-class UserInDB(BaseModel):\n-    username: str\n-    hashed_password: str\n-    email: EmailStr\n-    full_name: str = None\n-\n-\n-def fake_password_hasher(raw_password: str):\n-    return \"supersecret\" + raw_password\n-\n-\n-def fake_save_user(user_in: UserIn):\n-    hashed_password = fake_password_hasher(user_in.password)\n-    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)\n-    print(\"User saved! ..not really\")\n-    return user_in_db\n-\n-\n @app.post(\"/user/\", response_model=UserOut)\n-async def create_user(*, user_in: UserIn):\n-    user_saved = fake_save_user(user_in)\n-    return user_saved\n+async def create_user(*, user: UserIn):\n+    return user\n\n@@ -5,22 +5,24 @@ from pydantic.types import EmailStr\n app = FastAPI()\n \n \n-class UserBase(BaseModel):\n+class UserIn(BaseModel):\n+    username: str\n+    password: str\n+    email: EmailStr\n+    full_name: str = None\n+\n+\n+class UserOut(BaseModel):\n     username: str\n     email: EmailStr\n     full_name: str = None\n \n \n-class UserIn(UserBase):\n-    password: str\n-\n-\n-class UserOut(UserBase):\n-    pass\n-\n-\n-class UserInDB(UserBase):\n+class UserInDB(BaseModel):\n+    username: str\n     hashed_password: str\n+    email: EmailStr\n+    full_name: str = None\n \n \n def fake_password_hasher(raw_password: str):\n\n@@ -1,8 +1,40 @@\n-from fastapi import FastAPI, Form\n+from fastapi import FastAPI\n+from pydantic import BaseModel\n+from pydantic.types import EmailStr\n \n app = FastAPI()\n \n \n-@app.post(\"/login/\")\n-async def login(*, username: str = Form(...), password: str = Form(...)):\n-    return {\"username\": username}\n+class UserBase(BaseModel):\n+    username: str\n+    email: EmailStr\n+    full_name: str = None\n+\n+\n+class UserIn(UserBase):\n+    password: str\n+\n+\n+class UserOut(UserBase):\n+    pass\n+\n+\n+class UserInDB(UserBase):\n+    hashed_password: str\n+\n+\n+def fake_password_hasher(raw_password: str):\n+    return \"supersecret\" + raw_password\n+\n+\n+def fake_save_user(user_in: UserIn):\n+    hashed_password = fake_password_hasher(user_in.password)\n+    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)\n+    print(\"User saved! ..not really\")\n+    return user_in_db\n+\n+\n+@app.post(\"/user/\", response_model=UserOut)\n+async def create_user(*, user_in: UserIn):\n+    user_saved = fake_save_user(user_in)\n+    return user_saved\n\n@@ -1,8 +1,8 @@\n-from fastapi import FastAPI, File\n+from fastapi import FastAPI, Form\n \n app = FastAPI()\n \n \n-@app.post(\"/files/\")\n-async def create_file(*, file: bytes = File(...)):\n-    return {\"file_size\": len(file)}\n+@app.post(\"/login/\")\n+async def login(*, username: str = Form(...), password: str = Form(...)):\n+    return {\"username\": username}\n\n@@ -1,8 +1,8 @@\n-from fastapi import FastAPI, File, Form\n+from fastapi import FastAPI, File\n \n app = FastAPI()\n \n \n @app.post(\"/files/\")\n-async def create_file(*, file: bytes = File(...), token: str = Form(...)):\n-    return {\"file_size\": len(file), \"token\": token}\n+async def create_file(*, file: bytes = File(...)):\n+    return {\"file_size\": len(file)}\n\n@@ -1,20 +1,8 @@\n-from typing import Set\n-\n-from fastapi import FastAPI\n-from pydantic import BaseModel\n-from starlette.status import HTTP_201_CREATED\n+from fastapi import FastAPI, File, Form\n \n app = FastAPI()\n \n \n-class Item(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    tax: float = None\n-    tags: Set[str] = []\n-\n-\n-@app.post(\"/items/\", response_model=Item, status_code=HTTP_201_CREATED)\n-async def create_item(*, item: Item):\n-    return item\n+@app.post(\"/files/\")\n+async def create_file(*, file: bytes = File(...), token: str = Form(...)):\n+    return {\"file_size\": len(file), \"token\": token}\n\n@@ -2,6 +2,7 @@ from typing import Set\n \n from fastapi import FastAPI\n from pydantic import BaseModel\n+from starlette.status import HTTP_201_CREATED\n \n app = FastAPI()\n \n@@ -14,6 +15,6 @@ class Item(BaseModel):\n     tags: Set[str] = []\n \n \n-@app.post(\"/items/\", response_model=Item, tags=[\"items\"])\n+@app.post(\"/items/\", response_model=Item, status_code=HTTP_201_CREATED)\n async def create_item(*, item: Item):\n     return item\n\n@@ -14,11 +14,6 @@ class Item(BaseModel):\n     tags: Set[str] = []\n \n \n-@app.post(\n-    \"/items/\",\n-    response_model=Item,\n-    summary=\"Create an item\",\n-    description=\"Create an item with all the information, name, description, price, tax and a set of unique tags\",\n-)\n+@app.post(\"/items/\", response_model=Item, tags=[\"items\"])\n async def create_item(*, item: Item):\n     return item\n\n@@ -14,15 +14,11 @@ class Item(BaseModel):\n     tags: Set[str] = []\n \n \n-@app.post(\"/items/\", response_model=Item, summary=\"Create an item\")\n+@app.post(\n+    \"/items/\",\n+    response_model=Item,\n+    summary=\"Create an item\",\n+    description=\"Create an item with all the information, name, description, price, tax and a set of unique tags\",\n+)\n async def create_item(*, item: Item):\n-    \"\"\"\n-    Create an item with all the information:\n-    \n-    * name: each item must have a name\n-    * description: a long description\n-    * price: required\n-    * tax: if the item doesn't have tax, you can omit this\n-    * tags: a set of unique tag strings for this item\n-    \"\"\"\n     return item\n\n@@ -14,12 +14,7 @@ class Item(BaseModel):\n     tags: Set[str] = []\n \n \n-@app.post(\n-    \"/items/\",\n-    response_model=Item,\n-    summary=\"Create an item\",\n-    response_description=\"The created item\",\n-)\n+@app.post(\"/items/\", response_model=Item, summary=\"Create an item\")\n async def create_item(*, item: Item):\n     \"\"\"\n     Create an item with all the information:\n\n@@ -1,8 +1,33 @@\n+from typing import Set\n+\n from fastapi import FastAPI\n+from pydantic import BaseModel\n \n app = FastAPI()\n \n \n-@app.get(\"/items/\", deprecated=True)\n-async def read_items():\n-    return [{\"item_id\": \"Foo\"}]\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+    tags: Set[str] = []\n+\n+\n+@app.post(\n+    \"/items/\",\n+    response_model=Item,\n+    summary=\"Create an item\",\n+    response_description=\"The created item\",\n+)\n+async def create_item(*, item: Item):\n+    \"\"\"\n+    Create an item with all the information:\n+    \n+    * name: each item must have a name\n+    * description: a long description\n+    * price: required\n+    * tax: if the item doesn't have tax, you can omit this\n+    * tags: a set of unique tag strings for this item\n+    \"\"\"\n+    return item\n\n@@ -3,6 +3,6 @@ from fastapi import FastAPI\n app = FastAPI()\n \n \n-@app.get(\"/items/\", operation_id=\"some_specific_id_you_define\")\n+@app.get(\"/items/\", deprecated=True)\n async def read_items():\n     return [{\"item_id\": \"Foo\"}]\n\n@@ -3,6 +3,6 @@ from fastapi import FastAPI\n app = FastAPI()\n \n \n-@app.get(\"/items/\", include_in_schema=False)\n+@app.get(\"/items/\", operation_id=\"some_specific_id_you_define\")\n async def read_items():\n     return [{\"item_id\": \"Foo\"}]\n\n@@ -1,9 +1,8 @@\n from fastapi import FastAPI\n-from starlette.responses import UJSONResponse\n \n app = FastAPI()\n \n \n-@app.get(\"/items/\", content_type=UJSONResponse)\n+@app.get(\"/items/\", include_in_schema=False)\n async def read_items():\n     return [{\"item_id\": \"Foo\"}]\n\n@@ -1,18 +1,9 @@\n from fastapi import FastAPI\n-from starlette.responses import HTMLResponse\n+from starlette.responses import UJSONResponse\n \n app = FastAPI()\n \n \n-@app.get(\"/items/\", content_type=HTMLResponse)\n+@app.get(\"/items/\", content_type=UJSONResponse)\n async def read_items():\n-    return \"\"\"\n-    <html>\n-        <head>\n-            <title>Some HTML in here</title>\n-        </head>\n-        <body>\n-            <h1>Look ma! HTML!</h1>\n-        </body>\n-    </html>\n-    \"\"\"\n+    return [{\"item_id\": \"Foo\"}]\n\n@@ -1,27 +1,18 @@\n-from fastapi import Depends, FastAPI\n-from pydantic import BaseModel\n+from fastapi import FastAPI\n+from starlette.responses import HTMLResponse\n \n app = FastAPI()\n \n \n-fake_items_db = [{\"item_name\": \"Foo\"}, {\"item_name\": \"Bar\"}, {\"item_name\": \"Baz\"}]\n-\n-\n-class CommonQueryParams(BaseModel):\n-    q: str = None\n-    skip: int = None\n-    limit: int = None\n-\n-\n-async def common_parameters(q: str = None, skip: int = 0, limit: int = 100):\n-    return CommonQueryParams(q=q, skip=skip, limit=limit)\n-\n-\n-@app.get(\"/items/\")\n-async def read_items(commons: CommonQueryParams = Depends(common_parameters)):\n-    response = {}\n-    if commons.q:\n-        response.update({\"q\": commons.q})\n-    items = fake_items_db[commons.skip : commons.limit]\n-    response.update({\"items\": items})\n-    return response\n+@app.get(\"/items/\", content_type=HTMLResponse)\n+async def read_items():\n+    return \"\"\"\n+    <html>\n+        <head>\n+            <title>Some HTML in here</title>\n+        </head>\n+        <body>\n+            <h1>Look ma! HTML!</h1>\n+        </body>\n+    </html>\n+    \"\"\"\n\n@@ -1,34 +1,27 @@\n-from typing import List\n-\n-from fastapi import Cookie, Depends, FastAPI\n+from fastapi import Depends, FastAPI\n from pydantic import BaseModel\n \n app = FastAPI()\n \n \n-class InterestsTracker(BaseModel):\n-    track_code: str\n-    interests: List[str]\n+fake_items_db = [{\"item_name\": \"Foo\"}, {\"item_name\": \"Bar\"}, {\"item_name\": \"Baz\"}]\n \n \n-fake_tracked_users_db = {\n-    \"Foo\": {\"track_code\": \"Foo\", \"interests\": [\"sports\", \"movies\"]},\n-    \"Bar\": {\"track_code\": \"Bar\", \"interests\": [\"food\", \"shows\"]},\n-    \"Baz\": {\"track_code\": \"Baz\", \"interests\": [\"gaming\", \"virtual reality\"]},\n-}\n+class CommonQueryParams(BaseModel):\n+    q: str = None\n+    skip: int = None\n+    limit: int = None\n \n \n-async def get_tracked_interests(track_code: str = Cookie(None)):\n-    if track_code in fake_tracked_users_db:\n-        track_dict = fake_tracked_users_db[track_code]\n-        track = InterestsTracker(**track_dict)\n-        return track\n-    return None\n+async def common_parameters(q: str = None, skip: int = 0, limit: int = 100):\n+    return CommonQueryParams(q=q, skip=skip, limit=limit)\n \n \n-@app.get(\"/interests/\")\n-async def read_interests(\n-    tracked_interests: InterestsTracker = Depends(get_tracked_interests)\n-):\n-    response = {\"interests\": tracked_interests.interests}\n+@app.get(\"/items/\")\n+async def read_items(commons: CommonQueryParams = Depends(common_parameters)):\n+    response = {}\n+    if commons.q:\n+        response.update({\"q\": commons.q})\n+    items = fake_items_db[commons.skip : commons.limit]\n+    response.update({\"items\": items})\n     return response\n\n@@ -1,4 +1,3 @@\n-from random import choice\n from typing import List\n \n from fastapi import Cookie, Depends, FastAPI\n@@ -27,23 +26,9 @@ async def get_tracked_interests(track_code: str = Cookie(None)):\n     return None\n \n \n-class ComplexTracker:\n-    def __init__(self, tracker: InterestsTracker = Depends(get_tracked_interests)):\n-        self.tracker = tracker\n-\n-    def random_interest(self):\n-        \"\"\"\n-        Get a random interest from the tracked ones for the current user.\n-        If the user doesn't have tracked interests, return a random one from the ones available.\n-        \"\"\"\n-        if self.tracker.interests:\n-            return choice(self.tracker.interests)\n-        return choice(\n-            [\"sports\", \"movies\", \"food\", \"shows\", \"gaming\", \"virtual reality\"]\n-        )\n-\n-\n-@app.get(\"/suggested-category\")\n-async def read_suggested_category(tracker: ComplexTracker = Depends(None)):\n-    response = {\"category\": tracker.random_interest()}\n+@app.get(\"/interests/\")\n+async def read_interests(\n+    tracked_interests: InterestsTracker = Depends(get_tracked_interests)\n+):\n+    response = {\"interests\": tracked_interests.interests}\n     return response\n\n@@ -1,52 +1,49 @@\n-from fastapi import FastAPI\n+from random import choice\n+from typing import List\n \n-from sqlalchemy import Boolean, Column, Integer, String, create_engine\n-from sqlalchemy.ext.declarative import declarative_base, declared_attr\n-from sqlalchemy.orm import scoped_session, sessionmaker\n+from fastapi import Cookie, Depends, FastAPI\n+from pydantic import BaseModel\n \n-# SQLAlchemy specific code, as with any other app\n-\n-\n-SQLALCHEMY_DATABASE_URI = \"postgresql://user:password@postgresserver/db\"\n-\n-# By creating this a CustomBase class and inheriting from it, your models will have\n-# automatic __tablename__ attributes. So you don't have to declare them.\n-# So, your models will behave very similarly to, for example, Flask-SQLAlchemy\n-\n-\n-class CustomBase:\n-    # Generate __tablename__ automatically\n-    @declared_attr\n-    def __tablename__(cls):\n-        return cls.__name__.lower()\n-\n-\n-Base = declarative_base(cls=CustomBase)\n-\n-\n-class User(Base):\n-    # Own properties\n-    id = Column(Integer, primary_key=True, index=True)\n-    email = Column(String, unique=True, index=True)\n-    hashed_password = Column(String)\n-    is_active = Column(Boolean(), default=True)\n-\n-\n-engine = create_engine(SQLALCHEMY_DATABASE_URI, convert_unicode=True)\n-db_session = scoped_session(\n-    sessionmaker(autocommit=False, autoflush=False, bind=engine)\n-)\n-\n-\n-def get_user(username, db_session):\n-    return db_session.query(User).filter(User.id == username).first()\n-\n-\n-# FastAPI specific code\n app = FastAPI()\n \n \n-@app.get(\"/users/{username}\")\n-def read_user(username: str):\n-    user = get_user(username, db_session)\n-    return user\n+class InterestsTracker(BaseModel):\n+    track_code: str\n+    interests: List[str]\n+\n+\n+fake_tracked_users_db = {\n+    \"Foo\": {\"track_code\": \"Foo\", \"interests\": [\"sports\", \"movies\"]},\n+    \"Bar\": {\"track_code\": \"Bar\", \"interests\": [\"food\", \"shows\"]},\n+    \"Baz\": {\"track_code\": \"Baz\", \"interests\": [\"gaming\", \"virtual reality\"]},\n+}\n+\n+\n+async def get_tracked_interests(track_code: str = Cookie(None)):\n+    if track_code in fake_tracked_users_db:\n+        track_dict = fake_tracked_users_db[track_code]\n+        track = InterestsTracker(**track_dict)\n+        return track\n+    return None\n+\n+\n+class ComplexTracker:\n+    def __init__(self, tracker: InterestsTracker = Depends(get_tracked_interests)):\n+        self.tracker = tracker\n+\n+    def random_interest(self):\n+        \"\"\"\n+        Get a random interest from the tracked ones for the current user.\n+        If the user doesn't have tracked interests, return a random one from the ones available.\n+        \"\"\"\n+        if self.tracker.interests:\n+            return choice(self.tracker.interests)\n+        return choice(\n+            [\"sports\", \"movies\", \"food\", \"shows\", \"gaming\", \"virtual reality\"]\n+        )\n+\n+\n+@app.get(\"/suggested-category\")\n+async def read_suggested_category(tracker: ComplexTracker = Depends(None)):\n+    response = {\"category\": tracker.random_interest()}\n+    return response\n\n@@ -1,49 +1,45 @@\n-from typing import Optional\n-\n from fastapi import FastAPI\n-from pydantic import BaseModel\n \n-from app.models.config import USERPROFILE_DOC_TYPE\n-from couchbase import LOCKMODE_WAIT\n-from couchbase.bucket import Bucket\n-from couchbase.cluster import Cluster, PasswordAuthenticator\n+from sqlalchemy import Boolean, Column, Integer, String, create_engine\n+from sqlalchemy.ext.declarative import declarative_base, declared_attr\n+from sqlalchemy.orm import scoped_session, sessionmaker\n+\n+# SQLAlchemy specific code, as with any other app\n \n \n-def get_bucket():\n-    cluster = Cluster(\"couchbase://couchbasehost:8091\")\n-    authenticator = PasswordAuthenticator(\"username\", \"password\")\n-    cluster.authenticate(authenticator)\n-    bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT)\n-    return bucket\n+SQLALCHEMY_DATABASE_URI = \"postgresql://user:password@postgresserver/db\"\n+\n+# By creating this a CustomBase class and inheriting from it, your models will have\n+# automatic __tablename__ attributes. So you don't have to declare them.\n+# So, your models will behave very similarly to, for example, Flask-SQLAlchemy\n \n \n-class User(BaseModel):\n-    username: str\n-    email: Optional[str] = None\n-    full_name: Optional[str] = None\n-    disabled: Optional[bool] = None\n+class CustomBase:\n+    # Generate __tablename__ automatically\n+    @declared_attr\n+    def __tablename__(cls):\n+        return cls.__name__.lower()\n \n \n-class UserInDB(User):\n-    type: str = USERPROFILE_DOC_TYPE\n-    hashed_password: str\n-\n-    class Meta:\n-        key: Optional[str] = None\n+Base = declarative_base(cls=CustomBase)\n \n \n-def get_user_doc_id(username):\n-    return f\"userprofile::{username}\"\n+class User(Base):\n+    # Own properties\n+    id = Column(Integer, primary_key=True, index=True)\n+    email = Column(String, unique=True, index=True)\n+    hashed_password = Column(String)\n+    is_active = Column(Boolean(), default=True)\n \n \n-def get_user(bucket: Bucket, username: str):\n-    doc_id = get_user_doc_id(username)\n-    result = bucket.get(doc_id, quiet=True)\n-    if not result.value:\n-        return None\n-    user = UserInDB(**result.value)\n-    user.Meta.key = result.key\n-    return user\n+engine = create_engine(SQLALCHEMY_DATABASE_URI, convert_unicode=True)\n+db_session = scoped_session(\n+    sessionmaker(autocommit=False, autoflush=False, bind=engine)\n+)\n+\n+\n+def get_user(username, db_session):\n+    return db_session.query(User).filter(User.id == username).first()\n \n \n # FastAPI specific code\n@@ -52,6 +48,5 @@ app = FastAPI()\n \n @app.get(\"/users/{username}\")\n def read_user(username: str):\n-    bucket = get_bucket()\n-    user = get_user(bucket=bucket, username=username)\n+    user = get_user(username, db_session)\n     return user\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
