{"custom_id": "fastapi#a47243d915068ea7286e2d958e82deb7bc5ecd0e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 656 | Lines Deleted: 656 | Files Changed: 71 | Hunks: 171 | Methods Changed: 130 | Complexity Δ (Sum/Max): 2/5 | Churn Δ: 1312 | Churn Cumulative: 2538 | Contributors (this commit): 1 | Commits (past 90d): 130 | Contributors (cumulative): 71 | DMM Complexity: None\n\nDIFF:\n@@ -1,10 +0,0 @@\n-from fastapi import FastAPI\n-from fastapi import FastAPI\n-\n-app = FastAPI()\n-\n-@app.get(\"/items/{item_id}\")\n-async def read_item(item_id: str, q: str = None):\n-    if q:\n-        return {\"item_id\": item_id, \"q\": q}\n-    return {\"item_id\": item_id}\n\n\n@@ -1,12 +1,10 @@\n from fastapi import FastAPI\n+from fastapi import FastAPI\n \n app = FastAPI()\n \n @app.get(\"/items/{item_id}\")\n-async def read_item(item_id: str, q: str = None, short: bool = False):\n-    item = {\"item_id\": item_id}\n+async def read_item(item_id: str, q: str = None):\n     if q:\n-        item.update({\"q\": q})\n-    if not short:\n-        item.update({\"description\": \"This is an amazing item that has a long description\"})\n-    return item\n+        return {\"item_id\": item_id, \"q\": q}\n+    return {\"item_id\": item_id}\n\n@@ -2,9 +2,9 @@ from fastapi import FastAPI\n \n app = FastAPI()\n \n-@app.get(\"/users/{user_id}/items/{item_id}\")\n-async def read_user_item(user_id: int, item_id: str, q: str = None, short: bool = False):\n-    item = {\"item_id\": item_id, \"owner_id\": user_id}\n+@app.get(\"/items/{item_id}\")\n+async def read_item(item_id: str, q: str = None, short: bool = False):\n+    item = {\"item_id\": item_id}\n     if q:\n         item.update({\"q\": q})\n     if not short:\n\n@@ -3,8 +3,8 @@ from fastapi import FastAPI\n app = FastAPI()\n \n @app.get(\"/users/{user_id}/items/{item_id}\")\n-async def read_user_item(user_id: int, item_id: str, needy: str, q: str = None, short: bool = False):\n-    item = {\"item_id\": item_id, \"owner_id\": user_id, \"needy\": needy}\n+async def read_user_item(user_id: int, item_id: str, q: str = None, short: bool = False):\n+    item = {\"item_id\": item_id, \"owner_id\": user_id}\n     if q:\n         item.update({\"q\": q})\n     if not short:\n\n@@ -1,15 +1,12 @@\n from fastapi import FastAPI\n-from pydantic import BaseModel\n-\n-class Item(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    tax: float = None\n-\n \n app = FastAPI()\n \n-@app.post(\"/items/\")\n-async def create_item(item: Item):\n+@app.get(\"/users/{user_id}/items/{item_id}\")\n+async def read_user_item(user_id: int, item_id: str, needy: str, q: str = None, short: bool = False):\n+    item = {\"item_id\": item_id, \"owner_id\": user_id, \"needy\": needy}\n+    if q:\n+        item.update({\"q\": q})\n+    if not short:\n+        item.update({\"description\": \"This is an amazing item that has a long description\"})\n     return item\n\n@@ -12,8 +12,4 @@ app = FastAPI()\n \n @app.post(\"/items/\")\n async def create_item(item: Item):\n-    item_dict = item.dict()\n-    if item.tax:\n-        price_with_tax = item.price + item.tax\n-        item_dict.update({\"price_with_tax\": price_with_tax})\n-    return item_dict\n+    return item\n\n@@ -10,6 +10,10 @@ class Item(BaseModel):\n \n app = FastAPI()\n \n-@app.put(\"/items/{item_id}\")\n-async def create_item(item_id: int, item: Item):\n-    return {\"item_id\": item_id, **item.dict()}\n+@app.post(\"/items/\")\n+async def create_item(item: Item):\n+    item_dict = item.dict()\n+    if item.tax:\n+        price_with_tax = item.price + item.tax\n+        item_dict.update({\"price_with_tax\": price_with_tax})\n+    return item_dict\n\n@@ -11,8 +11,5 @@ class Item(BaseModel):\n app = FastAPI()\n \n @app.put(\"/items/{item_id}\")\n-async def create_item(item_id: int, item: Item, q: str = None):\n-    result = {\"item_id\": item_id, **item.dict()}\n-    if q:\n-        result.update({\"q\": q})\n-    return result\n+async def create_item(item_id: int, item: Item):\n+    return {\"item_id\": item_id, **item.dict()}\n\n@@ -1,11 +1,18 @@\n-from fastapi import FastAPI, Query\n+from fastapi import FastAPI\n+from pydantic import BaseModel\n+\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+\n \n app = FastAPI()\n \n-\n-@app.get(\"/items/\")\n-async def read_items(q: str = Query(None, max_length=50)):\n-    results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]}\n+@app.put(\"/items/{item_id}\")\n+async def create_item(item_id: int, item: Item, q: str = None):\n+    result = {\"item_id\": item_id, **item.dict()}\n     if q:\n-        results.update({\"q\": q})\n-    return results\n+        result.update({\"q\": q})\n+    return result\n\n@@ -4,7 +4,7 @@ app = FastAPI()\n \n \n @app.get(\"/items/\")\n-async def read_items(q: str = Query(None, min_length=3, max_length=50)):\n+async def read_items(q: str = Query(None, max_length=50)):\n     results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]}\n     if q:\n         results.update({\"q\": q})\n\n@@ -4,7 +4,7 @@ app = FastAPI()\n \n \n @app.get(\"/items/\")\n-async def read_items(q: str = Query(None, min_length=3, max_length=50, regex=\"^fixedquery$\")):\n+async def read_items(q: str = Query(None, min_length=3, max_length=50)):\n     results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]}\n     if q:\n         results.update({\"q\": q})\n\n@@ -4,11 +4,7 @@ app = FastAPI()\n \n \n @app.get(\"/items/\")\n-async def read_items(\n-    q: str = Query(\n-        None, title=\"Query string\", min_length=3, max_length=50, regex=\"^fixedquery$\"\n-    )\n-):\n+async def read_items(q: str = Query(None, min_length=3, max_length=50, regex=\"^fixedquery$\")):\n     results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]}\n     if q:\n         results.update({\"q\": q})\n\n@@ -6,12 +6,7 @@ app = FastAPI()\n @app.get(\"/items/\")\n async def read_items(\n     q: str = Query(\n-        None,\n-        title=\"Query string\",\n-        description=\"Query string for the items to search in the database that have a good match\",\n-        min_length=3,\n-        max_length=50,\n-        regex=\"^fixedquery$\",\n+        None, title=\"Query string\", min_length=3, max_length=50, regex=\"^fixedquery$\"\n     )\n ):\n     results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]}\n\n@@ -1,21 +0,0 @@\n-from fastapi import FastAPI, Query\n-\n-app = FastAPI()\n-\n-\n-@app.get(\"/items/\")\n-async def read_items(\n-    q: str = Query(\n-        \"fixedquery\",\n-        alias=\"item-query\",\n-        title=\"Query string\",\n-        description=\"Query string for the items to search in the database that have a good match\",\n-        min_length=3,\n-        max_length=50,\n-        regex=\"^fixedquery$\",\n-    )\n-):\n-    results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]}\n-    if q:\n-        results.update({\"q\": q})\n-    return results\n\n@@ -1,21 +0,0 @@\n-from fastapi import FastAPI, Query\n-\n-app = FastAPI()\n-\n-\n-@app.get(\"/items/\")\n-async def read_items(\n-    q: str = Query(\n-        ...,\n-        alias=\"item-query\",\n-        title=\"Query string\",\n-        description=\"Query string for the items to search in the database that have a good match\",\n-        min_length=3,\n-        max_length=50,\n-        regex=\"^fixedquery$\",\n-    )\n-):\n-    results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]}\n-    if q:\n-        results.update({\"q\": q})\n-    return results\n\n@@ -7,7 +7,6 @@ app = FastAPI()\n async def read_items(\n     q: str = Query(\n         None,\n-        alias=\"item-query\",\n         title=\"Query string\",\n         description=\"Query string for the items to search in the database that have a good match\",\n         min_length=3,\n\n@@ -6,14 +6,13 @@ app = FastAPI()\n @app.get(\"/items/\")\n async def read_items(\n     q: str = Query(\n-        None,\n+        \"fixedquery\",\n         alias=\"item-query\",\n         title=\"Query string\",\n         description=\"Query string for the items to search in the database that have a good match\",\n         min_length=3,\n         max_length=50,\n         regex=\"^fixedquery$\",\n-        deprecated=True,\n     )\n ):\n     results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]}\n\n@@ -1,14 +1,21 @@\n-from fastapi import FastAPI, Query, Path\n+from fastapi import FastAPI, Query\n \n app = FastAPI()\n \n \n-@app.get(\"/items/{item_id}\")\n+@app.get(\"/items/\")\n async def read_items(\n-    item_id: int = Path(..., title=\"The ID of the item to get\"),\n-    q: str = Query(None, alias=\"item-query\"),\n+    q: str = Query(\n+        None,\n+        alias=\"item-query\",\n+        title=\"Query string\",\n+        description=\"Query string for the items to search in the database that have a good match\",\n+        min_length=3,\n+        max_length=50,\n+        regex=\"^fixedquery$\",\n+    )\n ):\n-    results = {\"item_id\": item_id}\n+    results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]}\n     if q:\n         results.update({\"q\": q})\n     return results\n\n@@ -1,14 +1,21 @@\n-from fastapi import FastAPI, Query, Path\n+from fastapi import FastAPI, Query\n \n app = FastAPI()\n \n \n-@app.get(\"/items/{item_id}\")\n+@app.get(\"/items/\")\n async def read_items(\n-    q: str,\n-    item_id: int = Path(..., title=\"The ID of the item to get\"),\n+    q: str = Query(\n+        ...,\n+        alias=\"item-query\",\n+        title=\"Query string\",\n+        description=\"Query string for the items to search in the database that have a good match\",\n+        min_length=3,\n+        max_length=50,\n+        regex=\"^fixedquery$\",\n+    )\n ):\n-    results = {\"item_id\": item_id}\n+    results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]}\n     if q:\n         results.update({\"q\": q})\n     return results\n\n@@ -1,15 +1,22 @@\n-from fastapi import FastAPI, Query, Path\n+from fastapi import FastAPI, Query\n \n app = FastAPI()\n \n \n-@app.get(\"/items/{item_id}\")\n+@app.get(\"/items/\")\n async def read_items(\n-    *,\n-    item_id: int = Path(..., title=\"The ID of the item to get\"),\n-    q: str,\n+    q: str = Query(\n+        None,\n+        alias=\"item-query\",\n+        title=\"Query string\",\n+        description=\"Query string for the items to search in the database that have a good match\",\n+        min_length=3,\n+        max_length=50,\n+        regex=\"^fixedquery$\",\n+        deprecated=True,\n+    )\n ):\n-    results = {\"item_id\": item_id}\n+    results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]}\n     if q:\n         results.update({\"q\": q})\n     return results\n\n@@ -5,9 +5,8 @@ app = FastAPI()\n \n @app.get(\"/items/{item_id}\")\n async def read_items(\n-    *,\n-    item_id: int = Path(..., title=\"The ID of the item to get\", ge=1),\n-    q: str,\n+    item_id: int = Path(..., title=\"The ID of the item to get\"),\n+    q: str = Query(None, alias=\"item-query\"),\n ):\n     results = {\"item_id\": item_id}\n     if q:\n\n@@ -5,9 +5,8 @@ app = FastAPI()\n \n @app.get(\"/items/{item_id}\")\n async def read_items(\n-    *,\n-    item_id: int = Path(..., title=\"The ID of the item to get\", gt=0, le=1000),\n     q: str,\n+    item_id: int = Path(..., title=\"The ID of the item to get\"),\n ):\n     results = {\"item_id\": item_id}\n     if q:\n\n@@ -6,9 +6,8 @@ app = FastAPI()\n @app.get(\"/items/{item_id}\")\n async def read_items(\n     *,\n-    item_id: int = Path(..., title=\"The ID of the item to get\", ge=0, le=1000),\n+    item_id: int = Path(..., title=\"The ID of the item to get\"),\n     q: str,\n-    size: float = Query(..., gt=0, lt=10.5)\n ):\n     results = {\"item_id\": item_id}\n     if q:\n\n@@ -1,26 +1,15 @@\n from fastapi import FastAPI, Query, Path\n-from pydantic import BaseModel\n \n app = FastAPI()\n \n \n-class Item(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    tax: float = None\n-\n-\n-@app.put(\"/items/{item_id}\")\n-async def update_item(\n+@app.get(\"/items/{item_id}\")\n+async def read_items(\n     *,\n-    item_id: int = Path(..., title=\"The ID of the item to get\", ge=0, le=1000),\n+    item_id: int = Path(..., title=\"The ID of the item to get\", ge=1),\n     q: str,\n-    item: Item = None,\n ):\n     results = {\"item_id\": item_id}\n     if q:\n         results.update({\"q\": q})\n-    if item:\n-        results.update({\"item\": item})\n     return results\n\n@@ -1,27 +1,15 @@\n from fastapi import FastAPI, Query, Path\n-from pydantic import BaseModel\n \n app = FastAPI()\n \n \n-class Item(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    tax: float = None\n-\n-\n-class User(BaseModel):\n-    username: str\n-    full_name: str = None\n-\n-\n-@app.put(\"/items/{item_id}\")\n-async def update_item(\n+@app.get(\"/items/{item_id}\")\n+async def read_items(\n     *,\n-    item_id: int,\n-    item: Item,\n-    user: User,\n+    item_id: int = Path(..., title=\"The ID of the item to get\", gt=0, le=1000),\n+    q: str,\n ):\n-    results = {\"item_id\": item_id, \"item\": item, \"user\": user}\n+    results = {\"item_id\": item_id}\n+    if q:\n+        results.update({\"q\": q})\n     return results\n\n@@ -1,28 +1,16 @@\n-from fastapi import FastAPI, Query, Path, Body\n-from pydantic import BaseModel\n+from fastapi import FastAPI, Query, Path\n \n app = FastAPI()\n \n \n-class Item(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    tax: float = None\n-\n-\n-class User(BaseModel):\n-    username: str\n-    full_name: str = None\n-\n-\n-@app.put(\"/items/{item_id}\")\n-async def update_item(\n+@app.get(\"/items/{item_id}\")\n+async def read_items(\n     *,\n-    item_id: int,\n-    item: Item,\n-    user: User,\n-    access_token: str = Body(...),\n+    item_id: int = Path(..., title=\"The ID of the item to get\", ge=0, le=1000),\n+    q: str,\n+    size: float = Query(..., gt=0, lt=10.5)\n ):\n-    results = {\"item_id\": item_id, \"item\": item, \"user\": user, \"access_token\": access_token}\n+    results = {\"item_id\": item_id}\n+    if q:\n+        results.update({\"q\": q})\n     return results\n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Query, Path, Body\n+from fastapi import FastAPI, Query, Path\n from pydantic import BaseModel\n \n app = FastAPI()\n@@ -11,21 +11,16 @@ class Item(BaseModel):\n     tax: float = None\n \n \n-class User(BaseModel):\n-    username: str\n-    full_name: str = None\n-\n-\n @app.put(\"/items/{item_id}\")\n async def update_item(\n     *,\n-    item_id: int,\n-    item: Item,\n-    user: User,\n-    access_token: str = Body(...),\n-    q: str = None,\n+    item_id: int = Path(..., title=\"The ID of the item to get\", ge=0, le=1000),\n+    q: str,\n+    item: Item = None,\n ):\n-    results = {\"item_id\": item_id, \"item\": item, \"user\": user, \"access_token\": access_token}\n+    results = {\"item_id\": item_id}\n     if q:\n         results.update({\"q\": q})\n+    if item:\n+        results.update({\"item\": item})\n     return results\n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Query, Path, Body\n+from fastapi import FastAPI, Query, Path\n from pydantic import BaseModel\n \n app = FastAPI()\n@@ -11,11 +11,17 @@ class Item(BaseModel):\n     tax: float = None\n \n \n+class User(BaseModel):\n+    username: str\n+    full_name: str = None\n+\n+\n @app.put(\"/items/{item_id}\")\n async def update_item(\n     *,\n     item_id: int,\n-    item: Item = Body(..., embed=True),\n+    item: Item,\n+    user: User,\n ):\n-    results = {\"item_id\": item_id, \"item\": item}\n+    results = {\"item_id\": item_id, \"item\": item, \"user\": user}\n     return results\n\n@@ -1,21 +1,28 @@\n from fastapi import FastAPI, Query, Path, Body\n-from pydantic import BaseModel, Schema\n+from pydantic import BaseModel\n \n app = FastAPI()\n \n \n class Item(BaseModel):\n     name: str\n-    description: str = Schema(None, title=\"The description of the item\", max_length=300)\n-    price: float = Schema(..., gt=0, description=\"The price must be greater than zero\")\n+    description: str = None\n+    price: float\n     tax: float = None\n \n \n+class User(BaseModel):\n+    username: str\n+    full_name: str = None\n+\n+\n @app.put(\"/items/{item_id}\")\n async def update_item(\n     *,\n     item_id: int,\n-    item: Item = Body(..., embed=True),\n+    item: Item,\n+    user: User,\n+    access_token: str = Body(...),\n ):\n-    results = {\"item_id\": item_id, \"item\": item}\n+    results = {\"item_id\": item_id, \"item\": item, \"user\": user, \"access_token\": access_token}\n     return results\n\n@@ -9,7 +9,11 @@ class Item(BaseModel):\n     description: str = None\n     price: float\n     tax: float = None\n-    tags: list = []\n+\n+\n+class User(BaseModel):\n+    username: str\n+    full_name: str = None\n \n \n @app.put(\"/items/{item_id}\")\n@@ -17,6 +21,11 @@ async def update_item(\n     *,\n     item_id: int,\n     item: Item,\n+    user: User,\n+    access_token: str = Body(...),\n+    q: str = None,\n ):\n-    results = {\"item_id\": item_id, \"item\": item}\n+    results = {\"item_id\": item_id, \"item\": item, \"user\": user, \"access_token\": access_token}\n+    if q:\n+        results.update({\"q\": q})\n     return results\n\n@@ -1,6 +1,5 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from fastapi import FastAPI, Query, Path, Body\n from pydantic import BaseModel\n-from typing import List\n \n app = FastAPI()\n \n@@ -10,14 +9,13 @@ class Item(BaseModel):\n     description: str = None\n     price: float\n     tax: float = None\n-    tags: List[str] = []\n \n \n @app.put(\"/items/{item_id}\")\n async def update_item(\n     *,\n     item_id: int,\n-    item: Item,\n+    item: Item = Body(..., embed=True),\n ):\n     results = {\"item_id\": item_id, \"item\": item}\n     return results\n\n@@ -1,23 +1,21 @@\n-from fastapi import Body, FastAPI, Path, Query\n-from pydantic import BaseModel\n-from typing import Set\n+from fastapi import FastAPI, Query, Path, Body\n+from pydantic import BaseModel, Schema\n \n app = FastAPI()\n \n \n class Item(BaseModel):\n     name: str\n-    description: str = None\n-    price: float\n+    description: str = Schema(None, title=\"The description of the item\", max_length=300)\n+    price: float = Schema(..., gt=0, description=\"The price must be greater than zero\")\n     tax: float = None\n-    tags: Set[str] = []\n \n \n @app.put(\"/items/{item_id}\")\n async def update_item(\n     *,\n     item_id: int,\n-    item: Item,\n+    item: Item = Body(..., embed=True),\n ):\n     results = {\"item_id\": item_id, \"item\": item}\n     return results\n\n@@ -1,22 +1,15 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from fastapi import FastAPI, Query, Path, Body\n from pydantic import BaseModel\n-from typing import Set\n \n app = FastAPI()\n \n \n-class Image(BaseModel):\n-    url: str\n-    name: str\n-\n-\n class Item(BaseModel):\n     name: str\n     description: str = None\n     price: float\n     tax: float = None\n-    tags: Set[str] = []\n-    image: Image = None\n+    tags: list = []\n \n \n @app.put(\"/items/{item_id}\")\n\n@@ -1,23 +1,16 @@\n from fastapi import Body, FastAPI, Path, Query\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from typing import Set\n+from typing import List\n \n app = FastAPI()\n \n \n-class Image(BaseModel):\n-    url: UrlStr\n-    name: str\n-\n-\n class Item(BaseModel):\n     name: str\n     description: str = None\n     price: float\n     tax: float = None\n-    tags: Set[str] = []\n-    image: Image = None\n+    tags: List[str] = []\n \n \n @app.put(\"/items/{item_id}\")\n\n@@ -1,23 +1,16 @@\n from fastapi import Body, FastAPI, Path, Query\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from typing import Set, List\n+from typing import Set\n \n app = FastAPI()\n \n \n-class Image(BaseModel):\n-    url: UrlStr\n-    name: str\n-\n-\n class Item(BaseModel):\n     name: str\n     description: str = None\n     price: float\n     tax: float = None\n     tags: Set[str] = []\n-    image: List[Image] = None\n \n \n @app.put(\"/items/{item_id}\")\n\n@@ -1,13 +1,12 @@\n from fastapi import Body, FastAPI, Path, Query\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from typing import Set, List\n+from typing import Set\n \n app = FastAPI()\n \n \n class Image(BaseModel):\n-    url: UrlStr\n+    url: str\n     name: str\n \n \n@@ -17,16 +16,14 @@ class Item(BaseModel):\n     price: float\n     tax: float = None\n     tags: Set[str] = []\n-    image: List[Image] = None\n+    image: Image = None\n \n \n-class Offer(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    items: List[Item]\n-\n-\n-@app.post(\"/offers/\")\n-async def create_offer(*, offer: Offer):\n-    return offer\n+@app.put(\"/items/{item_id}\")\n+async def update_item(\n+    *,\n+    item_id: int,\n+    item: Item,\n+):\n+    results = {\"item_id\": item_id, \"item\": item}\n+    return results\n\n@@ -1,7 +1,7 @@\n from fastapi import Body, FastAPI, Path, Query\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n-from typing import Set, List\n+from typing import Set\n \n app = FastAPI()\n \n@@ -11,6 +11,20 @@ class Image(BaseModel):\n     name: str\n \n \n-@app.post(\"/images/multiple/\")\n-async def create_multiple_images(*, images: List[Image]):\n-    return images\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+    tags: Set[str] = []\n+    image: Image = None\n+\n+\n+@app.put(\"/items/{item_id}\")\n+async def update_item(\n+    *,\n+    item_id: int,\n+    item: Item,\n+):\n+    results = {\"item_id\": item_id, \"item\": item}\n+    return results\n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Cookie\n+from fastapi import Body, FastAPI, Path, Query\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n from typing import Set, List\n@@ -6,6 +6,25 @@ from typing import Set, List\n app = FastAPI()\n \n \n-@app.get(\"/items/\")\n-async def read_items(*, ads_id: str = Cookie(None)):\n-    return {\"ads_id\": ads_id}\n+class Image(BaseModel):\n+    url: UrlStr\n+    name: str\n+\n+\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+    tags: Set[str] = []\n+    image: List[Image] = None\n+\n+\n+@app.put(\"/items/{item_id}\")\n+async def update_item(\n+    *,\n+    item_id: int,\n+    item: Item,\n+):\n+    results = {\"item_id\": item_id, \"item\": item}\n+    return results\n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Header\n+from fastapi import Body, FastAPI, Path, Query\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n from typing import Set, List\n@@ -6,6 +6,27 @@ from typing import Set, List\n app = FastAPI()\n \n \n-@app.get(\"/items/\")\n-async def read_items(*, accept_encoding: str = Header(None)):\n-    return {\"Accept-Encoding\": accept_encoding}\n+class Image(BaseModel):\n+    url: UrlStr\n+    name: str\n+\n+\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+    tags: Set[str] = []\n+    image: List[Image] = None\n+\n+\n+class Offer(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    items: List[Item]\n+\n+\n+@app.post(\"/offers/\")\n+async def create_offer(*, offer: Offer):\n+    return offer\n\n@@ -1,4 +1,4 @@\n-from fastapi import FastAPI, Header\n+from fastapi import Body, FastAPI, Path, Query\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n from typing import Set, List\n@@ -6,6 +6,11 @@ from typing import Set, List\n app = FastAPI()\n \n \n-@app.get(\"/items/\")\n-async def read_items(*, strange_header: str = Header(None, convert_underscores=False)):\n-    return {\"strange_header\": strange_header}\n+class Image(BaseModel):\n+    url: UrlStr\n+    name: str\n+\n+\n+@app.post(\"/images/multiple/\")\n+async def create_multiple_images(*, images: List[Image]):\n+    return images\n\n@@ -1,4 +1,4 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from fastapi import FastAPI, Cookie\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n from typing import Set, List\n@@ -6,14 +6,6 @@ from typing import Set, List\n app = FastAPI()\n \n \n-class Item(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    tax: float = None\n-    tags: Set[str] = []\n-\n-\n-@app.post(\"/items/\", response_model=Item)\n-async def create_item(*, item: Item):\n-    return item\n+@app.get(\"/items/\")\n+async def read_items(*, ads_id: str = Cookie(None)):\n+    return {\"ads_id\": ads_id}\n\n@@ -1,20 +1,11 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from fastapi import FastAPI, Header\n from pydantic import BaseModel\n-from pydantic.types import EmailStr\n+from pydantic.types import UrlStr\n from typing import Set, List\n \n app = FastAPI()\n \n \n-class UserIn(BaseModel):\n-    username: str\n-    password: str\n-    email: EmailStr\n-    full_name: str = None\n-    \n-\n-\n-# Don't do this in production!\n-@app.post(\"/user/\", response_model=UserIn)\n-async def create_user(*, user: UserIn):\n-    return user\n+@app.get(\"/items/\")\n+async def read_items(*, accept_encoding: str = Header(None)):\n+    return {\"Accept-Encoding\": accept_encoding}\n\n@@ -1,24 +1,11 @@\n-from fastapi import Body, FastAPI, Path, Query\n+from fastapi import FastAPI, Header\n from pydantic import BaseModel\n-from pydantic.types import EmailStr\n+from pydantic.types import UrlStr\n from typing import Set, List\n \n app = FastAPI()\n \n \n-class UserIn(BaseModel):\n-    username: str\n-    password: str\n-    email: EmailStr\n-    full_name: str = None\n-\n-\n-class UserOut(BaseModel):\n-    username: str\n-    email: EmailStr\n-    full_name: str = None\n-\n-\n-@app.post(\"/user/\", response_model=UserOut)\n-async def create_user(*, user: UserIn):\n-    return user\n+@app.get(\"/items/\")\n+async def read_items(*, strange_header: str = Header(None, convert_underscores=False)):\n+    return {\"strange_header\": strange_header}\n\n@@ -1,43 +1,19 @@\n from fastapi import Body, FastAPI, Path, Query\n from pydantic import BaseModel\n-from pydantic.types import EmailStr\n+from pydantic.types import UrlStr\n from typing import Set, List\n-from uuid import UUID, uuid4\n \n app = FastAPI()\n \n \n-class UserIn(BaseModel):\n-    username: str\n-    password: str\n-    email: EmailStr\n-    full_name: str = None\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+    tags: Set[str] = []\n \n \n-class UserOut(BaseModel):\n-    username: str\n-    email: EmailStr\n-    full_name: str = None\n-\n-\n-class UserInDB(BaseModel):\n-    username: str\n-    hashed_password: str\n-    email: EmailStr\n-    full_name: str = None\n-\n-\n-def fake_password_hasher(raw_password: str):\n-    return \"supersecret\" + raw_password\n-\n-\n-def fake_save_user(user_in: UserIn):\n-    hashed_password = fake_password_hasher(user_in.password)\n-    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)\n-    print(\"User saved! ..not really\")\n-    return user_in_db\n-\n-@app.post(\"/user/\", response_model=UserOut)\n-async def create_user(*, user_in: UserIn):\n-    user_saved = fake_save_user(user_in)\n-    return user_saved\n+@app.post(\"/items/\", response_model=Item)\n+async def create_item(*, item: Item):\n+    return item\n\n@@ -1,37 +0,0 @@\n-from fastapi import Body, FastAPI, Path, Query\n-from pydantic import BaseModel\n-from pydantic.types import EmailStr\n-from typing import Set, List\n-\n-app = FastAPI()\n-\n-class UserBase(BaseModel):\n-    username: str\n-    email: EmailStr\n-    full_name: str = None\n-\n-class UserIn(UserBase):\n-    password: str\n-\n-\n-class UserOut(UserBase):\n-    pass\n-\n-class UserInDB(UserBase):\n-    hashed_password: str\n-    \n-\n-def fake_password_hasher(raw_password: str):\n-    return \"supersecret\" + raw_password\n-\n-\n-def fake_save_user(user_in: UserIn):\n-    hashed_password = fake_password_hasher(user_in.password)\n-    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)\n-    print(\"User saved! ..not really\")\n-    return user_in_db\n-\n-@app.post(\"/user/\", response_model=UserOut)\n-async def create_user(*, user_in: UserIn):\n-    user_saved = fake_save_user(user_in)\n-    return user_saved\n\n@@ -1,11 +0,0 @@\n-from fastapi import Body, FastAPI, Path, Query, Form\n-from pydantic import BaseModel\n-from pydantic.types import EmailStr\n-from typing import Set, List\n-\n-app = FastAPI()\n-\n-\n-@app.post(\"/login/\")\n-async def login(*, username: str = Form(...), password: str = Form(...)):\n-    return {\"username\": username}\n\n@@ -1,11 +0,0 @@\n-from fastapi import Body, FastAPI, Path, Query, File\n-from pydantic import BaseModel\n-from pydantic.types import EmailStr\n-from typing import Set, List\n-\n-app = FastAPI()\n-\n-\n-@app.post(\"/files/\")\n-async def create_file(*, file: bytes = File(...)):\n-    return {\"file_size\": len(file)}\n\n@@ -1,11 +0,0 @@\n-from fastapi import Body, FastAPI, Path, Query, File, Form\n-from pydantic import BaseModel\n-from pydantic.types import EmailStr\n-from typing import Set, List\n-\n-app = FastAPI()\n-\n-\n-@app.post(\"/files/\")\n-async def create_file(*, file: bytes = File(...), token: str = Form(...)):\n-    return {\"file_size\": len(file), \"token\": token}\n\n@@ -0,0 +1,20 @@\n+from fastapi import Body, FastAPI, Path, Query\n+from pydantic import BaseModel\n+from pydantic.types import EmailStr\n+from typing import Set, List\n+\n+app = FastAPI()\n+\n+\n+class UserIn(BaseModel):\n+    username: str\n+    password: str\n+    email: EmailStr\n+    full_name: str = None\n+    \n+\n+\n+# Don't do this in production!\n+@app.post(\"/user/\", response_model=UserIn)\n+async def create_user(*, user: UserIn):\n+    return user\n\n@@ -1,20 +1,24 @@\n from fastapi import Body, FastAPI, Path, Query\n-from starlette.status import HTTP_201_CREATED\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n+from pydantic.types import EmailStr\n from typing import Set, List\n \n app = FastAPI()\n \n \n-class Item(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    tax: float = None\n-    tags: Set[str] = []\n+class UserIn(BaseModel):\n+    username: str\n+    password: str\n+    email: EmailStr\n+    full_name: str = None\n \n \n-@app.post(\"/items/\", response_model=Item, status_code=HTTP_201_CREATED)\n-async def create_item(*, item: Item):\n-    return item\n+class UserOut(BaseModel):\n+    username: str\n+    email: EmailStr\n+    full_name: str = None\n+\n+\n+@app.post(\"/user/\", response_model=UserOut)\n+async def create_user(*, user: UserIn):\n+    return user\n\n@@ -1,20 +1,43 @@\n from fastapi import Body, FastAPI, Path, Query\n-from starlette.status import HTTP_201_CREATED\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n+from pydantic.types import EmailStr\n from typing import Set, List\n+from uuid import UUID, uuid4\n \n app = FastAPI()\n \n \n-class Item(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    tax: float = None\n-    tags: Set[str] = []\n+class UserIn(BaseModel):\n+    username: str\n+    password: str\n+    email: EmailStr\n+    full_name: str = None\n \n \n-@app.post(\"/items/\", response_model=Item, tags=[\"items\"])\n-async def create_item(*, item: Item):\n-    return item\n+class UserOut(BaseModel):\n+    username: str\n+    email: EmailStr\n+    full_name: str = None\n+\n+\n+class UserInDB(BaseModel):\n+    username: str\n+    hashed_password: str\n+    email: EmailStr\n+    full_name: str = None\n+\n+\n+def fake_password_hasher(raw_password: str):\n+    return \"supersecret\" + raw_password\n+\n+\n+def fake_save_user(user_in: UserIn):\n+    hashed_password = fake_password_hasher(user_in.password)\n+    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)\n+    print(\"User saved! ..not really\")\n+    return user_in_db\n+\n+@app.post(\"/user/\", response_model=UserOut)\n+async def create_user(*, user_in: UserIn):\n+    user_saved = fake_save_user(user_in)\n+    return user_saved\n\n@@ -1,25 +1,37 @@\n from fastapi import Body, FastAPI, Path, Query\n-from starlette.status import HTTP_201_CREATED\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n+from pydantic.types import EmailStr\n from typing import Set, List\n \n app = FastAPI()\n \n+class UserBase(BaseModel):\n+    username: str\n+    email: EmailStr\n+    full_name: str = None\n \n-class Item(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    tax: float = None\n-    tags: Set[str] = []\n+class UserIn(UserBase):\n+    password: str\n \n \n-@app.post(\n-    \"/items/\",\n-    response_model=Item,\n-    summary=\"Create an item\",\n-    description=\"Create an item with all the information, name, description, price, tax and a set of unique tags\",\n-)\n-async def create_item(*, item: Item):\n-    return item\n+class UserOut(UserBase):\n+    pass\n+\n+class UserInDB(UserBase):\n+    hashed_password: str\n+    \n+\n+def fake_password_hasher(raw_password: str):\n+    return \"supersecret\" + raw_password\n+\n+\n+def fake_save_user(user_in: UserIn):\n+    hashed_password = fake_password_hasher(user_in.password)\n+    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)\n+    print(\"User saved! ..not really\")\n+    return user_in_db\n+\n+@app.post(\"/user/\", response_model=UserOut)\n+async def create_user(*, user_in: UserIn):\n+    user_saved = fake_save_user(user_in)\n+    return user_saved\n\n@@ -1,29 +1,11 @@\n-from fastapi import Body, FastAPI, Path, Query\n-from starlette.status import HTTP_201_CREATED\n+from fastapi import Body, FastAPI, Path, Query, Form\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n+from pydantic.types import EmailStr\n from typing import Set, List\n \n app = FastAPI()\n \n \n-class Item(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    tax: float = None\n-    tags: Set[str] = []\n-\n-\n-@app.post(\"/items/\", response_model=Item, summary=\"Create an item\")\n-async def create_item(*, item: Item):\n-    \"\"\"\n-    Create an item with all the information:\n-    \n-    * name: each item must have a name\n-    * description: a long description\n-    * price: required\n-    * tax: if the item doesn't have tax, you can omit this\n-    * tags: a set of unique tag strings for this item\n-    \"\"\"\n-    return item\n+@app.post(\"/login/\")\n+async def login(*, username: str = Form(...), password: str = Form(...)):\n+    return {\"username\": username}\n\n@@ -1,29 +1,11 @@\n-from fastapi import Body, FastAPI, Path, Query\n-from starlette.status import HTTP_201_CREATED\n+from fastapi import Body, FastAPI, Path, Query, File\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n+from pydantic.types import EmailStr\n from typing import Set, List\n \n app = FastAPI()\n \n \n-class Item(BaseModel):\n-    name: str\n-    description: str = None\n-    price: float\n-    tax: float = None\n-    tags: Set[str] = []\n-\n-\n-@app.post(\"/items/\", response_model=Item, summary=\"Create an item\", response_description=\"The created item\")\n-async def create_item(*, item: Item):\n-    \"\"\"\n-    Create an item with all the information:\n-    \n-    * name: each item must have a name\n-    * description: a long description\n-    * price: required\n-    * tax: if the item doesn't have tax, you can omit this\n-    * tags: a set of unique tag strings for this item\n-    \"\"\"\n-    return item\n+@app.post(\"/files/\")\n+async def create_file(*, file: bytes = File(...)):\n+    return {\"file_size\": len(file)}\n\n@@ -1,13 +1,11 @@\n-from typing import List, Set\n-\n-from fastapi import Body, FastAPI, Path, Query\n+from fastapi import Body, FastAPI, Path, Query, File, Form\n from pydantic import BaseModel\n-from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n+from pydantic.types import EmailStr\n+from typing import Set, List\n \n app = FastAPI()\n \n \n-@app.get(\"/items/\", deprecated=True)\n-async def read_items():\n-    return [{\"item_id\": \"Foo\"}]\n+@app.post(\"/files/\")\n+async def create_file(*, file: bytes = File(...), token: str = Form(...)):\n+    return {\"file_size\": len(file), \"token\": token}\n\n@@ -1,13 +1,20 @@\n-from typing import List, Set\n-\n from fastapi import Body, FastAPI, Path, Query\n+from starlette.status import HTTP_201_CREATED\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n+from typing import Set, List\n \n app = FastAPI()\n \n \n-@app.get(\"/items/\", operation_id=\"some_specific_id_you_define\")\n-async def read_items():\n-    return [{\"item_id\": \"Foo\"}]\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+    tags: Set[str] = []\n+\n+\n+@app.post(\"/items/\", response_model=Item, status_code=HTTP_201_CREATED)\n+async def create_item(*, item: Item):\n+    return item\n\n@@ -1,13 +1,20 @@\n-from typing import List, Set\n-\n from fastapi import Body, FastAPI, Path, Query\n+from starlette.status import HTTP_201_CREATED\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n+from typing import Set, List\n \n app = FastAPI()\n \n \n-@app.get(\"/items/\", include_in_schema=False)\n-async def read_items():\n-    return [{\"item_id\": \"Foo\"}]\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+    tags: Set[str] = []\n+\n+\n+@app.post(\"/items/\", response_model=Item, tags=[\"items\"])\n+async def create_item(*, item: Item):\n+    return item\n\n@@ -1,14 +1,25 @@\n-from typing import List, Set\n-\n from fastapi import Body, FastAPI, Path, Query\n+from starlette.status import HTTP_201_CREATED\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n-from starlette.responses import UJSONResponse\n+from typing import Set, List\n \n app = FastAPI()\n \n \n-@app.get(\"/items/\", content_type=UJSONResponse)\n-async def read_items():\n-    return [{\"item_id\": \"Foo\"}]\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+    tags: Set[str] = []\n+\n+\n+@app.post(\n+    \"/items/\",\n+    response_model=Item,\n+    summary=\"Create an item\",\n+    description=\"Create an item with all the information, name, description, price, tax and a set of unique tags\",\n+)\n+async def create_item(*, item: Item):\n+    return item\n\n@@ -1,23 +1,29 @@\n-from typing import List, Set\n-\n from fastapi import Body, FastAPI, Path, Query\n+from starlette.status import HTTP_201_CREATED\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n-from starlette.status import HTTP_201_CREATED\n-from starlette.responses import HTMLResponse\n+from typing import Set, List\n \n app = FastAPI()\n \n \n-@app.get(\"/items/\", content_type=HTMLResponse)\n-async def read_items():\n-    return \"\"\"\n-    <html>\n-        <head>\n-            <title>Some HTML in here</title>\n-        </head>\n-        <body>\n-            <h1>Look ma! HTML!</h1>\n-        </body>\n-    </html>\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+    tags: Set[str] = []\n+\n+\n+@app.post(\"/items/\", response_model=Item, summary=\"Create an item\")\n+async def create_item(*, item: Item):\n     \"\"\"\n+    Create an item with all the information:\n+    \n+    * name: each item must have a name\n+    * description: a long description\n+    * price: required\n+    * tax: if the item doesn't have tax, you can omit this\n+    * tags: a set of unique tag strings for this item\n+    \"\"\"\n+    return item\n\n@@ -0,0 +1,29 @@\n+from fastapi import Body, FastAPI, Path, Query\n+from starlette.status import HTTP_201_CREATED\n+from pydantic import BaseModel\n+from pydantic.types import UrlStr\n+from typing import Set, List\n+\n+app = FastAPI()\n+\n+\n+class Item(BaseModel):\n+    name: str\n+    description: str = None\n+    price: float\n+    tax: float = None\n+    tags: Set[str] = []\n+\n+\n+@app.post(\"/items/\", response_model=Item, summary=\"Create an item\", response_description=\"The created item\")\n+async def create_item(*, item: Item):\n+    \"\"\"\n+    Create an item with all the information:\n+    \n+    * name: each item must have a name\n+    * description: a long description\n+    * price: required\n+    * tax: if the item doesn't have tax, you can omit this\n+    * tags: a set of unique tag strings for this item\n+    \"\"\"\n+    return item\n\n@@ -1,59 +1,13 @@\n from typing import List, Set\n \n-from fastapi import Body, FastAPI, Path, Query, Depends, Cookie\n+from fastapi import Body, FastAPI, Path, Query\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n from starlette.status import HTTP_201_CREATED\n-from starlette.responses import HTMLResponse\n-from random import choice\n \n-from sqlalchemy import create_engine\n-from sqlalchemy.orm import scoped_session, sessionmaker\n-from sqlalchemy import Column, Integer, DateTime, String, Boolean, ForeignKey\n-from sqlalchemy.ext.declarative import declarative_base, declared_attr\n-\n-\n-# SQLAlchemy specific code, as with any other app\n-\n-\n-SQLALCHEMY_DATABASE_URI = \"postgresql://user:password@postgresserver/db\"\n-\n-# By creating this a CustomBase class and inheriting from it, your models will have\n-# automatic __tablename__ attributes. So you don't have to declare them.\n-# So, your models will behave very similarly to, for example, Flask-SQLAlchemy\n-\n-class CustomBase:\n-    # Generate __tablename__ automatically\n-    @declared_attr\n-    def __tablename__(cls):\n-        return cls.__name__.lower()\n-\n-\n-Base = declarative_base(cls=CustomBase)\n-\n-\n-class User(Base):\n-    # Own properties\n-    id = Column(Integer, primary_key=True, index=True)\n-    email = Column(String, unique=True, index=True)\n-    hashed_password = Column(String)\n-    is_active = Column(Boolean(), default=True)\n-\n-\n-engine = create_engine(SQLALCHEMY_DATABASE_URI, convert_unicode=True)\n-db_session = scoped_session(\n-    sessionmaker(autocommit=False, autoflush=False, bind=engine)\n-)\n-\n-\n-def get_user(username, db_session):\n-    return db_session.query(User).filter(User.id == username).first()\n-\n-# FastAPI specific code\n app = FastAPI()\n \n \n-@app.get(\"/users/{username}\")\n-def read_user(username: str):\n-    user = get_user(username, db_session)\n-    return user\n+@app.get(\"/items/\", deprecated=True)\n+async def read_items():\n+    return [{\"item_id\": \"Foo\"}]\n\n@@ -1,66 +1,13 @@\n from typing import List, Set\n \n-from fastapi import Body, FastAPI, Path, Query, Depends, Cookie\n+from fastapi import Body, FastAPI, Path, Query\n from pydantic import BaseModel\n from pydantic.types import UrlStr\n from starlette.status import HTTP_201_CREATED\n-from starlette.responses import HTMLResponse\n-from random import choice\n \n-from typing import List, Optional, Union\n-\n-from pydantic import BaseModel\n-\n-from app.models.config import USERPROFILE_DOC_TYPE\n-from app.models.role import RoleEnum\n-from couchbase.bucket import Bucket\n-from couchbase.cluster import Cluster, PasswordAuthenticator\n-from couchbase import LOCKMODE_WAIT\n-\n-\n-def get_bucket():\n-    cluster = Cluster(\"couchbase://couchbasehost:8091\")\n-    authenticator = PasswordAuthenticator(\"username\", \"password\")\n-    cluster.authenticate(authenticator)\n-    bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT)\n-    return bucket\n-\n-\n-class User(BaseModel):\n-    username: str\n-    email: Optional[str] = None\n-    full_name: Optional[str] = None\n-    disabled: Optional[bool] = None\n-\n-\n-class UserInDB(User):\n-    type: str = USERPROFILE_DOC_TYPE\n-    hashed_password: str\n-\n-    class Meta:\n-        key: Optional[str] = None\n-\n-\n-def get_user_doc_id(username):\n-    return f\"userprofile::{username}\"\n-\n-\n-def get_user(bucket: Bucket, username: str):\n-    doc_id = get_user_doc_id(username)\n-    result = bucket.get(doc_id, quiet=True)\n-    if not result.value:\n-        return None\n-    user = UserInDB(**result.value)\n-    user.Meta.key = result.key\n-    return user\n-\n-\n-# FastAPI specific code\n app = FastAPI()\n \n \n-@app.get(\"/users/{username}\")\n-def read_user(username: str):\n-    bucket = get_bucket()\n-    user = get_user(bucket=bucket, username=username)\n-    return user\n+@app.get(\"/items/\", operation_id=\"some_specific_id_you_define\")\n+async def read_items():\n+    return [{\"item_id\": \"Foo\"}]\n\n@@ -0,0 +1,13 @@\n+from typing import List, Set\n+\n+from fastapi import Body, FastAPI, Path, Query\n+from pydantic import BaseModel\n+from pydantic.types import UrlStr\n+from starlette.status import HTTP_201_CREATED\n+\n+app = FastAPI()\n+\n+\n+@app.get(\"/items/\", include_in_schema=False)\n+async def read_items():\n+    return [{\"item_id\": \"Foo\"}]\n\n@@ -0,0 +1,14 @@\n+from typing import List, Set\n+\n+from fastapi import Body, FastAPI, Path, Query\n+from pydantic import BaseModel\n+from pydantic.types import UrlStr\n+from starlette.status import HTTP_201_CREATED\n+from starlette.responses import UJSONResponse\n+\n+app = FastAPI()\n+\n+\n+@app.get(\"/items/\", content_type=UJSONResponse)\n+async def read_items():\n+    return [{\"item_id\": \"Foo\"}]\n\n@@ -0,0 +1,23 @@\n+from typing import List, Set\n+\n+from fastapi import Body, FastAPI, Path, Query\n+from pydantic import BaseModel\n+from pydantic.types import UrlStr\n+from starlette.status import HTTP_201_CREATED\n+from starlette.responses import HTMLResponse\n+\n+app = FastAPI()\n+\n+\n+@app.get(\"/items/\", content_type=HTMLResponse)\n+async def read_items():\n+    return \"\"\"\n+    <html>\n+        <head>\n+            <title>Some HTML in here</title>\n+        </head>\n+        <body>\n+            <h1>Look ma! HTML!</h1>\n+        </body>\n+    </html>\n+    \"\"\"\n\n\n\n\n@@ -0,0 +1,59 @@\n+from typing import List, Set\n+\n+from fastapi import Body, FastAPI, Path, Query, Depends, Cookie\n+from pydantic import BaseModel\n+from pydantic.types import UrlStr\n+from starlette.status import HTTP_201_CREATED\n+from starlette.responses import HTMLResponse\n+from random import choice\n+\n+from sqlalchemy import create_engine\n+from sqlalchemy.orm import scoped_session, sessionmaker\n+from sqlalchemy import Column, Integer, DateTime, String, Boolean, ForeignKey\n+from sqlalchemy.ext.declarative import declarative_base, declared_attr\n+\n+\n+# SQLAlchemy specific code, as with any other app\n+\n+\n+SQLALCHEMY_DATABASE_URI = \"postgresql://user:password@postgresserver/db\"\n+\n+# By creating this a CustomBase class and inheriting from it, your models will have\n+# automatic __tablename__ attributes. So you don't have to declare them.\n+# So, your models will behave very similarly to, for example, Flask-SQLAlchemy\n+\n+class CustomBase:\n+    # Generate __tablename__ automatically\n+    @declared_attr\n+    def __tablename__(cls):\n+        return cls.__name__.lower()\n+\n+\n+Base = declarative_base(cls=CustomBase)\n+\n+\n+class User(Base):\n+    # Own properties\n+    id = Column(Integer, primary_key=True, index=True)\n+    email = Column(String, unique=True, index=True)\n+    hashed_password = Column(String)\n+    is_active = Column(Boolean(), default=True)\n+\n+\n+engine = create_engine(SQLALCHEMY_DATABASE_URI, convert_unicode=True)\n+db_session = scoped_session(\n+    sessionmaker(autocommit=False, autoflush=False, bind=engine)\n+)\n+\n+\n+def get_user(username, db_session):\n+    return db_session.query(User).filter(User.id == username).first()\n+\n+# FastAPI specific code\n+app = FastAPI()\n+\n+\n+@app.get(\"/users/{username}\")\n+def read_user(username: str):\n+    user = get_user(username, db_session)\n+    return user\n\n@@ -0,0 +1,66 @@\n+from typing import List, Set\n+\n+from fastapi import Body, FastAPI, Path, Query, Depends, Cookie\n+from pydantic import BaseModel\n+from pydantic.types import UrlStr\n+from starlette.status import HTTP_201_CREATED\n+from starlette.responses import HTMLResponse\n+from random import choice\n+\n+from typing import List, Optional, Union\n+\n+from pydantic import BaseModel\n+\n+from app.models.config import USERPROFILE_DOC_TYPE\n+from app.models.role import RoleEnum\n+from couchbase.bucket import Bucket\n+from couchbase.cluster import Cluster, PasswordAuthenticator\n+from couchbase import LOCKMODE_WAIT\n+\n+\n+def get_bucket():\n+    cluster = Cluster(\"couchbase://couchbasehost:8091\")\n+    authenticator = PasswordAuthenticator(\"username\", \"password\")\n+    cluster.authenticate(authenticator)\n+    bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT)\n+    return bucket\n+\n+\n+class User(BaseModel):\n+    username: str\n+    email: Optional[str] = None\n+    full_name: Optional[str] = None\n+    disabled: Optional[bool] = None\n+\n+\n+class UserInDB(User):\n+    type: str = USERPROFILE_DOC_TYPE\n+    hashed_password: str\n+\n+    class Meta:\n+        key: Optional[str] = None\n+\n+\n+def get_user_doc_id(username):\n+    return f\"userprofile::{username}\"\n+\n+\n+def get_user(bucket: Bucket, username: str):\n+    doc_id = get_user_doc_id(username)\n+    result = bucket.get(doc_id, quiet=True)\n+    if not result.value:\n+        return None\n+    user = UserInDB(**result.value)\n+    user.Meta.key = result.key\n+    return user\n+\n+\n+# FastAPI specific code\n+app = FastAPI()\n+\n+\n+@app.get(\"/users/{username}\")\n+def read_user(username: str):\n+    bucket = get_bucket()\n+    user = get_user(bucket=bucket, username=username)\n+    return user\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
