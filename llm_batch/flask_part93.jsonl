{"custom_id": "flask#7029674775023c076a1dc03367214d178423809a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 208 | Lines Deleted: 169 | Files Changed: 3 | Hunks: 41 | Methods Changed: 10 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 377 | Churn Cumulative: 2392 | Contributors (this commit): 13 | Commits (past 90d): 15 | Contributors (cumulative): 19 | DMM Complexity: None\n\nDIFF:\n@@ -346,21 +346,6 @@ class Flask(Scaffold):\n     #: .. versionadded:: 0.8\n     session_interface = SecureCookieSessionInterface()\n \n-    # TODO remove the next three attrs when Sphinx :inherited-members: works\n-    # https://github.com/sphinx-doc/sphinx/issues/741\n-\n-    #: The name of the package or module that this app belongs to. Do not\n-    #: change this once it is set by the constructor.\n-    import_name = None\n-\n-    #: Location of the template files to be added to the template lookup.\n-    #: ``None`` if templates should not be added.\n-    template_folder = None\n-\n-    #: Absolute path to the package on the filesystem. Used to look up\n-    #: resources contained in the package.\n-    root_path = None\n-\n     def __init__(\n         self,\n         import_name,\n@@ -1017,58 +1002,6 @@ class Flask(Scaffold):\n         provide_automatic_options=None,\n         **options,\n     ):\n-        \"\"\"Connects a URL rule.  Works exactly like the :meth:`route`\n-        decorator.  If a view_func is provided it will be registered with the\n-        endpoint.\n-\n-        Basically this example::\n-\n-            @app.route('/')\n-            def index():\n-                pass\n-\n-        Is equivalent to the following::\n-\n-            def index():\n-                pass\n-            app.add_url_rule('/', 'index', index)\n-\n-        If the view_func is not provided you will need to connect the endpoint\n-        to a view function like so::\n-\n-            app.view_functions['index'] = index\n-\n-        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want\n-        to customize the behavior via subclassing you only need to change\n-        this method.\n-\n-        For more information refer to :ref:`url-route-registrations`.\n-\n-        .. versionchanged:: 0.2\n-           `view_func` parameter added.\n-\n-        .. versionchanged:: 0.6\n-           ``OPTIONS`` is added automatically as method.\n-\n-        :param rule: the URL rule as string\n-        :param endpoint: the endpoint for the registered URL rule.  Flask\n-                         itself assumes the name of the view function as\n-                         endpoint\n-        :param view_func: the function to call when serving a request to the\n-                          provided endpoint\n-        :param provide_automatic_options: controls whether the ``OPTIONS``\n-            method should be added automatically. This can also be controlled\n-            by setting the ``view_func.provide_automatic_options = False``\n-            before adding the rule.\n-        :param options: the options to be forwarded to the underlying\n-                        :class:`~werkzeug.routing.Rule` object.  A change\n-                        to Werkzeug is handling of method options.  methods\n-                        is a list of methods this rule should be limited\n-                        to (``GET``, ``POST`` etc.).  By default a rule\n-                        just listens for ``GET`` (and implicitly ``HEAD``).\n-                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n-                        added and handled by the standard request handling.\n-        \"\"\"\n         if endpoint is None:\n             endpoint = _endpoint_from_view_func(view_func)\n         options[\"endpoint\"] = endpoint\n@@ -2023,6 +1956,7 @@ class Flask(Scaffold):\n \n     def __call__(self, environ, start_response):\n         \"\"\"The WSGI server calls the Flask application object as the\n-        WSGI application. This calls :meth:`wsgi_app` which can be\n-        wrapped to applying middleware.\"\"\"\n+        WSGI application. This calls :meth:`wsgi_app`, which can be\n+        wrapped to apply middleware.\n+        \"\"\"\n         return self.wsgi_app(environ, start_response)\n\n@@ -130,28 +130,13 @@ class Blueprint(Scaffold):\n     warn_on_modifications = False\n     _got_registered_once = False\n \n-    #: Blueprint local JSON encoder class to use.\n-    #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_encoder`.\n+    #: Blueprint local JSON encoder class to use. Set to ``None`` to use\n+    #: the app's :class:`~flask.Flask.json_encoder`.\n     json_encoder = None\n-    #: Blueprint local JSON decoder class to use.\n-    #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_decoder`.\n+    #: Blueprint local JSON decoder class to use. Set to ``None`` to use\n+    #: the app's :class:`~flask.Flask.json_decoder`.\n     json_decoder = None\n \n-    # TODO remove the next three attrs when Sphinx :inherited-members: works\n-    # https://github.com/sphinx-doc/sphinx/issues/741\n-\n-    #: The name of the package or module that this app belongs to. Do not\n-    #: change this once it is set by the constructor.\n-    import_name = None\n-\n-    #: Location of the template files to be added to the template lookup.\n-    #: ``None`` if templates should not be added.\n-    template_folder = None\n-\n-    #: Absolute path to the package on the filesystem. Used to look up\n-    #: resources contained in the package.\n-    root_path = None\n-\n     def __init__(\n         self,\n         name,\n\n@@ -1,3 +1,4 @@\n+import importlib.util\n import os\n import pkgutil\n import sys\n@@ -41,26 +42,39 @@ def setupmethod(f):\n \n \n class Scaffold:\n-    \"\"\"A common base for :class:`~flask.app.Flask` and\n+    \"\"\"Common behavior shared between :class:`~flask.Flask` and\n     :class:`~flask.blueprints.Blueprint`.\n+\n+    :param import_name: The import name of the module where this object\n+        is defined. Usually :attr:`__name__` should be used.\n+    :param static_folder: Path to a folder of static files to serve.\n+        If this is set, a static route will be added.\n+    :param static_url_path: URL prefix for the static route.\n+    :param template_folder: Path to a folder containing template files.\n+        for rendering. If this is set, a Jinja loader will be added.\n+    :param root_path: The path that static, template, and resource files\n+        are relative to. Typically not set, it is discovered based on\n+        the ``import_name``.\n+\n+    .. versionadded:: 2.0.0\n     \"\"\"\n \n     name: str\n     _static_folder = None\n     _static_url_path = None\n \n-    #: Skeleton local JSON decoder class to use.\n-    #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_encoder`.\n+    #: JSON encoder class used by :func:`flask.json.dumps`. If a\n+    #: blueprint sets this, it will be used instead of the app's value.\n     json_encoder = None\n \n-    #: Skeleton local JSON decoder class to use.\n-    #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_decoder`.\n+    #: JSON decoder class used by :func:`flask.json.loads`. If a\n+    #: blueprint sets this, it will be used instead of the app's value.\n     json_decoder = None\n \n     def __init__(\n         self,\n         import_name,\n-        static_folder=\"static\",\n+        static_folder=None,\n         static_url_path=None,\n         template_folder=None,\n         root_path=None,\n@@ -90,79 +104,105 @@ class Scaffold:\n         #: been registered.\n         self.cli = AppGroup()\n \n-        #: A dictionary of all view functions registered.  The keys will\n-        #: be function names which are also used to generate URLs and\n-        #: the values are the function objects themselves.\n+        #: A dictionary mapping endpoint names to view functions.\n+        #:\n         #: To register a view function, use the :meth:`route` decorator.\n+        #:\n+        #: This data structure is internal. It should not be modified\n+        #: directly and its format may change at any time.\n         self.view_functions = {}\n \n-        #: A dictionary of all registered error handlers.  The key is ``None``\n-        #: for error handlers active on the application, otherwise the key is\n-        #: the name of the blueprint.  Each key points to another dictionary\n-        #: where the key is the status code of the http exception.  The\n-        #: special key ``None`` points to a list of tuples where the first item\n-        #: is the class for the instance check and the second the error handler\n-        #: function.\n+        #: A data structure of registered error handlers, in the format\n+        #: ``{scope: {code: {class: handler}}}```. The ``scope`` key is\n+        #: the name of a blueprint the handlers are active for, or\n+        #: ``None`` for all requests. The ``code`` key is the HTTP\n+        #: status code for ``HTTPException``, or ``None`` for\n+        #: other exceptions. The innermost dictionary maps exception\n+        #: classes to handler functions.\n         #:\n         #: To register an error handler, use the :meth:`errorhandler`\n         #: decorator.\n+        #:\n+        #: This data structure is internal. It should not be modified\n+        #: directly and its format may change at any time.\n         self.error_handler_spec = defaultdict(lambda: defaultdict(dict))\n \n-        #: A dictionary with lists of functions that will be called at the\n-        #: beginning of each request. The key of the dictionary is the name of\n-        #: the blueprint this function is active for, or ``None`` for all\n-        #: requests. To register a function, use the :meth:`before_request`\n+        #: A data structure of functions to call at the beginning of\n+        #: each request, in the format ``{scope: [functions]}``. The\n+        #: ``scope`` key is the name of a blueprint the functions are\n+        #: active for, or ``None`` for all requests.\n+        #:\n+        #: To register a function, use the :meth:`before_request`\n         #: decorator.\n+        #:\n+        #: This data structure is internal. It should not be modified\n+        #: directly and its format may change at any time.\n         self.before_request_funcs = defaultdict(list)\n \n-        #: A dictionary with lists of functions that should be called after\n-        #: each request.  The key of the dictionary is the name of the blueprint\n-        #: this function is active for, ``None`` for all requests.  This can for\n-        #: example be used to close database connections. To register a function\n-        #: here, use the :meth:`after_request` decorator.\n+        #: A data structure of functions to call at the end of each\n+        #: request, in the format ``{scope: [functions]}``. The\n+        #: ``scope`` key is the name of a blueprint the functions are\n+        #: active for, or ``None`` for all requests.\n+        #:\n+        #: To register a function, use the :meth:`after_request`\n+        #: decorator.\n+        #:\n+        #: This data structure is internal. It should not be modified\n+        #: directly and its format may change at any time.\n         self.after_request_funcs = defaultdict(list)\n \n-        #: A dictionary with lists of functions that are called after\n-        #: each request, even if an exception has occurred. The key of the\n-        #: dictionary is the name of the blueprint this function is active for,\n-        #: ``None`` for all requests. These functions are not allowed to modify\n-        #: the request, and their return values are ignored. If an exception\n-        #: occurred while processing the request, it gets passed to each\n-        #: teardown_request function. To register a function here, use the\n-        #: :meth:`teardown_request` decorator.\n+        #: A data structure of functions to call at the end of each\n+        #: request even if an exception is raised, in the format\n+        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n+        #: blueprint the functions are active for, or ``None`` for all\n+        #: requests.\n         #:\n-        #: .. versionadded:: 0.7\n+        #: To register a function, use the :meth:`teardown_request`\n+        #: decorator.\n+        #:\n+        #: This data structure is internal. It should not be modified\n+        #: directly and its format may change at any time.\n         self.teardown_request_funcs = defaultdict(list)\n \n-        #: A dictionary with list of functions that are called without argument\n-        #: to populate the template context.  The key of the dictionary is the\n-        #: name of the blueprint this function is active for, ``None`` for all\n-        #: requests.  Each returns a dictionary that the template context is\n-        #: updated with.  To register a function here, use the\n-        #: :meth:`context_processor` decorator.\n+        #: A data structure of functions to call to pass extra context\n+        #: values when rendering templates, in the format\n+        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n+        #: blueprint the functions are active for, or ``None`` for all\n+        #: requests.\n+        #:\n+        #: To register a function, use the :meth:`context_processor`\n+        #: decorator.\n+        #:\n+        #: This data structure is internal. It should not be modified\n+        #: directly and its format may change at any time.\n         self.template_context_processors = defaultdict(\n             list, {None: [_default_template_ctx_processor]}\n         )\n \n-        #: A dictionary with lists of functions that are called before the\n-        #: :attr:`before_request_funcs` functions. The key of the dictionary is\n-        #: the name of the blueprint this function is active for, or ``None``\n-        #: for all requests. To register a function, use\n-        #: :meth:`url_value_preprocessor`.\n+        #: A data structure of functions to call to modify the keyword\n+        #: arguments passed to the view function, in the format\n+        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n+        #: blueprint the functions are active for, or ``None`` for all\n+        #: requests.\n         #:\n-        #: .. versionadded:: 0.7\n+        #: To register a function, use the\n+        #: :meth:`url_value_preprocessor` decorator.\n+        #:\n+        #: This data structure is internal. It should not be modified\n+        #: directly and its format may change at any time.\n         self.url_value_preprocessors = defaultdict(list)\n \n-        #: A dictionary with lists of functions that can be used as URL value\n-        #: preprocessors.  The key ``None`` here is used for application wide\n-        #: callbacks, otherwise the key is the name of the blueprint.\n-        #: Each of these functions has the chance to modify the dictionary\n-        #: of URL values before they are used as the keyword arguments of the\n-        #: view function.  For each function registered this one should also\n-        #: provide a :meth:`url_defaults` function that adds the parameters\n-        #: automatically again that were removed that way.\n+        #: A data structure of functions to call to modify the keyword\n+        #: arguments when generating URLs, in the format\n+        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n+        #: blueprint the functions are active for, or ``None`` for all\n+        #: requests.\n         #:\n-        #: .. versionadded:: 0.7\n+        #: To register a function, use the :meth:`url_defaults`\n+        #: decorator.\n+        #:\n+        #: This data structure is internal. It should not be modified\n+        #: directly and its format may change at any time.\n         self.url_default_functions = defaultdict(list)\n \n     def __repr__(self):\n@@ -328,19 +368,26 @@ class Scaffold:\n         return self._method_route(\"PATCH\", rule, options)\n \n     def route(self, rule, **options):\n-        \"\"\"A decorator that is used to register a view function for a\n-        given URL rule. This does the same thing as :meth:`add_url_rule`\n-        but is used as a decorator. See :meth:`add_url_rule` and\n-        :ref:`url-route-registrations` for more information.\n+        \"\"\"Decorate a view function to register it with the given URL\n+        rule and options. Calls :meth:`add_url_rule`, which has more\n+        details about the implementation.\n \n         .. code-block:: python\n \n             @app.route(\"/\")\n             def index():\n-                return \"Hello World\"\n+                return \"Hello, World!\"\n \n-        :param rule: The URL rule as a string.\n-        :param options: The options to be forwarded to the underlying\n+        See :ref:`url-route-registrations`.\n+\n+        The endpoint name for the route defaults to the name of the view\n+        function if the ``endpoint`` parameter isn't passed.\n+\n+        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and\n+        ``OPTIONS`` are added automatically.\n+\n+        :param rule: The URL rule string.\n+        :param options: Extra options passed to the\n             :class:`~werkzeug.routing.Rule` object.\n         \"\"\"\n \n@@ -360,17 +407,80 @@ class Scaffold:\n         provide_automatic_options=None,\n         **options,\n     ):\n+        \"\"\"Register a rule for routing incoming requests and building\n+        URLs. The :meth:`route` decorator is a shortcut to call this\n+        with the ``view_func`` argument. These are equivalent:\n+\n+        .. code-block:: python\n+\n+            @app.route(\"/\")\n+            def index():\n+                ...\n+\n+        .. code-block:: python\n+\n+            def index():\n+                ...\n+\n+            app.add_url_rule(\"/\", view_func=index)\n+\n+        See :ref:`url-route-registrations`.\n+\n+        The endpoint name for the route defaults to the name of the view\n+        function if the ``endpoint`` parameter isn't passed. An error\n+        will be raised if a function has already been registered for the\n+        endpoint.\n+\n+        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` is\n+        always added automatically, and ``OPTIONS`` is added\n+        automatically by default.\n+\n+        ``view_func`` does not necessarily need to be passed, but if the\n+        rule should participate in routing an endpoint name must be\n+        associated with a view function at some point with the\n+        :meth:`endpoint` decorator.\n+\n+        .. code-block:: python\n+\n+            app.add_url_rule(\"/\", endpoint=\"index\")\n+\n+            @app.endpoint(\"index\")\n+            def index():\n+                ...\n+\n+        If ``view_func`` has a ``required_methods`` attribute, those\n+        methods are added to the passed and automatic methods. If it\n+        has a ``provide_automatic_methods`` attribute, it is used as the\n+        default if the parameter is not passed.\n+\n+        :param rule: The URL rule string.\n+        :param endpoint: The endpoint name to associate with the rule\n+            and view function. Used when routing and building URLs.\n+            Defaults to ``view_func.__name__``.\n+        :param view_func: The view function to associate with the\n+            endpoint name.\n+        :param provide_automatic_options: Add the ``OPTIONS`` method and\n+            respond to ``OPTIONS`` requests automatically.\n+        :param options: Extra options passed to the\n+            :class:`~werkzeug.routing.Rule` object.\n+        \"\"\"\n         raise NotImplementedError\n \n     def endpoint(self, endpoint):\n-        \"\"\"A decorator to register a function as an endpoint.\n-        Example::\n+        \"\"\"Decorate a view function to register it for the given\n+        endpoint. Used if a rule is added without a ``view_func`` with\n+        :meth:`add_url_rule`.\n \n-            @app.endpoint('example.endpoint')\n+        .. code-block:: python\n+\n+            app.add_url_rule(\"/ex\", endpoint=\"example\")\n+\n+            @app.endpoint(\"example\")\n             def example():\n-                return \"example\"\n+                ...\n \n-        :param endpoint: the name of the endpoint\n+        :param endpoint: The endpoint name to associate with the view\n+            function.\n         \"\"\"\n \n         def decorator(f):\n@@ -381,28 +491,38 @@ class Scaffold:\n \n     @setupmethod\n     def before_request(self, f):\n-        \"\"\"Registers a function to run before each request.\n+        \"\"\"Register a function to run before each request.\n \n-        For example, this can be used to open a database connection, or to load\n-        the logged in user from the session.\n+        For example, this can be used to open a database connection, or\n+        to load the logged in user from the session.\n \n-        The function will be called without any arguments. If it returns a\n-        non-None value, the value is handled as if it was the return value from\n-        the view, and further request handling is stopped.\n+        .. code-block:: python\n+\n+            @app.before_request\n+            def load_user():\n+                if \"user_id\" in session:\n+                    g.user = db.session.get(session[\"user_id\"])\n+\n+        The function will be called without any arguments. If it returns\n+        a non-``None`` value, the value is handled as if it was the\n+        return value from the view, and further request handling is\n+        stopped.\n         \"\"\"\n         self.before_request_funcs[None].append(f)\n         return f\n \n     @setupmethod\n     def after_request(self, f):\n-        \"\"\"Register a function to be run after each request.\n+        \"\"\"Register a function to run after each request to this object.\n \n-        Your function must take one parameter, an instance of\n-        :attr:`response_class` and return a new response object or the\n-        same (see :meth:`process_response`).\n+        The function is called with the response object, and must return\n+        a response object. This allows the functions to modify or\n+        replace the response before it is sent.\n \n-        As of Flask 0.7 this function might not be executed at the end of the\n-        request in case an unhandled exception occurred.\n+        If a function raises an exception, any remaining\n+        ``after_request`` functions will not be called. Therefore, this\n+        should not be used for actions that must execute, such as to\n+        close resources. Use :meth:`teardown_request` for that.\n         \"\"\"\n         self.after_request_funcs[None].append(f)\n         return f\n@@ -426,8 +546,8 @@ class Scaffold:\n         stack of active contexts.  This becomes relevant if you are using\n         such constructs in tests.\n \n-        Generally teardown functions must take every necessary step to avoid\n-        that they will fail.  If they do execute code that might fail they\n+        Teardown functions must avoid raising exceptions, since they . If they\n+        execute code that might fail they\n         will have to surround the execution of these code by try/except\n         statements and log occurring errors.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#25ab05e6a2ae248ab76002807d47c23952492f17", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 1010 | Contributors (this commit): 11 | Commits (past 90d): 10 | Contributors (cumulative): 11 | DMM Complexity: None\n\nDIFF:\n@@ -1350,12 +1350,6 @@ class Flask(Scaffold):\n         always receive the ``InternalServerError``. The original\n         unhandled exception is available as ``e.original_exception``.\n \n-        .. note::\n-            Prior to Werkzeug 1.0.0, ``InternalServerError`` will not\n-            always have an ``original_exception`` attribute. Use\n-            ``getattr(e, \"original_exception\", None)`` to simulate the\n-            behavior for compatibility.\n-\n         .. versionchanged:: 1.1.0\n             Always passes the ``InternalServerError`` instance to the\n             handler, setting ``original_exception`` to the unhandled\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ef52e3e4a379b16a8b906ff101c6edae71d80dc9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 11 | Files Changed: 1 | Hunks: 3 | Methods Changed: 4 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 13 | Churn Cumulative: 1165 | Contributors (this commit): 3 | Commits (past 90d): 5 | Contributors (cumulative): 3 | DMM Complexity: 0.0\n\nDIFF:\n@@ -630,7 +630,7 @@ class Scaffold:\n         \"\"\"\n \n         def decorator(f):\n-            self._register_error_handler(None, code_or_exception, f)\n+            self.register_error_handler(code_or_exception, f)\n             return f\n \n         return decorator\n@@ -643,15 +643,6 @@ class Scaffold:\n \n         .. versionadded:: 0.7\n         \"\"\"\n-        self._register_error_handler(None, code_or_exception, f)\n-\n-    @setupmethod\n-    def _register_error_handler(self, key, code_or_exception, f):\n-        \"\"\"\n-        :type key: None|str\n-        :type code_or_exception: int|T<=Exception\n-        :type f: callable\n-        \"\"\"\n         if isinstance(code_or_exception, HTTPException):  # old broken behavior\n             raise ValueError(\n                 \"Tried to register a handler for an exception instance\"\n@@ -668,7 +659,7 @@ class Scaffold:\n                 \" instead.\"\n             )\n \n-        self.error_handler_spec[key][code][exc_class] = f\n+        self.error_handler_spec[None][code][exc_class] = f\n \n     @staticmethod\n     def _get_exc_class_and_code(exc_class_or_code):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#3dfc12e8d82a66c4041783fcaec58a7a24dbe348", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 41 | Lines Deleted: 46 | Files Changed: 1 | Hunks: 13 | Methods Changed: 7 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 87 | Churn Cumulative: 323 | Contributors (this commit): 5 | Commits (past 90d): 3 | Contributors (cumulative): 5 | DMM Complexity: 1.0\n\nDIFF:\n@@ -90,13 +90,6 @@ class Blueprint(Scaffold):\n \n     See :doc:`/blueprints` for more information.\n \n-    .. versionchanged:: 1.1.0\n-        Blueprints have a ``cli`` group to register nested CLI commands.\n-        The ``cli_group`` parameter controls the name of the group under\n-        the ``flask`` command.\n-\n-    .. versionadded:: 0.7\n-\n     :param name: The name of the blueprint. Will be prepended to each\n         endpoint name.\n     :param import_name: The name of the blueprint package, usually\n@@ -121,10 +114,17 @@ class Blueprint(Scaffold):\n         default.\n     :param url_defaults: A dict of default values that blueprint routes\n         will receive by default.\n-    :param root_path: By default, the blueprint will automatically set this\n-        based on ``import_name``. In certain situations this automatic\n-        detection can fail, so the path can be specified manually\n-        instead.\n+    :param root_path: By default, the blueprint will automatically set\n+        this based on ``import_name``. In certain situations this\n+        automatic detection can fail, so the path can be specified\n+        manually instead.\n+\n+    .. versionchanged:: 1.1.0\n+        Blueprints have a ``cli`` group to register nested CLI commands.\n+        The ``cli_group`` parameter controls the name of the group under\n+        the ``flask`` command.\n+\n+    .. versionadded:: 0.7\n     \"\"\"\n \n     warn_on_modifications = False\n@@ -161,8 +161,10 @@ class Blueprint(Scaffold):\n         self.url_prefix = url_prefix\n         self.subdomain = subdomain\n         self.deferred_functions = []\n+\n         if url_defaults is None:\n             url_defaults = {}\n+\n         self.url_values_defaults = url_defaults\n         self.cli_group = cli_group\n \n@@ -180,9 +182,9 @@ class Blueprint(Scaffold):\n \n             warn(\n                 Warning(\n-                    \"The blueprint was already registered once \"\n-                    \"but is getting modified now.  These changes \"\n-                    \"will not show up.\"\n+                    \"The blueprint was already registered once but is\"\n+                    \" getting modified now. These changes will not show\"\n+                    \" up.\"\n                 )\n             )\n         self.deferred_functions.append(func)\n@@ -208,12 +210,13 @@ class Blueprint(Scaffold):\n         return BlueprintSetupState(self, app, options, first_registration)\n \n     def register(self, app, options, first_registration=False):\n-        \"\"\"Called by :meth:`Flask.register_blueprint` to register all views\n-        and callbacks registered on the blueprint with the application. Creates\n-        a :class:`.BlueprintSetupState` and calls each :meth:`record` callback\n-        with it.\n+        \"\"\"Called by :meth:`Flask.register_blueprint` to register all\n+        views and callbacks registered on the blueprint with the\n+        application. Creates a :class:`.BlueprintSetupState` and calls\n+        each :meth:`record` callbackwith it.\n \n-        :param app: The application this blueprint is being registered with.\n+        :param app: The application this blueprint is being registered\n+            with.\n         :param options: Keyword arguments forwarded from\n             :meth:`~Flask.register_blueprint`.\n         :param first_registration: Whether this is the first time this\n@@ -229,44 +232,36 @@ class Blueprint(Scaffold):\n                 endpoint=\"static\",\n             )\n \n-        # Merge app and self dictionaries.\n-        def merge_dict_lists(self_dict, app_dict):\n-            \"\"\"Merges self_dict into app_dict. Replaces None keys with self.name.\n-            Values of dict must be lists.\n-            \"\"\"\n-            for key, values in self_dict.items():\n-                key = self.name if key is None else f\"{self.name}.{key}\"\n-                app_dict[key].extend(values)\n+        # Merge blueprint data into parent.\n+        if first_registration:\n \n-        def merge_dict_nested(self_dict, app_dict):\n-            \"\"\"Merges self_dict into app_dict. Replaces None keys with self.name.\n-            Values of dict must be dict.\n-            \"\"\"\n-            for key, value in self_dict.items():\n+            def extend(bp_dict, parent_dict):\n+                for key, values in bp_dict.items():\n                     key = self.name if key is None else f\"{self.name}.{key}\"\n-                app_dict[key] = value\n+                    parent_dict[key].extend(values)\n+\n+            def update(bp_dict, parent_dict):\n+                for key, value in bp_dict.items():\n+                    key = self.name if key is None else f\"{self.name}.{key}\"\n+                    parent_dict[key] = value\n \n             app.view_functions.update(self.view_functions)\n-\n-        merge_dict_lists(self.before_request_funcs, app.before_request_funcs)\n-        merge_dict_lists(self.after_request_funcs, app.after_request_funcs)\n-        merge_dict_lists(self.teardown_request_funcs, app.teardown_request_funcs)\n-        merge_dict_lists(self.url_default_functions, app.url_default_functions)\n-        merge_dict_lists(self.url_value_preprocessors, app.url_value_preprocessors)\n-        merge_dict_lists(\n-            self.template_context_processors, app.template_context_processors\n-        )\n-\n-        merge_dict_nested(self.error_handler_spec, app.error_handler_spec)\n+            extend(self.before_request_funcs, app.before_request_funcs)\n+            extend(self.after_request_funcs, app.after_request_funcs)\n+            extend(self.teardown_request_funcs, app.teardown_request_funcs)\n+            extend(self.url_default_functions, app.url_default_functions)\n+            extend(self.url_value_preprocessors, app.url_value_preprocessors)\n+            extend(self.template_context_processors, app.template_context_processors)\n+            update(self.error_handler_spec, app.error_handler_spec)\n \n         for deferred in self.deferred_functions:\n             deferred(state)\n \n-        cli_resolved_group = options.get(\"cli_group\", self.cli_group)\n-\n         if not self.cli.commands:\n             return\n \n+        cli_resolved_group = options.get(\"cli_group\", self.cli_group)\n+\n         if cli_resolved_group is None:\n             app.cli.commands.update(self.cli.commands)\n         elif cli_resolved_group is _sentinel:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#6979265fa643ed982d062f38d386c37bbbef0d9b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 101 | Lines Deleted: 9 | Files Changed: 5 | Hunks: 15 | Methods Changed: 17 | Complexity Δ (Sum/Max): 12/6 | Churn Δ: 110 | Churn Cumulative: 4187 | Contributors (this commit): 42 | Commits (past 90d): 37 | Contributors (cumulative): 54 | DMM Complexity: 1.0\n\nDIFF:\n@@ -9,5 +9,8 @@ setup(\n         \"itsdangerous>=0.24\",\n         \"click>=5.1\",\n     ],\n-    extras_require={\"dotenv\": [\"python-dotenv\"]},\n+    extras_require={\n+        \"async\": [\"asgiref>=3.2\"],\n+        \"dotenv\": [\"python-dotenv\"],\n+    },\n )\n\n@@ -1050,7 +1050,7 @@ class Flask(Scaffold):\n                     \"View function mapping is overwriting an existing\"\n                     f\" endpoint function: {endpoint}\"\n                 )\n-            self.view_functions[endpoint] = view_func\n+            self.view_functions[endpoint] = self.ensure_sync(view_func)\n \n     @setupmethod\n     def template_filter(self, name=None):\n@@ -1165,7 +1165,7 @@ class Flask(Scaffold):\n \n         .. versionadded:: 0.8\n         \"\"\"\n-        self.before_first_request_funcs.append(f)\n+        self.before_first_request_funcs.append(self.ensure_sync(f))\n         return f\n \n     @setupmethod\n@@ -1198,7 +1198,7 @@ class Flask(Scaffold):\n \n         .. versionadded:: 0.9\n         \"\"\"\n-        self.teardown_appcontext_funcs.append(f)\n+        self.teardown_appcontext_funcs.append(self.ensure_sync(f))\n         return f\n \n     @setupmethod\n\n@@ -2,6 +2,7 @@ import os\n import socket\n import warnings\n from functools import update_wrapper\n+from functools import wraps\n from threading import RLock\n \n import werkzeug.utils\n@@ -729,3 +730,43 @@ def is_ip(value):\n             return True\n \n     return False\n+\n+\n+def run_async(func):\n+    \"\"\"Return a sync function that will run the coroutine function *func*.\"\"\"\n+    try:\n+        from asgiref.sync import async_to_sync\n+    except ImportError:\n+        raise RuntimeError(\n+            \"Install Flask with the 'async' extra in order to use async views.\"\n+        )\n+\n+    @wraps(func)\n+    def outer(*args, **kwargs):\n+        \"\"\"This function grabs the current context for the inner function.\n+\n+        This is similar to the copy_current_xxx_context functions in the\n+        ctx module, except it has an async inner.\n+        \"\"\"\n+        ctx = None\n+        if _request_ctx_stack.top is not None:\n+            ctx = _request_ctx_stack.top.copy()\n+\n+        @wraps(func)\n+        async def inner(*a, **k):\n+            \"\"\"This restores the context before awaiting the func.\n+\n+            This is required as the func must be awaited within the\n+            context. Simply calling func (as per the\n+            copy_current_xxx_context functions) doesn't work as the\n+            with block will close before the coroutine is awaited.\n+            \"\"\"\n+            if ctx is not None:\n+                with ctx:\n+                    return await func(*a, **k)\n+            else:\n+                return await func(*a, **k)\n+\n+        return async_to_sync(inner)(*args, **kwargs)\n+\n+    return outer\n\n@@ -4,6 +4,7 @@ import pkgutil\n import sys\n from collections import defaultdict\n from functools import update_wrapper\n+from inspect import iscoroutinefunction\n \n from jinja2 import FileSystemLoader\n from werkzeug.exceptions import default_exceptions\n@@ -12,6 +13,7 @@ from werkzeug.exceptions import HTTPException\n from .cli import AppGroup\n from .globals import current_app\n from .helpers import locked_cached_property\n+from .helpers import run_async\n from .helpers import send_from_directory\n from .templating import _default_template_ctx_processor\n \n@@ -484,7 +486,7 @@ class Scaffold:\n         \"\"\"\n \n         def decorator(f):\n-            self.view_functions[endpoint] = f\n+            self.view_functions[endpoint] = self.ensure_sync(f)\n             return f\n \n         return decorator\n@@ -508,7 +510,7 @@ class Scaffold:\n         return value from the view, and further request handling is\n         stopped.\n         \"\"\"\n-        self.before_request_funcs[None].append(f)\n+        self.before_request_funcs.setdefault(None, []).append(self.ensure_sync(f))\n         return f\n \n     @setupmethod\n@@ -524,7 +526,7 @@ class Scaffold:\n         should not be used for actions that must execute, such as to\n         close resources. Use :meth:`teardown_request` for that.\n         \"\"\"\n-        self.after_request_funcs[None].append(f)\n+        self.after_request_funcs.setdefault(None, []).append(self.ensure_sync(f))\n         return f\n \n     @setupmethod\n@@ -563,7 +565,7 @@ class Scaffold:\n            debugger can still access it.  This behavior can be controlled\n            by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n         \"\"\"\n-        self.teardown_request_funcs[None].append(f)\n+        self.teardown_request_funcs.setdefault(None, []).append(self.ensure_sync(f))\n         return f\n \n     @setupmethod\n@@ -659,7 +661,7 @@ class Scaffold:\n                 \" instead.\"\n             )\n \n-        self.error_handler_spec[None][code][exc_class] = f\n+        self.error_handler_spec[None][code][exc_class] = self.ensure_sync(f)\n \n     @staticmethod\n     def _get_exc_class_and_code(exc_class_or_code):\n@@ -684,6 +686,19 @@ class Scaffold:\n         else:\n             return exc_class, None\n \n+    def ensure_sync(self, func):\n+        \"\"\"Ensure that the returned function is sync and calls the async func.\n+\n+        .. versionadded:: 2.0\n+\n+        Override if you wish to change how asynchronous functions are\n+        run.\n+        \"\"\"\n+        if iscoroutinefunction(func):\n+            return run_async(func)\n+        else:\n+            return func\n+\n \n def _endpoint_from_view_func(view_func):\n     \"\"\"Internal helper that returns the default endpoint for a given\n\n@@ -0,0 +1,33 @@\n+import asyncio\n+\n+import pytest\n+\n+from flask import abort\n+from flask import Flask\n+from flask import request\n+\n+\n+@pytest.fixture(name=\"async_app\")\n+def _async_app():\n+    app = Flask(__name__)\n+\n+    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n+    async def index():\n+        await asyncio.sleep(0)\n+        return request.method\n+\n+    @app.route(\"/error\")\n+    async def error():\n+        abort(412)\n+\n+    return app\n+\n+\n+def test_async_request_context(async_app):\n+    test_client = async_app.test_client()\n+    response = test_client.get(\"/\")\n+    assert b\"GET\" in response.get_data()\n+    response = test_client.post(\"/\")\n+    assert b\"POST\" in response.get_data()\n+    response = test_client.get(\"/error\")\n+    assert response.status_code == 412\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#c6c6408c3fb96245a2e2afc4b754cdf065fdad47", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 6 | Methods Changed: 2 | Complexity Δ (Sum/Max): 2/1 | Churn Δ: 15 | Churn Cumulative: 1137 | Contributors (this commit): 8 | Commits (past 90d): 4 | Contributors (cumulative): 9 | DMM Complexity: 1.0\n\nDIFF:\n@@ -7,6 +7,7 @@ from threading import RLock\n \n import werkzeug.utils\n from werkzeug.exceptions import NotFound\n+from werkzeug.local import ContextVar\n from werkzeug.routing import BuildError\n from werkzeug.urls import url_quote\n \n@@ -741,6 +742,11 @@ def run_async(func):\n             \"Install Flask with the 'async' extra in order to use async views.\"\n         )\n \n+    if ContextVar.__module__ == \"werkzeug.local\":\n+        raise RuntimeError(\n+            \"async cannot be used with this combination of Python & Greenlet versions\"\n+        )\n+\n     @wraps(func)\n     def outer(*args, **kwargs):\n         \"\"\"This function grabs the current context for the inner function.\n\n@@ -1,10 +1,12 @@\n import asyncio\n+import sys\n \n import pytest\n \n from flask import abort\n from flask import Flask\n from flask import request\n+from flask.helpers import run_async\n \n \n @pytest.fixture(name=\"async_app\")\n@@ -23,6 +25,7 @@ def _async_app():\n     return app\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 7), reason=\"requires Python >= 3.7\")\n def test_async_request_context(async_app):\n     test_client = async_app.test_client()\n     response = test_client.get(\"/\")\n@@ -31,3 +34,9 @@ def test_async_request_context(async_app):\n     assert b\"POST\" in response.get_data()\n     response = test_client.get(\"/error\")\n     assert response.status_code == 412\n+\n+\n+@pytest.mark.skipif(sys.version_info >= (3, 7), reason=\"should only raise Python < 3.7\")\n+def test_async_runtime_error():\n+    with pytest.raises(RuntimeError):\n+        run_async(None)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#00f5a3e55ca3b6dd4e98044ab76f055dc74997ac", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 168 | Lines Deleted: 31 | Files Changed: 5 | Hunks: 27 | Methods Changed: 29 | Complexity Δ (Sum/Max): 19/13 | Churn Δ: 199 | Churn Cumulative: 3865 | Contributors (this commit): 18 | Commits (past 90d): 27 | Contributors (cumulative): 28 | DMM Complexity: 0.8163265306122449\n\nDIFF:\n@@ -2,6 +2,7 @@ import os\n import sys\n import weakref\n from datetime import timedelta\n+from inspect import iscoroutinefunction\n from itertools import chain\n from threading import Lock\n \n@@ -34,6 +35,7 @@ from .helpers import get_env\n from .helpers import get_flashed_messages\n from .helpers import get_load_dotenv\n from .helpers import locked_cached_property\n+from .helpers import run_async\n from .helpers import url_for\n from .json import jsonify\n from .logging import create_logger\n@@ -1517,6 +1519,19 @@ class Flask(Scaffold):\n         \"\"\"\n         return False\n \n+    def ensure_sync(self, func):\n+        \"\"\"Ensure that the returned function is sync and calls the async func.\n+\n+        .. versionadded:: 2.0\n+\n+        Override if you wish to change how asynchronous functions are\n+        run.\n+        \"\"\"\n+        if iscoroutinefunction(func):\n+            return run_async(func)\n+\n+        return func\n+\n     def make_response(self, rv):\n         \"\"\"Convert the return value from a view function to an instance of\n         :attr:`response_class`.\n\n@@ -1,3 +1,4 @@\n+from collections import defaultdict\n from functools import update_wrapper\n \n from .scaffold import _endpoint_from_view_func\n@@ -235,24 +236,44 @@ class Blueprint(Scaffold):\n         # Merge blueprint data into parent.\n         if first_registration:\n \n-            def extend(bp_dict, parent_dict):\n+            def extend(bp_dict, parent_dict, ensure_sync=False):\n                 for key, values in bp_dict.items():\n                     key = self.name if key is None else f\"{self.name}.{key}\"\n+\n+                    if ensure_sync:\n+                        values = [app.ensure_sync(func) for func in values]\n+\n                     parent_dict[key].extend(values)\n \n-            def update(bp_dict, parent_dict):\n-                for key, value in bp_dict.items():\n+            for key, value in self.error_handler_spec.items():\n                 key = self.name if key is None else f\"{self.name}.{key}\"\n-                    parent_dict[key] = value\n+                value = defaultdict(\n+                    dict,\n+                    {\n+                        code: {\n+                            exc_class: app.ensure_sync(func)\n+                            for exc_class, func in code_values.items()\n+                        }\n+                        for code, code_values in value.items()\n+                    },\n+                )\n+                app.error_handler_spec[key] = value\n \n-            app.view_functions.update(self.view_functions)\n-            extend(self.before_request_funcs, app.before_request_funcs)\n-            extend(self.after_request_funcs, app.after_request_funcs)\n-            extend(self.teardown_request_funcs, app.teardown_request_funcs)\n+            for endpoint, func in self.view_functions.items():\n+                app.view_functions[endpoint] = app.ensure_sync(func)\n+\n+            extend(\n+                self.before_request_funcs, app.before_request_funcs, ensure_sync=True\n+            )\n+            extend(self.after_request_funcs, app.after_request_funcs, ensure_sync=True)\n+            extend(\n+                self.teardown_request_funcs,\n+                app.teardown_request_funcs,\n+                ensure_sync=True,\n+            )\n             extend(self.url_default_functions, app.url_default_functions)\n             extend(self.url_value_preprocessors, app.url_value_preprocessors)\n             extend(self.template_context_processors, app.template_context_processors)\n-            update(self.error_handler_spec, app.error_handler_spec)\n \n         for deferred in self.deferred_functions:\n             deferred(state)\n@@ -380,7 +401,9 @@ class Blueprint(Scaffold):\n         before each request, even if outside of a blueprint.\n         \"\"\"\n         self.record_once(\n-            lambda s: s.app.before_request_funcs.setdefault(None, []).append(f)\n+            lambda s: s.app.before_request_funcs.setdefault(None, []).append(\n+                s.app.ensure_sync(f)\n+            )\n         )\n         return f\n \n@@ -388,7 +411,9 @@ class Blueprint(Scaffold):\n         \"\"\"Like :meth:`Flask.before_first_request`.  Such a function is\n         executed before the first request to the application.\n         \"\"\"\n-        self.record_once(lambda s: s.app.before_first_request_funcs.append(f))\n+        self.record_once(\n+            lambda s: s.app.before_first_request_funcs.append(s.app.ensure_sync(f))\n+        )\n         return f\n \n     def after_app_request(self, f):\n@@ -396,7 +421,9 @@ class Blueprint(Scaffold):\n         is executed after each request, even if outside of the blueprint.\n         \"\"\"\n         self.record_once(\n-            lambda s: s.app.after_request_funcs.setdefault(None, []).append(f)\n+            lambda s: s.app.after_request_funcs.setdefault(None, []).append(\n+                s.app.ensure_sync(f)\n+            )\n         )\n         return f\n \n@@ -443,3 +470,14 @@ class Blueprint(Scaffold):\n             lambda s: s.app.url_default_functions.setdefault(None, []).append(f)\n         )\n         return f\n+\n+    def ensure_sync(self, f):\n+        \"\"\"Ensure the function is synchronous.\n+\n+        Override if you would like custom async to sync behaviour in\n+        this blueprint. Otherwise :meth:`~flask.Flask..ensure_sync` is\n+        used.\n+\n+        .. versionadded:: 2.0\n+        \"\"\"\n+        return f\n\n@@ -755,6 +755,7 @@ def run_async(func):\n         ctx module, except it has an async inner.\n         \"\"\"\n         ctx = None\n+\n         if _request_ctx_stack.top is not None:\n             ctx = _request_ctx_stack.top.copy()\n \n\n@@ -4,7 +4,6 @@ import pkgutil\n import sys\n from collections import defaultdict\n from functools import update_wrapper\n-from inspect import iscoroutinefunction\n \n from jinja2 import FileSystemLoader\n from werkzeug.exceptions import default_exceptions\n@@ -13,7 +12,6 @@ from werkzeug.exceptions import HTTPException\n from .cli import AppGroup\n from .globals import current_app\n from .helpers import locked_cached_property\n-from .helpers import run_async\n from .helpers import send_from_directory\n from .templating import _default_template_ctx_processor\n \n@@ -687,17 +685,7 @@ class Scaffold:\n             return exc_class, None\n \n     def ensure_sync(self, func):\n-        \"\"\"Ensure that the returned function is sync and calls the async func.\n-\n-        .. versionadded:: 2.0\n-\n-        Override if you wish to change how asynchronous functions are\n-        run.\n-        \"\"\"\n-        if iscoroutinefunction(func):\n-            return run_async(func)\n-        else:\n-            return func\n+        raise NotImplementedError()\n \n \n def _endpoint_from_view_func(view_func):\n\n@@ -3,12 +3,20 @@ import sys\n \n import pytest\n \n-from flask import abort\n+from flask import Blueprint\n from flask import Flask\n from flask import request\n from flask.helpers import run_async\n \n \n+class AppError(Exception):\n+    pass\n+\n+\n+class BlueprintError(Exception):\n+    pass\n+\n+\n @pytest.fixture(name=\"async_app\")\n def _async_app():\n     app = Flask(__name__)\n@@ -18,24 +26,111 @@ def _async_app():\n         await asyncio.sleep(0)\n         return request.method\n \n+    @app.errorhandler(AppError)\n+    async def handle(_):\n+        return \"\", 412\n+\n     @app.route(\"/error\")\n     async def error():\n-        abort(412)\n+        raise AppError()\n+\n+    blueprint = Blueprint(\"bp\", __name__)\n+\n+    @blueprint.route(\"/\", methods=[\"GET\", \"POST\"])\n+    async def bp_index():\n+        await asyncio.sleep(0)\n+        return request.method\n+\n+    @blueprint.errorhandler(BlueprintError)\n+    async def bp_handle(_):\n+        return \"\", 412\n+\n+    @blueprint.route(\"/error\")\n+    async def bp_error():\n+        raise BlueprintError()\n+\n+    app.register_blueprint(blueprint, url_prefix=\"/bp\")\n \n     return app\n \n \n @pytest.mark.skipif(sys.version_info < (3, 7), reason=\"requires Python >= 3.7\")\n-def test_async_request_context(async_app):\n+@pytest.mark.parametrize(\"path\", [\"/\", \"/bp/\"])\n+def test_async_route(path, async_app):\n     test_client = async_app.test_client()\n-    response = test_client.get(\"/\")\n+    response = test_client.get(path)\n     assert b\"GET\" in response.get_data()\n-    response = test_client.post(\"/\")\n+    response = test_client.post(path)\n     assert b\"POST\" in response.get_data()\n-    response = test_client.get(\"/error\")\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 7), reason=\"requires Python >= 3.7\")\n+@pytest.mark.parametrize(\"path\", [\"/error\", \"/bp/error\"])\n+def test_async_error_handler(path, async_app):\n+    test_client = async_app.test_client()\n+    response = test_client.get(path)\n     assert response.status_code == 412\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 7), reason=\"requires Python >= 3.7\")\n+def test_async_before_after_request():\n+    app_first_called = False\n+    app_before_called = False\n+    app_after_called = False\n+    bp_before_called = False\n+    bp_after_called = False\n+\n+    app = Flask(__name__)\n+\n+    @app.route(\"/\")\n+    def index():\n+        return \"\"\n+\n+    @app.before_first_request\n+    async def before_first():\n+        nonlocal app_first_called\n+        app_first_called = True\n+\n+    @app.before_request\n+    async def before():\n+        nonlocal app_before_called\n+        app_before_called = True\n+\n+    @app.after_request\n+    async def after(response):\n+        nonlocal app_after_called\n+        app_after_called = True\n+        return response\n+\n+    blueprint = Blueprint(\"bp\", __name__)\n+\n+    @blueprint.route(\"/\")\n+    def bp_index():\n+        return \"\"\n+\n+    @blueprint.before_request\n+    async def bp_before():\n+        nonlocal bp_before_called\n+        bp_before_called = True\n+\n+    @blueprint.after_request\n+    async def bp_after(response):\n+        nonlocal bp_after_called\n+        bp_after_called = True\n+        return response\n+\n+    app.register_blueprint(blueprint, url_prefix=\"/bp\")\n+\n+    test_client = app.test_client()\n+    test_client.get(\"/\")\n+    assert app_first_called\n+    assert app_before_called\n+    assert app_after_called\n+    test_client.get(\"/bp/\")\n+    assert bp_before_called\n+    assert bp_after_called\n+\n+\n @pytest.mark.skipif(sys.version_info >= (3, 7), reason=\"should only raise Python < 3.7\")\n def test_async_runtime_error():\n     with pytest.raises(RuntimeError):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
