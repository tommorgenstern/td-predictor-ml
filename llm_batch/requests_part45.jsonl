{"custom_id": "requests#11433d942dcc0bb9e321141ff04d378568c288fb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 197 | Contributors (this commit): 5 | Commits (past 90d): 3 | Contributors (cumulative): 5 | DMM Complexity: None\n\nDIFF:\n@@ -60,6 +60,7 @@ defaults['base_headers'] = {\n     'User-Agent': \" \".join([\n             'python-requests/%s' % __version__,\n             '%s/%s' % (_implementation, _implementation_version),\n+            '%s/%s' % (platform.system(), platform.release()),\n         ]),\n     'Accept': '*/*'\n }\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#25299400fafc5f1dead16f04eb258dc60b59c148", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 6 | Churn Cumulative: 5359 | Contributors (this commit): 68 | Commits (past 90d): 50 | Contributors (cumulative): 68 | DMM Complexity: None\n\nDIFF:\n@@ -7,10 +7,14 @@ requests.models\n This module contains the primary objects that power Requests.\n \"\"\"\n \n-import json\n import os\n from datetime import datetime\n \n+try:\n+    import simplejson as json\n+except ImportError:\n+    import json\n+\n from .hooks import dispatch_hook, HOOKS\n from .structures import CaseInsensitiveDict\n from .status_codes import codes\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f8c98715c307dda487d0cc404eb7d26c53c49aa4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 6 | Files Changed: 2 | Hunks: 3 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 11 | Churn Cumulative: 5487 | Contributors (this commit): 69 | Commits (past 90d): 54 | Contributors (cumulative): 71 | DMM Complexity: None\n\nDIFF:\n@@ -72,6 +72,10 @@ is_osx = ('darwin' in str(sys.platform).lower())\n is_hpux = ('hpux' in str(sys.platform).lower())   # Complete guess.\n is_solaris = ('solar==' in str(sys.platform).lower())   # Complete guess.\n \n+try:\n+    import simplejson as json\n+except ImportError:\n+    import json\n \n # ---------\n # Specifics\n\n@@ -10,11 +10,6 @@ This module contains the primary objects that power Requests.\n import os\n from datetime import datetime\n \n-try:\n-    import simplejson as json\n-except ImportError:\n-    import json\n-\n from .hooks import dispatch_hook, HOOKS\n from .structures import CaseInsensitiveDict\n from .status_codes import codes\n@@ -36,7 +31,7 @@ from .utils import (\n     DEFAULT_CA_BUNDLE_PATH)\n from .compat import (\n     cookielib, urlparse, urlunparse, urljoin, urlsplit, urlencode, str, bytes,\n-    StringIO, is_py2, chardet)\n+    StringIO, is_py2, chardet, json)\n \n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n CONTENT_CHUNK_SIZE = 10 * 1024\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#523433f26cc6385b91fcc87186437474abd2cde1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 198 | Contributors (this commit): 5 | Commits (past 90d): 4 | Contributors (cumulative): 5 | DMM Complexity: None\n\nDIFF:\n@@ -62,6 +62,7 @@ defaults['base_headers'] = {\n             '%s/%s' % (_implementation, _implementation_version),\n             '%s/%s' % (platform.system(), platform.release()),\n         ]),\n+    'Accept-Encoding': ', '.join(('identity', 'deflate', 'compress', 'gzip')),\n     'Accept': '*/*'\n }\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#21f60fe8dfe2ebbde2318f763f585d7de18d3d6f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 33 | Lines Deleted: 32 | Files Changed: 2 | Hunks: 7 | Methods Changed: 1 | Complexity Δ (Sum/Max): 6/6 | Churn Δ: 65 | Churn Cumulative: 1641 | Contributors (this commit): 26 | Commits (past 90d): 18 | Contributors (cumulative): 29 | DMM Complexity: 0.0\n\nDIFF:\n@@ -26,42 +26,12 @@ Configurations:\n \n SCHEMAS = ['http', 'https']\n \n-import platform\n-import sys\n-\n-from . import __version__\n+from .utils import default_user_agent\n \n defaults = dict()\n \n-\n-_implementation = platform.python_implementation()\n-\n-if _implementation == 'CPython':\n-    _implementation_version = platform.python_version()\n-elif _implementation == 'PyPy':\n-    _implementation_version = '%s.%s.%s' % (\n-                                                sys.pypy_version_info.major,\n-                                                sys.pypy_version_info.minor,\n-                                                sys.pypy_version_info.micro\n-                                            )\n-    if sys.pypy_version_info.releaselevel != 'final':\n-        _implementation_version = ''.join([_implementation_version, sys.pypy_version_info.releaselevel])\n-elif _implementation == 'Jython':\n-    # @@@ Is there a better way of getting this?\n-    _implementation_version = platform.python_version()\n-elif _implementation == 'IronPython':\n-    # @@@ Is there a better way of getting this?\n-    _implementation_version = platform.python_version()\n-else:\n-    _implementation_version = 'Unknown'\n-\n-\n defaults['base_headers'] = {\n-    'User-Agent': \" \".join([\n-            'python-requests/%s' % __version__,\n-            '%s/%s' % (_implementation, _implementation_version),\n-            '%s/%s' % (platform.system(), platform.release()),\n-        ]),\n+    'User-Agent': default_user_agent(),\n     'Accept-Encoding': ', '.join(('identity', 'deflate', 'compress', 'gzip')),\n     'Accept': '*/*'\n }\n\n@@ -12,10 +12,13 @@ that are also useful for external consumption.\n import cgi\n import codecs\n import os\n+import platform\n import re\n+import sys\n import zlib\n from netrc import netrc, NetrcParseError\n \n+from . import __version__\n from .compat import parse_http_list as _parse_list_header\n from .compat import quote, urlparse, basestring, bytes, str\n from .cookies import RequestsCookieJar, cookiejar_from_dict\n@@ -457,3 +460,31 @@ def get_environ_proxies():\n     get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n     proxies = [(key, get_proxy(key + '_proxy')) for key in proxy_keys]\n     return dict([(key, val) for (key, val) in proxies if val])\n+\n+\n+def default_user_agent():\n+    \"\"\"Return a string representing the default user agent.\"\"\"\n+    _implementation = platform.python_implementation()\n+\n+    if _implementation == 'CPython':\n+        _implementation_version = platform.python_version()\n+    elif _implementation == 'PyPy':\n+        _implementation_version = '%s.%s.%s' % (\n+                                                sys.pypy_version_info.major,\n+                                                sys.pypy_version_info.minor,\n+                                                sys.pypy_version_info.micro\n+                                            )\n+        if sys.pypy_version_info.releaselevel != 'final':\n+            _implementation_version = ''.join([_implementation_version, sys.pypy_version_info.releaselevel])\n+    elif _implementation == 'Jython':\n+        _implementation_version = platform.python_version()  # Complete Guess\n+    elif _implementation == 'IronPython':\n+        _implementation_version = platform.python_version()  # Complete Guess\n+    else:\n+        _implementation_version = 'Unknown'\n+\n+    return \" \".join([\n+            'python-requests/%s' % __version__,\n+            '%s/%s' % (_implementation, _implementation_version),\n+            '%s/%s' % (platform.system(), platform.release()),\n+        ])\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#08cebb3c2fb3b3a4164a8e38435ab30b2ddaaa73", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 5 | Files Changed: 2 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 20 | Churn Cumulative: 6027 | Contributors (this commit): 70 | Commits (past 90d): 73 | Contributors (cumulative): 83 | DMM Complexity: 1.0\n\nDIFF:\n@@ -395,14 +395,14 @@ class Request(object):\n             if isinstance(fragment, str):\n                 fragment = fragment.encode('utf-8')\n \n-        url = (urlunparse([scheme, netloc, path, params, query, fragment]))\n-\n         enc_params = self._encode_params(self.params)\n         if enc_params:\n-            if urlparse(url).query:\n-                url = '%s&%s' % (url, enc_params)\n+            if query:\n+                query = '%s&%s' % (query, enc_params)\n             else:\n-                url = '%s?%s' % (url, enc_params)\n+                query = enc_params\n+\n+        url = (urlunparse([scheme, netloc, path, params, query, fragment]))\n \n         if self.config.get('encode_uri', True):\n             url = requote_uri(url)\n\n@@ -83,6 +83,16 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n \n         self.assertEqual(request.path_url, \"/get/test%20case\")\n \n+    def test_params_are_added_before_fragment(self):\n+        request = requests.Request(\n+            \"http://example.com/path#fragment\", params={\"a\": \"b\"})\n+        self.assertEqual(request.full_url,\n+            \"http://example.com/path?a=b#fragment\")\n+        request = requests.Request(\n+            \"http://example.com/path?key=value#fragment\", params={\"a\": \"b\"})\n+        self.assertEqual(request.full_url,\n+            \"http://example.com/path?key=value&a=b#fragment\")\n+\n     def test_HTTP_200_OK_GET(self):\n         r = get(httpbin('get'))\n         self.assertEqual(r.status_code, 200)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#523906c54f23e0147cb8aacd3393ce6501a148fa", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 4 | Churn Cumulative: 5380 | Contributors (this commit): 69 | Commits (past 90d): 49 | Contributors (cumulative): 69 | DMM Complexity: 0.0\n\nDIFF:\n@@ -600,9 +600,9 @@ class Request(object):\n                 raise ConnectionError(e)\n \n             except (_SSLError, _HTTPError) as e:\n-                if self.verify and isinstance(e, _SSLError):\n+                if isinstance(e, _SSLError):\n                     raise SSLError(e)\n-\n+                else:\n                     raise Timeout('Request timed out.')\n \n             # build_response can throw TooManyRedirects\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#9fe4a9936572e638dad2db30fffd6b38b0b74f66", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 5382 | Contributors (this commit): 70 | Commits (past 90d): 48 | Contributors (cumulative): 70 | DMM Complexity: None\n\nDIFF:\n@@ -660,7 +660,7 @@ class Response(object):\n \n         #: A list of :class:`Response <Response>` objects from\n         #: the history of the Request. Any redirect responses will end\n-        #: up here.\n+        #: up here. The list is sorted from the oldest to the most recent request.\n         self.history = []\n \n         #: The :class:`Request <Request>` that created the Response.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#318f2460eed225b7d369db3f07d4cc3445e70804", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 3 | Churn Cumulative: 5385 | Contributors (this commit): 71 | Commits (past 90d): 49 | Contributors (cumulative): 71 | DMM Complexity: 0.0\n\nDIFF:\n@@ -17,6 +17,7 @@ from .status_codes import codes\n from .auth import HTTPBasicAuth, HTTPProxyAuth\n from .cookies import cookiejar_from_dict, extract_cookies_to_jar, get_cookie_header\n from .packages.urllib3.exceptions import MaxRetryError, LocationParseError\n+from .packages.urllib3.exceptions import TimeoutError\n from .packages.urllib3.exceptions import SSLError as _SSLError\n from .packages.urllib3.exceptions import HTTPError as _HTTPError\n from .packages.urllib3 import connectionpool, poolmanager\n@@ -602,6 +603,8 @@ class Request(object):\n             except (_SSLError, _HTTPError) as e:\n                 if isinstance(e, _SSLError):\n                     raise SSLError(e)\n+                elif isinstance(e, TimeoutError):\n+                    raise Timeout(e)\n                 else:\n                     raise Timeout('Request timed out.')\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#5296b8be90cb79f0e2b36bbf9a6108e65bec0e23", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 4 | Churn Cumulative: 653 | Contributors (this commit): 10 | Commits (past 90d): 16 | Contributors (cumulative): 10 | DMM Complexity: None\n\nDIFF:\n@@ -133,11 +133,11 @@ class HTTPDigestAuth(AuthBase):\n     def handle_401(self, r):\n         \"\"\"Takes the given response and tries digest-auth, if needed.\"\"\"\n \n-        r.request.deregister_hook('response', self.handle_401)\n+        num_401_calls = r.request.hooks['response'].count(self.handle_401)\n \t\n         s_auth = r.headers.get('www-authenticate', '')\n \n-        if 'digest' in s_auth.lower():\n+        if 'digest' in s_auth.lower() and num_401_calls < 2:\n \n             last_nonce = ''\n             nonce_count = 0\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f9c0ddf46ddae0a6b901257309424f2f3f196d90", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 7 | Churn Cumulative: 5392 | Contributors (this commit): 72 | Commits (past 90d): 50 | Contributors (cumulative): 72 | DMM Complexity: 0.0\n\nDIFF:\n@@ -355,6 +355,13 @@ class Request(object):\n                 fp = StringIO(fp)\n             fields.update({k: (fn, fp.read())})\n \n+        for field in fields:\n+            if isinstance(fields[field], float):\n+                fields[field] = str(fields[field])\n+            if isinstance(fields[field], list):\n+                newvalue = ', '.join(fields[field])\n+                fields[field] = newvalue\n+                \n         (body, content_type) = encode_multipart_formdata(fields)\n \n         return (body, content_type)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#2c241d28011626da17dabed80e190ac84e5cf79c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 21 | Contributors (this commit): 2 | Commits (past 90d): 2 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -1,3 +1,4 @@\n+from __future__ import print_function\r\n import sys, glob\r\n sys.path.insert(0, '..')\r\n from chardet.universaldetector import UniversalDetector\r\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#6eb1ac44527e40f26f078d336b4ad6838798432b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): -3/0 | Churn Δ: 6 | Churn Cumulative: 5398 | Contributors (this commit): 73 | Commits (past 90d): 47 | Contributors (cumulative): 73 | DMM Complexity: None\n\nDIFF:\n@@ -821,16 +821,16 @@ class Response(object):\n             raise self.error\n \n         if (self.status_code >= 300) and (self.status_code < 400) and not allow_redirects:\n-            http_error = HTTPError('%s Redirection' % self.status_code)\n+            http_error = HTTPError('%s Redirection: %s' % (self.status_code, self.content))\n             http_error.response = self\n             raise http_error\n \n         elif (self.status_code >= 400) and (self.status_code < 500):\n-            http_error = HTTPError('%s Client Error' % self.status_code)\n+            http_error = HTTPError('%s Client Error: %s' % (self.status_code, self.content))\n             http_error.response = self\n             raise http_error\n \n         elif (self.status_code >= 500) and (self.status_code < 600):\n-            http_error = HTTPError('%s Server Error' % self.status_code)\n+            http_error = HTTPError('%s Server Error: %s' % (self.status_code, self.content))\n             http_error.response = self\n             raise http_error\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c485928a9f964632cd9556607889aeb1379846b8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 5404 | Contributors (this commit): 73 | Commits (past 90d): 48 | Contributors (cumulative): 73 | DMM Complexity: None\n\nDIFF:\n@@ -821,16 +821,16 @@ class Response(object):\n             raise self.error\n \n         if (self.status_code >= 300) and (self.status_code < 400) and not allow_redirects:\n-            http_error = HTTPError('%s Redirection: %s' % (self.status_code, self.content))\n+            http_error = HTTPError('%s Redirection: %s' % (self.status_code, self.reason))\n             http_error.response = self\n             raise http_error\n \n         elif (self.status_code >= 400) and (self.status_code < 500):\n-            http_error = HTTPError('%s Client Error: %s' % (self.status_code, self.content))\n+            http_error = HTTPError('%s Client Error: %s' % (self.status_code, self.reason))\n             http_error.response = self\n             raise http_error\n \n         elif (self.status_code >= 500) and (self.status_code < 600):\n-            http_error = HTTPError('%s Server Error: %s' % (self.status_code, self.content))\n+            http_error = HTTPError('%s Server Error: %s' % (self.status_code, self.reason))\n             http_error.response = self\n             raise http_error\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#79aa9edde1bba39a433475929970dd519fecfdf3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 26 | Contributors (this commit): 2 | Commits (past 90d): 2 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -16,7 +16,8 @@ try:\n     from oauthlib.common import extract_params\n     from oauthlib.oauth1.rfc5849 import (Client, SIGNATURE_HMAC, SIGNATURE_TYPE_AUTH_HEADER)\n except ImportError:\n-    path = os.path.abspath('/'.join(__file__.split('/')[:-1]+['packages']))\n+    directory = os.path.dirname(__file__)\n+    path = os.path.join(directory, 'packages')\n     sys.path.insert(0, path)\n     from oauthlib.oauth1 import rfc5849\n     from oauthlib.common import extract_params\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#55237ad67dddaf070a40ea1ab64f84799356edfa", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 30 | Contributors (this commit): 2 | Commits (past 90d): 3 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -4,8 +4,8 @@\n requests._oauth\n ~~~~~~~~~~~~~~~\n \n-This module comtains the path hack neccesary for oauthlib to be vendored into requests\n-while allowing upstream changes.\n+This module contains the path hack necessary for oauthlib to be vendored into\n+requests while allowing upstream changes.\n \"\"\"\n \n import os\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#350be4a5496d10fab85b03fde65597e3a618abdf", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 1411 | Contributors (this commit): 25 | Commits (past 90d): 9 | Contributors (cumulative): 25 | DMM Complexity: None\n\nDIFF:\n@@ -101,7 +101,7 @@ def get_netrc_auth(url):\n             pass\n \n     # AppEngine hackiness.\n-    except AttributeError:\n+    except (ImportError, AttributeError):\n         pass\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e02fb2eb6c2acfa67793a2c77a3c7bd47998a024", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 329 | Lines Deleted: 229 | Files Changed: 6 | Hunks: 56 | Methods Changed: 38 | Complexity Δ (Sum/Max): 17/15 | Churn Δ: 558 | Churn Cumulative: 4149 | Contributors (this commit): 1 | Commits (past 90d): 10 | Contributors (cumulative): 6 | DMM Complexity: 0.0\n\nDIFF:\n@@ -4,128 +4,91 @@\n # This module is part of urllib3 and is released under\n # the MIT License: http://www.opensource.org/licenses/mit-license.php\n \n-from collections import deque\n+from collections import MutableMapping\n+from threading import Lock\n+\n+try: # Python 2.7+\n+    from collections import OrderedDict\n+except ImportError:\n+    from .packages.ordered_dict import OrderedDict\n \n-from threading import RLock\n \n __all__ = ['RecentlyUsedContainer']\n \n \n-class AccessEntry(object):\n-    __slots__ = ('key', 'is_valid')\n-\n-    def __init__(self, key, is_valid=True):\n-        self.key = key\n-        self.is_valid = is_valid\n+_Null = object()\n \n \n-class RecentlyUsedContainer(dict):\n+class RecentlyUsedContainer(MutableMapping):\n     \"\"\"\n-    Provides a dict-like that maintains up to ``maxsize`` keys while throwing\n-    away the least-recently-used keys beyond ``maxsize``.\n+    Provides a thread-safe dict-like container which maintains up to\n+    ``maxsize`` keys while throwing away the least-recently-used keys beyond\n+    ``maxsize``.\n+\n+    :param maxsize:\n+        Maximum number of recent elements to retain.\n+\n+    :param dispose_func:\n+        Every time an item is evicted from the container,\n+        ``dispose_func(value)`` is called.  Callback which will get called\n     \"\"\"\n \n-    # If len(self.access_log) exceeds self._maxsize * CLEANUP_FACTOR, then we\n-    # will attempt to cleanup the invalidated entries in the access_log\n-    # datastructure during the next 'get' operation.\n-    CLEANUP_FACTOR = 10\n+    ContainerCls = OrderedDict\n \n-    def __init__(self, maxsize=10):\n+    def __init__(self, maxsize=10, dispose_func=None):\n         self._maxsize = maxsize\n+        self.dispose_func = dispose_func\n \n-        self._container = {}\n-\n-        # We use a deque to to store our keys ordered by the last access.\n-        self.access_log = deque()\n-        self.access_log_lock = RLock()\n-\n-        # We look up the access log entry by the key to invalidate it so we can\n-        # insert a new authorative entry at the head without having to dig and\n-        # find the old entry for removal immediately.\n-        self.access_lookup = {}\n-\n-        # Trigger a heap cleanup when we get past this size\n-        self.access_log_limit = maxsize * self.CLEANUP_FACTOR\n-\n-    def _invalidate_entry(self, key):\n-        \"If exists: Invalidate old entry and return it.\"\n-        old_entry = self.access_lookup.get(key)\n-        if old_entry:\n-            old_entry.is_valid = False\n-\n-        return old_entry\n-\n-    def _push_entry(self, key):\n-        \"Push entry onto our access log, invalidate the old entry if exists.\"\n-        self._invalidate_entry(key)\n-\n-        new_entry = AccessEntry(key)\n-        self.access_lookup[key] = new_entry\n-\n-        self.access_log_lock.acquire()\n-        self.access_log.appendleft(new_entry)\n-        self.access_log_lock.release()\n-\n-    def _prune_entries(self, num):\n-        \"Pop entries from our access log until we popped ``num`` valid ones.\"\n-        while num > 0:\n-            self.access_log_lock.acquire()\n-            p = self.access_log.pop()\n-            self.access_log_lock.release()\n-\n-            if not p.is_valid:\n-                continue # Invalidated entry, skip\n-\n-            dict.pop(self, p.key, None)\n-            self.access_lookup.pop(p.key, None)\n-            num -= 1\n-\n-    def _prune_invalidated_entries(self):\n-        \"Rebuild our access_log without the invalidated entries.\"\n-        self.access_log_lock.acquire()\n-        self.access_log = deque(e for e in self.access_log if e.is_valid)\n-        self.access_log_lock.release()\n-\n-    def _get_ordered_access_keys(self):\n-        \"Return ordered access keys for inspection. Used for testing.\"\n-        self.access_log_lock.acquire()\n-        r = [e.key for e in self.access_log if e.is_valid]\n-        self.access_log_lock.release()\n-\n-        return r\n+        self._container = self.ContainerCls()\n+        self._lock = Lock()\n \n     def __getitem__(self, key):\n-        item = dict.get(self, key)\n-\n-        if not item:\n-            raise KeyError(key)\n-\n-        # Insert new entry with new high priority, also implicitly invalidates\n-        # the old entry.\n-        self._push_entry(key)\n-\n-        if len(self.access_log) > self.access_log_limit:\n-            # Heap is getting too big, try to clean up any tailing invalidated\n-            # entries.\n-            self._prune_invalidated_entries()\n-\n+        # Re-insert the item, moving it to the end of the eviction line.\n+        with self._lock:\n+            item = self._container.pop(key)\n+            self._container[key] = item\n             return item\n \n-    def __setitem__(self, key, item):\n-        # Add item to our container and access log\n-        dict.__setitem__(self, key, item)\n-        self._push_entry(key)\n+    def __setitem__(self, key, value):\n+        evicted_value = _Null\n+        with self._lock:\n+            # Possibly evict the existing value of 'key'\n+            evicted_value = self._container.get(key, _Null)\n+            self._container[key] = value\n \n-        # Discard invalid and excess entries\n-        self._prune_entries(len(self) - self._maxsize)\n+            # If we didn't evict an existing value, we might have to evict the\n+            # least recently used item from the beginning of the container.\n+            if len(self._container) > self._maxsize:\n+                _key, evicted_value = self._container.popitem(last=False)\n+\n+        if self.dispose_func and evicted_value is not _Null:\n+            self.dispose_func(evicted_value)\n \n     def __delitem__(self, key):\n-        self._invalidate_entry(key)\n-        self.access_lookup.pop(key, None)\n-        dict.__delitem__(self, key)\n+        with self._lock:\n+            value = self._container.pop(key)\n \n-    def get(self, key, default=None):\n-        try:\n-            return self[key]\n-        except KeyError:\n-            return default\n+        if self.dispose_func:\n+            self.dispose_func(value)\n+\n+    def __len__(self):\n+        with self._lock:\n+            return len(self._container)\n+\n+    def __iter__(self):\n+        raise NotImplementedError('Iteration over this class is unlikely to be threadsafe.')\n+\n+    def clear(self):\n+        with self._lock:\n+            # Copy pointers to all values, then wipe the mapping\n+            # under Python 2, this copies the list of values twice :-|\n+            values = list(self._container.values())\n+            self._container.clear()\n+\n+        if self.dispose_func:\n+            for value in values:\n+                self.dispose_func(value)\n+\n+    def keys(self):\n+        with self._lock:\n+            return self._container.keys()\n\n@@ -7,7 +7,7 @@\n import logging\n import socket\n \n-from socket import error as SocketError, timeout as SocketTimeout\n+from socket import timeout as SocketTimeout\n \n try: # Python 3\n     from http.client import HTTPConnection, HTTPException\n@@ -35,7 +35,7 @@ try:   # Compiled with SSL?\n     import ssl\n     BaseSSLError = ssl.SSLError\n \n-except (ImportError, AttributeError):\n+except (ImportError, AttributeError): # Platform-specific: No SSL.\n     pass\n \n \n@@ -43,6 +43,7 @@ from .request import RequestMethods\n from .response import HTTPResponse\n from .util import get_host, is_connection_dropped\n from .exceptions import (\n+    ClosedPoolError,\n     EmptyPoolError,\n     HostChangedError,\n     MaxRetryError,\n@@ -206,10 +207,8 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n         try:\n             conn = self.pool.get(block=self.block, timeout=timeout)\n \n-            # If this is a persistent connection, check if it got disconnected\n-            if conn and is_connection_dropped(conn):\n-                log.info(\"Resetting dropped connection: %s\" % self.host)\n-                conn.close()\n+        except AttributeError: # self.pool is None\n+            raise ClosedPoolError(self, \"Pool is closed.\")\n \n         except Empty:\n             if self.block:\n@@ -218,6 +217,11 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n                                      \"connections are allowed.\")\n             pass  # Oh well, we'll create a new connection then\n \n+        # If this is a persistent connection, check if it got disconnected\n+        if conn and is_connection_dropped(conn):\n+            log.info(\"Resetting dropped connection: %s\" % self.host)\n+            conn.close()\n+\n         return conn or self._new_conn()\n \n     def _put_conn(self, conn):\n@@ -228,17 +232,26 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n             Connection object for the current host and port as returned by\n             :meth:`._new_conn` or :meth:`._get_conn`.\n \n-        If the pool is already full, the connection is discarded because we\n-        exceeded maxsize. If connections are discarded frequently, then maxsize\n-        should be increased.\n+        If the pool is already full, the connection is closed and discarded\n+        because we exceeded maxsize. If connections are discarded frequently,\n+        then maxsize should be increased.\n+\n+        If the pool is closed, then the connection will be closed and discarded.\n         \"\"\"\n         try:\n             self.pool.put(conn, block=False)\n+            return # Everything is dandy, done.\n+        except AttributeError:\n+            # self.pool is None.\n+            pass\n         except Full:\n             # This should never happen if self.block == True\n             log.warning(\"HttpConnectionPool is full, discarding connection: %s\"\n                         % self.host)\n \n+        # Connection never got put back into the pool, close it.\n+        conn.close()\n+\n     def _make_request(self, conn, method, url, timeout=_Default,\n                       **httplib_request_kw):\n         \"\"\"\n@@ -268,15 +281,32 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n         log.debug(\"\\\"%s %s %s\\\" %s %s\" % (method, url, http_version,\n                                           httplib_response.status,\n                                           httplib_response.length))\n-\n         return httplib_response\n \n+    def close(self):\n+        \"\"\"\n+        Close all pooled connections and disable the pool.\n+        \"\"\"\n+        # Disable access to the pool\n+        old_pool, self.pool = self.pool, None\n+\n+        try:\n+            while True:\n+                conn = old_pool.get(block=False)\n+                if conn:\n+                    conn.close()\n+\n+        except Empty:\n+            pass # Done.\n \n     def is_same_host(self, url):\n         \"\"\"\n         Check if the given ``url`` is a member of the same host as this\n         connection pool.\n         \"\"\"\n+        if url.startswith('/'):\n+            return True\n+\n         # TODO: Add optional support for socket.gethostbyname checking.\n         scheme, host, port = get_host(url)\n \n@@ -284,8 +314,7 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n             # Use explicit default port for comparison when none is given.\n             port = port_by_scheme.get(scheme)\n \n-        return (url.startswith('/') or\n-                (scheme, host, port) == (self.scheme, self.host, self.port))\n+        return (scheme, host, port) == (self.scheme, self.host, self.port)\n \n     def urlopen(self, method, url, body=None, headers=None, retries=3,\n                 redirect=True, assert_same_host=True, timeout=_Default,\n@@ -378,7 +407,6 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n \n         try:\n             # Request a connection from the queue\n-            # (Could raise SocketError: Bad file descriptor)\n             conn = self._get_conn(timeout=pool_timeout)\n \n             # Make the request on the httplib connection object\n@@ -421,29 +449,38 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n             # Name mismatch\n             raise SSLError(e)\n \n-        except (HTTPException, SocketError) as e:\n+        except HTTPException as e:\n             # Connection broken, discard. It will be replaced next _get_conn().\n             conn = None\n             # This is necessary so we can access e below\n             err = e\n \n         finally:\n-            if conn and release_conn:\n-                # Put the connection back to be reused\n+            if release_conn:\n+                # Put the connection back to be reused. If the connection is\n+                # expired then it will be None, which will get replaced with a\n+                # fresh connection during _get_conn.\n                 self._put_conn(conn)\n \n         if not conn:\n+            # Try again\n             log.warn(\"Retrying (%d attempts remain) after connection \"\n                      \"broken by '%r': %s\" % (retries, err, url))\n             return self.urlopen(method, url, body, headers, retries - 1,\n-                                redirect, assert_same_host)  # Try again\n+                                redirect, assert_same_host,\n+                                timeout=timeout, pool_timeout=pool_timeout,\n+                                release_conn=release_conn, **response_kw)\n \n         # Handle redirect?\n         redirect_location = redirect and response.get_redirect_location()\n         if redirect_location:\n+            if response.status == 303:\n+                method = 'GET'\n             log.info(\"Redirecting %s -> %s\" % (url, redirect_location))\n             return self.urlopen(method, redirect_location, body, headers,\n-                                retries - 1, redirect, assert_same_host)\n+                                retries - 1, redirect, assert_same_host,\n+                                timeout=timeout, pool_timeout=pool_timeout,\n+                                release_conn=release_conn, **response_kw)\n \n         return response\n \n\n@@ -24,6 +24,11 @@ class SSLError(HTTPError):\n     pass\n \n \n+class DecodeError(HTTPError):\n+    \"Raised when automatic decoding based on Content-Type fails.\"\n+    pass\n+\n+\n ## Leaf Exceptions\n \n class MaxRetryError(PoolError):\n@@ -57,6 +62,11 @@ class EmptyPoolError(PoolError):\n     pass\n \n \n+class ClosedPoolError(PoolError):\n+    \"Raised when a request enters a pool after the pool has been closed.\"\n+    pass\n+\n+\n class LocationParseError(ValueError, HTTPError):\n     \"Raised when get_host or similar fails to parse the URL input.\"\n \n\n@@ -8,9 +8,9 @@ import logging\n \n from ._collections import RecentlyUsedContainer\n from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool\n-from .connectionpool import get_host, connection_from_url, port_by_scheme\n-from .exceptions import HostChangedError\n+from .connectionpool import connection_from_url, port_by_scheme\n from .request import RequestMethods\n+from .util import parse_url\n \n \n __all__ = ['PoolManager', 'ProxyManager', 'proxy_from_url']\n@@ -48,19 +48,29 @@ class PoolManager(RequestMethods):\n \n     \"\"\"\n \n-    # TODO: Make sure there are no memory leaks here.\n-\n     def __init__(self, num_pools=10, **connection_pool_kw):\n         self.connection_pool_kw = connection_pool_kw\n-        self.pools = RecentlyUsedContainer(num_pools)\n+        self.pools = RecentlyUsedContainer(num_pools,\n+                                           dispose_func=lambda p: p.close())\n \n-    def connection_from_host(self, host, port=80, scheme='http'):\n+    def clear(self):\n+        \"\"\"\n+        Empty our store of pools and direct them all to close.\n+\n+        This will not affect in-flight connections, but they will not be\n+        re-used after completion.\n+        \"\"\"\n+        self.pools.clear()\n+\n+    def connection_from_host(self, host, port=None, scheme='http'):\n         \"\"\"\n         Get a :class:`ConnectionPool` based on the host, port, and scheme.\n \n-        Note that an appropriate ``port`` value is required here to normalize\n-        connection pools in our container most effectively.\n+        If ``port`` isn't given, it will be derived from the ``scheme`` using\n+        ``urllib3.connectionpool.port_by_scheme``.\n         \"\"\"\n+        port = port or port_by_scheme.get(scheme, 80)\n+\n         pool_key = (scheme, host, port)\n \n         # If the scheme, host, or port doesn't match existing open connections,\n@@ -86,26 +96,36 @@ class PoolManager(RequestMethods):\n         Additional parameters are taken from the :class:`.PoolManager`\n         constructor.\n         \"\"\"\n-        scheme, host, port = get_host(url)\n+        u = parse_url(url)\n+        return self.connection_from_host(u.host, port=u.port, scheme=u.scheme)\n \n-        port = port or port_by_scheme.get(scheme, 80)\n-\n-        return self.connection_from_host(host, port=port, scheme=scheme)\n-\n-    def urlopen(self, method, url, **kw):\n+    def urlopen(self, method, url, redirect=True, **kw):\n         \"\"\"\n-        Same as :meth:`urllib3.connectionpool.HTTPConnectionPool.urlopen`.\n+        Same as :meth:`urllib3.connectionpool.HTTPConnectionPool.urlopen`\n+        with custom cross-host redirect logic and only sends the request-uri\n+        portion of the ``url``.\n \n-        ``url`` must be absolute, such that an appropriate\n+        The given ``url`` parameter must be absolute, such that an appropriate\n         :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.\n         \"\"\"\n-        conn = self.connection_from_url(url)\n-        try:\n-            return conn.urlopen(method, url, **kw)\n+        u = parse_url(url)\n+        conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)\n \n-        except HostChangedError as e:\n-            kw['retries'] = e.retries # Persist retries countdown\n-            return self.urlopen(method, e.url, **kw)\n+        kw['assert_same_host'] = False\n+        kw['redirect'] = False\n+\n+        response = conn.urlopen(method, u.request_uri, **kw)\n+\n+        redirect_location = redirect and response.get_redirect_location()\n+        if not redirect_location:\n+            return response\n+\n+        if response.status == 303:\n+            method = 'GET'\n+\n+        log.info(\"Redirecting %s -> %s\" % (url, redirect_location))\n+        kw['retries'] = kw.get('retries', 3) - 1 # Persist retries countdown\n+        return self.urlopen(method, redirect_location, **kw)\n \n \n class ProxyManager(RequestMethods):\n\n@@ -10,7 +10,7 @@ import zlib\n \n from io import BytesIO\n \n-from .exceptions import HTTPError\n+from .exceptions import DecodeError\n from .packages.six import string_types as basestring\n \n \n@@ -148,8 +148,8 @@ class HTTPResponse(object):\n             try:\n                 if decode_content and decoder:\n                     data = decoder(data)\n-            except IOError:\n-                raise HTTPError(\"Received response with content-encoding: %s, but \"\n+            except (IOError, zlib.error):\n+                raise DecodeError(\"Received response with content-encoding: %s, but \"\n                                   \"failed to decode it.\" % content_encoding)\n \n             if cache_content:\n\n@@ -6,6 +6,8 @@\n \n \n from base64 import b64encode\n+from collections import namedtuple\n+from socket import error as SocketError\n \n try:\n     from select import poll, POLLIN\n@@ -20,6 +22,152 @@ from .packages import six\n from .exceptions import LocationParseError\n \n \n+class Url(namedtuple('Url', ['scheme', 'auth', 'host', 'port', 'path', 'query', 'fragment'])):\n+    \"\"\"\n+    Datastructure for representing an HTTP URL. Used as a return value for\n+    :func:`parse_url`.\n+    \"\"\"\n+    slots = ()\n+\n+    def __new__(cls, scheme=None, auth=None, host=None, port=None, path=None, query=None, fragment=None):\n+        return super(Url, cls).__new__(cls, scheme, auth, host, port, path, query, fragment)\n+\n+    @property\n+    def hostname(self):\n+        \"\"\"For backwards-compatibility with urlparse. We're nice like that.\"\"\"\n+        return self.host\n+\n+    @property\n+    def request_uri(self):\n+        \"\"\"Absolute path including the query string.\"\"\"\n+        uri = self.path or '/'\n+\n+        if self.query is not None:\n+            uri += '?' + self.query\n+\n+        return uri\n+\n+\n+def split_first(s, delims):\n+    \"\"\"\n+    Given a string and an iterable of delimiters, split on the first found\n+    delimiter. Return two split parts and the matched delimiter.\n+\n+    If not found, then the first part is the full input string.\n+\n+    Example: ::\n+\n+        >>> split_first('foo/bar?baz', '?/=')\n+        ('foo', 'bar?baz', '/')\n+        >>> split_first('foo/bar?baz', '123')\n+        ('foo/bar?baz', '', None)\n+\n+    Scales linearly with number of delims. Not ideal for large number of delims.\n+    \"\"\"\n+    min_idx = None\n+    min_delim = None\n+    for d in delims:\n+        idx = s.find(d)\n+        if idx < 0:\n+            continue\n+\n+        if min_idx is None or idx < min_idx:\n+            min_idx = idx\n+            min_delim = d\n+\n+    if min_idx is None or min_idx < 0:\n+        return s, '', None\n+\n+    return s[:min_idx], s[min_idx+1:], min_delim\n+\n+\n+def parse_url(url):\n+    \"\"\"\n+    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n+    performed to parse incomplete urls. Fields not provided will be None.\n+\n+    Partly backwards-compatible with :mod:`urlparse`.\n+\n+    Example: ::\n+\n+        >>> parse_url('http://google.com/mail/')\n+        Url(scheme='http', host='google.com', port=None, path='/', ...)\n+        >>> prase_url('google.com:80')\n+        Url(scheme=None, host='google.com', port=80, path=None, ...)\n+        >>> prase_url('/foo?bar')\n+        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n+    \"\"\"\n+\n+    # While this code has overlap with stdlib's urlparse, it is much\n+    # simplified for our needs and less annoying.\n+    # Additionally, this imeplementations does silly things to be optimal\n+    # on CPython.\n+\n+    scheme = None\n+    auth = None\n+    host = None\n+    port = None\n+    path = None\n+    fragment = None\n+    query = None\n+\n+    # Scheme\n+    if '://' in url:\n+        scheme, url = url.split('://', 1)\n+\n+    # Find the earliest Authority Terminator\n+    # (http://tools.ietf.org/html/rfc3986#section-3.2)\n+    url, path_, delim = split_first(url, ['/', '?', '#'])\n+\n+    if delim:\n+        # Reassemble the path\n+        path = delim + path_\n+\n+    # Auth\n+    if '@' in url:\n+        auth, url = url.split('@', 1)\n+\n+    # IPv6\n+    if url and url[0] == '[':\n+        host, url = url[1:].split(']', 1)\n+\n+    # Port\n+    if ':' in url:\n+        _host, port = url.split(':', 1)\n+\n+        if not host:\n+            host = _host\n+\n+        if not port.isdigit():\n+            raise LocationParseError(\"Failed to parse: %s\" % url)\n+\n+        port = int(port)\n+\n+    elif not host and url:\n+        host = url\n+\n+    if not path:\n+        return Url(scheme, auth, host, port, path, query, fragment)\n+\n+    # Fragment\n+    if '#' in path:\n+        path, fragment = path.split('#', 1)\n+\n+    # Query\n+    if '?' in path:\n+        path, query = path.split('?', 1)\n+\n+    return Url(scheme, auth, host, port, path, query, fragment)\n+\n+\n+def get_host(url):\n+    \"\"\"\n+    Deprecated. Use :func:`.parse_url` instead.\n+    \"\"\"\n+    p = parse_url(url)\n+    return p.scheme or 'http', p.hostname, p.port\n+\n+\n def make_headers(keep_alive=None, accept_encoding=None, user_agent=None,\n                  basic_auth=None):\n     \"\"\"\n@@ -72,93 +220,12 @@ def make_headers(keep_alive=None, accept_encoding=None, user_agent=None,\n     return headers\n \n \n-def split_first(s, delims):\n-    \"\"\"\n-    Given a string and an iterable of delimiters, split on the first found\n-    delimiter. Return two split parts.\n-\n-    If not found, then the first part is the full input string.\n-\n-    Scales linearly with number of delims. Not ideal for large number of delims.\n-    \"\"\"\n-    min_idx = None\n-    for d in delims:\n-        idx = s.find(d)\n-        if idx < 0:\n-            continue\n-\n-        if not min_idx:\n-            min_idx = idx\n-        else:\n-            min_idx = min(idx, min_idx)\n-\n-    if min_idx < 0:\n-        return s, ''\n-\n-    return s[:min_idx], s[min_idx+1:]\n-\n-\n-def get_host(url):\n-    \"\"\"\n-    Given a url, return its scheme, host and port (None if it's not there).\n-\n-    For example: ::\n-\n-        >>> get_host('http://google.com/mail/')\n-        ('http', 'google.com', None)\n-        >>> get_host('google.com:80')\n-        ('http', 'google.com', 80)\n-    \"\"\"\n-\n-    # While this code has overlap with stdlib's urlparse, it is much\n-    # simplified for our needs and less annoying.\n-    # Additionally, this imeplementations does silly things to be optimal\n-    # on CPython.\n-\n-    scheme = 'http'\n-    host = None\n-    port = None\n-\n-    # Scheme\n-    if '://' in url:\n-        scheme, url = url.split('://', 1)\n-\n-    # Find the earliest Authority Terminator\n-    # (http://tools.ietf.org/html/rfc3986#section-3.2)\n-    url, _path = split_first(url, ['/', '?', '#'])\n-\n-    # Auth\n-    if '@' in url:\n-        _auth, url = url.split('@', 1)\n-\n-    # IPv6\n-    if url and url[0] == '[':\n-        host, url = url[1:].split(']', 1)\n-\n-    # Port\n-    if ':' in url:\n-        _host, port = url.split(':', 1)\n-\n-        if not host:\n-            host = _host\n-\n-        if not port.isdigit():\n-            raise LocationParseError(\"Failed to parse: %s\" % url)\n-\n-        port = int(port)\n-\n-    elif not host:\n-        host = url\n-\n-    return scheme, host, port\n-\n-\n def is_connection_dropped(conn):\n     \"\"\"\n     Returns True if the connection is dropped and should be closed.\n \n     :param conn:\n-        ``HTTPConnection`` object.\n+        :class:`httplib.HTTPConnection` object.\n \n     Note: For platforms like AppEngine, this will always return ``False`` to\n     let the platform handle connection recycling transparently for us.\n@@ -171,7 +238,10 @@ def is_connection_dropped(conn):\n         if not select: # Platform-specific: AppEngine\n             return False\n \n+        try:\n             return select([sock], [], [], 0.0)[0]\n+        except SocketError:\n+            return True\n \n     # This version is better on platforms that support it.\n     p = poll()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
