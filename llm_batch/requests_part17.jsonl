{"custom_id": "requests#e69a3a41f630fd580256f3b9b4004cbca1da6665", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 7 | Contributors (this commit): 1 | Commits (past 90d): 1 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -1,3 +1,3 @@\n from __future__ import absolute_import\n \n-from . import poster\n+from . import urllib3\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#3127a34298ec4a674916033b8d9678a1b57f828b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 5 | Files Changed: 2 | Hunks: 3 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 1599 | Contributors (this commit): 16 | Commits (past 90d): 82 | Contributors (cumulative): 19 | DMM Complexity: None\n\nDIFF:\n@@ -19,8 +19,5 @@ class Timeout(RequestException):\n class URLRequired(RequestException):\n     \"\"\"A valid URL is required to make a request.\"\"\"\n \n-class InvalidMethod(RequestException):\n-    \"\"\"An inappropriate method was attempted.\"\"\"\n-\n class TooManyRedirects(RequestException):\n     \"\"\"Too many redirects.\"\"\"\n\n@@ -9,7 +9,6 @@ requests.models\n import urllib\n import urllib2\n import socket\n-import codecs\n import zlib\n \n \n@@ -24,7 +23,7 @@ from .packages.poster.encode import multipart_encode\n from .packages.poster.streaminghttp import register_openers, get_handlers\n from .utils import dict_from_cookiejar, get_unicode_from_response, stream_decode_response_unicode, decode_gzip, stream_decode_gzip\n from .status_codes import codes\n-from .exceptions import RequestException, AuthenticationError, Timeout, URLRequired, InvalidMethod, TooManyRedirects\n+from .exceptions import RequestException, AuthenticationError, Timeout, URLRequired, TooManyRedirects\n \n \n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#aa5e47723621d86e249884c083b2d51d87135f47", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 70 | Lines Deleted: 9 | Files Changed: 1 | Hunks: 8 | Methods Changed: 4 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 79 | Churn Cumulative: 1647 | Contributors (this commit): 16 | Commits (past 90d): 81 | Contributors (cumulative): 16 | DMM Complexity: 1.0\n\nDIFF:\n@@ -16,11 +16,15 @@ from urllib2 import HTTPError\n from urlparse import urlparse, urlunparse, urljoin\n from datetime import datetime\n \n+\n+from .packages import urllib3\n+print dir(urllib3)\n+\n from .config import settings\n from .monkeys import Request as _Request, HTTPBasicAuthHandler, HTTPForcedBasicAuthHandler, HTTPDigestAuthHandler, HTTPRedirectHandler\n from .structures import CaseInsensitiveDict\n-from .packages.poster.encode import multipart_encode\n-from .packages.poster.streaminghttp import register_openers, get_handlers\n+# from .packages.poster.encode import multipart_encode\n+# from .packages.poster.streaminghttp import register_openers, get_handlers\n from .utils import dict_from_cookiejar, get_unicode_from_response, stream_decode_response_unicode, decode_gzip, stream_decode_gzip\n from .status_codes import codes\n from .exceptions import RequestException, AuthenticationError, Timeout, URLRequired, TooManyRedirects\n@@ -182,16 +186,15 @@ class Request(object):\n         def build(resp):\n \n             response = Response()\n-            response.status_code = getattr(resp, 'code', None)\n+            response.status_code = getattr(resp, 'status', None)\n \n             try:\n-                response.headers = CaseInsensitiveDict(getattr(resp.info(), 'dict', None))\n-                response.fo = resp\n+                response.headers = CaseInsensitiveDict(getattr(resp, 'headers', None))\n+                # response.fo = resp\n \n-                if self.cookiejar:\n-\n-                    response.cookies = dict_from_cookiejar(self.cookiejar)\n+                # if self.cookiejar:\n \n+                    # response.cookies = dict_from_cookiejar(self.cookiejar)\n \n             except AttributeError:\n                 pass\n@@ -216,7 +219,7 @@ class Request(object):\n                 (self.allow_redirects))\n             ):\n \n-                r.fo.close()\n+                # r.fo.close()\n \n                 if not len(history) < settings.max_redirects:\n                     raise TooManyRedirects()\n@@ -302,6 +305,64 @@ class Request(object):\n \n \n     def send(self, anyway=False):\n+        \"\"\"Sends the shit.\"\"\"\n+\n+        # Safety check.\n+        self._checks()\n+\n+        # Build the final URL.\n+        url = self._build_url()\n+\n+        # Setup Files.\n+        # Setup form data.\n+        #\n+        # def urlopen(self, method, url, body=None, headers=None, retries=3,\n+        #         redirect=True, assert_same_host=True):\n+                # req = _Request(url, data=self._enc_data, method=self.method)\n+\n+\n+        if not self.sent or anyway:\n+\n+            try:\n+\n+                pool = urllib3.connection_from_url(url, timeout=self.timeout)\n+\n+                r = pool.urlopen(\n+                    method=self.method,\n+                    url=url,\n+                    body=self.data,\n+                    headers=self.headers,\n+                    redirect=False,\n+                    assert_same_host=False\n+                )\n+\n+                r.socket = pool._get_conn().sock\n+\n+                # if self.cookiejar is not None:\n+                    # self.cookiejar.extract_cookies(resp, req)\n+\n+            # except (urllib2.HTTPError, urllib2.URLError), why:\n+            except Exception, why:\n+                # if hasattr(why, 'reason'):\n+                #     if isinstance(why.reason, socket.timeout):\n+                #         why = Timeout(why)\n+\n+                # self._build_response(why, is_error=True)\n+                print 'FUCK'\n+                print why\n+\n+            else:\n+                self._build_response(r)\n+                self.response.ok = True\n+\n+\n+        self.sent = self.response.ok\n+\n+        return self.sent\n+\n+\n+\n+    def old_send(self, anyway=False):\n         \"\"\"Sends the request. Returns True of successful, false if not.\n         If there was an HTTPError during transmission,\n         self.response.status_code will contain the HTTPError code.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#71d3490bcde6a6c595bc76a1244f059a7d7f4458", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 7 | Methods Changed: 4 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 15 | Churn Cumulative: 559 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 1 | DMM Complexity: 0.0\n\nDIFF:\n@@ -76,7 +76,7 @@ class HTTPResponse(object):\n         self.strict = strict\n \n     @staticmethod\n-    def from_httplib(r):\n+    def from_httplib(r, block=True):\n         \"\"\"\n         Given an httplib.HTTPResponse instance, return a corresponding\n         urllib3.HTTPResponse object.\n@@ -84,6 +84,8 @@ class HTTPResponse(object):\n         NOTE: This method will perform r.read() which will have side effects\n         on the original http.HTTPResponse object.\n         \"\"\"\n+\n+        if block:\n             tmp_data = r.read()\n             try:\n                 if r.getheader('content-encoding') == 'gzip':\n@@ -106,14 +108,19 @@ class HTTPResponse(object):\n                 raise HTTPError(\"Received response with content-encoding: %s, \"\n                                 \"but failed to decompress it.\" %\n                                 (r.getheader('content-encoding')))\n+        else:\n+            data = None\n \n-        return HTTPResponse(data=data,\n+        resp = HTTPResponse(data=data,\n                     headers=dict(r.getheaders()),\n                     status=r.status,\n                     version=r.version,\n                     reason=r.reason,\n                     strict=r.strict)\n \n+        resp._raw = r\n+        return resp\n+\n     # Backwards-compatibility methods for httplib.HTTPResponse\n     def getheaders(self):\n         return self.headers\n@@ -262,7 +269,7 @@ class HTTPConnectionPool(object):\n                 get_host(url) == (self.scheme, self.host, self.port))\n \n     def urlopen(self, method, url, body=None, headers=None, retries=3,\n-                redirect=True, assert_same_host=True):\n+                redirect=True, assert_same_host=True, block=True):\n         \"\"\"\n         Get a connection from the pool and perform an HTTP request.\n \n@@ -323,7 +330,7 @@ class HTTPConnectionPool(object):\n             # from_httplib will perform httplib_response.read() which will have\n             # the side effect of letting us use this connection for another\n             # request.\n-            response = HTTPResponse.from_httplib(httplib_response)\n+            response = HTTPResponse.from_httplib(httplib_response, block=block)\n \n             # Put the connection back to be reused\n             self._put_conn(conn)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#a3cc97128b9511659e136afb9b3fa42ae7490bda", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 20 | Lines Deleted: 13 | Files Changed: 1 | Hunks: 12 | Methods Changed: 8 | Complexity Δ (Sum/Max): 6/6 | Churn Δ: 33 | Churn Cumulative: 1680 | Contributors (this commit): 16 | Commits (past 90d): 82 | Contributors (cumulative): 16 | DMM Complexity: 0.0\n\nDIFF:\n@@ -18,7 +18,7 @@ from datetime import datetime\n \n \n from .packages import urllib3\n-print dir(urllib3)\n+# print dir(urllib3)\n \n from .config import settings\n from .monkeys import Request as _Request, HTTPBasicAuthHandler, HTTPForcedBasicAuthHandler, HTTPDigestAuthHandler, HTTPRedirectHandler\n@@ -190,7 +190,7 @@ class Request(object):\n \n             try:\n                 response.headers = CaseInsensitiveDict(getattr(resp, 'headers', None))\n-                # response.fo = resp\n+                response.raw = resp._raw\n \n                 # if self.cookiejar:\n \n@@ -202,13 +202,12 @@ class Request(object):\n             if is_error:\n                 response.error = resp\n \n-            response.url = getattr(resp, 'url', None)\n-\n             return response\n \n \n         history = []\n \n+\n         r = build(resp)\n \n         if r.status_code in REDIRECT_STATI and not self.redirect:\n@@ -219,7 +218,7 @@ class Request(object):\n                 (self.allow_redirects))\n             ):\n \n-                # r.fo.close()\n+                r.raw.close()\n \n                 if not len(history) < settings.max_redirects:\n                     raise TooManyRedirects()\n@@ -333,10 +332,12 @@ class Request(object):\n                     body=self.data,\n                     headers=self.headers,\n                     redirect=False,\n-                    assert_same_host=False\n+                    assert_same_host=False,\n+                    block=True\n                 )\n \n-                r.socket = pool._get_conn().sock\n+                # r.socket = pool._get_conn().sock\n+                # r.fo = r.data\n \n                 # if self.cookiejar is not None:\n                     # self.cookiejar.extract_cookies(resp, req)\n@@ -468,10 +469,7 @@ class Response(object):\n         self.headers = CaseInsensitiveDict()\n \n         #: File-like object representation of response (for advanced usage).\n-        self.fo = None\n-\n-        #: Final URL location of Response.\n-        self.url = None\n+        self.raw = None\n \n         #: True if no :attr:`error` occured.\n         self.ok = False\n@@ -512,7 +510,7 @@ class Response(object):\n \n         def generate():\n             while 1:\n-                chunk = self.fo.read(chunk_size)\n+                chunk = self.raw.read(chunk_size)\n                 if not chunk:\n                     break\n                 yield chunk\n@@ -540,7 +538,7 @@ class Response(object):\n                                'already consumed')\n \n         # Read the contents.\n-        self._content = self.fo.read()\n+        self._content = self.raw.read()\n \n         # Decode GZip'd content.\n         if 'gzip' in self.headers.get('content-encoding', ''):\n@@ -559,9 +557,18 @@ class Response(object):\n \n     def raise_for_status(self):\n         \"\"\"Raises stored :class:`HTTPError` or :class:`URLError`, if one occured.\"\"\"\n+\n         if self.error:\n             raise self.error\n \n+        if (self.status_code >= 300) and (self.status_code < 400):\n+            raise Exception('300 yo')\n+\n+        elif (self.status_code >= 400) and (self.status_code < 500):\n+            raise Exception('400 yo')\n+\n+        elif (self.status_code >= 500) and (self.status_code < 600):\n+            raise Exception('500 yo')\n \n \n class AuthManager(object):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#2d38f518348625cc9c6b8f5ee63a86bda784630e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 34 | Contributors (this commit): 3 | Commits (past 90d): 3 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -10,9 +10,6 @@ class RequestException(Exception):\n     \"\"\"There was an ambiguous exception that occured while handling your\n     request.\"\"\"\n \n-class AuthenticationError(RequestException):\n-    \"\"\"The authentication credentials provided were invalid.\"\"\"\n-\n class Timeout(RequestException):\n     \"\"\"The request timed out.\"\"\"\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#2a2e7bd19082af86f4c4ed7c00d68b99970b7bb8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 7 | Methods Changed: 4 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 17 | Churn Cumulative: 627 | Contributors (this commit): 7 | Commits (past 90d): 22 | Contributors (cumulative): 7 | DMM Complexity: 0.0\n\nDIFF:\n@@ -23,7 +23,8 @@ __all__ = ('request', 'get', 'head', 'post', 'patch', 'put', 'delete')\n \n def request(method, url,\n     params=None, data=None, headers=None, cookies=None, files=None, auth=None,\n-    timeout=None, allow_redirects=False, proxies=None, hooks=None):\n+    timeout=None, allow_redirects=False, proxies=None, hooks=None,\n+    _connection=None):\n \n     \"\"\"Constructs and sends a :class:`Request <Request>`.\n     Returns :class:`Response <Response>` object.\n@@ -39,6 +40,7 @@ def request(method, url,\n     :param timeout: (optional) Float describing the timeout of the request.\n     :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n     :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n+    :param _connection: (optional) An HTTP Connection to re-use.\n     \"\"\"\n \n     method = str(method).upper()\n@@ -64,19 +66,20 @@ def request(method, url,\n         auth = auth,\n         timeout = timeout or config.settings.timeout,\n         allow_redirects = allow_redirects,\n-        proxies = proxies or config.settings.proxies,\n+        proxies = proxies or config.settings.proxies\n     )\n \n     # Arguments manipulation hook.\n     args = dispatch_hook('args', hooks, args)\n \n+    # Create Request object.\n     r = Request(**args)\n \n     # Pre-request hook.\n     r = dispatch_hook('pre_request', hooks, r)\n \n     # Send the HTTP Request.\n-    r.send()\n+    r.send(connection=_connection)\n \n     # Post-request hook.\n     r = dispatch_hook('post_request', hooks, r)\n@@ -94,8 +97,8 @@ def get(url, **kwargs):\n     :param **kwargs: Optional arguments that ``request`` takes.\n     \"\"\"\n \n-    if \"allow_redirects\" not in kwargs:\n-        kwargs[\"allow_redirects\"] = True\n+    if 'allow_redirects' not in kwargs:\n+        kwargs['allow_redirects'] = True\n \n     return request('get', url, **kwargs)\n \n@@ -107,8 +110,8 @@ def head(url, **kwargs):\n     :param **kwargs: Optional arguments that ``request`` takes.\n     \"\"\"\n \n-    if \"allow_redirects\" not in kwargs:\n-        kwargs[\"allow_redirects\"] = True\n+    if 'allow_redirects' not in kwargs:\n+        kwargs['allow_redirects'] = True\n \n     return request('head', url, **kwargs)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#645933a5da8a6554045f918bfca7798bed7c4b7c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 26 | Lines Deleted: 19 | Files Changed: 1 | Hunks: 14 | Methods Changed: 5 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 45 | Churn Cumulative: 1725 | Contributors (this commit): 16 | Commits (past 90d): 83 | Contributors (cumulative): 16 | DMM Complexity: 0.8333333333333334\n\nDIFF:\n@@ -21,13 +21,10 @@ from .packages import urllib3\n # print dir(urllib3)\n \n from .config import settings\n-from .monkeys import Request as _Request, HTTPBasicAuthHandler, HTTPForcedBasicAuthHandler, HTTPDigestAuthHandler, HTTPRedirectHandler\n from .structures import CaseInsensitiveDict\n-# from .packages.poster.encode import multipart_encode\n-# from .packages.poster.streaminghttp import register_openers, get_handlers\n from .utils import dict_from_cookiejar, get_unicode_from_response, stream_decode_response_unicode, decode_gzip, stream_decode_gzip\n from .status_codes import codes\n-from .exceptions import RequestException, AuthenticationError, Timeout, URLRequired, TooManyRedirects\n+from .exceptions import RequestException, Timeout, URLRequired, TooManyRedirects\n \n \n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n@@ -209,6 +206,7 @@ class Request(object):\n \n \n         r = build(resp)\n+        r._response = resp\n \n         if r.status_code in REDIRECT_STATI and not self.redirect:\n \n@@ -303,7 +301,7 @@ class Request(object):\n             return self.url\n \n \n-    def send(self, anyway=False):\n+    def send(self, connection=None, anyway=False):\n         \"\"\"Sends the shit.\"\"\"\n \n         # Safety check.\n@@ -320,20 +318,24 @@ class Request(object):\n                 # req = _Request(url, data=self._enc_data, method=self.method)\n \n \n-        if not self.sent or anyway:\n+        if (anyway) or (not self.sent):\n \n             try:\n+                if not connection:\n+                    connection = urllib3.connection_from_url(url,\n+                        timeout=self.timeout)\n+                    do_block = False\n+                else:\n+                    do_block = True\n \n-                pool = urllib3.connection_from_url(url, timeout=self.timeout)\n-\n-                r = pool.urlopen(\n+                r = connection.urlopen(\n                     method=self.method,\n                     url=url,\n                     body=self.data,\n                     headers=self.headers,\n                     redirect=False,\n                     assert_same_host=False,\n-                    block=True\n+                    block=do_block\n                 )\n \n                 # r.socket = pool._get_conn().sock\n@@ -524,6 +526,7 @@ class Response(object):\n             gen = stream_decode_response_unicode(gen, self)\n         return gen\n \n+\n     @property\n     def content(self):\n         \"\"\"Content of the response, in bytes or unicode\n@@ -534,11 +537,13 @@ class Response(object):\n             return self._content\n \n         if self._content_consumed:\n-            raise RuntimeError('The content for this response was '\n-                               'already consumed')\n+            raise RuntimeError(\n+                'The content for this response was already consumed')\n \n         # Read the contents.\n-        self._content = self.raw.read()\n+        # print self.raw.__dict__\n+        self._content = self.raw.read() or self._response.data\n+        # print self.raw.__dict__\n \n         # Decode GZip'd content.\n         if 'gzip' in self.headers.get('content-encoding', ''):\n@@ -556,7 +561,9 @@ class Response(object):\n \n \n     def raise_for_status(self):\n-        \"\"\"Raises stored :class:`HTTPError` or :class:`URLError`, if one occured.\"\"\"\n+        \"\"\"Raises stored :class:`HTTPError` or :class:`URLError`,\n+        if one occured.\n+        \"\"\"\n \n         if self.error:\n             raise self.error\n@@ -729,11 +736,11 @@ class AuthObject(object):\n     \"\"\"\n \n     _handlers = {\n-        'basic': HTTPBasicAuthHandler,\n-        'forced_basic': HTTPForcedBasicAuthHandler,\n-        'digest': HTTPDigestAuthHandler,\n-        'proxy_basic': urllib2.ProxyBasicAuthHandler,\n-        'proxy_digest': urllib2.ProxyDigestAuthHandler\n+        # 'basic': HTTPBasicAuthHandler,\n+        # 'forced_basic': HTTPForcedBasicAuthHandler,\n+        # 'digest': HTTPDigestAuthHandler,\n+        # 'proxy_basic': urllib2.ProxyBasicAuthHandler,\n+        # 'proxy_digest': urllib2.ProxyDigestAuthHandler\n     }\n \n     def __init__(self, username, password, handler='forced_basic', realm=None):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#18270e1059c8eaea2bced14caad2d35e78fe7e8a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 18 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 8 | Methods Changed: 1 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 25 | Churn Cumulative: 1750 | Contributors (this commit): 16 | Commits (past 90d): 84 | Contributors (cumulative): 16 | DMM Complexity: 0.0\n\nDIFF:\n@@ -311,23 +311,37 @@ class Request(object):\n         url = self._build_url()\n \n         # Setup Files.\n+        if self.files:\n+            pass\n+\n         # Setup form data.\n-        #\n-        # def urlopen(self, method, url, body=None, headers=None, retries=3,\n-        #         redirect=True, assert_same_host=True):\n+        elif self.data:\n+            pass\n+\n+        # Setup cookies.\n+        elif self.cookies:\n+            pass\n+\n+\n         # req = _Request(url, data=self._enc_data, method=self.method)\n \n-\n+        # Only send the Request if new or forced.\n         if (anyway) or (not self.sent):\n \n             try:\n+\n+                # Create a new HTTP connection, since one wasn't passed in.\n                 if not connection:\n                     connection = urllib3.connection_from_url(url,\n                         timeout=self.timeout)\n+\n+                    # One-off request. Delay fetching the content until needed.\n                     do_block = False\n                 else:\n+                    # Part of a connection pool, so no streaming. Sorry!\n                     do_block = True\n \n+                # Create the connection.\n                 r = connection.urlopen(\n                     method=self.method,\n                     url=url,\n@@ -338,9 +352,6 @@ class Request(object):\n                     block=do_block\n                 )\n \n-                # r.socket = pool._get_conn().sock\n-                # r.fo = r.data\n-\n                 # if self.cookiejar is not None:\n                     # self.cookiejar.extract_cookies(resp, req)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#7f3f641fb81463ae56d4e70b2de7daeb39e5d09b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 9 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 17 | Churn Cumulative: 1767 | Contributors (this commit): 16 | Commits (past 90d): 85 | Contributors (cumulative): 16 | DMM Complexity: None\n\nDIFF:\n@@ -285,19 +285,34 @@ class Request(object):\n         \"\"\"Build the actual URL to use.\"\"\"\n \n         # Support for unicode domain names and paths.\n-        scheme, netloc, path, params, query, fragment = urlparse(self.url)\n+        (scheme, netloc, path, params, query, fragment) = urlparse(self.url)\n+\n+        # International Domain Name\n         netloc = netloc.encode('idna')\n+\n+        # Encode the path to to utf-8.\n         if isinstance(path, unicode):\n             path = path.encode('utf-8')\n+\n+        # URL-encode the path.\n         path = urllib.quote(path, safe=\"%/:=&?~#+!$,;'@()*[]\")\n+\n+        # Turn it back into a bytestring.\n         self.url = str(urlunparse([scheme, netloc, path, params, query, fragment]))\n \n+        # Query Parameters?\n         if self._enc_params:\n+\n+            # If query parameters already exist in the URL, append.\n             if urlparse(self.url).query:\n                 return '%s&%s' % (self.url, self._enc_params)\n+\n+            # Otherwise, have at it.\n             else:\n                 return '%s?%s' % (self.url, self._enc_params)\n+\n         else:\n+            # Kosher URL.\n             return self.url\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#332f55e552326323e205dd5069a1726439cca3cd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 27 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 21 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 31 | Churn Cumulative: 1798 | Contributors (this commit): 16 | Commits (past 90d): 86 | Contributors (cumulative): 16 | DMM Complexity: None\n\nDIFF:\n@@ -202,27 +202,40 @@ class Request(object):\n             return response\n \n \n+        # Request collector.\n         history = []\n \n-\n+        # Create the lone response object.\n         r = build(resp)\n+\n+        # Store the HTTP response, just in case.\n         r._response = resp\n \n+        # It's a redirect, and we're not already in a redirect loop.\n         if r.status_code in REDIRECT_STATI and not self.redirect:\n \n             while (\n+                # There's a `Location` header.\n                 ('location' in r.headers) and\n+\n+                # See other response.\n                 ((r.status_code is codes.see_other) or\n+\n+                # Opt-in to redirects for non- idempotent methods.\n                 (self.allow_redirects))\n             ):\n \n+                # We already redirected. Don't keep it alive.\n                 r.raw.close()\n \n-                if not len(history) < settings.max_redirects:\n+                # Woah, this is getting crazy.\n+                if len(history) >= settings.max_redirects:\n                     raise TooManyRedirects()\n \n+                # Add the old request to the history collector.\n                 history.append(r)\n \n+                # Redirect to...\n                 url = r.headers['location']\n \n                 # Handle redirection without scheme (see: RFC 1808 Section 4)\n@@ -238,23 +251,33 @@ class Request(object):\n                     parsed_url[2] = urllib.quote(parsed_url[2], safe=\"%/:=&?~#+!$,;'@()*[]\")\n                     url = urljoin(r.url, str(urlunparse(parsed_url)))\n \n+                # If 303, convert to idempotent GET.\n                 # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n                 if r.status_code is codes.see_other:\n                     method = 'GET'\n                 else:\n                     method = self.method\n \n+                # Create the new Request.\n                 request = Request(\n                     url, self.headers, self.files, method,\n                     self.data, self.params, self.auth, self.cookiejar,\n+\n+                    # Flag as part of a redirect loop.\n                     redirect=True\n                 )\n+\n+                # Send her away!\n                 request.send()\n                 r = request.response\n \n+            # Insert collected history.\n             r.history = history\n \n+        # Attach Response to Request.\n         self.response = r\n+\n+        # Give Response some context.\n         self.response.request = self\n \n \n@@ -344,7 +367,6 @@ class Request(object):\n         if (anyway) or (not self.sent):\n \n             try:\n-\n                 # Create a new HTTP connection, since one wasn't passed in.\n                 if not connection:\n                     connection = urllib3.connection_from_url(url,\n@@ -353,7 +375,7 @@ class Request(object):\n                     # One-off request. Delay fetching the content until needed.\n                     do_block = False\n                 else:\n-                    # Part of a connection pool, so no streaming. Sorry!\n+                    # Part of a connection pool, so no fancy stuff. Sorry!\n                     do_block = True\n \n                 # Create the connection.\n@@ -367,6 +389,7 @@ class Request(object):\n                     block=do_block\n                 )\n \n+                # Extract cookies.\n                 # if self.cookiejar is not None:\n                     # self.cookiejar.extract_cookies(resp, req)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#04bcab80574c7c2f1cf8e090ca34cd44a96b1e64", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 5 | Churn Cumulative: 1803 | Contributors (this commit): 16 | Commits (past 90d): 87 | Contributors (cumulative): 16 | DMM Complexity: 1.0\n\nDIFF:\n@@ -357,9 +357,8 @@ class Request(object):\n             pass\n \n         # Setup cookies.\n-        elif self.cookies:\n-            pass\n-\n+        # elif self.cookies:\n+            # pass\n \n         # req = _Request(url, data=self._enc_data, method=self.method)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#95b0549c75c61fe0b759400713112de357ae74b1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 8 | Churn Cumulative: 533 | Contributors (this commit): 5 | Commits (past 90d): 31 | Contributors (cumulative): 5 | DMM Complexity: 0.6666666666666666\n\nDIFF:\n@@ -181,12 +181,12 @@ def unicode_from_html(content):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n     encoding = get_encoding_from_headers(r.headers)\n-    if encoding is None:\n+    try:\n+        decoder = codecs.getincrementaldecoder(str(encoding))(errors='replace')\n+    except LookupError:\n         for item in iterator:\n             yield item\n         return\n-\n-    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n@@ -221,6 +221,8 @@ def get_unicode_from_response(r):\n             return unicode(r.content, encoding)\n         except UnicodeError:\n             tried_encodings.append(encoding)\n+        except LookupError:\n+            return r.content\n \n     # Fall back:\n     try:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#5345a89dc5121daffddcdab008ddfb324d6b87c8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 49 | Lines Deleted: 56 | Files Changed: 7 | Hunks: 66 | Methods Changed: 8 | Complexity Δ (Sum/Max): -14/0 | Churn Δ: 105 | Churn Cumulative: 3771 | Contributors (this commit): 21 | Commits (past 90d): 147 | Contributors (cumulative): 40 | DMM Complexity: 0.6666666666666666\n\nDIFF:\n@@ -6,8 +6,23 @@ requests.config\n \n This module provides the Requests settings feature set.\n \n+settings parameters:\n+\n+TODO: Verify!!!\n+TODO: Make sure format is acceptabl/cool\n+- :base_headers: - Sets default User-Agent to `python-requests.org`\n+- :accept_gzip:  - Whether or not to accept gzip-compressed data\n+- :proxies: - http proxies?\n+- :verbose: - display verbose information?\n+- :timeout: - timeout time until request terminates\n+- :max_redirects: - maximum number of allowed redirects?\n+- :decode_unicode: - whether or not to accept unicode?\n+\n+Used globally\n+\n \"\"\"\n \n+\n class Settings(object):\n \n     def __init__(self, **kwargs):\n\n@@ -6,21 +6,27 @@ requests.exceptions\n \n \"\"\"\n \n+\n class RequestException(Exception):\n     \"\"\"There was an ambiguous exception that occured while handling your\n     request.\"\"\"\n \n+\n class AuthenticationError(RequestException):\n     \"\"\"The authentication credentials provided were invalid.\"\"\"\n \n+\n class Timeout(RequestException):\n     \"\"\"The request timed out.\"\"\"\n \n+\n class URLRequired(RequestException):\n     \"\"\"A valid URL is required to make a request.\"\"\"\n \n+\n class InvalidMethod(RequestException):\n     \"\"\"An inappropriate method was attempted.\"\"\"\n \n+\n class TooManyRedirects(RequestException):\n     \"\"\"Too many redirects.\"\"\"\n\n@@ -30,7 +30,6 @@ from .exceptions import RequestException, AuthenticationError, Timeout, URLRequi\n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n \n \n-\n class Request(object):\n     \"\"\"The :class:`Request <Request>` object. It carries out all functionality of\n     Requests. Recommended interface is with the Requests functions.\n@@ -96,7 +95,6 @@ class Request(object):\n         #: True if Request has been sent.\n         self.sent = False\n \n-\n         # Header manipulation and defaults.\n \n         if settings.accept_gzip:\n@@ -113,18 +111,15 @@ class Request(object):\n \n         self.headers = headers\n \n-\n     def __repr__(self):\n         return '<Request [%s]>' % (self.method)\n \n-\n     def _checks(self):\n         \"\"\"Deterministic checks for consistency.\"\"\"\n \n         if not self.url:\n             raise URLRequired\n \n-\n     def _get_opener(self):\n         \"\"\"Creates appropriate opener object for urllib2.\"\"\"\n \n@@ -173,13 +168,11 @@ class Request(object):\n \n         return opener.open\n \n-\n     def _build_response(self, resp, is_error=False):\n         \"\"\"Build internal :class:`Response <Response>` object\n         from given response.\n         \"\"\"\n \n-\n         def build(resp):\n \n             response = Response()\n@@ -193,7 +186,6 @@ class Request(object):\n \n                     response.cookies = dict_from_cookiejar(self.cookiejar)\n \n-\n             except AttributeError:\n                 pass\n \n@@ -204,7 +196,6 @@ class Request(object):\n \n             return response\n \n-\n         history = []\n \n         r = build(resp)\n@@ -258,7 +249,6 @@ class Request(object):\n         self.response = r\n         self.response.request = self\n \n-\n     @staticmethod\n     def _encode_params(data):\n         \"\"\"Encode parameters in a piece of data.\n@@ -276,22 +266,28 @@ class Request(object):\n             for k, vs in data.items():\n                 for v in isinstance(vs, list) and vs or [vs]:\n                     result.append((k.encode('utf-8') if isinstance(k, unicode) else k,\n-                                   v.encode('utf-8') if isinstance(v, unicode) else v))\n-            return result, urllib.urlencode(result, doseq=True)\n+                                   v.encode('utf-8') if isinstance(v, unicode) else v)\n+                    )\n+            return (result, urllib.urlencode(result, doseq=True))\n+\n         else:\n             return data, data\n \n-\n     def _build_url(self):\n         \"\"\"Build the actual URL to use.\"\"\"\n \n         # Support for unicode domain names and paths.\n         scheme, netloc, path, params, query, fragment = urlparse(self.url)\n         netloc = netloc.encode('idna')\n+\n         if isinstance(path, unicode):\n             path = path.encode('utf-8')\n+\n         path = urllib.quote(path, safe=\"%/:=&?~#+!$,;'@()*[]\")\n-        self.url = str(urlunparse([ scheme, netloc, path, params, query, fragment ]))\n+\n+        self.url = str(urlunparse(\n+          [scheme, netloc, path, params, query, fragment]\n+         ))\n \n         if self._enc_params:\n             if urlparse(self.url).query:\n@@ -301,7 +297,6 @@ class Request(object):\n         else:\n             return self.url\n \n-\n     def send(self, anyway=False):\n         \"\"\"Sends the request. Returns True of successful, false if not.\n         If there was an HTTPError during transmission,\n@@ -321,7 +316,6 @@ class Request(object):\n                 datetime.now().isoformat(), self.method, self.url\n             ))\n \n-\n         url = self._build_url()\n         if self.method in ('GET', 'HEAD', 'DELETE'):\n             req = _Request(url, method=self.method)\n@@ -381,17 +375,17 @@ class Request(object):\n                 self._build_response(resp)\n                 self.response.ok = True\n \n-\n         self.sent = self.response.ok\n \n         return self.sent\n \n \n class Response(object):\n-    \"\"\"The core :class:`Response <Response>` object. All\n-    :class:`Request <Request>` objects contain a\n-    :class:`response <Response>` attribute, which is an instance\n-    of this class.\n+    \"\"\"The core :class:`Response <Response>` object.\n+\n+\n+    All :class:`Request <Request>` objects contain a :class:`response\n+    <Response>` attribute, which is an instance of this class.\n     \"\"\"\n \n     def __init__(self):\n@@ -430,11 +424,9 @@ class Response(object):\n         #: A dictionary of Cookies the server sent back.\n         self.cookies = None\n \n-\n     def __repr__(self):\n         return '<Response [%s]>' % (self.status_code)\n \n-\n     def __nonzero__(self):\n         \"\"\"Returns true if :attr:`status_code` is 'OK'.\"\"\"\n \n@@ -496,14 +488,12 @@ class Response(object):\n         self._content_consumed = True\n         return self._content\n \n-\n     def raise_for_status(self):\n         \"\"\"Raises stored :class:`HTTPError` or :class:`URLError`, if one occured.\"\"\"\n         if self.error:\n             raise self.error\n \n \n-\n class AuthManager(object):\n     \"\"\"Requests Authentication Manager.\"\"\"\n \n@@ -516,16 +506,13 @@ class AuthManager(object):\n \n         return singleton\n \n-\n     def __init__(self):\n         self.passwd = {}\n         self._auth = {}\n \n-\n     def __repr__(self):\n         return '<AuthManager [%s]>' % (self.method)\n \n-\n     def add_auth(self, uri, auth):\n         \"\"\"Registers AuthObject to AuthManager.\"\"\"\n \n@@ -540,7 +527,6 @@ class AuthManager(object):\n \n         self._auth[uri] = auth\n \n-\n     def add_password(self, realm, uri, user, passwd):\n         \"\"\"Adds password to AuthManager.\"\"\"\n         # uri could be a single URI or a sequence\n@@ -553,7 +539,6 @@ class AuthManager(object):\n             self.passwd[reduced_uri] = {}\n         self.passwd[reduced_uri] = (user, passwd)\n \n-\n     def find_user_password(self, realm, authuri):\n         for uris, authinfo in self.passwd.iteritems():\n             reduced_authuri = self.reduce_uri(authuri, False)\n@@ -563,7 +548,6 @@ class AuthManager(object):\n \n         return (None, None)\n \n-\n     def get_auth(self, uri):\n         (in_domain, in_path) = self.reduce_uri(uri, False)\n \n@@ -574,7 +558,6 @@ class AuthManager(object):\n                 if path in in_path:\n                     return authority\n \n-\n     def reduce_uri(self, uri, default_port=True):\n         \"\"\"Accept authority or URI and extract only the authority and path.\"\"\"\n \n@@ -603,7 +586,6 @@ class AuthManager(object):\n \n         return authority, path\n \n-\n     def is_suburi(self, base, test):\n         \"\"\"Check if test is below base in a URI tree\n \n@@ -618,11 +600,9 @@ class AuthManager(object):\n             return True\n         return False\n \n-\n     def empty(self):\n         self.passwd = {}\n \n-\n     def remove(self, uri, realm=None):\n         # uri could be a single URI or a sequence\n         if isinstance(uri, basestring):\n@@ -632,7 +612,6 @@ class AuthManager(object):\n             reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])\n             del self.passwd[reduced_uri][realm]\n \n-\n     def __contains__(self, uri):\n         # uri could be a single URI or a sequence\n         if isinstance(uri, basestring):\n@@ -648,12 +627,12 @@ class AuthManager(object):\n auth_manager = AuthManager()\n \n \n-\n class AuthObject(object):\n-    \"\"\"The :class:`AuthObject` is a simple HTTP Authentication token. When\n-    given to a Requests function, it enables Basic HTTP Authentication for that\n-    Request. You can also enable Authorization for domain realms with AutoAuth.\n-    See AutoAuth for more details.\n+    \"\"\"The :class:`AuthObject` is a simple HTTP Authentication token.\n+\n+    When given to a Requests function, it enables Basic HTTP Authentication\n+    for that Request. You can also enable Authorization for domain realms\n+    with AutoAuth. See AutoAuth for more details.\n \n     :param username: Username to authenticate with.\n     :param password: Password for given username.\n\n@@ -8,8 +8,9 @@ Urllib2 Monkey patches.\n \n \"\"\"\n \n-import urllib2\n import re\n+import urllib2\n+\n \n class Request(urllib2.Request):\n     \"\"\"Hidden wrapper around the urllib2.Request object. Allows for manual\n@@ -35,7 +36,6 @@ class HTTPRedirectHandler(urllib2.HTTPRedirectHandler):\n     http_error_302 = http_error_303 = http_error_307 = http_error_301\n \n \n-\n class HTTPBasicAuthHandler(urllib2.HTTPBasicAuthHandler):\n     \"\"\"HTTP Basic Auth Handler with authentication loop fixes.\"\"\"\n \n@@ -44,14 +44,12 @@ class HTTPBasicAuthHandler(urllib2.HTTPBasicAuthHandler):\n         self.retried_req = None\n         self.retried = 0\n \n-\n     def reset_retry_count(self):\n         # Python 2.6.5 will call this on 401 or 407 errors and thus loop\n         # forever. We disable reset_retry_count completely and reset in\n         # http_error_auth_reqed instead.\n         pass\n \n-\n     def http_error_auth_reqed(self, auth_header, host, req, headers):\n         # Reset the retry counter once for each request.\n         if req is not self.retried_req:\n@@ -63,7 +61,6 @@ class HTTPBasicAuthHandler(urllib2.HTTPBasicAuthHandler):\n         )\n \n \n-\n class HTTPForcedBasicAuthHandler(HTTPBasicAuthHandler):\n     \"\"\"HTTP Basic Auth Handler with forced Authentication.\"\"\"\n \n@@ -74,7 +71,6 @@ class HTTPForcedBasicAuthHandler(HTTPBasicAuthHandler):\n     def __init__(self, *args, **kwargs):\n         HTTPBasicAuthHandler.__init__(self, *args, **kwargs)\n \n-\n     def http_error_401(self, req, fp, code, msg, headers):\n         url = req.get_full_url()\n         response = self._http_error_auth_reqed('www-authenticate', url, req, headers)\n@@ -83,7 +79,6 @@ class HTTPForcedBasicAuthHandler(HTTPBasicAuthHandler):\n \n     http_error_404 = http_error_401\n \n-\n     def _http_error_auth_reqed(self, authreq, host, req, headers):\n \n         authreq = headers.get(authreq, None)\n@@ -116,7 +111,6 @@ class HTTPForcedBasicAuthHandler(HTTPBasicAuthHandler):\n             return response\n \n \n-\n class HTTPDigestAuthHandler(urllib2.HTTPDigestAuthHandler):\n \n     def __init__(self, *args, **kwargs):\n\n@@ -15,13 +15,11 @@ from . import api\n from .utils import add_dict_to_cookiejar\n \n \n-\n class Session(object):\n     \"\"\"A Requests session.\"\"\"\n \n     __attrs__ = ['headers', 'cookies', 'auth', 'timeout', 'proxies', 'hooks']\n \n-\n     def __init__(self, **kwargs):\n \n         # Set up a CookieJar to be used by default\n@@ -34,7 +32,6 @@ class Session(object):\n         # Map and wrap requests.api methods\n         self._map_api_methods()\n \n-\n     def __repr__(self):\n         return '<requests-client at 0x%x>' % (id(self))\n \n@@ -45,7 +42,6 @@ class Session(object):\n         # print args\n         pass\n \n-\n     def _map_api_methods(self):\n         \"\"\"Reads each available method from requests.api and decorates\n         them with a wrapper, which inserts any instance-local attributes\n\n@@ -8,6 +8,7 @@ Datastructures that power Requests.\n \n \"\"\"\n \n+\n class CaseInsensitiveDict(dict):\n     \"\"\"Case-insensitive Dictionary\n \n@@ -46,6 +47,7 @@ class CaseInsensitiveDict(dict):\n         else:\n             return default\n \n+\n class LookupDict(dict):\n     \"\"\"Dictionary lookup object.\"\"\"\n \n\n@@ -54,7 +54,6 @@ def header_expand(headers):\n         if not len(headers) == i + 1:\n                 collector.append(', ')\n \n-\n     # Remove trailing seperators.\n     if collector[-1] in (', ', '; '):\n         del collector[-1]\n@@ -62,7 +61,6 @@ def header_expand(headers):\n     return ''.join(collector)\n \n \n-\n def dict_from_cookiejar(cj):\n     \"\"\"Returns a key/value dictionary from a CookieJar.\n \n@@ -255,6 +253,7 @@ def stream_decode_gzip(iterator):\n     except zlib.error:\n         pass\n \n+\n def curl_from_request(request):\n     \"\"\"Returns a curl command from the request.\n \n@@ -276,10 +275,13 @@ def curl_from_request(request):\n     #: -u/--user - Specify the user name and password to use for server auth.\n     #: Basic Auth only for now\n     auth = ''\n+\n     if request.auth is not None:\n+\n         auth = '-u \"%s:%s\" ' % (request.auth.username, request.auth.password)\n \n     method = ''\n+\n     if request.method.upper() == 'HEAD':\n         #: -I/--head - fetch headers only.\n         method = '-I '\n@@ -321,4 +323,3 @@ def curl_from_request(request):\n \n     #: Params handled in _build_url\n     return curl + auth + method + header + cookies + form + '\"' + request._build_url() + '\"'\n-\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#dcebab4c35369f9f91dab3eb6ff877509f7d38c2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 49 | Lines Deleted: 56 | Files Changed: 7 | Hunks: 66 | Methods Changed: 8 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 105 | Churn Cumulative: 3876 | Contributors (this commit): 21 | Commits (past 90d): 154 | Contributors (cumulative): 40 | DMM Complexity: 0.6666666666666666\n\nDIFF:\n@@ -6,8 +6,23 @@ requests.config\n \n This module provides the Requests settings feature set.\n \n+settings parameters:\n+\n+TODO: Verify!!!\n+TODO: Make sure format is acceptabl/cool\n+- :base_headers: - Sets default User-Agent to `python-requests.org`\n+- :accept_gzip:  - Whether or not to accept gzip-compressed data\n+- :proxies: - http proxies?\n+- :verbose: - display verbose information?\n+- :timeout: - timeout time until request terminates\n+- :max_redirects: - maximum number of allowed redirects?\n+- :decode_unicode: - whether or not to accept unicode?\n+\n+Used globally\n+\n \"\"\"\n \n+\n class Settings(object):\n \n     def __init__(self, **kwargs):\n\n@@ -6,21 +6,27 @@ requests.exceptions\n \n \"\"\"\n \n+\n class RequestException(Exception):\n     \"\"\"There was an ambiguous exception that occured while handling your\n     request.\"\"\"\n \n+\n class AuthenticationError(RequestException):\n     \"\"\"The authentication credentials provided were invalid.\"\"\"\n \n+\n class Timeout(RequestException):\n     \"\"\"The request timed out.\"\"\"\n \n+\n class URLRequired(RequestException):\n     \"\"\"A valid URL is required to make a request.\"\"\"\n \n+\n class InvalidMethod(RequestException):\n     \"\"\"An inappropriate method was attempted.\"\"\"\n \n+\n class TooManyRedirects(RequestException):\n     \"\"\"Too many redirects.\"\"\"\n\n@@ -30,7 +30,6 @@ from .exceptions import RequestException, AuthenticationError, Timeout, URLRequi\n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n \n \n-\n class Request(object):\n     \"\"\"The :class:`Request <Request>` object. It carries out all functionality of\n     Requests. Recommended interface is with the Requests functions.\n@@ -96,7 +95,6 @@ class Request(object):\n         #: True if Request has been sent.\n         self.sent = False\n \n-\n         # Header manipulation and defaults.\n \n         if settings.accept_gzip:\n@@ -113,18 +111,15 @@ class Request(object):\n \n         self.headers = headers\n \n-\n     def __repr__(self):\n         return '<Request [%s]>' % (self.method)\n \n-\n     def _checks(self):\n         \"\"\"Deterministic checks for consistency.\"\"\"\n \n         if not self.url:\n             raise URLRequired\n \n-\n     def _get_opener(self):\n         \"\"\"Creates appropriate opener object for urllib2.\"\"\"\n \n@@ -173,13 +168,11 @@ class Request(object):\n \n         return opener.open\n \n-\n     def _build_response(self, resp, is_error=False):\n         \"\"\"Build internal :class:`Response <Response>` object\n         from given response.\n         \"\"\"\n \n-\n         def build(resp):\n \n             response = Response()\n@@ -193,7 +186,6 @@ class Request(object):\n \n                     response.cookies = dict_from_cookiejar(self.cookiejar)\n \n-\n             except AttributeError:\n                 pass\n \n@@ -204,7 +196,6 @@ class Request(object):\n \n             return response\n \n-\n         history = []\n \n         r = build(resp)\n@@ -258,7 +249,6 @@ class Request(object):\n         self.response = r\n         self.response.request = self\n \n-\n     @staticmethod\n     def _encode_params(data):\n         \"\"\"Encode parameters in a piece of data.\n@@ -276,22 +266,28 @@ class Request(object):\n             for k, vs in data.items():\n                 for v in isinstance(vs, list) and vs or [vs]:\n                     result.append((k.encode('utf-8') if isinstance(k, unicode) else k,\n-                                   v.encode('utf-8') if isinstance(v, unicode) else v))\n-            return result, urllib.urlencode(result, doseq=True)\n+                                   v.encode('utf-8') if isinstance(v, unicode) else v)\n+                    )\n+            return (result, urllib.urlencode(result, doseq=True))\n+\n         else:\n             return data, data\n \n-\n     def _build_url(self):\n         \"\"\"Build the actual URL to use.\"\"\"\n \n         # Support for unicode domain names and paths.\n         scheme, netloc, path, params, query, fragment = urlparse(self.url)\n         netloc = netloc.encode('idna')\n+\n         if isinstance(path, unicode):\n             path = path.encode('utf-8')\n+\n         path = urllib.quote(path, safe=\"%/:=&?~#+!$,;'@()*[]\")\n-        self.url = str(urlunparse([ scheme, netloc, path, params, query, fragment ]))\n+\n+        self.url = str(urlunparse(\n+          [scheme, netloc, path, params, query, fragment]\n+         ))\n \n         if self._enc_params:\n             if urlparse(self.url).query:\n@@ -301,7 +297,6 @@ class Request(object):\n         else:\n             return self.url\n \n-\n     def send(self, anyway=False):\n         \"\"\"Sends the request. Returns True of successful, false if not.\n         If there was an HTTPError during transmission,\n@@ -321,7 +316,6 @@ class Request(object):\n                 datetime.now().isoformat(), self.method, self.url\n             ))\n \n-\n         url = self._build_url()\n         if self.method in ('GET', 'HEAD', 'DELETE'):\n             req = _Request(url, method=self.method)\n@@ -381,17 +375,17 @@ class Request(object):\n                 self._build_response(resp)\n                 self.response.ok = True\n \n-\n         self.sent = self.response.ok\n \n         return self.sent\n \n \n class Response(object):\n-    \"\"\"The core :class:`Response <Response>` object. All\n-    :class:`Request <Request>` objects contain a\n-    :class:`response <Response>` attribute, which is an instance\n-    of this class.\n+    \"\"\"The core :class:`Response <Response>` object.\n+\n+\n+    All :class:`Request <Request>` objects contain a :class:`response\n+    <Response>` attribute, which is an instance of this class.\n     \"\"\"\n \n     def __init__(self):\n@@ -430,11 +424,9 @@ class Response(object):\n         #: A dictionary of Cookies the server sent back.\n         self.cookies = None\n \n-\n     def __repr__(self):\n         return '<Response [%s]>' % (self.status_code)\n \n-\n     def __nonzero__(self):\n         \"\"\"Returns true if :attr:`status_code` is 'OK'.\"\"\"\n \n@@ -496,14 +488,12 @@ class Response(object):\n         self._content_consumed = True\n         return self._content\n \n-\n     def raise_for_status(self):\n         \"\"\"Raises stored :class:`HTTPError` or :class:`URLError`, if one occured.\"\"\"\n         if self.error:\n             raise self.error\n \n \n-\n class AuthManager(object):\n     \"\"\"Requests Authentication Manager.\"\"\"\n \n@@ -516,16 +506,13 @@ class AuthManager(object):\n \n         return singleton\n \n-\n     def __init__(self):\n         self.passwd = {}\n         self._auth = {}\n \n-\n     def __repr__(self):\n         return '<AuthManager [%s]>' % (self.method)\n \n-\n     def add_auth(self, uri, auth):\n         \"\"\"Registers AuthObject to AuthManager.\"\"\"\n \n@@ -540,7 +527,6 @@ class AuthManager(object):\n \n         self._auth[uri] = auth\n \n-\n     def add_password(self, realm, uri, user, passwd):\n         \"\"\"Adds password to AuthManager.\"\"\"\n         # uri could be a single URI or a sequence\n@@ -553,7 +539,6 @@ class AuthManager(object):\n             self.passwd[reduced_uri] = {}\n         self.passwd[reduced_uri] = (user, passwd)\n \n-\n     def find_user_password(self, realm, authuri):\n         for uris, authinfo in self.passwd.iteritems():\n             reduced_authuri = self.reduce_uri(authuri, False)\n@@ -563,7 +548,6 @@ class AuthManager(object):\n \n         return (None, None)\n \n-\n     def get_auth(self, uri):\n         (in_domain, in_path) = self.reduce_uri(uri, False)\n \n@@ -574,7 +558,6 @@ class AuthManager(object):\n                 if path in in_path:\n                     return authority\n \n-\n     def reduce_uri(self, uri, default_port=True):\n         \"\"\"Accept authority or URI and extract only the authority and path.\"\"\"\n \n@@ -603,7 +586,6 @@ class AuthManager(object):\n \n         return authority, path\n \n-\n     def is_suburi(self, base, test):\n         \"\"\"Check if test is below base in a URI tree\n \n@@ -618,11 +600,9 @@ class AuthManager(object):\n             return True\n         return False\n \n-\n     def empty(self):\n         self.passwd = {}\n \n-\n     def remove(self, uri, realm=None):\n         # uri could be a single URI or a sequence\n         if isinstance(uri, basestring):\n@@ -632,7 +612,6 @@ class AuthManager(object):\n             reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])\n             del self.passwd[reduced_uri][realm]\n \n-\n     def __contains__(self, uri):\n         # uri could be a single URI or a sequence\n         if isinstance(uri, basestring):\n@@ -648,12 +627,12 @@ class AuthManager(object):\n auth_manager = AuthManager()\n \n \n-\n class AuthObject(object):\n-    \"\"\"The :class:`AuthObject` is a simple HTTP Authentication token. When\n-    given to a Requests function, it enables Basic HTTP Authentication for that\n-    Request. You can also enable Authorization for domain realms with AutoAuth.\n-    See AutoAuth for more details.\n+    \"\"\"The :class:`AuthObject` is a simple HTTP Authentication token.\n+\n+    When given to a Requests function, it enables Basic HTTP Authentication\n+    for that Request. You can also enable Authorization for domain realms\n+    with AutoAuth. See AutoAuth for more details.\n \n     :param username: Username to authenticate with.\n     :param password: Password for given username.\n\n@@ -8,8 +8,9 @@ Urllib2 Monkey patches.\n \n \"\"\"\n \n-import urllib2\n import re\n+import urllib2\n+\n \n class Request(urllib2.Request):\n     \"\"\"Hidden wrapper around the urllib2.Request object. Allows for manual\n@@ -35,7 +36,6 @@ class HTTPRedirectHandler(urllib2.HTTPRedirectHandler):\n     http_error_302 = http_error_303 = http_error_307 = http_error_301\n \n \n-\n class HTTPBasicAuthHandler(urllib2.HTTPBasicAuthHandler):\n     \"\"\"HTTP Basic Auth Handler with authentication loop fixes.\"\"\"\n \n@@ -44,14 +44,12 @@ class HTTPBasicAuthHandler(urllib2.HTTPBasicAuthHandler):\n         self.retried_req = None\n         self.retried = 0\n \n-\n     def reset_retry_count(self):\n         # Python 2.6.5 will call this on 401 or 407 errors and thus loop\n         # forever. We disable reset_retry_count completely and reset in\n         # http_error_auth_reqed instead.\n         pass\n \n-\n     def http_error_auth_reqed(self, auth_header, host, req, headers):\n         # Reset the retry counter once for each request.\n         if req is not self.retried_req:\n@@ -63,7 +61,6 @@ class HTTPBasicAuthHandler(urllib2.HTTPBasicAuthHandler):\n         )\n \n \n-\n class HTTPForcedBasicAuthHandler(HTTPBasicAuthHandler):\n     \"\"\"HTTP Basic Auth Handler with forced Authentication.\"\"\"\n \n@@ -74,7 +71,6 @@ class HTTPForcedBasicAuthHandler(HTTPBasicAuthHandler):\n     def __init__(self, *args, **kwargs):\n         HTTPBasicAuthHandler.__init__(self, *args, **kwargs)\n \n-\n     def http_error_401(self, req, fp, code, msg, headers):\n         url = req.get_full_url()\n         response = self._http_error_auth_reqed('www-authenticate', url, req, headers)\n@@ -83,7 +79,6 @@ class HTTPForcedBasicAuthHandler(HTTPBasicAuthHandler):\n \n     http_error_404 = http_error_401\n \n-\n     def _http_error_auth_reqed(self, authreq, host, req, headers):\n \n         authreq = headers.get(authreq, None)\n@@ -116,7 +111,6 @@ class HTTPForcedBasicAuthHandler(HTTPBasicAuthHandler):\n             return response\n \n \n-\n class HTTPDigestAuthHandler(urllib2.HTTPDigestAuthHandler):\n \n     def __init__(self, *args, **kwargs):\n\n@@ -15,13 +15,11 @@ from . import api\n from .utils import add_dict_to_cookiejar\n \n \n-\n class Session(object):\n     \"\"\"A Requests session.\"\"\"\n \n     __attrs__ = ['headers', 'cookies', 'auth', 'timeout', 'proxies', 'hooks']\n \n-\n     def __init__(self, **kwargs):\n \n         # Set up a CookieJar to be used by default\n@@ -34,7 +32,6 @@ class Session(object):\n         # Map and wrap requests.api methods\n         self._map_api_methods()\n \n-\n     def __repr__(self):\n         return '<requests-client at 0x%x>' % (id(self))\n \n@@ -45,7 +42,6 @@ class Session(object):\n         # print args\n         pass\n \n-\n     def _map_api_methods(self):\n         \"\"\"Reads each available method from requests.api and decorates\n         them with a wrapper, which inserts any instance-local attributes\n\n@@ -8,6 +8,7 @@ Datastructures that power Requests.\n \n \"\"\"\n \n+\n class CaseInsensitiveDict(dict):\n     \"\"\"Case-insensitive Dictionary\n \n@@ -46,6 +47,7 @@ class CaseInsensitiveDict(dict):\n         else:\n             return default\n \n+\n class LookupDict(dict):\n     \"\"\"Dictionary lookup object.\"\"\"\n \n\n@@ -54,7 +54,6 @@ def header_expand(headers):\n         if not len(headers) == i + 1:\n                 collector.append(', ')\n \n-\n     # Remove trailing seperators.\n     if collector[-1] in (', ', '; '):\n         del collector[-1]\n@@ -62,7 +61,6 @@ def header_expand(headers):\n     return ''.join(collector)\n \n \n-\n def dict_from_cookiejar(cj):\n     \"\"\"Returns a key/value dictionary from a CookieJar.\n \n@@ -255,6 +253,7 @@ def stream_decode_gzip(iterator):\n     except zlib.error:\n         pass\n \n+\n def curl_from_request(request):\n     \"\"\"Returns a curl command from the request.\n \n@@ -276,10 +275,13 @@ def curl_from_request(request):\n     #: -u/--user - Specify the user name and password to use for server auth.\n     #: Basic Auth only for now\n     auth = ''\n+\n     if request.auth is not None:\n+\n         auth = '-u \"%s:%s\" ' % (request.auth.username, request.auth.password)\n \n     method = ''\n+\n     if request.method.upper() == 'HEAD':\n         #: -I/--head - fetch headers only.\n         method = '-I '\n@@ -321,4 +323,3 @@ def curl_from_request(request):\n \n     #: Params handled in _build_url\n     return curl + auth + method + header + cookies + form + '\"' + request._build_url() + '\"'\n-\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
