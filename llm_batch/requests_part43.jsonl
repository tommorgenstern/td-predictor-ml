{"custom_id": "requests#0442122d34ba79b67b3ab80d04729259a01cd6c6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 5299 | Contributors (this commit): 61 | Commits (past 90d): 82 | Contributors (cumulative): 61 | DMM Complexity: None\n\nDIFF:\n@@ -17,7 +17,6 @@ from .status_codes import codes\n \n from .auth import HTTPBasicAuth, HTTPProxyAuth\n from .cookies import cookiejar_from_dict, extract_cookies_to_jar, get_cookie_header\n-from .packages.urllib3.response import HTTPResponse\n from .packages.urllib3.exceptions import MaxRetryError, LocationParseError\n from .packages.urllib3.exceptions import SSLError as _SSLError\n from .packages.urllib3.exceptions import HTTPError as _HTTPError\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#ed767cb70381ba4313a9e4b0c53a68b016f10e36", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 5301 | Contributors (this commit): 62 | Commits (past 90d): 83 | Contributors (cumulative): 62 | DMM Complexity: None\n\nDIFF:\n@@ -457,7 +457,7 @@ class Request(object):\n             return False\n \n     def send(self, anyway=False, prefetch=False):\n-        \"\"\"Sends the request. Returns True of successful, False if not.\n+        \"\"\"Sends the request. Returns True if successful, False if not.\n         If there was an HTTPError during transmission,\n         self.response.status_code will contain the HTTPError code.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#973e9cb54826062328f1c8650630819205ccfe8e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 895 | Contributors (this commit): 15 | Commits (past 90d): 17 | Contributors (cumulative): 15 | DMM Complexity: None\n\nDIFF:\n@@ -9,6 +9,7 @@ requests (cookies, auth, proxies).\n \n \"\"\"\n \n+from copy import deepcopy\n from .compat import cookielib\n from .cookies import cookiejar_from_dict, remove_cookie_by_name\n from .defaults import defaults\n@@ -81,7 +82,7 @@ class Session(object):\n         self.cert = cert\n \n         for (k, v) in list(defaults.items()):\n-            self.config.setdefault(k, v)\n+            self.config.setdefault(k, deepcopy(v))\n \n         self.init_poolmanager()\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c24665b59352006120ef33624ae8177ff68990bd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 38 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 5 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 39 | Churn Cumulative: 496 | Contributors (this commit): 7 | Commits (past 90d): 14 | Contributors (cumulative): 7 | DMM Complexity: 1.0\n\nDIFF:\n@@ -60,13 +60,50 @@ class OAuth1(AuthBase):\n             signature_type, rsa_key, verifier)\n \n     def __call__(self, r):\n+        \"\"\"Add OAuth parameters to the request.\n+\n+        Parameters may be included from the body if the content-type is\n+        urlencoded, if no content type is set an educated guess is made.\n+        \"\"\"\n         contenttype = r.headers.get('Content-Type', None)\n+        # extract_params will not give params unless the body is a properly\n+        # formatted string, a dictionary or a list of 2-tuples.\n         decoded_body = extract_params(r.data)     \n         if contenttype == None and decoded_body != None:\n+            # extract_params can only check the present r.data and does not know\n+            # of r.files, thus an extra check is performed. We know that \n+            # if files are present the request will not have \n+            # Content-type: x-www-form-urlencoded. We guess it will have\n+            # a mimetype of multipart/form-encoded and if this is not the case\n+            # we assume the correct header will be set later.\n+            if r.files:\n+                # Omit body data in the signing and since it will always\n+                # be empty (cant add paras to body if multipart) and we wish\n+                # to preserve body. \n+                r.headers['Content-Type'] = 'multipart/form-encoded'\n+                r.url, r.headers, _ = self.client.sign(\n+                    unicode(r.url), unicode(r.method), None, r.headers)\n+            else:\n+                # Normal signing\n                 r.headers['Content-Type'] = 'application/x-www-form-urlencoded'\n-\n                 r.url, r.headers, r.data = self.client.sign(\n                     unicode(r.url), unicode(r.method), r.data, r.headers)\n+\n+            # Having the authorization header, key or value, in unicode will\n+            # result in UnicodeDecodeErrors when the request is concatenated\n+            # by httplib. This can easily be seen when attaching files.\n+            # Note that simply encoding the value is not enough since Python\n+            # saves the type of first key set. Thus we remove and re-add.\n+            # >>> d = {u'a':u'foo'}\n+            # >>> d['a'] = 'foo'\n+            # >>> d\n+            # { u'a' : 'foo' }\n+            if u'Authorization' in r.headers:\n+                auth_header = r.headers[u'Authorization'].encode('utf-8')\n+                del r.headers[u'Authorization']\n+                r.headers['Authorization'] = auth_header\n+                print r.headers\n+\n             return r\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#6a9d59ea97f9681b57c1fe0db263b7e2af3e60c9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 8 | Churn Cumulative: 504 | Contributors (this commit): 7 | Commits (past 90d): 15 | Contributors (cumulative): 7 | DMM Complexity: None\n\nDIFF:\n@@ -98,11 +98,11 @@ class OAuth1(AuthBase):\n             # >>> d['a'] = 'foo'\n             # >>> d\n             # { u'a' : 'foo' }\n-            if u'Authorization' in r.headers:\n-                auth_header = r.headers[u'Authorization'].encode('utf-8')\n-                del r.headers[u'Authorization']\n+            u_header = unicode('Authorization')\n+            if u_header in r.headers:               \n+                auth_header = r.headers[u_header].encode('utf-8')\n+                del r.headers[u_header]\n                 r.headers['Authorization'] = auth_header\n-                print r.headers\n \n             return r\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f25827c5b66450482fad8209f38ca77664f504dd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 14 | Files Changed: 2 | Hunks: 6 | Methods Changed: 2 | Complexity Δ (Sum/Max): -4/0 | Churn Δ: 18 | Churn Cumulative: 1859 | Contributors (this commit): 26 | Commits (past 90d): 49 | Contributors (cumulative): 28 | DMM Complexity: 0.0\n\nDIFF:\n@@ -7,13 +7,14 @@ requests.auth\n This module contains the authentication handlers for Requests.\n \"\"\"\n \n+import os\n import time\n import hashlib\n \n from base64 import b64encode\n \n from .compat import urlparse, str\n-from .utils import randombytes, parse_dict_header\n+from .utils import parse_dict_header\n \n try:\n     from oauthlib.oauth1.rfc5849 import (Client, SIGNATURE_HMAC, SIGNATURE_TYPE_AUTH_HEADER)\n@@ -192,7 +193,7 @@ class HTTPDigestAuth(AuthBase):\n                 s = str(nonce_count).encode('utf-8')\n                 s += nonce.encode('utf-8')\n                 s += time.ctime().encode('utf-8')\n-                s += randombytes(8)\n+                s += os.urandom(8)\n \n                 cnonce = (hashlib.sha1(s).hexdigest()[:16])\n                 noncebit = \"%s:%s:%s:%s:%s\" % (nonce, ncvalue, cnonce, qop, hash_utf8(A2))\n\n@@ -12,14 +12,12 @@ that are also useful for external consumption.\n import cgi\n import codecs\n import os\n-import random\n import re\n import zlib\n from netrc import netrc, NetrcParseError\n \n from .compat import parse_http_list as _parse_list_header\n-from .compat import quote, is_py2, urlparse\n-from .compat import basestring, bytes, str\n+from .compat import quote, urlparse, basestring, bytes, str\n from .cookies import RequestsCookieJar, cookiejar_from_dict\n \n _hush_pyflakes = (RequestsCookieJar,)\n@@ -248,15 +246,6 @@ def header_expand(headers):\n     return ''.join(collector)\n \n \n-def randombytes(n):\n-    \"\"\"Return n random bytes.\"\"\"\n-    if is_py2:\n-        L = [chr(random.randrange(0, 256)) for i in range(n)]\n-    else:\n-        L = [chr(random.randrange(0, 256)).encode('utf-8') for i in range(n)]\n-    return b\"\".join(L)\n-\n-\n def dict_from_cookiejar(cj):\n     \"\"\"Returns a key/value dictionary from a CookieJar.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4b7c5dab0e565004d2e46b62d4fcc95737edf33d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 886 | Contributors (this commit): 5 | Commits (past 90d): 1 | Contributors (cumulative): 5 | DMM Complexity: None\n\nDIFF:\n@@ -30,7 +30,7 @@ class CaseInsensitiveDict(dict):\n         self._clear_lower_keys()\n \n     def __delitem__(self, key):\n-        dict.__delitem__(self, key)\n+        dict.__delitem__(self, self.lower_keys.get(key.lower(), key))\n         self._lower_keys.clear()\n \n     def __contains__(self, key):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c501784541ffe595f25cd62774d392270639c662", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 34 | Lines Deleted: 2 | Files Changed: 4 | Hunks: 11 | Methods Changed: 8 | Complexity Δ (Sum/Max): 7/6 | Churn Δ: 36 | Churn Cumulative: 7467 | Contributors (this commit): 69 | Commits (past 90d): 104 | Contributors (cumulative): 100 | DMM Complexity: 0.0\n\nDIFF:\n@@ -23,6 +23,7 @@ def request(method, url, **kwargs):\n     :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.\n     :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n     :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n+    :param store_cookies: (optional) if ``False``, the received cookies as part of the HTTP response would be ignored.\n     :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.\n     :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.\n     :param timeout: (optional) Float describing the timeout of the request.\n\n@@ -60,6 +60,7 @@ class Request(object):\n         params=dict(),\n         auth=None,\n         cookies=None,\n+        store_cookies=True,\n         timeout=None,\n         redirect=False,\n         allow_redirects=False,\n@@ -110,6 +111,9 @@ class Request(object):\n         # Dictionary mapping protocol to the URL of the proxy (e.g. {'http': 'foo.bar:3128'})\n         self.proxies = dict(proxies or [])\n \n+        #param store_cookies: (optional) if ``False``, the received cookies as part of the HTTP response would be ignored.\n+        self.store_cookies = store_cookies\n+\n         # If no proxies are given, allow configuration by environment variables\n         # HTTP_PROXY and HTTPS_PROXY.\n         if not self.proxies and self.config.get('trust_env'):\n@@ -197,7 +201,8 @@ class Request(object):\n                 # Set encoding.\n                 response.encoding = get_encoding_from_headers(response.headers)\n \n-                # Add new cookies from the server.\n+                # Add new cookies from the server. Don't if configured not to\n+                if self.store_cookies:\n                     extract_cookies_to_jar(self.cookies, self, resp)\n \n                 # Save cookies in Response.\n@@ -460,7 +465,7 @@ class Request(object):\n             return False\n \n     def send(self, anyway=False, prefetch=False):\n-        \"\"\"Sends the request. Returns True of successful, False if not.\n+        \"\"\"Sends the request. Returns True if successful, False if not.\n         If there was an HTTPError during transmission,\n         self.response.status_code will contain the HTTPError code.\n \n\n@@ -59,6 +59,7 @@ class Session(object):\n     def __init__(self,\n         headers=None,\n         cookies=None,\n+        store_cookies=True,\n         auth=None,\n         timeout=None,\n         proxies=None,\n@@ -79,6 +80,7 @@ class Session(object):\n         self.prefetch = prefetch\n         self.verify = verify\n         self.cert = cert\n+        self.store_cookies = store_cookies\n \n         for (k, v) in list(defaults.items()):\n             self.config.setdefault(k, v)\n@@ -111,6 +113,7 @@ class Session(object):\n         data=None,\n         headers=None,\n         cookies=None,\n+        store_cookies=True,\n         files=None,\n         auth=None,\n         timeout=None,\n@@ -132,6 +135,7 @@ class Session(object):\n         :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.\n         :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n         :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n+        :param store_cookies: (optional) if ``False``, the received cookies as part of the HTTP response would be ignored.\n         :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n         :param auth: (optional) Auth tuple or callable to enable Basic/Digest/Custom HTTP Auth.\n         :param timeout: (optional) Float describing the timeout of the request.\n@@ -170,6 +174,7 @@ class Session(object):\n             params=params,\n             headers=headers,\n             cookies=cookies,\n+            store_cookies=store_cookies,\n             files=files,\n             auth=auth,\n             hooks=hooks,\n\n@@ -102,6 +102,27 @@ class CookieTests(TestBaseMixin, unittest.TestCase):\n         insecure_cookies_sent = json.loads(insecure_resp.text)['cookies']\n         self.assertEqual(insecure_cookies_sent, {})\n \n+    def test_disabled_cookie_persistence(self):\n+        \"\"\"Test that cookies are not persisted when configured accordingly.\"\"\"\n+\n+        # Check the case when no cookie is passed as part of the request and the one in response is ignored\n+        cookies = requests.get(httpbin('cookies', 'set', 'key', 'value'), store_cookies = False).cookies\n+        self.assertIsNone(cookies.get(\"key\"))\n+\n+        # Test that the cookies passed while making the request still gets used and is available in response object.\n+        # only the ones received from server is not saved\n+        cookies_2 = requests.get(httpbin('cookies', 'set', 'key', 'value'), store_cookies = False,\\\n+                                                cookies = {\"key_2\" : \"value_2\"}).cookies\n+        self.assertEqual(len(cookies_2), 1)\n+        self.assertEqual(cookies_2.get(\"key_2\"), \"value_2\")\n+\n+        # Use the session and make sure that the received cookie is not used in subsequent calls\n+        s = requests.session()\n+        s.get(httpbin('cookies', 'set', 'key', 'value'), store_cookies = False)\n+        r = s.get(httpbin('cookies'))\n+        self.assertEqual(json.loads(r.text)['cookies'], {})\n+\n+\n class LWPCookieJarTest(TestBaseMixin, unittest.TestCase):\n     \"\"\"Check store/load of cookies to FileCookieJar's, specifically LWPCookieJar's.\"\"\"\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#3c144351095c7849753e477da0482c044d36f1c4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 244 | Contributors (this commit): 3 | Commits (past 90d): 7 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -107,7 +107,7 @@ class CookieTests(TestBaseMixin, unittest.TestCase):\n \n         # Check the case when no cookie is passed as part of the request and the one in response is ignored\n         cookies = requests.get(httpbin('cookies', 'set', 'key', 'value'), store_cookies = False).cookies\n-        self.assertIsNone(cookies.get(\"key\"))\n+        self.assertEqual(cookies.get(\"key\"), None)\n \n         # Test that the cookies passed while making the request still gets used and is available in response object.\n         # only the ones received from server is not saved\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#9f26d0ced3d7a360b1bb392a5e8257409378bac5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 18 | Lines Deleted: 19 | Files Changed: 1 | Hunks: 14 | Methods Changed: 6 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 37 | Churn Cumulative: 422 | Contributors (this commit): 3 | Commits (past 90d): 9 | Contributors (cumulative): 3 | DMM Complexity: 1.0\n\nDIFF:\n@@ -120,6 +120,10 @@ def remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n     for domain, path, name in clearables:\n         cookiejar.clear(domain, path, name)\n \n+class CookieConflictError(RuntimeError):\n+    \"\"\"There are two cookies that meet the criteria specified in the cookie jar. \n+    Use .get and .set and include domain and path args in order to be more specific.\"\"\"\n+\n class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n     \"\"\"Compatibility class; is a cookielib.CookieJar, but exposes a dict interface.\n \n@@ -138,7 +142,6 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n     \"\"\"\n \n     # TODO test, test, test\n-    # TODO should get and set require domain and/or path?\n     def get(self, name, default=None, domain=None, path=None):\n         \"\"\"Dict-like get() that also supports optional domain and path args in\n         order to resolve naming collisions from using one cookie jar over\n@@ -217,19 +220,14 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n \n     def __getitem__(self, name):\n         \"\"\"Dict-like __getitem__() for compatibility with client code. Throws exception\n-        if there are multiple domains or paths in the jar. In that case, use the more\n+        if there are more than one cookie with name. In that case, use the more\n         explicit get() method instead. Caution: operation is O(n), not O(1).\"\"\"\n-        if self._multipleDomainsOrPaths():\n-            raise KeyError('Multiple domains/paths in jar. Use .get instead.')\n         return self._find(name)\n \n     def __setitem__(self, name, value):\n         \"\"\"Dict-like __setitem__ for compatibility with client code. Throws exception\n-        if there are multiple domains or paths in the jar. In that case, use the more\n+        if there is already a cookie of that name in the jar. In that case, use the more\n         explicit set() method instead.\"\"\"\n-        # TODO is this check nesc?\n-        if self._multipleDomainsOrPaths():\n-            raise KeyError('Multiple domains/paths in jar. Use .set instead.')\n         self.set(name, value)\n \n     def __delitem__(self, name):\n@@ -239,29 +237,30 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n     def _find(self, name, domain=None, path=None):\n         \"\"\"Requests uses this method internally to find cookies. Takes as args name \n         and optional domain and path. Returns a cookie.value. Throws KeyError\n-        if cookie is not found.\"\"\"\n+        if cookie is not found and CookieConflictError if there are multiple cookies\n+        that match name and optionally domain and path.\"\"\"\n+        toReturn = None\n         for cookie in iter(self):\n             if cookie.name == name:\n                 if domain is None or cookie.domain == domain:\n                     if path is None or cookie.path == path:\n-                        return cookie.value\n+                        if toReturn != None: # if there are multiple cookies that meet passed in criteria\n+                            raise CookieConflictError('There are multiple cookies with name, %r' % (name))\n+                        toReturn = cookie.value # we will eventually return this as long as no cookie conflict\n \n+        if toReturn:\n+            return toReturn\n         raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))\n \n-    def _multipleDomainsOrPaths(self):\n-        \"\"\"Returns True if there are multiple domains or paths in the jar.\n+    def _multipleDomains(self):\n+        \"\"\"Returns True if there are multiple domains in the jar.\n         Returns False otherwise.\"\"\"\n-        # TODO: possible bug -- always multiple paths, right?\n         domains = []\n-        paths = []\n         for cookie in iter(self):\n             if cookie.domain is not None and cookie.domain in domains:\n                 return True\n             domains.append(cookie.domain)\n-            if cookie.path is not None and cookie.path in paths:\n-                return True\n-            paths.append(cookie.path)\n-        return False # there is only one domains and one path in jar\n+        return False # there is only one domain in jar\n \n     # TODO docstrings\n     def __getstate__(self):\n@@ -276,7 +275,7 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n             self._cookies_lock = threading.RLock()\n \n     def copy(self):\n-        \"\"\"This is not currently implemented. Calling copy() will throw an exception.\"\"\"\n+        \"\"\"This is not implemented. Calling this will throw an exception.\"\"\"\n         raise NotImplementedError\n \n def create_cookie(name, value, **kwargs):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#96cd8e9ca0b6953794b9b3244b244dd34f975544", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 71 | Lines Deleted: 23 | Files Changed: 2 | Hunks: 16 | Methods Changed: 18 | Complexity Δ (Sum/Max): 9/7 | Churn Δ: 94 | Churn Cumulative: 760 | Contributors (this commit): 5 | Commits (past 90d): 18 | Contributors (cumulative): 7 | DMM Complexity: 0.7096774193548387\n\nDIFF:\n@@ -141,13 +141,12 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n     Unlike a regular CookieJar, this class is pickleable.\n     \"\"\"\n \n-    # TODO test, test, test\n     def get(self, name, default=None, domain=None, path=None):\n         \"\"\"Dict-like get() that also supports optional domain and path args in\n         order to resolve naming collisions from using one cookie jar over\n         multiple domains. Caution: operation is O(n), not O(1).\"\"\"\n         try:\n-            return self._find(name, domain, path)\n+            return self._find_no_duplicates(name, domain, path)\n         except KeyError:\n             return default\n \n@@ -167,7 +166,7 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n         self.set_cookie(c)\n         return c\n \n-    def keys():\n+    def keys(self):\n         \"\"\"Dict-like keys() that returns a list of names of cookies from the jar.\n         See values() and items().\"\"\"\n         keys = []\n@@ -175,21 +174,21 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n             keys.append(cookie.name)\n         return keys\n \n-    def values():\n+    def values(self):\n         \"\"\"Dict-like values() that returns a list of values of cookies from the jar.\n         See keys() and items().\"\"\"\n         values = []\n         for cookie in iter(self):\n-            values.append(cookie.values)\n+            values.append(cookie.value)\n         return values\n     \n-    def items():\n+    def items(self):\n         \"\"\"Dict-like items() that returns a list of name-value tuples from the jar.\n         See keys() and values(). Allows client-code to call \"dict(RequestsCookieJar)\n         and get a vanilla python dict of key value pairs.\"\"\"\n         items = []\n         for cookie in iter(self):\n-            items.append((cookies.name, cookie.values))\n+            items.append((cookie.name, cookie.value))\n         return items\n \n     def list_domains(self):\n@@ -208,11 +207,23 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n                 paths.append(cookie.path)\n         return paths\n \n+    def multiple_domains(self):\n+        \"\"\"Returns True if there are multiple domains in the jar.\n+        Returns False otherwise.\"\"\"\n+        domains = []\n+        for cookie in iter(self):\n+            if cookie.domain is not None and cookie.domain in domains:\n+                return True\n+            domains.append(cookie.domain)\n+        return False # there is only one domain in jar\n+\n     def get_dict(self, domain=None, path=None):\n         \"\"\"Takes as an argument an optional domain and path and returns a plain old\n         Python dict of name-value pairs of cookies that meet the requirements.\"\"\"\n         dictionary = {}\n         for cookie in iter(self):\n+            print path\n+            print cookie.path\n             if (domain == None or cookie.domain == domain) and (path == None \n                                                 or cookie.path == path):\n                 dictionary[cookie.name] = cookie.value\n@@ -222,7 +233,7 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n         \"\"\"Dict-like __getitem__() for compatibility with client code. Throws exception\n         if there are more than one cookie with name. In that case, use the more\n         explicit get() method instead. Caution: operation is O(n), not O(1).\"\"\"\n-        return self._find(name)\n+        return self._find_no_duplicates(name)\n \n     def __setitem__(self, name, value):\n         \"\"\"Dict-like __setitem__ for compatibility with client code. Throws exception\n@@ -235,10 +246,23 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n         remove_cookie_by_name(self, name)\n \n     def _find(self, name, domain=None, path=None):\n-        \"\"\"Requests uses this method internally to find cookies. Takes as args name \n-        and optional domain and path. Returns a cookie.value. Throws KeyError\n-        if cookie is not found and CookieConflictError if there are multiple cookies\n-        that match name and optionally domain and path.\"\"\"\n+        \"\"\"Requests uses this method internally to get cookie values. Takes as args name \n+        and optional domain and path. Returns a cookie.value. If there are conflicting cookies,\n+        _find arbitrarily chooses one. See _find_no_duplicates if you want an exception thrown\n+        if there are conflicting cookies.\"\"\"\n+        for cookie in iter(self):\n+            if cookie.name == name:\n+                if domain is None or cookie.domain == domain:\n+                    if path is None or cookie.path == path:\n+                        return cookie.value\n+\n+        raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))\n+\n+    def _find_no_duplicates(self, name, domain=None, path=None):\n+        \"\"\"__get_item__ and get call _find_no_duplicates -- never used in Requests internally. \n+        Takes as args name and optional domain and path. Returns a cookie.value. \n+        Throws KeyError if cookie is not found and CookieConflictError if there are \n+        multiple cookies that match name and optionally domain and path.\"\"\"\n         toReturn = None\n         for cookie in iter(self):\n             if cookie.name == name:\n@@ -252,24 +276,15 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n             return toReturn\n         raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))\n \n-    def _multipleDomains(self):\n-        \"\"\"Returns True if there are multiple domains in the jar.\n-        Returns False otherwise.\"\"\"\n-        domains = []\n-        for cookie in iter(self):\n-            if cookie.domain is not None and cookie.domain in domains:\n-                return True\n-            domains.append(cookie.domain)\n-        return False # there is only one domain in jar\n-\n-    # TODO docstrings\n     def __getstate__(self):\n+        \"\"\"Unlike a normal CookieJar, this class is pickleable.\"\"\"\n         state = self.__dict__.copy()\n         # remove the unpickleable RLock object\n         state.pop('_cookies_lock')\n         return state\n \n     def __setstate__(self, state):\n+        \"\"\"Unlike a normal CookieJar, this class is pickleable.\"\"\"\n         self.__dict__.update(state)\n         if '_cookies_lock' not in self.__dict__:\n             self._cookies_lock = threading.RLock()\n\n@@ -24,6 +24,7 @@ class CookieTests(TestBaseMixin, unittest.TestCase):\n \n         # test deprecated dictionary interface\n         self.assertEqual(r.cookies['myname'], 'myvalue')\n+        self.assertEqual(r.cookies.get('myname'), 'myvalue')\n         # test CookieJar interface\n         jar = r.cookies\n         self.assertEqual(len(jar), 1)\n@@ -122,6 +123,38 @@ class CookieTests(TestBaseMixin, unittest.TestCase):\n         r = s.get(httpbin('cookies'))\n         self.assertEqual(json.loads(r.text)['cookies'], {})\n \n+    def test_jar_utility_functions(self):\n+        \"\"\"Test utility functions such as list_domains, list_paths, multiple_domains.\"\"\"\n+        r = requests.get(\"http://github.com\")\n+        c = r.cookies\n+        # github should send us cookies\n+        self.assertTrue(len(c) >= 1)\n+        self.assertEqual(len(c), len(r.cookies.keys()))\n+        self.assertEqual(len(c), len(r.cookies.values()))\n+        self.assertEqual(len(c), len(r.cookies.items()))\n+        \n+        # domain and path utility functions\n+        domain = r.cookies.list_domains()[0]\n+        path = r.cookies.list_paths()[0]\n+        self.assertEqual(dict(r.cookies), r.cookies.get_dict(domain=domain, path=path))\n+        self.assertEqual(len(r.cookies.list_domains()), 1)\n+        self.assertEqual(len(r.cookies.list_paths()), 1)\n+        self.assertFalse(r.cookies.multiple_domains())\n+\n+    def test_convert_jar_to_dict(self):\n+        \"\"\"Test that keys, values, and items are defined and that we can convert\n+        cookie jars to plain old Python dicts.\"\"\"\n+        r = requests.get(httpbin('cookies', 'set', 'myname', 'myvalue'))\n+\n+        # test keys, values, and items\n+        self.assertEqual(r.cookies.keys(), ['myname'])\n+        self.assertEqual(r.cookies.values(), ['myvalue'])\n+        self.assertEqual(r.cookies.items(), [('myname','myvalue')])\n+        \n+        # test if we can convert jar to dict\n+        dictOfCookies = dict(r.cookies)\n+        self.assertEqual(dictOfCookies, {'myname':'myvalue'})\n+        self.assertEqual(dictOfCookies, r.cookies.get_dict())\n \n class LWPCookieJarTest(TestBaseMixin, unittest.TestCase):\n     \"\"\"Check store/load of cookies to FileCookieJar's, specifically LWPCookieJar's.\"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#0eb0b89431d467197b361e4eab3c3399ff07b22e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 485 | Contributors (this commit): 3 | Commits (past 90d): 11 | Contributors (cumulative): 3 | DMM Complexity: 1.0\n\nDIFF:\n@@ -222,8 +222,6 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n         Python dict of name-value pairs of cookies that meet the requirements.\"\"\"\n         dictionary = {}\n         for cookie in iter(self):\n-            print path\n-            print cookie.path\n             if (domain == None or cookie.domain == domain) and (path == None \n                                                 or cookie.path == path):\n                 dictionary[cookie.name] = cookie.value\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b28673368b0a4236b3cfbb50fb15f846793a1c40", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 17 | Files Changed: 5 | Hunks: 17 | Methods Changed: 8 | Complexity Δ (Sum/Max): -5/0 | Churn Δ: 28 | Churn Cumulative: 7691 | Contributors (this commit): 69 | Commits (past 90d): 108 | Contributors (cumulative): 106 | DMM Complexity: 1.0\n\nDIFF:\n@@ -25,7 +25,6 @@ def request(method, url, **kwargs):\n     :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.\n     :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n     :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n-    :param store_cookies: (optional) if ``False``, the received cookies as part of the HTTP response would be ignored.\n     :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.\n     :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.\n     :param timeout: (optional) Float describing the timeout of the request.\n@@ -33,7 +32,7 @@ def request(method, url, **kwargs):\n     :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n     :param return_response: (optional) If False, an un-sent Request object will returned.\n     :param session: (optional) A :class:`Session` object to be used for the request.\n-    :param config: (optional) A configuration dictionary.\n+    :param config: (optional) A configuration dictionary. See ``request.defaults`` for allowed keys and their default values.\n     :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n     :param prefetch: (optional) if ``True``, the response content will be immediately downloaded.\n     :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n\n@@ -20,6 +20,7 @@ Configurations:\n :pool_connections: The number of active HTTP connection pools to use.\n :encode_uri: If true, URIs will automatically be percent-encoded.\n :trust_env: If true, the surrouding environment will be trusted (environ, netrc).\n+:param store_cookies: If false, the received cookies as part of the HTTP response would be ignored.\n \n \"\"\"\n \n@@ -47,5 +48,6 @@ defaults['strict_mode'] = False\n defaults['keep_alive'] = True\n defaults['encode_uri'] = True\n defaults['trust_env'] = True\n+defaults['store_cookies'] = True\n \n \n\n@@ -59,7 +59,6 @@ class Request(object):\n         params=dict(),\n         auth=None,\n         cookies=None,\n-        store_cookies=True,\n         timeout=None,\n         redirect=False,\n         allow_redirects=False,\n@@ -110,9 +109,6 @@ class Request(object):\n         # Dictionary mapping protocol to the URL of the proxy (e.g. {'http': 'foo.bar:3128'})\n         self.proxies = dict(proxies or [])\n \n-        #param store_cookies: (optional) if ``False``, the received cookies as part of the HTTP response would be ignored.\n-        self.store_cookies = store_cookies\n-\n         # If no proxies are given, allow configuration by environment variables\n         # HTTP_PROXY and HTTPS_PROXY.\n         if not self.proxies and self.config.get('trust_env'):\n@@ -201,7 +197,7 @@ class Request(object):\n                 response.encoding = get_encoding_from_headers(response.headers)\n \n                 # Add new cookies from the server. Don't if configured not to\n-                if self.store_cookies:\n+                if self.config.get('store_cookies'):\n                     extract_cookies_to_jar(self.cookies, self, resp)\n \n                 # Save cookies in Response.\n\n@@ -60,7 +60,6 @@ class Session(object):\n     def __init__(self,\n         headers=None,\n         cookies=None,\n-        store_cookies=True,\n         auth=None,\n         timeout=None,\n         proxies=None,\n@@ -81,7 +80,6 @@ class Session(object):\n         self.prefetch = prefetch\n         self.verify = verify\n         self.cert = cert\n-        self.store_cookies = store_cookies\n \n         for (k, v) in list(defaults.items()):\n             self.config.setdefault(k, deepcopy(v))\n@@ -114,7 +112,6 @@ class Session(object):\n         data=None,\n         headers=None,\n         cookies=None,\n-        store_cookies=True,\n         files=None,\n         auth=None,\n         timeout=None,\n@@ -136,14 +133,13 @@ class Session(object):\n         :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.\n         :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n         :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n-        :param store_cookies: (optional) if ``False``, the received cookies as part of the HTTP response would be ignored.\n         :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n         :param auth: (optional) Auth tuple or callable to enable Basic/Digest/Custom HTTP Auth.\n         :param timeout: (optional) Float describing the timeout of the request.\n         :param allow_redirects: (optional) Boolean. Set to True by default.\n         :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n         :param return_response: (optional) If False, an un-sent Request object will returned.\n-        :param config: (optional) A configuration dictionary.\n+        :param config: (optional) A configuration dictionary. See ``request.defaults`` for allowed keys and their default values.\n         :param prefetch: (optional) if ``True``, the response content will be immediately downloaded.\n         :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n         :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n@@ -175,7 +171,6 @@ class Session(object):\n             params=params,\n             headers=headers,\n             cookies=cookies,\n-            store_cookies=store_cookies,\n             files=files,\n             auth=auth,\n             hooks=hooks,\n\n@@ -106,20 +106,22 @@ class CookieTests(TestBaseMixin, unittest.TestCase):\n     def test_disabled_cookie_persistence(self):\n         \"\"\"Test that cookies are not persisted when configured accordingly.\"\"\"\n \n+        config = {'store_cookies' : False}\n+\n         # Check the case when no cookie is passed as part of the request and the one in response is ignored\n-        cookies = requests.get(httpbin('cookies', 'set', 'key', 'value'), store_cookies = False).cookies\n-        self.assertEqual(cookies.get(\"key\"), None)\n+        cookies = requests.get(httpbin('cookies', 'set', 'key', 'value'), config = config).cookies\n+        self.assertIsNone(cookies.get(\"key\"))\n \n         # Test that the cookies passed while making the request still gets used and is available in response object.\n         # only the ones received from server is not saved\n-        cookies_2 = requests.get(httpbin('cookies', 'set', 'key', 'value'), store_cookies = False,\\\n+        cookies_2 = requests.get(httpbin('cookies', 'set', 'key', 'value'), config = config,\\\n                                                 cookies = {\"key_2\" : \"value_2\"}).cookies\n         self.assertEqual(len(cookies_2), 1)\n         self.assertEqual(cookies_2.get(\"key_2\"), \"value_2\")\n \n         # Use the session and make sure that the received cookie is not used in subsequent calls\n         s = requests.session()\n-        s.get(httpbin('cookies', 'set', 'key', 'value'), store_cookies = False)\n+        s.get(httpbin('cookies', 'set', 'key', 'value'), config = config)\n         r = s.get(httpbin('cookies'))\n         self.assertEqual(json.loads(r.text)['cookies'], {})\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4a309796225cfae96cf8473c8d70b5c71080011c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 289 | Contributors (this commit): 4 | Commits (past 90d): 10 | Contributors (cumulative): 4 | DMM Complexity: None\n\nDIFF:\n@@ -110,7 +110,7 @@ class CookieTests(TestBaseMixin, unittest.TestCase):\n \n         # Check the case when no cookie is passed as part of the request and the one in response is ignored\n         cookies = requests.get(httpbin('cookies', 'set', 'key', 'value'), config = config).cookies\n-        self.assertIsNone(cookies.get(\"key\"))\n+        self.assertTrue(cookies.get(\"key\") is None)\n \n         # Test that the cookies passed while making the request still gets used and is available in response object.\n         # only the ones received from server is not saved\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#7125fe5554332b636ce42dcbe8224d0918381917", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 7 | Churn Cumulative: 1357 | Contributors (this commit): 22 | Commits (past 90d): 15 | Contributors (cumulative): 22 | DMM Complexity: 1.0\n\nDIFF:\n@@ -407,6 +407,11 @@ UNRESERVED_SET = frozenset(\n \n \n def unquote_unreserved(uri):\n+    '''\n+    this try catch is a poor man's patch for issue #630\n+    https://github.com/kennethreitz/requests/issues/630\n+    '''\n+    try:\n         \"\"\"Un-escape any percent-escape sequences in a URI that are unreserved\n         characters.\n         This leaves all reserved, illegal and non-ASCII bytes encoded.\n@@ -423,6 +428,8 @@ def unquote_unreserved(uri):\n             else:\n                 parts[i] = '%' + parts[i]\n         return ''.join(parts)\n+    except:\n+        return uri\n \n \n def requote_uri(uri):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b8561cda5e2bf9cb0129c2863ff52754e837ad85", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 4 | Churn Cumulative: 5320 | Contributors (this commit): 64 | Commits (past 90d): 69 | Contributors (cumulative): 64 | DMM Complexity: 0.0\n\nDIFF:\n@@ -9,6 +9,7 @@ This module contains the primary objects that power Requests.\n \n import json\n import os\n+import string\n from datetime import datetime\n \n from .hooks import dispatch_hook, HOOKS\n@@ -521,9 +522,10 @@ class Request(object):\n             self.headers['Content-Type'] = content_type\n \n         _p = urlparse(url)\n+        no_proxy = filter(string.strip, self.proxies.get('no', '').split(','))\n         proxy = self.proxies.get(_p.scheme)\n \n-        if proxy:\n+        if proxy and not any(map(_p.netloc.endswith, no_proxy)):\n             conn = poolmanager.proxy_from_url(proxy)\n             _proxy = urlparse(proxy)\n             if '@' in _proxy.netloc:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#cb8f9756e3cf57a12ea5619609460f29f930fd3d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 5323 | Contributors (this commit): 64 | Commits (past 90d): 70 | Contributors (cumulative): 64 | DMM Complexity: None\n\nDIFF:\n@@ -9,7 +9,6 @@ This module contains the primary objects that power Requests.\n \n import json\n import os\n-import string\n from datetime import datetime\n \n from .hooks import dispatch_hook, HOOKS\n@@ -522,7 +521,7 @@ class Request(object):\n             self.headers['Content-Type'] = content_type\n \n         _p = urlparse(url)\n-        no_proxy = filter(string.strip, self.proxies.get('no', '').split(','))\n+        no_proxy = filter(lambda x:x.strip(), self.proxies.get('no', '').split(','))\n         proxy = self.proxies.get(_p.scheme)\n \n         if proxy and not any(map(_p.netloc.endswith, no_proxy)):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#ba4cc326c2736f8cad7bc5c031e7c9230bd713e0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 2 | Churn Cumulative: 5325 | Contributors (this commit): 65 | Commits (past 90d): 71 | Contributors (cumulative): 65 | DMM Complexity: None\n\nDIFF:\n@@ -665,7 +665,7 @@ class Response(object):\n         #: Resulting :class:`HTTPError` of request, if one occurred.\n         self.error = None\n \n-        #: Encoding to decode with when accessing r.content.\n+        #: Encoding to decode with when accessing r.text.\n         self.encoding = None\n \n         #: A list of :class:`Response <Response>` objects from\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#1c0abbd74b1ef39f15adbb3af10a998ea8af88d9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 8 | Files Changed: 1 | Hunks: 4 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 11 | Churn Cumulative: 1368 | Contributors (this commit): 22 | Commits (past 90d): 15 | Contributors (cumulative): 22 | DMM Complexity: 0.0\n\nDIFF:\n@@ -407,15 +407,10 @@ UNRESERVED_SET = frozenset(\n \n \n def unquote_unreserved(uri):\n-    '''\n-    this try catch is a poor man's patch for issue #630\n-    https://github.com/kennethreitz/requests/issues/630\n-    '''\n-    try:\n     \"\"\"Un-escape any percent-escape sequences in a URI that are unreserved\n-        characters.\n-        This leaves all reserved, illegal and non-ASCII bytes encoded.\n+    characters. This leaves all reserved, illegal and non-ASCII bytes encoded.\n     \"\"\"\n+    try:\n         parts = uri.split('%')\n         for i in range(1, len(parts)):\n             h = parts[i][0:2]\n@@ -428,7 +423,7 @@ def unquote_unreserved(uri):\n             else:\n                 parts[i] = '%' + parts[i]\n         return ''.join(parts)\n-    except:\n+    except ValueError:\n         return uri\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
