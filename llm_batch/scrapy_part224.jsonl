{"custom_id": "scrapy#c8cf1a303d2272aa44422035fd1e3e6048cb5606", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 78 | Lines Deleted: 97 | Files Changed: 6 | Hunks: 54 | Methods Changed: 1 | Complexity Δ (Sum/Max): -412/0 | Churn Δ: 175 | Churn Cumulative: 7733 | Contributors (this commit): 11 | Commits (past 90d): 11 | Contributors (cumulative): 25 | DMM Complexity: 0.15358931552587646\n\nDIFF:\n@@ -38,26 +38,21 @@ from twisted.internet.error import ConnectionDone\n from twisted.internet.defer import Deferred, succeed, fail, maybeDeferred\n from twisted.internet.defer import CancelledError\n from twisted.internet.protocol import Protocol\n-from twisted.protocols.basic import LineReceiver\n-from twisted.web.iweb import UNKNOWN_LENGTH\n-from twisted.web.http_headers import Headers\n+#from twisted.protocols.basic import LineReceiver\n+from twisted.web.iweb import UNKNOWN_LENGTH, IResponse\n+#from twisted.web.http_headers import Headers\n from twisted.web.http import NO_CONTENT, NOT_MODIFIED\n from twisted.web.http import _DataLoss, PotentialDataLoss\n from twisted.web.http import _IdentityTransferDecoder, _ChunkedTransferDecoder\n \n from twisted.web._newclient import (\n     BadHeaders, ExcessWrite, ParseError, BadResponseVersion, _WrapperException,\n-    RequestGenerationFailed, RequestTransmissionFailed,\n-    WrongBodyLength, ResponseDone, RequestNotSent,\n-    LengthEnforcingConsumer, makeStatefulDispatcher, ChunkedEncoder,\n-    TransportProxyProducer,\n+    RequestGenerationFailed, RequestTransmissionFailed, ConnectionAborted,\n+    WrongBodyLength, ResponseDone, ResponseFailed, RequestNotSent,\n+    ResponseNeverReceived, HTTPParser, HTTPClientParser, Request,\n+    LengthEnforcingConsumer, makeStatefulDispatcher, Response, ChunkedEncoder,\n+    TransportProxyProducer, HTTP11ClientProtocol\n )\n-# newer than 10.0.0\n-#from twisted.web._newclient import (\n-#    ConnectionAborted, ResponseFailed, ResponseNeverReceived, HTTPParser,\n-#    HTTPClientParser, Request, Response, HTTP11ClientProtocol,\n-#)\n-from .iweb import IResponse\n \n # States HTTPParser can be in\n STATUS = 'STATUS'\n@@ -130,7 +125,7 @@ class RequestTransmissionFailed(_WrapperException):\n     @ivar reasons: A C{list} of one or more L{Failure} instances giving the\n         reasons the request transmission was considered to have failed.\n     \"\"\"\n-}}} '''\n+\n \n \n class ConnectionAborted(Exception):\n@@ -139,7 +134,7 @@ class ConnectionAborted(Exception):\n     \"\"\"\n \n \n-''' {{{\n+\n class WrongBodyLength(Exception):\n     \"\"\"\n     An L{IBodyProducer} declared the number of bytes it was going to\n@@ -155,7 +150,7 @@ class ResponseDone(Exception):\n     protocol passed to L{Response.deliverBody} and indicates that the entire\n     response has been delivered.\n     \"\"\"\n-}}} '''\n+\n \n \n class ResponseFailed(_WrapperException):\n@@ -182,7 +177,7 @@ class ResponseNeverReceived(ResponseFailed):\n     \"\"\"\n \n \n-''' {{{\n+\n class RequestNotSent(Exception):\n     \"\"\"\n     L{RequestNotSent} indicates that an attempt was made to issue a request but\n@@ -191,7 +186,7 @@ class RequestNotSent(Exception):\n     to send a request using a protocol which is no longer connected to a\n     server.\n     \"\"\"\n-}}} '''\n+\n \n \n def _callAppFunction(function):\n@@ -777,7 +772,7 @@ class Request:\n         _callAppFunction(self.bodyProducer.stopProducing)\n \n \n-''' {{{\n+\n class LengthEnforcingConsumer:\n     \"\"\"\n     An L{IConsumer} proxy which enforces an exact length requirement on the\n@@ -1201,7 +1196,7 @@ class TransportProxyProducer:\n         \"\"\"\n         if self._producer is not None:\n             self._producer.pauseProducing()\n-}}} '''\n+\n \n \n class HTTP11ClientProtocol(Protocol):\n@@ -1527,3 +1522,4 @@ class HTTP11ClientProtocol(Protocol):\n         d = Deferred()\n         self._abortDeferreds.append(d)\n         return d\n+}}} '''\n\n@@ -29,23 +29,18 @@ from twisted.python.failure import Failure\n from twisted.web import http\n from twisted.internet import defer, protocol, task, reactor\n from twisted.internet.interfaces import IProtocol\n+from twisted.internet.endpoints import TCP4ClientEndpoint, SSL4ClientEndpoint\n from twisted.python import failure\n from twisted.python.components import proxyForInterface\n from twisted.web import error\n-from twisted.web.iweb import UNKNOWN_LENGTH, IBodyProducer\n+from twisted.web.iweb import UNKNOWN_LENGTH, IBodyProducer, IResponse\n from twisted.web.http_headers import Headers\n \n from twisted.web.client import (\n-    PartialDownloadError,\n+    PartialDownloadError, FileBodyProducer,\n+    CookieAgent, GzipDecoder, ContentDecoderAgent, RedirectAgent,\n+    Agent, ProxyAgent, HTTPConnectionPool, readBody,\n )\n-# newer than 10.0.0\n-#from twisted.web.client import (\n-#    CookieAgent, GzipDecoder, ContentDecoderAgent, RedirectAgent, FileBodyProducer,\n-#    HTTPConnectionPool, Agent, ProxyAgent,\n-#)\n-\n-from .endpoints import TCP4ClientEndpoint, SSL4ClientEndpoint\n-from .iweb import IResponse\n \n ''' {{{\n class PartialDownloadError(error.Error):\n@@ -54,7 +49,7 @@ class PartialDownloadError(error.Error):\n \n     @ivar response: All of the response body which was downloaded.\n     \"\"\"\n-}}} '''\n+\n \n class _URL(tuple):\n     \"\"\"\n@@ -138,22 +133,21 @@ def _makeGetterFactory(url, factoryFactory, contextFactory=None,\n     else:\n         reactor.connectTCP(host, port, factory)\n     return factory\n-\n+}}} '''\n \n # The code which follows is based on the new HTTP client implementation.  It\n # should be significantly better than anything above, though it is not yet\n # feature equivalent.\n \n-from twisted.web.error import SchemeNotSupported\n-from ._newclient import Request, Response, HTTP11ClientProtocol\n-from twisted.web._newclient import ResponseDone\n-from ._newclient import ResponseFailed\n-from twisted.web._newclient import RequestNotSent, RequestTransmissionFailed\n-from twisted.web._newclient import (\n-    PotentialDataLoss, _WrapperException)\n-from ._newclient import (\n-    ResponseNeverReceived)\n+#from twisted.web.error import SchemeNotSupported\n+from twisted.web._newclient import Response\n+#from twisted.web._newclient import Request, HTTP11ClientProtocol\n+from twisted.web._newclient import ResponseDone, ResponseFailed\n+#from twisted.web._newclient import RequestNotSent, RequestTransmissionFailed\n+#from twisted.web._newclient import (\n+#    ResponseNeverReceived, PotentialDataLoss, _WrapperException)\n \n+''' {{{\n try:\n     from twisted.internet.ssl import ClientContextFactory\n except ImportError:\n@@ -1170,7 +1164,7 @@ def readBody(response):\n     d = defer.Deferred()\n     response.deliverBody(_ReadBodyProtocol(response.code, response.phrase, d))\n     return d\n-\n+}}} '''\n \n \n __all__ = [\n\n@@ -21,38 +21,33 @@ from zope.interface import implementer, directlyProvides\n import warnings\n \n from twisted.internet import interfaces, defer, error, fdesc\n-from twisted.internet.protocol import (\n-        ClientFactory, Protocol, Factory)\n+#from twisted.internet.protocol import (\n+#        ClientFactory, Protocol)\n+from twisted.internet.protocol import Factory\n #from twisted.internet import threads, ProcessProtocol\n from twisted.internet.interfaces import IStreamServerEndpointStringParser\n-from twisted.internet.interfaces import IStreamClientEndpointStringParser\n+#from twisted.internet.interfaces import IStreamClientEndpointStringParser\n from twisted.python.filepath import FilePath\n #from twisted.python.failure import Failure\n #from twisted.python import log\n-from twisted.python.components import proxyForInterface\n+#from twisted.python.components import proxyForInterface\n \n from twisted.plugin import IPlugin, getPlugins\n #from twisted.internet import stdio\n \n-# newer than 10.0.0\n-#from twisted.internet.endpoints import (\n-#    TCP4ServerEndpoint, TCP6ServerEndpoint, TCP4ClientEndpoint, SSL4ServerEndpoint, SSL4ClientEndpoint,\n-#    UNIXServerEndpoint, UNIXClientEndpoint, AdoptedStreamServerEndpoint, connectProtocol,\n-#    quoteStringArgument,\n-#    serverFromString, #> using newer _parseSSL, _tokenize in _serverParsers\n-#    clientFromString, #> using newer _clientParsers\n-#    _WrappingProtocol, _WrappingFactory, _TCPServerEndpoint,\n-#    _parseTCP, _parseUNIX, _loadCAsFromDir,\n-#    _parseSSL, _tokenize,\n-#    _parseClientTCP, _parseClientSSL, _parseClientUNIX,\n-#)\n-\n-from .interfaces import IFileDescriptorReceiver\n+from twisted.internet.endpoints import (\n+    clientFromString, serverFromString, quoteStringArgument,\n+    TCP4ServerEndpoint, TCP6ServerEndpoint,\n+    TCP4ClientEndpoint, TCP6ClientEndpoint,\n+    UNIXServerEndpoint, UNIXClientEndpoint,\n+    SSL4ServerEndpoint, SSL4ClientEndpoint,\n+    AdoptedStreamServerEndpoint, connectProtocol,\n+)\n \n \n __all__ = [\"TCP4ClientEndpoint\", \"SSL4ServerEndpoint\"]\n \n-\n+''' {{{\n class _WrappingProtocol(Protocol):\n     \"\"\"\n     Wrap another protocol in order to notify my user when a connection has\n@@ -71,7 +66,7 @@ class _WrappingProtocol(Protocol):\n         self._wrappedProtocol = wrappedProtocol\n \n         for iface in [interfaces.IHalfCloseableProtocol,\n-                      IFileDescriptorReceiver]:\n+                      interfaces.IFileDescriptorReceiver]:\n             if iface.providedBy(self._wrappedProtocol):\n                 directlyProvides(self, iface)\n \n@@ -609,6 +604,7 @@ class AdoptedStreamServerEndpoint(object):\n \n \n \n+\n def _parseTCP(factory, port, interface=\"\", backlog=50):\n     \"\"\"\n     Internal parser function for L{_parseServer} to convert the string\n@@ -1280,4 +1276,4 @@ def connectProtocol(endpoint, protocol):\n         def buildProtocol(self, addr):\n             return protocol\n     return endpoint.connect(OneShotFactory())\n-\n+}}} '''\n\n@@ -13,24 +13,21 @@ from zope.interface import Interface, Attribute\n \n from twisted.internet.interfaces import (\n     IAddress, IConnector, IResolverSimple, IReactorTCP, IReactorSSL,\n-    IReactorUDP, IReactorMulticast, IReactorProcess,\n+    IReactorWin32Events, IReactorUDP, IReactorMulticast, IReactorProcess,\n     IReactorTime, IDelayedCall, IReactorThreads, IReactorCore,\n-    IReactorPluggableResolver, IReactorFDSet,\n+    IReactorPluggableResolver, IReactorDaemonize, IReactorFDSet,\n     IListeningPort, ILoggingContext, IFileDescriptor, IReadDescriptor,\n     IWriteDescriptor, IReadWriteDescriptor, IHalfCloseableDescriptor,\n     ISystemHandle, IConsumer, IProducer, IPushProducer, IPullProducer,\n     IProtocol, IProcessProtocol, IHalfCloseableProtocol,\n-    IProtocolFactory, ITransport, IProcessTransport, IServiceCollection,\n+    IFileDescriptorReceiver, IProtocolFactory, ITransport, ITCPTransport,\n+    IUNIXTransport,\n+    ITLSTransport, ISSLTransport, IProcessTransport, IServiceCollection,\n     IUDPTransport, IUNIXDatagramTransport, IUNIXDatagramConnectedTransport,\n-    IMulticastTransport,\n+    IMulticastTransport, IStreamClientEndpoint, IStreamServerEndpoint,\n+    IStreamServerEndpointStringParser, IStreamClientEndpointStringParser,\n+    IReactorUNIX, IReactorUNIXDatagram, IReactorSocket, IResolver\n )\n-# newer than 10.0.0\n-#from twisted.internet.interfaces import (\n-#    IResolver, IReactorUNIX, IReactorUNIXDatagram, IReactorWin32Events, IReactorSocket,\n-#    IReactorDaemonize, IFileDescriptorReceiver, ITCPTransport, IUNIXTransport,\n-#    ITLSTransport, ISSLTransport, IStreamClientEndpoint, IStreamServerEndpoint,\n-#    IStreamServerEndpointStringParser, IStreamClientEndpointStringParser,\n-#)\n \n ''' {{{\n class IAddress(Interface):\n@@ -95,7 +92,7 @@ class IResolverSimple(Interface):\n         @raise twisted.internet.defer.TimeoutError: Raised (asynchronously)\n         if the name cannot be resolved within the specified timeout period.\n         \"\"\"\n-}}} '''\n+\n \n \n class IResolver(IResolverSimple):\n@@ -635,7 +632,7 @@ class IResolver(IResolverSimple):\n         \"\"\"\n \n \n-''' {{{\n+\n class IReactorTCP(Interface):\n \n     def listenTCP(port, factory, backlog=50, interface=''):\n@@ -722,7 +719,7 @@ class IReactorSSL(Interface):\n \n         @param interface: the hostname to bind to, defaults to '' (all)\n         \"\"\"\n-}}} '''\n+\n \n \n class IReactorUNIX(Interface):\n@@ -850,7 +847,7 @@ class IReactorWin32Events(Interface):\n         \"\"\"\n \n \n-''' {{{\n+\n class IReactorUDP(Interface):\n     \"\"\"\n     UDP socket methods.\n@@ -889,7 +886,7 @@ class IReactorMulticast(Interface):\n         @see: L{twisted.internet.interfaces.IMulticastTransport}\n         @see: U{http://twistedmatrix.com/documents/current/core/howto/udp.html}\n         \"\"\"\n-}}} '''\n+\n \n \n class IReactorSocket(Interface):\n@@ -991,7 +988,7 @@ class IReactorSocket(Interface):\n         \"\"\"\n \n \n-''' {{{\n+\n class IReactorProcess(Interface):\n \n     def spawnProcess(processProtocol, executable, args=(), env={}, path=None,\n@@ -1368,7 +1365,7 @@ class IReactorPluggableResolver(Interface):\n \n         @return: The previously installed resolver.\n         \"\"\"\n-}}} '''\n+\n \n class IReactorDaemonize(Interface):\n     \"\"\"\n@@ -1400,7 +1397,7 @@ class IReactorDaemonize(Interface):\n         \"\"\"\n \n \n-''' {{{\n+\n class IReactorFDSet(Interface):\n     \"\"\"\n     Implement me to be able to use L{IFileDescriptor} type resources.\n@@ -1884,7 +1881,7 @@ class IHalfCloseableProtocol(Interface):\n         This will never be called for TCP connections as TCP does not\n         support notification of this type of half-close.\n         \"\"\"\n-}}} '''\n+\n \n \n class IFileDescriptorReceiver(Interface):\n@@ -1905,7 +1902,7 @@ class IFileDescriptorReceiver(Interface):\n         \"\"\"\n \n \n-''' {{{\n+\n class IProtocolFactory(Interface):\n     \"\"\"\n     Interface for protocol factories.\n@@ -1995,7 +1992,7 @@ class ITransport(Interface):\n \n         @return: An L{IAddress} provider.\n         \"\"\"\n-}}} '''\n+\n \n class ITCPTransport(ITransport):\n     \"\"\"\n@@ -2116,7 +2113,7 @@ class ISSLTransport(ITCPTransport):\n         Return an object with the peer's certificate info.\n         \"\"\"\n \n-''' {{{\n+\n class IProcessTransport(ITransport):\n     \"\"\"\n     A process transport.\n@@ -2345,7 +2342,7 @@ class IMulticastTransport(Interface):\n         \"\"\"\n         Leave multicast group, return L{Deferred} of success.\n         \"\"\"\n-}}} '''\n+\n \n class IStreamClientEndpoint(Interface):\n     \"\"\"\n@@ -2461,3 +2458,4 @@ class IStreamClientEndpointStringParser(Interface):\n         @return: a client endpoint\n         @rtype: L{IStreamClientEndpoint}\n         \"\"\"\n+}}} '''\n\n@@ -15,14 +15,11 @@ from zope.interface import Interface, Attribute\n #from twisted.internet.interfaces import IPushProducer\n \n from twisted.web.iweb import (\n-    ICredentialFactory, IBodyProducer,\n-    UNKNOWN_LENGTH,\n+    IRequest, ICredentialFactory, IBodyProducer, IRenderable, ITemplateLoader,\n+    IResponse, _IRequestEncoder, _IRequestEncoderFactory, UNKNOWN_LENGTH,\n )\n-# newer than 10.0.0\n-#from twisted.web.iweb import (\n-#    IRequest, IRenderable, ITemplateLoader, IResponse, _IRequestEncoder, _IRequestEncoderFactory,\n-#)\n \n+''' {{{\n class IRequest(Interface):\n     \"\"\"\n     An HTTP request.\n@@ -328,7 +325,7 @@ class IRequest(Interface):\n         \"\"\"\n \n \n-''' {{{\n+\n class ICredentialFactory(Interface):\n     \"\"\"\n     A credential factory defines a way to generate a particular kind of\n@@ -432,7 +429,7 @@ class IBodyProducer(IPushProducer):\n         L{Deferred<twisted.internet.defer.Deferred>} returned by\n         C{startProducing} is never fired.\n         \"\"\"\n-}}} '''\n+\n \n \n class IRenderable(Interface):\n@@ -584,7 +581,7 @@ class _IRequestEncoderFactory(Interface):\n         \"\"\"\n \n \n-''' {{{\n+\n UNKNOWN_LENGTH = u\"twisted.web.iweb.UNKNOWN_LENGTH\"\n }}} '''\n __all__ = [\n\n@@ -41,7 +41,7 @@ setup(\n         'Topic :: Software Development :: Libraries :: Python Modules',\n     ],\n     install_requires=[\n-        'Twisted>=10.0.0',\n+        'Twisted>=13.1.0',\n         'w3lib>=1.15.0',\n         'queuelib',\n         'lxml',\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#985755d1fe0aabf922bcdb0e8bc22d67948820cb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 6837 | Files Changed: 5 | Hunks: 14 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6837 | Churn Cumulative: 14150 | Contributors (this commit): 4 | Commits (past 90d): 15 | Contributors (cumulative): 14 | DMM Complexity: None\n\nDIFF:\n@@ -38,9 +38,7 @@ from twisted.internet.error import ConnectionDone\n from twisted.internet.defer import Deferred, succeed, fail, maybeDeferred\n from twisted.internet.defer import CancelledError\n from twisted.internet.protocol import Protocol\n-#from twisted.protocols.basic import LineReceiver\n from twisted.web.iweb import UNKNOWN_LENGTH, IResponse\n-#from twisted.web.http_headers import Headers\n from twisted.web.http import NO_CONTENT, NOT_MODIFIED\n from twisted.web.http import _DataLoss, PotentialDataLoss\n from twisted.web.http import _IdentityTransferDecoder, _ChunkedTransferDecoder\n@@ -59,1467 +57,3 @@ STATUS = 'STATUS'\n HEADER = 'HEADER'\n BODY = 'BODY'\n DONE = 'DONE'\n-\n-''' {{{\n-class BadHeaders(Exception):\n-    \"\"\"\n-    Headers passed to L{Request} were in some way invalid.\n-    \"\"\"\n-\n-\n-\n-class ExcessWrite(Exception):\n-    \"\"\"\n-    The body L{IBodyProducer} for a request tried to write data after\n-    indicating it had finished writing data.\n-    \"\"\"\n-\n-\n-class ParseError(Exception):\n-    \"\"\"\n-    Some received data could not be parsed.\n-\n-    @ivar data: The string which could not be parsed.\n-    \"\"\"\n-    def __init__(self, reason, data):\n-        Exception.__init__(self, reason, data)\n-        self.data = data\n-\n-\n-\n-class BadResponseVersion(ParseError):\n-    \"\"\"\n-    The version string in a status line was unparsable.\n-    \"\"\"\n-\n-\n-\n-class _WrapperException(Exception):\n-    \"\"\"\n-    L{_WrapperException} is the base exception type for exceptions which\n-    include one or more other exceptions as the low-level causes.\n-\n-    @ivar reasons: A list of exceptions.  See subclass documentation for more\n-        details.\n-    \"\"\"\n-    def __init__(self, reasons):\n-        Exception.__init__(self, reasons)\n-        self.reasons = reasons\n-\n-\n-\n-class RequestGenerationFailed(_WrapperException):\n-    \"\"\"\n-    There was an error while creating the bytes which make up a request.\n-\n-    @ivar reasons: A C{list} of one or more L{Failure} instances giving the\n-        reasons the request generation was considered to have failed.\n-    \"\"\"\n-\n-\n-\n-class RequestTransmissionFailed(_WrapperException):\n-    \"\"\"\n-    There was an error while sending the bytes which make up a request.\n-\n-    @ivar reasons: A C{list} of one or more L{Failure} instances giving the\n-        reasons the request transmission was considered to have failed.\n-    \"\"\"\n-\n-\n-\n-class ConnectionAborted(Exception):\n-    \"\"\"\n-    The connection was explicitly aborted by application code.\n-    \"\"\"\n-\n-\n-\n-class WrongBodyLength(Exception):\n-    \"\"\"\n-    An L{IBodyProducer} declared the number of bytes it was going to\n-    produce (via its C{length} attribute) and then produced a different number\n-    of bytes.\n-    \"\"\"\n-\n-\n-\n-class ResponseDone(Exception):\n-    \"\"\"\n-    L{ResponseDone} may be passed to L{IProtocol.connectionLost} on the\n-    protocol passed to L{Response.deliverBody} and indicates that the entire\n-    response has been delivered.\n-    \"\"\"\n-\n-\n-\n-class ResponseFailed(_WrapperException):\n-    \"\"\"\n-    L{ResponseFailed} indicates that all of the response to a request was not\n-    received for some reason.\n-\n-    @ivar reasons: A C{list} of one or more L{Failure} instances giving the\n-        reasons the response was considered to have failed.\n-\n-    @ivar response: If specified, the L{Response} received from the server (and\n-        in particular the status code and the headers).\n-    \"\"\"\n-\n-    def __init__(self, reasons, response=None):\n-        _WrapperException.__init__(self, reasons)\n-        self.response = response\n-\n-\n-\n-class ResponseNeverReceived(ResponseFailed):\n-    \"\"\"\n-    A L{ResponseFailed} that knows no response bytes at all have been received.\n-    \"\"\"\n-\n-\n-\n-class RequestNotSent(Exception):\n-    \"\"\"\n-    L{RequestNotSent} indicates that an attempt was made to issue a request but\n-    for reasons unrelated to the details of the request itself, the request\n-    could not be sent.  For example, this may indicate that an attempt was made\n-    to send a request using a protocol which is no longer connected to a\n-    server.\n-    \"\"\"\n-\n-\n-\n-def _callAppFunction(function):\n-    \"\"\"\n-    Call C{function}.  If it raises an exception, log it with a minimal\n-    description of the source.\n-\n-    @return: C{None}\n-    \"\"\"\n-    try:\n-        function()\n-    except:\n-        log.err(None, \"Unexpected exception from %s\" % (\n-                fullyQualifiedName(function),))\n-\n-\n-\n-class HTTPParser(LineReceiver):\n-    \"\"\"\n-    L{HTTPParser} handles the parsing side of HTTP processing. With a suitable\n-    subclass, it can parse either the client side or the server side of the\n-    connection.\n-\n-    @ivar headers: All of the non-connection control message headers yet\n-        received.\n-\n-    @ivar state: State indicator for the response parsing state machine.  One\n-        of C{STATUS}, C{HEADER}, C{BODY}, C{DONE}.\n-\n-    @ivar _partialHeader: C{None} or a C{list} of the lines of a multiline\n-        header while that header is being received.\n-    \"\"\"\n-\n-    # NOTE: According to HTTP spec, we're supposed to eat the\n-    # 'Proxy-Authenticate' and 'Proxy-Authorization' headers also, but that\n-    # doesn't sound like a good idea to me, because it makes it impossible to\n-    # have a non-authenticating transparent proxy in front of an authenticating\n-    # proxy. An authenticating proxy can eat them itself. -jknight\n-    #\n-    # Further, quoting\n-    # http://homepages.tesco.net/J.deBoynePollard/FGA/web-proxy-connection-header.html\n-    # regarding the 'Proxy-Connection' header:\n-    #\n-    #    The Proxy-Connection: header is a mistake in how some web browsers\n-    #    use HTTP. Its name is the result of a false analogy. It is not a\n-    #    standard part of the protocol. There is a different standard\n-    #    protocol mechanism for doing what it does. And its existence\n-    #    imposes a requirement upon HTTP servers such that no proxy HTTP\n-    #    server can be standards-conforming in practice.\n-    #\n-    # -exarkun\n-\n-    # Some servers (like http://news.ycombinator.com/) return status lines and\n-    # HTTP headers delimited by \\n instead of \\r\\n.\n-    delimiter = '\\n'\n-\n-    CONNECTION_CONTROL_HEADERS = set([\n-            'content-length', 'connection', 'keep-alive', 'te', 'trailers',\n-            'transfer-encoding', 'upgrade', 'proxy-connection'])\n-\n-    def connectionMade(self):\n-        self.headers = Headers()\n-        self.connHeaders = Headers()\n-        self.state = STATUS\n-        self._partialHeader = None\n-\n-\n-    def switchToBodyMode(self, decoder):\n-        \"\"\"\n-        Switch to body parsing mode - interpret any more bytes delivered as\n-        part of the message body and deliver them to the given decoder.\n-        \"\"\"\n-        if self.state == BODY:\n-            raise RuntimeError(\"already in body mode\")\n-\n-        self.bodyDecoder = decoder\n-        self.state = BODY\n-        self.setRawMode()\n-\n-\n-    def lineReceived(self, line):\n-        \"\"\"\n-        Handle one line from a response.\n-        \"\"\"\n-        # Handle the normal CR LF case.\n-        if line[-1:] == '\\r':\n-            line = line[:-1]\n-\n-        if self.state == STATUS:\n-            self.statusReceived(line)\n-            self.state = HEADER\n-        elif self.state == HEADER:\n-            if not line or line[0] not in ' \\t':\n-                if self._partialHeader is not None:\n-                    header = ''.join(self._partialHeader)\n-                    name, value = header.split(':', 1)\n-                    value = value.strip()\n-                    self.headerReceived(name, value)\n-                if not line:\n-                    # Empty line means the header section is over.\n-                    self.allHeadersReceived()\n-                else:\n-                    # Line not beginning with LWS is another header.\n-                    self._partialHeader = [line]\n-            else:\n-                # A line beginning with LWS is a continuation of a header\n-                # begun on a previous line.\n-                self._partialHeader.append(line)\n-\n-\n-    def rawDataReceived(self, data):\n-        \"\"\"\n-        Pass data from the message body to the body decoder object.\n-        \"\"\"\n-        self.bodyDecoder.dataReceived(data)\n-\n-\n-    def isConnectionControlHeader(self, name):\n-        \"\"\"\n-        Return C{True} if the given lower-cased name is the name of a\n-        connection control header (rather than an entity header).\n-\n-        According to RFC 2616, section 14.10, the tokens in the Connection\n-        header are probably relevant here.  However, I am not sure what the\n-        practical consequences of either implementing or ignoring that are.\n-        So I leave it unimplemented for the time being.\n-        \"\"\"\n-        return name in self.CONNECTION_CONTROL_HEADERS\n-\n-\n-    def statusReceived(self, status):\n-        \"\"\"\n-        Callback invoked whenever the first line of a new message is received.\n-        Override this.\n-\n-        @param status: The first line of an HTTP request or response message\n-            without trailing I{CR LF}.\n-        @type status: C{str}\n-        \"\"\"\n-\n-\n-    def headerReceived(self, name, value):\n-        \"\"\"\n-        Store the given header in C{self.headers}.\n-        \"\"\"\n-        name = name.lower()\n-        if self.isConnectionControlHeader(name):\n-            headers = self.connHeaders\n-        else:\n-            headers = self.headers\n-        headers.addRawHeader(name, value)\n-\n-\n-    def allHeadersReceived(self):\n-        \"\"\"\n-        Callback invoked after the last header is passed to C{headerReceived}.\n-        Override this to change to the C{BODY} or C{DONE} state.\n-        \"\"\"\n-        self.switchToBodyMode(None)\n-\n-\n-\n-class HTTPClientParser(HTTPParser):\n-    \"\"\"\n-    An HTTP parser which only handles HTTP responses.\n-\n-    @ivar request: The request with which the expected response is associated.\n-    @type request: L{Request}\n-\n-    @ivar NO_BODY_CODES: A C{set} of response codes which B{MUST NOT} have a\n-        body.\n-\n-    @ivar finisher: A callable to invoke when this response is fully parsed.\n-\n-    @ivar _responseDeferred: A L{Deferred} which will be called back with the\n-        response when all headers in the response have been received.\n-        Thereafter, C{None}.\n-\n-    @ivar _everReceivedData: C{True} if any bytes have been received.\n-    \"\"\"\n-    NO_BODY_CODES = set([NO_CONTENT, NOT_MODIFIED])\n-\n-    _transferDecoders = {\n-        'chunked': _ChunkedTransferDecoder,\n-        }\n-\n-    bodyDecoder = None\n-\n-    def __init__(self, request, finisher):\n-        self.request = request\n-        self.finisher = finisher\n-        self._responseDeferred = Deferred()\n-        self._everReceivedData = False\n-\n-\n-    def dataReceived(self, data):\n-        \"\"\"\n-        Override so that we know if any response has been received.\n-        \"\"\"\n-        self._everReceivedData = True\n-        HTTPParser.dataReceived(self, data)\n-\n-\n-    def parseVersion(self, strversion):\n-        \"\"\"\n-        Parse version strings of the form Protocol '/' Major '.' Minor. E.g.\n-        'HTTP/1.1'.  Returns (protocol, major, minor).  Will raise ValueError\n-        on bad syntax.\n-        \"\"\"\n-        try:\n-            proto, strnumber = strversion.split('/')\n-            major, minor = strnumber.split('.')\n-            major, minor = int(major), int(minor)\n-        except ValueError as e:\n-            raise BadResponseVersion(str(e), strversion)\n-        if major < 0 or minor < 0:\n-            raise BadResponseVersion(\"version may not be negative\", strversion)\n-        return (proto, major, minor)\n-\n-\n-    def statusReceived(self, status):\n-        \"\"\"\n-        Parse the status line into its components and create a response object\n-        to keep track of this response's state.\n-        \"\"\"\n-        parts = status.split(' ', 2)\n-        if len(parts) != 3:\n-            raise ParseError(\"wrong number of parts\", status)\n-\n-        try:\n-            statusCode = int(parts[1])\n-        except ValueError:\n-            raise ParseError(\"non-integer status code\", status)\n-\n-        self.response = Response(\n-            self.parseVersion(parts[0]),\n-            statusCode,\n-            parts[2],\n-            self.headers,\n-            self.transport)\n-\n-\n-    def _finished(self, rest):\n-        \"\"\"\n-        Called to indicate that an entire response has been received.  No more\n-        bytes will be interpreted by this L{HTTPClientParser}.  Extra bytes are\n-        passed up and the state of this L{HTTPClientParser} is set to I{DONE}.\n-\n-        @param rest: A C{str} giving any extra bytes delivered to this\n-            L{HTTPClientParser} which are not part of the response being\n-            parsed.\n-        \"\"\"\n-        self.state = DONE\n-        self.finisher(rest)\n-\n-\n-    def isConnectionControlHeader(self, name):\n-        \"\"\"\n-        Content-Length in the response to a HEAD request is an entity header,\n-        not a connection control header.\n-        \"\"\"\n-        if self.request.method == 'HEAD' and name == 'content-length':\n-            return False\n-        return HTTPParser.isConnectionControlHeader(self, name)\n-\n-\n-    def allHeadersReceived(self):\n-        \"\"\"\n-        Figure out how long the response body is going to be by examining\n-        headers and stuff.\n-        \"\"\"\n-        if (self.response.code in self.NO_BODY_CODES\n-            or self.request.method == 'HEAD'):\n-            self.response.length = 0\n-            self._finished(self.clearLineBuffer())\n-        else:\n-            transferEncodingHeaders = self.connHeaders.getRawHeaders(\n-                'transfer-encoding')\n-            if transferEncodingHeaders:\n-\n-                # This could be a KeyError.  However, that would mean we do not\n-                # know how to decode the response body, so failing the request\n-                # is as good a behavior as any.  Perhaps someday we will want\n-                # to normalize/document/test this specifically, but failing\n-                # seems fine to me for now.\n-                transferDecoder = self._transferDecoders[transferEncodingHeaders[0].lower()]\n-\n-                # If anyone ever invents a transfer encoding other than\n-                # chunked (yea right), and that transfer encoding can predict\n-                # the length of the response body, it might be sensible to\n-                # allow the transfer decoder to set the response object's\n-                # length attribute.\n-            else:\n-                contentLengthHeaders = self.connHeaders.getRawHeaders('content-length')\n-                if contentLengthHeaders is None:\n-                    contentLength = None\n-                elif len(contentLengthHeaders) == 1:\n-                    contentLength = int(contentLengthHeaders[0])\n-                    self.response.length = contentLength\n-                else:\n-                    # \"HTTP Message Splitting\" or \"HTTP Response Smuggling\"\n-                    # potentially happening.  Or it's just a buggy server.\n-                    raise ValueError(\n-                        \"Too many Content-Length headers; response is invalid\")\n-\n-                if contentLength == 0:\n-                    self._finished(self.clearLineBuffer())\n-                    transferDecoder = None\n-                else:\n-                    transferDecoder = lambda x, y: _IdentityTransferDecoder(\n-                        contentLength, x, y)\n-\n-            if transferDecoder is None:\n-                self.response._bodyDataFinished()\n-            else:\n-                # Make sure as little data as possible from the response body\n-                # gets delivered to the response object until the response\n-                # object actually indicates it is ready to handle bytes\n-                # (probably because an application gave it a way to interpret\n-                # them).\n-                self.transport.pauseProducing()\n-                self.switchToBodyMode(transferDecoder(\n-                        self.response._bodyDataReceived,\n-                        self._finished))\n-\n-        # This must be last.  If it were first, then application code might\n-        # change some state (for example, registering a protocol to receive the\n-        # response body).  Then the pauseProducing above would be wrong since\n-        # the response is ready for bytes and nothing else would ever resume\n-        # the transport.\n-        self._responseDeferred.callback(self.response)\n-        del self._responseDeferred\n-\n-\n-    def connectionLost(self, reason):\n-        if self.bodyDecoder is not None:\n-            try:\n-                try:\n-                    self.bodyDecoder.noMoreData()\n-                except PotentialDataLoss:\n-                    self.response._bodyDataFinished(Failure())\n-                except _DataLoss:\n-                    self.response._bodyDataFinished(\n-                        Failure(ResponseFailed([reason, Failure()],\n-                                               self.response)))\n-                else:\n-                    self.response._bodyDataFinished()\n-            except:\n-                # Handle exceptions from both the except suites and the else\n-                # suite.  Those functions really shouldn't raise exceptions,\n-                # but maybe there's some buggy application code somewhere\n-                # making things difficult.\n-                log.err()\n-        elif self.state != DONE:\n-            if self._everReceivedData:\n-                exceptionClass = ResponseFailed\n-            else:\n-                exceptionClass = ResponseNeverReceived\n-            self._responseDeferred.errback(Failure(exceptionClass([reason])))\n-            del self._responseDeferred\n-\n-\n-\n-class Request:\n-    \"\"\"\n-    A L{Request} instance describes an HTTP request to be sent to an HTTP\n-    server.\n-\n-    @ivar method: The HTTP method to for this request, ex: 'GET', 'HEAD',\n-        'POST', etc.\n-    @type method: C{str}\n-\n-    @ivar uri: The relative URI of the resource to request.  For example,\n-        C{'/foo/bar?baz=quux'}.\n-    @type uri: C{str}\n-\n-    @ivar headers: Headers to be sent to the server.  It is important to\n-        note that this object does not create any implicit headers.  So it\n-        is up to the HTTP Client to add required headers such as 'Host'.\n-    @type headers: L{twisted.web.http_headers.Headers}\n-\n-    @ivar bodyProducer: C{None} or an L{IBodyProducer} provider which\n-        produces the content body to send to the remote HTTP server.\n-\n-    @ivar persistent: Set to C{True} when you use HTTP persistent connection.\n-    @type persistent: C{bool}\n-    \"\"\"\n-    def __init__(self, method, uri, headers, bodyProducer, persistent=False):\n-        self.method = method\n-        self.uri = uri\n-        self.headers = headers\n-        self.bodyProducer = bodyProducer\n-        self.persistent = persistent\n-\n-\n-    def _writeHeaders(self, transport, TEorCL):\n-        hosts = self.headers.getRawHeaders('host', ())\n-        if len(hosts) != 1:\n-            raise BadHeaders(\"Exactly one Host header required\")\n-\n-        # In the future, having the protocol version be a parameter to this\n-        # method would probably be good.  It would be nice if this method\n-        # weren't limited to issuing HTTP/1.1 requests.\n-        requestLines = []\n-        requestLines.append(\n-            '%s %s HTTP/1.1\\r\\n' % (self.method, self.uri))\n-        if not self.persistent:\n-            requestLines.append('Connection: close\\r\\n')\n-        if TEorCL is not None:\n-            requestLines.append(TEorCL)\n-        for name, values in self.headers.getAllRawHeaders():\n-            requestLines.extend(['%s: %s\\r\\n' % (name, v) for v in values])\n-        requestLines.append('\\r\\n')\n-        transport.writeSequence(requestLines)\n-\n-\n-    def _writeToChunked(self, transport):\n-        \"\"\"\n-        Write this request to the given transport using chunked\n-        transfer-encoding to frame the body.\n-        \"\"\"\n-        self._writeHeaders(transport, 'Transfer-Encoding: chunked\\r\\n')\n-        encoder = ChunkedEncoder(transport)\n-        encoder.registerProducer(self.bodyProducer, True)\n-        d = self.bodyProducer.startProducing(encoder)\n-\n-        def cbProduced(ignored):\n-            encoder.unregisterProducer()\n-        def ebProduced(err):\n-            encoder._allowNoMoreWrites()\n-            # Don't call the encoder's unregisterProducer because it will write\n-            # a zero-length chunk.  This would indicate to the server that the\n-            # request body is complete.  There was an error, though, so we\n-            # don't want to do that.\n-            transport.unregisterProducer()\n-            return err\n-        d.addCallbacks(cbProduced, ebProduced)\n-        return d\n-\n-\n-    def _writeToContentLength(self, transport):\n-        \"\"\"\n-        Write this request to the given transport using content-length to frame\n-        the body.\n-        \"\"\"\n-        self._writeHeaders(\n-            transport,\n-            'Content-Length: %d\\r\\n' % (self.bodyProducer.length,))\n-\n-        # This Deferred is used to signal an error in the data written to the\n-        # encoder below.  It can only errback and it will only do so before too\n-        # many bytes have been written to the encoder and before the producer\n-        # Deferred fires.\n-        finishedConsuming = Deferred()\n-\n-        # This makes sure the producer writes the correct number of bytes for\n-        # the request body.\n-        encoder = LengthEnforcingConsumer(\n-            self.bodyProducer, transport, finishedConsuming)\n-\n-        transport.registerProducer(self.bodyProducer, True)\n-\n-        finishedProducing = self.bodyProducer.startProducing(encoder)\n-\n-        def combine(consuming, producing):\n-            # This Deferred is returned and will be fired when the first of\n-            # consuming or producing fires. If it's cancelled, forward that\n-            # cancellation to the producer.\n-            def cancelConsuming(ign):\n-                finishedProducing.cancel()\n-            ultimate = Deferred(cancelConsuming)\n-\n-            # Keep track of what has happened so far.  This initially\n-            # contains None, then an integer uniquely identifying what\n-            # sequence of events happened.  See the callbacks and errbacks\n-            # defined below for the meaning of each value.\n-            state = [None]\n-\n-            def ebConsuming(err):\n-                if state == [None]:\n-                    # The consuming Deferred failed first.  This means the\n-                    # overall writeTo Deferred is going to errback now.  The\n-                    # producing Deferred should not fire later (because the\n-                    # consumer should have called stopProducing on the\n-                    # producer), but if it does, a callback will be ignored\n-                    # and an errback will be logged.\n-                    state[0] = 1\n-                    ultimate.errback(err)\n-                else:\n-                    # The consuming Deferred errbacked after the producing\n-                    # Deferred fired.  This really shouldn't ever happen.\n-                    # If it does, I goofed.  Log the error anyway, just so\n-                    # there's a chance someone might notice and complain.\n-                    log.err(\n-                        err,\n-                        \"Buggy state machine in %r/[%d]: \"\n-                        \"ebConsuming called\" % (self, state[0]))\n-\n-            def cbProducing(result):\n-                if state == [None]:\n-                    # The producing Deferred succeeded first.  Nothing will\n-                    # ever happen to the consuming Deferred.  Tell the\n-                    # encoder we're done so it can check what the producer\n-                    # wrote and make sure it was right.\n-                    state[0] = 2\n-                    try:\n-                        encoder._noMoreWritesExpected()\n-                    except:\n-                        # Fail the overall writeTo Deferred - something the\n-                        # producer did was wrong.\n-                        ultimate.errback()\n-                    else:\n-                        # Success - succeed the overall writeTo Deferred.\n-                        ultimate.callback(None)\n-                # Otherwise, the consuming Deferred already errbacked.  The\n-                # producing Deferred wasn't supposed to fire, but it did\n-                # anyway.  It's buggy, but there's not really anything to be\n-                # done about it.  Just ignore this result.\n-\n-            def ebProducing(err):\n-                if state == [None]:\n-                    # The producing Deferred failed first.  This means the\n-                    # overall writeTo Deferred is going to errback now.\n-                    # Tell the encoder that we're done so it knows to reject\n-                    # further writes from the producer (which should not\n-                    # happen, but the producer may be buggy).\n-                    state[0] = 3\n-                    encoder._allowNoMoreWrites()\n-                    ultimate.errback(err)\n-                else:\n-                    # The producing Deferred failed after the consuming\n-                    # Deferred failed.  It shouldn't have, so it's buggy.\n-                    # Log the exception in case anyone who can fix the code\n-                    # is watching.\n-                    log.err(err, \"Producer is buggy\")\n-\n-            consuming.addErrback(ebConsuming)\n-            producing.addCallbacks(cbProducing, ebProducing)\n-\n-            return ultimate\n-\n-        d = combine(finishedConsuming, finishedProducing)\n-        def f(passthrough):\n-            # Regardless of what happens with the overall Deferred, once it\n-            # fires, the producer registered way up above the definition of\n-            # combine should be unregistered.\n-            transport.unregisterProducer()\n-            return passthrough\n-        d.addBoth(f)\n-        return d\n-\n-\n-    def writeTo(self, transport):\n-        \"\"\"\n-        Format this L{Request} as an HTTP/1.1 request and write it to the given\n-        transport.  If bodyProducer is not None, it will be associated with an\n-        L{IConsumer}.\n-\n-        @return: A L{Deferred} which fires with C{None} when the request has\n-            been completely written to the transport or with a L{Failure} if\n-            there is any problem generating the request bytes.\n-        \"\"\"\n-        if self.bodyProducer is not None:\n-            if self.bodyProducer.length is UNKNOWN_LENGTH:\n-                return self._writeToChunked(transport)\n-            else:\n-                return self._writeToContentLength(transport)\n-        else:\n-            self._writeHeaders(transport, None)\n-            return succeed(None)\n-\n-\n-    def stopWriting(self):\n-        \"\"\"\n-        Stop writing this request to the transport.  This can only be called\n-        after C{writeTo} and before the L{Deferred} returned by C{writeTo}\n-        fires.  It should cancel any asynchronous task started by C{writeTo}.\n-        The L{Deferred} returned by C{writeTo} need not be fired if this method\n-        is called.\n-        \"\"\"\n-        # If bodyProducer is None, then the Deferred returned by writeTo has\n-        # fired already and this method cannot be called.\n-        _callAppFunction(self.bodyProducer.stopProducing)\n-\n-\n-\n-class LengthEnforcingConsumer:\n-    \"\"\"\n-    An L{IConsumer} proxy which enforces an exact length requirement on the\n-    total data written to it.\n-\n-    @ivar _length: The number of bytes remaining to be written.\n-\n-    @ivar _producer: The L{IBodyProducer} which is writing to this\n-        consumer.\n-\n-    @ivar _consumer: The consumer to which at most C{_length} bytes will be\n-        forwarded.\n-\n-    @ivar _finished: A L{Deferred} which will be fired with a L{Failure} if too\n-        many bytes are written to this consumer.\n-    \"\"\"\n-    def __init__(self, producer, consumer, finished):\n-        self._length = producer.length\n-        self._producer = producer\n-        self._consumer = consumer\n-        self._finished = finished\n-\n-\n-    def _allowNoMoreWrites(self):\n-        \"\"\"\n-        Indicate that no additional writes are allowed.  Attempts to write\n-        after calling this method will be met with an exception.\n-        \"\"\"\n-        self._finished = None\n-\n-\n-    def write(self, bytes):\n-        \"\"\"\n-        Write C{bytes} to the underlying consumer unless\n-        C{_noMoreWritesExpected} has been called or there are/have been too\n-        many bytes.\n-        \"\"\"\n-        if self._finished is None:\n-            # No writes are supposed to happen any more.  Try to convince the\n-            # calling code to stop calling this method by calling its\n-            # stopProducing method and then throwing an exception at it.  This\n-            # exception isn't documented as part of the API because you're\n-            # never supposed to expect it: only buggy code will ever receive\n-            # it.\n-            self._producer.stopProducing()\n-            raise ExcessWrite()\n-\n-        if len(bytes) <= self._length:\n-            self._length -= len(bytes)\n-            self._consumer.write(bytes)\n-        else:\n-            # No synchronous exception is raised in *this* error path because\n-            # we still have _finished which we can use to report the error to a\n-            # better place than the direct caller of this method (some\n-            # arbitrary application code).\n-            _callAppFunction(self._producer.stopProducing)\n-            self._finished.errback(WrongBodyLength(\"too many bytes written\"))\n-            self._allowNoMoreWrites()\n-\n-\n-    def _noMoreWritesExpected(self):\n-        \"\"\"\n-        Called to indicate no more bytes will be written to this consumer.\n-        Check to see that the correct number have been written.\n-\n-        @raise WrongBodyLength: If not enough bytes have been written.\n-        \"\"\"\n-        if self._finished is not None:\n-            self._allowNoMoreWrites()\n-            if self._length:\n-                raise WrongBodyLength(\"too few bytes written\")\n-\n-\n-\n-def makeStatefulDispatcher(name, template):\n-    \"\"\"\n-    Given a I{dispatch} name and a function, return a function which can be\n-    used as a method and which, when called, will call another method defined\n-    on the instance and return the result.  The other method which is called is\n-    determined by the value of the C{_state} attribute of the instance.\n-\n-    @param name: A string which is used to construct the name of the subsidiary\n-        method to invoke.  The subsidiary method is named like C{'_%s_%s' %\n-        (name, _state)}.\n-\n-    @param template: A function object which is used to give the returned\n-        function a docstring.\n-\n-    @return: The dispatcher function.\n-    \"\"\"\n-    def dispatcher(self, *args, **kwargs):\n-        func = getattr(self, '_' + name + '_' + self._state, None)\n-        if func is None:\n-            raise RuntimeError(\n-                \"%r has no %s method in state %s\" % (self, name, self._state))\n-        return func(*args, **kwargs)\n-    dispatcher.__doc__ = template.__doc__\n-    return dispatcher\n-\n-\n-\n-class Response:\n-    \"\"\"\n-    A L{Response} instance describes an HTTP response received from an HTTP\n-    server.\n-\n-    L{Response} should not be subclassed or instantiated.\n-\n-    @ivar _transport: The transport which is delivering this response.\n-\n-    @ivar _bodyProtocol: The L{IProtocol} provider to which the body is\n-        delivered.  C{None} before one has been registered with\n-        C{deliverBody}.\n-\n-    @ivar _bodyBuffer: A C{list} of the strings passed to C{bodyDataReceived}\n-        before C{deliverBody} is called.  C{None} afterwards.\n-\n-    @ivar _state: Indicates what state this L{Response} instance is in,\n-        particularly with respect to delivering bytes from the response body\n-        to an application-suppled protocol object.  This may be one of\n-        C{'INITIAL'}, C{'CONNECTED'}, C{'DEFERRED_CLOSE'}, or C{'FINISHED'},\n-        with the following meanings:\n-\n-          - INITIAL: This is the state L{Response} objects start in.  No\n-            protocol has yet been provided and the underlying transport may\n-            still have bytes to deliver to it.\n-\n-          - DEFERRED_CLOSE: If the underlying transport indicates all bytes\n-            have been delivered but no application-provided protocol is yet\n-            available, the L{Response} moves to this state.  Data is\n-            buffered and waiting for a protocol to be delivered to.\n-\n-          - CONNECTED: If a protocol is provided when the state is INITIAL,\n-            the L{Response} moves to this state.  Any buffered data is\n-            delivered and any data which arrives from the transport\n-            subsequently is given directly to the protocol.\n-\n-          - FINISHED: If a protocol is provided in the DEFERRED_CLOSE state,\n-            the L{Response} moves to this state after delivering all\n-            buffered data to the protocol.  Otherwise, if the L{Response} is\n-            in the CONNECTED state, if the transport indicates there is no\n-            more data, the L{Response} moves to this state.  Nothing else\n-            can happen once the L{Response} is in this state.\n-    \"\"\"\n-    implements(IResponse)\n-\n-    length = UNKNOWN_LENGTH\n-\n-    _bodyProtocol = None\n-    _bodyFinished = False\n-\n-    def __init__(self, version, code, phrase, headers, _transport):\n-        self.version = version\n-        self.code = code\n-        self.phrase = phrase\n-        self.headers = headers\n-        self._transport = _transport\n-        self._bodyBuffer = []\n-        self._state = 'INITIAL'\n-\n-\n-    def deliverBody(self, protocol):\n-        \"\"\"\n-        Dispatch the given L{IProtocol} depending of the current state of the\n-        response.\n-        \"\"\"\n-    deliverBody = makeStatefulDispatcher('deliverBody', deliverBody)\n-\n-\n-    def _deliverBody_INITIAL(self, protocol):\n-        \"\"\"\n-        Deliver any buffered data to C{protocol} and prepare to deliver any\n-        future data to it.  Move to the C{'CONNECTED'} state.\n-        \"\"\"\n-        # Now that there's a protocol to consume the body, resume the\n-        # transport.  It was previously paused by HTTPClientParser to avoid\n-        # reading too much data before it could be handled.\n-        self._transport.resumeProducing()\n-\n-        protocol.makeConnection(self._transport)\n-        self._bodyProtocol = protocol\n-        for data in self._bodyBuffer:\n-            self._bodyProtocol.dataReceived(data)\n-        self._bodyBuffer = None\n-        self._state = 'CONNECTED'\n-\n-\n-    def _deliverBody_CONNECTED(self, protocol):\n-        \"\"\"\n-        It is invalid to attempt to deliver data to a protocol when it is\n-        already being delivered to another protocol.\n-        \"\"\"\n-        raise RuntimeError(\n-            \"Response already has protocol %r, cannot deliverBody \"\n-            \"again\" % (self._bodyProtocol,))\n-\n-\n-    def _deliverBody_DEFERRED_CLOSE(self, protocol):\n-        \"\"\"\n-        Deliver any buffered data to C{protocol} and then disconnect the\n-        protocol.  Move to the C{'FINISHED'} state.\n-        \"\"\"\n-        # Unlike _deliverBody_INITIAL, there is no need to resume the\n-        # transport here because all of the response data has been received\n-        # already.  Some higher level code may want to resume the transport if\n-        # that code expects further data to be received over it.\n-\n-        protocol.makeConnection(self._transport)\n-\n-        for data in self._bodyBuffer:\n-            protocol.dataReceived(data)\n-        self._bodyBuffer = None\n-        protocol.connectionLost(self._reason)\n-        self._state = 'FINISHED'\n-\n-\n-    def _deliverBody_FINISHED(self, protocol):\n-        \"\"\"\n-        It is invalid to attempt to deliver data to a protocol after the\n-        response body has been delivered to another protocol.\n-        \"\"\"\n-        raise RuntimeError(\n-            \"Response already finished, cannot deliverBody now.\")\n-\n-\n-    def _bodyDataReceived(self, data):\n-        \"\"\"\n-        Called by HTTPClientParser with chunks of data from the response body.\n-        They will be buffered or delivered to the protocol passed to\n-        deliverBody.\n-        \"\"\"\n-    _bodyDataReceived = makeStatefulDispatcher('bodyDataReceived',\n-                                               _bodyDataReceived)\n-\n-\n-    def _bodyDataReceived_INITIAL(self, data):\n-        \"\"\"\n-        Buffer any data received for later delivery to a protocol passed to\n-        C{deliverBody}.\n-\n-        Little or no data should be buffered by this method, since the\n-        transport has been paused and will not be resumed until a protocol\n-        is supplied.\n-        \"\"\"\n-        self._bodyBuffer.append(data)\n-\n-\n-    def _bodyDataReceived_CONNECTED(self, data):\n-        \"\"\"\n-        Deliver any data received to the protocol to which this L{Response}\n-        is connected.\n-        \"\"\"\n-        self._bodyProtocol.dataReceived(data)\n-\n-\n-    def _bodyDataReceived_DEFERRED_CLOSE(self, data):\n-        \"\"\"\n-        It is invalid for data to be delivered after it has been indicated\n-        that the response body has been completely delivered.\n-        \"\"\"\n-        raise RuntimeError(\"Cannot receive body data after _bodyDataFinished\")\n-\n-\n-    def _bodyDataReceived_FINISHED(self, data):\n-        \"\"\"\n-        It is invalid for data to be delivered after the response body has\n-        been delivered to a protocol.\n-        \"\"\"\n-        raise RuntimeError(\"Cannot receive body data after protocol disconnected\")\n-\n-\n-    def _bodyDataFinished(self, reason=None):\n-        \"\"\"\n-        Called by HTTPClientParser when no more body data is available.  If the\n-        optional reason is supplied, this indicates a problem or potential\n-        problem receiving all of the response body.\n-        \"\"\"\n-    _bodyDataFinished = makeStatefulDispatcher('bodyDataFinished',\n-                                               _bodyDataFinished)\n-\n-\n-    def _bodyDataFinished_INITIAL(self, reason=None):\n-        \"\"\"\n-        Move to the C{'DEFERRED_CLOSE'} state to wait for a protocol to\n-        which to deliver the response body.\n-        \"\"\"\n-        self._state = 'DEFERRED_CLOSE'\n-        if reason is None:\n-            reason = Failure(ResponseDone(\"Response body fully received\"))\n-        self._reason = reason\n-\n-\n-    def _bodyDataFinished_CONNECTED(self, reason=None):\n-        \"\"\"\n-        Disconnect the protocol and move to the C{'FINISHED'} state.\n-        \"\"\"\n-        if reason is None:\n-            reason = Failure(ResponseDone(\"Response body fully received\"))\n-        self._bodyProtocol.connectionLost(reason)\n-        self._bodyProtocol = None\n-        self._state = 'FINISHED'\n-\n-\n-    def _bodyDataFinished_DEFERRED_CLOSE(self):\n-        \"\"\"\n-        It is invalid to attempt to notify the L{Response} of the end of the\n-        response body data more than once.\n-        \"\"\"\n-        raise RuntimeError(\"Cannot finish body data more than once\")\n-\n-\n-    def _bodyDataFinished_FINISHED(self):\n-        \"\"\"\n-        It is invalid to attempt to notify the L{Response} of the end of the\n-        response body data more than once.\n-        \"\"\"\n-        raise RuntimeError(\"Cannot finish body data after protocol disconnected\")\n-\n-\n-\n-class ChunkedEncoder:\n-    \"\"\"\n-    Helper object which exposes L{IConsumer} on top of L{HTTP11ClientProtocol}\n-    for streaming request bodies to the server.\n-    \"\"\"\n-    implements(IConsumer)\n-\n-    def __init__(self, transport):\n-        self.transport = transport\n-\n-\n-    def _allowNoMoreWrites(self):\n-        \"\"\"\n-        Indicate that no additional writes are allowed.  Attempts to write\n-        after calling this method will be met with an exception.\n-        \"\"\"\n-        self.transport = None\n-\n-\n-    def registerProducer(self, producer, streaming):\n-        \"\"\"\n-        Register the given producer with C{self.transport}.\n-        \"\"\"\n-        self.transport.registerProducer(producer, streaming)\n-\n-\n-    def write(self, data):\n-        \"\"\"\n-        Write the given request body bytes to the transport using chunked\n-        encoding.\n-\n-        @type data: C{str}\n-        \"\"\"\n-        if self.transport is None:\n-            raise ExcessWrite()\n-        self.transport.writeSequence((\"%x\\r\\n\" % len(data), data, \"\\r\\n\"))\n-\n-\n-    def unregisterProducer(self):\n-        \"\"\"\n-        Indicate that the request body is complete and finish the request.\n-        \"\"\"\n-        self.write('')\n-        self.transport.unregisterProducer()\n-        self._allowNoMoreWrites()\n-\n-\n-\n-class TransportProxyProducer:\n-    \"\"\"\n-    An L{IPushProducer} implementation which wraps another such thing and\n-    proxies calls to it until it is told to stop.\n-\n-    @ivar _producer: The wrapped L{IPushProducer} provider or C{None} after\n-        this proxy has been stopped.\n-    \"\"\"\n-    implements(IPushProducer)\n-\n-    # LineReceiver uses this undocumented attribute of transports to decide\n-    # when to stop calling lineReceived or rawDataReceived (if it finds it to\n-    # be true, it doesn't bother to deliver any more data).  Set disconnecting\n-    # to False here and never change it to true so that all data is always\n-    # delivered to us and so that LineReceiver doesn't fail with an\n-    # AttributeError.\n-    disconnecting = False\n-\n-    def __init__(self, producer):\n-        self._producer = producer\n-\n-\n-    def _stopProxying(self):\n-        \"\"\"\n-        Stop forwarding calls of L{IPushProducer} methods to the underlying\n-        L{IPushProvider} provider.\n-        \"\"\"\n-        self._producer = None\n-\n-\n-    def stopProducing(self):\n-        \"\"\"\n-        Proxy the stoppage to the underlying producer, unless this proxy has\n-        been stopped.\n-        \"\"\"\n-        if self._producer is not None:\n-            self._producer.stopProducing()\n-\n-\n-    def resumeProducing(self):\n-        \"\"\"\n-        Proxy the resumption to the underlying producer, unless this proxy has\n-        been stopped.\n-        \"\"\"\n-        if self._producer is not None:\n-            self._producer.resumeProducing()\n-\n-\n-    def pauseProducing(self):\n-        \"\"\"\n-        Proxy the pause to the underlying producer, unless this proxy has been\n-        stopped.\n-        \"\"\"\n-        if self._producer is not None:\n-            self._producer.pauseProducing()\n-\n-\n-\n-class HTTP11ClientProtocol(Protocol):\n-    \"\"\"\n-    L{HTTP11ClientProtocol} is an implementation of the HTTP 1.1 client\n-    protocol.  It supports as few features as possible.\n-\n-    @ivar _parser: After a request is issued, the L{HTTPClientParser} to\n-        which received data making up the response to that request is\n-        delivered.\n-\n-    @ivar _finishedRequest: After a request is issued, the L{Deferred} which\n-        will fire when a L{Response} object corresponding to that request is\n-        available.  This allows L{HTTP11ClientProtocol} to fail the request\n-        if there is a connection or parsing problem.\n-\n-    @ivar _currentRequest: After a request is issued, the L{Request}\n-        instance used to make that request.  This allows\n-        L{HTTP11ClientProtocol} to stop request generation if necessary (for\n-        example, if the connection is lost).\n-\n-    @ivar _transportProxy: After a request is issued, the\n-        L{TransportProxyProducer} to which C{_parser} is connected.  This\n-        allows C{_parser} to pause and resume the transport in a way which\n-        L{HTTP11ClientProtocol} can exert some control over.\n-\n-    @ivar _responseDeferred: After a request is issued, the L{Deferred} from\n-        C{_parser} which will fire with a L{Response} when one has been\n-        received.  This is eventually chained with C{_finishedRequest}, but\n-        only in certain cases to avoid double firing that Deferred.\n-\n-    @ivar _state: Indicates what state this L{HTTP11ClientProtocol} instance\n-        is in with respect to transmission of a request and reception of a\n-        response.  This may be one of the following strings:\n-\n-          - QUIESCENT: This is the state L{HTTP11ClientProtocol} instances\n-            start in.  Nothing is happening: no request is being sent and no\n-            response is being received or expected.\n-\n-          - TRANSMITTING: When a request is made (via L{request}), the\n-            instance moves to this state.  L{Request.writeTo} has been used\n-            to start to send a request but it has not yet finished.\n-\n-          - TRANSMITTING_AFTER_RECEIVING_RESPONSE: The server has returned a\n-            complete response but the request has not yet been fully sent\n-            yet.  The instance will remain in this state until the request\n-            is fully sent.\n-\n-          - GENERATION_FAILED: There was an error while the request.  The\n-            request was not fully sent to the network.\n-\n-          - WAITING: The request was fully sent to the network.  The\n-            instance is now waiting for the response to be fully received.\n-\n-          - ABORTING: Application code has requested that the HTTP connection\n-            be aborted.\n-\n-          - CONNECTION_LOST: The connection has been lost.\n-\n-    @ivar _abortDeferreds: A list of C{Deferred} instances that will fire when\n-        the connection is lost.\n-    \"\"\"\n-    _state = 'QUIESCENT'\n-    _parser = None\n-    _finishedRequest = None\n-    _currentRequest = None\n-    _transportProxy = None\n-    _responseDeferred = None\n-\n-\n-    def __init__(self, quiescentCallback=lambda c: None):\n-        self._quiescentCallback = quiescentCallback\n-        self._abortDeferreds = []\n-\n-\n-    @property\n-    def state(self):\n-        return self._state\n-\n-\n-    def request(self, request):\n-        \"\"\"\n-        Issue C{request} over C{self.transport} and return a L{Deferred} which\n-        will fire with a L{Response} instance or an error.\n-\n-        @param request: The object defining the parameters of the request to\n-           issue.\n-        @type request: L{Request}\n-\n-        @rtype: L{Deferred}\n-        @return: The deferred may errback with L{RequestGenerationFailed} if\n-            the request was not fully written to the transport due to a local\n-            error.  It may errback with L{RequestTransmissionFailed} if it was\n-            not fully written to the transport due to a network error.  It may\n-            errback with L{ResponseFailed} if the request was sent (not\n-            necessarily received) but some or all of the response was lost.  It\n-            may errback with L{RequestNotSent} if it is not possible to send\n-            any more requests using this L{HTTP11ClientProtocol}.\n-        \"\"\"\n-        if self._state != 'QUIESCENT':\n-            return fail(RequestNotSent())\n-\n-        self._state = 'TRANSMITTING'\n-        _requestDeferred = maybeDeferred(request.writeTo, self.transport)\n-\n-        def cancelRequest(ign):\n-            # Explicitly cancel the request's deferred if it's still trying to\n-            # write when this request is cancelled.\n-            if self._state in (\n-                    'TRANSMITTING', 'TRANSMITTING_AFTER_RECEIVING_RESPONSE'):\n-                _requestDeferred.cancel()\n-            else:\n-                self.transport.abortConnection()\n-                self._disconnectParser(Failure(CancelledError()))\n-        self._finishedRequest = Deferred(cancelRequest)\n-\n-        # Keep track of the Request object in case we need to call stopWriting\n-        # on it.\n-        self._currentRequest = request\n-\n-        self._transportProxy = TransportProxyProducer(self.transport)\n-        self._parser = HTTPClientParser(request, self._finishResponse)\n-        self._parser.makeConnection(self._transportProxy)\n-        self._responseDeferred = self._parser._responseDeferred\n-\n-        def cbRequestWrotten(ignored):\n-            if self._state == 'TRANSMITTING':\n-                self._state = 'WAITING'\n-                self._responseDeferred.chainDeferred(self._finishedRequest)\n-\n-        def ebRequestWriting(err):\n-            if self._state == 'TRANSMITTING':\n-                self._state = 'GENERATION_FAILED'\n-                self.transport.abortConnection()\n-                self._finishedRequest.errback(\n-                    Failure(RequestGenerationFailed([err])))\n-            else:\n-                log.err(err, 'Error writing request, but not in valid state '\n-                             'to finalize request: %s' % self._state)\n-\n-        _requestDeferred.addCallbacks(cbRequestWrotten, ebRequestWriting)\n-\n-        return self._finishedRequest\n-\n-\n-    def _finishResponse(self, rest):\n-        \"\"\"\n-        Called by an L{HTTPClientParser} to indicate that it has parsed a\n-        complete response.\n-\n-        @param rest: A C{str} giving any trailing bytes which were given to\n-            the L{HTTPClientParser} which were not part of the response it\n-            was parsing.\n-        \"\"\"\n-    _finishResponse = makeStatefulDispatcher('finishResponse', _finishResponse)\n-\n-\n-    def _finishResponse_WAITING(self, rest):\n-        # Currently the rest parameter is ignored. Don't forget to use it if\n-        # we ever add support for pipelining. And maybe check what trailers\n-        # mean.\n-        if self._state == 'WAITING':\n-            self._state = 'QUIESCENT'\n-        else:\n-            # The server sent the entire response before we could send the\n-            # whole request.  That sucks.  Oh well.  Fire the request()\n-            # Deferred with the response.  But first, make sure that if the\n-            # request does ever finish being written that it won't try to fire\n-            # that Deferred.\n-            self._state = 'TRANSMITTING_AFTER_RECEIVING_RESPONSE'\n-            self._responseDeferred.chainDeferred(self._finishedRequest)\n-\n-        # This will happen if we're being called due to connection being lost;\n-        # if so, no need to disconnect parser again, or to call\n-        # _quiescentCallback.\n-        if self._parser is None:\n-            return\n-\n-        reason = ConnectionDone(\"synthetic!\")\n-        connHeaders = self._parser.connHeaders.getRawHeaders('connection', ())\n-        if (('close' in connHeaders) or self._state != \"QUIESCENT\" or\n-            not self._currentRequest.persistent):\n-            self._giveUp(Failure(reason))\n-        else:\n-            # We call the quiescent callback first, to ensure connection gets\n-            # added back to connection pool before we finish the request.\n-            try:\n-                self._quiescentCallback(self)\n-            except:\n-                # If callback throws exception, just log it and disconnect;\n-                # keeping persistent connections around is an optimisation:\n-                log.err()\n-                self.transport.loseConnection()\n-            self._disconnectParser(reason)\n-\n-\n-    _finishResponse_TRANSMITTING = _finishResponse_WAITING\n-\n-\n-    def _disconnectParser(self, reason):\n-        \"\"\"\n-        If there is still a parser, call its C{connectionLost} method with the\n-        given reason.  If there is not, do nothing.\n-\n-        @type reason: L{Failure}\n-        \"\"\"\n-        if self._parser is not None:\n-            parser = self._parser\n-            self._parser = None\n-            self._currentRequest = None\n-            self._finishedRequest = None\n-            self._responseDeferred = None\n-\n-            # The parser is no longer allowed to do anything to the real\n-            # transport.  Stop proxying from the parser's transport to the real\n-            # transport before telling the parser it's done so that it can't do\n-            # anything.\n-            self._transportProxy._stopProxying()\n-            self._transportProxy = None\n-            parser.connectionLost(reason)\n-\n-\n-    def _giveUp(self, reason):\n-        \"\"\"\n-        Lose the underlying connection and disconnect the parser with the given\n-        L{Failure}.\n-\n-        Use this method instead of calling the transport's loseConnection\n-        method directly otherwise random things will break.\n-        \"\"\"\n-        self.transport.loseConnection()\n-        self._disconnectParser(reason)\n-\n-\n-    def dataReceived(self, bytes):\n-        \"\"\"\n-        Handle some stuff from some place.\n-        \"\"\"\n-        try:\n-            self._parser.dataReceived(bytes)\n-        except:\n-            self._giveUp(Failure())\n-\n-\n-    def connectionLost(self, reason):\n-        \"\"\"\n-        The underlying transport went away.  If appropriate, notify the parser\n-        object.\n-        \"\"\"\n-    connectionLost = makeStatefulDispatcher('connectionLost', connectionLost)\n-\n-\n-    def _connectionLost_QUIESCENT(self, reason):\n-        \"\"\"\n-        Nothing is currently happening.  Move to the C{'CONNECTION_LOST'}\n-        state but otherwise do nothing.\n-        \"\"\"\n-        self._state = 'CONNECTION_LOST'\n-\n-\n-    def _connectionLost_GENERATION_FAILED(self, reason):\n-        \"\"\"\n-        The connection was in an inconsistent state.  Move to the\n-        C{'CONNECTION_LOST'} state but otherwise do nothing.\n-        \"\"\"\n-        self._state = 'CONNECTION_LOST'\n-\n-\n-    def _connectionLost_TRANSMITTING(self, reason):\n-        \"\"\"\n-        Fail the L{Deferred} for the current request, notify the request\n-        object that it does not need to continue transmitting itself, and\n-        move to the C{'CONNECTION_LOST'} state.\n-        \"\"\"\n-        self._state = 'CONNECTION_LOST'\n-        self._finishedRequest.errback(\n-            Failure(RequestTransmissionFailed([reason])))\n-        del self._finishedRequest\n-\n-        # Tell the request that it should stop bothering now.\n-        self._currentRequest.stopWriting()\n-\n-\n-    def _connectionLost_TRANSMITTING_AFTER_RECEIVING_RESPONSE(self, reason):\n-        \"\"\"\n-        Move to the C{'CONNECTION_LOST'} state.\n-        \"\"\"\n-        self._state = 'CONNECTION_LOST'\n-\n-\n-    def _connectionLost_WAITING(self, reason):\n-        \"\"\"\n-        Disconnect the response parser so that it can propagate the event as\n-        necessary (for example, to call an application protocol's\n-        C{connectionLost} method, or to fail a request L{Deferred}) and move\n-        to the C{'CONNECTION_LOST'} state.\n-        \"\"\"\n-        self._disconnectParser(reason)\n-        self._state = 'CONNECTION_LOST'\n-\n-\n-    def _connectionLost_ABORTING(self, reason):\n-        \"\"\"\n-        Disconnect the response parser with a L{ConnectionAborted} failure, and\n-        move to the C{'CONNECTION_LOST'} state.\n-        \"\"\"\n-        self._disconnectParser(Failure(ConnectionAborted()))\n-        self._state = 'CONNECTION_LOST'\n-        for d in self._abortDeferreds:\n-            d.callback(None)\n-        self._abortDeferreds = []\n-\n-\n-    def abort(self):\n-        \"\"\"\n-        Close the connection and cause all outstanding L{request} L{Deferred}s\n-        to fire with an error.\n-        \"\"\"\n-        if self._state == \"CONNECTION_LOST\":\n-            return succeed(None)\n-        self.transport.loseConnection()\n-        self._state = 'ABORTING'\n-        d = Deferred()\n-        self._abortDeferreds.append(d)\n-        return d\n-}}} '''\n\n@@ -42,1129 +42,13 @@ from twisted.web.client import (\n     Agent, ProxyAgent, HTTPConnectionPool, readBody,\n )\n \n-''' {{{\n-class PartialDownloadError(error.Error):\n-    \"\"\"\n-    Page was only partially downloaded, we got disconnected in middle.\n-\n-    @ivar response: All of the response body which was downloaded.\n-    \"\"\"\n-\n-\n-class _URL(tuple):\n-    \"\"\"\n-    A parsed URL.\n-\n-    At some point this should be replaced with a better URL implementation.\n-    \"\"\"\n-    def __new__(self, scheme, host, port, path):\n-        return tuple.__new__(_URL, (scheme, host, port, path))\n-\n-\n-    def __init__(self, scheme, host, port, path):\n-        self.scheme = scheme\n-        self.host = host\n-        self.port = port\n-        self.path = path\n-\n-\n-def _parse(url, defaultPort=None):\n-    \"\"\"\n-    Split the given URL into the scheme, host, port, and path.\n-\n-    @type url: C{bytes}\n-    @param url: An URL to parse.\n-\n-    @type defaultPort: C{int} or C{None}\n-    @param defaultPort: An alternate value to use as the port if the URL does\n-    not include one.\n-\n-    @return: A four-tuple of the scheme, host, port, and path of the URL.  All\n-    of these are C{bytes} instances except for port, which is an C{int}.\n-    \"\"\"\n-    url = url.strip()\n-    parsed = http.urlparse(url)\n-    scheme = parsed[0]\n-    path = urlunparse((b'', b'') + parsed[2:])\n-\n-    if defaultPort is None:\n-        if scheme == b'https':\n-            defaultPort = 443\n-        else:\n-            defaultPort = 80\n-\n-    host, port = parsed[1], defaultPort\n-    if b':' in host:\n-        host, port = host.split(b':')\n-        try:\n-            port = int(port)\n-        except ValueError:\n-            port = defaultPort\n-\n-    if path == b'':\n-        path = b'/'\n-\n-    return _URL(scheme, host, port, path)\n-\n-\n-def _makeGetterFactory(url, factoryFactory, contextFactory=None,\n-                       *args, **kwargs):\n-    \"\"\"\n-    Create and connect an HTTP page getting factory.\n-\n-    Any additional positional or keyword arguments are used when calling\n-    C{factoryFactory}.\n-\n-    @param factoryFactory: Factory factory that is called with C{url}, C{args}\n-        and C{kwargs} to produce the getter\n-\n-    @param contextFactory: Context factory to use when creating a secure\n-        connection, defaulting to C{None}\n-\n-    @return: The factory created by C{factoryFactory}\n-    \"\"\"\n-    scheme, host, port, path = _parse(url)\n-    factory = factoryFactory(url, *args, **kwargs)\n-    if scheme == b'https':\n-        from twisted.internet import ssl\n-        if contextFactory is None:\n-            contextFactory = ssl.ClientContextFactory()\n-        reactor.connectSSL(host, port, factory, contextFactory)\n-    else:\n-        reactor.connectTCP(host, port, factory)\n-    return factory\n-}}} '''\n \n # The code which follows is based on the new HTTP client implementation.  It\n # should be significantly better than anything above, though it is not yet\n # feature equivalent.\n \n-#from twisted.web.error import SchemeNotSupported\n from twisted.web._newclient import Response\n-#from twisted.web._newclient import Request, HTTP11ClientProtocol\n from twisted.web._newclient import ResponseDone, ResponseFailed\n-#from twisted.web._newclient import RequestNotSent, RequestTransmissionFailed\n-#from twisted.web._newclient import (\n-#    ResponseNeverReceived, PotentialDataLoss, _WrapperException)\n-\n-''' {{{\n-try:\n-    from twisted.internet.ssl import ClientContextFactory\n-except ImportError:\n-    class WebClientContextFactory(object):\n-        \"\"\"\n-        A web context factory which doesn't work because the necessary SSL\n-        support is missing.\n-        \"\"\"\n-        def getContext(self, hostname, port):\n-            raise NotImplementedError(\"SSL support unavailable\")\n-else:\n-    class WebClientContextFactory(ClientContextFactory):\n-        \"\"\"\n-        A web context factory which ignores the hostname and port and does no\n-        certificate verification.\n-        \"\"\"\n-        def getContext(self, hostname, port):\n-            return ClientContextFactory.getContext(self)\n-\n-\n-\n-class _WebToNormalContextFactory(object):\n-    \"\"\"\n-    Adapt a web context factory to a normal context factory.\n-\n-    @ivar _webContext: A web context factory which accepts a hostname and port\n-        number to its C{getContext} method.\n-\n-    @ivar _hostname: The hostname which will be passed to\n-        C{_webContext.getContext}.\n-\n-    @ivar _port: The port number which will be passed to\n-        C{_webContext.getContext}.\n-    \"\"\"\n-    def __init__(self, webContext, hostname, port):\n-        self._webContext = webContext\n-        self._hostname = hostname\n-        self._port = port\n-\n-\n-    def getContext(self):\n-        \"\"\"\n-        Called the wrapped web context factory's C{getContext} method with a\n-        hostname and port number and return the resulting context object.\n-        \"\"\"\n-        return self._webContext.getContext(self._hostname, self._port)\n-\n-\n-\n-@implementer(IBodyProducer)\n-class FileBodyProducer(object):\n-    \"\"\"\n-    L{FileBodyProducer} produces bytes from an input file object incrementally\n-    and writes them to a consumer.\n-\n-    Since file-like objects cannot be read from in an event-driven manner,\n-    L{FileBodyProducer} uses a L{Cooperator} instance to schedule reads from\n-    the file.  This process is also paused and resumed based on notifications\n-    from the L{IConsumer} provider being written to.\n-\n-    The file is closed after it has been read, or if the producer is stopped\n-    early.\n-\n-    @ivar _inputFile: Any file-like object, bytes read from which will be\n-        written to a consumer.\n-\n-    @ivar _cooperate: A method like L{Cooperator.cooperate} which is used to\n-        schedule all reads.\n-\n-    @ivar _readSize: The number of bytes to read from C{_inputFile} at a time.\n-    \"\"\"\n-\n-    # Python 2.4 doesn't have these symbolic constants\n-    _SEEK_SET = getattr(os, 'SEEK_SET', 0)\n-    _SEEK_END = getattr(os, 'SEEK_END', 2)\n-\n-    def __init__(self, inputFile, cooperator=task, readSize=2 ** 16):\n-        self._inputFile = inputFile\n-        self._cooperate = cooperator.cooperate\n-        self._readSize = readSize\n-        self.length = self._determineLength(inputFile)\n-\n-\n-    def _determineLength(self, fObj):\n-        \"\"\"\n-        Determine how many bytes can be read out of C{fObj} (assuming it is not\n-        modified from this point on).  If the determination cannot be made,\n-        return C{UNKNOWN_LENGTH}.\n-        \"\"\"\n-        try:\n-            seek = fObj.seek\n-            tell = fObj.tell\n-        except AttributeError:\n-            return UNKNOWN_LENGTH\n-        originalPosition = tell()\n-        seek(0, self._SEEK_END)\n-        end = tell()\n-        seek(originalPosition, self._SEEK_SET)\n-        return end - originalPosition\n-\n-\n-    def stopProducing(self):\n-        \"\"\"\n-        Permanently stop writing bytes from the file to the consumer by\n-        stopping the underlying L{CooperativeTask}.\n-        \"\"\"\n-        self._inputFile.close()\n-        self._task.stop()\n-\n-\n-    def startProducing(self, consumer):\n-        \"\"\"\n-        Start a cooperative task which will read bytes from the input file and\n-        write them to C{consumer}.  Return a L{Deferred} which fires after all\n-        bytes have been written.\n-\n-        @param consumer: Any L{IConsumer} provider\n-        \"\"\"\n-        self._task = self._cooperate(self._writeloop(consumer))\n-        d = self._task.whenDone()\n-        def maybeStopped(reason):\n-            # IBodyProducer.startProducing's Deferred isn't support to fire if\n-            # stopProducing is called.\n-            reason.trap(task.TaskStopped)\n-            return defer.Deferred()\n-        d.addCallbacks(lambda ignored: None, maybeStopped)\n-        return d\n-\n-\n-    def _writeloop(self, consumer):\n-        \"\"\"\n-        Return an iterator which reads one chunk of bytes from the input file\n-        and writes them to the consumer for each time it is iterated.\n-        \"\"\"\n-        while True:\n-            bytes = self._inputFile.read(self._readSize)\n-            if not bytes:\n-                self._inputFile.close()\n-                break\n-            consumer.write(bytes)\n-            yield None\n-\n-\n-    def pauseProducing(self):\n-        \"\"\"\n-        Temporarily suspend copying bytes from the input file to the consumer\n-        by pausing the L{CooperativeTask} which drives that activity.\n-        \"\"\"\n-        self._task.pause()\n-\n-\n-    def resumeProducing(self):\n-        \"\"\"\n-        Undo the effects of a previous C{pauseProducing} and resume copying\n-        bytes to the consumer by resuming the L{CooperativeTask} which drives\n-        the write activity.\n-        \"\"\"\n-        self._task.resume()\n-\n-\n-\n-class _HTTP11ClientFactory(protocol.Factory):\n-    \"\"\"\n-    A factory for L{HTTP11ClientProtocol}, used by L{HTTPConnectionPool}.\n-\n-    @ivar _quiescentCallback: The quiescent callback to be passed to protocol\n-        instances, used to return them to the connection pool.\n-\n-    @since: 11.1\n-    \"\"\"\n-    def __init__(self, quiescentCallback):\n-        self._quiescentCallback = quiescentCallback\n-\n-\n-    def buildProtocol(self, addr):\n-        return HTTP11ClientProtocol(self._quiescentCallback)\n-\n-\n-\n-class _RetryingHTTP11ClientProtocol(object):\n-    \"\"\"\n-    A wrapper for L{HTTP11ClientProtocol} that automatically retries requests.\n-\n-    @ivar _clientProtocol: The underlying L{HTTP11ClientProtocol}.\n-\n-    @ivar _newConnection: A callable that creates a new connection for a\n-        retry.\n-    \"\"\"\n-\n-    def __init__(self, clientProtocol, newConnection):\n-        self._clientProtocol = clientProtocol\n-        self._newConnection = newConnection\n-\n-\n-    def _shouldRetry(self, method, exception, bodyProducer):\n-        \"\"\"\n-        Indicate whether request should be retried.\n-\n-        Only returns C{True} if method is idempotent, no response was\n-        received, the reason for the failed request was not due to\n-        user-requested cancellation, and no body was sent. The latter\n-        requirement may be relaxed in the future, and PUT added to approved\n-        method list.\n-        \"\"\"\n-        if method not in (\"GET\", \"HEAD\", \"OPTIONS\", \"DELETE\", \"TRACE\"):\n-            return False\n-        if not isinstance(exception, (RequestNotSent, RequestTransmissionFailed,\n-                                      ResponseNeverReceived)):\n-            return False\n-        if isinstance(exception, _WrapperException):\n-            for failure in exception.reasons:\n-                if failure.check(defer.CancelledError):\n-                    return False\n-        if bodyProducer is not None:\n-            return False\n-        return True\n-\n-\n-    def request(self, request):\n-        \"\"\"\n-        Do a request, and retry once (with a new connection) it it fails in\n-        a retryable manner.\n-\n-        @param request: A L{Request} instance that will be requested using the\n-            wrapped protocol.\n-        \"\"\"\n-        d = self._clientProtocol.request(request)\n-\n-        def failed(reason):\n-            if self._shouldRetry(request.method, reason.value,\n-                                 request.bodyProducer):\n-                return self._newConnection().addCallback(\n-                    lambda connection: connection.request(request))\n-            else:\n-                return reason\n-        d.addErrback(failed)\n-        return d\n-\n-\n-\n-class HTTPConnectionPool(object):\n-    \"\"\"\n-    A pool of persistent HTTP connections.\n-\n-    Features:\n-     - Cached connections will eventually time out.\n-     - Limits on maximum number of persistent connections.\n-\n-    Connections are stored using keys, which should be chosen such that any\n-    connections stored under a given key can be used interchangeably.\n-\n-    Failed requests done using previously cached connections will be retried\n-    once if they use an idempotent method (e.g. GET), in case the HTTP server\n-    timed them out.\n-\n-    @ivar persistent: Boolean indicating whether connections should be\n-        persistent. Connections are persistent by default.\n-\n-    @ivar maxPersistentPerHost: The maximum number of cached persistent\n-        connections for a C{host:port} destination.\n-    @type maxPersistentPerHost: C{int}\n-\n-    @ivar cachedConnectionTimeout: Number of seconds a cached persistent\n-        connection will stay open before disconnecting.\n-\n-    @ivar retryAutomatically: C{boolean} indicating whether idempotent\n-        requests should be retried once if no response was received.\n-\n-    @ivar _factory: The factory used to connect to the proxy.\n-\n-    @ivar _connections: Map (scheme, host, port) to lists of\n-        L{HTTP11ClientProtocol} instances.\n-\n-    @ivar _timeouts: Map L{HTTP11ClientProtocol} instances to a\n-        C{IDelayedCall} instance of their timeout.\n-\n-    @since: 12.1\n-    \"\"\"\n-\n-    _factory = _HTTP11ClientFactory\n-    maxPersistentPerHost = 2\n-    cachedConnectionTimeout = 240\n-    retryAutomatically = True\n-\n-    def __init__(self, reactor, persistent=True):\n-        self._reactor = reactor\n-        self.persistent = persistent\n-        self._connections = {}\n-        self._timeouts = {}\n-\n-\n-    def getConnection(self, key, endpoint):\n-        \"\"\"\n-        Supply a connection, newly created or retrieved from the pool, to be\n-        used for one HTTP request.\n-\n-        The connection will remain out of the pool (not available to be\n-        returned from future calls to this method) until one HTTP request has\n-        been completed over it.\n-\n-        Afterwards, if the connection is still open, it will automatically be\n-        added to the pool.\n-\n-        @param key: A unique key identifying connections that can be used\n-            interchangeably.\n-\n-        @param endpoint: An endpoint that can be used to open a new connection\n-            if no cached connection is available.\n-\n-        @return: A C{Deferred} that will fire with a L{HTTP11ClientProtocol}\n-           (or a wrapper) that can be used to send a single HTTP request.\n-        \"\"\"\n-        # Try to get cached version:\n-        connections = self._connections.get(key)\n-        while connections:\n-            connection = connections.pop(0)\n-            # Cancel timeout:\n-            self._timeouts[connection].cancel()\n-            del self._timeouts[connection]\n-            if connection.state == \"QUIESCENT\":\n-                if self.retryAutomatically:\n-                    newConnection = lambda: self._newConnection(key, endpoint)\n-                    connection = _RetryingHTTP11ClientProtocol(\n-                        connection, newConnection)\n-                return defer.succeed(connection)\n-\n-        return self._newConnection(key, endpoint)\n-\n-\n-    def _newConnection(self, key, endpoint):\n-        \"\"\"\n-        Create a new connection.\n-\n-        This implements the new connection code path for L{getConnection}.\n-        \"\"\"\n-        def quiescentCallback(protocol):\n-            self._putConnection(key, protocol)\n-        factory = self._factory(quiescentCallback)\n-        return endpoint.connect(factory)\n-\n-\n-    def _removeConnection(self, key, connection):\n-        \"\"\"\n-        Remove a connection from the cache and disconnect it.\n-        \"\"\"\n-        connection.transport.loseConnection()\n-        self._connections[key].remove(connection)\n-        del self._timeouts[connection]\n-\n-\n-    def _putConnection(self, key, connection):\n-        \"\"\"\n-        Return a persistent connection to the pool. This will be called by\n-        L{HTTP11ClientProtocol} when the connection becomes quiescent.\n-        \"\"\"\n-        if connection.state != \"QUIESCENT\":\n-            # Log with traceback for debugging purposes:\n-            try:\n-                raise RuntimeError(\n-                    \"BUG: Non-quiescent protocol added to connection pool.\")\n-            except:\n-                log.err()\n-            return\n-        connections = self._connections.setdefault(key, [])\n-        if len(connections) == self.maxPersistentPerHost:\n-            dropped = connections.pop(0)\n-            dropped.transport.loseConnection()\n-            self._timeouts[dropped].cancel()\n-            del self._timeouts[dropped]\n-        connections.append(connection)\n-        cid = self._reactor.callLater(self.cachedConnectionTimeout,\n-                                      self._removeConnection,\n-                                      key, connection)\n-        self._timeouts[connection] = cid\n-\n-\n-    def closeCachedConnections(self):\n-        \"\"\"\n-        Close all persistent connections and remove them from the pool.\n-\n-        @return: L{defer.Deferred} that fires when all connections have been\n-            closed.\n-        \"\"\"\n-        results = []\n-        for protocols in self._connections.itervalues():\n-            for p in protocols:\n-                results.append(p.abort())\n-        self._connections = {}\n-        for dc in self._timeouts.values():\n-            dc.cancel()\n-        self._timeouts = {}\n-        return defer.gatherResults(results).addCallback(lambda ign: None)\n-\n-\n-\n-class _AgentBase(object):\n-    \"\"\"\n-    Base class offering common facilities for L{Agent}-type classes.\n-\n-    @ivar _reactor: The C{IReactorTime} implementation which will be used by\n-        the pool, and perhaps by subclasses as well.\n-\n-    @ivar _pool: The L{HTTPConnectionPool} used to manage HTTP connections.\n-    \"\"\"\n-\n-    def __init__(self, reactor, pool):\n-        if pool is None:\n-            pool = HTTPConnectionPool(reactor, False)\n-        self._reactor = reactor\n-        self._pool = pool\n-\n-\n-    def _computeHostValue(self, scheme, host, port):\n-        \"\"\"\n-        Compute the string to use for the value of the I{Host} header, based on\n-        the given scheme, host name, and port number.\n-        \"\"\"\n-        if (scheme, port) in (('http', 80), ('https', 443)):\n-            return host\n-        return '%s:%d' % (host, port)\n-\n-\n-    def _requestWithEndpoint(self, key, endpoint, method, parsedURI,\n-                             headers, bodyProducer, requestPath):\n-        \"\"\"\n-        Issue a new request, given the endpoint and the path sent as part of\n-        the request.\n-        \"\"\"\n-        # Create minimal headers, if necessary:\n-        if headers is None:\n-            headers = Headers()\n-        if not headers.hasHeader('host'):\n-            #headers = headers.copy()  # not supported in twisted <= 11.1, and it doesn't affects us\n-            headers.addRawHeader(\n-                'host', self._computeHostValue(parsedURI.scheme, parsedURI.host,\n-                                               parsedURI.port))\n-\n-        d = self._pool.getConnection(key, endpoint)\n-        def cbConnected(proto):\n-            return proto.request(\n-                Request(method, requestPath, headers, bodyProducer,\n-                        persistent=self._pool.persistent))\n-        d.addCallback(cbConnected)\n-        return d\n-\n-\n-\n-class Agent(_AgentBase):\n-    \"\"\"\n-    L{Agent} is a very basic HTTP client.  It supports I{HTTP} and I{HTTPS}\n-    scheme URIs (but performs no certificate checking by default).\n-\n-    @param pool: A L{HTTPConnectionPool} instance, or C{None}, in which case a\n-        non-persistent L{HTTPConnectionPool} instance will be created.\n-\n-    @ivar _contextFactory: A web context factory which will be used to create\n-        SSL context objects for any SSL connections the agent needs to make.\n-\n-    @ivar _connectTimeout: If not C{None}, the timeout passed to C{connectTCP}\n-        or C{connectSSL} for specifying the connection timeout.\n-\n-    @ivar _bindAddress: If not C{None}, the address passed to C{connectTCP} or\n-        C{connectSSL} for specifying the local address to bind to.\n-\n-    @since: 9.0\n-    \"\"\"\n-\n-    def __init__(self, reactor, contextFactory=WebClientContextFactory(),\n-                 connectTimeout=None, bindAddress=None,\n-                 pool=None):\n-        _AgentBase.__init__(self, reactor, pool)\n-        self._contextFactory = contextFactory\n-        self._connectTimeout = connectTimeout\n-        self._bindAddress = bindAddress\n-\n-\n-    def _wrapContextFactory(self, host, port):\n-        \"\"\"\n-        Create and return a normal context factory wrapped around\n-        C{self._contextFactory} in such a way that C{self._contextFactory} will\n-        have the host and port information passed to it.\n-\n-        @param host: A C{str} giving the hostname which will be connected to in\n-            order to issue a request.\n-\n-        @param port: An C{int} giving the port number the connection will be\n-            on.\n-\n-        @return: A context factory suitable to be passed to\n-            C{reactor.connectSSL}.\n-        \"\"\"\n-        return _WebToNormalContextFactory(self._contextFactory, host, port)\n-\n-\n-    def _getEndpoint(self, scheme, host, port):\n-        \"\"\"\n-        Get an endpoint for the given host and port, using a transport\n-        selected based on scheme.\n-\n-        @param scheme: A string like C{'http'} or C{'https'} (the only two\n-            supported values) to use to determine how to establish the\n-            connection.\n-\n-        @param host: A C{str} giving the hostname which will be connected to in\n-            order to issue a request.\n-\n-        @param port: An C{int} giving the port number the connection will be\n-            on.\n-\n-        @return: An endpoint which can be used to connect to given address.\n-        \"\"\"\n-        kwargs = {}\n-        if self._connectTimeout is not None:\n-            kwargs['timeout'] = self._connectTimeout\n-        kwargs['bindAddress'] = self._bindAddress\n-        if scheme == 'http':\n-            return TCP4ClientEndpoint(self._reactor, host, port, **kwargs)\n-        elif scheme == 'https':\n-            return SSL4ClientEndpoint(self._reactor, host, port,\n-                                      self._wrapContextFactory(host, port),\n-                                      **kwargs)\n-        else:\n-            raise SchemeNotSupported(\"Unsupported scheme: %r\" % (scheme,))\n-\n-\n-    def request(self, method, uri, headers=None, bodyProducer=None):\n-        \"\"\"\n-        Issue a new request.\n-\n-        @param method: The request method to send.\n-        @type method: C{str}\n-\n-        @param uri: The request URI send.\n-        @type uri: C{str}\n-\n-        @param headers: The request headers to send.  If no I{Host} header is\n-            included, one will be added based on the request URI.\n-        @type headers: L{Headers}\n-\n-        @param bodyProducer: An object which will produce the request body or,\n-            if the request body is to be empty, L{None}.\n-        @type bodyProducer: L{IBodyProducer} provider\n-\n-        @return: A L{Deferred} which fires with the result of the request (a\n-            L{twisted.web.iweb.IResponse} provider), or fails if there is a\n-            problem setting up a connection over which to issue the request.\n-            It may also fail with L{SchemeNotSupported} if the scheme of the\n-            given URI is not supported.\n-        @rtype: L{Deferred}\n-        \"\"\"\n-        parsedURI = _parse(uri)\n-        try:\n-            endpoint = self._getEndpoint(parsedURI.scheme, parsedURI.host,\n-                                         parsedURI.port)\n-        except SchemeNotSupported:\n-            return defer.fail(Failure())\n-        key = (parsedURI.scheme, parsedURI.host, parsedURI.port)\n-        return self._requestWithEndpoint(key, endpoint, method, parsedURI,\n-                                         headers, bodyProducer, parsedURI.path)\n-\n-\n-\n-class ProxyAgent(_AgentBase):\n-    \"\"\"\n-    An HTTP agent able to cross HTTP proxies.\n-\n-    @ivar _proxyEndpoint: The endpoint used to connect to the proxy.\n-\n-    @since: 11.1\n-    \"\"\"\n-\n-    def __init__(self, endpoint, reactor=None, pool=None):\n-        if reactor is None:\n-            from twisted.internet import reactor\n-        _AgentBase.__init__(self, reactor, pool)\n-        self._proxyEndpoint = endpoint\n-\n-\n-    def request(self, method, uri, headers=None, bodyProducer=None):\n-        \"\"\"\n-        Issue a new request via the configured proxy.\n-        \"\"\"\n-        # Cache *all* connections under the same key, since we are only\n-        # connecting to a single destination, the proxy:\n-        key = (\"http-proxy\", self._proxyEndpoint)\n-\n-        # To support proxying HTTPS via CONNECT, we will use key\n-        # (\"http-proxy-CONNECT\", scheme, host, port), and an endpoint that\n-        # wraps _proxyEndpoint with an additional callback to do the CONNECT.\n-        return self._requestWithEndpoint(key, self._proxyEndpoint, method,\n-                                         _parse(uri), headers, bodyProducer,\n-                                         uri)\n-\n-\n-\n-class _FakeUrllib2Request(object):\n-    \"\"\"\n-    A fake C{urllib2.Request} object for C{cookielib} to work with.\n-\n-    @see: U{http://docs.python.org/library/urllib2.html#request-objects}\n-\n-    @type uri: C{str}\n-    @ivar uri: Request URI.\n-\n-    @type headers: L{twisted.web.http_headers.Headers}\n-    @ivar headers: Request headers.\n-\n-    @type type: C{str}\n-    @ivar type: The scheme of the URI.\n-\n-    @type host: C{str}\n-    @ivar host: The host[:port] of the URI.\n-\n-    @since: 11.1\n-    \"\"\"\n-    def __init__(self, uri):\n-        self.uri = uri\n-        self.headers = Headers()\n-        self.type, rest = splittype(self.uri)\n-        self.host, rest = splithost(rest)\n-\n-\n-    def has_header(self, header):\n-        return self.headers.hasHeader(header)\n-\n-\n-    def add_unredirected_header(self, name, value):\n-        self.headers.addRawHeader(name, value)\n-\n-\n-    def get_full_url(self):\n-        return self.uri\n-\n-\n-    def get_header(self, name, default=None):\n-        headers = self.headers.getRawHeaders(name, default)\n-        if headers is not None:\n-            return headers[0]\n-        return None\n-\n-\n-    def get_host(self):\n-        return self.host\n-\n-\n-    def get_type(self):\n-        return self.type\n-\n-\n-    def is_unverifiable(self):\n-        # In theory this shouldn't be hardcoded.\n-        return False\n-\n-\n-\n-class _FakeUrllib2Response(object):\n-    \"\"\"\n-    A fake C{urllib2.Response} object for C{cookielib} to work with.\n-\n-    @type response: C{twisted.web.iweb.IResponse}\n-    @ivar response: Underlying Twisted Web response.\n-\n-    @since: 11.1\n-    \"\"\"\n-    def __init__(self, response):\n-        self.response = response\n-\n-\n-    def info(self):\n-        class _Meta(object):\n-            def getheaders(zelf, name):\n-                return self.response.headers.getRawHeaders(name, [])\n-        return _Meta()\n-\n-\n-\n-class CookieAgent(object):\n-    \"\"\"\n-    L{CookieAgent} extends the basic L{Agent} to add RFC-compliant\n-    handling of HTTP cookies.  Cookies are written to and extracted\n-    from a C{cookielib.CookieJar} instance.\n-\n-    The same cookie jar instance will be used for any requests through this\n-    agent, mutating it whenever a I{Set-Cookie} header appears in a response.\n-\n-    @type _agent: L{twisted.web.client.Agent}\n-    @ivar _agent: Underlying Twisted Web agent to issue requests through.\n-\n-    @type cookieJar: C{cookielib.CookieJar}\n-    @ivar cookieJar: Initialized cookie jar to read cookies from and store\n-        cookies to.\n-\n-    @since: 11.1\n-    \"\"\"\n-    def __init__(self, agent, cookieJar):\n-        self._agent = agent\n-        self.cookieJar = cookieJar\n-\n-\n-    def request(self, method, uri, headers=None, bodyProducer=None):\n-        \"\"\"\n-        Issue a new request to the wrapped L{Agent}.\n-\n-        Send a I{Cookie} header if a cookie for C{uri} is stored in\n-        L{CookieAgent.cookieJar}. Cookies are automatically extracted and\n-        stored from requests.\n-\n-        If a C{'cookie'} header appears in C{headers} it will override the\n-        automatic cookie header obtained from the cookie jar.\n-\n-        @see: L{Agent.request}\n-        \"\"\"\n-        if headers is None:\n-            headers = Headers()\n-        lastRequest = _FakeUrllib2Request(uri)\n-        # Setting a cookie header explicitly will disable automatic request\n-        # cookies.\n-        if not headers.hasHeader('cookie'):\n-            self.cookieJar.add_cookie_header(lastRequest)\n-            cookieHeader = lastRequest.get_header('Cookie', None)\n-            if cookieHeader is not None:\n-                headers = headers.copy()\n-                headers.addRawHeader('cookie', cookieHeader)\n-\n-        d = self._agent.request(method, uri, headers, bodyProducer)\n-        d.addCallback(self._extractCookies, lastRequest)\n-        return d\n-\n-\n-    def _extractCookies(self, response, request):\n-        \"\"\"\n-        Extract response cookies and store them in the cookie jar.\n-\n-        @type response: L{twisted.web.iweb.IResponse}\n-        @param response: Twisted Web response.\n-\n-        @param request: A urllib2 compatible request object.\n-        \"\"\"\n-        resp = _FakeUrllib2Response(response)\n-        self.cookieJar.extract_cookies(resp, request)\n-        return response\n-\n-\n-\n-class GzipDecoder(proxyForInterface(IResponse)):\n-    \"\"\"\n-    A wrapper for a L{Response} instance which handles gzip'ed body.\n-\n-    @ivar original: The original L{Response} object.\n-\n-    @since: 11.1\n-    \"\"\"\n-\n-    def __init__(self, response):\n-        self.original = response\n-        self.length = UNKNOWN_LENGTH\n-\n-\n-    def deliverBody(self, protocol):\n-        \"\"\"\n-        Override C{deliverBody} to wrap the given C{protocol} with\n-        L{_GzipProtocol}.\n-        \"\"\"\n-        self.original.deliverBody(_GzipProtocol(protocol, self.original))\n-\n-\n-\n-class _GzipProtocol(proxyForInterface(IProtocol)):\n-    \"\"\"\n-    A L{Protocol} implementation which wraps another one, transparently\n-    decompressing received data.\n-\n-    @ivar _zlibDecompress: A zlib decompress object used to decompress the data\n-        stream.\n-\n-    @ivar _response: A reference to the original response, in case of errors.\n-\n-    @since: 11.1\n-    \"\"\"\n-\n-    def __init__(self, protocol, response):\n-        self.original = protocol\n-        self._response = response\n-        self._zlibDecompress = zlib.decompressobj(16 + zlib.MAX_WBITS)\n-\n-\n-    def dataReceived(self, data):\n-        \"\"\"\n-        Decompress C{data} with the zlib decompressor, forwarding the raw data\n-        to the original protocol.\n-        \"\"\"\n-        try:\n-            rawData = self._zlibDecompress.decompress(data)\n-        except zlib.error:\n-            raise ResponseFailed([failure.Failure()], self._response)\n-        if rawData:\n-            self.original.dataReceived(rawData)\n-\n-\n-    def connectionLost(self, reason):\n-        \"\"\"\n-        Forward the connection lost event, flushing remaining data from the\n-        decompressor if any.\n-        \"\"\"\n-        try:\n-            rawData = self._zlibDecompress.flush()\n-        except zlib.error:\n-            raise ResponseFailed([reason, failure.Failure()], self._response)\n-        if rawData:\n-            self.original.dataReceived(rawData)\n-        self.original.connectionLost(reason)\n-\n-\n-\n-class ContentDecoderAgent(object):\n-    \"\"\"\n-    An L{Agent} wrapper to handle encoded content.\n-\n-    It takes care of declaring the support for content in the\n-    I{Accept-Encoding} header, and automatically decompresses the received data\n-    if it's effectively using compression.\n-\n-    @param decoders: A list or tuple of (name, decoder) objects. The name\n-        declares which decoding the decoder supports, and the decoder must\n-        return a response object when called/instantiated. For example,\n-        C{(('gzip', GzipDecoder))}. The order determines how the decoders are\n-        going to be advertized to the server.\n-\n-    @since: 11.1\n-    \"\"\"\n-\n-    def __init__(self, agent, decoders):\n-        self._agent = agent\n-        self._decoders = dict(decoders)\n-        self._supported = ','.join([decoder[0] for decoder in decoders])\n-\n-\n-    def request(self, method, uri, headers=None, bodyProducer=None):\n-        \"\"\"\n-        Send a client request which declares supporting compressed content.\n-\n-        @see: L{Agent.request}.\n-        \"\"\"\n-        if headers is None:\n-            headers = Headers()\n-        else:\n-            headers = headers.copy()\n-        headers.addRawHeader('accept-encoding', self._supported)\n-        deferred = self._agent.request(method, uri, headers, bodyProducer)\n-        return deferred.addCallback(self._handleResponse)\n-\n-\n-    def _handleResponse(self, response):\n-        \"\"\"\n-        Check if the response is encoded, and wrap it to handle decompression.\n-        \"\"\"\n-        contentEncodingHeaders = response.headers.getRawHeaders(\n-            'content-encoding', [])\n-        contentEncodingHeaders = ','.join(contentEncodingHeaders).split(',')\n-        while contentEncodingHeaders:\n-            name = contentEncodingHeaders.pop().strip()\n-            decoder = self._decoders.get(name)\n-            if decoder is not None:\n-                response = decoder(response)\n-            else:\n-                # Add it back\n-                contentEncodingHeaders.append(name)\n-                break\n-        if contentEncodingHeaders:\n-            response.headers.setRawHeaders(\n-                'content-encoding', [','.join(contentEncodingHeaders)])\n-        else:\n-            response.headers.removeHeader('content-encoding')\n-        return response\n-\n-\n-\n-class RedirectAgent(object):\n-    \"\"\"\n-    An L{Agent} wrapper which handles HTTP redirects.\n-\n-    The implementation is rather strict: 301 and 302 behaves like 307, not\n-    redirecting automatically on methods different from C{GET} and C{HEAD}.\n-\n-    @param redirectLimit: The maximum number of times the agent is allowed to\n-        follow redirects before failing with a L{error.InfiniteRedirection}.\n-\n-    @since: 11.1\n-    \"\"\"\n-\n-    def __init__(self, agent, redirectLimit=20):\n-        self._agent = agent\n-        self._redirectLimit = redirectLimit\n-\n-\n-    def request(self, method, uri, headers=None, bodyProducer=None):\n-        \"\"\"\n-        Send a client request following HTTP redirects.\n-\n-        @see: L{Agent.request}.\n-        \"\"\"\n-        deferred = self._agent.request(method, uri, headers, bodyProducer)\n-        return deferred.addCallback(\n-            self._handleResponse, method, uri, headers, 0)\n-\n-\n-    def _handleRedirect(self, response, method, uri, headers, redirectCount):\n-        \"\"\"\n-        Handle a redirect response, checking the number of redirects already\n-        followed, and extracting the location header fields.\n-        \"\"\"\n-        if redirectCount >= self._redirectLimit:\n-            err = error.InfiniteRedirection(\n-                response.code,\n-                'Infinite redirection detected',\n-                location=uri)\n-            raise ResponseFailed([failure.Failure(err)], response)\n-        locationHeaders = response.headers.getRawHeaders('location', [])\n-        if not locationHeaders:\n-            err = error.RedirectWithNoLocation(\n-                response.code, 'No location header field', uri)\n-            raise ResponseFailed([failure.Failure(err)], response)\n-        location = locationHeaders[0]\n-        deferred = self._agent.request(method, location, headers)\n-        return deferred.addCallback(\n-            self._handleResponse, method, uri, headers, redirectCount + 1)\n-\n-\n-    def _handleResponse(self, response, method, uri, headers, redirectCount):\n-        \"\"\"\n-        Handle the response, making another request if it indicates a redirect.\n-        \"\"\"\n-        if response.code in (http.MOVED_PERMANENTLY, http.FOUND,\n-                             http.TEMPORARY_REDIRECT):\n-            if method not in ('GET', 'HEAD'):\n-                err = error.PageRedirect(response.code, location=uri)\n-                raise ResponseFailed([failure.Failure(err)], response)\n-            return self._handleRedirect(response, method, uri, headers,\n-                                        redirectCount)\n-        elif response.code == http.SEE_OTHER:\n-            return self._handleRedirect(response, 'GET', uri, headers,\n-                                        redirectCount)\n-        return response\n-\n-\n-\n-class _ReadBodyProtocol(protocol.Protocol):\n-    \"\"\"\n-    Protocol that collects data sent to it.\n-\n-    This is a helper for L{IResponse.deliverBody}, which collects the body and\n-    fires a deferred with it.\n-\n-    @ivar deferred: See L{__init__}.\n-    @ivar status: See L{__init__}.\n-    @ivar message: See L{__init__}.\n-\n-    @ivar dataBuffer: list of byte-strings received\n-    @type dataBuffer: L{list} of L{bytes}\n-    \"\"\"\n-\n-    def __init__(self, status, message, deferred):\n-        \"\"\"\n-        @param status: Status of L{IResponse}\n-        @ivar status: L{int}\n-\n-        @param message: Message of L{IResponse}\n-        @type message: L{bytes}\n-\n-        @param deferred: deferred to fire when response is complete\n-        @type deferred: L{Deferred} firing with L{bytes}\n-        \"\"\"\n-        self.deferred = deferred\n-        self.status = status\n-        self.message = message\n-        self.dataBuffer = []\n-\n-\n-    def dataReceived(self, data):\n-        \"\"\"\n-        Accumulate some more bytes from the response.\n-        \"\"\"\n-        self.dataBuffer.append(data)\n-\n-\n-    def connectionLost(self, reason):\n-        \"\"\"\n-        Deliver the accumulated response bytes to the waiting L{Deferred}, if\n-        the response body has been completely received without error.\n-        \"\"\"\n-        if reason.check(ResponseDone):\n-            self.deferred.callback(b''.join(self.dataBuffer))\n-        elif reason.check(PotentialDataLoss):\n-            self.deferred.errback(\n-                PartialDownloadError(self.status, self.message,\n-                                     b''.join(self.dataBuffer)))\n-        else:\n-            self.deferred.errback(reason)\n-\n-\n-\n-def readBody(response):\n-    \"\"\"\n-    Get the body of an L{IResponse} and return it as a byte string.\n-\n-    This is a helper function for clients that don't want to incrementally\n-    receive the body of an HTTP response.\n-\n-    @param response: The HTTP response for which the body will be read.\n-    @type response: L{IResponse} provider\n-\n-    @return: A L{Deferred} which will fire with the body of the response.\n-    \"\"\"\n-    d = defer.Deferred()\n-    response.deliverBody(_ReadBodyProtocol(response.code, response.phrase, d))\n-    return d\n-}}} '''\n \n \n __all__ = [\n\n@@ -14,27 +14,6 @@ parsed by the L{clientFromString} and L{serverFromString} functions.\n \n from __future__ import division, absolute_import\n \n-import os\n-#import socket\n-\n-from zope.interface import implementer, directlyProvides\n-import warnings\n-\n-from twisted.internet import interfaces, defer, error, fdesc\n-#from twisted.internet.protocol import (\n-#        ClientFactory, Protocol)\n-from twisted.internet.protocol import Factory\n-#from twisted.internet import threads, ProcessProtocol\n-from twisted.internet.interfaces import IStreamServerEndpointStringParser\n-#from twisted.internet.interfaces import IStreamClientEndpointStringParser\n-from twisted.python.filepath import FilePath\n-#from twisted.python.failure import Failure\n-#from twisted.python import log\n-#from twisted.python.components import proxyForInterface\n-\n-from twisted.plugin import IPlugin, getPlugins\n-#from twisted.internet import stdio\n-\n from twisted.internet.endpoints import (\n     clientFromString, serverFromString, quoteStringArgument,\n     TCP4ServerEndpoint, TCP6ServerEndpoint,\n@@ -44,1236 +23,4 @@ from twisted.internet.endpoints import (\n     AdoptedStreamServerEndpoint, connectProtocol,\n )\n \n-\n __all__ = [\"TCP4ClientEndpoint\", \"SSL4ServerEndpoint\"]\n-\n-''' {{{\n-class _WrappingProtocol(Protocol):\n-    \"\"\"\n-    Wrap another protocol in order to notify my user when a connection has\n-    been made.\n-    \"\"\"\n-\n-    def __init__(self, connectedDeferred, wrappedProtocol):\n-        \"\"\"\n-        @param connectedDeferred: The L{Deferred} that will callback\n-            with the C{wrappedProtocol} when it is connected.\n-\n-        @param wrappedProtocol: An L{IProtocol} provider that will be\n-            connected.\n-        \"\"\"\n-        self._connectedDeferred = connectedDeferred\n-        self._wrappedProtocol = wrappedProtocol\n-\n-        for iface in [interfaces.IHalfCloseableProtocol,\n-                      interfaces.IFileDescriptorReceiver]:\n-            if iface.providedBy(self._wrappedProtocol):\n-                directlyProvides(self, iface)\n-\n-\n-    def logPrefix(self):\n-        \"\"\"\n-        Transparently pass through the wrapped protocol's log prefix.\n-        \"\"\"\n-        if interfaces.ILoggingContext.providedBy(self._wrappedProtocol):\n-            return self._wrappedProtocol.logPrefix()\n-        return self._wrappedProtocol.__class__.__name__\n-\n-\n-    def connectionMade(self):\n-        \"\"\"\n-        Connect the C{self._wrappedProtocol} to our C{self.transport} and\n-        callback C{self._connectedDeferred} with the C{self._wrappedProtocol}\n-        \"\"\"\n-        self._wrappedProtocol.makeConnection(self.transport)\n-        self._connectedDeferred.callback(self._wrappedProtocol)\n-\n-\n-    def dataReceived(self, data):\n-        \"\"\"\n-        Proxy C{dataReceived} calls to our C{self._wrappedProtocol}\n-        \"\"\"\n-        return self._wrappedProtocol.dataReceived(data)\n-\n-\n-    def fileDescriptorReceived(self, descriptor):\n-        \"\"\"\n-        Proxy C{fileDescriptorReceived} calls to our C{self._wrappedProtocol}\n-        \"\"\"\n-        return self._wrappedProtocol.fileDescriptorReceived(descriptor)\n-\n-\n-    def connectionLost(self, reason):\n-        \"\"\"\n-        Proxy C{connectionLost} calls to our C{self._wrappedProtocol}\n-        \"\"\"\n-        return self._wrappedProtocol.connectionLost(reason)\n-\n-\n-    def readConnectionLost(self):\n-        \"\"\"\n-        Proxy L{IHalfCloseableProtocol.readConnectionLost} to our\n-        C{self._wrappedProtocol}\n-        \"\"\"\n-        self._wrappedProtocol.readConnectionLost()\n-\n-\n-    def writeConnectionLost(self):\n-        \"\"\"\n-        Proxy L{IHalfCloseableProtocol.writeConnectionLost} to our\n-        C{self._wrappedProtocol}\n-        \"\"\"\n-        self._wrappedProtocol.writeConnectionLost()\n-\n-\n-\n-class _WrappingFactory(ClientFactory):\n-    \"\"\"\n-    Wrap a factory in order to wrap the protocols it builds.\n-\n-    @ivar _wrappedFactory: A provider of I{IProtocolFactory} whose buildProtocol\n-        method will be called and whose resulting protocol will be wrapped.\n-\n-    @ivar _onConnection: A L{Deferred} that fires when the protocol is\n-        connected\n-\n-    @ivar _connector: A L{connector <twisted.internet.interfaces.IConnector>}\n-        that is managing the current or previous connection attempt.\n-    \"\"\"\n-    protocol = _WrappingProtocol\n-\n-    def __init__(self, wrappedFactory):\n-        \"\"\"\n-        @param wrappedFactory: A provider of I{IProtocolFactory} whose\n-            buildProtocol method will be called and whose resulting protocol\n-            will be wrapped.\n-        \"\"\"\n-        self._wrappedFactory = wrappedFactory\n-        self._onConnection = defer.Deferred(canceller=self._canceller)\n-\n-\n-    def startedConnecting(self, connector):\n-        \"\"\"\n-        A connection attempt was started.  Remember the connector which started\n-        said attempt, for use later.\n-        \"\"\"\n-        self._connector = connector\n-\n-\n-    def _canceller(self, deferred):\n-        \"\"\"\n-        The outgoing connection attempt was cancelled.  Fail that L{Deferred}\n-        with an L{error.ConnectingCancelledError}.\n-\n-        @param deferred: The L{Deferred <defer.Deferred>} that was cancelled;\n-            should be the same as C{self._onConnection}.\n-        @type deferred: L{Deferred <defer.Deferred>}\n-\n-        @note: This relies on startedConnecting having been called, so it may\n-            seem as though there's a race condition where C{_connector} may not\n-            have been set.  However, using public APIs, this condition is\n-            impossible to catch, because a connection API\n-            (C{connectTCP}/C{SSL}/C{UNIX}) is always invoked before a\n-            L{_WrappingFactory}'s L{Deferred <defer.Deferred>} is returned to\n-            C{connect()}'s caller.\n-\n-        @return: C{None}\n-        \"\"\"\n-        deferred.errback(\n-            error.ConnectingCancelledError(\n-                self._connector.getDestination()))\n-        self._connector.stopConnecting()\n-\n-\n-    def doStart(self):\n-        \"\"\"\n-        Start notifications are passed straight through to the wrapped factory.\n-        \"\"\"\n-        self._wrappedFactory.doStart()\n-\n-\n-    def doStop(self):\n-        \"\"\"\n-        Stop notifications are passed straight through to the wrapped factory.\n-        \"\"\"\n-        self._wrappedFactory.doStop()\n-\n-\n-    def buildProtocol(self, addr):\n-        \"\"\"\n-        Proxy C{buildProtocol} to our C{self._wrappedFactory} or errback\n-        the C{self._onConnection} L{Deferred}.\n-\n-        @return: An instance of L{_WrappingProtocol} or C{None}\n-        \"\"\"\n-        try:\n-            proto = self._wrappedFactory.buildProtocol(addr)\n-        except:\n-            self._onConnection.errback()\n-        else:\n-            return self.protocol(self._onConnection, proto)\n-\n-\n-    def clientConnectionFailed(self, connector, reason):\n-        \"\"\"\n-        Errback the C{self._onConnection} L{Deferred} when the\n-        client connection fails.\n-        \"\"\"\n-        if not self._onConnection.called:\n-            self._onConnection.errback(reason)\n-\n-\n-\n-\n-\n-@implementer(interfaces.ITransport)\n-class _ProcessEndpointTransport(proxyForInterface(\n-                                interfaces.IProcessTransport, '_process')):\n-    \"\"\"\n-    An L{ITransport} provider for the L{IProtocol} instance passed to the\n-    process endpoint.\n-\n-    @ivar _process: An active process transport which will be used by write\n-        methods on this object to write data to a child process.\n-    @type _process: L{interfaces.IProcessTransport} provider\n-    \"\"\"\n-\n-    def write(self, data):\n-        \"\"\"\n-        Write to the child process's standard input.\n-\n-        @param data: The data to write on stdin.\n-        \"\"\"\n-        self._process.writeToChild(0, data)\n-\n-\n-    def writeSequence(self, data):\n-        \"\"\"\n-        Write a list of strings to child process's stdin.\n-\n-        @param data: The list of chunks to write on stdin.\n-        \"\"\"\n-        for chunk in data:\n-            self._process.writeToChild(0, chunk)\n-\n-\n-@implementer(interfaces.IStreamServerEndpoint)\n-class _TCPServerEndpoint(object):\n-    \"\"\"\n-    A TCP server endpoint interface\n-    \"\"\"\n-\n-    def __init__(self, reactor, port, backlog, interface):\n-        \"\"\"\n-        @param reactor: An L{IReactorTCP} provider.\n-\n-        @param port: The port number used for listening\n-        @type port: int\n-\n-        @param backlog: Size of the listen queue\n-        @type backlog: int\n-\n-        @param interface: The hostname to bind to\n-        @type interface: str\n-        \"\"\"\n-        self._reactor = reactor\n-        self._port = port\n-        self._backlog = backlog\n-        self._interface = interface\n-\n-\n-    def listen(self, protocolFactory):\n-        \"\"\"\n-        Implement L{IStreamServerEndpoint.listen} to listen on a TCP\n-        socket\n-        \"\"\"\n-        return defer.execute(self._reactor.listenTCP,\n-                             self._port,\n-                             protocolFactory,\n-                             backlog=self._backlog,\n-                             interface=self._interface)\n-\n-\n-\n-class TCP4ServerEndpoint(_TCPServerEndpoint):\n-    \"\"\"\n-    Implements TCP server endpoint with an IPv4 configuration\n-    \"\"\"\n-    def __init__(self, reactor, port, backlog=50, interface=''):\n-        \"\"\"\n-        @param reactor: An L{IReactorTCP} provider.\n-\n-        @param port: The port number used for listening\n-        @type port: int\n-\n-        @param backlog: Size of the listen queue\n-        @type backlog: int\n-\n-        @param interface: The hostname to bind to, defaults to '' (all)\n-        @type interface: str\n-        \"\"\"\n-        _TCPServerEndpoint.__init__(self, reactor, port, backlog, interface)\n-\n-\n-\n-class TCP6ServerEndpoint(_TCPServerEndpoint):\n-    \"\"\"\n-    Implements TCP server endpoint with an IPv6 configuration\n-    \"\"\"\n-    def __init__(self, reactor, port, backlog=50, interface='::'):\n-        \"\"\"\n-        @param reactor: An L{IReactorTCP} provider.\n-\n-        @param port: The port number used for listening\n-        @type port: int\n-\n-        @param backlog: Size of the listen queue\n-        @type backlog: int\n-\n-        @param interface: The hostname to bind to, defaults to '' (all)\n-        @type interface: str\n-        \"\"\"\n-        _TCPServerEndpoint.__init__(self, reactor, port, backlog, interface)\n-\n-\n-\n-@implementer(interfaces.IStreamClientEndpoint)\n-class TCP4ClientEndpoint(object):\n-    \"\"\"\n-    TCP client endpoint with an IPv4 configuration.\n-    \"\"\"\n-\n-    def __init__(self, reactor, host, port, timeout=30, bindAddress=None):\n-        \"\"\"\n-        @param reactor: An L{IReactorTCP} provider\n-\n-        @param host: A hostname, used when connecting\n-        @type host: str\n-\n-        @param port: The port number, used when connecting\n-        @type port: int\n-\n-        @param timeout: The number of seconds to wait before assuming the\n-            connection has failed.\n-        @type timeout: int\n-\n-        @param bindAddress: A (host, port) tuple of local address to bind to,\n-            or None.\n-        @type bindAddress: tuple\n-        \"\"\"\n-        self._reactor = reactor\n-        self._host = host\n-        self._port = port\n-        self._timeout = timeout\n-        self._bindAddress = bindAddress\n-\n-\n-    def connect(self, protocolFactory):\n-        \"\"\"\n-        Implement L{IStreamClientEndpoint.connect} to connect via TCP.\n-        \"\"\"\n-        try:\n-            wf = _WrappingFactory(protocolFactory)\n-            self._reactor.connectTCP(\n-                self._host, self._port, wf,\n-                timeout=self._timeout, bindAddress=self._bindAddress)\n-            return wf._onConnection\n-        except:\n-            return defer.fail()\n-\n-\n-\n-\n-@implementer(interfaces.IStreamServerEndpoint)\n-class SSL4ServerEndpoint(object):\n-    \"\"\"\n-    SSL secured TCP server endpoint with an IPv4 configuration.\n-    \"\"\"\n-\n-    def __init__(self, reactor, port, sslContextFactory,\n-                 backlog=50, interface=''):\n-        \"\"\"\n-        @param reactor: An L{IReactorSSL} provider.\n-\n-        @param port: The port number used for listening\n-        @type port: int\n-\n-        @param sslContextFactory: An instance of\n-            L{twisted.internet.ssl.ContextFactory}.\n-\n-        @param backlog: Size of the listen queue\n-        @type backlog: int\n-\n-        @param interface: The hostname to bind to, defaults to '' (all)\n-        @type interface: str\n-        \"\"\"\n-        self._reactor = reactor\n-        self._port = port\n-        self._sslContextFactory = sslContextFactory\n-        self._backlog = backlog\n-        self._interface = interface\n-\n-\n-    def listen(self, protocolFactory):\n-        \"\"\"\n-        Implement L{IStreamServerEndpoint.listen} to listen for SSL on a\n-        TCP socket.\n-        \"\"\"\n-        return defer.execute(self._reactor.listenSSL, self._port,\n-                             protocolFactory,\n-                             contextFactory=self._sslContextFactory,\n-                             backlog=self._backlog,\n-                             interface=self._interface)\n-\n-\n-\n-@implementer(interfaces.IStreamClientEndpoint)\n-class SSL4ClientEndpoint(object):\n-    \"\"\"\n-    SSL secured TCP client endpoint with an IPv4 configuration\n-    \"\"\"\n-\n-    def __init__(self, reactor, host, port, sslContextFactory,\n-                 timeout=30, bindAddress=None):\n-        \"\"\"\n-        @param reactor: An L{IReactorSSL} provider.\n-\n-        @param host: A hostname, used when connecting\n-        @type host: str\n-\n-        @param port: The port number, used when connecting\n-        @type port: int\n-\n-        @param sslContextFactory: SSL Configuration information as an instance\n-            of L{twisted.internet.ssl.ContextFactory}.\n-\n-        @param timeout: Number of seconds to wait before assuming the\n-            connection has failed.\n-        @type timeout: int\n-\n-        @param bindAddress: A (host, port) tuple of local address to bind to,\n-            or None.\n-        @type bindAddress: tuple\n-        \"\"\"\n-        self._reactor = reactor\n-        self._host = host\n-        self._port = port\n-        self._sslContextFactory = sslContextFactory\n-        self._timeout = timeout\n-        self._bindAddress = bindAddress\n-\n-\n-    def connect(self, protocolFactory):\n-        \"\"\"\n-        Implement L{IStreamClientEndpoint.connect} to connect with SSL over\n-        TCP.\n-        \"\"\"\n-        try:\n-            wf = _WrappingFactory(protocolFactory)\n-            self._reactor.connectSSL(\n-                self._host, self._port, wf, self._sslContextFactory,\n-                timeout=self._timeout, bindAddress=self._bindAddress)\n-            return wf._onConnection\n-        except:\n-            return defer.fail()\n-\n-\n-\n-@implementer(interfaces.IStreamServerEndpoint)\n-class UNIXServerEndpoint(object):\n-    \"\"\"\n-    UnixSocket server endpoint.\n-    \"\"\"\n-    def __init__(self, reactor, address, backlog=50, mode=0o666, wantPID=0):\n-        \"\"\"\n-        @param reactor: An L{IReactorUNIX} provider.\n-        @param address: The path to the Unix socket file, used when listening\n-        @param backlog: number of connections to allow in backlog.\n-        @param mode: mode to set on the unix socket.  This parameter is\n-            deprecated.  Permissions should be set on the directory which\n-            contains the UNIX socket.\n-        @param wantPID: If True, create a pidfile for the socket.\n-        \"\"\"\n-        self._reactor = reactor\n-        self._address = address\n-        self._backlog = backlog\n-        self._mode = mode\n-        self._wantPID = wantPID\n-\n-\n-    def listen(self, protocolFactory):\n-        \"\"\"\n-        Implement L{IStreamServerEndpoint.listen} to listen on a UNIX socket.\n-        \"\"\"\n-        return defer.execute(self._reactor.listenUNIX, self._address,\n-                             protocolFactory,\n-                             backlog=self._backlog,\n-                             mode=self._mode,\n-                             wantPID=self._wantPID)\n-\n-\n-\n-@implementer(interfaces.IStreamClientEndpoint)\n-class UNIXClientEndpoint(object):\n-    \"\"\"\n-    UnixSocket client endpoint.\n-    \"\"\"\n-    def __init__(self, reactor, path, timeout=30, checkPID=0):\n-        \"\"\"\n-        @param reactor: An L{IReactorUNIX} provider.\n-\n-        @param path: The path to the Unix socket file, used when connecting\n-        @type path: str\n-\n-        @param timeout: Number of seconds to wait before assuming the\n-            connection has failed.\n-        @type timeout: int\n-\n-        @param checkPID: If True, check for a pid file to verify that a server\n-            is listening.\n-        @type checkPID: bool\n-        \"\"\"\n-        self._reactor = reactor\n-        self._path = path\n-        self._timeout = timeout\n-        self._checkPID = checkPID\n-\n-\n-    def connect(self, protocolFactory):\n-        \"\"\"\n-        Implement L{IStreamClientEndpoint.connect} to connect via a\n-        UNIX Socket\n-        \"\"\"\n-        try:\n-            wf = _WrappingFactory(protocolFactory)\n-            self._reactor.connectUNIX(\n-                self._path, wf,\n-                timeout=self._timeout,\n-                checkPID=self._checkPID)\n-            return wf._onConnection\n-        except:\n-            return defer.fail()\n-\n-\n-\n-@implementer(interfaces.IStreamServerEndpoint)\n-class AdoptedStreamServerEndpoint(object):\n-    \"\"\"\n-    An endpoint for listening on a file descriptor initialized outside of\n-    Twisted.\n-\n-    @ivar _used: A C{bool} indicating whether this endpoint has been used to\n-        listen with a factory yet.  C{True} if so.\n-    \"\"\"\n-    _close = os.close\n-    _setNonBlocking = staticmethod(fdesc.setNonBlocking)\n-\n-    def __init__(self, reactor, fileno, addressFamily):\n-        \"\"\"\n-        @param reactor: An L{IReactorSocket} provider.\n-\n-        @param fileno: An integer file descriptor corresponding to a listening\n-            I{SOCK_STREAM} socket.\n-\n-        @param addressFamily: The address family of the socket given by\n-            C{fileno}.\n-        \"\"\"\n-        self.reactor = reactor\n-        self.fileno = fileno\n-        self.addressFamily = addressFamily\n-        self._used = False\n-\n-\n-    def listen(self, factory):\n-        \"\"\"\n-        Implement L{IStreamServerEndpoint.listen} to start listening on, and\n-        then close, C{self._fileno}.\n-        \"\"\"\n-        if self._used:\n-            return defer.fail(error.AlreadyListened())\n-        self._used = True\n-\n-        try:\n-            self._setNonBlocking(self.fileno)\n-            port = self.reactor.adoptStreamPort(\n-                self.fileno, self.addressFamily, factory)\n-            self._close(self.fileno)\n-        except:\n-            return defer.fail()\n-        return defer.succeed(port)\n-\n-\n-\n-\n-def _parseTCP(factory, port, interface=\"\", backlog=50):\n-    \"\"\"\n-    Internal parser function for L{_parseServer} to convert the string\n-    arguments for a TCP(IPv4) stream endpoint into the structured arguments.\n-\n-    @param factory: the protocol factory being parsed, or C{None}.  (This was a\n-        leftover argument from when this code was in C{strports}, and is now\n-        mostly None and unused.)\n-\n-    @type factory: L{IProtocolFactory} or C{NoneType}\n-\n-    @param port: the integer port number to bind\n-    @type port: C{str}\n-\n-    @param interface: the interface IP to listen on\n-    @param backlog: the length of the listen queue\n-    @type backlog: C{str}\n-\n-    @return: a 2-tuple of (args, kwargs), describing  the parameters to\n-        L{IReactorTCP.listenTCP} (or, modulo argument 2, the factory, arguments\n-        to L{TCP4ServerEndpoint}.\n-    \"\"\"\n-    return (int(port), factory), {'interface': interface,\n-                                  'backlog': int(backlog)}\n-\n-\n-\n-def _parseUNIX(factory, address, mode='666', backlog=50, lockfile=True):\n-    \"\"\"\n-    Internal parser function for L{_parseServer} to convert the string\n-    arguments for a UNIX (AF_UNIX/SOCK_STREAM) stream endpoint into the\n-    structured arguments.\n-\n-    @param factory: the protocol factory being parsed, or C{None}.  (This was a\n-        leftover argument from when this code was in C{strports}, and is now\n-        mostly None and unused.)\n-\n-    @type factory: L{IProtocolFactory} or C{NoneType}\n-\n-    @param address: the pathname of the unix socket\n-    @type address: C{str}\n-\n-    @param backlog: the length of the listen queue\n-    @type backlog: C{str}\n-\n-    @param lockfile: A string '0' or '1', mapping to True and False\n-        respectively.  See the C{wantPID} argument to C{listenUNIX}\n-\n-    @return: a 2-tuple of (args, kwargs), describing  the parameters to\n-        L{IReactorTCP.listenUNIX} (or, modulo argument 2, the factory,\n-        arguments to L{UNIXServerEndpoint}.\n-    \"\"\"\n-    return (\n-        (address, factory),\n-        {'mode': int(mode, 8), 'backlog': int(backlog),\n-         'wantPID': bool(int(lockfile))})\n-\n-\n-\n-def _parseSSL(factory, port, privateKey=\"server.pem\", certKey=None,\n-              sslmethod=None, interface='', backlog=50):\n-    \"\"\"\n-    Internal parser function for L{_parseServer} to convert the string\n-    arguments for an SSL (over TCP/IPv4) stream endpoint into the structured\n-    arguments.\n-\n-    @param factory: the protocol factory being parsed, or C{None}.  (This was a\n-        leftover argument from when this code was in C{strports}, and is now\n-        mostly None and unused.)\n-    @type factory: L{IProtocolFactory} or C{NoneType}\n-\n-    @param port: the integer port number to bind\n-    @type port: C{str}\n-\n-    @param interface: the interface IP to listen on\n-    @param backlog: the length of the listen queue\n-    @type backlog: C{str}\n-\n-    @param privateKey: The file name of a PEM format private key file.\n-    @type privateKey: C{str}\n-\n-    @param certKey: The file name of a PEM format certificate file.\n-    @type certKey: C{str}\n-\n-    @param sslmethod: The string name of an SSL method, based on the name of a\n-        constant in C{OpenSSL.SSL}.  Must be one of: \"SSLv23_METHOD\",\n-        \"SSLv2_METHOD\", \"SSLv3_METHOD\", \"TLSv1_METHOD\".\n-    @type sslmethod: C{str}\n-\n-    @return: a 2-tuple of (args, kwargs), describing  the parameters to\n-        L{IReactorSSL.listenSSL} (or, modulo argument 2, the factory, arguments\n-        to L{SSL4ServerEndpoint}.\n-    \"\"\"\n-    from twisted.internet import ssl\n-    if certKey is None:\n-        certKey = privateKey\n-    kw = {}\n-    if sslmethod is not None:\n-        kw['method'] = getattr(ssl.SSL, sslmethod)\n-    else:\n-        kw['method'] = ssl.SSL.SSLv23_METHOD\n-    certPEM = FilePath(certKey).getContent()\n-    keyPEM = FilePath(privateKey).getContent()\n-    privateCertificate = ssl.PrivateCertificate.loadPEM(certPEM + keyPEM)\n-    cf = ssl.CertificateOptions(\n-        privateKey=privateCertificate.privateKey.original,\n-        certificate=privateCertificate.original,\n-        **kw\n-    )\n-    return ((int(port), factory, cf),\n-            {'interface': interface, 'backlog': int(backlog)})\n-\n-\n-\n-@implementer(IPlugin, IStreamServerEndpointStringParser)\n-class _StandardIOParser(object):\n-    \"\"\"\n-    Stream server endpoint string parser for the Standard I/O type.\n-\n-    @ivar prefix: See L{IStreamClientEndpointStringParser.prefix}.\n-    \"\"\"\n-    prefix = \"stdio\"\n-\n-    def _parseServer(self, reactor):\n-        \"\"\"\n-        Internal parser function for L{_parseServer} to convert the string\n-        arguments into structured arguments for the L{StandardIOEndpoint}\n-\n-        @param reactor: Reactor for the endpoint\n-        \"\"\"\n-        return StandardIOEndpoint(reactor)\n-\n-\n-    def parseStreamServer(self, reactor, *args, **kwargs):\n-        # Redirects to another function (self._parseServer), tricks zope.interface\n-        # into believing the interface is correctly implemented.\n-        return self._parseServer(reactor)\n-\n-\n-\n-\n-@implementer(IPlugin, IStreamServerEndpointStringParser)\n-class _TCP6ServerParser(object):\n-    \"\"\"\n-    Stream server endpoint string parser for the TCP6ServerEndpoint type.\n-\n-    @ivar prefix: See L{IStreamClientEndpointStringParser.prefix}.\n-    \"\"\"\n-    prefix = \"tcp6\"     # Used in _parseServer to identify the plugin with the endpoint type\n-\n-    def _parseServer(self, reactor, port, backlog=50, interface='::'):\n-        \"\"\"\n-        Internal parser function for L{_parseServer} to convert the string\n-        arguments into structured arguments for the L{TCP6ServerEndpoint}\n-\n-        @param reactor: An L{IReactorTCP} provider.\n-\n-        @param port: The port number used for listening\n-        @type port: int\n-\n-        @param backlog: Size of the listen queue\n-        @type backlog: int\n-\n-        @param interface: The hostname to bind to\n-        @type interface: str\n-        \"\"\"\n-        port = int(port)\n-        backlog = int(backlog)\n-        return TCP6ServerEndpoint(reactor, port, backlog, interface)\n-\n-\n-    def parseStreamServer(self, reactor, *args, **kwargs):\n-        # Redirects to another function (self._parseServer), tricks zope.interface\n-        # into believing the interface is correctly implemented.\n-        return self._parseServer(reactor, *args, **kwargs)\n-\n-\n-\n-_serverParsers = {\"tcp\": _parseTCP,\n-                  \"unix\": _parseUNIX,\n-                  \"ssl\": _parseSSL,\n-                  }\n-\n-_OP, _STRING = range(2)\n-\n-def _tokenize(description):\n-    \"\"\"\n-    Tokenize a strports string and yield each token.\n-\n-    @param description: a string as described by L{serverFromString} or\n-        L{clientFromString}.\n-\n-    @return: an iterable of 2-tuples of (L{_OP} or L{_STRING}, string).  Tuples\n-        starting with L{_OP} will contain a second element of either ':' (i.e.\n-        'next parameter') or '=' (i.e. 'assign parameter value').  For example,\n-        the string 'hello:greet\\=ing=world' would result in a generator\n-        yielding these values::\n-\n-            _STRING, 'hello'\n-            _OP, ':'\n-            _STRING, 'greet=ing'\n-            _OP, '='\n-            _STRING, 'world'\n-    \"\"\"\n-    current = ''\n-    ops = ':='\n-    nextOps = {':': ':=', '=': ':'}\n-    description = iter(description)\n-    for n in description:\n-        if n in ops:\n-            yield _STRING, current\n-            yield _OP, n\n-            current = ''\n-            ops = nextOps[n]\n-        elif n == '\\\\':\n-            current += next(description)\n-        else:\n-            current += n\n-    yield _STRING, current\n-\n-\n-\n-def _parse(description):\n-    \"\"\"\n-    Convert a description string into a list of positional and keyword\n-    parameters, using logic vaguely like what Python does.\n-\n-    @param description: a string as described by L{serverFromString} or\n-        L{clientFromString}.\n-\n-    @return: a 2-tuple of C{(args, kwargs)}, where 'args' is a list of all\n-        ':'-separated C{str}s not containing an '=' and 'kwargs' is a map of\n-        all C{str}s which do contain an '='.  For example, the result of\n-        C{_parse('a:b:d=1:c')} would be C{(['a', 'b', 'c'], {'d': '1'})}.\n-    \"\"\"\n-    args, kw = [], {}\n-    def add(sofar):\n-        if len(sofar) == 1:\n-            args.append(sofar[0])\n-        else:\n-            kw[sofar[0]] = sofar[1]\n-    sofar = ()\n-    for (type, value) in _tokenize(description):\n-        if type is _STRING:\n-            sofar += (value,)\n-        elif value == ':':\n-            add(sofar)\n-            sofar = ()\n-    add(sofar)\n-    return args, kw\n-\n-\n-# Mappings from description \"names\" to endpoint constructors.\n-_endpointServerFactories = {\n-    'TCP': TCP4ServerEndpoint,\n-    'SSL': SSL4ServerEndpoint,\n-    'UNIX': UNIXServerEndpoint,\n-    }\n-\n-_endpointClientFactories = {\n-    'TCP': TCP4ClientEndpoint,\n-    'SSL': SSL4ClientEndpoint,\n-    'UNIX': UNIXClientEndpoint,\n-    }\n-\n-\n-_NO_DEFAULT = object()\n-\n-def _parseServer(description, factory, default=None):\n-    \"\"\"\n-    Parse a stports description into a 2-tuple of arguments and keyword values.\n-\n-    @param description: A description in the format explained by\n-        L{serverFromString}.\n-    @type description: C{str}\n-\n-    @param factory: A 'factory' argument; this is left-over from\n-        twisted.application.strports, it's not really used.\n-    @type factory: L{IProtocolFactory} or L{None}\n-\n-    @param default: Deprecated argument, specifying the default parser mode to\n-        use for unqualified description strings (those which do not have a ':'\n-        and prefix).\n-    @type default: C{str} or C{NoneType}\n-\n-    @return: a 3-tuple of (plugin or name, arguments, keyword arguments)\n-    \"\"\"\n-    args, kw = _parse(description)\n-    if not args or (len(args) == 1 and not kw):\n-        deprecationMessage = (\n-            \"Unqualified strport description passed to 'service'.\"\n-            \"Use qualified endpoint descriptions; for example, 'tcp:%s'.\"\n-            % (description,))\n-        if default is None:\n-            default = 'tcp'\n-            warnings.warn(\n-                deprecationMessage, category=DeprecationWarning, stacklevel=4)\n-        elif default is _NO_DEFAULT:\n-            raise ValueError(deprecationMessage)\n-        # If the default has been otherwise specified, the user has already\n-        # been warned.\n-        args[0:0] = [default]\n-    endpointType = args[0]\n-    parser = _serverParsers.get(endpointType)\n-    if parser is None:\n-        # If the required parser is not found in _server, check if\n-        # a plugin exists for the endpointType\n-        for plugin in getPlugins(IStreamServerEndpointStringParser):\n-            if plugin.prefix == endpointType:\n-                return (plugin, args[1:], kw)\n-        raise ValueError(\"Unknown endpoint type: '%s'\" % (endpointType,))\n-    return (endpointType.upper(),) + parser(factory, *args[1:], **kw)\n-\n-\n-\n-def _serverFromStringLegacy(reactor, description, default):\n-    \"\"\"\n-    Underlying implementation of L{serverFromString} which avoids exposing the\n-    deprecated 'default' argument to anything but L{strports.service}.\n-    \"\"\"\n-    nameOrPlugin, args, kw = _parseServer(description, None, default)\n-    if type(nameOrPlugin) is not str:\n-        plugin = nameOrPlugin\n-        return plugin.parseStreamServer(reactor, *args, **kw)\n-    else:\n-        name = nameOrPlugin\n-    # Chop out the factory.\n-    args = args[:1] + args[2:]\n-    return _endpointServerFactories[name](reactor, *args, **kw)\n-\n-\n-\n-def serverFromString(reactor, description):\n-    \"\"\"\n-    Construct a stream server endpoint from an endpoint description string.\n-\n-    The format for server endpoint descriptions is a simple string.  It is a\n-    prefix naming the type of endpoint, then a colon, then the arguments for\n-    that endpoint.\n-\n-    For example, you can call it like this to create an endpoint that will\n-    listen on TCP port 80::\n-\n-        serverFromString(reactor, \"tcp:80\")\n-\n-    Additional arguments may be specified as keywords, separated with colons.\n-    For example, you can specify the interface for a TCP server endpoint to\n-    bind to like this::\n-\n-        serverFromString(reactor, \"tcp:80:interface=127.0.0.1\")\n-\n-    SSL server endpoints may be specified with the 'ssl' prefix, and the\n-    private key and certificate files may be specified by the C{privateKey} and\n-    C{certKey} arguments::\n-\n-        serverFromString(reactor, \"ssl:443:privateKey=key.pem:certKey=crt.pem\")\n-\n-    If a private key file name (C{privateKey}) isn't provided, a \"server.pem\"\n-    file is assumed to exist which contains the private key. If the certificate\n-    file name (C{certKey}) isn't provided, the private key file is assumed to\n-    contain the certificate as well.\n-\n-    You may escape colons in arguments with a backslash, which you will need to\n-    use if you want to specify a full pathname argument on Windows::\n-\n-        serverFromString(reactor,\n-            \"ssl:443:privateKey=C\\\\:/key.pem:certKey=C\\\\:/cert.pem\")\n-\n-    finally, the 'unix' prefix may be used to specify a filesystem UNIX socket,\n-    optionally with a 'mode' argument to specify the mode of the socket file\n-    created by C{listen}::\n-\n-        serverFromString(reactor, \"unix:/var/run/finger\")\n-        serverFromString(reactor, \"unix:/var/run/finger:mode=660\")\n-\n-    This function is also extensible; new endpoint types may be registered as\n-    L{IStreamServerEndpointStringParser} plugins.  See that interface for more\n-    information.\n-\n-    @param reactor: The server endpoint will be constructed with this reactor.\n-\n-    @param description: The strports description to parse.\n-\n-    @return: A new endpoint which can be used to listen with the parameters\n-        given by by C{description}.\n-\n-    @rtype: L{IStreamServerEndpoint<twisted.internet.interfaces.IStreamServerEndpoint>}\n-\n-    @raise ValueError: when the 'description' string cannot be parsed.\n-\n-    @since: 10.2\n-    \"\"\"\n-    return _serverFromStringLegacy(reactor, description, _NO_DEFAULT)\n-\n-\n-\n-def quoteStringArgument(argument):\n-    \"\"\"\n-    Quote an argument to L{serverFromString} and L{clientFromString}.  Since\n-    arguments are separated with colons and colons are escaped with\n-    backslashes, some care is necessary if, for example, you have a pathname,\n-    you may be tempted to interpolate into a string like this::\n-\n-        serverFromString(\"ssl:443:privateKey=%s\" % (myPathName,))\n-\n-    This may appear to work, but will have portability issues (Windows\n-    pathnames, for example).  Usually you should just construct the appropriate\n-    endpoint type rather than interpolating strings, which in this case would\n-    be L{SSL4ServerEndpoint}.  There are some use-cases where you may need to\n-    generate such a string, though; for example, a tool to manipulate a\n-    configuration file which has strports descriptions in it.  To be correct in\n-    those cases, do this instead::\n-\n-        serverFromString(\"ssl:443:privateKey=%s\" %\n-                         (quoteStringArgument(myPathName),))\n-\n-    @param argument: The part of the endpoint description string you want to\n-        pass through.\n-\n-    @type argument: C{str}\n-\n-    @return: The quoted argument.\n-\n-    @rtype: C{str}\n-    \"\"\"\n-    return argument.replace('\\\\', '\\\\\\\\').replace(':', '\\\\:')\n-\n-\n-\n-def _parseClientTCP(*args, **kwargs):\n-    \"\"\"\n-    Perform any argument value coercion necessary for TCP client parameters.\n-\n-    Valid positional arguments to this function are host and port.\n-\n-    Valid keyword arguments to this function are all L{IReactorTCP.connectTCP}\n-    arguments.\n-\n-    @return: The coerced values as a C{dict}.\n-    \"\"\"\n-\n-    if len(args) == 2:\n-        kwargs['port'] = int(args[1])\n-        kwargs['host'] = args[0]\n-    elif len(args) == 1:\n-        if 'host' in kwargs:\n-            kwargs['port'] = int(args[0])\n-        else:\n-            kwargs['host'] = args[0]\n-\n-    try:\n-        kwargs['port'] = int(kwargs['port'])\n-    except KeyError:\n-        pass\n-\n-    try:\n-        kwargs['timeout'] = int(kwargs['timeout'])\n-    except KeyError:\n-        pass\n-    return kwargs\n-\n-\n-\n-def _loadCAsFromDir(directoryPath):\n-    \"\"\"\n-    Load certificate-authority certificate objects in a given directory.\n-\n-    @param directoryPath: a L{FilePath} pointing at a directory to load .pem\n-        files from.\n-\n-    @return: a C{list} of L{OpenSSL.crypto.X509} objects.\n-    \"\"\"\n-    from twisted.internet import ssl\n-\n-    caCerts = {}\n-    for child in directoryPath.children():\n-        if not child.basename().split('.')[-1].lower() == 'pem':\n-            continue\n-        try:\n-            data = child.getContent()\n-        except IOError:\n-            # Permission denied, corrupt disk, we don't care.\n-            continue\n-        try:\n-            theCert = ssl.Certificate.loadPEM(data)\n-        except ssl.SSL.Error:\n-            # Duplicate certificate, invalid certificate, etc.  We don't care.\n-            pass\n-        else:\n-            caCerts[theCert.digest()] = theCert.original\n-    return caCerts.values()\n-\n-\n-\n-def _parseClientSSL(*args, **kwargs):\n-    \"\"\"\n-    Perform any argument value coercion necessary for SSL client parameters.\n-\n-    Valid keyword arguments to this function are all L{IReactorSSL.connectSSL}\n-    arguments except for C{contextFactory}.  Instead, C{certKey} (the path name\n-    of the certificate file) C{privateKey} (the path name of the private key\n-    associated with the certificate) are accepted and used to construct a\n-    context factory.\n-\n-    Valid positional arguments to this function are host and port.\n-\n-    @param caCertsDir: The one parameter which is not part of\n-        L{IReactorSSL.connectSSL}'s signature, this is a path name used to\n-        construct a list of certificate authority certificates.  The directory\n-        will be scanned for files ending in C{.pem}, all of which will be\n-        considered valid certificate authorities for this connection.\n-\n-    @type caCertsDir: C{str}\n-\n-    @return: The coerced values as a C{dict}.\n-    \"\"\"\n-    from twisted.internet import ssl\n-    kwargs = _parseClientTCP(*args, **kwargs)\n-    certKey = kwargs.pop('certKey', None)\n-    privateKey = kwargs.pop('privateKey', None)\n-    caCertsDir = kwargs.pop('caCertsDir', None)\n-    if certKey is not None:\n-        certx509 = ssl.Certificate.loadPEM(\n-            FilePath(certKey).getContent()).original\n-    else:\n-        certx509 = None\n-    if privateKey is not None:\n-        privateKey = ssl.PrivateCertificate.loadPEM(\n-            FilePath(privateKey).getContent()).privateKey.original\n-    else:\n-        privateKey = None\n-    if caCertsDir is not None:\n-        verify = True\n-        caCerts = _loadCAsFromDir(FilePath(caCertsDir))\n-    else:\n-        verify = False\n-        caCerts = None\n-    kwargs['sslContextFactory'] = ssl.CertificateOptions(\n-        method=ssl.SSL.SSLv23_METHOD,\n-        certificate=certx509,\n-        privateKey=privateKey,\n-        verify=verify,\n-        caCerts=caCerts\n-    )\n-    return kwargs\n-\n-\n-\n-def _parseClientUNIX(*args, **kwargs):\n-    \"\"\"\n-    Perform any argument value coercion necessary for UNIX client parameters.\n-\n-    Valid keyword arguments to this function are all L{IReactorUNIX.connectUNIX}\n-    keyword arguments except for C{checkPID}.  Instead, C{lockfile} is accepted\n-    and has the same meaning.  Also C{path} is used instead of C{address}.\n-\n-    Valid positional arguments to this function are C{path}.\n-\n-    @return: The coerced values as a C{dict}.\n-    \"\"\"\n-    if len(args) == 1:\n-        kwargs['path'] = args[0]\n-\n-    try:\n-        kwargs['checkPID'] = bool(int(kwargs.pop('lockfile')))\n-    except KeyError:\n-        pass\n-    try:\n-        kwargs['timeout'] = int(kwargs['timeout'])\n-    except KeyError:\n-        pass\n-    return kwargs\n-\n-_clientParsers = {\n-    'TCP': _parseClientTCP,\n-    'SSL': _parseClientSSL,\n-    'UNIX': _parseClientUNIX,\n-    }\n-\n-\n-\n-def clientFromString(reactor, description):\n-    \"\"\"\n-    Construct a client endpoint from a description string.\n-\n-    Client description strings are much like server description strings,\n-    although they take all of their arguments as keywords, aside from host and\n-    port.\n-\n-    You can create a TCP client endpoint with the 'host' and 'port' arguments,\n-    like so::\n-\n-        clientFromString(reactor, \"tcp:host=www.example.com:port=80\")\n-\n-    or, without specifying host and port keywords::\n-\n-        clientFromString(reactor, \"tcp:www.example.com:80\")\n-\n-    Or you can specify only one or the other, as in the following 2 examples::\n-\n-        clientFromString(reactor, \"tcp:host=www.example.com:80\")\n-        clientFromString(reactor, \"tcp:www.example.com:port=80\")\n-\n-    or an SSL client endpoint with those arguments, plus the arguments used by\n-    the server SSL, for a client certificate::\n-\n-        clientFromString(reactor, \"ssl:web.example.com:443:\"\n-                                  \"privateKey=foo.pem:certKey=foo.pem\")\n-\n-    to specify your certificate trust roots, you can identify a directory with\n-    PEM files in it with the C{caCertsDir} argument::\n-\n-        clientFromString(reactor, \"ssl:host=web.example.com:port=443:\"\n-                                  \"caCertsDir=/etc/ssl/certs\")\n-\n-    You can create a UNIX client endpoint with the 'path' argument and optional\n-    'lockfile' and 'timeout' arguments::\n-\n-        clientFromString(reactor, \"unix:path=/var/foo/bar:lockfile=1:timeout=9\")\n-\n-    or, with the path as a positional argument with or without optional\n-    arguments as in the following 2 examples::\n-\n-        clientFromString(reactor, \"unix:/var/foo/bar\")\n-        clientFromString(reactor, \"unix:/var/foo/bar:lockfile=1:timeout=9\")\n-\n-    This function is also extensible; new endpoint types may be registered as\n-    L{IStreamClientEndpointStringParser} plugins.  See that interface for more\n-    information.\n-\n-    @param reactor: The client endpoint will be constructed with this reactor.\n-\n-    @param description: The strports description to parse.\n-\n-    @return: A new endpoint which can be used to connect with the parameters\n-        given by by C{description}.\n-    @rtype: L{IStreamClientEndpoint<twisted.internet.interfaces.IStreamClientEndpoint>}\n-\n-    @since: 10.2\n-    \"\"\"\n-    args, kwargs = _parse(description)\n-    aname = args.pop(0)\n-    name = aname.upper()\n-    for plugin in getPlugins(IStreamClientEndpointStringParser):\n-        if plugin.prefix.upper() == name:\n-            return plugin.parseStreamClient(*args, **kwargs)\n-    if name not in _clientParsers:\n-        raise ValueError(\"Unknown endpoint type: %r\" % (aname,))\n-    kwargs = _clientParsers[name](*args, **kwargs)\n-    return _endpointClientFactories[name](reactor, **kwargs)\n-\n-\n-\n-def connectProtocol(endpoint, protocol):\n-    \"\"\"\n-    Connect a protocol instance to an endpoint.\n-\n-    This allows using a client endpoint without having to create a factory.\n-\n-    @param endpoint: A client endpoint to connect to.\n-\n-    @param protocol: A protocol instance.\n-\n-    @return: The result of calling C{connect} on the endpoint, i.e. a\n-    L{Deferred} that will fire with the protocol when connected, or an\n-    appropriate error.\n-    \"\"\"\n-    class OneShotFactory(Factory):\n-        def buildProtocol(self, addr):\n-            return protocol\n-    return endpoint.connect(OneShotFactory())\n-}}} '''\n\n@@ -9,8 +9,6 @@ Maintainer: Itamar Shtull-Trauring\n \n from __future__ import division, absolute_import\n \n-from zope.interface import Interface, Attribute\n-\n from twisted.internet.interfaces import (\n     IAddress, IConnector, IResolverSimple, IReactorTCP, IReactorSSL,\n     IReactorWin32Events, IReactorUDP, IReactorMulticast, IReactorProcess,\n@@ -28,2434 +26,3 @@ from twisted.internet.interfaces import (\n     IStreamServerEndpointStringParser, IStreamClientEndpointStringParser,\n     IReactorUNIX, IReactorUNIXDatagram, IReactorSocket, IResolver\n )\n-\n-''' {{{\n-class IAddress(Interface):\n-    \"\"\"\n-    An address, e.g. a TCP C{(host, port)}.\n-\n-    Default implementations are in L{twisted.internet.address}.\n-    \"\"\"\n-\n-### Reactor Interfaces\n-\n-class IConnector(Interface):\n-    \"\"\"\n-    Object used to interface between connections and protocols.\n-\n-    Each L{IConnector} manages one connection.\n-    \"\"\"\n-\n-    def stopConnecting():\n-        \"\"\"\n-        Stop attempting to connect.\n-        \"\"\"\n-\n-    def disconnect():\n-        \"\"\"\n-        Disconnect regardless of the connection state.\n-\n-        If we are connected, disconnect, if we are trying to connect,\n-        stop trying.\n-        \"\"\"\n-\n-    def connect():\n-        \"\"\"\n-        Try to connect to remote address.\n-        \"\"\"\n-\n-    def getDestination():\n-        \"\"\"\n-        Return destination this will try to connect to.\n-\n-        @return: An object which provides L{IAddress}.\n-        \"\"\"\n-\n-\n-\n-class IResolverSimple(Interface):\n-    def getHostByName(name, timeout = (1, 3, 11, 45)):\n-        \"\"\"\n-        Resolve the domain name C{name} into an IP address.\n-\n-        @type name: C{str}\n-        @type timeout: C{tuple}\n-        @rtype: L{twisted.internet.defer.Deferred}\n-        @return: The callback of the Deferred that is returned will be\n-        passed a string that represents the IP address of the specified\n-        name, or the errback will be called if the lookup times out.  If\n-        multiple types of address records are associated with the name,\n-        A6 records will be returned in preference to AAAA records, which\n-        will be returned in preference to A records.  If there are multiple\n-        records of the type to be returned, one will be selected at random.\n-\n-        @raise twisted.internet.defer.TimeoutError: Raised (asynchronously)\n-        if the name cannot be resolved within the specified timeout period.\n-        \"\"\"\n-\n-\n-\n-class IResolver(IResolverSimple):\n-    def query(query, timeout=None):\n-        \"\"\"\n-        Dispatch C{query} to the method which can handle its type.\n-\n-        @type query: L{twisted.names.dns.Query}\n-        @param query: The DNS query being issued, to which a response is to be\n-            generated.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupAddress(name, timeout=None):\n-        \"\"\"\n-        Perform an A record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupAddress6(name, timeout=None):\n-        \"\"\"\n-        Perform an A6 record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupIPV6Address(name, timeout=None):\n-        \"\"\"\n-        Perform an AAAA record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupMailExchange(name, timeout=None):\n-        \"\"\"\n-        Perform an MX record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupNameservers(name, timeout=None):\n-        \"\"\"\n-        Perform an NS record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupCanonicalName(name, timeout=None):\n-        \"\"\"\n-        Perform a CNAME record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupMailBox(name, timeout=None):\n-        \"\"\"\n-        Perform an MB record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupMailGroup(name, timeout=None):\n-        \"\"\"\n-        Perform an MG record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupMailRename(name, timeout=None):\n-        \"\"\"\n-        Perform an MR record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupPointer(name, timeout=None):\n-        \"\"\"\n-        Perform a PTR record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupAuthority(name, timeout=None):\n-        \"\"\"\n-        Perform an SOA record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupNull(name, timeout=None):\n-        \"\"\"\n-        Perform a NULL record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupWellKnownServices(name, timeout=None):\n-        \"\"\"\n-        Perform a WKS record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupHostInfo(name, timeout=None):\n-        \"\"\"\n-        Perform a HINFO record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupMailboxInfo(name, timeout=None):\n-        \"\"\"\n-        Perform an MINFO record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupText(name, timeout=None):\n-        \"\"\"\n-        Perform a TXT record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupResponsibility(name, timeout=None):\n-        \"\"\"\n-        Perform an RP record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupAFSDatabase(name, timeout=None):\n-        \"\"\"\n-        Perform an AFSDB record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupService(name, timeout=None):\n-        \"\"\"\n-        Perform an SRV record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupAllRecords(name, timeout=None):\n-        \"\"\"\n-        Perform an ALL_RECORD lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupSenderPolicy(name, timeout= 10):\n-        \"\"\"\n-        Perform a SPF record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupNamingAuthorityPointer(name, timeout=None):\n-        \"\"\"\n-        Perform a NAPTR record lookup.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: Sequence of C{int}\n-        @param timeout: Number of seconds after which to reissue the query.\n-            When the last timeout expires, the query is considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.  The first element of the\n-            tuple gives answers.  The second element of the tuple gives\n-            authorities.  The third element of the tuple gives additional\n-            information.  The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-    def lookupZone(name, timeout=None):\n-        \"\"\"\n-        Perform an AXFR record lookup.\n-\n-        NB This is quite different from other DNS requests. See\n-        U{http://cr.yp.to/djbdns/axfr-notes.html} for more\n-        information.\n-\n-        NB Unlike other C{lookup*} methods, the timeout here is not a\n-        list of ints, it is a single int.\n-\n-        @type name: C{str}\n-        @param name: DNS name to resolve.\n-\n-        @type timeout: C{int}\n-        @param timeout: When this timeout expires, the query is\n-            considered failed.\n-\n-        @rtype: L{Deferred}\n-        @return: A L{Deferred} which fires with a three-tuple of lists of\n-            L{twisted.names.dns.RRHeader} instances.\n-            The first element of the tuple gives answers.\n-            The second and third elements are always empty.\n-            The L{Deferred} may instead fail with one of the\n-            exceptions defined in L{twisted.names.error} or with\n-            C{NotImplementedError}.\n-        \"\"\"\n-\n-\n-\n-class IReactorTCP(Interface):\n-\n-    def listenTCP(port, factory, backlog=50, interface=''):\n-        \"\"\"\n-        Connects a given protocol factory to the given numeric TCP/IP port.\n-\n-        @param port: a port number on which to listen\n-\n-        @param factory: a L{twisted.internet.protocol.ServerFactory} instance\n-\n-        @param backlog: size of the listen queue\n-\n-        @param interface: The local IPv4 or IPv6 address to which to bind;\n-            defaults to '', ie all IPv4 addresses.  To bind to all IPv4 and IPv6\n-            addresses, you must call this method twice.\n-\n-        @return: an object that provides L{IListeningPort}.\n-\n-        @raise CannotListenError: as defined here\n-                                  L{twisted.internet.error.CannotListenError},\n-                                  if it cannot listen on this port (e.g., it\n-                                  cannot bind to the required port number)\n-        \"\"\"\n-\n-    def connectTCP(host, port, factory, timeout=30, bindAddress=None):\n-        \"\"\"\n-        Connect a TCP client.\n-\n-        @param host: a host name\n-\n-        @param port: a port number\n-\n-        @param factory: a L{twisted.internet.protocol.ClientFactory} instance\n-\n-        @param timeout: number of seconds to wait before assuming the\n-                        connection has failed.\n-\n-        @param bindAddress: a (host, port) tuple of local address to bind\n-                            to, or None.\n-\n-        @return: An object which provides L{IConnector}. This connector will\n-                 call various callbacks on the factory when a connection is\n-                 made, failed, or lost - see\n-                 L{ClientFactory<twisted.internet.protocol.ClientFactory>}\n-                 docs for details.\n-        \"\"\"\n-\n-class IReactorSSL(Interface):\n-\n-    def connectSSL(host, port, factory, contextFactory, timeout=30, bindAddress=None):\n-        \"\"\"\n-        Connect a client Protocol to a remote SSL socket.\n-\n-        @param host: a host name\n-\n-        @param port: a port number\n-\n-        @param factory: a L{twisted.internet.protocol.ClientFactory} instance\n-\n-        @param contextFactory: a L{twisted.internet.ssl.ClientContextFactory} object.\n-\n-        @param timeout: number of seconds to wait before assuming the\n-                        connection has failed.\n-\n-        @param bindAddress: a (host, port) tuple of local address to bind to,\n-                            or C{None}.\n-\n-        @return: An object which provides L{IConnector}.\n-        \"\"\"\n-\n-    def listenSSL(port, factory, contextFactory, backlog=50, interface=''):\n-        \"\"\"\n-        Connects a given protocol factory to the given numeric TCP/IP port.\n-        The connection is a SSL one, using contexts created by the context\n-        factory.\n-\n-        @param port: a port number on which to listen\n-\n-        @param factory: a L{twisted.internet.protocol.ServerFactory} instance\n-\n-        @param contextFactory: a L{twisted.internet.ssl.ContextFactory} instance\n-\n-        @param backlog: size of the listen queue\n-\n-        @param interface: the hostname to bind to, defaults to '' (all)\n-        \"\"\"\n-\n-\n-\n-class IReactorUNIX(Interface):\n-    \"\"\"\n-    UNIX socket methods.\n-    \"\"\"\n-\n-    def connectUNIX(address, factory, timeout=30, checkPID=0):\n-        \"\"\"\n-        Connect a client protocol to a UNIX socket.\n-\n-        @param address: a path to a unix socket on the filesystem.\n-\n-        @param factory: a L{twisted.internet.protocol.ClientFactory} instance\n-\n-        @param timeout: number of seconds to wait before assuming the connection\n-            has failed.\n-\n-        @param checkPID: if True, check for a pid file to verify that a server\n-            is listening.  If C{address} is a Linux abstract namespace path,\n-            this must be C{False}.\n-\n-        @return: An object which provides L{IConnector}.\n-        \"\"\"\n-\n-\n-    def listenUNIX(address, factory, backlog=50, mode=0o666, wantPID=0):\n-        \"\"\"\n-        Listen on a UNIX socket.\n-\n-        @param address: a path to a unix socket on the filesystem.\n-\n-        @param factory: a L{twisted.internet.protocol.Factory} instance.\n-\n-        @param backlog: number of connections to allow in backlog.\n-\n-        @param mode: The mode (B{not} umask) to set on the unix socket.  See\n-            platform specific documentation for information about how this\n-            might affect connection attempts.\n-        @type mode: C{int}\n-\n-        @param wantPID: if True, create a pidfile for the socket.  If C{address}\n-            is a Linux abstract namespace path, this must be C{False}.\n-\n-        @return: An object which provides L{IListeningPort}.\n-        \"\"\"\n-\n-\n-\n-class IReactorUNIXDatagram(Interface):\n-    \"\"\"\n-    Datagram UNIX socket methods.\n-    \"\"\"\n-\n-    def connectUNIXDatagram(address, protocol, maxPacketSize=8192, mode=0o666, bindAddress=None):\n-        \"\"\"\n-        Connect a client protocol to a datagram UNIX socket.\n-\n-        @param address: a path to a unix socket on the filesystem.\n-\n-        @param protocol: a L{twisted.internet.protocol.ConnectedDatagramProtocol} instance\n-\n-        @param maxPacketSize: maximum packet size to accept\n-\n-        @param mode: The mode (B{not} umask) to set on the unix socket.  See\n-            platform specific documentation for information about how this\n-            might affect connection attempts.\n-        @type mode: C{int}\n-\n-        @param bindAddress: address to bind to\n-\n-        @return: An object which provides L{IConnector}.\n-        \"\"\"\n-\n-\n-    def listenUNIXDatagram(address, protocol, maxPacketSize=8192, mode=0o666):\n-        \"\"\"\n-        Listen on a datagram UNIX socket.\n-\n-        @param address: a path to a unix socket on the filesystem.\n-\n-        @param protocol: a L{twisted.internet.protocol.DatagramProtocol} instance.\n-\n-        @param maxPacketSize: maximum packet size to accept\n-\n-        @param mode: The mode (B{not} umask) to set on the unix socket.  See\n-            platform specific documentation for information about how this\n-            might affect connection attempts.\n-        @type mode: C{int}\n-\n-        @return: An object which provides L{IListeningPort}.\n-        \"\"\"\n-\n-\n-\n-class IReactorWin32Events(Interface):\n-    \"\"\"\n-    Win32 Event API methods\n-\n-    @since: 10.2\n-    \"\"\"\n-\n-    def addEvent(event, fd, action):\n-        \"\"\"\n-        Add a new win32 event to the event loop.\n-\n-        @param event: a Win32 event object created using win32event.CreateEvent()\n-\n-        @param fd: an instance of L{twisted.internet.abstract.FileDescriptor}\n-\n-        @param action: a string that is a method name of the fd instance.\n-                       This method is called in response to the event.\n-\n-        @return: None\n-        \"\"\"\n-\n-\n-    def removeEvent(event):\n-        \"\"\"\n-        Remove an event.\n-\n-        @param event: a Win32 event object added using L{IReactorWin32Events.addEvent}\n-\n-        @return: None\n-        \"\"\"\n-\n-\n-\n-class IReactorUDP(Interface):\n-    \"\"\"\n-    UDP socket methods.\n-    \"\"\"\n-\n-    def listenUDP(port, protocol, interface='', maxPacketSize=8192):\n-        \"\"\"\n-        Connects a given DatagramProtocol to the given numeric UDP port.\n-\n-        @return: object which provides L{IListeningPort}.\n-        \"\"\"\n-\n-\n-\n-class IReactorMulticast(Interface):\n-    \"\"\"\n-    UDP socket methods that support multicast.\n-\n-    IMPORTANT: This is an experimental new interface. It may change\n-    without backwards compatibility. Suggestions are welcome.\n-    \"\"\"\n-\n-    def listenMulticast(port, protocol, interface='', maxPacketSize=8192,\n-                        listenMultiple=False):\n-        \"\"\"\n-        Connects a given\n-        L{DatagramProtocol<twisted.internet.protocol.DatagramProtocol>} to the\n-        given numeric UDP port.\n-\n-        @param listenMultiple: If set to True, allows multiple sockets to\n-            bind to the same address and port number at the same time.\n-        @type listenMultiple: C{bool}\n-\n-        @returns: An object which provides L{IListeningPort}.\n-\n-        @see: L{twisted.internet.interfaces.IMulticastTransport}\n-        @see: U{http://twistedmatrix.com/documents/current/core/howto/udp.html}\n-        \"\"\"\n-\n-\n-\n-class IReactorSocket(Interface):\n-    \"\"\"\n-    Methods which allow a reactor to use externally created sockets.\n-\n-    For example, to use C{adoptStreamPort} to implement behavior equivalent\n-    to that of L{IReactorTCP.listenTCP}, you might write code like this::\n-\n-        from socket import SOMAXCONN, AF_INET, SOCK_STREAM, socket\n-        portSocket = socket(AF_INET, SOCK_STREAM)\n-        # Set FD_CLOEXEC on port, left as an exercise.  Then make it into a\n-        # non-blocking listening port:\n-        portSocket.setblocking(False)\n-        portSocket.bind(('192.168.1.2', 12345))\n-        portSocket.listen(SOMAXCONN)\n-\n-        # Now have the reactor use it as a TCP port\n-        port = reactor.adoptStreamPort(\n-            portSocket.fileno(), AF_INET, YourFactory())\n-\n-        # portSocket itself is no longer necessary, and needs to be cleaned\n-        # up by us.\n-        portSocket.close()\n-\n-        # Whenever the server is no longer needed, stop it as usual.\n-        stoppedDeferred = port.stopListening()\n-\n-    Another potential use is to inherit a listening descriptor from a parent\n-    process (for example, systemd or launchd), or to receive one over a UNIX\n-    domain socket.\n-\n-    Some plans for extending this interface exist.  See:\n-\n-        - U{http://twistedmatrix.com/trac/ticket/5570}: established connections\n-        - U{http://twistedmatrix.com/trac/ticket/5573}: AF_UNIX ports\n-        - U{http://twistedmatrix.com/trac/ticket/5574}: SOCK_DGRAM sockets\n-    \"\"\"\n-\n-    def adoptStreamPort(fileDescriptor, addressFamily, factory):\n-        \"\"\"\n-        Add an existing listening I{SOCK_STREAM} socket to the reactor to\n-        monitor for new connections to accept and handle.\n-\n-        @param fileDescriptor: A file descriptor associated with a socket which\n-            is already bound to an address and marked as listening.  The socket\n-            must be set non-blocking.  Any additional flags (for example,\n-            close-on-exec) must also be set by application code.  Application\n-            code is responsible for closing the file descriptor, which may be\n-            done as soon as C{adoptStreamPort} returns.\n-        @type fileDescriptor: C{int}\n-\n-        @param addressFamily: The address family (or I{domain}) of the socket.\n-            For example, L{socket.AF_INET6}.\n-\n-        @param factory: A L{ServerFactory} instance to use to create new\n-            protocols to handle connections accepted via this socket.\n-\n-        @return: An object providing L{IListeningPort}.\n-\n-        @raise UnsupportedAddressFamily: If the given address family is not\n-            supported by this reactor, or not supported with the given socket\n-            type.\n-\n-        @raise UnsupportedSocketType: If the given socket type is not supported\n-            by this reactor, or not supported with the given socket type.\n-        \"\"\"\n-\n-\n-    def adoptStreamConnection(fileDescriptor, addressFamily, factory):\n-        \"\"\"\n-        Add an existing connected I{SOCK_STREAM} socket to the reactor to\n-        monitor for data.\n-\n-        Note that the given factory won't have its C{startFactory} and\n-        C{stopFactory} methods called, as there is no sensible time to call\n-        them in this situation.\n-\n-        @param fileDescriptor: A file descriptor associated with a socket which\n-            is already connected.  The socket must be set non-blocking.  Any\n-            additional flags (for example, close-on-exec) must also be set by\n-            application code.  Application code is responsible for closing the\n-            file descriptor, which may be done as soon as\n-            C{adoptStreamConnection} returns.\n-        @type fileDescriptor: C{int}\n-\n-        @param addressFamily: The address family (or I{domain}) of the socket.\n-            For example, L{socket.AF_INET6}.\n-\n-        @param factory: A L{ServerFactory} instance to use to create a new\n-            protocol to handle the connection via this socket.\n-\n-        @raise UnsupportedAddressFamily: If the given address family is not\n-            supported by this reactor, or not supported with the given socket\n-            type.\n-\n-        @raise UnsupportedSocketType: If the given socket type is not supported\n-            by this reactor, or not supported with the given socket type.\n-        \"\"\"\n-\n-\n-\n-class IReactorProcess(Interface):\n-\n-    def spawnProcess(processProtocol, executable, args=(), env={}, path=None,\n-                     uid=None, gid=None, usePTY=0, childFDs=None):\n-        \"\"\"\n-        Spawn a process, with a process protocol.\n-\n-        @type processProtocol: L{IProcessProtocol} provider\n-        @param processProtocol: An object which will be notified of all\n-            events related to the created process.\n-\n-        @param executable: the file name to spawn - the full path should be\n-                           used.\n-\n-        @param args: the command line arguments to pass to the process; a\n-                     sequence of strings. The first string should be the\n-                     executable's name.\n-\n-        @type env: a C{dict} mapping C{str} to C{str}, or C{None}.\n-        @param env: the environment variables to pass to the child process. The\n-                    resulting behavior varies between platforms. If\n-                      - C{env} is not set:\n-                        - On POSIX: pass an empty environment.\n-                        - On Windows: pass C{os.environ}.\n-                      - C{env} is C{None}:\n-                        - On POSIX: pass C{os.environ}.\n-                        - On Windows: pass C{os.environ}.\n-                      - C{env} is a C{dict}:\n-                        - On POSIX: pass the key/value pairs in C{env} as the\n-                          complete environment.\n-                        - On Windows: update C{os.environ} with the key/value\n-                          pairs in the C{dict} before passing it. As a\n-                          consequence of U{bug #1640\n-                          <http://twistedmatrix.com/trac/ticket/1640>}, passing\n-                          keys with empty values in an effort to unset\n-                          environment variables I{won't} unset them.\n-\n-        @param path: the path to run the subprocess in - defaults to the\n-                     current directory.\n-\n-        @param uid: user ID to run the subprocess as. (Only available on\n-                    POSIX systems.)\n-\n-        @param gid: group ID to run the subprocess as. (Only available on\n-                    POSIX systems.)\n-\n-        @param usePTY: if true, run this process in a pseudo-terminal.\n-                       optionally a tuple of C{(masterfd, slavefd, ttyname)},\n-                       in which case use those file descriptors.\n-                       (Not available on all systems.)\n-\n-        @param childFDs: A dictionary mapping file descriptors in the new child\n-                         process to an integer or to the string 'r' or 'w'.\n-\n-                         If the value is an integer, it specifies a file\n-                         descriptor in the parent process which will be mapped\n-                         to a file descriptor (specified by the key) in the\n-                         child process.  This is useful for things like inetd\n-                         and shell-like file redirection.\n-\n-                         If it is the string 'r', a pipe will be created and\n-                         attached to the child at that file descriptor: the\n-                         child will be able to write to that file descriptor\n-                         and the parent will receive read notification via the\n-                         L{IProcessProtocol.childDataReceived} callback.  This\n-                         is useful for the child's stdout and stderr.\n-\n-                         If it is the string 'w', similar setup to the previous\n-                         case will occur, with the pipe being readable by the\n-                         child instead of writeable.  The parent process can\n-                         write to that file descriptor using\n-                         L{IProcessTransport.writeToChild}.  This is useful for\n-                         the child's stdin.\n-\n-                         If childFDs is not passed, the default behaviour is to\n-                         use a mapping that opens the usual stdin/stdout/stderr\n-                         pipes.\n-\n-        @see: L{twisted.internet.protocol.ProcessProtocol}\n-\n-        @return: An object which provides L{IProcessTransport}.\n-\n-        @raise OSError: Raised with errno C{EAGAIN} or C{ENOMEM} if there are\n-                        insufficient system resources to create a new process.\n-        \"\"\"\n-\n-class IReactorTime(Interface):\n-    \"\"\"\n-    Time methods that a Reactor should implement.\n-    \"\"\"\n-\n-    def seconds():\n-        \"\"\"\n-        Get the current time in seconds.\n-\n-        @return: A number-like object of some sort.\n-        \"\"\"\n-\n-\n-    def callLater(delay, callable, *args, **kw):\n-        \"\"\"\n-        Call a function later.\n-\n-        @type delay:  C{float}\n-        @param delay: the number of seconds to wait.\n-\n-        @param callable: the callable object to call later.\n-\n-        @param args: the arguments to call it with.\n-\n-        @param kw: the keyword arguments to call it with.\n-\n-        @return: An object which provides L{IDelayedCall} and can be used to\n-                 cancel the scheduled call, by calling its C{cancel()} method.\n-                 It also may be rescheduled by calling its C{delay()} or\n-                 C{reset()} methods.\n-        \"\"\"\n-\n-\n-    def getDelayedCalls():\n-        \"\"\"\n-        Retrieve all currently scheduled delayed calls.\n-\n-        @return: A tuple of all L{IDelayedCall} providers representing all\n-                 currently scheduled calls. This is everything that has been\n-                 returned by C{callLater} but not yet called or canceled.\n-        \"\"\"\n-\n-\n-class IDelayedCall(Interface):\n-    \"\"\"\n-    A scheduled call.\n-\n-    There are probably other useful methods we can add to this interface;\n-    suggestions are welcome.\n-    \"\"\"\n-\n-    def getTime():\n-        \"\"\"\n-        Get time when delayed call will happen.\n-\n-        @return: time in seconds since epoch (a float).\n-        \"\"\"\n-\n-    def cancel():\n-        \"\"\"\n-        Cancel the scheduled call.\n-\n-        @raises twisted.internet.error.AlreadyCalled: if the call has already\n-            happened.\n-        @raises twisted.internet.error.AlreadyCancelled: if the call has already\n-            been cancelled.\n-        \"\"\"\n-\n-    def delay(secondsLater):\n-        \"\"\"\n-        Delay the scheduled call.\n-\n-        @param secondsLater: how many seconds from its current firing time to delay\n-\n-        @raises twisted.internet.error.AlreadyCalled: if the call has already\n-            happened.\n-        @raises twisted.internet.error.AlreadyCancelled: if the call has already\n-            been cancelled.\n-        \"\"\"\n-\n-    def reset(secondsFromNow):\n-        \"\"\"\n-        Reset the scheduled call's timer.\n-\n-        @param secondsFromNow: how many seconds from now it should fire,\n-            equivalent to C{.cancel()} and then doing another\n-            C{reactor.callLater(secondsLater, ...)}\n-\n-        @raises twisted.internet.error.AlreadyCalled: if the call has already\n-            happened.\n-        @raises twisted.internet.error.AlreadyCancelled: if the call has already\n-            been cancelled.\n-        \"\"\"\n-\n-    def active():\n-        \"\"\"\n-        @return: True if this call is still active, False if it has been\n-                 called or cancelled.\n-        \"\"\"\n-\n-class IReactorThreads(Interface):\n-    \"\"\"\n-    Dispatch methods to be run in threads.\n-\n-    Internally, this should use a thread pool and dispatch methods to them.\n-    \"\"\"\n-\n-    def getThreadPool():\n-        \"\"\"\n-        Return the threadpool used by L{callInThread}.  Create it first if\n-        necessary.\n-\n-        @rtype: L{twisted.python.threadpool.ThreadPool}\n-        \"\"\"\n-\n-\n-    def callInThread(callable, *args, **kwargs):\n-        \"\"\"\n-        Run the callable object in a separate thread.\n-        \"\"\"\n-\n-\n-    def callFromThread(callable, *args, **kw):\n-        \"\"\"\n-        Cause a function to be executed by the reactor thread.\n-\n-        Use this method when you want to run a function in the reactor's thread\n-        from another thread.  Calling L{callFromThread} should wake up the main\n-        thread (where L{reactor.run()<reactor.run>} is executing) and run the\n-        given callable in that thread.\n-\n-        If you're writing a multi-threaded application the C{callable} may need\n-        to be thread safe, but this method doesn't require it as such. If you\n-        want to call a function in the next mainloop iteration, but you're in\n-        the same thread, use L{callLater} with a delay of 0.\n-        \"\"\"\n-\n-\n-    def suggestThreadPoolSize(size):\n-        \"\"\"\n-        Suggest the size of the internal threadpool used to dispatch functions\n-        passed to L{callInThread}.\n-        \"\"\"\n-\n-\n-class IReactorCore(Interface):\n-    \"\"\"\n-    Core methods that a Reactor must implement.\n-    \"\"\"\n-\n-    running = Attribute(\n-        \"A C{bool} which is C{True} from I{during startup} to \"\n-        \"I{during shutdown} and C{False} the rest of the time.\")\n-\n-\n-    def resolve(name, timeout=10):\n-        \"\"\"\n-        Return a L{twisted.internet.defer.Deferred} that will resolve a hostname.\n-        \"\"\"\n-\n-    def run():\n-        \"\"\"\n-        Fire 'startup' System Events, move the reactor to the 'running'\n-        state, then run the main loop until it is stopped with C{stop()} or\n-        C{crash()}.\n-        \"\"\"\n-\n-    def stop():\n-        \"\"\"\n-        Fire 'shutdown' System Events, which will move the reactor to the\n-        'stopped' state and cause C{reactor.run()} to exit.\n-        \"\"\"\n-\n-    def crash():\n-        \"\"\"\n-        Stop the main loop *immediately*, without firing any system events.\n-\n-        This is named as it is because this is an extremely \"rude\" thing to do;\n-        it is possible to lose data and put your system in an inconsistent\n-        state by calling this.  However, it is necessary, as sometimes a system\n-        can become wedged in a pre-shutdown call.\n-        \"\"\"\n-\n-    def iterate(delay=0):\n-        \"\"\"\n-        Run the main loop's I/O polling function for a period of time.\n-\n-        This is most useful in applications where the UI is being drawn \"as\n-        fast as possible\", such as games. All pending L{IDelayedCall}s will\n-        be called.\n-\n-        The reactor must have been started (via the C{run()} method) prior to\n-        any invocations of this method.  It must also be stopped manually\n-        after the last call to this method (via the C{stop()} method).  This\n-        method is not re-entrant: you must not call it recursively; in\n-        particular, you must not call it while the reactor is running.\n-        \"\"\"\n-\n-    def fireSystemEvent(eventType):\n-        \"\"\"\n-        Fire a system-wide event.\n-\n-        System-wide events are things like 'startup', 'shutdown', and\n-        'persist'.\n-        \"\"\"\n-\n-    def addSystemEventTrigger(phase, eventType, callable, *args, **kw):\n-        \"\"\"\n-        Add a function to be called when a system event occurs.\n-\n-        Each \"system event\" in Twisted, such as 'startup', 'shutdown', and\n-        'persist', has 3 phases: 'before', 'during', and 'after' (in that\n-        order, of course).  These events will be fired internally by the\n-        Reactor.\n-\n-        An implementor of this interface must only implement those events\n-        described here.\n-\n-        Callbacks registered for the \"before\" phase may return either None or a\n-        Deferred.  The \"during\" phase will not execute until all of the\n-        Deferreds from the \"before\" phase have fired.\n-\n-        Once the \"during\" phase is running, all of the remaining triggers must\n-        execute; their return values must be ignored.\n-\n-        @param phase: a time to call the event -- either the string 'before',\n-                      'after', or 'during', describing when to call it\n-                      relative to the event's execution.\n-\n-        @param eventType: this is a string describing the type of event.\n-\n-        @param callable: the object to call before shutdown.\n-\n-        @param args: the arguments to call it with.\n-\n-        @param kw: the keyword arguments to call it with.\n-\n-        @return: an ID that can be used to remove this call with\n-                 removeSystemEventTrigger.\n-        \"\"\"\n-\n-    def removeSystemEventTrigger(triggerID):\n-        \"\"\"\n-        Removes a trigger added with addSystemEventTrigger.\n-\n-        @param triggerID: a value returned from addSystemEventTrigger.\n-\n-        @raise KeyError: If there is no system event trigger for the given\n-            C{triggerID}.\n-\n-        @raise ValueError: If there is no system event trigger for the given\n-            C{triggerID}.\n-\n-        @raise TypeError: If there is no system event trigger for the given\n-            C{triggerID}.\n-        \"\"\"\n-\n-    def callWhenRunning(callable, *args, **kw):\n-        \"\"\"\n-        Call a function when the reactor is running.\n-\n-        If the reactor has not started, the callable will be scheduled\n-        to run when it does start. Otherwise, the callable will be invoked\n-        immediately.\n-\n-        @param callable: the callable object to call later.\n-\n-        @param args: the arguments to call it with.\n-\n-        @param kw: the keyword arguments to call it with.\n-\n-        @return: None if the callable was invoked, otherwise a system\n-                 event id for the scheduled call.\n-        \"\"\"\n-\n-\n-class IReactorPluggableResolver(Interface):\n-    \"\"\"\n-    A reactor with a pluggable name resolver interface.\n-    \"\"\"\n-\n-    def installResolver(resolver):\n-        \"\"\"\n-        Set the internal resolver to use to for name lookups.\n-\n-        @type resolver: An object implementing the L{IResolverSimple} interface\n-        @param resolver: The new resolver to use.\n-\n-        @return: The previously installed resolver.\n-        \"\"\"\n-\n-\n-class IReactorDaemonize(Interface):\n-    \"\"\"\n-    A reactor which provides hooks that need to be called before and after\n-    daemonization.\n-\n-    Notes:\n-       - This interface SHOULD NOT be called by applications.\n-       - This interface should only be implemented by reactors as a workaround\n-         (in particular, it's implemented currently only by kqueue()).\n-         For details please see the comments on ticket #1918.\n-    \"\"\"\n-\n-    def beforeDaemonize():\n-        \"\"\"\n-        Hook to be called immediately before daemonization. No reactor methods\n-        may be called until L{afterDaemonize} is called.\n-\n-        @return: C{None}.\n-        \"\"\"\n-\n-\n-    def afterDaemonize():\n-        \"\"\"\n-        Hook to be called immediately after daemonization. This may only be\n-        called after L{beforeDaemonize} had been called previously.\n-\n-        @return: C{None}.\n-        \"\"\"\n-\n-\n-\n-class IReactorFDSet(Interface):\n-    \"\"\"\n-    Implement me to be able to use L{IFileDescriptor} type resources.\n-\n-    This assumes that your main-loop uses UNIX-style numeric file descriptors\n-    (or at least similarly opaque IDs returned from a .fileno() method)\n-    \"\"\"\n-\n-    def addReader(reader):\n-        \"\"\"\n-        I add reader to the set of file descriptors to get read events for.\n-\n-        @param reader: An L{IReadDescriptor} provider that will be checked for\n-                       read events until it is removed from the reactor with\n-                       L{removeReader}.\n-\n-        @return: C{None}.\n-        \"\"\"\n-\n-    def addWriter(writer):\n-        \"\"\"\n-        I add writer to the set of file descriptors to get write events for.\n-\n-        @param writer: An L{IWriteDescriptor} provider that will be checked for\n-                       write events until it is removed from the reactor with\n-                       L{removeWriter}.\n-\n-        @return: C{None}.\n-        \"\"\"\n-\n-    def removeReader(reader):\n-        \"\"\"\n-        Removes an object previously added with L{addReader}.\n-\n-        @return: C{None}.\n-        \"\"\"\n-\n-    def removeWriter(writer):\n-        \"\"\"\n-        Removes an object previously added with L{addWriter}.\n-\n-        @return: C{None}.\n-        \"\"\"\n-\n-    def removeAll():\n-        \"\"\"\n-        Remove all readers and writers.\n-\n-        Should not remove reactor internal reactor connections (like a waker).\n-\n-        @return: A list of L{IReadDescriptor} and L{IWriteDescriptor} providers\n-                 which were removed.\n-        \"\"\"\n-\n-    def getReaders():\n-        \"\"\"\n-        Return the list of file descriptors currently monitored for input\n-        events by the reactor.\n-\n-        @return: the list of file descriptors monitored for input events.\n-        @rtype: C{list} of C{IReadDescriptor}\n-        \"\"\"\n-\n-    def getWriters():\n-        \"\"\"\n-        Return the list file descriptors currently monitored for output events\n-        by the reactor.\n-\n-        @return: the list of file descriptors monitored for output events.\n-        @rtype: C{list} of C{IWriteDescriptor}\n-        \"\"\"\n-\n-\n-class IListeningPort(Interface):\n-    \"\"\"\n-    A listening port.\n-    \"\"\"\n-\n-    def startListening():\n-        \"\"\"\n-        Start listening on this port.\n-\n-        @raise CannotListenError: If it cannot listen on this port (e.g., it is\n-                                  a TCP port and it cannot bind to the required\n-                                  port number).\n-        \"\"\"\n-\n-    def stopListening():\n-        \"\"\"\n-        Stop listening on this port.\n-\n-        If it does not complete immediately, will return Deferred that fires\n-        upon completion.\n-        \"\"\"\n-\n-    def getHost():\n-        \"\"\"\n-        Get the host that this port is listening for.\n-\n-        @return: An L{IAddress} provider.\n-        \"\"\"\n-\n-\n-class ILoggingContext(Interface):\n-    \"\"\"\n-    Give context information that will be used to log events generated by\n-    this item.\n-    \"\"\"\n-\n-    def logPrefix():\n-        \"\"\"\n-        @return: Prefix used during log formatting to indicate context.\n-        @rtype: C{str}\n-        \"\"\"\n-\n-\n-\n-class IFileDescriptor(ILoggingContext):\n-    \"\"\"\n-    An interface representing a UNIX-style numeric file descriptor.\n-    \"\"\"\n-\n-    def fileno():\n-        \"\"\"\n-        @raise: If the descriptor no longer has a valid file descriptor\n-            number associated with it.\n-\n-        @return: The platform-specified representation of a file descriptor\n-            number.  Or C{-1} if the descriptor no longer has a valid file\n-            descriptor number associated with it.  As long as the descriptor\n-            is valid, calls to this method on a particular instance must\n-            return the same value.\n-        \"\"\"\n-\n-\n-    def connectionLost(reason):\n-        \"\"\"\n-        Called when the connection was lost.\n-\n-        This is called when the connection on a selectable object has been\n-        lost.  It will be called whether the connection was closed explicitly,\n-        an exception occurred in an event handler, or the other end of the\n-        connection closed it first.\n-\n-        See also L{IHalfCloseableDescriptor} if your descriptor wants to be\n-        notified separately of the two halves of the connection being closed.\n-\n-        @param reason: A failure instance indicating the reason why the\n-                       connection was lost.  L{error.ConnectionLost} and\n-                       L{error.ConnectionDone} are of special note, but the\n-                       failure may be of other classes as well.\n-        \"\"\"\n-\n-\n-\n-class IReadDescriptor(IFileDescriptor):\n-    \"\"\"\n-    An L{IFileDescriptor} that can read.\n-\n-    This interface is generally used in conjunction with L{IReactorFDSet}.\n-    \"\"\"\n-\n-    def doRead():\n-        \"\"\"\n-        Some data is available for reading on your descriptor.\n-\n-        @return: If an error is encountered which causes the descriptor to\n-            no longer be valid, a L{Failure} should be returned.  Otherwise,\n-            C{None}.\n-        \"\"\"\n-\n-\n-class IWriteDescriptor(IFileDescriptor):\n-    \"\"\"\n-    An L{IFileDescriptor} that can write.\n-\n-    This interface is generally used in conjunction with L{IReactorFDSet}.\n-    \"\"\"\n-\n-    def doWrite():\n-        \"\"\"\n-        Some data can be written to your descriptor.\n-\n-        @return: If an error is encountered which causes the descriptor to\n-            no longer be valid, a L{Failure} should be returned.  Otherwise,\n-            C{None}.\n-        \"\"\"\n-\n-\n-class IReadWriteDescriptor(IReadDescriptor, IWriteDescriptor):\n-    \"\"\"\n-    An L{IFileDescriptor} that can both read and write.\n-    \"\"\"\n-\n-\n-class IHalfCloseableDescriptor(Interface):\n-    \"\"\"\n-    A descriptor that can be half-closed.\n-    \"\"\"\n-\n-    def writeConnectionLost(reason):\n-        \"\"\"\n-        Indicates write connection was lost.\n-        \"\"\"\n-\n-    def readConnectionLost(reason):\n-        \"\"\"\n-        Indicates read connection was lost.\n-        \"\"\"\n-\n-\n-class ISystemHandle(Interface):\n-    \"\"\"\n-    An object that wraps a networking OS-specific handle.\n-    \"\"\"\n-\n-    def getHandle():\n-        \"\"\"\n-        Return a system- and reactor-specific handle.\n-\n-        This might be a socket.socket() object, or some other type of\n-        object, depending on which reactor is being used. Use and\n-        manipulate at your own risk.\n-\n-        This might be used in cases where you want to set specific\n-        options not exposed by the Twisted APIs.\n-        \"\"\"\n-\n-\n-class IConsumer(Interface):\n-    \"\"\"\n-    A consumer consumes data from a producer.\n-    \"\"\"\n-\n-    def registerProducer(producer, streaming):\n-        \"\"\"\n-        Register to receive data from a producer.\n-\n-        This sets self to be a consumer for a producer.  When this object runs\n-        out of data (as when a send(2) call on a socket succeeds in moving the\n-        last data from a userspace buffer into a kernelspace buffer), it will\n-        ask the producer to resumeProducing().\n-\n-        For L{IPullProducer} providers, C{resumeProducing} will be called once\n-        each time data is required.\n-\n-        For L{IPushProducer} providers, C{pauseProducing} will be called\n-        whenever the write buffer fills up and C{resumeProducing} will only be\n-        called when it empties.\n-\n-        @type producer: L{IProducer} provider\n-\n-        @type streaming: C{bool}\n-        @param streaming: C{True} if C{producer} provides L{IPushProducer},\n-        C{False} if C{producer} provides L{IPullProducer}.\n-\n-        @raise RuntimeError: If a producer is already registered.\n-\n-        @return: C{None}\n-        \"\"\"\n-\n-\n-    def unregisterProducer():\n-        \"\"\"\n-        Stop consuming data from a producer, without disconnecting.\n-        \"\"\"\n-\n-\n-    def write(data):\n-        \"\"\"\n-        The producer will write data by calling this method.\n-\n-        The implementation must be non-blocking and perform whatever\n-        buffering is necessary.  If the producer has provided enough data\n-        for now and it is a L{IPushProducer}, the consumer may call its\n-        C{pauseProducing} method.\n-        \"\"\"\n-\n-\n-\n-class IProducer(Interface):\n-    \"\"\"\n-    A producer produces data for a consumer.\n-\n-    Typically producing is done by calling the write method of an class\n-    implementing L{IConsumer}.\n-    \"\"\"\n-\n-    def stopProducing():\n-        \"\"\"\n-        Stop producing data.\n-\n-        This tells a producer that its consumer has died, so it must stop\n-        producing data for good.\n-        \"\"\"\n-\n-\n-class IPushProducer(IProducer):\n-    \"\"\"\n-    A push producer, also known as a streaming producer is expected to\n-    produce (write to this consumer) data on a continuous basis, unless\n-    it has been paused. A paused push producer will resume producing\n-    after its resumeProducing() method is called.   For a push producer\n-    which is not pauseable, these functions may be noops.\n-    \"\"\"\n-\n-    def pauseProducing():\n-        \"\"\"\n-        Pause producing data.\n-\n-        Tells a producer that it has produced too much data to process for\n-        the time being, and to stop until resumeProducing() is called.\n-        \"\"\"\n-    def resumeProducing():\n-        \"\"\"\n-        Resume producing data.\n-\n-        This tells a producer to re-add itself to the main loop and produce\n-        more data for its consumer.\n-        \"\"\"\n-\n-class IPullProducer(IProducer):\n-    \"\"\"\n-    A pull producer, also known as a non-streaming producer, is\n-    expected to produce data each time resumeProducing() is called.\n-    \"\"\"\n-\n-    def resumeProducing():\n-        \"\"\"\n-        Produce data for the consumer a single time.\n-\n-        This tells a producer to produce data for the consumer once\n-        (not repeatedly, once only). Typically this will be done\n-        by calling the consumer's write() method a single time with\n-        produced data.\n-        \"\"\"\n-\n-class IProtocol(Interface):\n-\n-    def dataReceived(data):\n-        \"\"\"\n-        Called whenever data is received.\n-\n-        Use this method to translate to a higher-level message.  Usually, some\n-        callback will be made upon the receipt of each complete protocol\n-        message.\n-\n-        @param data: a string of indeterminate length.  Please keep in mind\n-            that you will probably need to buffer some data, as partial\n-            (or multiple) protocol messages may be received!  I recommend\n-            that unit tests for protocols call through to this method with\n-            differing chunk sizes, down to one byte at a time.\n-        \"\"\"\n-\n-    def connectionLost(reason):\n-        \"\"\"\n-        Called when the connection is shut down.\n-\n-        Clear any circular references here, and any external references\n-        to this Protocol.  The connection has been closed. The C{reason}\n-        Failure wraps a L{twisted.internet.error.ConnectionDone} or\n-        L{twisted.internet.error.ConnectionLost} instance (or a subclass\n-        of one of those).\n-\n-        @type reason: L{twisted.python.failure.Failure}\n-        \"\"\"\n-\n-    def makeConnection(transport):\n-        \"\"\"\n-        Make a connection to a transport and a server.\n-        \"\"\"\n-\n-    def connectionMade():\n-        \"\"\"\n-        Called when a connection is made.\n-\n-        This may be considered the initializer of the protocol, because\n-        it is called when the connection is completed.  For clients,\n-        this is called once the connection to the server has been\n-        established; for servers, this is called after an accept() call\n-        stops blocking and a socket has been received.  If you need to\n-        send any greeting or initial message, do it here.\n-        \"\"\"\n-\n-\n-class IProcessProtocol(Interface):\n-    \"\"\"\n-    Interface for process-related event handlers.\n-    \"\"\"\n-\n-    def makeConnection(process):\n-        \"\"\"\n-        Called when the process has been created.\n-\n-        @type process: L{IProcessTransport} provider\n-        @param process: An object representing the process which has been\n-            created and associated with this protocol.\n-        \"\"\"\n-\n-\n-    def childDataReceived(childFD, data):\n-        \"\"\"\n-        Called when data arrives from the child process.\n-\n-        @type childFD: C{int}\n-        @param childFD: The file descriptor from which the data was\n-            received.\n-\n-        @type data: C{str}\n-        @param data: The data read from the child's file descriptor.\n-        \"\"\"\n-\n-\n-    def childConnectionLost(childFD):\n-        \"\"\"\n-        Called when a file descriptor associated with the child process is\n-        closed.\n-\n-        @type childFD: C{int}\n-        @param childFD: The file descriptor which was closed.\n-        \"\"\"\n-\n-\n-    def processExited(reason):\n-        \"\"\"\n-        Called when the child process exits.\n-\n-        @type reason: L{twisted.python.failure.Failure}\n-        @param reason: A failure giving the reason the child process\n-            terminated.  The type of exception for this failure is either\n-            L{twisted.internet.error.ProcessDone} or\n-            L{twisted.internet.error.ProcessTerminated}.\n-\n-        @since: 8.2\n-        \"\"\"\n-\n-\n-    def processEnded(reason):\n-        \"\"\"\n-        Called when the child process exits and all file descriptors associated\n-        with it have been closed.\n-\n-        @type reason: L{twisted.python.failure.Failure}\n-        @param reason: A failure giving the reason the child process\n-            terminated.  The type of exception for this failure is either\n-            L{twisted.internet.error.ProcessDone} or\n-            L{twisted.internet.error.ProcessTerminated}.\n-        \"\"\"\n-\n-\n-\n-class IHalfCloseableProtocol(Interface):\n-    \"\"\"\n-    Implemented to indicate they want notification of half-closes.\n-\n-    TCP supports the notion of half-closing the connection, e.g.\n-    closing the write side but still not stopping reading. A protocol\n-    that implements this interface will be notified of such events,\n-    instead of having connectionLost called.\n-    \"\"\"\n-\n-    def readConnectionLost():\n-        \"\"\"\n-        Notification of the read connection being closed.\n-\n-        This indicates peer did half-close of write side. It is now\n-        the responsibility of the this protocol to call\n-        loseConnection().  In addition, the protocol MUST make sure a\n-        reference to it still exists (i.e. by doing a callLater with\n-        one of its methods, etc.)  as the reactor will only have a\n-        reference to it if it is writing.\n-\n-        If the protocol does not do so, it might get garbage collected\n-        without the connectionLost method ever being called.\n-        \"\"\"\n-\n-    def writeConnectionLost():\n-        \"\"\"\n-        Notification of the write connection being closed.\n-\n-        This will never be called for TCP connections as TCP does not\n-        support notification of this type of half-close.\n-        \"\"\"\n-\n-\n-\n-class IFileDescriptorReceiver(Interface):\n-    \"\"\"\n-    Protocols may implement L{IFileDescriptorReceiver} to receive file\n-    descriptors sent to them.  This is useful in conjunction with\n-    L{IUNIXTransport}, which allows file descriptors to be sent between\n-    processes on a single host.\n-    \"\"\"\n-    def fileDescriptorReceived(descriptor):\n-        \"\"\"\n-        Called when a file descriptor is received over the connection.\n-\n-        @param descriptor: The descriptor which was received.\n-        @type descriptor: C{int}\n-\n-        @return: C{None}\n-        \"\"\"\n-\n-\n-\n-class IProtocolFactory(Interface):\n-    \"\"\"\n-    Interface for protocol factories.\n-    \"\"\"\n-\n-    def buildProtocol(addr):\n-        \"\"\"\n-        Called when a connection has been established to addr.\n-\n-        If None is returned, the connection is assumed to have been refused,\n-        and the Port will close the connection.\n-\n-        @type addr: (host, port)\n-        @param addr: The address of the newly-established connection\n-\n-        @return: None if the connection was refused, otherwise an object\n-                 providing L{IProtocol}.\n-        \"\"\"\n-\n-    def doStart():\n-        \"\"\"\n-        Called every time this is connected to a Port or Connector.\n-        \"\"\"\n-\n-    def doStop():\n-        \"\"\"\n-        Called every time this is unconnected from a Port or Connector.\n-        \"\"\"\n-\n-\n-class ITransport(Interface):\n-    \"\"\"\n-    I am a transport for bytes.\n-\n-    I represent (and wrap) the physical connection and synchronicity\n-    of the framework which is talking to the network.  I make no\n-    representations about whether calls to me will happen immediately\n-    or require returning to a control loop, or whether they will happen\n-    in the same or another thread.  Consider methods of this class\n-    (aside from getPeer) to be 'thrown over the wall', to happen at some\n-    indeterminate time.\n-    \"\"\"\n-\n-    def write(data):\n-        \"\"\"\n-        Write some data to the physical connection, in sequence, in a\n-        non-blocking fashion.\n-\n-        If possible, make sure that it is all written.  No data will\n-        ever be lost, although (obviously) the connection may be closed\n-        before it all gets through.\n-        \"\"\"\n-\n-    def writeSequence(data):\n-        \"\"\"\n-        Write a list of strings to the physical connection.\n-\n-        If possible, make sure that all of the data is written to\n-        the socket at once, without first copying it all into a\n-        single string.\n-        \"\"\"\n-\n-    def loseConnection():\n-        \"\"\"\n-        Close my connection, after writing all pending data.\n-\n-        Note that if there is a registered producer on a transport it\n-        will not be closed until the producer has been unregistered.\n-        \"\"\"\n-\n-    def getPeer():\n-        \"\"\"\n-        Get the remote address of this connection.\n-\n-        Treat this method with caution.  It is the unfortunate result of the\n-        CGI and Jabber standards, but should not be considered reliable for\n-        the usual host of reasons; port forwarding, proxying, firewalls, IP\n-        masquerading, etc.\n-\n-        @return: An L{IAddress} provider.\n-        \"\"\"\n-\n-    def getHost():\n-        \"\"\"\n-        Similar to getPeer, but returns an address describing this side of the\n-        connection.\n-\n-        @return: An L{IAddress} provider.\n-        \"\"\"\n-\n-\n-class ITCPTransport(ITransport):\n-    \"\"\"\n-    A TCP based transport.\n-    \"\"\"\n-\n-    def loseWriteConnection():\n-        \"\"\"\n-        Half-close the write side of a TCP connection.\n-\n-        If the protocol instance this is attached to provides\n-        IHalfCloseableProtocol, it will get notified when the operation is\n-        done. When closing write connection, as with loseConnection this will\n-        only happen when buffer has emptied and there is no registered\n-        producer.\n-        \"\"\"\n-\n-\n-    def abortConnection():\n-        \"\"\"\n-        Close the connection abruptly.\n-\n-        Discards any buffered data, stops any registered producer,\n-        and, if possible, notifies the other end of the unclean\n-        closure.\n-\n-        @since: 11.1\n-        \"\"\"\n-\n-\n-    def getTcpNoDelay():\n-        \"\"\"\n-        Return if C{TCP_NODELAY} is enabled.\n-        \"\"\"\n-\n-    def setTcpNoDelay(enabled):\n-        \"\"\"\n-        Enable/disable C{TCP_NODELAY}.\n-\n-        Enabling C{TCP_NODELAY} turns off Nagle's algorithm. Small packets are\n-        sent sooner, possibly at the expense of overall throughput.\n-        \"\"\"\n-\n-    def getTcpKeepAlive():\n-        \"\"\"\n-        Return if C{SO_KEEPALIVE} is enabled.\n-        \"\"\"\n-\n-    def setTcpKeepAlive(enabled):\n-        \"\"\"\n-        Enable/disable C{SO_KEEPALIVE}.\n-\n-        Enabling C{SO_KEEPALIVE} sends packets periodically when the connection\n-        is otherwise idle, usually once every two hours. They are intended\n-        to allow detection of lost peers in a non-infinite amount of time.\n-        \"\"\"\n-\n-    def getHost():\n-        \"\"\"\n-        Returns L{IPv4Address} or L{IPv6Address}.\n-        \"\"\"\n-\n-    def getPeer():\n-        \"\"\"\n-        Returns L{IPv4Address} or L{IPv6Address}.\n-        \"\"\"\n-\n-\n-\n-class IUNIXTransport(ITransport):\n-    \"\"\"\n-    Transport for stream-oriented unix domain connections.\n-    \"\"\"\n-    def sendFileDescriptor(descriptor):\n-        \"\"\"\n-        Send a duplicate of this (file, socket, pipe, etc) descriptor to the\n-        other end of this connection.\n-\n-        The send is non-blocking and will be queued if it cannot be performed\n-        immediately.  The send will be processed in order with respect to other\n-        C{sendFileDescriptor} calls on this transport, but not necessarily with\n-        respect to C{write} calls on this transport.  The send can only be\n-        processed if there are also bytes in the normal connection-oriented send\n-        buffer (ie, you must call C{write} at least as many times as you call\n-        C{sendFileDescriptor}).\n-\n-        @param descriptor: An C{int} giving a valid file descriptor in this\n-            process.  Note that a I{file descriptor} may actually refer to a\n-            socket, a pipe, or anything else POSIX tries to treat in the same\n-            way as a file.\n-\n-        @return: C{None}\n-        \"\"\"\n-\n-\n-\n-class ITLSTransport(ITCPTransport):\n-    \"\"\"\n-    A TCP transport that supports switching to TLS midstream.\n-\n-    Once TLS mode is started the transport will implement L{ISSLTransport}.\n-    \"\"\"\n-\n-    def startTLS(contextFactory):\n-        \"\"\"\n-        Initiate TLS negotiation.\n-\n-        @param contextFactory: A context factory (see L{ssl.py<twisted.internet.ssl>})\n-        \"\"\"\n-\n-class ISSLTransport(ITCPTransport):\n-    \"\"\"\n-    A SSL/TLS based transport.\n-    \"\"\"\n-\n-    def getPeerCertificate():\n-        \"\"\"\n-        Return an object with the peer's certificate info.\n-        \"\"\"\n-\n-\n-class IProcessTransport(ITransport):\n-    \"\"\"\n-    A process transport.\n-    \"\"\"\n-\n-    pid = Attribute(\n-        \"From before L{IProcessProtocol.makeConnection} is called to before \"\n-        \"L{IProcessProtocol.processEnded} is called, C{pid} is an L{int} \"\n-        \"giving the platform process ID of this process.  C{pid} is L{None} \"\n-        \"at all other times.\")\n-\n-    def closeStdin():\n-        \"\"\"\n-        Close stdin after all data has been written out.\n-        \"\"\"\n-\n-    def closeStdout():\n-        \"\"\"\n-        Close stdout.\n-        \"\"\"\n-\n-    def closeStderr():\n-        \"\"\"\n-        Close stderr.\n-        \"\"\"\n-\n-    def closeChildFD(descriptor):\n-        \"\"\"\n-        Close a file descriptor which is connected to the child process, identified\n-        by its FD in the child process.\n-        \"\"\"\n-\n-    def writeToChild(childFD, data):\n-        \"\"\"\n-        Similar to L{ITransport.write} but also allows the file descriptor in\n-        the child process which will receive the bytes to be specified.\n-\n-        @type childFD: C{int}\n-        @param childFD: The file descriptor to which to write.\n-\n-        @type data: C{str}\n-        @param data: The bytes to write.\n-\n-        @return: C{None}\n-\n-        @raise KeyError: If C{childFD} is not a file descriptor that was mapped\n-            in the child when L{IReactorProcess.spawnProcess} was used to create\n-            it.\n-        \"\"\"\n-\n-    def loseConnection():\n-        \"\"\"\n-        Close stdin, stderr and stdout.\n-        \"\"\"\n-\n-    def signalProcess(signalID):\n-        \"\"\"\n-        Send a signal to the process.\n-\n-        @param signalID: can be\n-          - one of C{\"KILL\"}, C{\"TERM\"}, or C{\"INT\"}.\n-              These will be implemented in a\n-              cross-platform manner, and so should be used\n-              if possible.\n-          - an integer, where it represents a POSIX\n-              signal ID.\n-\n-        @raise twisted.internet.error.ProcessExitedAlready: If the process has\n-            already exited.\n-        @raise OSError: If the C{os.kill} call fails with an errno different\n-            from C{ESRCH}.\n-        \"\"\"\n-\n-\n-class IServiceCollection(Interface):\n-    \"\"\"\n-    An object which provides access to a collection of services.\n-    \"\"\"\n-\n-    def getServiceNamed(serviceName):\n-        \"\"\"\n-        Retrieve the named service from this application.\n-\n-        Raise a C{KeyError} if there is no such service name.\n-        \"\"\"\n-\n-    def addService(service):\n-        \"\"\"\n-        Add a service to this collection.\n-        \"\"\"\n-\n-    def removeService(service):\n-        \"\"\"\n-        Remove a service from this collection.\n-        \"\"\"\n-\n-\n-class IUDPTransport(Interface):\n-    \"\"\"\n-    Transport for UDP DatagramProtocols.\n-    \"\"\"\n-\n-    def write(packet, addr=None):\n-        \"\"\"\n-        Write packet to given address.\n-\n-        @param addr: a tuple of (ip, port). For connected transports must\n-                     be the address the transport is connected to, or None.\n-                     In non-connected mode this is mandatory.\n-\n-        @raise twisted.internet.error.MessageLengthError: C{packet} was too\n-        long.\n-        \"\"\"\n-\n-    def connect(host, port):\n-        \"\"\"\n-        Connect the transport to an address.\n-\n-        This changes it to connected mode. Datagrams can only be sent to\n-        this address, and will only be received from this address. In addition\n-        the protocol's connectionRefused method might get called if destination\n-        is not receiving datagrams.\n-\n-        @param host: an IP address, not a domain name ('127.0.0.1', not 'localhost')\n-        @param port: port to connect to.\n-        \"\"\"\n-\n-    def getHost():\n-        \"\"\"\n-        Returns L{IPv4Address}.\n-        \"\"\"\n-\n-    def stopListening():\n-        \"\"\"\n-        Stop listening on this port.\n-\n-        If it does not complete immediately, will return L{Deferred} that fires\n-        upon completion.\n-        \"\"\"\n-\n-\n-\n-class IUNIXDatagramTransport(Interface):\n-    \"\"\"\n-    Transport for UDP PacketProtocols.\n-    \"\"\"\n-\n-    def write(packet, address):\n-        \"\"\"\n-        Write packet to given address.\n-        \"\"\"\n-\n-    def getHost():\n-        \"\"\"\n-        Returns L{UNIXAddress}.\n-        \"\"\"\n-\n-\n-class IUNIXDatagramConnectedTransport(Interface):\n-    \"\"\"\n-    Transport for UDP ConnectedPacketProtocols.\n-    \"\"\"\n-\n-    def write(packet):\n-        \"\"\"\n-        Write packet to address we are connected to.\n-        \"\"\"\n-\n-    def getHost():\n-        \"\"\"\n-        Returns L{UNIXAddress}.\n-        \"\"\"\n-\n-    def getPeer():\n-        \"\"\"\n-        Returns L{UNIXAddress}.\n-        \"\"\"\n-\n-\n-class IMulticastTransport(Interface):\n-    \"\"\"\n-    Additional functionality for multicast UDP.\n-    \"\"\"\n-\n-    def getOutgoingInterface():\n-        \"\"\"\n-        Return interface of outgoing multicast packets.\n-        \"\"\"\n-\n-    def setOutgoingInterface(addr):\n-        \"\"\"\n-        Set interface for outgoing multicast packets.\n-\n-        Returns Deferred of success.\n-        \"\"\"\n-\n-    def getLoopbackMode():\n-        \"\"\"\n-        Return if loopback mode is enabled.\n-        \"\"\"\n-\n-    def setLoopbackMode(mode):\n-        \"\"\"\n-        Set if loopback mode is enabled.\n-        \"\"\"\n-\n-    def getTTL():\n-        \"\"\"\n-        Get time to live for multicast packets.\n-        \"\"\"\n-\n-    def setTTL(ttl):\n-        \"\"\"\n-        Set time to live on multicast packets.\n-        \"\"\"\n-\n-    def joinGroup(addr, interface=\"\"):\n-        \"\"\"\n-        Join a multicast group. Returns L{Deferred} of success or failure.\n-\n-        If an error occurs, the returned L{Deferred} will fail with\n-        L{error.MulticastJoinError}.\n-        \"\"\"\n-\n-    def leaveGroup(addr, interface=\"\"):\n-        \"\"\"\n-        Leave multicast group, return L{Deferred} of success.\n-        \"\"\"\n-\n-\n-class IStreamClientEndpoint(Interface):\n-    \"\"\"\n-    A stream client endpoint is a place that L{ClientFactory} can connect to.\n-    For example, a remote TCP host/port pair would be a TCP client endpoint.\n-\n-    @since: 10.1\n-    \"\"\"\n-\n-    def connect(protocolFactory):\n-        \"\"\"\n-        Connect the C{protocolFactory} to the location specified by this\n-        L{IStreamClientEndpoint} provider.\n-\n-        @param protocolFactory: A provider of L{IProtocolFactory}\n-        @return: A L{Deferred} that results in an L{IProtocol} upon successful\n-            connection otherwise a L{ConnectError}\n-        \"\"\"\n-\n-\n-\n-class IStreamServerEndpoint(Interface):\n-    \"\"\"\n-    A stream server endpoint is a place that a L{Factory} can listen for\n-    incoming connections.\n-\n-    @since: 10.1\n-    \"\"\"\n-\n-    def listen(protocolFactory):\n-        \"\"\"\n-        Listen with C{protocolFactory} at the location specified by this\n-        L{IStreamServerEndpoint} provider.\n-\n-        @param protocolFactory: A provider of L{IProtocolFactory}\n-        @return: A L{Deferred} that results in an L{IListeningPort} or an\n-            L{CannotListenError}\n-        \"\"\"\n-\n-\n-\n-class IStreamServerEndpointStringParser(Interface):\n-    \"\"\"\n-    An L{IStreamServerEndpointStringParser} is like an\n-    L{IStreamClientEndpointStringParser}, except for L{IStreamServerEndpoint}s\n-    instead of clients.  It integrates with L{endpoints.serverFromString} in\n-    much the same way.\n-    \"\"\"\n-\n-    prefix = Attribute(\n-        \"\"\"\n-        @see: L{IStreamClientEndpointStringParser.prefix}\n-        \"\"\"\n-    )\n-\n-\n-    def parseStreamServer(reactor, *args, **kwargs):\n-        \"\"\"\n-        Parse a stream server endpoint from a reactor and string-only arguments\n-        and keyword arguments.\n-\n-        @see: L{IStreamClientEndpointStringParser.parseStreamClient}\n-\n-        @return: a stream server endpoint\n-        @rtype: L{IStreamServerEndpoint}\n-        \"\"\"\n-\n-\n-\n-class IStreamClientEndpointStringParser(Interface):\n-    \"\"\"\n-    An L{IStreamClientEndpointStringParser} is a parser which can convert\n-    a set of string C{*args} and C{**kwargs} into an L{IStreamClientEndpoint}\n-    provider.\n-\n-    This interface is really only useful in the context of the plugin system\n-    for L{endpoints.clientFromString}.  See the document entitled \"I{The\n-    Twisted Plugin System}\" for more details on how to write a plugin.\n-\n-    If you place an L{IStreamClientEndpointStringParser} plugin in the\n-    C{twisted.plugins} package, that plugin's C{parseStreamClient} method will\n-    be used to produce endpoints for any description string that begins with\n-    the result of that L{IStreamClientEndpointStringParser}'s prefix attribute.\n-    \"\"\"\n-\n-    prefix = Attribute(\n-        \"\"\"\n-        A C{str}, the description prefix to respond to.  For example, an\n-        L{IStreamClientEndpointStringParser} plugin which had C{\"foo\"} for its\n-        C{prefix} attribute would be called for endpoint descriptions like\n-        C{\"foo:bar:baz\"} or C{\"foo:\"}.\n-        \"\"\"\n-    )\n-\n-\n-    def parseStreamClient(*args, **kwargs):\n-        \"\"\"\n-        This method is invoked by L{endpoints.clientFromString}, if the type of\n-        endpoint matches the return value from this\n-        L{IStreamClientEndpointStringParser}'s C{prefix} method.\n-\n-        @param args: The string arguments, minus the endpoint type, in the\n-            endpoint description string, parsed according to the rules\n-            described in L{endpoints.quoteStringArgument}.  For example, if the\n-            description were C{\"my-type:foo:bar:baz=qux\"}, C{args} would be\n-            C{('foo','bar')}\n-\n-        @param kwargs: The string arguments from the endpoint description\n-            passed as keyword arguments.  For example, if the description were\n-            C{\"my-type:foo:bar:baz=qux\"}, C{kwargs} would be\n-            C{dict(baz='qux')}.\n-\n-        @return: a client endpoint\n-        @rtype: L{IStreamClientEndpoint}\n-        \"\"\"\n-}}} '''\n\n@@ -10,580 +10,11 @@ Interface definitions for L{twisted.web}.\n     body is not known in advance.\n \"\"\"\n \n-from zope.interface import Interface, Attribute\n-\n-#from twisted.internet.interfaces import IPushProducer\n-\n from twisted.web.iweb import (\n     IRequest, ICredentialFactory, IBodyProducer, IRenderable, ITemplateLoader,\n     IResponse, _IRequestEncoder, _IRequestEncoderFactory, UNKNOWN_LENGTH,\n )\n \n-''' {{{\n-class IRequest(Interface):\n-    \"\"\"\n-    An HTTP request.\n-\n-    @since: 9.0\n-    \"\"\"\n-\n-    method = Attribute(\"A C{str} giving the HTTP method that was used.\")\n-    uri = Attribute(\n-        \"A C{str} giving the full encoded URI which was requested (including \"\n-        \"query arguments).\")\n-    path = Attribute(\n-        \"A C{str} giving the encoded query path of the request URI.\")\n-    args = Attribute(\n-        \"A mapping of decoded query argument names as C{str} to \"\n-        \"corresponding query argument values as C{list}s of C{str}.  \"\n-        \"For example, for a URI with C{'foo=bar&foo=baz&quux=spam'} \"\n-        \"for its query part, C{args} will be C{{'foo': ['bar', 'baz'], \"\n-        \"'quux': ['spam']}}.\")\n-\n-    received_headers = Attribute(\n-        \"Backwards-compatibility access to C{requestHeaders}.  Use \"\n-        \"C{requestHeaders} instead.  C{received_headers} behaves mostly \"\n-        \"like a C{dict} and does not provide access to all header values.\")\n-\n-    requestHeaders = Attribute(\n-        \"A L{http_headers.Headers} instance giving all received HTTP request \"\n-        \"headers.\")\n-\n-    content = Attribute(\n-        \"A file-like object giving the request body.  This may be a file on \"\n-        \"disk, a C{StringIO}, or some other type.  The implementation is free \"\n-        \"to decide on a per-request basis.\")\n-\n-    headers = Attribute(\n-        \"Backwards-compatibility access to C{responseHeaders}.  Use\"\n-        \"C{responseHeaders} instead.  C{headers} behaves mostly like a \"\n-        \"C{dict} and does not provide access to all header values nor \"\n-        \"does it allow multiple values for one header to be set.\")\n-\n-    responseHeaders = Attribute(\n-        \"A L{http_headers.Headers} instance holding all HTTP response \"\n-        \"headers to be sent.\")\n-\n-    def getHeader(key):\n-        \"\"\"\n-        Get an HTTP request header.\n-\n-        @type key: C{str}\n-        @param key: The name of the header to get the value of.\n-\n-        @rtype: C{str} or C{NoneType}\n-        @return: The value of the specified header, or C{None} if that header\n-            was not present in the request.\n-        \"\"\"\n-\n-\n-    def getCookie(key):\n-        \"\"\"\n-        Get a cookie that was sent from the network.\n-        \"\"\"\n-\n-\n-    def getAllHeaders():\n-        \"\"\"\n-        Return dictionary mapping the names of all received headers to the last\n-        value received for each.\n-\n-        Since this method does not return all header information,\n-        C{requestHeaders.getAllRawHeaders()} may be preferred.\n-        \"\"\"\n-\n-\n-    def getRequestHostname():\n-        \"\"\"\n-        Get the hostname that the user passed in to the request.\n-\n-        This will either use the Host: header (if it is available) or the\n-        host we are listening on if the header is unavailable.\n-\n-        @returns: the requested hostname\n-        @rtype: C{str}\n-        \"\"\"\n-\n-\n-    def getHost():\n-        \"\"\"\n-        Get my originally requesting transport's host.\n-\n-        @return: An L{IAddress<twisted.internet.interfaces.IAddress>}.\n-        \"\"\"\n-\n-\n-    def getClientIP():\n-        \"\"\"\n-        Return the IP address of the client who submitted this request.\n-\n-        @returns: the client IP address or C{None} if the request was submitted\n-            over a transport where IP addresses do not make sense.\n-        @rtype: L{str} or C{NoneType}\n-        \"\"\"\n-\n-\n-    def getClient():\n-        \"\"\"\n-        Return the hostname of the IP address of the client who submitted this\n-        request, if possible.\n-\n-        This method is B{deprecated}.  See L{getClientIP} instead.\n-\n-        @rtype: C{NoneType} or L{str}\n-        @return: The canonical hostname of the client, as determined by\n-            performing a name lookup on the IP address of the client.\n-        \"\"\"\n-\n-\n-    def getUser():\n-        \"\"\"\n-        Return the HTTP user sent with this request, if any.\n-\n-        If no user was supplied, return the empty string.\n-\n-        @returns: the HTTP user, if any\n-        @rtype: C{str}\n-        \"\"\"\n-\n-\n-    def getPassword():\n-        \"\"\"\n-        Return the HTTP password sent with this request, if any.\n-\n-        If no password was supplied, return the empty string.\n-\n-        @returns: the HTTP password, if any\n-        @rtype: C{str}\n-        \"\"\"\n-\n-\n-    def isSecure():\n-        \"\"\"\n-        Return True if this request is using a secure transport.\n-\n-        Normally this method returns True if this request's HTTPChannel\n-        instance is using a transport that implements ISSLTransport.\n-\n-        This will also return True if setHost() has been called\n-        with ssl=True.\n-\n-        @returns: True if this request is secure\n-        @rtype: C{bool}\n-        \"\"\"\n-\n-\n-    def getSession(sessionInterface=None):\n-        \"\"\"\n-        Look up the session associated with this request or create a new one if\n-        there is not one.\n-\n-        @return: The L{Session} instance identified by the session cookie in\n-            the request, or the C{sessionInterface} component of that session\n-            if C{sessionInterface} is specified.\n-        \"\"\"\n-\n-\n-    def URLPath():\n-        \"\"\"\n-        @return: A L{URLPath} instance which identifies the URL for which this\n-            request is.\n-        \"\"\"\n-\n-\n-    def prePathURL():\n-        \"\"\"\n-        @return: At any time during resource traversal, a L{str} giving an\n-            absolute URL to the most nested resource which has yet been\n-            reached.\n-        \"\"\"\n-\n-\n-    def rememberRootURL():\n-        \"\"\"\n-        Remember the currently-processed part of the URL for later\n-        recalling.\n-        \"\"\"\n-\n-\n-    def getRootURL():\n-        \"\"\"\n-        Get a previously-remembered URL.\n-        \"\"\"\n-\n-\n-    # Methods for outgoing response\n-    def finish():\n-        \"\"\"\n-        Indicate that the response to this request is complete.\n-        \"\"\"\n-\n-\n-    def write(data):\n-        \"\"\"\n-        Write some data to the body of the response to this request.  Response\n-        headers are written the first time this method is called, after which\n-        new response headers may not be added.\n-        \"\"\"\n-\n-\n-    def addCookie(k, v, expires=None, domain=None, path=None, max_age=None, comment=None, secure=None):\n-        \"\"\"\n-        Set an outgoing HTTP cookie.\n-\n-        In general, you should consider using sessions instead of cookies, see\n-        L{twisted.web.server.Request.getSession} and the\n-        L{twisted.web.server.Session} class for details.\n-        \"\"\"\n-\n-\n-    def setResponseCode(code, message=None):\n-        \"\"\"\n-        Set the HTTP response code.\n-        \"\"\"\n-\n-\n-    def setHeader(k, v):\n-        \"\"\"\n-        Set an HTTP response header.  Overrides any previously set values for\n-        this header.\n-\n-        @type name: C{str}\n-        @param name: The name of the header for which to set the value.\n-\n-        @type value: C{str}\n-        @param value: The value to set for the named header.\n-        \"\"\"\n-\n-\n-    def redirect(url):\n-        \"\"\"\n-        Utility function that does a redirect.\n-\n-        The request should have finish() called after this.\n-        \"\"\"\n-\n-\n-    def setLastModified(when):\n-        \"\"\"\n-        Set the C{Last-Modified} time for the response to this request.\n-\n-        If I am called more than once, I ignore attempts to set Last-Modified\n-        earlier, only replacing the Last-Modified time if it is to a later\n-        value.\n-\n-        If I am a conditional request, I may modify my response code to\n-        L{NOT_MODIFIED<http.NOT_MODIFIED>} if appropriate for the time given.\n-\n-        @param when: The last time the resource being returned was modified, in\n-            seconds since the epoch.\n-        @type when: L{int}, L{long} or L{float}\n-\n-        @return: If I am a C{If-Modified-Since} conditional request and the time\n-            given is not newer than the condition, I return\n-            L{CACHED<http.CACHED>} to indicate that you should write no body.\n-            Otherwise, I return a false value.\n-        \"\"\"\n-\n-\n-    def setETag(etag):\n-        \"\"\"\n-        Set an C{entity tag} for the outgoing response.\n-\n-        That's \"entity tag\" as in the HTTP/1.1 I{ETag} header, \"used for\n-        comparing two or more entities from the same requested resource.\"\n-\n-        If I am a conditional request, I may modify my response code to\n-        L{NOT_MODIFIED<http.NOT_MODIFIED>} or\n-        L{PRECONDITION_FAILED<http.PRECONDITION_FAILED>}, if appropriate for the\n-        tag given.\n-\n-        @param etag: The entity tag for the resource being returned.\n-        @type etag: C{str}\n-\n-        @return: If I am a C{If-None-Match} conditional request and the tag\n-            matches one in the request, I return L{CACHED<http.CACHED>} to\n-            indicate that you should write no body.  Otherwise, I return a\n-            false value.\n-        \"\"\"\n-\n-\n-    def setHost(host, port, ssl=0):\n-        \"\"\"\n-        Change the host and port the request thinks it's using.\n-\n-        This method is useful for working with reverse HTTP proxies (e.g.  both\n-        Squid and Apache's mod_proxy can do this), when the address the HTTP\n-        client is using is different than the one we're listening on.\n-\n-        For example, Apache may be listening on https://www.example.com, and\n-        then forwarding requests to http://localhost:8080, but we don't want\n-        HTML produced by Twisted to say 'http://localhost:8080', they should\n-        say 'https://www.example.com', so we do::\n-\n-           request.setHost('www.example.com', 443, ssl=1)\n-        \"\"\"\n-\n-\n-\n-class ICredentialFactory(Interface):\n-    \"\"\"\n-    A credential factory defines a way to generate a particular kind of\n-    authentication challenge and a way to interpret the responses to these\n-    challenges.  It creates\n-    L{ICredentials<twisted.cred.credentials.ICredentials>} providers from\n-    responses.  These objects will be used with L{twisted.cred} to authenticate\n-    an authorize requests.\n-    \"\"\"\n-    scheme = Attribute(\n-        \"A C{str} giving the name of the authentication scheme with which \"\n-        \"this factory is associated.  For example, C{'basic'} or C{'digest'}.\")\n-\n-\n-    def getChallenge(request):\n-        \"\"\"\n-        Generate a new challenge to be sent to a client.\n-\n-        @type peer: L{twisted.web.http.Request}\n-        @param peer: The request the response to which this challenge will be\n-            included.\n-\n-        @rtype: C{dict}\n-        @return: A mapping from C{str} challenge fields to associated C{str}\n-            values.\n-        \"\"\"\n-\n-\n-    def decode(response, request):\n-        \"\"\"\n-        Create a credentials object from the given response.\n-\n-        @type response: C{str}\n-        @param response: scheme specific response string\n-\n-        @type request: L{twisted.web.http.Request}\n-        @param request: The request being processed (from which the response\n-            was taken).\n-\n-        @raise twisted.cred.error.LoginFailed: If the response is invalid.\n-\n-        @rtype: L{twisted.cred.credentials.ICredentials} provider\n-        @return: The credentials represented by the given response.\n-        \"\"\"\n-\n-\n-\n-class IBodyProducer(IPushProducer):\n-    \"\"\"\n-    Objects which provide L{IBodyProducer} write bytes to an object which\n-    provides L{IConsumer<twisted.internet.interfaces.IConsumer>} by calling its\n-    C{write} method repeatedly.\n-\n-    L{IBodyProducer} providers may start producing as soon as they have an\n-    L{IConsumer<twisted.internet.interfaces.IConsumer>} provider.  That is, they\n-    should not wait for a C{resumeProducing} call to begin writing data.\n-\n-    L{IConsumer.unregisterProducer<twisted.internet.interfaces.IConsumer.unregisterProducer>}\n-    must not be called.  Instead, the\n-    L{Deferred<twisted.internet.defer.Deferred>} returned from C{startProducing}\n-    must be fired when all bytes have been written.\n-\n-    L{IConsumer.write<twisted.internet.interfaces.IConsumer.write>} may\n-    synchronously invoke any of C{pauseProducing}, C{resumeProducing}, or\n-    C{stopProducing}.  These methods must be implemented with this in mind.\n-\n-    @since: 9.0\n-    \"\"\"\n-\n-    # Despite the restrictions above and the additional requirements of\n-    # stopProducing documented below, this interface still needs to be an\n-    # IPushProducer subclass.  Providers of it will be passed to IConsumer\n-    # providers which only know about IPushProducer and IPullProducer, not\n-    # about this interface.  This interface needs to remain close enough to one\n-    # of those interfaces for consumers to work with it.\n-\n-    length = Attribute(\n-        \"\"\"\n-        C{length} is a C{int} indicating how many bytes in total this\n-        L{IBodyProducer} will write to the consumer or L{UNKNOWN_LENGTH}\n-        if this is not known in advance.\n-        \"\"\")\n-\n-    def startProducing(consumer):\n-        \"\"\"\n-        Start producing to the given\n-        L{IConsumer<twisted.internet.interfaces.IConsumer>} provider.\n-\n-        @return: A L{Deferred<twisted.internet.defer.Deferred>} which fires with\n-            C{None} when all bytes have been produced or with a\n-            L{Failure<twisted.python.failure.Failure>} if there is any problem\n-            before all bytes have been produced.\n-        \"\"\"\n-\n-\n-    def stopProducing():\n-        \"\"\"\n-        In addition to the standard behavior of\n-        L{IProducer.stopProducing<twisted.internet.interfaces.IProducer.stopProducing>}\n-        (stop producing data), make sure the\n-        L{Deferred<twisted.internet.defer.Deferred>} returned by\n-        C{startProducing} is never fired.\n-        \"\"\"\n-\n-\n-\n-class IRenderable(Interface):\n-    \"\"\"\n-    An L{IRenderable} is an object that may be rendered by the\n-    L{twisted.web.template} templating system.\n-    \"\"\"\n-\n-    def lookupRenderMethod(name):\n-        \"\"\"\n-        Look up and return the render method associated with the given name.\n-\n-        @type name: C{str}\n-        @param name: The value of a render directive encountered in the\n-            document returned by a call to L{IRenderable.render}.\n-\n-        @return: A two-argument callable which will be invoked with the request\n-            being responded to and the tag object on which the render directive\n-            was encountered.\n-        \"\"\"\n-\n-\n-    def render(request):\n-        \"\"\"\n-        Get the document for this L{IRenderable}.\n-\n-        @type request: L{IRequest} provider or C{NoneType}\n-        @param request: The request in response to which this method is being\n-            invoked.\n-\n-        @return: An object which can be flattened.\n-        \"\"\"\n-\n-\n-\n-class ITemplateLoader(Interface):\n-    \"\"\"\n-    A loader for templates; something usable as a value for\n-    L{twisted.web.template.Element}'s C{loader} attribute.\n-    \"\"\"\n-\n-    def load():\n-        \"\"\"\n-        Load a template suitable for rendering.\n-\n-        @return: a C{list} of C{list}s, C{unicode} objects, C{Element}s and\n-            other L{IRenderable} providers.\n-        \"\"\"\n-\n-\n-\n-class IResponse(Interface):\n-    \"\"\"\n-    An object representing an HTTP response received from an HTTP server.\n-\n-    @since: 11.1\n-    \"\"\"\n-\n-    version = Attribute(\n-        \"A three-tuple describing the protocol and protocol version \"\n-        \"of the response.  The first element is of type C{str}, the second \"\n-        \"and third are of type C{int}.  For example, C{('HTTP', 1, 1)}.\")\n-\n-\n-    code = Attribute(\"The HTTP status code of this response, as a C{int}.\")\n-\n-\n-    phrase = Attribute(\n-        \"The HTTP reason phrase of this response, as a C{str}.\")\n-\n-\n-    headers = Attribute(\"The HTTP response L{Headers} of this response.\")\n-\n-\n-    length = Attribute(\n-        \"The C{int} number of bytes expected to be in the body of this \"\n-        \"response or L{UNKNOWN_LENGTH} if the server did not indicate how \"\n-        \"many bytes to expect.  For I{HEAD} responses, this will be 0; if \"\n-        \"the response includes a I{Content-Length} header, it will be \"\n-        \"available in C{headers}.\")\n-\n-\n-    def deliverBody(protocol):\n-        \"\"\"\n-        Register an L{IProtocol<twisted.internet.interfaces.IProtocol>} provider\n-        to receive the response body.\n-\n-        The protocol will be connected to a transport which provides\n-        L{IPushProducer}.  The protocol's C{connectionLost} method will be\n-        called with:\n-\n-            - ResponseDone, which indicates that all bytes from the response\n-              have been successfully delivered.\n-\n-            - PotentialDataLoss, which indicates that it cannot be determined\n-              if the entire response body has been delivered.  This only occurs\n-              when making requests to HTTP servers which do not set\n-              I{Content-Length} or a I{Transfer-Encoding} in the response.\n-\n-            - ResponseFailed, which indicates that some bytes from the response\n-              were lost.  The C{reasons} attribute of the exception may provide\n-              more specific indications as to why.\n-        \"\"\"\n-\n-\n-\n-class _IRequestEncoder(Interface):\n-    \"\"\"\n-    An object encoding data passed to L{IRequest.write}, for example for\n-    compression purpose.\n-\n-    @since: 12.3\n-    \"\"\"\n-\n-    def encode(data):\n-        \"\"\"\n-        Encode the data given and return the result.\n-\n-        @param data: The content to encode.\n-        @type data: C{str}\n-\n-        @return: The encoded data.\n-        @rtype: C{str}\n-        \"\"\"\n-\n-\n-    def finish():\n-        \"\"\"\n-        Callback called when the request is closing.\n-\n-        @return: If necessary, the pending data accumulated from previous\n-            C{encode} calls.\n-        @rtype: C{str}\n-        \"\"\"\n-\n-\n-\n-class _IRequestEncoderFactory(Interface):\n-    \"\"\"\n-    A factory for returing L{_IRequestEncoder} instances.\n-\n-    @since: 12.3\n-    \"\"\"\n-\n-    def encoderForRequest(request):\n-        \"\"\"\n-        If applicable, returns a L{_IRequestEncoder} instance which will encode\n-        the request.\n-        \"\"\"\n-\n-\n-\n-UNKNOWN_LENGTH = u\"twisted.web.iweb.UNKNOWN_LENGTH\"\n-}}} '''\n __all__ = [\n     \"ICredentialFactory\", \"IRequest\",\n     \"IBodyProducer\", \"IRenderable\", \"IResponse\", \"_IRequestEncoder\",\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
