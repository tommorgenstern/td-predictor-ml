{"custom_id": "keras#c6beaa5758b54287c35344b4dbe19d35ac267b72", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 407 | Contributors (this commit): 22 | Commits (past 90d): 9 | Contributors (cumulative): 25 | DMM Complexity: None\n\nDIFF:\n@@ -45,6 +45,7 @@ setup(name='Keras',\n                     'pytest-pep8',\n                     'pytest-xdist',\n                     'pytest-cov',\n+                    'pytest-timeout',\n                     'pandas',\n                     'requests'],\n       },\n\n@@ -131,6 +131,7 @@ def test_regression_build_fn():\n     assert_regression_works(reg)\n \n \n+@pytest.mark.timeout(50)\n def test_regression_class_build_fn():\n     class ClassBuildFnReg(object):\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#e40ffd2c56977492a382103a31b64bd3bfcfd1a1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 4742 | Contributors (this commit): 29 | Commits (past 90d): 13 | Contributors (cumulative): 29 | DMM Complexity: None\n\nDIFF:\n@@ -1145,8 +1145,8 @@ class TestBackend(object):\n             assert np.abs(np.std(rand) - std) < std * 0.015\n \n             # test that random_normal also generates different values when used within a function\n-            r = K.random_normal((1,), mean=mean, stddev=std, seed=1337)\n-            samples = [K.eval(r) for _ in range(60000)]\n+            r = K.random_normal((10, 10), mean=mean, stddev=std, seed=1337)\n+            samples = [K.eval(r) for _ in range(100)]\n             assert np.abs(np.mean(samples) - mean) < std * 0.015\n             assert np.abs(np.std(samples) - std) < std * 0.015\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#7a195b64ea02e02698083b0b795287ffa6e72cf8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 33 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 5 | Methods Changed: 4 | Complexity Δ (Sum/Max): 4/3 | Churn Δ: 36 | Churn Cumulative: 11169 | Contributors (this commit): 121 | Commits (past 90d): 21 | Contributors (cumulative): 134 | DMM Complexity: 1.0\n\nDIFF:\n@@ -15,6 +15,7 @@ from tensorflow.core.protobuf import config_pb2\n from collections import defaultdict\n \n import numpy as np\n+from distutils.version import StrictVersion\n import os\n \n from .common import floatx\n@@ -3400,7 +3401,9 @@ def _preprocess_conv1d_input(x, data_format):\n     # Returns\n         A tensor.\n     \"\"\"\n-    if dtype(x) == 'float64':\n+    # tensorflow doesn't support float64 for conv layer before 1.8.0\n+    if (dtype(x) == 'float64'\n+            and StrictVersion(tf.__version__) < StrictVersion('1.8.0')):\n         x = tf.cast(x, 'float32')\n     tf_data_format = 'NWC'  # to pass TF Conv2dNative operations\n     if data_format == 'channels_first':\n@@ -3421,7 +3424,9 @@ def _preprocess_conv2d_input(x, data_format):\n     # Returns\n         A tensor.\n     \"\"\"\n-    if dtype(x) == 'float64':\n+    # tensorflow doesn't support float64 for conv layer before 1.8.0\n+    if (dtype(x) == 'float64'\n+            and StrictVersion(tf.__version__) < StrictVersion('1.8.0')):\n         x = tf.cast(x, 'float32')\n     tf_data_format = 'NHWC'\n     if data_format == 'channels_first':\n@@ -3442,7 +3447,9 @@ def _preprocess_conv3d_input(x, data_format):\n     # Returns\n         A tensor.\n     \"\"\"\n-    if dtype(x) == 'float64':\n+    # tensorflow doesn't support float64 for conv layer before 1.8.0\n+    if (dtype(x) == 'float64'\n+            and StrictVersion(tf.__version__) < StrictVersion('1.8.0')):\n         x = tf.cast(x, 'float32')\n     tf_data_format = 'NDHWC'\n     if data_format == 'channels_first':\n\n@@ -1062,5 +1062,28 @@ def test_cropping_3d():\n         layer = convolutional.Cropping3D(cropping=lambda x: x)\n \n \n+@keras_test\n+@pytest.mark.skipif((K.backend() == 'cntk'),\n+                    reason='CNTK does not support float64')\n+@pytest.mark.parametrize(\n+    'input_shape,conv_class',\n+    [((2, 4, 2), convolutional.Conv1D),\n+     ((2, 4, 4, 2), convolutional.Conv2D),\n+     ((2, 4, 4, 4, 2), convolutional.Conv3D)]\n+)\n+def test_conv_float64(input_shape, conv_class):\n+    kernel_size = 3\n+    strides = 1\n+    filters = 3\n+    K.set_floatx('float64')\n+    layer_test(conv_class,\n+               kwargs={'filters': filters,\n+                       'kernel_size': kernel_size,\n+                       'padding': 'valid',\n+                       'strides': strides},\n+               input_shape=input_shape)\n+    K.set_floatx('float32')\n+\n+\n if __name__ == '__main__':\n     pytest.main([__file__])\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#4e4e57d1e4af7e9c7eef8cb2b73cd620206df2fd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 11 | Churn Cumulative: 11554 | Contributors (this commit): 63 | Commits (past 90d): 13 | Contributors (cumulative): 63 | DMM Complexity: None\n\nDIFF:\n@@ -264,10 +264,13 @@ class Conv1D(_Conv):\n             `\"valid\"` means \"no padding\".\n             `\"same\"` results in padding the input such that\n             the output has the same length as the original input.\n-            `\"causal\"` results in causal (dilated) convolutions, e.g. output[t]\n-            does not depend on input[t+1:]. Useful when modeling temporal data\n-            where the model should not violate the temporal order.\n-            See [WaveNet: A Generative Model for Raw Audio, section 2.1](https://arxiv.org/abs/1609.03499).\n+            `\"causal\"` results in causal (dilated) convolutions,\n+            e.g. `output[t]` does not depend on `input[t + 1:]`.\n+            A zero padding is used such that\n+            the output has the same length as the original input.\n+            Useful when modeling temporal data where the model\n+            should not violate the temporal order. See\n+            [WaveNet: A Generative Model for Raw Audio, section 2.1](https://arxiv.org/abs/1609.03499).\n         data_format: A string,\n             one of `\"channels_last\"` (default) or `\"channels_first\"`.\n             The ordering of the dimensions in the inputs.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#4f110b644599ac3f62e24e950e87159bc7d0f458", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 63 | Contributors (this commit): 7 | Commits (past 90d): 3 | Contributors (cumulative): 7 | DMM Complexity: None\n\nDIFF:\n@@ -131,7 +131,6 @@ def test_regression_build_fn():\n     assert_regression_works(reg)\n \n \n-@pytest.mark.timeout(50)\n def test_regression_class_build_fn():\n     class ClassBuildFnReg(object):\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#72e326dde38cb731424210bfd6e56f301ddc9e2b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 68 | Lines Deleted: 107 | Files Changed: 1 | Hunks: 16 | Methods Changed: 6 | Complexity Δ (Sum/Max): -14/0 | Churn Δ: 175 | Churn Cumulative: 11729 | Contributors (this commit): 63 | Commits (past 90d): 14 | Contributors (cumulative): 63 | DMM Complexity: 1.0\n\nDIFF:\n@@ -2043,7 +2043,53 @@ class UpSampling3D(Layer):\n         return dict(list(base_config.items()) + list(config.items()))\n \n \n-class ZeroPadding1D(Layer):\n+class _ZeroPadding(Layer):\n+    \"\"\"Abstract nD ZeroPadding layer (private, used as implementation base).\n+\n+    # Arguments\n+        padding: Tuple of tuples of two ints. Can be a tuple of ints when\n+            rank is 1.\n+        data_format: A string,\n+            one of `\"channels_last\"` or `\"channels_first\"`.\n+            The ordering of the dimensions in the inputs.\n+            `\"channels_last\"` corresponds to inputs with shape\n+            `(batch, ..., channels)` while `\"channels_first\"` corresponds to\n+            inputs with shape `(batch, channels, ...)`.\n+            It defaults to the `image_data_format` value found in your\n+            Keras config file at `~/.keras/keras.json`.\n+            If you never set it, then it will be \"channels_last\".\n+    \"\"\"\n+    def __init__(self, padding, data_format=None, **kwargs):\n+        # self.rank is 1 for ZeroPadding1D, 2 for ZeroPadding2D.\n+        self.rank = len(padding)\n+        self.padding = padding\n+        self.data_format = K.normalize_data_format(data_format)\n+        self.input_spec = InputSpec(ndim=self.rank + 2)\n+        super(_ZeroPadding, self).__init__(**kwargs)\n+\n+    def call(self, inputs):\n+        raise NotImplementedError\n+\n+    def compute_output_shape(self, input_shape):\n+        padding_all_dims = ((0, 0),) + self.padding + ((0, 0),)\n+        spatial_axes = list(range(1, 1 + self.rank))\n+        padding_all_dims = transpose_shape(padding_all_dims,\n+                                           self.data_format,\n+                                           spatial_axes)\n+        output_shape = list(input_shape)\n+        for dim in range(len(output_shape)):\n+            if output_shape[dim] is not None:\n+                output_shape[dim] += sum(padding_all_dims[dim])\n+        return tuple(output_shape)\n+\n+    def get_config(self):\n+        config = {'padding': self.padding,\n+                  'data_format': self.data_format}\n+        base_config = super(_ZeroPadding, self).get_config()\n+        return dict(list(base_config.items()) + list(config.items()))\n+\n+\n+class ZeroPadding1D(_ZeroPadding):\n     \"\"\"Zero-padding layer for 1D input (e.g. temporal sequence).\n \n     # Arguments\n@@ -2063,29 +2109,22 @@ class ZeroPadding1D(Layer):\n     \"\"\"\n \n     def __init__(self, padding=1, **kwargs):\n-        super(ZeroPadding1D, self).__init__(**kwargs)\n-        self.padding = conv_utils.normalize_tuple(padding, 2, 'padding')\n-        self.input_spec = InputSpec(ndim=3)\n-\n-    def compute_output_shape(self, input_shape):\n-        if input_shape[1] is not None:\n-            length = input_shape[1] + self.padding[0] + self.padding[1]\n-        else:\n-            length = None\n-        return (input_shape[0],\n-                length,\n-                input_shape[2])\n+        normalized_padding = (conv_utils.normalize_tuple(padding, 2, 'padding'),)\n+        super(ZeroPadding1D, self).__init__(normalized_padding,\n+                                            'channels_last',\n+                                            **kwargs)\n \n     def call(self, inputs):\n-        return K.temporal_padding(inputs, padding=self.padding)\n+        return K.temporal_padding(inputs, padding=self.padding[0])\n \n     def get_config(self):\n-        config = {'padding': self.padding}\n-        base_config = super(ZeroPadding1D, self).get_config()\n-        return dict(list(base_config.items()) + list(config.items()))\n+        config = super(ZeroPadding1D, self).get_config()\n+        config['padding'] = config['padding'][0]\n+        config.pop('data_format')\n+        return config\n \n \n-class ZeroPadding2D(Layer):\n+class ZeroPadding2D(_ZeroPadding):\n     \"\"\"Zero-padding layer for 2D input (e.g. picture).\n \n     This layer can add rows and columns of zeros\n@@ -2133,10 +2172,8 @@ class ZeroPadding2D(Layer):\n                  padding=(1, 1),\n                  data_format=None,\n                  **kwargs):\n-        super(ZeroPadding2D, self).__init__(**kwargs)\n-        self.data_format = K.normalize_data_format(data_format)\n         if isinstance(padding, int):\n-            self.padding = ((padding, padding), (padding, padding))\n+            normalized_padding = ((padding, padding), (padding, padding))\n         elif hasattr(padding, '__len__'):\n             if len(padding) != 2:\n                 raise ValueError('`padding` should have two elements. '\n@@ -2145,7 +2182,7 @@ class ZeroPadding2D(Layer):\n                                                         '1st entry of padding')\n             width_padding = conv_utils.normalize_tuple(padding[1], 2,\n                                                        '2nd entry of padding')\n-            self.padding = (height_padding, width_padding)\n+            normalized_padding = (height_padding, width_padding)\n         else:\n             raise ValueError('`padding` should be either an int, '\n                              'a tuple of 2 ints '\n@@ -2153,49 +2190,17 @@ class ZeroPadding2D(Layer):\n                              'or a tuple of 2 tuples of 2 ints '\n                              '((top_pad, bottom_pad), (left_pad, right_pad)). '\n                              'Found: ' + str(padding))\n-        self.input_spec = InputSpec(ndim=4)\n-\n-    def compute_output_shape(self, input_shape):\n-        if self.data_format == 'channels_first':\n-            if input_shape[2] is not None:\n-                rows = input_shape[2] + self.padding[0][0] + self.padding[0][1]\n-            else:\n-                rows = None\n-            if input_shape[3] is not None:\n-                cols = input_shape[3] + self.padding[1][0] + self.padding[1][1]\n-            else:\n-                cols = None\n-            return (input_shape[0],\n-                    input_shape[1],\n-                    rows,\n-                    cols)\n-        elif self.data_format == 'channels_last':\n-            if input_shape[1] is not None:\n-                rows = input_shape[1] + self.padding[0][0] + self.padding[0][1]\n-            else:\n-                rows = None\n-            if input_shape[2] is not None:\n-                cols = input_shape[2] + self.padding[1][0] + self.padding[1][1]\n-            else:\n-                cols = None\n-            return (input_shape[0],\n-                    rows,\n-                    cols,\n-                    input_shape[3])\n+        super(ZeroPadding2D, self).__init__(normalized_padding,\n+                                            data_format,\n+                                            **kwargs)\n \n     def call(self, inputs):\n         return K.spatial_2d_padding(inputs,\n                                     padding=self.padding,\n                                     data_format=self.data_format)\n \n-    def get_config(self):\n-        config = {'padding': self.padding,\n-                  'data_format': self.data_format}\n-        base_config = super(ZeroPadding2D, self).get_config()\n-        return dict(list(base_config.items()) + list(config.items()))\n \n-\n-class ZeroPadding3D(Layer):\n+class ZeroPadding3D(_ZeroPadding):\n     \"\"\"Zero-padding layer for 3D data (spatial or spatio-temporal).\n \n     # Arguments\n@@ -2237,10 +2242,8 @@ class ZeroPadding3D(Layer):\n \n     @interfaces.legacy_zeropadding3d_support\n     def __init__(self, padding=(1, 1, 1), data_format=None, **kwargs):\n-        super(ZeroPadding3D, self).__init__(**kwargs)\n-        self.data_format = K.normalize_data_format(data_format)\n         if isinstance(padding, int):\n-            self.padding = ((padding, padding), (padding, padding), (padding, padding))\n+            normalized_padding = ((padding, padding), (padding, padding), (padding, padding))\n         elif hasattr(padding, '__len__'):\n             if len(padding) != 3:\n                 raise ValueError('`padding` should have 3 elements. '\n@@ -2251,7 +2254,7 @@ class ZeroPadding3D(Layer):\n                                                       '2nd entry of padding')\n             dim3_padding = conv_utils.normalize_tuple(padding[2], 2,\n                                                       '3rd entry of padding')\n-            self.padding = (dim1_padding, dim2_padding, dim3_padding)\n+            normalized_padding = (dim1_padding, dim2_padding, dim3_padding)\n         else:\n             raise ValueError('`padding` should be either an int, '\n                              'a tuple of 3 ints '\n@@ -2261,57 +2264,15 @@ class ZeroPadding3D(Layer):\n                              ' (left_dim2_pad, right_dim2_pad),'\n                              ' (left_dim3_pad, right_dim2_pad)). '\n                              'Found: ' + str(padding))\n-        self.input_spec = InputSpec(ndim=5)\n-\n-    def compute_output_shape(self, input_shape):\n-        if self.data_format == 'channels_first':\n-            if input_shape[2] is not None:\n-                dim1 = input_shape[2] + self.padding[0][0] + self.padding[0][1]\n-            else:\n-                dim1 = None\n-            if input_shape[3] is not None:\n-                dim2 = input_shape[3] + self.padding[1][0] + self.padding[1][1]\n-            else:\n-                dim2 = None\n-            if input_shape[4] is not None:\n-                dim3 = input_shape[4] + self.padding[2][0] + self.padding[2][1]\n-            else:\n-                dim3 = None\n-            return (input_shape[0],\n-                    input_shape[1],\n-                    dim1,\n-                    dim2,\n-                    dim3)\n-        elif self.data_format == 'channels_last':\n-            if input_shape[1] is not None:\n-                dim1 = input_shape[1] + self.padding[0][0] + self.padding[0][1]\n-            else:\n-                dim1 = None\n-            if input_shape[2] is not None:\n-                dim2 = input_shape[2] + self.padding[1][0] + self.padding[1][1]\n-            else:\n-                dim2 = None\n-            if input_shape[3] is not None:\n-                dim3 = input_shape[3] + self.padding[2][0] + self.padding[2][1]\n-            else:\n-                dim3 = None\n-            return (input_shape[0],\n-                    dim1,\n-                    dim2,\n-                    dim3,\n-                    input_shape[4])\n+        super(ZeroPadding3D, self).__init__(normalized_padding,\n+                                            data_format,\n+                                            **kwargs)\n \n     def call(self, inputs):\n         return K.spatial_3d_padding(inputs,\n                                     padding=self.padding,\n                                     data_format=self.data_format)\n \n-    def get_config(self):\n-        config = {'padding': self.padding,\n-                  'data_format': self.data_format}\n-        base_config = super(ZeroPadding3D, self).get_config()\n-        return dict(list(base_config.items()) + list(config.items()))\n-\n \n class _Cropping(Layer):\n     \"\"\"Abstract nD copping layer (private, used as implementation base).\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#1b2ac897e369d30ef3a20b93442212989ed7ed77", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 4744 | Contributors (this commit): 29 | Commits (past 90d): 14 | Contributors (cumulative): 29 | DMM Complexity: None\n\nDIFF:\n@@ -1146,7 +1146,7 @@ class TestBackend(object):\n \n             # test that random_normal also generates different values when used within a function\n             r = K.random_normal((10, 10), mean=mean, stddev=std, seed=1337)\n-            samples = [K.eval(r) for _ in range(100)]\n+            samples = [K.eval(r) for _ in range(200)]\n             assert np.abs(np.mean(samples) - mean) < std * 0.015\n             assert np.abs(np.std(samples) - std) < std * 0.015\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#f06c7e4dcd9d3044580dff155cdeb4978e622188", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 24 | Lines Deleted: 16 | Files Changed: 2 | Hunks: 9 | Methods Changed: 3 | Complexity Δ (Sum/Max): 4/2 | Churn Δ: 40 | Churn Cumulative: 4659 | Contributors (this commit): 35 | Commits (past 90d): 20 | Contributors (cumulative): 42 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1494,14 +1494,17 @@ def conv1d(x, kernel, strides=1, padding='valid',\n         kernel = C.swapaxes(kernel, 0, 2)\n \n     padding = _preprocess_border_mode(padding)\n-    strides = [strides]\n+\n+    if dev.type() == 0 and dilation_rate != 1:\n+        raise ValueError('Dilated convolution on CPU is not supported by CNTK backend. '\n+                         'Please set `dilation_rate` to 1. You passed: %s' % (dilation_rate,))\n+\n     x = C.convolution(\n         kernel,\n         x,\n-        strides=tuple(strides),\n-        auto_padding=[\n-            False,\n-            padding])\n+        strides=strides,\n+        auto_padding=[False, padding],\n+        dilation=dilation_rate)\n \n     if data_format == 'channels_last':\n         x = C.swapaxes(x, 0, 1)\n@@ -1517,8 +1520,9 @@ def conv2d(x, kernel, strides=(1, 1), padding='valid',\n     padding = _preprocess_border_mode(padding)\n \n     if dev.type() == 0 and dilation_rate != (1, 1):\n-        raise ValueError('Dilated convolution on CPU is not supported by CNTK backend. ' +\n-                         'Please set dilation_rate with (1, 1).')\n+        raise ValueError('Dilated convolution on CPU is not supported by CNTK backend. '\n+                         'Please set `dilation_rate` to (1, 1). '\n+                         'You passed: %s' % (dilation_rate,))\n \n     x = C.convolution(kernel,\n                       x,\n@@ -1649,17 +1653,19 @@ def conv3d(x, kernel, strides=(1, 1, 1), padding='valid',\n     x = _preprocess_conv3d_input(x, data_format)\n     kernel = _preprocess_conv3d_kernel(kernel, data_format)\n     padding = _preprocess_border_mode(padding)\n-    strides = strides + (strides[0],)\n+\n+    if dev.type() == 0 and dilation_rate != (1, 1, 1):\n+        raise ValueError('Dilated convolution on CPU is not supported by CNTK backend. '\n+                         'Please set `dilation_rate` to (1, 1, 1). '\n+                         'You passed: %s' % (dilation_rate,))\n \n     x = C.convolution(\n         kernel,\n         x,\n         strides,\n-        auto_padding=[\n-            False,\n-            padding,\n-            padding,\n-            padding])\n+        auto_padding=[False, padding, padding, padding],\n+        dilation=dilation_rate)\n+\n     return _postprocess_conv3d_output(x, data_format)\n \n \n\n@@ -20,7 +20,7 @@ else:\n \n @keras_test\n @pytest.mark.skipif((K.backend() == 'cntk'),\n-                    reason=\"cntk does not support dilated conv\")\n+                    reason='cntk only support dilated conv on GPU')\n def test_causal_dilated_conv():\n     # Causal:\n     layer_test(convolutional.Conv1D,\n@@ -98,6 +98,8 @@ def test_conv_1d():\n                        input_shape=(batch_size, steps, input_dim))\n \n     # Test dilation\n+    if K.backend() != 'cntk':\n+        # cntk only support dilated conv on GPU\n         layer_test(convolutional.Conv1D,\n                    kwargs={'filters': filters,\n                            'kernel_size': kernel_size,\n@@ -138,8 +140,6 @@ def test_averagepooling_1d():\n \n \n @keras_test\n-@pytest.mark.skipif((K.backend() == 'cntk'),\n-                    reason=\"cntk only supports dilated conv on GPU\")\n def test_convolution_2d():\n     num_samples = 2\n     filters = 2\n@@ -176,6 +176,8 @@ def test_convolution_2d():\n                input_shape=(num_samples, num_row, num_col, stack_size))\n \n     # Test dilation\n+    if K.backend() != 'cntk':\n+        # cntk only support dilated conv on GPU\n         layer_test(convolutional.Conv2D,\n                    kwargs={'filters': filters,\n                            'kernel_size': kernel_size,\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#4562b64cf2719e8d34824ed905b5d283efd41ae4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 37 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 3/2 | Churn Δ: 37 | Churn Cumulative: 4835 | Contributors (this commit): 80 | Commits (past 90d): 10 | Contributors (cumulative): 106 | DMM Complexity: 0.9\n\nDIFF:\n@@ -956,7 +956,10 @@ class TensorBoard(Callback):\n                 continue\n             summary = tf.Summary()\n             summary_value = summary.value.add()\n+            if isinstance(value, np.ndarray):\n                 summary_value.simple_value = value.item()\n+            else:\n+                summary_value.simple_value = value\n             summary_value.tag = name\n             self.writer.add_summary(summary, epoch)\n         self.writer.flush()\n\n@@ -853,6 +853,40 @@ def test_TensorBoard_convnet(tmpdir):\n     assert not tmpdir.listdir()\n \n \n+@keras_test\n+def test_TensorBoard_display_float_from_logs(tmpdir):\n+    filepath = str(tmpdir / 'logs')\n+\n+    input_shape = (3,)\n+    (x_train, y_train), _ = get_test_data(num_train=10,\n+                                          num_test=0,\n+                                          input_shape=input_shape,\n+                                          classification=True,\n+                                          num_classes=num_classes)\n+    y_train = np_utils.to_categorical(y_train)\n+\n+    model = Sequential([\n+        Dense(num_classes, activation='softmax')\n+    ])\n+    model.compile(loss='categorical_crossentropy',\n+                  optimizer='rmsprop')\n+\n+    class CustomCallback(callbacks.Callback):\n+\n+        def on_epoch_end(self, epoch, logs=None):\n+            logs['test'] = 0.\n+\n+    tsb = callbacks.TensorBoard(log_dir=filepath,\n+                                batch_size=16)\n+    cbks = [CustomCallback(), tsb]\n+    model.fit(x_train, y_train, epochs=2, batch_size=16,\n+              callbacks=cbks,\n+              verbose=0)\n+    assert os.path.isdir(filepath)\n+    shutil.rmtree(filepath)\n+    assert not tmpdir.listdir()\n+\n+\n @keras_test\n def test_CallbackValData():\n     np.random.seed(1337)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#f6ed1c8712e5b69ea35bcad3bd33d39d0d0b554c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 12 | Churn Cumulative: 9930 | Contributors (this commit): 118 | Commits (past 90d): 13 | Contributors (cumulative): 118 | DMM Complexity: None\n\nDIFF:\n@@ -3402,8 +3402,8 @@ def _preprocess_conv1d_input(x, data_format):\n         A tensor.\n     \"\"\"\n     # tensorflow doesn't support float64 for conv layer before 1.8.0\n-    if (dtype(x) == 'float64'\n-            and StrictVersion(tf.__version__) < StrictVersion('1.8.0')):\n+    if (dtype(x) == 'float64' and\n+            StrictVersion(tf.__version__.split('-')[0]) < StrictVersion('1.8.0')):\n         x = tf.cast(x, 'float32')\n     tf_data_format = 'NWC'  # to pass TF Conv2dNative operations\n     if data_format == 'channels_first':\n@@ -3425,8 +3425,8 @@ def _preprocess_conv2d_input(x, data_format):\n         A tensor.\n     \"\"\"\n     # tensorflow doesn't support float64 for conv layer before 1.8.0\n-    if (dtype(x) == 'float64'\n-            and StrictVersion(tf.__version__) < StrictVersion('1.8.0')):\n+    if (dtype(x) == 'float64' and\n+            StrictVersion(tf.__version__.split('-')[0]) < StrictVersion('1.8.0')):\n         x = tf.cast(x, 'float32')\n     tf_data_format = 'NHWC'\n     if data_format == 'channels_first':\n@@ -3448,8 +3448,8 @@ def _preprocess_conv3d_input(x, data_format):\n         A tensor.\n     \"\"\"\n     # tensorflow doesn't support float64 for conv layer before 1.8.0\n-    if (dtype(x) == 'float64'\n-            and StrictVersion(tf.__version__) < StrictVersion('1.8.0')):\n+    if (dtype(x) == 'float64' and\n+            StrictVersion(tf.__version__.split('-')[0]) < StrictVersion('1.8.0')):\n         x = tf.cast(x, 'float32')\n     tf_data_format = 'NDHWC'\n     if data_format == 'channels_first':\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#4c015964da4e7e2dfa504461f020408d0692a57b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 460 | Lines Deleted: 287 | Files Changed: 2 | Hunks: 50 | Methods Changed: 60 | Complexity Δ (Sum/Max): -45/10 | Churn Δ: 747 | Churn Cumulative: 2006 | Contributors (this commit): 16 | Commits (past 90d): 12 | Contributors (cumulative): 17 | DMM Complexity: 1.0\n\nDIFF:\n@@ -6,8 +6,6 @@ from keras.utils.test_utils import layer_test\n from keras.utils.test_utils import keras_test\n from keras import backend as K\n from keras.layers import convolutional\n-from keras.layers import pooling\n-from keras.layers import Masking\n from keras.models import Sequential\n \n \n@@ -21,63 +19,45 @@ else:\n @keras_test\n @pytest.mark.skipif((K.backend() == 'cntk'),\n                     reason='cntk only support dilated conv on GPU')\n-def test_causal_dilated_conv():\n-    # Causal:\n-    layer_test(convolutional.Conv1D,\n-               input_data=np.reshape(np.arange(4, dtype='float32'), (1, 4, 1)),\n-               kwargs={\n-                   'filters': 1,\n-                   'kernel_size': 2,\n-                   'dilation_rate': 1,\n-                   'padding': 'causal',\n-                   'kernel_initializer': 'ones',\n-                   'use_bias': False,\n-               },\n-               expected_output=[[[0], [1], [3], [5]]]\n-               )\n-\n-    # Non-causal:\n-    layer_test(convolutional.Conv1D,\n-               input_data=np.reshape(np.arange(4, dtype='float32'), (1, 4, 1)),\n-               kwargs={\n-                   'filters': 1,\n-                   'kernel_size': 2,\n-                   'dilation_rate': 1,\n-                   'padding': 'valid',\n-                   'kernel_initializer': 'ones',\n-                   'use_bias': False,\n-               },\n-               expected_output=[[[1], [3], [5]]]\n-               )\n-\n-    # Causal dilated with larger kernel size:\n-    layer_test(convolutional.Conv1D,\n-               input_data=np.reshape(np.arange(10, dtype='float32'), (1, 10, 1)),\n-               kwargs={\n-                   'filters': 1,\n-                   'kernel_size': 3,\n-                   'dilation_rate': 2,\n-                   'padding': 'causal',\n-                   'kernel_initializer': 'ones',\n-                   'use_bias': False,\n-               },\n-               expected_output=np.float32(\n-                   [[[0], [1], [2], [4], [6], [9], [12], [15], [18], [21]]])\n+@pytest.mark.parametrize(\n+    'layer_kwargs,input_length,expected_output',\n+    [\n+        # Causal\n+        ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'causal',\n+          'kernel_initializer': 'ones', 'use_bias': False},\n+         4, [[[0], [1], [3], [5]]]),\n+        # Non-causal\n+        ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'valid',\n+          'kernel_initializer': 'ones', 'use_bias': False},\n+         4, [[[1], [3], [5]]]),\n+        # Causal dilated with larger kernel size\n+        ({'filters': 1, 'kernel_size': 3, 'dilation_rate': 2, 'padding': 'causal',\n+          'kernel_initializer': 'ones', 'use_bias': False},\n+         10, np.float32([[[0], [1], [2], [4], [6], [9], [12], [15], [18], [21]]])),\n+    ]\n )\n+def test_causal_dilated_conv(layer_kwargs, input_length, expected_output):\n+    input_data = np.reshape(np.arange(input_length, dtype='float32'),\n+                            (1, input_length, 1))\n+    layer_test(convolutional.Conv1D, input_data=input_data,\n+               kwargs=layer_kwargs, expected_output=expected_output)\n \n \n @keras_test\n-def test_conv_1d():\n+@pytest.mark.parametrize(\n+    'padding,strides',\n+    [(padding, strides)\n+     for padding in _convolution_paddings\n+     for strides in [1, 2]\n+     if not (padding == 'same' and strides != 1)]\n+)\n+def test_conv_1d(padding, strides):\n     batch_size = 2\n     steps = 8\n     input_dim = 2\n     kernel_size = 3\n     filters = 3\n \n-    for padding in _convolution_paddings:\n-        for strides in [1, 2]:\n-            if padding == 'same' and strides != 1:\n-                continue\n     layer_test(convolutional.Conv1D,\n                kwargs={'filters': filters,\n                        'kernel_size': kernel_size,\n@@ -97,9 +77,18 @@ def test_conv_1d():\n                        'strides': strides},\n                input_shape=(batch_size, steps, input_dim))\n \n-    # Test dilation\n-    if K.backend() != 'cntk':\n-        # cntk only support dilated conv on GPU\n+\n+@keras_test\n+@pytest.mark.skipif((K.backend() == 'cntk'),\n+                    reason='cntk only support dilated conv on GPU')\n+def test_conv_1d_dilation():\n+    batch_size = 2\n+    steps = 8\n+    input_dim = 2\n+    kernel_size = 3\n+    filters = 3\n+    padding = _convolution_paddings[-1]\n+\n     layer_test(convolutional.Conv1D,\n                kwargs={'filters': filters,\n                        'kernel_size': kernel_size,\n@@ -107,7 +96,15 @@ def test_conv_1d():\n                        'dilation_rate': 2},\n                input_shape=(batch_size, steps, input_dim))\n \n-    # Test channels_first\n+\n+@keras_test\n+def test_conv_1d_channels_first():\n+    batch_size = 2\n+    steps = 8\n+    input_dim = 2\n+    kernel_size = 3\n+    filters = 3\n+\n     layer_test(convolutional.Conv1D,\n                kwargs={'filters': filters,\n                        'kernel_size': kernel_size,\n@@ -116,31 +113,14 @@ def test_conv_1d():\n \n \n @keras_test\n-def test_maxpooling_1d():\n-    for padding in ['valid', 'same']:\n-        for stride in [1, 2]:\n-            for data_format in ['channels_first', 'channels_last']:\n-                layer_test(convolutional.MaxPooling1D,\n-                           kwargs={'strides': stride,\n-                                   'padding': padding,\n-                                   'data_format': data_format},\n-                           input_shape=(3, 5, 4))\n-\n-\n-@keras_test\n-def test_averagepooling_1d():\n-    for padding in ['valid', 'same']:\n-        for stride in [1, 2]:\n-            for data_format in ['channels_first', 'channels_last']:\n-                layer_test(convolutional.AveragePooling1D,\n-                           kwargs={'strides': stride,\n-                                   'padding': padding,\n-                                   'data_format': data_format},\n-                           input_shape=(3, 5, 4))\n-\n-\n-@keras_test\n-def test_convolution_2d():\n+@pytest.mark.parametrize(\n+    'strides,padding',\n+    [(strides, padding)\n+     for padding in _convolution_paddings\n+     for strides in [(1, 1), (2, 2)]\n+     if not (padding == 'same' and strides != (1, 1))]\n+)\n+def test_convolution_2d(strides, padding):\n     num_samples = 2\n     filters = 2\n     stack_size = 3\n@@ -148,11 +128,6 @@ def test_convolution_2d():\n     num_row = 7\n     num_col = 6\n \n-    for padding in _convolution_paddings:\n-        for strides in [(1, 1), (2, 2)]:\n-            if padding == 'same' and strides != (1, 1):\n-                continue\n-\n     layer_test(convolutional.Conv2D,\n                kwargs={'filters': filters,\n                        'kernel_size': kernel_size,\n@@ -161,6 +136,17 @@ def test_convolution_2d():\n                        'data_format': 'channels_first'},\n                input_shape=(num_samples, stack_size, num_row, num_col))\n \n+\n+@keras_test\n+def test_convolution_2d_channels_last():\n+    num_samples = 2\n+    filters = 2\n+    stack_size = 3\n+    num_row = 7\n+    num_col = 6\n+    padding = 'valid'\n+    strides = (2, 2)\n+\n     layer_test(convolutional.Conv2D,\n                kwargs={'filters': filters,\n                        'kernel_size': 3,\n@@ -175,6 +161,19 @@ def test_convolution_2d():\n                        'strides': strides},\n                input_shape=(num_samples, num_row, num_col, stack_size))\n \n+\n+@keras_test\n+@pytest.mark.skipif((K.backend() == 'cntk'),\n+                    reason=\"cntk only supports dilated conv on GPU\")\n+def test_convolution_2d_dilation():\n+    num_samples = 2\n+    filters = 2\n+    stack_size = 3\n+    kernel_size = (3, 2)\n+    num_row = 7\n+    num_col = 6\n+    padding = 'valid'\n+\n     # Test dilation\n     if K.backend() != 'cntk':\n         # cntk only support dilated conv on GPU\n@@ -185,7 +184,13 @@ def test_convolution_2d():\n                            'dilation_rate': (2, 2)},\n                    input_shape=(num_samples, num_row, num_col, stack_size))\n \n-    # Test invalid use case\n+\n+@keras_test\n+def test_convolution_2d_invalid():\n+    filters = 2\n+    padding = _convolution_paddings[-1]\n+    kernel_size = (3, 2)\n+\n     with pytest.raises(ValueError):\n         model = Sequential([convolutional.Conv2D(\n             filters=filters, kernel_size=kernel_size, padding=padding,\n@@ -193,20 +198,22 @@ def test_convolution_2d():\n \n \n @keras_test\n-def test_conv2d_transpose():\n+@pytest.mark.parametrize(\n+    'padding,out_padding,strides',\n+    [(padding, out_padding, strides)\n+     for padding in _convolution_paddings\n+     for out_padding in [None, (0, 0), (1, 1)]\n+     for strides in [(1, 1), (2, 2)]\n+     if (not (padding == 'same' and strides != (1, 1))\n+         and not(strides == (1, 1) and out_padding == (1, 1)))]\n+)\n+def test_conv2d_transpose(padding, out_padding, strides):\n     num_samples = 2\n     filters = 2\n     stack_size = 3\n     num_row = 5\n     num_col = 6\n \n-    for padding in _convolution_paddings:\n-        for out_padding in [None, (0, 0), (1, 1)]:\n-            for strides in [(1, 1), (2, 2)]:\n-                if padding == 'same' and strides != (1, 1):\n-                    continue\n-                if strides == (1, 1) and out_padding == (1, 1):\n-                    continue\n     layer_test(convolutional.Conv2DTranspose,\n                kwargs={'filters': filters,\n                        'kernel_size': 3,\n@@ -217,6 +224,17 @@ def test_conv2d_transpose():\n                input_shape=(num_samples, num_row, num_col, stack_size),\n                fixed_batch_size=True)\n \n+\n+@keras_test\n+def test_conv2d_transpose_channels_first():\n+    num_samples = 2\n+    filters = 2\n+    stack_size = 3\n+    num_row = 5\n+    num_col = 6\n+    padding = 'valid'\n+    strides = (2, 2)\n+\n     layer_test(convolutional.Conv2DTranspose,\n                kwargs={'filters': filters,\n                        'kernel_size': 3,\n@@ -232,7 +250,15 @@ def test_conv2d_transpose():\n                input_shape=(num_samples, stack_size, num_row, num_col),\n                fixed_batch_size=True)\n \n-    # Test invalid use case\n+\n+@keras_test\n+def test_conv2d_transpose_invalid():\n+    filters = 2\n+    stack_size = 3\n+    num_row = 5\n+    num_col = 6\n+    padding = 'valid'\n+\n     with pytest.raises(ValueError):\n         model = Sequential([convolutional.Conv2DTranspose(\n             filters=filters,\n@@ -241,8 +267,7 @@ def test_conv2d_transpose():\n             use_bias=True,\n             batch_input_shape=(None, None, 5, None))])\n \n-    # Test invalid output padding for given stride. Output padding equal\n-    # to stride\n+    # Test invalid output padding for given stride. Output padding equal to stride\n     with pytest.raises(ValueError):\n         model = Sequential([convolutional.Conv2DTranspose(\n             filters=filters,\n@@ -251,6 +276,7 @@ def test_conv2d_transpose():\n             output_padding=(0, 3),\n             strides=(1, 3),\n             batch_input_shape=(None, num_row, num_col, stack_size))])\n+\n     # Output padding greater than stride\n     with pytest.raises(ValueError):\n         model = Sequential([convolutional.Conv2DTranspose(\n@@ -263,23 +289,23 @@ def test_conv2d_transpose():\n \n \n @keras_test\n-def test_separable_conv_1d():\n+@pytest.mark.parametrize(\n+    'padding,strides,multiplier,dilation_rate',\n+    [(padding, strides, multiplier, dilation_rate)\n+     for padding in _convolution_paddings\n+     for strides in [1, 2]\n+     for multiplier in [1, 2]\n+     for dilation_rate in [1, 2]\n+     if (not (padding == 'same' and strides != 1)\n+         and not (dilation_rate != 1 and strides != 1)\n+         and not (dilation_rate != 1 and K.backend() == 'cntk'))]\n+)\n+def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):\n     num_samples = 2\n     filters = 6\n     stack_size = 3\n     num_step = 9\n \n-    for padding in _convolution_paddings:\n-        for strides in [1, 2]:\n-            for multiplier in [1, 2]:\n-                for dilation_rate in [1, 2]:\n-                    if padding == 'same' and strides != 1:\n-                        continue\n-                    if dilation_rate != 1 and strides != 1:\n-                        continue\n-                    if dilation_rate != 1 and K.backend() == 'cntk':\n-                        continue\n-\n     layer_test(convolutional.SeparableConv1D,\n                kwargs={'filters': filters,\n                        'kernel_size': 3,\n@@ -289,6 +315,16 @@ def test_separable_conv_1d():\n                        'dilation_rate': dilation_rate},\n                input_shape=(num_samples, num_step, stack_size))\n \n+\n+@keras_test\n+def test_separable_conv_1d_additional_args():\n+    num_samples = 2\n+    filters = 6\n+    stack_size = 3\n+    num_step = 9\n+    padding = 'valid'\n+    multiplier = 2\n+\n     layer_test(convolutional.SeparableConv1D,\n                kwargs={'filters': filters,\n                        'kernel_size': 3,\n@@ -306,7 +342,11 @@ def test_separable_conv_1d():\n                        'depth_multiplier': multiplier},\n                input_shape=(num_samples, stack_size, num_step))\n \n-    # Test invalid use case\n+\n+@keras_test\n+def test_separable_conv_1d_invalid():\n+    filters = 6\n+    padding = 'valid'\n     with pytest.raises(ValueError):\n         model = Sequential([convolutional.SeparableConv1D(\n             filters=filters, kernel_size=3, padding=padding,\n@@ -314,26 +354,25 @@ def test_separable_conv_1d():\n \n \n @keras_test\n-def test_separable_conv_2d():\n+@pytest.mark.parametrize(\n+    'padding,strides,multiplier,dilation_rate',\n+    [(padding, strides, multiplier, dilation_rate)\n+     for padding in _convolution_paddings\n+     for strides in [(1, 1), (2, 2)]\n+     for multiplier in [1, 2]\n+     for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]\n+     if (not (padding == 'same' and strides != (1, 1))\n+         and not (dilation_rate != (1, 1) and strides != (1, 1))\n+         and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])\n+         and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]\n+)\n+def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):\n     num_samples = 2\n     filters = 6\n     stack_size = 3\n     num_row = 7\n     num_col = 6\n \n-    for padding in _convolution_paddings:\n-        for strides in [(1, 1), (2, 2)]:\n-            for multiplier in [1, 2]:\n-                for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]:\n-                    if padding == 'same' and strides != (1, 1):\n-                        continue\n-                    if dilation_rate != (1, 1) and strides != (1, 1):\n-                        continue\n-                    if dilation_rate != (1, 1) and multiplier == dilation_rate[0]:\n-                        continue\n-                    if dilation_rate != (1, 1) and K.backend() == 'cntk':\n-                        continue\n-\n     layer_test(\n         convolutional.SeparableConv2D,\n         kwargs={'filters': filters,\n@@ -344,6 +383,18 @@ def test_separable_conv_2d():\n                 'dilation_rate': dilation_rate},\n         input_shape=(num_samples, num_row, num_col, stack_size))\n \n+\n+@keras_test\n+def test_separable_conv_2d_additional_args():\n+    num_samples = 2\n+    filters = 6\n+    stack_size = 3\n+    num_row = 7\n+    num_col = 6\n+    padding = 'valid'\n+    strides = (2, 2)\n+    multiplier = 2\n+\n     layer_test(convolutional.SeparableConv2D,\n                kwargs={'filters': filters,\n                        'kernel_size': 3,\n@@ -360,7 +411,11 @@ def test_separable_conv_2d():\n                        'depth_multiplier': multiplier},\n                input_shape=(num_samples, stack_size, num_row, num_col))\n \n-    # Test invalid use case\n+\n+@keras_test\n+def test_separable_conv_2d_invalid():\n+    filters = 6\n+    padding = 'valid'\n     with pytest.raises(ValueError):\n         model = Sequential([convolutional.SeparableConv2D(\n             filters=filters, kernel_size=3, padding=padding,\n@@ -368,18 +423,20 @@ def test_separable_conv_2d():\n \n \n @keras_test\n-def test_depthwise_conv_2d():\n+@pytest.mark.parametrize(\n+    'padding,strides,multiplier',\n+    [(padding, strides, multiplier)\n+     for padding in _convolution_paddings\n+     for strides in [(1, 1), (2, 2)]\n+     for multiplier in [1, 2]\n+     if not (padding == 'same' and strides != (1, 1))]\n+)\n+def test_depthwise_conv_2d(padding, strides, multiplier):\n     num_samples = 2\n     stack_size = 3\n     num_row = 7\n     num_col = 6\n \n-    for padding in _convolution_paddings:\n-        for strides in [(1, 1), (2, 2)]:\n-            for multiplier in [1, 2]:\n-                if padding == 'same' and strides != (1, 1):\n-                    continue\n-\n     layer_test(convolutional.DepthwiseConv2D,\n                kwargs={'kernel_size': (3, 3),\n                        'padding': padding,\n@@ -390,6 +447,17 @@ def test_depthwise_conv_2d():\n                             num_col,\n                             stack_size))\n \n+\n+@keras_test\n+def test_depthwise_conv_2d_additional_args():\n+    num_samples = 2\n+    stack_size = 3\n+    num_row = 7\n+    num_col = 6\n+    padding = 'valid'\n+    strides = (2, 2)\n+    multiplier = 2\n+\n     layer_test(convolutional.DepthwiseConv2D,\n                kwargs={'kernel_size': 3,\n                        'padding': padding,\n@@ -404,7 +472,10 @@ def test_depthwise_conv_2d():\n                        'depth_multiplier': multiplier},\n                input_shape=(num_samples, stack_size, num_row, num_col))\n \n-    # Test invalid use case\n+\n+@keras_test\n+def test_depthwise_conv_2d_invalid():\n+    padding = 'valid'\n     with pytest.raises(ValueError):\n         Sequential([convolutional.DepthwiseConv2D(\n             kernel_size=3,\n@@ -413,96 +484,14 @@ def test_depthwise_conv_2d():\n \n \n @keras_test\n-def test_globalpooling_1d():\n-    for data_format in ['channels_first', 'channels_last']:\n-        layer_test(pooling.GlobalMaxPooling1D,\n-                   kwargs={'data_format': data_format},\n-                   input_shape=(3, 4, 5))\n-        layer_test(pooling.GlobalAveragePooling1D,\n-                   kwargs={'data_format': data_format},\n-                   input_shape=(3, 4, 5))\n-\n-\n-@keras_test\n-def test_globalpooling_1d_supports_masking():\n-    # Test GlobalAveragePooling1D supports masking\n-    model = Sequential()\n-    model.add(Masking(mask_value=0., input_shape=(3, 4)))\n-    model.add(pooling.GlobalAveragePooling1D())\n-    model.compile(loss='mae', optimizer='adam')\n-\n-    model_input = np.random.randint(low=1, high=5, size=(2, 3, 4))\n-    model_input[0, 1:, :] = 0\n-    output = model.predict(model_input)\n-    assert np.array_equal(output[0], model_input[0, 0, :])\n-\n-\n-@keras_test\n-def test_globalpooling_2d():\n-    layer_test(pooling.GlobalMaxPooling2D,\n-               kwargs={'data_format': 'channels_first'},\n-               input_shape=(3, 4, 5, 6))\n-    layer_test(pooling.GlobalMaxPooling2D,\n-               kwargs={'data_format': 'channels_last'},\n-               input_shape=(3, 5, 6, 4))\n-    layer_test(pooling.GlobalAveragePooling2D,\n-               kwargs={'data_format': 'channels_first'},\n-               input_shape=(3, 4, 5, 6))\n-    layer_test(pooling.GlobalAveragePooling2D,\n-               kwargs={'data_format': 'channels_last'},\n-               input_shape=(3, 5, 6, 4))\n-\n-\n-@keras_test\n-def test_globalpooling_3d():\n-    layer_test(pooling.GlobalMaxPooling3D,\n-               kwargs={'data_format': 'channels_first'},\n-               input_shape=(3, 4, 3, 4, 3))\n-    layer_test(pooling.GlobalMaxPooling3D,\n-               kwargs={'data_format': 'channels_last'},\n-               input_shape=(3, 4, 3, 4, 3))\n-    layer_test(pooling.GlobalAveragePooling3D,\n-               kwargs={'data_format': 'channels_first'},\n-               input_shape=(3, 4, 3, 4, 3))\n-    layer_test(pooling.GlobalAveragePooling3D,\n-               kwargs={'data_format': 'channels_last'},\n-               input_shape=(3, 4, 3, 4, 3))\n-\n-\n-@keras_test\n-def test_maxpooling_2d():\n-    pool_size = (3, 3)\n-\n-    for strides in [(1, 1), (2, 2)]:\n-        layer_test(convolutional.MaxPooling2D,\n-                   kwargs={'strides': strides,\n-                           'padding': 'valid',\n-                           'pool_size': pool_size},\n-                   input_shape=(3, 5, 6, 4))\n-\n-\n-@keras_test\n-def test_averagepooling_2d():\n-    layer_test(convolutional.AveragePooling2D,\n-               kwargs={'strides': (2, 2),\n-                       'padding': 'same',\n-                       'pool_size': (2, 2)},\n-               input_shape=(3, 5, 6, 4))\n-    layer_test(convolutional.AveragePooling2D,\n-               kwargs={'strides': (2, 2),\n-                       'padding': 'valid',\n-                       'pool_size': (3, 3)},\n-               input_shape=(3, 5, 6, 4))\n-    layer_test(convolutional.AveragePooling2D,\n-               kwargs={'strides': (1, 1),\n-                       'padding': 'valid',\n-                       'pool_size': (2, 2),\n-                       'data_format': 'channels_first'},\n-               input_shape=(3, 4, 5, 6))\n-\n-\n-@keras_test\n-def test_convolution_3d():\n+@pytest.mark.parametrize(\n+    'padding,strides',\n+    [(padding, strides)\n+     for padding in _convolution_paddings\n+     for strides in [(1, 1, 1), (2, 2, 2)]\n+     if not (padding == 'same' and strides != (1, 1, 1))]\n+)\n+def test_convolution_3d(padding, strides):\n     num_samples = 2\n     filters = 2\n     stack_size = 3\n@@ -511,11 +500,6 @@ def test_convolution_3d():\n     input_len_dim2 = 8\n     input_len_dim3 = 8\n \n-    for padding in _convolution_paddings:\n-        for strides in [(1, 1, 1), (2, 2, 2)]:\n-            if padding == 'same' and strides != (1, 1, 1):\n-                continue\n-\n     layer_test(convolutional.Convolution3D,\n                kwargs={'filters': filters,\n                        'kernel_size': 3,\n@@ -525,6 +509,19 @@ def test_convolution_3d():\n                             input_len_dim1, input_len_dim2, input_len_dim3,\n                             stack_size))\n \n+\n+@keras_test\n+def test_convolution_3d_additional_args():\n+    num_samples = 2\n+    filters = 2\n+    stack_size = 3\n+    padding = 'valid'\n+    strides = (2, 2, 2)\n+\n+    input_len_dim1 = 9\n+    input_len_dim2 = 8\n+    input_len_dim3 = 8\n+\n     layer_test(convolutional.Convolution3D,\n                kwargs={'filters': filters,\n                        'kernel_size': (1, 2, 3),\n@@ -542,21 +539,23 @@ def test_convolution_3d():\n \n \n @keras_test\n-def test_conv3d_transpose():\n+@pytest.mark.parametrize(\n+    'padding,out_padding,strides,data_format',\n+    [(padding, out_padding, strides, data_format)\n+     for padding in _convolution_paddings\n+     for out_padding in [None, (0, 0, 0), (1, 1, 1)]\n+     for strides in [(1, 1, 1), (2, 2, 2)]\n+     for data_format in ['channels_first', 'channels_last']\n+     if (not (padding == 'same' and strides != (1, 1, 1))\n+         and not (strides == (1, 1, 1) and out_padding == (1, 1, 1)))]\n+)\n+def test_conv3d_transpose(padding, out_padding, strides, data_format):\n     filters = 2\n     stack_size = 3\n     num_depth = 7\n     num_row = 5\n     num_col = 6\n \n-    for padding in _convolution_paddings:\n-        for out_padding in [None, (0, 0, 0), (1, 1, 1)]:\n-            for strides in [(1, 1, 1), (2, 2, 2)]:\n-                for data_format in ['channels_first', 'channels_last']:\n-                    if padding == 'same' and strides != (1, 1, 1):\n-                        continue\n-                    if strides == (1, 1, 1) and out_padding == (1, 1, 1):\n-                        continue\n     layer_test(\n         convolutional.Conv3DTranspose,\n         kwargs={'filters': filters,\n@@ -568,6 +567,17 @@ def test_conv3d_transpose():\n         input_shape=(None, num_depth, num_row, num_col, stack_size),\n         fixed_batch_size=True)\n \n+\n+@keras_test\n+def test_conv3d_transpose_additional_args():\n+    filters = 2\n+    stack_size = 3\n+    num_depth = 7\n+    num_row = 5\n+    num_col = 6\n+    padding = 'valid'\n+    strides = (2, 2, 2)\n+\n     layer_test(convolutional.Conv3DTranspose,\n                kwargs={'filters': filters,\n                        'kernel_size': 3,\n@@ -584,6 +594,16 @@ def test_conv3d_transpose():\n                input_shape=(None, stack_size, num_depth, num_row, num_col),\n                fixed_batch_size=True)\n \n+\n+@keras_test\n+def test_conv3d_transpose_invalid():\n+    filters = 2\n+    stack_size = 3\n+    num_depth = 7\n+    num_row = 5\n+    num_col = 6\n+    padding = 'valid'\n+\n     # Test invalid use case\n     with pytest.raises(ValueError):\n         model = Sequential([convolutional.Conv3DTranspose(\n@@ -602,6 +622,7 @@ def test_conv3d_transpose():\n             output_padding=(0, 3, 3),\n             strides=(1, 3, 4),\n             batch_input_shape=(None, num_depth, num_row, num_col, stack_size))])\n+\n     # Output padding greater than stride\n     with pytest.raises(ValueError):\n         model = Sequential([convolutional.Conv3DTranspose(\n@@ -613,40 +634,6 @@ def test_conv3d_transpose():\n             batch_input_shape=(None, num_depth, num_row, num_col, stack_size))])\n \n \n-@keras_test\n-def test_maxpooling_3d():\n-    pool_size = (3, 3, 3)\n-\n-    layer_test(convolutional.MaxPooling3D,\n-               kwargs={'strides': 2,\n-                       'padding': 'valid',\n-                       'pool_size': pool_size},\n-               input_shape=(3, 11, 12, 10, 4))\n-    layer_test(convolutional.MaxPooling3D,\n-               kwargs={'strides': 3,\n-                       'padding': 'valid',\n-                       'data_format': 'channels_first',\n-                       'pool_size': pool_size},\n-               input_shape=(3, 4, 11, 12, 10))\n-\n-\n-@keras_test\n-def test_averagepooling_3d():\n-    pool_size = (3, 3, 3)\n-\n-    layer_test(convolutional.AveragePooling3D,\n-               kwargs={'strides': 2,\n-                       'padding': 'valid',\n-                       'pool_size': pool_size},\n-               input_shape=(3, 11, 12, 10, 4))\n-    layer_test(convolutional.AveragePooling3D,\n-               kwargs={'strides': 3,\n-                       'padding': 'valid',\n-                       'data_format': 'channels_first',\n-                       'pool_size': pool_size},\n-               input_shape=(3, 4, 11, 12, 10))\n-\n-\n @keras_test\n def test_zero_padding_1d():\n     num_samples = 2\n@@ -685,26 +672,37 @@ def test_zero_padding_1d():\n \n \n @keras_test\n-def test_zero_padding_2d():\n+@pytest.mark.parametrize(\n+    'data_format,padding',\n+    [(data_format, padding)\n+     for data_format in ['channels_first', 'channels_last']\n+     for padding in [(2, 2), ((1, 2), (3, 4))]]\n+)\n+def test_zero_padding_2d(data_format, padding):\n     num_samples = 2\n     stack_size = 2\n     input_num_row = 4\n     input_num_col = 5\n-    for data_format in ['channels_first', 'channels_last']:\n+\n     if data_format == 'channels_last':\n         inputs = np.ones((num_samples, input_num_row, input_num_col, stack_size))\n     else:\n         inputs = np.ones((num_samples, stack_size, input_num_row, input_num_col))\n \n-        # basic test\n     layer_test(convolutional.ZeroPadding2D,\n-                   kwargs={'padding': (2, 2), 'data_format': data_format},\n-                   input_shape=inputs.shape)\n-        layer_test(convolutional.ZeroPadding2D,\n-                   kwargs={'padding': ((1, 2), (3, 4)), 'data_format': data_format},\n+               kwargs={'padding': padding, 'data_format': data_format},\n                input_shape=inputs.shape)\n \n-        # correctness test\n+\n+@keras_test\n+def test_zero_padding_2d_correctness():\n+    num_samples = 2\n+    stack_size = 2\n+    input_num_row = 4\n+    input_num_col = 5\n+    inputs = np.ones((num_samples, stack_size, input_num_row, input_num_col))\n+\n+    for data_format in ['channels_first', 'channels_last']:\n         layer = convolutional.ZeroPadding2D(padding=(2, 2),\n                                             data_format=data_format)\n         layer.build(inputs.shape)\n@@ -748,28 +746,40 @@ def test_zero_padding_2d():\n             assert_allclose(np_output[:, :, 1:-2, 3:-4], 1.)\n \n \n-def test_zero_padding_3d():\n+@keras_test\n+@pytest.mark.parametrize(\n+    'data_format,padding',\n+    [(data_format, padding)\n+     for data_format in ['channels_first', 'channels_last']\n+     for padding in [(2, 2, 2), ((1, 2), (3, 4), (0, 2))]]\n+)\n+def test_zero_padding_3d(data_format, padding):\n     num_samples = 2\n     stack_size = 2\n     input_len_dim1 = 4\n     input_len_dim2 = 5\n     input_len_dim3 = 3\n-\n     inputs = np.ones((num_samples,\n                      input_len_dim1, input_len_dim2, input_len_dim3,\n                      stack_size))\n \n-    # basic test\n-    for data_format in ['channels_first', 'channels_last']:\n     layer_test(convolutional.ZeroPadding3D,\n-                   kwargs={'padding': (2, 2, 2), 'data_format': data_format},\n-                   input_shape=inputs.shape)\n-        layer_test(convolutional.ZeroPadding3D,\n-                   kwargs={'padding': ((1, 2), (3, 4), (0, 2)),\n-                           'data_format': data_format},\n+               kwargs={'padding': padding, 'data_format': data_format},\n                input_shape=inputs.shape)\n \n-        # correctness test\n+\n+@keras_test\n+def test_zero_padding_3d_correctness():\n+    num_samples = 2\n+    stack_size = 2\n+    input_len_dim1 = 4\n+    input_len_dim2 = 5\n+    input_len_dim3 = 3\n+    inputs = np.ones((num_samples,\n+                      input_len_dim1, input_len_dim2, input_len_dim3,\n+                      stack_size))\n+\n+    for data_format in ['channels_first', 'channels_last']:\n         layer = convolutional.ZeroPadding3D(padding=(2, 2, 2),\n                                             data_format=data_format)\n         layer.build(inputs.shape)\n\n@@ -0,0 +1,163 @@\n+import numpy as np\n+import pytest\n+\n+from keras.utils.test_utils import keras_test, layer_test\n+from keras.layers import pooling\n+from keras.layers import Masking\n+from keras.layers import convolutional\n+from keras.models import Sequential\n+\n+\n+@keras_test\n+@pytest.mark.parametrize(\n+    'padding,stride,data_format',\n+    [(padding, stride, data_format)\n+     for padding in ['valid', 'same']\n+     for stride in [1, 2]\n+     for data_format in ['channels_first', 'channels_last']]\n+)\n+def test_maxpooling_1d(padding, stride, data_format):\n+    layer_test(convolutional.MaxPooling1D,\n+               kwargs={'strides': stride,\n+                       'padding': padding,\n+                       'data_format': data_format},\n+               input_shape=(3, 5, 4))\n+\n+\n+@keras_test\n+@pytest.mark.parametrize(\n+    'strides',\n+    [(1, 1), (2, 3)]\n+)\n+def test_maxpooling_2d(strides):\n+    pool_size = (3, 3)\n+    layer_test(convolutional.MaxPooling2D,\n+               kwargs={'strides': strides,\n+                       'padding': 'valid',\n+                       'pool_size': pool_size},\n+               input_shape=(3, 5, 6, 4))\n+\n+\n+@keras_test\n+@pytest.mark.parametrize(\n+    'strides,data_format,input_shape',\n+    [(2, None, (3, 11, 12, 10, 4)),\n+     (3, 'channels_first', (3, 4, 11, 12, 10))]\n+)\n+def test_maxpooling_3d(strides, data_format, input_shape):\n+    pool_size = (3, 3, 3)\n+    layer_test(convolutional.MaxPooling3D,\n+               kwargs={'strides': strides,\n+                       'padding': 'valid',\n+                       'data_format': data_format,\n+                       'pool_size': pool_size},\n+               input_shape=input_shape)\n+\n+\n+@keras_test\n+@pytest.mark.parametrize(\n+    'padding,stride,data_format',\n+    [(padding, stride, data_format)\n+     for padding in ['valid', 'same']\n+     for stride in [1, 2]\n+     for data_format in ['channels_first', 'channels_last']]\n+)\n+def test_averagepooling_1d(padding, stride, data_format):\n+    layer_test(convolutional.AveragePooling1D,\n+               kwargs={'strides': stride,\n+                       'padding': padding,\n+                       'data_format': data_format},\n+               input_shape=(3, 5, 4))\n+\n+\n+@keras_test\n+@pytest.mark.parametrize(\n+    'strides,padding,data_format,input_shape',\n+    [((2, 2), 'same', None, (3, 5, 6, 4)),\n+     ((2, 2), 'valid', None, (3, 5, 6, 4)),\n+     ((1, 1), 'valid', 'channels_first', (3, 4, 5, 6))]\n+)\n+def test_averagepooling_2d(strides, padding, data_format, input_shape):\n+    layer_test(convolutional.AveragePooling2D,\n+               kwargs={'strides': strides,\n+                       'padding': padding,\n+                       'pool_size': (2, 2),\n+                       'data_format': data_format},\n+               input_shape=input_shape)\n+\n+\n+@keras_test\n+@pytest.mark.parametrize(\n+    'strides,data_format,input_shape',\n+    [(2, None, (3, 11, 12, 10, 4)),\n+     (3, 'channels_first', (3, 4, 11, 12, 10))]\n+)\n+def test_averagepooling_3d(strides, data_format, input_shape):\n+    pool_size = (3, 3, 3)\n+\n+    layer_test(convolutional.AveragePooling3D,\n+               kwargs={'strides': strides,\n+                       'padding': 'valid',\n+                       'data_format': data_format,\n+                       'pool_size': pool_size},\n+               input_shape=input_shape)\n+\n+\n+@keras_test\n+@pytest.mark.parametrize(\n+    'data_format,pooling_class',\n+    [(data_format, pooling_class)\n+     for data_format in ['channels_first', 'channels_last']\n+     for pooling_class in [pooling.GlobalMaxPooling1D,\n+                           pooling.GlobalAveragePooling1D]]\n+)\n+def test_globalpooling_1d(data_format, pooling_class):\n+    layer_test(pooling_class,\n+               kwargs={'data_format': data_format},\n+               input_shape=(3, 4, 5))\n+\n+\n+@keras_test\n+def test_globalpooling_1d_supports_masking():\n+    # Test GlobalAveragePooling1D supports masking\n+    model = Sequential()\n+    model.add(Masking(mask_value=0., input_shape=(3, 4)))\n+    model.add(pooling.GlobalAveragePooling1D())\n+    model.compile(loss='mae', optimizer='adam')\n+\n+    model_input = np.random.randint(low=1, high=5, size=(2, 3, 4))\n+    model_input[0, 1:, :] = 0\n+    output = model.predict(model_input)\n+    assert np.array_equal(output[0], model_input[0, 0, :])\n+\n+\n+@keras_test\n+@pytest.mark.parametrize(\n+    'data_format,pooling_class',\n+    [(data_format, pooling_class)\n+     for data_format in ['channels_first', 'channels_last']\n+     for pooling_class in [pooling.GlobalMaxPooling2D,\n+                           pooling.GlobalAveragePooling2D]]\n+)\n+def test_globalpooling_2d(data_format, pooling_class):\n+    layer_test(pooling_class,\n+               kwargs={'data_format': data_format},\n+               input_shape=(3, 4, 5, 6))\n+\n+\n+@keras_test\n+@pytest.mark.parametrize(\n+    'data_format,pooling_class',\n+    [(data_format, pooling_class)\n+     for data_format in ['channels_first', 'channels_last']\n+     for pooling_class in [pooling.GlobalMaxPooling3D,\n+                           pooling.GlobalAveragePooling3D]]\n+)\n+def test_globalpooling_3d(data_format, pooling_class):\n+    layer_test(pooling_class,\n+               kwargs={'data_format': data_format},\n+               input_shape=(3, 4, 3, 4, 3))\n+\n+\n+if __name__ == '__main__':\n+    pytest.main([__file__])\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
