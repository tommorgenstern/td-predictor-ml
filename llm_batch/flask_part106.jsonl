{"custom_id": "flask#82c2e0366ce6b74a3786a64631ce58b85b3a7d4e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 105 | Lines Deleted: 122 | Files Changed: 13 | Hunks: 68 | Methods Changed: 38 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 227 | Churn Cumulative: 13474 | Contributors (this commit): 92 | Commits (past 90d): 70 | Contributors (cumulative): 164 | DMM Complexity: 0.15384615384615385\n\nDIFF:\n@@ -38,10 +38,11 @@ from .config import ConfigAttribute\n from .ctx import _AppCtxGlobals\n from .ctx import AppContext\n from .ctx import RequestContext\n-from .globals import _app_ctx_stack\n-from .globals import _request_ctx_stack\n+from .globals import _cv_app\n+from .globals import _cv_req\n from .globals import g\n from .globals import request\n+from .globals import request_ctx\n from .globals import session\n from .helpers import _split_blueprint_path\n from .helpers import get_debug_flag\n@@ -1554,10 +1555,10 @@ class Flask(Scaffold):\n            This no longer does the exception handling, this code was\n            moved to the new :meth:`full_dispatch_request`.\n         \"\"\"\n-        req = _request_ctx_stack.top.request\n+        req = request_ctx.request\n         if req.routing_exception is not None:\n             self.raise_routing_exception(req)\n-        rule = req.url_rule\n+        rule: Rule = req.url_rule  # type: ignore[assignment]\n         # if we provide automatic options for this URL and the\n         # request came with the OPTIONS method, reply automatically\n         if (\n@@ -1566,7 +1567,8 @@ class Flask(Scaffold):\n         ):\n             return self.make_default_options_response()\n         # otherwise dispatch to the handler for that endpoint\n-        return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)\n+        view_args: t.Dict[str, t.Any] = req.view_args  # type: ignore[assignment]\n+        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)\n \n     def full_dispatch_request(self) -> Response:\n         \"\"\"Dispatches the request and on top of that performs request\n@@ -1631,8 +1633,8 @@ class Flask(Scaffold):\n \n         .. versionadded:: 0.7\n         \"\"\"\n-        adapter = _request_ctx_stack.top.url_adapter\n-        methods = adapter.allowed_methods()\n+        adapter = request_ctx.url_adapter\n+        methods = adapter.allowed_methods()  # type: ignore[union-attr]\n         rv = self.response_class()\n         rv.allow.update(methods)\n         return rv\n@@ -1740,7 +1742,7 @@ class Flask(Scaffold):\n         .. versionadded:: 2.2\n             Moved from ``flask.url_for``, which calls this method.\n         \"\"\"\n-        req_ctx = _request_ctx_stack.top\n+        req_ctx = _cv_req.get(None)\n \n         if req_ctx is not None:\n             url_adapter = req_ctx.url_adapter\n@@ -1759,7 +1761,7 @@ class Flask(Scaffold):\n             if _external is None:\n                 _external = _scheme is not None\n         else:\n-            app_ctx = _app_ctx_stack.top\n+            app_ctx = _cv_app.get(None)\n \n             # If called by helpers.url_for, an app context is active,\n             # use its url_adapter. Otherwise, app.url_for was called\n@@ -1790,7 +1792,7 @@ class Flask(Scaffold):\n         self.inject_url_defaults(endpoint, values)\n \n         try:\n-            rv = url_adapter.build(\n+            rv = url_adapter.build(  # type: ignore[union-attr]\n                 endpoint,\n                 values,\n                 method=_method,\n@@ -2099,7 +2101,7 @@ class Flask(Scaffold):\n         :return: a new response object or the same, has to be an\n                  instance of :attr:`response_class`.\n         \"\"\"\n-        ctx = _request_ctx_stack.top\n+        ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]\n \n         for func in ctx._after_request_functions:\n             response = self.ensure_sync(func)(response)\n@@ -2305,8 +2307,8 @@ class Flask(Scaffold):\n             return response(environ, start_response)\n         finally:\n             if \"werkzeug.debug.preserve_context\" in environ:\n-                environ[\"werkzeug.debug.preserve_context\"](_app_ctx_stack.top)\n-                environ[\"werkzeug.debug.preserve_context\"](_request_ctx_stack.top)\n+                environ[\"werkzeug.debug.preserve_context\"](_cv_app.get())\n+                environ[\"werkzeug.debug.preserve_context\"](_cv_req.get())\n \n             if error is not None and self.should_ignore_error(error):\n                 error = None\n\n@@ -1051,13 +1051,11 @@ def shell_command() -> None:\n     without having to manually configure the application.\n     \"\"\"\n     import code\n-    from .globals import _app_ctx_stack\n \n-    app = _app_ctx_stack.top.app\n     banner = (\n         f\"Python {sys.version} on {sys.platform}\\n\"\n-        f\"App: {app.import_name} [{app.env}]\\n\"\n-        f\"Instance: {app.instance_path}\"\n+        f\"App: {current_app.import_name} [{current_app.env}]\\n\"\n+        f\"Instance: {current_app.instance_path}\"\n     )\n     ctx: dict = {}\n \n@@ -1068,7 +1066,7 @@ def shell_command() -> None:\n         with open(startup) as f:\n             eval(compile(f.read(), startup, \"exec\"), ctx)\n \n-    ctx.update(app.make_shell_context())\n+    ctx.update(current_app.make_shell_context())\n \n     # Site, customize, or startup script can set a hook to call when\n     # entering interactive mode. The default one sets up readline with\n\n@@ -7,10 +7,8 @@ from types import TracebackType\n from werkzeug.exceptions import HTTPException\n \n from . import typing as ft\n-from .globals import _app_ctx_stack\n from .globals import _cv_app\n from .globals import _cv_req\n-from .globals import _request_ctx_stack\n from .signals import appcontext_popped\n from .signals import appcontext_pushed\n \n@@ -106,9 +104,9 @@ class _AppCtxGlobals:\n         return iter(self.__dict__)\n \n     def __repr__(self) -> str:\n-        top = _app_ctx_stack.top\n-        if top is not None:\n-            return f\"<flask.g of {top.app.name!r}>\"\n+        ctx = _cv_app.get(None)\n+        if ctx is not None:\n+            return f\"<flask.g of '{ctx.app.name}'>\"\n         return object.__repr__(self)\n \n \n@@ -133,15 +131,15 @@ def after_this_request(f: ft.AfterRequestCallable) -> ft.AfterRequestCallable:\n \n     .. versionadded:: 0.9\n     \"\"\"\n-    top = _request_ctx_stack.top\n+    ctx = _cv_req.get(None)\n \n-    if top is None:\n+    if ctx is None:\n         raise RuntimeError(\n-            \"This decorator can only be used when a request context is\"\n-            \" active, such as within a view function.\"\n+            \"'after_this_request' can only be used when a request\"\n+            \" context is active, such as in a view function.\"\n         )\n \n-    top._after_request_functions.append(f)\n+    ctx._after_request_functions.append(f)\n     return f\n \n \n@@ -169,19 +167,19 @@ def copy_current_request_context(f: t.Callable) -> t.Callable:\n \n     .. versionadded:: 0.10\n     \"\"\"\n-    top = _request_ctx_stack.top\n+    ctx = _cv_req.get(None)\n \n-    if top is None:\n+    if ctx is None:\n         raise RuntimeError(\n-            \"This decorator can only be used when a request context is\"\n-            \" active, such as within a view function.\"\n+            \"'copy_current_request_context' can only be used when a\"\n+            \" request context is active, such as in a view function.\"\n         )\n \n-    reqctx = top.copy()\n+    ctx = ctx.copy()\n \n     def wrapper(*args, **kwargs):\n-        with reqctx:\n-            return reqctx.app.ensure_sync(f)(*args, **kwargs)\n+        with ctx:\n+            return ctx.app.ensure_sync(f)(*args, **kwargs)\n \n     return update_wrapper(wrapper, f)\n \n@@ -240,7 +238,7 @@ class AppContext:\n     def __init__(self, app: \"Flask\") -> None:\n         self.app = app\n         self.url_adapter = app.create_url_adapter(None)\n-        self.g = app.app_ctx_globals_class()\n+        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n         self._cv_tokens: t.List[contextvars.Token] = []\n \n     def push(self) -> None:\n@@ -311,14 +309,14 @@ class RequestContext:\n         self.app = app\n         if request is None:\n             request = app.request_class(environ)\n-        self.request = request\n+        self.request: Request = request\n         self.url_adapter = None\n         try:\n             self.url_adapter = app.create_url_adapter(self.request)\n         except HTTPException as e:\n             self.request.routing_exception = e\n-        self.flashes = None\n-        self.session = session\n+        self.flashes: t.Optional[t.List[t.Tuple[str, str]]] = None\n+        self.session: t.Optional[\"SessionMixin\"] = session\n         # Functions that should be executed after the request on the response\n         # object.  These will be called before the regular \"after_request\"\n         # functions.\n\n@@ -2,7 +2,7 @@ import typing as t\n \n from .app import Flask\n from .blueprints import Blueprint\n-from .globals import _request_ctx_stack\n+from .globals import request_ctx\n \n \n class UnexpectedUnicodeError(AssertionError, UnicodeError):\n@@ -116,9 +116,8 @@ def explain_template_loading_attempts(app: Flask, template, attempts) -> None:\n     info = [f\"Locating template {template!r}:\"]\n     total_found = 0\n     blueprint = None\n-    reqctx = _request_ctx_stack.top\n-    if reqctx is not None and reqctx.request.blueprint is not None:\n-        blueprint = reqctx.request.blueprint\n+    if request_ctx and request_ctx.request.blueprint is not None:\n+        blueprint = request_ctx.request.blueprint\n \n     for idx, (loader, srcobj, triple) in enumerate(attempts):\n         if isinstance(srcobj, Flask):\n\n@@ -12,9 +12,10 @@ import werkzeug.utils\n from werkzeug.exceptions import abort as _wz_abort\n from werkzeug.utils import redirect as _wz_redirect\n \n-from .globals import _request_ctx_stack\n+from .globals import _cv_req\n from .globals import current_app\n from .globals import request\n+from .globals import request_ctx\n from .globals import session\n from .signals import message_flashed\n \n@@ -110,11 +111,11 @@ def stream_with_context(\n         return update_wrapper(decorator, generator_or_function)  # type: ignore\n \n     def generator() -> t.Generator:\n-        ctx = _request_ctx_stack.top\n+        ctx = _cv_req.get(None)\n         if ctx is None:\n             raise RuntimeError(\n-                \"Attempted to stream with context but \"\n-                \"there was no context in the first place to keep around.\"\n+                \"'stream_with_context' can only be used when a request\"\n+                \" context is active, such as in a view function.\"\n             )\n         with ctx:\n             # Dummy sentinel.  Has to be inside the context block or we're\n@@ -377,11 +378,10 @@ def get_flashed_messages(\n     :param category_filter: filter of categories to limit return values.  Only\n                             categories in the list will be returned.\n     \"\"\"\n-    flashes = _request_ctx_stack.top.flashes\n+    flashes = request_ctx.flashes\n     if flashes is None:\n-        _request_ctx_stack.top.flashes = flashes = (\n-            session.pop(\"_flashes\") if \"_flashes\" in session else []\n-        )\n+        flashes = session.pop(\"_flashes\") if \"_flashes\" in session else []\n+        request_ctx.flashes = flashes\n     if category_filter:\n         flashes = list(filter(lambda f: f[0] in category_filter, flashes))\n     if not with_categories:\n\n@@ -5,8 +5,8 @@ from jinja2 import Environment as BaseEnvironment\n from jinja2 import Template\n from jinja2 import TemplateNotFound\n \n-from .globals import _app_ctx_stack\n-from .globals import _request_ctx_stack\n+from .globals import _cv_app\n+from .globals import _cv_req\n from .globals import current_app\n from .globals import request\n from .helpers import stream_with_context\n@@ -22,9 +22,9 @@ def _default_template_ctx_processor() -> t.Dict[str, t.Any]:\n     \"\"\"Default template context processor.  Injects `request`,\n     `session` and `g`.\n     \"\"\"\n-    reqctx = _request_ctx_stack.top\n-    appctx = _app_ctx_stack.top\n-    rv = {}\n+    appctx = _cv_app.get(None)\n+    reqctx = _cv_req.get(None)\n+    rv: t.Dict[str, t.Any] = {}\n     if appctx is not None:\n         rv[\"g\"] = appctx.g\n     if reqctx is not None:\n@@ -124,7 +124,8 @@ class DispatchingJinjaLoader(BaseLoader):\n         return list(result)\n \n \n-def _render(template: Template, context: dict, app: \"Flask\") -> str:\n+def _render(app: \"Flask\", template: Template, context: t.Dict[str, t.Any]) -> str:\n+    app.update_template_context(context)\n     before_render_template.send(app, template=template, context=context)\n     rv = template.render(context)\n     template_rendered.send(app, template=template, context=context)\n@@ -135,36 +136,27 @@ def render_template(\n     template_name_or_list: t.Union[str, Template, t.List[t.Union[str, Template]]],\n     **context: t.Any\n ) -> str:\n-    \"\"\"Renders a template from the template folder with the given\n-    context.\n+    \"\"\"Render a template by name with the given context.\n \n-    :param template_name_or_list: the name of the template to be\n-                                  rendered, or an iterable with template names\n-                                  the first one existing will be rendered\n-    :param context: the variables that should be available in the\n-                    context of the template.\n+    :param template_name_or_list: The name of the template to render. If\n+        a list is given, the first name to exist will be rendered.\n+    :param context: The variables to make available in the template.\n     \"\"\"\n-    ctx = _app_ctx_stack.top\n-    ctx.app.update_template_context(context)\n-    return _render(\n-        ctx.app.jinja_env.get_or_select_template(template_name_or_list),\n-        context,\n-        ctx.app,\n-    )\n+    app = current_app._get_current_object()  # type: ignore[attr-defined]\n+    template = app.jinja_env.get_or_select_template(template_name_or_list)\n+    return _render(app, template, context)\n \n \n def render_template_string(source: str, **context: t.Any) -> str:\n-    \"\"\"Renders a template from the given template source string\n-    with the given context. Template variables will be autoescaped.\n+    \"\"\"Render a template from the given source string with the given\n+    context.\n \n-    :param source: the source code of the template to be\n-                   rendered\n-    :param context: the variables that should be available in the\n-                    context of the template.\n+    :param source: The source code of the template to render.\n+    :param context: The variables to make available in the template.\n     \"\"\"\n-    ctx = _app_ctx_stack.top\n-    ctx.app.update_template_context(context)\n-    return _render(ctx.app.jinja_env.from_string(source), context, ctx.app)\n+    app = current_app._get_current_object()  # type: ignore[attr-defined]\n+    template = app.jinja_env.from_string(source)\n+    return _render(app, template, context)\n \n \n def _stream(\n\n@@ -163,7 +163,7 @@ class FlaskClient(Client):\n             # behavior.  It's important to not use the push and pop\n             # methods of the actual request context object since that would\n             # mean that cleanup handlers are called\n-            token = _cv_req.set(outer_reqctx)\n+            token = _cv_req.set(outer_reqctx)  # type: ignore[arg-type]\n             try:\n                 yield sess\n             finally:\n\n@@ -6,8 +6,8 @@ import textwrap\n import pytest\n from _pytest import monkeypatch\n \n-import flask\n-from flask import Flask as _Flask\n+from flask import Flask\n+from flask.globals import request_ctx\n \n \n @pytest.fixture(scope=\"session\", autouse=True)\n@@ -44,14 +44,13 @@ def _reset_os_environ(monkeypatch, _standard_os_environ):\n     monkeypatch._setitem.extend(_standard_os_environ)\n \n \n-class Flask(_Flask):\n-    testing = True\n-    secret_key = \"test key\"\n-\n-\n @pytest.fixture\n def app():\n     app = Flask(\"flask_test\", root_path=os.path.dirname(__file__))\n+    app.config.update(\n+        TESTING=True,\n+        SECRET_KEY=\"test key\",\n+    )\n     return app\n \n \n@@ -92,8 +91,10 @@ def leak_detector():\n     # make sure we're not leaking a request context since we are\n     # testing flask internally in debug mode in a few cases\n     leaks = []\n-    while flask._request_ctx_stack.top is not None:\n-        leaks.append(flask._request_ctx_stack.pop())\n+    while request_ctx:\n+        leaks.append(request_ctx._get_current_object())\n+        request_ctx.pop()\n+\n     assert leaks == []\n \n \n\n@@ -1,6 +1,8 @@\n import pytest\n \n import flask\n+from flask.globals import app_ctx\n+from flask.globals import request_ctx\n \n \n def test_basic_url_generation(app):\n@@ -29,14 +31,14 @@ def test_url_generation_without_context_fails():\n \n def test_request_context_means_app_context(app):\n     with app.test_request_context():\n-        assert flask.current_app._get_current_object() == app\n-    assert flask._app_ctx_stack.top is None\n+        assert flask.current_app._get_current_object() is app\n+    assert not flask.current_app\n \n \n def test_app_context_provides_current_app(app):\n     with app.app_context():\n-        assert flask.current_app._get_current_object() == app\n-    assert flask._app_ctx_stack.top is None\n+        assert flask.current_app._get_current_object() is app\n+    assert not flask.current_app\n \n \n def test_app_tearing_down(app):\n@@ -175,11 +177,11 @@ def test_context_refcounts(app, client):\n \n     @app.route(\"/\")\n     def index():\n-        with flask._app_ctx_stack.top:\n-            with flask._request_ctx_stack.top:\n+        with app_ctx:\n+            with request_ctx:\n                 pass\n-        env = flask._request_ctx_stack.top.request.environ\n-        assert env[\"werkzeug.request\"] is not None\n+\n+        assert flask.request.environ[\"werkzeug.request\"] is not None\n         return \"\"\n \n     res = client.get(\"/\")\n\n@@ -1110,10 +1110,6 @@ def test_enctype_debug_helper(app, client):\n     def index():\n         return flask.request.files[\"foo\"].filename\n \n-    # with statement is important because we leave an exception on the\n-    # stack otherwise and we want to ensure that this is not the case\n-    # to not negatively affect other tests.\n-    with client:\n     with pytest.raises(DebugFilesKeyError) as e:\n         client.post(\"/fail\", data={\"foo\": \"index.txt\"})\n     assert \"no file contents were transmitted\" in str(e.value)\n@@ -1548,30 +1544,22 @@ def test_server_name_subdomain():\n     assert rv.data == b\"subdomain\"\n \n \n-@pytest.mark.filterwarnings(\"ignore::pytest.PytestUnraisableExceptionWarning\")\n-@pytest.mark.filterwarnings(\"ignore::pytest.PytestUnhandledThreadExceptionWarning\")\n-def test_exception_propagation(app, client):\n-    def apprunner(config_key):\n+@pytest.mark.parametrize(\"key\", [\"TESTING\", \"PROPAGATE_EXCEPTIONS\", \"DEBUG\", None])\n+def test_exception_propagation(app, client, key):\n+    app.testing = False\n+\n     @app.route(\"/\")\n     def index():\n         1 // 0\n \n-        if config_key is not None:\n-            app.config[config_key] = True\n-            with pytest.raises(Exception):\n+    if key is not None:\n+        app.config[key] = True\n+\n+        with pytest.raises(ZeroDivisionError):\n             client.get(\"/\")\n     else:\n         assert client.get(\"/\").status_code == 500\n \n-    # we have to run this test in an isolated thread because if the\n-    # debug flag is set to true and an exception happens the context is\n-    # not torn down.  This causes other tests that run after this fail\n-    # when they expect no exception on the stack.\n-    for config_key in \"TESTING\", \"PROPAGATE_EXCEPTIONS\", \"DEBUG\", None:\n-        t = Thread(target=apprunner, args=(config_key,))\n-        t.start()\n-        t.join()\n-\n \n @pytest.mark.parametrize(\"debug\", [True, False])\n @pytest.mark.parametrize(\"use_debugger\", [True, False])\n\n@@ -3,6 +3,7 @@ import warnings\n import pytest\n \n import flask\n+from flask.globals import request_ctx\n from flask.sessions import SecureCookieSessionInterface\n from flask.sessions import SessionInterface\n \n@@ -116,7 +117,7 @@ def test_context_binding(app):\n         assert index() == \"Hello World!\"\n     with app.test_request_context(\"/meh\"):\n         assert meh() == \"http://localhost/meh\"\n-    assert flask._request_ctx_stack.top is None\n+    assert not flask.request\n \n \n def test_context_test(app):\n@@ -152,7 +153,7 @@ class TestGreenletContextCopying:\n         @app.route(\"/\")\n         def index():\n             flask.session[\"fizz\"] = \"buzz\"\n-            reqctx = flask._request_ctx_stack.top.copy()\n+            reqctx = request_ctx.copy()\n \n             def g():\n                 assert not flask.request\n\n@@ -1,4 +1,5 @@\n import flask\n+from flask.globals import request_ctx\n from flask.sessions import SessionInterface\n \n \n@@ -13,7 +14,7 @@ def test_open_session_with_endpoint():\n             pass\n \n         def open_session(self, app, request):\n-            flask._request_ctx_stack.top.match_request()\n+            request_ctx.match_request()\n             assert request.endpoint is not None\n \n     app = flask.Flask(__name__)\n\n@@ -5,6 +5,7 @@ import werkzeug\n import flask\n from flask import appcontext_popped\n from flask.cli import ScriptInfo\n+from flask.globals import _cv_req\n from flask.json import jsonify\n from flask.testing import EnvironBuilder\n from flask.testing import FlaskCliRunner\n@@ -399,4 +400,4 @@ def test_client_pop_all_preserved(app, req_ctx, client):\n     # close the response, releasing the context held by stream_with_context\n     rv.close()\n     # only req_ctx fixture should still be pushed\n-    assert flask._request_ctx_stack.top is req_ctx\n+    assert _cv_req.get(None) is req_ctx\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#e0dad454810dd081947d3ca2ff376c5096185698", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 45 | Lines Deleted: 50 | Files Changed: 4 | Hunks: 17 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 95 | Churn Cumulative: 5048 | Contributors (this commit): 33 | Commits (past 90d): 45 | Contributors (cumulative): 50 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1284,29 +1284,30 @@ class Flask(Scaffold):\n \n     @setupmethod\n     def teardown_appcontext(self, f: T_teardown) -> T_teardown:\n-        \"\"\"Registers a function to be called when the application context\n-        ends.  These functions are typically also called when the request\n-        context is popped.\n+        \"\"\"Registers a function to be called when the application\n+        context is popped. The application context is typically popped\n+        after the request context for each request, at the end of CLI\n+        commands, or after a manually pushed context ends.\n \n-        Example::\n+        .. code-block:: python\n \n-            ctx = app.app_context()\n-            ctx.push()\n+            with app.app_context():\n                 ...\n-            ctx.pop()\n \n-        When ``ctx.pop()`` is executed in the above example, the teardown\n-        functions are called just before the app context moves from the\n-        stack of active contexts.  This becomes relevant if you are using\n-        such constructs in tests.\n+        When the ``with`` block exits (or ``ctx.pop()`` is called), the\n+        teardown functions are called just before the app context is\n+        made inactive. Since a request context typically also manages an\n+        application context it would also be called when you pop a\n+        request context.\n \n-        Since a request context typically also manages an application\n-        context it would also be called when you pop a request context.\n+        When a teardown function was called because of an unhandled\n+        exception it will be passed an error object. If an\n+        :meth:`errorhandler` is registered, it will handle the exception\n+        and the teardown will not receive it.\n \n-        When a teardown function was called because of an unhandled exception\n-        it will be passed an error object. If an :meth:`errorhandler` is\n-        registered, it will handle the exception and the teardown will not\n-        receive it.\n+        Teardown functions must avoid raising exceptions. If they\n+        execute code that might fail they must surround that code with a\n+        ``try``/``except`` block and log any errors.\n \n         The return values of teardown functions are ignored.\n \n\n@@ -227,12 +227,10 @@ def has_app_context() -> bool:\n \n \n class AppContext:\n-    \"\"\"The application context binds an application object implicitly\n-    to the current thread or greenlet, similar to how the\n-    :class:`RequestContext` binds request information.  The application\n-    context is also implicitly created if a request context is created\n-    but the application is not on top of the individual application\n-    context.\n+    \"\"\"The app context contains application-specific information. An app\n+    context is created and pushed at the beginning of each request if\n+    one is not already active. An app context is also pushed when\n+    running CLI commands.\n     \"\"\"\n \n     def __init__(self, app: \"Flask\") -> None:\n@@ -278,10 +276,10 @@ class AppContext:\n \n \n class RequestContext:\n-    \"\"\"The request context contains all request relevant information.  It is\n-    created at the beginning of the request and pushed to the\n-    `_request_ctx_stack` and removed at the end of it.  It will create the\n-    URL adapter and request object for the WSGI environment provided.\n+    \"\"\"The request context contains per-request information. The Flask\n+    app creates and pushes it at the beginning of the request, then pops\n+    it at the end of the request. It will create the URL adapter and\n+    request object for the WSGI environment provided.\n \n     Do not attempt to use this class directly, instead use\n     :meth:`~flask.Flask.test_request_context` and\n\n@@ -574,30 +574,27 @@ class Scaffold:\n \n     @setupmethod\n     def teardown_request(self, f: T_teardown) -> T_teardown:\n-        \"\"\"Register a function to be run at the end of each request,\n-        regardless of whether there was an exception or not.  These functions\n-        are executed when the request context is popped, even if not an\n-        actual request was performed.\n+        \"\"\"Register a function to be called when the request context is\n+        popped. Typically this happens at the end of each request, but\n+        contexts may be pushed manually as well during testing.\n \n-        Example::\n+        .. code-block:: python\n \n-            ctx = app.test_request_context()\n-            ctx.push()\n+            with app.test_request_context():\n                 ...\n-            ctx.pop()\n \n-        When ``ctx.pop()`` is executed in the above example, the teardown\n-        functions are called just before the request context moves from the\n-        stack of active contexts.  This becomes relevant if you are using\n-        such constructs in tests.\n+        When the ``with`` block exits (or ``ctx.pop()`` is called), the\n+        teardown functions are called just before the request context is\n+        made inactive.\n \n-        Teardown functions must avoid raising exceptions. If\n-        they execute code that might fail they\n-        will have to surround the execution of that code with try/except\n-        statements and log any errors.\n+        When a teardown function was called because of an unhandled\n+        exception it will be passed an error object. If an\n+        :meth:`errorhandler` is registered, it will handle the exception\n+        and the teardown will not receive it.\n \n-        When a teardown function was called because of an exception it will\n-        be passed an error object.\n+        Teardown functions must avoid raising exceptions. If they\n+        execute code that might fail they must surround that code with a\n+        ``try``/``except`` block and log any errors.\n \n         The return values of teardown functions are ignored.\n         \"\"\"\n\n@@ -94,11 +94,10 @@ class EnvironBuilder(werkzeug.test.EnvironBuilder):\n \n \n class FlaskClient(Client):\n-    \"\"\"Works like a regular Werkzeug test client but has some knowledge about\n-    how Flask works to defer the cleanup of the request context stack to the\n-    end of a ``with`` body when used in a ``with`` statement.  For general\n-    information about how to use this class refer to\n-    :class:`werkzeug.test.Client`.\n+    \"\"\"Works like a regular Werkzeug test client but has knowledge about\n+    Flask's contexts to defer the cleanup of the request context until\n+    the end of a ``with`` block. For general information about how to\n+    use this class refer to :class:`werkzeug.test.Client`.\n \n     .. versionchanged:: 0.12\n        `app.test_client()` includes preset default environment, which can be\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#91044c4d769efa7f20455e1b70457a7da95c26d8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 25 | Lines Deleted: 25 | Files Changed: 7 | Hunks: 24 | Methods Changed: 12 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 50 | Churn Cumulative: 6424 | Contributors (this commit): 46 | Commits (past 90d): 57 | Contributors (cumulative): 72 | DMM Complexity: None\n\nDIFF:\n@@ -39,7 +39,7 @@ from .ctx import _AppCtxGlobals\n from .ctx import AppContext\n from .ctx import RequestContext\n from .globals import _cv_app\n-from .globals import _cv_req\n+from .globals import _cv_request\n from .globals import g\n from .globals import request\n from .globals import request_ctx\n@@ -1743,7 +1743,7 @@ class Flask(Scaffold):\n         .. versionadded:: 2.2\n             Moved from ``flask.url_for``, which calls this method.\n         \"\"\"\n-        req_ctx = _cv_req.get(None)\n+        req_ctx = _cv_request.get(None)\n \n         if req_ctx is not None:\n             url_adapter = req_ctx.url_adapter\n@@ -2309,7 +2309,7 @@ class Flask(Scaffold):\n         finally:\n             if \"werkzeug.debug.preserve_context\" in environ:\n                 environ[\"werkzeug.debug.preserve_context\"](_cv_app.get())\n-                environ[\"werkzeug.debug.preserve_context\"](_cv_req.get())\n+                environ[\"werkzeug.debug.preserve_context\"](_cv_request.get())\n \n             if error is not None and self.should_ignore_error(error):\n                 error = None\n\n@@ -8,7 +8,7 @@ from werkzeug.exceptions import HTTPException\n \n from . import typing as ft\n from .globals import _cv_app\n-from .globals import _cv_req\n+from .globals import _cv_request\n from .signals import appcontext_popped\n from .signals import appcontext_pushed\n \n@@ -131,7 +131,7 @@ def after_this_request(f: ft.AfterRequestCallable) -> ft.AfterRequestCallable:\n \n     .. versionadded:: 0.9\n     \"\"\"\n-    ctx = _cv_req.get(None)\n+    ctx = _cv_request.get(None)\n \n     if ctx is None:\n         raise RuntimeError(\n@@ -167,7 +167,7 @@ def copy_current_request_context(f: t.Callable) -> t.Callable:\n \n     .. versionadded:: 0.10\n     \"\"\"\n-    ctx = _cv_req.get(None)\n+    ctx = _cv_request.get(None)\n \n     if ctx is None:\n         raise RuntimeError(\n@@ -223,7 +223,7 @@ def has_app_context() -> bool:\n \n     .. versionadded:: 0.9\n     \"\"\"\n-    return _cv_req.get(None) is not None\n+    return _cv_request.get(None) is not None\n \n \n class AppContext:\n@@ -363,7 +363,7 @@ class RequestContext:\n         else:\n             app_ctx = None\n \n-        self._cv_tokens.append((_cv_req.set(self), app_ctx))\n+        self._cv_tokens.append((_cv_request.set(self), app_ctx))\n \n         # Open the session at the moment that the request context is available.\n         # This allows a custom open_session method to use the request context.\n@@ -401,9 +401,9 @@ class RequestContext:\n                 if request_close is not None:\n                     request_close()\n         finally:\n-            ctx = _cv_req.get()\n+            ctx = _cv_request.get()\n             token, app_ctx = self._cv_tokens.pop()\n-            _cv_req.reset(token)\n+            _cv_request.reset(token)\n \n             # get rid of circular dependencies at the end of the request\n             # so that we don't require the GC to be active.\n\n@@ -70,16 +70,16 @@ This typically means that you attempted to use functionality that needed\n an active HTTP request. Consult the documentation on testing for\n information about how to avoid this problem.\\\n \"\"\"\n-_cv_req: ContextVar[\"RequestContext\"] = ContextVar(\"flask.request_ctx\")\n-__request_ctx_stack = _FakeStack(\"request\", _cv_req)\n+_cv_request: ContextVar[\"RequestContext\"] = ContextVar(\"flask.request_ctx\")\n+__request_ctx_stack = _FakeStack(\"request\", _cv_request)\n request_ctx: \"RequestContext\" = LocalProxy(  # type: ignore[assignment]\n-    _cv_req, unbound_message=_no_req_msg\n+    _cv_request, unbound_message=_no_req_msg\n )\n request: \"Request\" = LocalProxy(  # type: ignore[assignment]\n-    _cv_req, \"request\", unbound_message=_no_req_msg\n+    _cv_request, \"request\", unbound_message=_no_req_msg\n )\n session: \"SessionMixin\" = LocalProxy(  # type: ignore[assignment]\n-    _cv_req, \"session\", unbound_message=_no_req_msg\n+    _cv_request, \"session\", unbound_message=_no_req_msg\n )\n \n \n\n@@ -12,7 +12,7 @@ import werkzeug.utils\n from werkzeug.exceptions import abort as _wz_abort\n from werkzeug.utils import redirect as _wz_redirect\n \n-from .globals import _cv_req\n+from .globals import _cv_request\n from .globals import current_app\n from .globals import request\n from .globals import request_ctx\n@@ -111,7 +111,7 @@ def stream_with_context(\n         return update_wrapper(decorator, generator_or_function)  # type: ignore\n \n     def generator() -> t.Generator:\n-        ctx = _cv_req.get(None)\n+        ctx = _cv_request.get(None)\n         if ctx is None:\n             raise RuntimeError(\n                 \"'stream_with_context' can only be used when a request\"\n\n@@ -6,7 +6,7 @@ from jinja2 import Template\n from jinja2 import TemplateNotFound\n \n from .globals import _cv_app\n-from .globals import _cv_req\n+from .globals import _cv_request\n from .globals import current_app\n from .globals import request\n from .helpers import stream_with_context\n@@ -23,7 +23,7 @@ def _default_template_ctx_processor() -> t.Dict[str, t.Any]:\n     `session` and `g`.\n     \"\"\"\n     appctx = _cv_app.get(None)\n-    reqctx = _cv_req.get(None)\n+    reqctx = _cv_request.get(None)\n     rv: t.Dict[str, t.Any] = {}\n     if appctx is not None:\n         rv[\"g\"] = appctx.g\n\n@@ -11,7 +11,7 @@ from werkzeug.urls import url_parse\n from werkzeug.wrappers import Request as BaseRequest\n \n from .cli import ScriptInfo\n-from .globals import _cv_req\n+from .globals import _cv_request\n from .json import dumps as json_dumps\n from .sessions import SessionMixin\n \n@@ -146,7 +146,7 @@ class FlaskClient(Client):\n         app = self.application\n         environ_overrides = kwargs.setdefault(\"environ_overrides\", {})\n         self.cookie_jar.inject_wsgi(environ_overrides)\n-        outer_reqctx = _cv_req.get(None)\n+        outer_reqctx = _cv_request.get(None)\n         with app.test_request_context(*args, **kwargs) as c:\n             session_interface = app.session_interface\n             sess = session_interface.open_session(app, c.request)\n@@ -162,11 +162,11 @@ class FlaskClient(Client):\n             # behavior.  It's important to not use the push and pop\n             # methods of the actual request context object since that would\n             # mean that cleanup handlers are called\n-            token = _cv_req.set(outer_reqctx)  # type: ignore[arg-type]\n+            token = _cv_request.set(outer_reqctx)  # type: ignore[arg-type]\n             try:\n                 yield sess\n             finally:\n-                _cv_req.reset(token)\n+                _cv_request.reset(token)\n \n             resp = app.response_class()\n             if not session_interface.is_null_session(sess):\n\n@@ -5,7 +5,7 @@ import werkzeug\n import flask\n from flask import appcontext_popped\n from flask.cli import ScriptInfo\n-from flask.globals import _cv_req\n+from flask.globals import _cv_request\n from flask.json import jsonify\n from flask.testing import EnvironBuilder\n from flask.testing import FlaskCliRunner\n@@ -400,4 +400,4 @@ def test_client_pop_all_preserved(app, req_ctx, client):\n     # close the response, releasing the context held by stream_with_context\n     rv.close()\n     # only req_ctx fixture should still be pushed\n-    assert _cv_req.get(None) is req_ctx\n+    assert _cv_request.get(None) is req_ctx\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#69f9845ef2da3051d74d4dade3e88ccf5b2ee3de", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 605 | Lines Deleted: 263 | Files Changed: 10 | Hunks: 81 | Methods Changed: 51 | Complexity Δ (Sum/Max): 13/38 | Churn Δ: 868 | Churn Cumulative: 13769 | Contributors (this commit): 80 | Commits (past 90d): 80 | Contributors (cumulative): 135 | DMM Complexity: 0.9639175257731959\n\nDIFF:\n@@ -31,7 +31,6 @@ from werkzeug.utils import redirect as _wz_redirect\n from werkzeug.wrappers import Response as BaseResponse\n \n from . import cli\n-from . import json\n from . import typing as ft\n from .config import Config\n from .config import ConfigAttribute\n@@ -50,7 +49,8 @@ from .helpers import get_env\n from .helpers import get_flashed_messages\n from .helpers import get_load_dotenv\n from .helpers import locked_cached_property\n-from .json import jsonify\n+from .json.provider import DefaultJSONProvider\n+from .json.provider import JSONProvider\n from .logging import create_logger\n from .scaffold import _endpoint_from_view_func\n from .scaffold import _sentinel\n@@ -315,15 +315,37 @@ class Flask(Scaffold):\n     #: ``USE_X_SENDFILE`` configuration key.  Defaults to ``False``.\n     use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n \n-    #: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.\n+    #: The JSON encoder class to use. Defaults to\n+    #: :class:`~flask.json.JSONEncoder`.\n+    #:\n+    #: .. deprecated:: 2.2\n+    #:      Will be removed in Flask 2.3. Customize\n+    #:      :attr:`json_provider_class` instead.\n     #:\n     #: .. versionadded:: 0.10\n-    json_encoder = json.JSONEncoder\n+    json_encoder: None = None\n \n-    #: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.\n+    #: The JSON decoder class to use. Defaults to\n+    #: :class:`~flask.json.JSONDecoder`.\n+    #:\n+    #: .. deprecated:: 2.2\n+    #:      Will be removed in Flask 2.3. Customize\n+    #:      :attr:`json_provider_class` instead.\n     #:\n     #: .. versionadded:: 0.10\n-    json_decoder = json.JSONDecoder\n+    json_decoder: None = None\n+\n+    json_provider_class: t.Type[JSONProvider] = DefaultJSONProvider\n+    \"\"\"A subclass of :class:`~flask.json.provider.JSONProvider`. An\n+    instance is created and assigned to :attr:`app.json` when creating\n+    the app.\n+\n+    The default, :class:`~flask.json.provider.DefaultJSONProvider`, uses\n+    Python's built-in :mod:`json` library. A different provider can use\n+    a different JSON library.\n+\n+    .. versionadded:: 2.2\n+    \"\"\"\n \n     #: Options that are passed to the Jinja environment in\n     #: :meth:`create_jinja_environment`. Changing these options after\n@@ -361,10 +383,10 @@ class Flask(Scaffold):\n             \"TRAP_HTTP_EXCEPTIONS\": False,\n             \"EXPLAIN_TEMPLATE_LOADING\": False,\n             \"PREFERRED_URL_SCHEME\": \"http\",\n-            \"JSON_AS_ASCII\": True,\n-            \"JSON_SORT_KEYS\": True,\n-            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n-            \"JSONIFY_MIMETYPE\": \"application/json\",\n+            \"JSON_AS_ASCII\": None,\n+            \"JSON_SORT_KEYS\": None,\n+            \"JSONIFY_PRETTYPRINT_REGULAR\": None,\n+            \"JSONIFY_MIMETYPE\": None,\n             \"TEMPLATES_AUTO_RELOAD\": None,\n             \"MAX_COOKIE_SIZE\": 4093,\n         }\n@@ -449,6 +471,22 @@ class Flask(Scaffold):\n         #:     Moved from ``flask.abort``, which calls this object.\n         self.aborter = self.make_aborter()\n \n+        self.json: JSONProvider = self.json_provider_class(self)\n+        \"\"\"Provides access to JSON methods. Functions in ``flask.json``\n+        will call methods on this provider when the application context\n+        is active. Used for handling JSON requests and responses.\n+\n+        An instance of :attr:`json_provider_class`. Can be customized by\n+        changing that attribute on a subclass, or by assigning to this\n+        attribute afterwards.\n+\n+        The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n+        uses Python's built-in :mod:`json` library. A different provider\n+        can use a different JSON library.\n+\n+        .. versionadded:: 2.2\n+        \"\"\"\n+\n         #: A list of functions that are called by\n         #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n         #: :exc:`~werkzeug.routing.BuildError`. Each function is called\n@@ -745,7 +783,7 @@ class Flask(Scaffold):\n             session=session,\n             g=g,\n         )\n-        rv.policies[\"json.dumps_function\"] = json.dumps\n+        rv.policies[\"json.dumps_function\"] = self.json.dumps\n         return rv\n \n     def create_global_jinja_loader(self) -> DispatchingJinjaLoader:\n@@ -1926,7 +1964,7 @@ class Flask(Scaffold):\n                 )\n                 status = headers = None\n             elif isinstance(rv, (dict, list)):\n-                rv = jsonify(rv)\n+                rv = self.json.response(rv)\n             elif isinstance(rv, BaseResponse) or callable(rv):\n                 # evaluate a WSGI callable, or coerce a different response\n                 # class to the correct type\n\n@@ -174,10 +174,16 @@ class Blueprint(Scaffold):\n \n     #: Blueprint local JSON encoder class to use. Set to ``None`` to use\n     #: the app's :class:`~flask.Flask.json_encoder`.\n-    json_encoder = None\n+    #:\n+    #: .. deprecated:: 2.2\n+    #:      Will be removed in Flask 2.3.\n+    json_encoder: None = None\n     #: Blueprint local JSON decoder class to use. Set to ``None`` to use\n     #: the app's :class:`~flask.Flask.json_decoder`.\n-    json_decoder = None\n+    #:\n+    #: .. deprecated:: 2.2\n+    #:      Will be removed in Flask 2.3.\n+    json_decoder: None = None\n \n     def __init__(\n         self,\n\n@@ -307,6 +307,7 @@ class RequestContext:\n         self.app = app\n         if request is None:\n             request = app.request_class(environ)\n+            request.json_module = app.json  # type: ignore[misc]\n         self.request: Request = request\n         self.url_adapter = None\n         try:\n\n@@ -1,15 +1,12 @@\n-import dataclasses\n-import decimal\n+from __future__ import annotations\n+\n import json as _json\n import typing as t\n-import uuid\n-from datetime import date\n \n from jinja2.utils import htmlsafe_json_dumps as _jinja_htmlsafe_dumps\n-from werkzeug.http import http_date\n \n from ..globals import current_app\n-from ..globals import request\n+from .provider import _default\n \n if t.TYPE_CHECKING:  # pragma: no cover\n     from ..app import Flask\n@@ -31,23 +28,30 @@ class JSONEncoder(_json.JSONEncoder):\n \n     Assign a subclass of this to :attr:`flask.Flask.json_encoder` or\n     :attr:`flask.Blueprint.json_encoder` to override the default.\n+\n+    .. deprecated:: 2.2\n+        Will be removed in Flask 2.3. Use ``app.json`` instead.\n     \"\"\"\n \n+    def __init__(self, **kwargs) -> None:\n+        import warnings\n+\n+        warnings.warn(\n+            \"'JSONEncoder' is deprecated and will be removed in\"\n+            \" Flask 2.3. Use 'Flask.json' to provide an alternate\"\n+            \" JSON implementation instead.\",\n+            DeprecationWarning,\n+            stacklevel=3,\n+        )\n+        super().__init__(**kwargs)\n+\n     def default(self, o: t.Any) -> t.Any:\n         \"\"\"Convert ``o`` to a JSON serializable type. See\n         :meth:`json.JSONEncoder.default`. Python does not support\n         overriding how basic types like ``str`` or ``list`` are\n         serialized, they are handled before this method.\n         \"\"\"\n-        if isinstance(o, date):\n-            return http_date(o)\n-        if isinstance(o, (decimal.Decimal, uuid.UUID)):\n-            return str(o)\n-        if dataclasses and dataclasses.is_dataclass(o):\n-            return dataclasses.asdict(o)\n-        if hasattr(o, \"__html__\"):\n-            return str(o.__html__())\n-        return super().default(o)\n+        return _default(o)\n \n \n class JSONDecoder(_json.JSONDecoder):\n@@ -58,144 +62,193 @@ class JSONDecoder(_json.JSONDecoder):\n \n     Assign a subclass of this to :attr:`flask.Flask.json_decoder` or\n     :attr:`flask.Blueprint.json_decoder` to override the default.\n+\n+    .. deprecated:: 2.2\n+        Will be removed in Flask 2.3. Use ``app.json`` instead.\n     \"\"\"\n \n+    def __init__(self, **kwargs) -> None:\n+        import warnings\n \n-def _dump_arg_defaults(\n-    kwargs: t.Dict[str, t.Any], app: t.Optional[\"Flask\"] = None\n-) -> None:\n-    \"\"\"Inject default arguments for dump functions.\"\"\"\n-    if app is None:\n-        app = current_app\n-\n-    if app:\n-        cls = app.json_encoder\n-        bp = app.blueprints.get(request.blueprint) if request else None  # type: ignore\n-        if bp is not None and bp.json_encoder is not None:\n-            cls = bp.json_encoder\n-\n-        # Only set a custom encoder if it has custom behavior. This is\n-        # faster on PyPy.\n-        if cls is not _json.JSONEncoder:\n-            kwargs.setdefault(\"cls\", cls)\n-\n-        kwargs.setdefault(\"cls\", cls)\n-        kwargs.setdefault(\"ensure_ascii\", app.config[\"JSON_AS_ASCII\"])\n-        kwargs.setdefault(\"sort_keys\", app.config[\"JSON_SORT_KEYS\"])\n-    else:\n-        kwargs.setdefault(\"sort_keys\", True)\n-        kwargs.setdefault(\"cls\", JSONEncoder)\n+        warnings.warn(\n+            \"'JSONDecoder' is deprecated and will be removed in\"\n+            \" Flask 2.3. Use 'Flask.json' to provide an alternate\"\n+            \" JSON implementation instead.\",\n+            DeprecationWarning,\n+            stacklevel=3,\n+        )\n+        super().__init__(**kwargs)\n \n \n-def _load_arg_defaults(\n-    kwargs: t.Dict[str, t.Any], app: t.Optional[\"Flask\"] = None\n-) -> None:\n-    \"\"\"Inject default arguments for load functions.\"\"\"\n-    if app is None:\n-        app = current_app\n+def dumps(obj: t.Any, *, app: Flask | None = None, **kwargs: t.Any) -> str:\n+    \"\"\"Serialize data as JSON.\n \n-    if app:\n-        cls = app.json_decoder\n-        bp = app.blueprints.get(request.blueprint) if request else None  # type: ignore\n-        if bp is not None and bp.json_decoder is not None:\n-            cls = bp.json_decoder\n+    If :data:`~flask.current_app` is available, it will use its\n+    :meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`\n+    method, otherwise it will use :func:`json.dumps`.\n \n-        # Only set a custom decoder if it has custom behavior. This is\n-        # faster on PyPy.\n-        if cls not in {JSONDecoder, _json.JSONDecoder}:\n-            kwargs.setdefault(\"cls\", cls)\n+    :param obj: The data to serialize.\n+    :param kwargs: Arguments passed to the ``dumps`` implementation.\n \n+    .. versionchanged:: 2.2\n+        Calls ``current_app.json.dumps``, allowing an app to override\n+        the behavior.\n \n-def dumps(obj: t.Any, app: t.Optional[\"Flask\"] = None, **kwargs: t.Any) -> str:\n-    \"\"\"Serialize an object to a string of JSON.\n-\n-    Takes the same arguments as the built-in :func:`json.dumps`, with\n-    some defaults from application configuration.\n-\n-    :param obj: Object to serialize to JSON.\n-    :param app: Use this app's config instead of the active app context\n-        or defaults.\n-    :param kwargs: Extra arguments passed to :func:`json.dumps`.\n+    .. versionchanged:: 2.2\n+        The ``app`` parameter will be removed in Flask 2.3.\n \n     .. versionchanged:: 2.0.2\n         :class:`decimal.Decimal` is supported by converting to a string.\n \n     .. versionchanged:: 2.0\n-        ``encoding`` is deprecated and will be removed in Flask 2.1.\n+        ``encoding`` will be removed in Flask 2.1.\n \n     .. versionchanged:: 1.0.3\n         ``app`` can be passed directly, rather than requiring an app\n         context for configuration.\n     \"\"\"\n-    _dump_arg_defaults(kwargs, app=app)\n+    if app is not None:\n+        import warnings\n+\n+        warnings.warn(\n+            \"The 'app' parameter is deprecated and will be removed in\"\n+            \" Flask 2.3. Call 'app.json.dumps' directly instead.\",\n+            DeprecationWarning,\n+            stacklevel=2,\n+        )\n+    else:\n+        app = current_app\n+\n+    if app:\n+        return app.json.dumps(obj, **kwargs)\n+\n+    kwargs.setdefault(\"default\", _default)\n     return _json.dumps(obj, **kwargs)\n \n \n def dump(\n-    obj: t.Any, fp: t.IO[str], app: t.Optional[\"Flask\"] = None, **kwargs: t.Any\n+    obj: t.Any, fp: t.IO[str], *, app: Flask | None = None, **kwargs: t.Any\n ) -> None:\n-    \"\"\"Serialize an object to JSON written to a file object.\n+    \"\"\"Serialize data as JSON and write to a file.\n \n-    Takes the same arguments as the built-in :func:`json.dump`, with\n-    some defaults from application configuration.\n+    If :data:`~flask.current_app` is available, it will use its\n+    :meth:`app.json.dump() <flask.json.provider.JSONProvider.dump>`\n+    method, otherwise it will use :func:`json.dump`.\n \n-    :param obj: Object to serialize to JSON.\n-    :param fp: File object to write JSON to.\n-    :param app: Use this app's config instead of the active app context\n-        or defaults.\n-    :param kwargs: Extra arguments passed to :func:`json.dump`.\n+    :param obj: The data to serialize.\n+    :param fp: A file opened for writing text. Should use the UTF-8\n+        encoding to be valid JSON.\n+    :param kwargs: Arguments passed to the ``dump`` implementation.\n+\n+    .. versionchanged:: 2.2\n+        Calls ``current_app.json.dump``, allowing an app to override\n+        the behavior.\n+\n+    .. versionchanged:: 2.2\n+        The ``app`` parameter will be removed in Flask 2.3.\n \n     .. versionchanged:: 2.0\n-        Writing to a binary file, and the ``encoding`` argument, is\n-        deprecated and will be removed in Flask 2.1.\n+        Writing to a binary file, and the ``encoding`` argument, will be\n+        removed in Flask 2.1.\n     \"\"\"\n-    _dump_arg_defaults(kwargs, app=app)\n+    if app is not None:\n+        import warnings\n+\n+        warnings.warn(\n+            \"The 'app' parameter is deprecated and will be removed in\"\n+            \" Flask 2.3. Call 'app.json.dump' directly instead.\",\n+            DeprecationWarning,\n+            stacklevel=2,\n+        )\n+    else:\n+        app = current_app\n+\n+    if app:\n+        app.json.dump(obj, fp, **kwargs)\n+    else:\n+        kwargs.setdefault(\"default\", _default)\n         _json.dump(obj, fp, **kwargs)\n \n \n-def loads(\n-    s: t.Union[str, bytes],\n-    app: t.Optional[\"Flask\"] = None,\n-    **kwargs: t.Any,\n-) -> t.Any:\n-    \"\"\"Deserialize an object from a string of JSON.\n+def loads(s: str | bytes, *, app: Flask | None = None, **kwargs: t.Any) -> t.Any:\n+    \"\"\"Deserialize data as JSON.\n \n-    Takes the same arguments as the built-in :func:`json.loads`, with\n-    some defaults from application configuration.\n+    If :data:`~flask.current_app` is available, it will use its\n+    :meth:`app.json.loads() <flask.json.provider.JSONProvider.loads>`\n+    method, otherwise it will use :func:`json.loads`.\n \n-    :param s: JSON string to deserialize.\n-    :param app: Use this app's config instead of the active app context\n-        or defaults.\n-    :param kwargs: Extra arguments passed to :func:`json.loads`.\n+    :param s: Text or UTF-8 bytes.\n+    :param kwargs: Arguments passed to the ``loads`` implementation.\n+\n+    .. versionchanged:: 2.2\n+        Calls ``current_app.json.loads``, allowing an app to override\n+        the behavior.\n+\n+    .. versionchanged:: 2.2\n+        The ``app`` parameter will be removed in Flask 2.3.\n \n     .. versionchanged:: 2.0\n-        ``encoding`` is deprecated and will be removed in Flask 2.1. The\n-        data must be a string or UTF-8 bytes.\n+        ``encoding`` will be removed in Flask 2.1. The data must be a\n+        string or UTF-8 bytes.\n \n     .. versionchanged:: 1.0.3\n         ``app`` can be passed directly, rather than requiring an app\n         context for configuration.\n     \"\"\"\n-    _load_arg_defaults(kwargs, app=app)\n+    if app is not None:\n+        import warnings\n+\n+        warnings.warn(\n+            \"The 'app' parameter is deprecated and will be removed in\"\n+            \" Flask 2.3. Call 'app.json.loads' directly instead.\",\n+            DeprecationWarning,\n+            stacklevel=2,\n+        )\n+    else:\n+        app = current_app\n+\n+    if app:\n+        return app.json.loads(s, **kwargs)\n+\n     return _json.loads(s, **kwargs)\n \n \n-def load(fp: t.IO[str], app: t.Optional[\"Flask\"] = None, **kwargs: t.Any) -> t.Any:\n-    \"\"\"Deserialize an object from JSON read from a file object.\n+def load(fp: t.IO[t.AnyStr], *, app: Flask | None = None, **kwargs: t.Any) -> t.Any:\n+    \"\"\"Deserialize data as JSON read from a file.\n \n-    Takes the same arguments as the built-in :func:`json.load`, with\n-    some defaults from application configuration.\n+    If :data:`~flask.current_app` is available, it will use its\n+    :meth:`app.json.load() <flask.json.provider.JSONProvider.load>`\n+    method, otherwise it will use :func:`json.load`.\n \n-    :param fp: File object to read JSON from.\n-    :param app: Use this app's config instead of the active app context\n-        or defaults.\n-    :param kwargs: Extra arguments passed to :func:`json.load`.\n+    :param fp: A file opened for reading text or UTF-8 bytes.\n+    :param kwargs: Arguments passed to the ``load`` implementation.\n+\n+    .. versionchanged:: 2.2\n+        Calls ``current_app.json.load``, allowing an app to override\n+        the behavior.\n+\n+    .. versionchanged:: 2.2\n+        The ``app`` parameter will be removed in Flask 2.3.\n \n     .. versionchanged:: 2.0\n-        ``encoding`` is deprecated and will be removed in Flask 2.1. The\n-        file must be text mode, or binary mode with UTF-8 bytes.\n+        ``encoding`` will be removed in Flask 2.1. The file must be text\n+        mode, or binary mode with UTF-8 bytes.\n     \"\"\"\n-    _load_arg_defaults(kwargs, app=app)\n+    if app is not None:\n+        import warnings\n+\n+        warnings.warn(\n+            \"The 'app' parameter is deprecated and will be removed in\"\n+            \" Flask 2.3. Call 'app.json.load' directly instead.\",\n+            DeprecationWarning,\n+            stacklevel=2,\n+        )\n+    else:\n+        app = current_app\n+\n+    if app:\n+        return app.json.load(fp, **kwargs)\n+\n     return _json.load(fp, **kwargs)\n \n \n@@ -211,6 +264,9 @@ def htmlsafe_dumps(obj: t.Any, **kwargs: t.Any) -> str:\n     double quoted; either use single quotes or the ``|forceescape``\n     filter.\n \n+    .. deprecated:: 2.2\n+        Will be removed in Flask 2.3. This is built-in to Jinja now.\n+\n     .. versionchanged:: 2.0\n         Uses :func:`jinja2.utils.htmlsafe_json_dumps`. The returned\n         value is marked safe by wrapping in :class:`~markupsafe.Markup`.\n@@ -220,6 +276,14 @@ def htmlsafe_dumps(obj: t.Any, **kwargs: t.Any) -> str:\n         ``<script>`` tags, and single-quoted attributes without further\n         escaping.\n     \"\"\"\n+    import warnings\n+\n+    warnings.warn(\n+        \"'htmlsafe_dumps' is deprecated and will be removed in Flask\"\n+        \" 2.3. Use 'jinja2.utils.htmlsafe_json_dumps' instead.\",\n+        DeprecationWarning,\n+        stacklevel=2,\n+    )\n     return _jinja_htmlsafe_dumps(obj, dumps=dumps, **kwargs)\n \n \n@@ -227,77 +291,51 @@ def htmlsafe_dump(obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n     \"\"\"Serialize an object to JSON written to a file object, replacing\n     HTML-unsafe characters with Unicode escapes. See\n     :func:`htmlsafe_dumps` and :func:`dumps`.\n+\n+    .. deprecated:: 2.2\n+        Will be removed in Flask 2.3.\n     \"\"\"\n+    import warnings\n+\n+    warnings.warn(\n+        \"'htmlsafe_dump' is deprecated and will be removed in Flask\"\n+        \" 2.3. Use 'jinja2.utils.htmlsafe_json_dumps' instead.\",\n+        DeprecationWarning,\n+        stacklevel=2,\n+    )\n     fp.write(htmlsafe_dumps(obj, **kwargs))\n \n \n-def jsonify(*args: t.Any, **kwargs: t.Any) -> \"Response\":\n-    \"\"\"Serialize data to JSON and wrap it in a :class:`~flask.Response`\n-    with the :mimetype:`application/json` mimetype.\n+def jsonify(*args: t.Any, **kwargs: t.Any) -> Response:\n+    \"\"\"Serialize the given arguments as JSON, and return a\n+    :class:`~flask.Response` object with the ``application/json``\n+    mimetype. A dict or list returned from a view will be converted to a\n+    JSON response automatically without needing to call this.\n \n-    Uses :func:`dumps` to serialize the data, but ``args`` and\n-    ``kwargs`` are treated as data rather than arguments to\n-    :func:`json.dumps`.\n+    This requires an active request or application context, and calls\n+    :meth:`app.json.response() <flask.json.provider.JSONProvider.response>`.\n \n-    1.  Single argument: Treated as a single value.\n-    2.  Multiple arguments: Treated as a list of values.\n-        ``jsonify(1, 2, 3)`` is the same as ``jsonify([1, 2, 3])``.\n-    3.  Keyword arguments: Treated as a dict of values.\n-        ``jsonify(data=data, errors=errors)`` is the same as\n-        ``jsonify({\"data\": data, \"errors\": errors})``.\n-    4.  Passing both arguments and keyword arguments is not allowed as\n-        it's not clear what should happen.\n+    In debug mode, the output is formatted with indentation to make it\n+    easier to read. This may also be controlled by the provider.\n \n-    .. code-block:: python\n+    Either positional or keyword arguments can be given, not both.\n+    If no arguments are given, ``None`` is serialized.\n \n-        from flask import jsonify\n+    :param args: A single value to serialize, or multiple values to\n+        treat as a list to serialize.\n+    :param kwargs: Treat as a dict to serialize.\n \n-        @app.route(\"/users/me\")\n-        def get_current_user():\n-            return jsonify(\n-                username=g.user.username,\n-                email=g.user.email,\n-                id=g.user.id,\n-            )\n-\n-    Will return a JSON response like this:\n-\n-    .. code-block:: javascript\n-\n-        {\n-          \"username\": \"admin\",\n-          \"email\": \"admin@localhost\",\n-          \"id\": 42\n-        }\n-\n-    The default output omits indents and spaces after separators. In\n-    debug mode or if :data:`JSONIFY_PRETTYPRINT_REGULAR` is ``True``,\n-    the output will be formatted to be easier to read.\n+    .. versionchanged:: 2.2\n+        Calls ``current_app.json.response``, allowing an app to override\n+        the behavior.\n \n     .. versionchanged:: 2.0.2\n         :class:`decimal.Decimal` is supported by converting to a string.\n \n     .. versionchanged:: 0.11\n-        Added support for serializing top-level arrays. This introduces\n-        a security risk in ancient browsers. See :ref:`security-json`.\n+        Added support for serializing top-level arrays. This was a\n+        security risk in ancient browsers. See :ref:`security-json`.\n \n     .. versionadded:: 0.2\n     \"\"\"\n-    indent = None\n-    separators = (\",\", \":\")\n-\n-    if current_app.config[\"JSONIFY_PRETTYPRINT_REGULAR\"] or current_app.debug:\n-        indent = 2\n-        separators = (\", \", \": \")\n-\n-    if args and kwargs:\n-        raise TypeError(\"jsonify() behavior undefined when passed both args and kwargs\")\n-    elif len(args) == 1:  # single args are passed directly to dumps()\n-        data = args[0]\n-    else:\n-        data = args or kwargs\n-\n-    return current_app.response_class(\n-        f\"{dumps(data, indent=indent, separators=separators)}\\n\",\n-        mimetype=current_app.config[\"JSONIFY_MIMETYPE\"],\n-    )\n+    return current_app.json.response(*args, **kwargs)\n\n@@ -0,0 +1,310 @@\n+from __future__ import annotations\n+\n+import dataclasses\n+import decimal\n+import json\n+import typing as t\n+import uuid\n+import weakref\n+from datetime import date\n+\n+from werkzeug.http import http_date\n+\n+from ..globals import request\n+\n+if t.TYPE_CHECKING:  # pragma: no cover\n+    from ..app import Flask\n+    from ..wrappers import Response\n+\n+\n+class JSONProvider:\n+    \"\"\"A standard set of JSON operations for an application. Subclasses\n+    of this can be used to customize JSON behavior or use different\n+    JSON libraries.\n+\n+    To implement a provider for a specific library, subclass this base\n+    class and implement at least :meth:`dumps` and :meth:`loads`. All\n+    other methods have default implementations.\n+\n+    To use a different provider, either subclass ``Flask`` and set\n+    :attr:`~flask.Flask.json_provider_class` to a provider class, or set\n+    :attr:`app.json <flask.Flask.json>` to an instance of the class.\n+\n+    :param app: An application instance. This will be stored as a\n+        :class:`weakref.proxy` on the :attr:`_app` attribute.\n+\n+    .. versionadded:: 2.2\n+    \"\"\"\n+\n+    def __init__(self, app: Flask) -> None:\n+        self._app = weakref.proxy(app)\n+\n+    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n+        \"\"\"Serialize data as JSON.\n+\n+        :param obj: The data to serialize.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n+        \"\"\"Serialize data as JSON and write to a file.\n+\n+        :param obj: The data to serialize.\n+        :param fp: A file opened for writing text. Should use the UTF-8\n+            encoding to be valid JSON.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        fp.write(self.dumps(obj, **kwargs))\n+\n+    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n+        \"\"\"Deserialize data as JSON.\n+\n+        :param s: Text or UTF-8 bytes.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n+        \"\"\"Deserialize data as JSON read from a file.\n+\n+        :param fp: A file opened for reading text or UTF-8 bytes.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        return self.loads(fp.read(), **kwargs)\n+\n+    def _prepare_response_obj(\n+        self, args: t.Tuple[t.Any, ...], kwargs: t.Dict[str, t.Any]\n+    ) -> t.Any:\n+        if args and kwargs:\n+            raise TypeError(\"app.json.response() takes either args or kwargs, not both\")\n+\n+        if not args and not kwargs:\n+            return None\n+\n+        if len(args) == 1:\n+            return args[0]\n+\n+        return args or kwargs\n+\n+    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:\n+        \"\"\"Serialize the given arguments as JSON, and return a\n+        :class:`~flask.Response` object with the ``application/json``\n+        mimetype.\n+\n+        The :func:`~flask.json.jsonify` function calls this method for\n+        the current application.\n+\n+        Either positional or keyword arguments can be given, not both.\n+        If no arguments are given, ``None`` is serialized.\n+\n+        :param args: A single value to serialize, or multiple values to\n+            treat as a list to serialize.\n+        :param kwargs: Treat as a dict to serialize.\n+        \"\"\"\n+        obj = self._prepare_response_obj(args, kwargs)\n+        return self._app.response_class(self.dumps(obj), mimetype=\"application/json\")\n+\n+\n+def _default(o: t.Any) -> t.Any:\n+    if isinstance(o, date):\n+        return http_date(o)\n+\n+    if isinstance(o, (decimal.Decimal, uuid.UUID)):\n+        return str(o)\n+\n+    if dataclasses and dataclasses.is_dataclass(o):\n+        return dataclasses.asdict(o)\n+\n+    if hasattr(o, \"__html__\"):\n+        return str(o.__html__())\n+\n+    raise TypeError(f\"Object of type {type(o).__name__} is not JSON serializable\")\n+\n+\n+class DefaultJSONProvider(JSONProvider):\n+    \"\"\"Provide JSON operations using Python's built-in :mod:`json`\n+    library. Serializes the following additional data types:\n+\n+    -   :class:`datetime.datetime` and :class:`datetime.date` are\n+        serialized to :rfc:`822` strings. This is the same as the HTTP\n+        date format.\n+    -   :class:`uuid.UUID` is serialized to a string.\n+    -   :class:`dataclasses.dataclass` is passed to\n+        :func:`dataclasses.asdict`.\n+    -   :class:`~markupsafe.Markup` (or any object with a ``__html__``\n+        method) will call the ``__html__`` method to get a string.\n+    \"\"\"\n+\n+    default: t.Callable[[t.Any], t.Any] = staticmethod(\n+        _default\n+    )  # type: ignore[assignment]\n+    \"\"\"Apply this function to any object that :meth:`json.dumps` does\n+    not know how to serialize. It should return a valid JSON type or\n+    raise a ``TypeError``.\n+    \"\"\"\n+\n+    ensure_ascii = True\n+    \"\"\"Replace non-ASCII characters with escape sequences. This may be\n+    more compatible with some clients, but can be disabled for better\n+    performance and size.\n+    \"\"\"\n+\n+    sort_keys = True\n+    \"\"\"Sort the keys in any serialized dicts. This may be useful for\n+    some caching situations, but can be disabled for better performance.\n+    When enabled, keys must all be strings, they are not converted\n+    before sorting.\n+    \"\"\"\n+\n+    compact: bool | None = None\n+    \"\"\"If ``True``, or ``None`` out of debug mode, the :meth:`response`\n+    output will not add indentation, newlines, or spaces. If ``False``,\n+    or ``None`` in debug mode, it will use a non-compact representation.\n+    \"\"\"\n+\n+    mimetype = \"application/json\"\n+    \"\"\"The mimetype set in :meth:`response`.\"\"\"\n+\n+    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n+        \"\"\"Serialize data as JSON to a string.\n+\n+        Keyword arguments are passed to :func:`json.dumps`. Sets some\n+        parameter defaults from the :attr:`default`,\n+        :attr:`ensure_ascii`, and :attr:`sort_keys` attributes.\n+\n+        :param obj: The data to serialize.\n+        :param kwargs: Passed to :func:`json.dumps`.\n+        \"\"\"\n+        cls = self._app.json_encoder\n+        bp = self._app.blueprints.get(request.blueprint) if request else None\n+\n+        if bp is not None and bp.json_encoder is not None:\n+            cls = bp.json_encoder\n+\n+        if cls is not None:\n+            import warnings\n+\n+            warnings.warn(\n+                \"Setting 'json_encoder' on the app or a blueprint is\"\n+                \" deprecated and will be removed in Flask 2.3.\"\n+                \" Customize 'app.json' instead.\",\n+                DeprecationWarning,\n+            )\n+            kwargs.setdefault(\"cls\", cls)\n+\n+            if \"default\" not in cls.__dict__:\n+                kwargs.setdefault(\"default\", self.default)\n+        else:\n+            kwargs.setdefault(\"default\", self.default)\n+\n+        ensure_ascii = self._app.config[\"JSON_AS_ASCII\"]\n+        sort_keys = self._app.config[\"JSON_SORT_KEYS\"]\n+\n+        if ensure_ascii is not None:\n+            import warnings\n+\n+            warnings.warn(\n+                \"The 'JSON_AS_ASCII' config key is deprecated and will\"\n+                \" be removed in Flask 2.3. Set 'app.json.ensure_ascii'\"\n+                \" instead.\",\n+                DeprecationWarning,\n+            )\n+        else:\n+            ensure_ascii = self.ensure_ascii\n+\n+        if sort_keys is not None:\n+            import warnings\n+\n+            warnings.warn(\n+                \"The 'JSON_SORT_KEYS' config key is deprecated and will\"\n+                \" be removed in Flask 2.3. Set 'app.json.sort_keys'\"\n+                \" instead.\",\n+                DeprecationWarning,\n+            )\n+        else:\n+            sort_keys = self.sort_keys\n+\n+        kwargs.setdefault(\"ensure_ascii\", ensure_ascii)\n+        kwargs.setdefault(\"sort_keys\", sort_keys)\n+        return json.dumps(obj, **kwargs)\n+\n+    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n+        \"\"\"Deserialize data as JSON from a string or bytes.\n+\n+        :param s: Text or UTF-8 bytes.\n+        :param kwargs: Passed to :func:`json.loads`.\n+        \"\"\"\n+        cls = self._app.json_decoder\n+        bp = self._app.blueprints.get(request.blueprint) if request else None\n+\n+        if bp is not None and bp.json_decoder is not None:\n+            cls = bp.json_decoder\n+\n+        if cls is not None:\n+            import warnings\n+\n+            warnings.warn(\n+                \"Setting 'json_decoder' on the app or a blueprint is\"\n+                \" deprecated and will be removed in Flask 2.3.\"\n+                \" Customize 'app.json' instead.\",\n+                DeprecationWarning,\n+            )\n+            kwargs.setdefault(\"cls\", cls)\n+\n+        return json.loads(s, **kwargs)\n+\n+    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:\n+        \"\"\"Serialize the given arguments as JSON, and return a\n+        :class:`~flask.Response` object with it. The response mimetype\n+        will be \"application/json\" and can be changed with\n+        :attr:`mimetype`.\n+\n+        If :attr:`compact` is ``False`` or debug mode is enabled, the\n+        output will be formatted to be easier to read.\n+\n+        Either positional or keyword arguments can be given, not both.\n+        If no arguments are given, ``None`` is serialized.\n+\n+        :param args: A single value to serialize, or multiple values to\n+            treat as a list to serialize.\n+        :param kwargs: Treat as a dict to serialize.\n+        \"\"\"\n+        obj = self._prepare_response_obj(args, kwargs)\n+        dump_args: t.Dict[str, t.Any] = {}\n+        pretty = self._app.config[\"JSONIFY_PRETTYPRINT_REGULAR\"]\n+        mimetype = self._app.config[\"JSONIFY_MIMETYPE\"]\n+\n+        if pretty is not None:\n+            import warnings\n+\n+            warnings.warn(\n+                \"The 'JSONIFY_PRETTYPRINT_REGULAR' config key is\"\n+                \" deprecated and will be removed in Flask 2.3. Set\"\n+                \" 'app.json.compact' instead.\",\n+                DeprecationWarning,\n+            )\n+            compact: bool | None = not pretty\n+        else:\n+            compact = self.compact\n+\n+        if (compact is None and self._app.debug) or compact is False:\n+            dump_args.setdefault(\"indent\", 2)\n+        else:\n+            dump_args.setdefault(\"separators\", (\",\", \":\"))\n+\n+        if mimetype is not None:\n+            import warnings\n+\n+            warnings.warn(\n+                \"The 'JSONIFY_MIMETYPE' config key is deprecated and\"\n+                \" will be removed in Flask 2.3. Set 'app.json.mimetype'\"\n+                \" instead.\",\n+                DeprecationWarning,\n+            )\n+        else:\n+            mimetype = self.mimetype\n+\n+        return self._app.response_class(\n+            f\"{self.dumps(obj, **dump_args)}\\n\", mimetype=mimetype\n+        )\n\n@@ -6,8 +6,6 @@ import sys\n import typing as t\n from collections import defaultdict\n from functools import update_wrapper\n-from json import JSONDecoder\n-from json import JSONEncoder\n \n from jinja2 import FileSystemLoader\n from werkzeug.exceptions import default_exceptions\n@@ -76,11 +74,17 @@ class Scaffold:\n \n     #: JSON encoder class used by :func:`flask.json.dumps`. If a\n     #: blueprint sets this, it will be used instead of the app's value.\n-    json_encoder: t.Optional[t.Type[JSONEncoder]] = None\n+    #:\n+    #: .. deprecated:: 2.2\n+    #:      Will be removed in Flask 2.3.\n+    json_encoder: None = None\n \n     #: JSON decoder class used by :func:`flask.json.loads`. If a\n     #: blueprint sets this, it will be used instead of the app's value.\n-    json_decoder: t.Optional[t.Type[JSONDecoder]] = None\n+    #:\n+    #: .. deprecated:: 2.2\n+    #:      Will be removed in Flask 2.3.\n+    json_decoder: None = None\n \n     def __init__(\n         self,\n\n@@ -12,7 +12,6 @@ from werkzeug.wrappers import Request as BaseRequest\n \n from .cli import ScriptInfo\n from .globals import _cv_request\n-from .json import dumps as json_dumps\n from .sessions import SessionMixin\n \n if t.TYPE_CHECKING:  # pragma: no cover\n@@ -89,8 +88,7 @@ class EnvironBuilder(werkzeug.test.EnvironBuilder):\n         The serialization will be configured according to the config associated\n         with this EnvironBuilder's ``app``.\n         \"\"\"\n-        kwargs.setdefault(\"app\", self.app)\n-        return json_dumps(obj, **kwargs)\n+        return self.app.json.dumps(obj, **kwargs)\n \n \n class FlaskClient(Client):\n@@ -227,6 +225,7 @@ class FlaskClient(Client):\n             buffered=buffered,\n             follow_redirects=follow_redirects,\n         )\n+        response.json_module = self.application.json  # type: ignore[misc]\n \n         # Re-push contexts that were preserved during the request.\n         while self._new_contexts:\n\n@@ -1302,28 +1302,17 @@ def test_make_response_with_response_instance(app, req_ctx):\n     assert rv.headers[\"X-Foo\"] == \"bar\"\n \n \n-def test_jsonify_no_prettyprint(app, req_ctx):\n-    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": False})\n-    compressed_msg = b'{\"msg\":{\"submsg\":\"W00t\"},\"msg2\":\"foobar\"}\\n'\n-    uncompressed_msg = {\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"}\n-\n-    rv = flask.make_response(flask.jsonify(uncompressed_msg), 200)\n-    assert rv.data == compressed_msg\n-\n-\n-def test_jsonify_prettyprint(app, req_ctx):\n-    app.config.update({\"JSONIFY_PRETTYPRINT_REGULAR\": True})\n-    compressed_msg = {\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"}\n-    pretty_response = (\n-        b'{\\n  \"msg\": {\\n    \"submsg\": \"W00t\"\\n  }, \\n  \"msg2\": \"foobar\"\\n}\\n'\n-    )\n-\n-    rv = flask.make_response(flask.jsonify(compressed_msg), 200)\n-    assert rv.data == pretty_response\n+@pytest.mark.parametrize(\"compact\", [True, False])\n+def test_jsonify_no_prettyprint(app, compact):\n+    app.json.compact = compact\n+    rv = app.json.response({\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"})\n+    data = rv.data.strip()\n+    assert (b\" \" not in data) is compact\n+    assert (b\"\\n\" not in data) is compact\n \n \n def test_jsonify_mimetype(app, req_ctx):\n-    app.config.update({\"JSONIFY_MIMETYPE\": \"application/vnd.api+json\"})\n+    app.json.mimetype = \"application/vnd.api+json\"\n     msg = {\"msg\": {\"submsg\": \"W00t\"}}\n     rv = flask.make_response(flask.jsonify(msg), 200)\n     assert rv.mimetype == \"application/vnd.api+json\"\n@@ -1333,15 +1322,15 @@ def test_json_dump_dataclass(app, req_ctx):\n     from dataclasses import make_dataclass\n \n     Data = make_dataclass(\"Data\", [(\"name\", str)])\n-    value = flask.json.dumps(Data(\"Flask\"), app=app)\n-    value = flask.json.loads(value, app=app)\n+    value = app.json.dumps(Data(\"Flask\"))\n+    value = app.json.loads(value)\n     assert value == {\"name\": \"Flask\"}\n \n \n def test_jsonify_args_and_kwargs_check(app, req_ctx):\n     with pytest.raises(TypeError) as e:\n         flask.jsonify(\"fake args\", kwargs=\"fake\")\n-    assert \"behavior undefined\" in str(e.value)\n+    assert \"args or kwargs\" in str(e.value)\n \n \n def test_url_generation(app, req_ctx):\n\n@@ -8,6 +8,7 @@ from werkzeug.http import http_date\n \n import flask\n from flask import json\n+from flask.json.provider import DefaultJSONProvider\n \n \n @pytest.mark.parametrize(\"debug\", (True, False))\n@@ -48,9 +49,8 @@ def test_json_custom_mimetypes(app, client):\n     \"test_value,expected\", [(True, '\"\\\\u2603\"'), (False, '\"\\u2603\"')]\n )\n def test_json_as_unicode(test_value, expected, app, app_ctx):\n-\n-    app.config[\"JSON_AS_ASCII\"] = test_value\n-    rv = flask.json.dumps(\"\\N{SNOWMAN}\")\n+    app.json.ensure_ascii = test_value\n+    rv = app.json.dumps(\"\\N{SNOWMAN}\")\n     assert rv == expected\n \n \n@@ -170,7 +170,7 @@ def test_jsonify_aware_datetimes(tz):\n     dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n     gmt = FixedOffset(hours=0, name=\"GMT\")\n     expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n-    assert flask.json.JSONEncoder().encode(dt) == expected\n+    assert flask.json.dumps(dt) == expected\n \n \n def test_jsonify_uuid_types(app, client):\n@@ -225,24 +225,25 @@ def test_json_customization(app, client):\n         def __init__(self, val):\n             self.val = val\n \n-    class MyEncoder(flask.json.JSONEncoder):\n-        def default(self, o):\n+    def default(o):\n         if isinstance(o, X):\n             return f\"<{o.val}>\"\n-            return flask.json.JSONEncoder.default(self, o)\n \n-    class MyDecoder(flask.json.JSONDecoder):\n-        def __init__(self, *args, **kwargs):\n-            kwargs.setdefault(\"object_hook\", self.object_hook)\n-            flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n+        return DefaultJSONProvider.default(o)\n \n+    class CustomProvider(DefaultJSONProvider):\n         def object_hook(self, obj):\n             if len(obj) == 1 and \"_foo\" in obj:\n                 return X(obj[\"_foo\"])\n+\n             return obj\n \n-    app.json_encoder = MyEncoder\n-    app.json_decoder = MyDecoder\n+        def loads(self, s, **kwargs):\n+            kwargs.setdefault(\"object_hook\", self.object_hook)\n+            return super().loads(s, **kwargs)\n+\n+    app.json = CustomProvider(app)\n+    app.json.default = default\n \n     @app.route(\"/\", methods=[\"POST\"])\n     def index():\n@@ -256,49 +257,6 @@ def test_json_customization(app, client):\n     assert rv.data == b'\"<42>\"'\n \n \n-def test_blueprint_json_customization(app, client):\n-    class X:\n-        __slots__ = (\"val\",)\n-\n-        def __init__(self, val):\n-            self.val = val\n-\n-    class MyEncoder(flask.json.JSONEncoder):\n-        def default(self, o):\n-            if isinstance(o, X):\n-                return f\"<{o.val}>\"\n-\n-            return flask.json.JSONEncoder.default(self, o)\n-\n-    class MyDecoder(flask.json.JSONDecoder):\n-        def __init__(self, *args, **kwargs):\n-            kwargs.setdefault(\"object_hook\", self.object_hook)\n-            flask.json.JSONDecoder.__init__(self, *args, **kwargs)\n-\n-        def object_hook(self, obj):\n-            if len(obj) == 1 and \"_foo\" in obj:\n-                return X(obj[\"_foo\"])\n-\n-            return obj\n-\n-    bp = flask.Blueprint(\"bp\", __name__)\n-    bp.json_encoder = MyEncoder\n-    bp.json_decoder = MyDecoder\n-\n-    @bp.route(\"/bp\", methods=[\"POST\"])\n-    def index():\n-        return flask.json.dumps(flask.request.get_json()[\"x\"])\n-\n-    app.register_blueprint(bp)\n-\n-    rv = client.post(\n-        \"/bp\",\n-        data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n-        content_type=\"application/json\",\n-    )\n-    assert rv.data == b'\"<42>\"'\n-\n-\n def _has_encoding(name):\n     try:\n         import codecs\n@@ -330,8 +288,7 @@ def test_modified_url_encoding(app, client):\n \n def test_json_key_sorting(app, client):\n     app.debug = True\n-\n-    assert app.config[\"JSON_SORT_KEYS\"]\n+    assert app.json.sort_keys\n     d = dict.fromkeys(range(20), \"foo\")\n \n     @app.route(\"/\")\n\n@@ -112,7 +112,7 @@ def test_path_is_url(app):\n \n def test_environbuilder_json_dumps(app):\n     \"\"\"EnvironBuilder.json_dumps() takes settings from the app.\"\"\"\n-    app.config[\"JSON_AS_ASCII\"] = False\n+    app.json.ensure_ascii = False\n     eb = EnvironBuilder(app, json=\"\\u20ac\")\n     assert eb.input_stream.read().decode(\"utf8\") == '\"\\u20ac\"'\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
