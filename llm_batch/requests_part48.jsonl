{"custom_id": "requests#53d454c8137e3c4863d7c1ecef8e3664f399f883", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 665 | Contributors (this commit): 12 | Commits (past 90d): 7 | Contributors (cumulative): 12 | DMM Complexity: 0.0\n\nDIFF:\n@@ -227,6 +227,11 @@ class HTTPDigestAuth(AuthBase):\n             if qop:\n                 base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n \n+            # Consume content and release the original connection \n+            # to allow our new request to reuse the same one.\n+            r.content\n+            r.raw.release_conn()\n+\n             r.request.headers['Authorization'] = 'Digest %s' % (base)\n             r.request.send(anyway=True)\n             _r = r.request.response\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#5017aeb06c3893a1e500ae73d7d343b480a9c8c2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 35 | Lines Deleted: 27 | Files Changed: 1 | Hunks: 12 | Methods Changed: 4 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 62 | Churn Cumulative: 727 | Contributors (this commit): 12 | Commits (past 90d): 8 | Contributors (cumulative): 12 | DMM Complexity: 1.0\n\nDIFF:\n@@ -143,26 +143,17 @@ class HTTPDigestAuth(AuthBase):\n     def __init__(self, username, password):\n         self.username = username\n         self.password = password\n+        self.last_nonce = ''\n+        self.nonce_count = 0\n+        self.chal = {}\n \n-    def handle_401(self, r):\n-        \"\"\"Takes the given response and tries digest-auth, if needed.\"\"\"\n+    def build_digest_header(self, method, url):\n \n-        num_401_calls = r.request.hooks['response'].count(self.handle_401)\n-\n-        s_auth = r.headers.get('www-authenticate', '')\n-\n-        if 'digest' in s_auth.lower() and num_401_calls < 2:\n-\n-            last_nonce = ''\n-            nonce_count = 0\n-\n-            chal = parse_dict_header(s_auth.replace('Digest ', ''))\n-\n-            realm = chal['realm']\n-            nonce = chal['nonce']\n-            qop = chal.get('qop')\n-            algorithm = chal.get('algorithm', 'MD5')\n-            opaque = chal.get('opaque', None)\n+        realm = self.chal['realm']\n+        nonce = self.chal['nonce']\n+        qop = self.chal.get('qop')\n+        algorithm = self.chal.get('algorithm', 'MD5')\n+        opaque = self.chal.get('opaque', None)\n     \n         algorithm = algorithm.upper()\n         # lambdas assume digest modules are imported at the top level\n@@ -186,23 +177,22 @@ class HTTPDigestAuth(AuthBase):\n     \n         # XXX not implemented yet\n         entdig = None\n-            p_parsed = urlparse(r.request.url)\n+        p_parsed = urlparse(url)\n         path = p_parsed.path\n         if p_parsed.query:\n             path += '?' + p_parsed.query\n     \n         A1 = '%s:%s:%s' % (self.username, realm, self.password)\n-            A2 = '%s:%s' % (r.request.method, path)\n+        A2 = '%s:%s' % (method, path)\n     \n         if qop == 'auth':\n-                if nonce == last_nonce:\n-                    nonce_count += 1\n+            if nonce == self.last_nonce:\n+                self.nonce_count += 1\n             else:\n-                    nonce_count = 1\n-                    last_nonce = nonce\n+                self.nonce_count = 1\n     \n-                ncvalue = '%08x' % nonce_count\n-                s = str(nonce_count).encode('utf-8')\n+            ncvalue = '%08x' % self.nonce_count\n+            s = str(self.nonce_count).encode('utf-8')\n             s += nonce.encode('utf-8')\n             s += time.ctime().encode('utf-8')\n             s += os.urandom(8)\n@@ -216,6 +206,8 @@ class HTTPDigestAuth(AuthBase):\n             # XXX handle auth-int.\n             return None\n     \n+        self.last_nonce = nonce\n+    \n         # XXX should the partial digests be encoded too?\n         base = 'username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", ' \\\n            'response=\"%s\"' % (self.username, realm, nonce, path, respdig)\n@@ -227,12 +219,25 @@ class HTTPDigestAuth(AuthBase):\n         if qop:\n             base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n     \n+        return 'Digest %s' % (base)\n+\n+    def handle_401(self, r):\n+        \"\"\"Takes the given response and tries digest-auth, if needed.\"\"\"\n+\n+        num_401_calls = r.request.hooks['response'].count(self.handle_401)\n+\n+        s_auth = r.headers.get('www-authenticate', '')\n+\n+        if 'digest' in s_auth.lower() and num_401_calls < 2:\n+\n+            self.chal = parse_dict_header(s_auth.replace('Digest ', ''))\n+\n             # Consume content and release the original connection \n             # to allow our new request to reuse the same one.\n             r.content\n             r.raw.release_conn()\n \n-            r.request.headers['Authorization'] = 'Digest %s' % (base)\n+            r.request.headers['Authorization'] = self.build_digest_header(r.request.method, r.request.url)\n             r.request.send(anyway=True)\n             _r = r.request.response\n             _r.history.append(r)\n@@ -242,6 +247,9 @@ class HTTPDigestAuth(AuthBase):\n         return r\n \n     def __call__(self, r):\n+        # If we have a saved nonce, skip the 401\n+        if self.last_nonce:\n+            r.headers['Authorization'] = self.build_digest_header(r.method, r.url)    \n         r.register_hook('response', self.handle_401)\n         return r\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#6d0203609294a9f95b2808515829b3c371aaac74", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 965 | Contributors (this commit): 20 | Commits (past 90d): 26 | Contributors (cumulative): 20 | DMM Complexity: 1.0\n\nDIFF:\n@@ -277,6 +277,11 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n \n             r = get(url, auth=auth)\n             self.assertEqual(r.status_code, 200)\n+            self.assertEqual(len(r.history), 1)\n+\n+            r = get(url, auth=auth)\n+            self.assertEqual(r.status_code, 200)\n+            self.assertEqual(len(r.history), 0)\n \n             r = get(url)\n             self.assertEqual(r.status_code, 401)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f01694e2743c9883ca316d3abd8d2385d5c5f37e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): -5/2 | Churn Δ: 6 | Churn Cumulative: 6599 | Contributors (this commit): 82 | Commits (past 90d): 68 | Contributors (cumulative): 100 | DMM Complexity: 0.0\n\nDIFF:\n@@ -348,6 +348,7 @@ class Request(object):\n         if (not files) or isinstance(self.data, str):\n             return None\n \n+        new_fields = []\n         fields = to_key_val_list(self.data)\n         files = to_key_val_list(files)\n \n@@ -362,9 +363,8 @@ class Request(object):\n                 fp = StringIO(fp)\n             if isinstance(fp, bytes):\n                 fp = BytesIO(fp)\n-            fields.append((k, (fn, fp.read())))\n+            new_fields.append((k, (fn, fp.read())))\n \n-        new_fields = []\n         for field, val in fields:\n             if isinstance(val, list):\n                 for v in val:\n\n@@ -1038,8 +1038,6 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n         self.assertEqual(t.get('form'), {'field': ['a', 'b']})\n         self.assertEqual(t.get('files'), files)\n         r = post(httpbin('post'), data=data, files=files.items())\n-        t = r.json\n-        self.assertEqual(t.get('form'), {'field': 'a, b'})\n         self.assertEqual(t.get('files'), files)\n \n     def test_str_data_content_type(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#ab56e4a9f170c2c951d443853466f27b31dcc256", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 8 | Lines Deleted: 7 | Files Changed: 2 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 15 | Churn Cumulative: 1962 | Contributors (this commit): 32 | Commits (past 90d): 34 | Contributors (cumulative): 38 | DMM Complexity: 1.0\n\nDIFF:\n@@ -72,7 +72,8 @@ class Session(object):\n         verify=True,\n         cert=None):\n \n-        self.headers = to_key_val_list(headers or [])\n+        #self.headers = to_key_val_list(headers or [])\n+        self.headers = headers or {}\n         self.auth = auth\n         self.timeout = timeout\n         self.proxies = to_key_val_list(proxies or [])\n@@ -160,7 +161,7 @@ class Session(object):\n         # Default empty dicts for dict params.\n         data = [] if data is None else data\n         files = [] if files is None else files\n-        headers = [] if headers is None else headers\n+        headers = {} if headers is None else headers\n         params = [] if params is None else params\n         hooks = {} if hooks is None else hooks\n         prefetch = prefetch if prefetch is not None else self.prefetch\n@@ -171,10 +172,10 @@ class Session(object):\n \n         # Expand header values.\n         if headers:\n-            expanded = []\n-            for k, v in to_key_val_list(headers):\n-                expanded.append((k, header_expand(v)))\n-            headers = expanded\n+            #e = [(k, header_expand(v)) for k, v in to_key_val_list(headers)]\n+            #headers = e\n+            for k, v in list(headers.items()) or {}:\n+                headers[k] = header_expand(v)\n \n         args = dict(\n             method=method,\n\n@@ -977,7 +977,7 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n             # Don't choke on headers with none in the value.\n             requests.get(httpbin('headers'), headers={'Foo': None})\n         except TypeError:\n-            self.fail()\n+            self.fail('Not able to have none in header values')\n \n     def test_danger_mode_redirects(self):\n         s = requests.session()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#a04775f862c479d017689dddf28c6e6a84beb74e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 101 | Contributors (this commit): 6 | Commits (past 90d): 3 | Contributors (cumulative): 6 | DMM Complexity: None\n\nDIFF:\n@@ -117,7 +117,7 @@ class RequestsTestSuite(unittest.TestCase):\n         # cookies of the first domain should NOT be sent to the next one\n         r3 = s.get(url='http://tinyurl.com/7zp3jnr')\n         assert r3.url == 'http://httpbin.org/cookies'\n-        self.assertTrue('preview' not in json.loads(r2.text)['cookies'])\n+        self.assertTrue('preview' not in json.loads(r3.text)['cookies'])\n \n if __name__ == '__main__':\n     unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#a5d462e176c61c9967ef6cbcc0ef50a4764dc0b6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 24 | Files Changed: 1 | Hunks: 12 | Methods Changed: 7 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 35 | Churn Cumulative: 1004 | Contributors (this commit): 20 | Commits (past 90d): 29 | Contributors (cumulative): 20 | DMM Complexity: 0.0\n\nDIFF:\n@@ -52,18 +52,15 @@ class TestSetup(object):\n             # time.sleep(1)\n             _httpbin = True\n \n-\n class TestBaseMixin(object):\n \n     def assertCookieHas(self, cookie, **kwargs):\n         \"\"\"Assert that a cookie has various specified properties.\"\"\"\n         for attr, expected_value in kwargs.items():\n             cookie_attr = getattr(cookie, attr)\n-            message = 'Failed comparison for %s: %s != %s' % (attr,\n-                    cookie_attr, expected_value)\n+            message = 'Failed comparison for %s: %s != %s' % (attr, cookie_attr, expected_value)\n             self.assertEqual(cookie_attr, expected_value, message)\n \n-\n class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n     \"\"\"Requests test cases.\"\"\"\n \n@@ -129,8 +126,7 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n     def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):\n         heads = {'User-agent': 'Mozilla/5.0'}\n \n-        r = get(httpbin('get') + '?test=true', params={'q': 'test'},\n-                headers=heads)\n+        r = get(httpbin('get') + '?test=true', params={'q': 'test'}, headers=heads)\n         self.assertEqual(r.status_code, 200)\n \n     # def test_unicode_headers(self):\n@@ -775,8 +771,7 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n         self.assertEqual(c, _c)\n \n         # Have the server set a cookie.\n-        r = get(httpbin('cookies', 'set', 'k', 'v'), allow_redirects=True,\n-                session=s)\n+        r = get(httpbin('cookies', 'set', 'k', 'v'), allow_redirects=True, session=s)\n         c = json.loads(r.text).get('cookies')\n \n         assert 'k' in c\n@@ -841,8 +836,7 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n \n     def test_unpickled_session_requests(self):\n         s = requests.session()\n-        r = get(httpbin('cookies', 'set', 'k', 'v'), allow_redirects=True,\n-                session=s)\n+        r = get(httpbin('cookies', 'set', 'k', 'v'), allow_redirects=True, session=s)\n         c = json.loads(r.text).get('cookies')\n         assert 'k' in c\n \n@@ -984,31 +978,24 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n         s.config['danger_mode'] = True\n         s.get(httpbin('redirect', '4'))\n \n+\n     def test_empty_response(self):\n         r = requests.get(httpbin('status', '404'))\n         r.text\n \n     def test_max_redirects(self):\n-        \"\"\"Test the max_redirects config variable, normally and under\n-        safe_mode.\n-        \"\"\"\n+        \"\"\"Test the max_redirects config variable, normally and under safe_mode.\"\"\"\n         def unsafe_callable():\n-            requests.get(httpbin('redirect', '3'),\n-                    config=dict(max_redirects=2))\n-        self.assertRaises(requests.exceptions.TooManyRedirects,\n-                unsafe_callable)\n+            requests.get(httpbin('redirect', '3'), config=dict(max_redirects=2))\n+        self.assertRaises(requests.exceptions.TooManyRedirects, unsafe_callable)\n \n         # add safe mode\n-        response = requests.get(httpbin('redirect', '3'),\n-                config=dict(safe_mode=True, max_redirects=2))\n+        response = requests.get(httpbin('redirect', '3'), config=dict(safe_mode=True, max_redirects=2))\n         self.assertTrue(response.content is None)\n-        self.assertTrue(isinstance(response.error,\n-                requests.exceptions.TooManyRedirects))\n+        self.assertTrue(isinstance(response.error, requests.exceptions.TooManyRedirects))\n \n     def test_connection_keepalive_and_close(self):\n-        \"\"\"Test that we send 'Connection: close' when keep_alive is\n-        disabled.\n-        \"\"\"\n+        \"\"\"Test that we send 'Connection: close' when keep_alive is disabled.\"\"\"\n         # keep-alive should be on by default\n         r1 = requests.get(httpbin('get'))\n         # XXX due to proxying issues, test the header sent back by httpbin, rather than\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b130b98086e1826bd0ade3fd9a899e49eeb253ec", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 371 | Contributors (this commit): 3 | Commits (past 90d): 7 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -15,8 +15,8 @@ requests\n \"\"\"\n \n __title__ = 'requests'\n-__version__ = '0.13.6'\n-__build__ = 0x001306\n+__version__ = '0.13.7'\n+__build__ = 0x001307\n __author__ = 'Kenneth Reitz'\n __license__ = 'ISC'\n __copyright__ = 'Copyright 2012 Kenneth Reitz'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f48c78c9eebde590dfadc7f0d89e1de1ed9f85b3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 13 | Churn Cumulative: 5645 | Contributors (this commit): 80 | Commits (past 90d): 42 | Contributors (cumulative): 80 | DMM Complexity: None\n\nDIFF:\n@@ -352,6 +352,13 @@ class Request(object):\n         fields = to_key_val_list(self.data)\n         files = to_key_val_list(files)\n \n+        for field, val in fields:\n+            if isinstance(val, list):\n+                for v in val:\n+                    new_fields.append((k, str(v)))\n+            else:\n+                new_fields.append((field, str(val)))\n+\n         for (k, v) in files:\n             # support for explicit filename\n             if isinstance(v, (tuple, list)):\n@@ -365,12 +372,6 @@ class Request(object):\n                 fp = BytesIO(fp)\n             new_fields.append((k, (fn, fp.read())))\n \n-        for field, val in fields:\n-            if isinstance(val, list):\n-                for v in val:\n-                    new_fields.append((k, str(v)))\n-            else:\n-                new_fields.append((field, str(val)))\n         body, content_type = encode_multipart_formdata(new_fields)\n \n         return body, content_type\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#6d418d91324c77c6b131abcdbe7a82095ea074dc", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 5647 | Contributors (this commit): 80 | Commits (past 90d): 43 | Contributors (cumulative): 80 | DMM Complexity: None\n\nDIFF:\n@@ -355,7 +355,7 @@ class Request(object):\n         for field, val in fields:\n             if isinstance(val, list):\n                 for v in val:\n-                    new_fields.append((k, str(v)))\n+                    new_fields.append((field, str(v)))\n             else:\n                 new_fields.append((field, str(val)))\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c19650b00f0c169cdf6372a093425830e11a8771", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 10 | Churn Cumulative: 2150 | Contributors (this commit): 2 | Commits (past 90d): 4 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -96,9 +96,17 @@ class VerifiedHTTPSConnection(HTTPSConnection):\n \n         # Wrap socket using verification with the root certs in\n         # trusted_root_certs\n+        try:\n           self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file,\n                                       cert_reqs=self.cert_reqs,\n-                                    ca_certs=self.ca_certs)\n+                                      ca_certs=self.ca_certs,\n+                                      ssl_version=ssl.PROTOCOL_SSLv3)\n+        except ssl.SSLError:\n+          self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file,\n+                                      cert_reqs=self.cert_reqs,\n+                                      ca_certs=self.ca_certs,\n+                                      ssl_version=ssl.PROTOCOL_SSLv23)\n+\n         if self.ca_certs:\n             match_hostname(self.sock.getpeercert(), self.host)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#301d1a838f56c6c8e5e886b7dde3de88656cfae4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 3 | Churn Cumulative: 730 | Contributors (this commit): 13 | Commits (past 90d): 9 | Contributors (cumulative): 13 | DMM Complexity: 0.0\n\nDIFF:\n@@ -78,7 +78,8 @@ class OAuth1(AuthBase):\n         # extract_params will not give params unless the body is a properly\n         # formatted string, a dictionary or a list of 2-tuples.\n         decoded_body = extract_params(r.data)\n-        if contenttype == None and decoded_body != None:\n+        if (contenttype is None or contenttype.lower() == \"application/x-www-form-urlencoded\")\\\n+            and decoded_body != None:\n             # extract_params can only check the present r.data and does not know\n             # of r.files, thus an extra check is performed. We know that\n             # if files are present the request will not have\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e5fc88ad37418cc7d52c15011c06b10c46b02dff", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 357 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 29 | Complexity Δ (Sum/Max): 58/58 | Churn Δ: 357 | Churn Cumulative: 1244 | Contributors (this commit): 6 | Commits (past 90d): 2 | Contributors (cumulative): 6 | DMM Complexity: 0.864\n\nDIFF:\n@@ -8,6 +8,7 @@ Data structures that power Requests.\n \n \"\"\"\n \n+_missing = KeyError\n \n class CaseInsensitiveDict(dict):\n     \"\"\"Case-insensitive Dictionary\n@@ -65,3 +66,359 @@ class LookupDict(dict):\n \n     def get(self, key, default=None):\n         return self.__dict__.get(key, default)\n+\n+\n+class TypeConversionDict(dict):\n+    \"\"\"Works like a regular dict but the :meth:`get` method can perform\n+    type conversions.  :class:`MultiDict` and :class:`CombinedMultiDict`\n+    are subclasses of this class and provide the same feature.\n+\n+    .. versionadded:: 0.5\n+    \"\"\"\n+\n+    def get(self, key, default=None, type=None):\n+        \"\"\"Return the default value if the requested data doesn't exist.\n+        If `type` is provided and is a callable it should convert the value,\n+        return it or raise a :exc:`ValueError` if that is not possible.  In\n+        this case the function will return the default as if the value was not\n+        found:\n+\n+        >>> d = TypeConversionDict(foo='42', bar='blub')\n+        >>> d.get('foo', type=int)\n+        42\n+        >>> d.get('bar', -1, type=int)\n+        -1\n+\n+        :param key: The key to be looked up.\n+        :param default: The default value to be returned if the key can't\n+                        be looked up.  If not further specified `None` is\n+                        returned.\n+        :param type: A callable that is used to cast the value in the\n+                     :class:`MultiDict`.  If a :exc:`ValueError` is raised\n+                     by this callable the default value is returned.\n+        \"\"\"\n+        try:\n+            rv = self[key]\n+            if type is not None:\n+                rv = type(rv)\n+        except (KeyError, ValueError):\n+            rv = default\n+        return rv\n+\n+\n+class MultiDict(TypeConversionDict):\n+    \"\"\"A :class:`MultiDict` is a dictionary subclass customized to deal with\n+    multiple values for the same key which is for example used by the parsing\n+    functions in the wrappers.  This is necessary because some HTML form\n+    elements pass multiple values for the same key.\n+\n+    :class:`MultiDict` implements all standard dictionary methods.\n+    Internally, it saves all values for a key as a list, but the standard dict\n+    access methods will only return the first value for a key. If you want to\n+    gain access to the other values, too, you have to use the `list` methods as\n+    explained below.\n+\n+    Basic Usage:\n+\n+    >>> d = MultiDict([('a', 'b'), ('a', 'c')])\n+    >>> d\n+    MultiDict([('a', 'b'), ('a', 'c')])\n+    >>> d['a']\n+    'b'\n+    >>> d.getlist('a')\n+    ['b', 'c']\n+    >>> 'a' in d\n+    True\n+\n+    It behaves like a normal dict thus all dict functions will only return the\n+    first value when multiple values for one key are found.\n+\n+    From Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a\n+    subclass of the :exc:`~exceptions.BadRequest` HTTP exception and will\n+    render a page for a ``400 BAD REQUEST`` if caught in a catch-all for HTTP\n+    exceptions.\n+\n+    A :class:`MultiDict` can be constructed from an iterable of\n+    ``(key, value)`` tuples, a dict, a :class:`MultiDict` or from Werkzeug 0.2\n+    onwards some keyword parameters.\n+\n+    :param mapping: the initial value for the :class:`MultiDict`.  Either a\n+                    regular dict, an iterable of ``(key, value)`` tuples\n+                    or `None`.\n+    \"\"\"\n+\n+    def __init__(self, mapping=None):\n+        if isinstance(mapping, MultiDict):\n+            dict.__init__(self, ((k, l[:]) for k, l in mapping.iterlists()))\n+        elif isinstance(mapping, dict):\n+            tmp = {}\n+            for key, value in mapping.iteritems():\n+                if isinstance(value, (tuple, list)):\n+                    value = list(value)\n+                else:\n+                    value = [value]\n+                tmp[key] = value\n+            dict.__init__(self, tmp)\n+        else:\n+            tmp = {}\n+            for key, value in mapping or ():\n+                tmp.setdefault(key, []).append(value)\n+            dict.__init__(self, tmp)\n+\n+    def __getstate__(self):\n+        return dict(self.lists())\n+\n+    def __setstate__(self, value):\n+        dict.clear(self)\n+        dict.update(self, value)\n+\n+    def __iter__(self):\n+        return self.iterkeys()\n+\n+    def __getitem__(self, key):\n+        \"\"\"Return the first data value for this key;\n+        raises KeyError if not found.\n+\n+        :param key: The key to be looked up.\n+        :raise KeyError: if the key does not exist.\n+        \"\"\"\n+        if key in self:\n+            return dict.__getitem__(self, key)[0]\n+        raise BadRequestKeyError(key)\n+\n+    def __setitem__(self, key, value):\n+        \"\"\"Like :meth:`add` but removes an existing key first.\n+\n+        :param key: the key for the value.\n+        :param value: the value to set.\n+        \"\"\"\n+        dict.__setitem__(self, key, [value])\n+\n+    def add(self, key, value):\n+        \"\"\"Adds a new value for the key.\n+\n+        .. versionadded:: 0.6\n+\n+        :param key: the key for the value.\n+        :param value: the value to add.\n+        \"\"\"\n+        dict.setdefault(self, key, []).append(value)\n+\n+    def getlist(self, key, type=None):\n+        \"\"\"Return the list of items for a given key. If that key is not in the\n+        `MultiDict`, the return value will be an empty list.  Just as `get`\n+        `getlist` accepts a `type` parameter.  All items will be converted\n+        with the callable defined there.\n+\n+        :param key: The key to be looked up.\n+        :param type: A callable that is used to cast the value in the\n+                     :class:`MultiDict`.  If a :exc:`ValueError` is raised\n+                     by this callable the value will be removed from the list.\n+        :return: a :class:`list` of all the values for the key.\n+        \"\"\"\n+        try:\n+            rv = dict.__getitem__(self, key)\n+        except KeyError:\n+            return []\n+        if type is None:\n+            return list(rv)\n+        result = []\n+        for item in rv:\n+            try:\n+                result.append(type(item))\n+            except ValueError:\n+                pass\n+        return result\n+\n+    def setlist(self, key, new_list):\n+        \"\"\"Remove the old values for a key and add new ones.  Note that the list\n+        you pass the values in will be shallow-copied before it is inserted in\n+        the dictionary.\n+\n+        >>> d = MultiDict()\n+        >>> d.setlist('foo', ['1', '2'])\n+        >>> d['foo']\n+        '1'\n+        >>> d.getlist('foo')\n+        ['1', '2']\n+\n+        :param key: The key for which the values are set.\n+        :param new_list: An iterable with the new values for the key.  Old values\n+                         are removed first.\n+        \"\"\"\n+        dict.__setitem__(self, key, list(new_list))\n+\n+    def setdefault(self, key, default=None):\n+        \"\"\"Returns the value for the key if it is in the dict, otherwise it\n+        returns `default` and sets that value for `key`.\n+\n+        :param key: The key to be looked up.\n+        :param default: The default value to be returned if the key is not\n+                        in the dict.  If not further specified it's `None`.\n+        \"\"\"\n+        if key not in self:\n+            self[key] = default\n+        else:\n+            default = self[key]\n+        return default\n+\n+    def setlistdefault(self, key, default_list=None):\n+        \"\"\"Like `setdefault` but sets multiple values.  The list returned\n+        is not a copy, but the list that is actually used internally.  This\n+        means that you can put new values into the dict by appending items\n+        to the list:\n+\n+        >>> d = MultiDict({\"foo\": 1})\n+        >>> d.setlistdefault(\"foo\").extend([2, 3])\n+        >>> d.getlist(\"foo\")\n+        [1, 2, 3]\n+\n+        :param key: The key to be looked up.\n+        :param default: An iterable of default values.  It is either copied\n+                        (in case it was a list) or converted into a list\n+                        before returned.\n+        :return: a :class:`list`\n+        \"\"\"\n+        if key not in self:\n+            default_list = list(default_list or ())\n+            dict.__setitem__(self, key, default_list)\n+        else:\n+            default_list = dict.__getitem__(self, key)\n+        return default_list\n+\n+    def items(self, multi=False):\n+        \"\"\"Return a list of ``(key, value)`` pairs.\n+\n+        :param multi: If set to `True` the list returned will have a\n+                      pair for each value of each key.  Otherwise it\n+                      will only contain pairs for the first value of\n+                      each key.\n+\n+        :return: a :class:`list`\n+        \"\"\"\n+        return list(self.iteritems(multi))\n+\n+    def lists(self):\n+        \"\"\"Return a list of ``(key, values)`` pairs, where values is the list of\n+        all values associated with the key.\n+\n+        :return: a :class:`list`\n+        \"\"\"\n+        return list(self.iterlists())\n+\n+    def values(self):\n+        \"\"\"Returns a list of the first value on every key's value list.\n+\n+        :return: a :class:`list`.\n+        \"\"\"\n+        return [self[key] for key in self.iterkeys()]\n+\n+    def listvalues(self):\n+        \"\"\"Return a list of all values associated with a key.  Zipping\n+        :meth:`keys` and this is the same as calling :meth:`lists`:\n+\n+        >>> d = MultiDict({\"foo\": [1, 2, 3]})\n+        >>> zip(d.keys(), d.listvalues()) == d.lists()\n+        True\n+\n+        :return: a :class:`list`\n+        \"\"\"\n+        return list(self.iterlistvalues())\n+\n+    def iteritems(self, multi=False):\n+        \"\"\"Like :meth:`items` but returns an iterator.\"\"\"\n+        for key, values in dict.iteritems(self):\n+            if multi:\n+                for value in values:\n+                    yield key, value\n+            else:\n+                yield key, values[0]\n+\n+    def iterlists(self):\n+        \"\"\"Like :meth:`items` but returns an iterator.\"\"\"\n+        for key, values in dict.iteritems(self):\n+            yield key, list(values)\n+\n+    def itervalues(self):\n+        \"\"\"Like :meth:`values` but returns an iterator.\"\"\"\n+        for values in dict.itervalues(self):\n+            yield values[0]\n+\n+    def iterlistvalues(self):\n+        \"\"\"Like :meth:`listvalues` but returns an iterator.\"\"\"\n+        return dict.itervalues(self)\n+\n+    def copy(self):\n+        \"\"\"Return a shallow copy of this object.\"\"\"\n+        return self.__class__(self)\n+\n+    def to_dict(self, flat=True):\n+        \"\"\"Return the contents as regular dict.  If `flat` is `True` the\n+        returned dict will only have the first item present, if `flat` is\n+        `False` all values will be returned as lists.\n+\n+        :param flat: If set to `False` the dict returned will have lists\n+                     with all the values in it.  Otherwise it will only\n+                     contain the first value for each key.\n+        :return: a :class:`dict`\n+        \"\"\"\n+        if flat:\n+            return dict(self.iteritems())\n+        return dict(self.lists())\n+\n+    def update(self, other_dict):\n+        \"\"\"update() extends rather than replaces existing key lists.\"\"\"\n+        for key, value in iter_multi_items(other_dict):\n+            MultiDict.add(self, key, value)\n+\n+    def pop(self, key, default=_missing):\n+        \"\"\"Pop the first item for a list on the dict.  Afterwards the\n+        key is removed from the dict, so additional values are discarded:\n+\n+        >>> d = MultiDict({\"foo\": [1, 2, 3]})\n+        >>> d.pop(\"foo\")\n+        1\n+        >>> \"foo\" in d\n+        False\n+\n+        :param key: the key to pop.\n+        :param default: if provided the value to return if the key was\n+                        not in the dictionary.\n+        \"\"\"\n+        try:\n+            return dict.pop(self, key)[0]\n+        except KeyError, e:\n+            if default is not _missing:\n+                return default\n+            raise BadRequestKeyError(str(e))\n+\n+    def popitem(self):\n+        \"\"\"Pop an item from the dict.\"\"\"\n+        try:\n+            item = dict.popitem(self)\n+            return (item[0], item[1][0])\n+        except KeyError, e:\n+            raise BadRequestKeyError(str(e))\n+\n+    def poplist(self, key):\n+        \"\"\"Pop the list for a key from the dict.  If the key is not in the dict\n+        an empty list is returned.\n+\n+        .. versionchanged:: 0.5\n+           If the key does no longer exist a list is returned instead of\n+           raising an error.\n+        \"\"\"\n+        return dict.pop(self, key, [])\n+\n+    def popitemlist(self):\n+        \"\"\"Pop a ``(key, list)`` tuple from the dict.\"\"\"\n+        try:\n+            return dict.popitem(self)\n+        except KeyError, e:\n+            raise BadRequestKeyError(str(e))\n+\n+    def __copy__(self):\n+        return self.copy()\n+\n+    def __repr__(self):\n+        return '%s(%r)' % (self.__class__.__name__, self.items(multi=True))\n\\ No newline at end of file\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f3159ed4f619124ab4b47c4e0f06f96daed762ce", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 33 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 10/10 | Churn Δ: 33 | Churn Cumulative: 1474 | Contributors (this commit): 28 | Commits (past 90d): 10 | Contributors (cumulative): 28 | DMM Complexity: 1.0\n\nDIFF:\n@@ -518,3 +518,36 @@ def default_user_agent():\n             '%s/%s' % (_implementation, _implementation_version),\n             '%s/%s' % (platform.system(), platform.release()),\n         ])\n+\n+def parse_header_links(value):\n+    \"\"\"Return a dict of parsed link headers proxies.\n+\n+    i.e. Link: <http:/.../front.jpeg>; rel=front; type=\"image/jpeg\",<http://.../back.jpeg>; rel=back;type=\"image/jpeg\"\n+\n+    \"\"\"\n+    \n+    links = []\n+\n+    replace_chars = \" '\\\"\"\n+\n+    for val in value.split(\",\"):\n+        try:\n+            url, params = val.split(\";\", 1)\n+        except ValueError:\n+            url, params = val, ''\n+\n+        link = {}\n+\n+        link[\"url\"] = url.strip(\"<> '\\\"\")\n+\n+        for param in params.split(\";\"):\n+            try:\n+                key,value = param.split(\"=\")\n+            except ValueError:\n+                break\n+            \n+            link[key.strip(replace_chars)] = value.strip(replace_chars)\n+\n+        links.append(link)\n+\n+    return links\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#d8dcd35316621df0691ab5fc3fe1d5f3d76f71bb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 21 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 24 | Churn Cumulative: 5671 | Contributors (this commit): 80 | Commits (past 90d): 44 | Contributors (cumulative): 80 | DMM Complexity: 1.0\n\nDIFF:\n@@ -13,7 +13,7 @@ from datetime import datetime\n from io import BytesIO\n \n from .hooks import dispatch_hook, HOOKS\n-from .structures import CaseInsensitiveDict\n+from .structures import CaseInsensitiveDict, MultiDict\n from .status_codes import codes\n \n from .auth import HTTPBasicAuth, HTTPProxyAuth\n@@ -31,7 +31,7 @@ from .exceptions import (\n from .utils import (\n     get_encoding_from_headers, stream_untransfer, guess_filename, requote_uri,\n     stream_decode_response_unicode, get_netrc_auth, get_environ_proxies,\n-    to_key_val_list, DEFAULT_CA_BUNDLE_PATH)\n+    to_key_val_list, DEFAULT_CA_BUNDLE_PATH, parse_header_links)\n from .compat import (\n     cookielib, urlparse, urlunparse, urljoin, urlsplit, urlencode, str, bytes,\n     StringIO, is_py2, chardet, json, builtin_str, numeric_types)\n@@ -833,12 +833,30 @@ class Response(object):\n \n     @property\n     def json(self):\n-        \"\"\"Returns the json-encoded content of a request, if any.\"\"\"\n+        \"\"\"Returns the json-encoded content of a response, if any.\"\"\"\n         try:\n             return json.loads(self.text or self.content)\n         except ValueError:\n             return None\n \n+    @property\n+    def links(self):\n+        \"\"\"Returns the parsed header links of the response, if any.\"\"\"\n+\n+        header = self.headers['link']\n+\n+        # l = MultiDict()\n+        l = {}\n+\n+        if header:\n+            links = parse_header_links(header)\n+\n+            for link in links:\n+                key = link.get('rel') or link.get('url')\n+                l[key] = link\n+\n+        return l\n+\n     @property\n     def reason(self):\n         \"\"\"The HTTP Reason for the response.\"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c323047dbe5cfb892eada9c37037145738507c5e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 359 | Files Changed: 2 | Hunks: 3 | Methods Changed: 29 | Complexity Δ (Sum/Max): -58/0 | Churn Δ: 360 | Churn Cumulative: 7275 | Contributors (this commit): 83 | Commits (past 90d): 48 | Contributors (cumulative): 86 | DMM Complexity: 0.136\n\nDIFF:\n@@ -13,7 +13,7 @@ from datetime import datetime\n from io import BytesIO\n \n from .hooks import dispatch_hook, HOOKS\n-from .structures import CaseInsensitiveDict, MultiDict\n+from .structures import CaseInsensitiveDict\n from .status_codes import codes\n \n from .auth import HTTPBasicAuth, HTTPProxyAuth\n\n@@ -8,8 +8,6 @@ Data structures that power Requests.\n \n \"\"\"\n \n-_missing = KeyError\n-\n class CaseInsensitiveDict(dict):\n     \"\"\"Case-insensitive Dictionary\n \n@@ -66,359 +64,3 @@ class LookupDict(dict):\n \n     def get(self, key, default=None):\n         return self.__dict__.get(key, default)\n-\n-\n-class TypeConversionDict(dict):\n-    \"\"\"Works like a regular dict but the :meth:`get` method can perform\n-    type conversions.  :class:`MultiDict` and :class:`CombinedMultiDict`\n-    are subclasses of this class and provide the same feature.\n-\n-    .. versionadded:: 0.5\n-    \"\"\"\n-\n-    def get(self, key, default=None, type=None):\n-        \"\"\"Return the default value if the requested data doesn't exist.\n-        If `type` is provided and is a callable it should convert the value,\n-        return it or raise a :exc:`ValueError` if that is not possible.  In\n-        this case the function will return the default as if the value was not\n-        found:\n-\n-        >>> d = TypeConversionDict(foo='42', bar='blub')\n-        >>> d.get('foo', type=int)\n-        42\n-        >>> d.get('bar', -1, type=int)\n-        -1\n-\n-        :param key: The key to be looked up.\n-        :param default: The default value to be returned if the key can't\n-                        be looked up.  If not further specified `None` is\n-                        returned.\n-        :param type: A callable that is used to cast the value in the\n-                     :class:`MultiDict`.  If a :exc:`ValueError` is raised\n-                     by this callable the default value is returned.\n-        \"\"\"\n-        try:\n-            rv = self[key]\n-            if type is not None:\n-                rv = type(rv)\n-        except (KeyError, ValueError):\n-            rv = default\n-        return rv\n-\n-\n-class MultiDict(TypeConversionDict):\n-    \"\"\"A :class:`MultiDict` is a dictionary subclass customized to deal with\n-    multiple values for the same key which is for example used by the parsing\n-    functions in the wrappers.  This is necessary because some HTML form\n-    elements pass multiple values for the same key.\n-\n-    :class:`MultiDict` implements all standard dictionary methods.\n-    Internally, it saves all values for a key as a list, but the standard dict\n-    access methods will only return the first value for a key. If you want to\n-    gain access to the other values, too, you have to use the `list` methods as\n-    explained below.\n-\n-    Basic Usage:\n-\n-    >>> d = MultiDict([('a', 'b'), ('a', 'c')])\n-    >>> d\n-    MultiDict([('a', 'b'), ('a', 'c')])\n-    >>> d['a']\n-    'b'\n-    >>> d.getlist('a')\n-    ['b', 'c']\n-    >>> 'a' in d\n-    True\n-\n-    It behaves like a normal dict thus all dict functions will only return the\n-    first value when multiple values for one key are found.\n-\n-    From Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a\n-    subclass of the :exc:`~exceptions.BadRequest` HTTP exception and will\n-    render a page for a ``400 BAD REQUEST`` if caught in a catch-all for HTTP\n-    exceptions.\n-\n-    A :class:`MultiDict` can be constructed from an iterable of\n-    ``(key, value)`` tuples, a dict, a :class:`MultiDict` or from Werkzeug 0.2\n-    onwards some keyword parameters.\n-\n-    :param mapping: the initial value for the :class:`MultiDict`.  Either a\n-                    regular dict, an iterable of ``(key, value)`` tuples\n-                    or `None`.\n-    \"\"\"\n-\n-    def __init__(self, mapping=None):\n-        if isinstance(mapping, MultiDict):\n-            dict.__init__(self, ((k, l[:]) for k, l in mapping.iterlists()))\n-        elif isinstance(mapping, dict):\n-            tmp = {}\n-            for key, value in mapping.iteritems():\n-                if isinstance(value, (tuple, list)):\n-                    value = list(value)\n-                else:\n-                    value = [value]\n-                tmp[key] = value\n-            dict.__init__(self, tmp)\n-        else:\n-            tmp = {}\n-            for key, value in mapping or ():\n-                tmp.setdefault(key, []).append(value)\n-            dict.__init__(self, tmp)\n-\n-    def __getstate__(self):\n-        return dict(self.lists())\n-\n-    def __setstate__(self, value):\n-        dict.clear(self)\n-        dict.update(self, value)\n-\n-    def __iter__(self):\n-        return self.iterkeys()\n-\n-    def __getitem__(self, key):\n-        \"\"\"Return the first data value for this key;\n-        raises KeyError if not found.\n-\n-        :param key: The key to be looked up.\n-        :raise KeyError: if the key does not exist.\n-        \"\"\"\n-        if key in self:\n-            return dict.__getitem__(self, key)[0]\n-        raise BadRequestKeyError(key)\n-\n-    def __setitem__(self, key, value):\n-        \"\"\"Like :meth:`add` but removes an existing key first.\n-\n-        :param key: the key for the value.\n-        :param value: the value to set.\n-        \"\"\"\n-        dict.__setitem__(self, key, [value])\n-\n-    def add(self, key, value):\n-        \"\"\"Adds a new value for the key.\n-\n-        .. versionadded:: 0.6\n-\n-        :param key: the key for the value.\n-        :param value: the value to add.\n-        \"\"\"\n-        dict.setdefault(self, key, []).append(value)\n-\n-    def getlist(self, key, type=None):\n-        \"\"\"Return the list of items for a given key. If that key is not in the\n-        `MultiDict`, the return value will be an empty list.  Just as `get`\n-        `getlist` accepts a `type` parameter.  All items will be converted\n-        with the callable defined there.\n-\n-        :param key: The key to be looked up.\n-        :param type: A callable that is used to cast the value in the\n-                     :class:`MultiDict`.  If a :exc:`ValueError` is raised\n-                     by this callable the value will be removed from the list.\n-        :return: a :class:`list` of all the values for the key.\n-        \"\"\"\n-        try:\n-            rv = dict.__getitem__(self, key)\n-        except KeyError:\n-            return []\n-        if type is None:\n-            return list(rv)\n-        result = []\n-        for item in rv:\n-            try:\n-                result.append(type(item))\n-            except ValueError:\n-                pass\n-        return result\n-\n-    def setlist(self, key, new_list):\n-        \"\"\"Remove the old values for a key and add new ones.  Note that the list\n-        you pass the values in will be shallow-copied before it is inserted in\n-        the dictionary.\n-\n-        >>> d = MultiDict()\n-        >>> d.setlist('foo', ['1', '2'])\n-        >>> d['foo']\n-        '1'\n-        >>> d.getlist('foo')\n-        ['1', '2']\n-\n-        :param key: The key for which the values are set.\n-        :param new_list: An iterable with the new values for the key.  Old values\n-                         are removed first.\n-        \"\"\"\n-        dict.__setitem__(self, key, list(new_list))\n-\n-    def setdefault(self, key, default=None):\n-        \"\"\"Returns the value for the key if it is in the dict, otherwise it\n-        returns `default` and sets that value for `key`.\n-\n-        :param key: The key to be looked up.\n-        :param default: The default value to be returned if the key is not\n-                        in the dict.  If not further specified it's `None`.\n-        \"\"\"\n-        if key not in self:\n-            self[key] = default\n-        else:\n-            default = self[key]\n-        return default\n-\n-    def setlistdefault(self, key, default_list=None):\n-        \"\"\"Like `setdefault` but sets multiple values.  The list returned\n-        is not a copy, but the list that is actually used internally.  This\n-        means that you can put new values into the dict by appending items\n-        to the list:\n-\n-        >>> d = MultiDict({\"foo\": 1})\n-        >>> d.setlistdefault(\"foo\").extend([2, 3])\n-        >>> d.getlist(\"foo\")\n-        [1, 2, 3]\n-\n-        :param key: The key to be looked up.\n-        :param default: An iterable of default values.  It is either copied\n-                        (in case it was a list) or converted into a list\n-                        before returned.\n-        :return: a :class:`list`\n-        \"\"\"\n-        if key not in self:\n-            default_list = list(default_list or ())\n-            dict.__setitem__(self, key, default_list)\n-        else:\n-            default_list = dict.__getitem__(self, key)\n-        return default_list\n-\n-    def items(self, multi=False):\n-        \"\"\"Return a list of ``(key, value)`` pairs.\n-\n-        :param multi: If set to `True` the list returned will have a\n-                      pair for each value of each key.  Otherwise it\n-                      will only contain pairs for the first value of\n-                      each key.\n-\n-        :return: a :class:`list`\n-        \"\"\"\n-        return list(self.iteritems(multi))\n-\n-    def lists(self):\n-        \"\"\"Return a list of ``(key, values)`` pairs, where values is the list of\n-        all values associated with the key.\n-\n-        :return: a :class:`list`\n-        \"\"\"\n-        return list(self.iterlists())\n-\n-    def values(self):\n-        \"\"\"Returns a list of the first value on every key's value list.\n-\n-        :return: a :class:`list`.\n-        \"\"\"\n-        return [self[key] for key in self.iterkeys()]\n-\n-    def listvalues(self):\n-        \"\"\"Return a list of all values associated with a key.  Zipping\n-        :meth:`keys` and this is the same as calling :meth:`lists`:\n-\n-        >>> d = MultiDict({\"foo\": [1, 2, 3]})\n-        >>> zip(d.keys(), d.listvalues()) == d.lists()\n-        True\n-\n-        :return: a :class:`list`\n-        \"\"\"\n-        return list(self.iterlistvalues())\n-\n-    def iteritems(self, multi=False):\n-        \"\"\"Like :meth:`items` but returns an iterator.\"\"\"\n-        for key, values in dict.iteritems(self):\n-            if multi:\n-                for value in values:\n-                    yield key, value\n-            else:\n-                yield key, values[0]\n-\n-    def iterlists(self):\n-        \"\"\"Like :meth:`items` but returns an iterator.\"\"\"\n-        for key, values in dict.iteritems(self):\n-            yield key, list(values)\n-\n-    def itervalues(self):\n-        \"\"\"Like :meth:`values` but returns an iterator.\"\"\"\n-        for values in dict.itervalues(self):\n-            yield values[0]\n-\n-    def iterlistvalues(self):\n-        \"\"\"Like :meth:`listvalues` but returns an iterator.\"\"\"\n-        return dict.itervalues(self)\n-\n-    def copy(self):\n-        \"\"\"Return a shallow copy of this object.\"\"\"\n-        return self.__class__(self)\n-\n-    def to_dict(self, flat=True):\n-        \"\"\"Return the contents as regular dict.  If `flat` is `True` the\n-        returned dict will only have the first item present, if `flat` is\n-        `False` all values will be returned as lists.\n-\n-        :param flat: If set to `False` the dict returned will have lists\n-                     with all the values in it.  Otherwise it will only\n-                     contain the first value for each key.\n-        :return: a :class:`dict`\n-        \"\"\"\n-        if flat:\n-            return dict(self.iteritems())\n-        return dict(self.lists())\n-\n-    def update(self, other_dict):\n-        \"\"\"update() extends rather than replaces existing key lists.\"\"\"\n-        for key, value in iter_multi_items(other_dict):\n-            MultiDict.add(self, key, value)\n-\n-    def pop(self, key, default=_missing):\n-        \"\"\"Pop the first item for a list on the dict.  Afterwards the\n-        key is removed from the dict, so additional values are discarded:\n-\n-        >>> d = MultiDict({\"foo\": [1, 2, 3]})\n-        >>> d.pop(\"foo\")\n-        1\n-        >>> \"foo\" in d\n-        False\n-\n-        :param key: the key to pop.\n-        :param default: if provided the value to return if the key was\n-                        not in the dictionary.\n-        \"\"\"\n-        try:\n-            return dict.pop(self, key)[0]\n-        except KeyError, e:\n-            if default is not _missing:\n-                return default\n-            raise BadRequestKeyError(str(e))\n-\n-    def popitem(self):\n-        \"\"\"Pop an item from the dict.\"\"\"\n-        try:\n-            item = dict.popitem(self)\n-            return (item[0], item[1][0])\n-        except KeyError, e:\n-            raise BadRequestKeyError(str(e))\n-\n-    def poplist(self, key):\n-        \"\"\"Pop the list for a key from the dict.  If the key is not in the dict\n-        an empty list is returned.\n-\n-        .. versionchanged:: 0.5\n-           If the key does no longer exist a list is returned instead of\n-           raising an error.\n-        \"\"\"\n-        return dict.pop(self, key, [])\n-\n-    def popitemlist(self):\n-        \"\"\"Pop a ``(key, list)`` tuple from the dict.\"\"\"\n-        try:\n-            return dict.popitem(self)\n-        except KeyError, e:\n-            raise BadRequestKeyError(str(e))\n-\n-    def __copy__(self):\n-        return self.copy()\n-\n-    def __repr__(self):\n-        return '%s(%r)' % (self.__class__.__name__, self.items(multi=True))\n\\ No newline at end of file\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
