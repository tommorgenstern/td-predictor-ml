{"custom_id": "flask#8017febac4d8cfec57378a6d5514ab19957f8cdc", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): -16/0 | Churn Δ: 5 | Churn Cumulative: 810 | Contributors (this commit): 10 | Commits (past 90d): 10 | Contributors (cumulative): 10 | DMM Complexity: 0.0\n\nDIFF:\n@@ -379,7 +379,10 @@ def send_file(filename_or_fp, mimetype=None, as_attachment=False,\n         rv.set_etag('flask-%s-%s-%s' % (\n             os.path.getmtime(filename),\n             os.path.getsize(filename),\n-            adler32(filename) & 0xffffffff\n+            adler32(\n+                filename.encode('utf8') if isinstance(filename, unicode)\n+                else filename\n+            ) & 0xffffffff\n         ))\n         if conditional:\n             rv = rv.make_conditional(request)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#f5ec9952decda8731a1f40ba788ba06d12c0229b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 177 | Lines Deleted: 12 | Files Changed: 3 | Hunks: 18 | Methods Changed: 26 | Complexity Δ (Sum/Max): 25/13 | Churn Δ: 189 | Churn Cumulative: 4217 | Contributors (this commit): 16 | Commits (past 90d): 35 | Contributors (cumulative): 24 | DMM Complexity: 1.0\n\nDIFF:\n@@ -234,12 +234,21 @@ class Flask(_PackageBoundObject):\n         #: To register a view function, use the :meth:`route` decorator.\n         self.view_functions = {}\n \n-        #: A dictionary of all registered error handlers.  The key is\n-        #: be the error code as integer, the value the function that\n-        #: should handle that error.\n+        # support for the now deprecated `error_handlers` attribute.  The\n+        # :attr:`error_handler_spec` shall be used now.\n+        self._error_handlers = {}\n+\n+        #: A dictionary of all registered error handlers.  The key is `None`\n+        #: for error handlers active on the application, otherwise the key is\n+        #: the name of the blueprint.  Each key points to another dictionary\n+        #: where they key is the status code of the http exception.  The\n+        #: special key `None` points to a list of tuples where the first item\n+        #: is the class for the instance check and the second the error handler\n+        #: function.\n+        #:\n         #: To register a error handler, use the :meth:`errorhandler`\n         #: decorator.\n-        self.error_handlers = {}\n+        self.error_handler_spec = {None: self._error_handlers}\n \n         #: A dictionary with lists of functions that should be called at the\n         #: beginning of the request.  The key of the dictionary is the name of\n@@ -351,6 +360,17 @@ class Flask(_PackageBoundObject):\n                               endpoint='static',\n                               view_func=self.send_static_file)\n \n+    def _get_error_handlers(self):\n+        from warnings import warn\n+        warn(DeprecationWarning('error_handlers is deprecated, use the '\n+            'new error_handler_spec attribute instead.'), stacklevel=1)\n+        return self._error_handlers\n+    def _set_error_handlers(self, value):\n+        self._error_handlers = value\n+        self.error_handler_spec[None] = value\n+    error_handlers = property(_get_error_handlers, _set_error_handlers)\n+    del _get_error_handlers, _set_error_handlers\n+\n     @property\n     def propagate_exceptions(self):\n         \"\"\"Returns the value of the `PROPAGATE_EXCEPTIONS` configuration\n@@ -761,7 +781,7 @@ class Flask(_PackageBoundObject):\n             return f\n         return decorator\n \n-    def errorhandler(self, code):\n+    def errorhandler(self, code_or_exception):\n         \"\"\"A decorator that is used to register a function give a given\n         error code.  Example::\n \n@@ -769,21 +789,51 @@ class Flask(_PackageBoundObject):\n             def page_not_found(error):\n                 return 'This page does not exist', 404\n \n+        You can also register handlers for arbitrary exceptions::\n+\n+            @app.errorhandler(DatabaseError)\n+            def special_exception_handler(error):\n+                return 'Database connection failed', 500\n+\n         You can also register a function as error handler without using\n         the :meth:`errorhandler` decorator.  The following example is\n         equivalent to the one above::\n \n             def page_not_found(error):\n                 return 'This page does not exist', 404\n-            app.error_handlers[404] = page_not_found\n+            app.error_handler_spec[None][404] = page_not_found\n+\n+        Setting error handlers via assignments to :attr:`error_handler_spec`\n+        however is discouraged as it requires fidling with nested dictionaries\n+        and the special case for arbitrary exception types.\n+\n+        The first `None` refers to the active blueprint.  If the error\n+        handler should be application wide `None` shall be used.\n+\n+        .. versionadded:: 0.7\n+           One can now additionally also register custom exception types\n+           that do not necessarily have to be a subclass of the\n+           :class:~`werkzeug.exceptions.HTTPException` class.\n \n         :param code: the code as integer for the handler\n         \"\"\"\n         def decorator(f):\n-            self.error_handlers[code] = f\n+            self._register_error_handler(None, code_or_exception, f)\n             return f\n         return decorator\n \n+    def _register_error_handler(self, key, code_or_exception, f):\n+        if isinstance(code_or_exception, HTTPException):\n+            code_or_exception = code_or_exception.code\n+        if isinstance(code_or_exception, (int, long)):\n+            assert code_or_exception != 500 or key is None, \\\n+                'It is currently not possible to register a 500 internal ' \\\n+                'server error on a per-blueprint level.'\n+            self.error_handler_spec.setdefault(key, {})[code_or_exception] = f\n+        else:\n+            self.error_handler_spec.setdefault(key, {}).setdefault(None, []) \\\n+                .append((code_or_exception, f))\n+\n     def template_filter(self, name=None):\n         \"\"\"A decorator that is used to register custom template filter.\n         You can specify a name for the filter, otherwise the function\n@@ -871,11 +921,44 @@ class Flask(_PackageBoundObject):\n \n         .. versionadded: 0.3\n         \"\"\"\n-        handler = self.error_handlers.get(e.code)\n+        handlers = self.error_handler_spec.get(request.blueprint)\n+        if handlers and e.code in handlers:\n+            handler = handlers[e.code]\n+        else:\n+            handler = self.error_handler_spec[None].get(e.code)\n         if handler is None:\n             return e\n         return handler(e)\n \n+    def handle_user_exception(self, e):\n+        \"\"\"This method is called whenever an exception occurs that should be\n+        handled.  A special case are\n+        :class:`~werkzeug.exception.HTTPException`\\s which are forwarded by\n+        this function to the :meth:`handle_http_exception` method.  This\n+        function will either return a response value or reraise the\n+        exception with the same traceback.\n+\n+        .. versionadded:: 0.7\n+        \"\"\"\n+        # ensure not to trash sys.exc_info() at that point in case someone\n+        # wants the traceback preserved in handle_http_exception.\n+        if isinstance(e, HTTPException):\n+            return self.handle_http_exception(e)\n+\n+        exc_type, exc_value, tb = sys.exc_info()\n+        assert exc_value is e\n+\n+        blueprint_handlers = ()\n+        handlers = self.error_handler_spec.get(request.blueprint)\n+        if handlers is not None:\n+            blueprint_handlers = handlers.get(None, ())\n+        app_handlers = self.error_handler_spec[None].get(None, ())\n+        for typecheck, handler in chain(blueprint_handlers, app_handlers):\n+            if isinstance(e, typecheck):\n+                return handler(e)\n+\n+        raise exc_type, exc_value, tb\n+\n     def handle_exception(self, e):\n         \"\"\"Default exception handling that kicks in when an exception\n         occours that is not caught.  In debug mode the exception will\n@@ -888,7 +971,7 @@ class Flask(_PackageBoundObject):\n         exc_type, exc_value, tb = sys.exc_info()\n \n         got_request_exception.send(self, exception=e)\n-        handler = self.error_handlers.get(500)\n+        handler = self.error_handler_spec[None].get(500)\n \n         if self.propagate_exceptions:\n             # if we want to repropagate the exception, we can attempt to\n@@ -942,8 +1025,8 @@ class Flask(_PackageBoundObject):\n             rv = self.preprocess_request()\n             if rv is None:\n                 rv = self.dispatch_request()\n-        except HTTPException, e:\n-            rv = self.handle_http_exception(e)\n+        except Exception, e:\n+            rv = self.handle_user_exception(e)\n         response = self.make_response(rv)\n         response = self.process_response(response)\n         request_finished.send(self, response=response)\n\n@@ -62,6 +62,7 @@ class Blueprint(_PackageBoundObject):\n         self.static_folder = static_folder\n         self.static_url_path = static_url_path\n         self.deferred_functions = []\n+        self.view_functions = {}\n \n     def _record(self, func):\n         self.deferred_functions.append(func)\n@@ -110,7 +111,9 @@ class Blueprint(_PackageBoundObject):\n     def endpoint(self, endpoint):\n         \"\"\"Like :meth:`Flask.endpoint` but for a module.  This does not\n         prefix the endpoint with the module name, this has to be done\n-        explicitly by the user of this method.\n+        explicitly by the user of this method.  If the endpoint is prefixed\n+        with a `.` it will be registered to the current blueprint, otherwise\n+        it's an application independent endpoint.\n         \"\"\"\n         def decorator(f):\n             def register_endpoint(state):\n@@ -209,3 +212,22 @@ class Blueprint(_PackageBoundObject):\n         self._record_once(lambda s: s.app.url_default_functions\n             .setdefault(None, []).append(f))\n         return f\n+\n+    def errorhandler(self, code_or_exception):\n+        \"\"\"Registers an error handler that becomes active for this blueprint\n+        only.  Please be aware that routing does not happen local to a\n+        blueprint so an error handler for 404 usually is not handled by\n+        a blueprint unless it is caused inside a view function.  Another\n+        special case is the 500 internal server error which is always looked\n+        up from the application.\n+\n+        Otherwise works as the :meth:`~flask.Flask.errorhandler` decorator\n+        of the :class:`~flask.Flask` object.\n+\n+        .. versionadded:: 0.7\n+        \"\"\"\n+        def decorator(f):\n+            self._record_once(lambda s: s.app._register_error_handler(\n+                self.name, code_or_exception, f))\n+            return f\n+        return decorator\n\n@@ -531,6 +531,22 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n         assert rv.status_code == 500\n         assert 'internal server error' == rv.data\n \n+    def test_user_error_handling(self):\n+        class MyException(Exception):\n+            pass\n+\n+        app = flask.Flask(__name__)\n+        @app.errorhandler(MyException)\n+        def handle_my_exception(e):\n+            assert isinstance(e, MyException)\n+            return '42'\n+        @app.route('/')\n+        def index():\n+            raise MyException()\n+\n+        c = app.test_client()\n+        assert c.get('/').data == '42'\n+\n     def test_teardown_on_pop(self):\n         buffer = []\n         app = flask.Flask(__name__)\n@@ -1214,6 +1230,49 @@ class ModuleTestCase(unittest.TestCase):\n         assert c.get('/foo/bar').data == 'bar'\n \n \n+class BlueprintTestCase(unittest.TestCase):\n+\n+    def test_blueprint_specific_error_handling(self):\n+        frontend = flask.Blueprint('frontend', __name__)\n+        backend = flask.Blueprint('backend', __name__)\n+        sideend = flask.Blueprint('sideend', __name__)\n+\n+        @frontend.errorhandler(403)\n+        def frontend_forbidden(e):\n+            return 'frontend says no', 403\n+\n+        @frontend.route('/frontend-no')\n+        def frontend_no():\n+            flask.abort(403)\n+\n+        @backend.errorhandler(403)\n+        def backend_forbidden(e):\n+            return 'backend says no', 403\n+\n+        @backend.route('/backend-no')\n+        def backend_no():\n+            flask.abort(403)\n+\n+        @sideend.route('/what-is-a-sideend')\n+        def sideend_no():\n+            flask.abort(403)\n+\n+        app = flask.Flask(__name__)\n+        app.register_blueprint(frontend)\n+        app.register_blueprint(backend)\n+        app.register_blueprint(sideend)\n+\n+        @app.errorhandler(403)\n+        def app_forbidden(e):\n+            return 'application itself says no', 403\n+\n+        c = app.test_client()\n+\n+        assert c.get('/frontend-no').data == 'frontend says no'\n+        assert c.get('/backend-no').data == 'backend says no'\n+        assert c.get('/what-is-a-sideend').data == 'application itself says no'\n+\n+\n class SendfileTestCase(unittest.TestCase):\n \n     def test_send_file_regular(self):\n@@ -1631,6 +1690,7 @@ def suite():\n     suite.addTest(unittest.makeSuite(BasicFunctionalityTestCase))\n     suite.addTest(unittest.makeSuite(TemplatingTestCase))\n     suite.addTest(unittest.makeSuite(ModuleTestCase))\n+    suite.addTest(unittest.makeSuite(BlueprintTestCase))\n     suite.addTest(unittest.makeSuite(SendfileTestCase))\n     suite.addTest(unittest.makeSuite(LoggingTestCase))\n     suite.addTest(unittest.makeSuite(ConfigTestCase))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#1f31ec4bea20e67f1870a0857c869eafa109c4d4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 9 | Churn Cumulative: 1992 | Contributors (this commit): 12 | Commits (past 90d): 18 | Contributors (cumulative): 12 | DMM Complexity: 1.0\n\nDIFF:\n@@ -822,6 +822,15 @@ class Flask(_PackageBoundObject):\n             return f\n         return decorator\n \n+    def register_error_handler(self, code_or_exception, f):\n+        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n+        decorator that is more straightforward to use for non decorator\n+        usage.\n+\n+        .. versionadded:: 0.7\n+        \"\"\"\n+        self._register_error_handler(None, code_or_exception, f)\n+\n     def _register_error_handler(self, key, code_or_exception, f):\n         if isinstance(code_or_exception, HTTPException):\n             code_or_exception = code_or_exception.code\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#6dae36f94db40d242fee73d10467a25cfa90b580", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 178 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 4 | Methods Changed: 13 | Complexity Δ (Sum/Max): 61/44 | Churn Δ: 182 | Churn Cumulative: 992 | Contributors (this commit): 10 | Commits (past 90d): 12 | Contributors (cumulative): 11 | DMM Complexity: 0.5535714285714286\n\nDIFF:\n@@ -168,15 +168,18 @@ def url_for(endpoint, **values):\n     :param _external: if set to `True`, an absolute URL is generated.\n     \"\"\"\n     ctx = _request_ctx_stack.top\n+    blueprint_name = request.blueprint\n     if not ctx.request._is_old_module:\n         if endpoint[:1] == '.':\n-            endpoint = request.blueprint + endpoint\n+            if blueprint_name is not None:\n+                endpoint = blueprint_name + endpoint\n+            else:\n+                endpoint = endpoint[1:]\n     else:\n         # TODO: get rid of this deprecated functionality in 1.0\n         if '.' not in endpoint:\n-            mod = ctx.request.blueprint\n-            if mod is not None:\n-                endpoint = mod + '.' + endpoint\n+            if blueprint_name is not None:\n+                endpoint = blueprint_name + '.' + endpoint\n         elif endpoint.startswith('.'):\n             endpoint = endpoint[1:]\n     external = values.pop('_external', False)\n\n@@ -0,0 +1,171 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+    flask-07-upgrade\n+    ~~~~~~~~~~~~~~~~\n+\n+    This command line script scans a whole application tree and attempts to\n+    output an unified diff with all the changes that are necessary to easily\n+    upgrade the application to 0.7 and to not yield deprecation warnings.\n+\n+    This will also attempt to find `after_request` functions that don't modify\n+    the response and appear to be better suited for `teardown_request`.\n+\n+    :copyright: (c) Copyright 2011 by Armin Ronacher.\n+    :license: see LICENSE for more details.\n+\"\"\"\n+import re\n+import os\n+import sys\n+import inspect\n+import difflib\n+import posixpath\n+from optparse import OptionParser\n+\n+try:\n+    import ast\n+except ImportError:\n+    ast = None\n+\n+\n+_string_re_part = r\"('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\" \\\n+                  r'|\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")'\n+_url_for_re = re.compile(r'\\b(url_for\\()(%s)' % _string_re_part)\n+_after_request_re = re.compile(r'((?:@\\S+\\.(?:app_)?))(after_request)(\\b\\s*$)(?m)')\n+\n+\n+def error(message):\n+    print >> sys.stderr, 'error:', message\n+    sys.exit(1)\n+\n+\n+def make_diff(filename, old, new):\n+    for line in difflib.unified_diff(old.splitlines(), new.splitlines(),\n+                     posixpath.normpath(posixpath.join('a', filename)),\n+                     posixpath.normpath(posixpath.join('b', filename)),\n+                     lineterm=''):\n+        print line\n+\n+\n+def fix_url_for(contents):\n+    def handle_match(match):\n+        prefix = match.group(1)\n+        endpoint = ast.literal_eval(match.group(2))\n+        if endpoint.startswith('.'):\n+            endpoint = endpoint[1:]\n+        else:\n+            endpoint = '.' + endpoint\n+        return prefix + repr(endpoint)\n+    return _url_for_re.sub(handle_match, contents)\n+\n+\n+def looks_like_teardown_function(node):\n+    returns = [x for x in ast.walk(node) if isinstance(x, ast.Return)]\n+    if len(returns) != 1:\n+        return\n+    return_def = returns[0]\n+    resp_name = node.args.args[0]\n+    if not isinstance(return_def.value, ast.Name) or \\\n+       return_def.value.id != resp_name.id:\n+        return\n+\n+    for body_node in node.body:\n+        for child in ast.walk(body_node):\n+            if isinstance(child, ast.Name) and \\\n+               child.id == resp_name.id:\n+                if child is not return_def.value:\n+                    return\n+\n+    return resp_name.id\n+\n+\n+def fix_teardown_funcs(contents):\n+\n+    def is_return_line(line):\n+        args = line.strip().split()\n+        return args and args[0] == 'return'\n+\n+    def fix_single(match, lines, lineno):\n+        if not lines[lineno + 1].startswith('def'):\n+            return\n+        block_lines = inspect.getblock(lines[lineno + 1:])\n+        func_code = ''.join(block_lines)\n+        if func_code[0].isspace():\n+            node = ast.parse('if 1:\\n' + func_code).body[0].body\n+        else:\n+            node = ast.parse(func_code).body[0]\n+        response_param_name = looks_like_teardown_function(node)\n+        if response_param_name is None:\n+            return\n+        before = lines[:lineno]\n+        decorator = [match.group(1) +\n+                     match.group(2).replace('after_', 'teardown_') +\n+                     match.group(3)]\n+        body = [line.replace(response_param_name, 'exception')\n+                for line in block_lines if\n+                not is_return_line(line)]\n+        after = lines[lineno + len(block_lines) + 1:]\n+        return before + decorator + body + after\n+\n+    content_lines = contents.splitlines(True)\n+    while 1:\n+        found_one = False\n+        for idx, line in enumerate(content_lines):\n+            match = _after_request_re.match(line)\n+            if match is None:\n+                continue\n+            new_content_lines = fix_single(match, content_lines, idx)\n+            if new_content_lines is not None:\n+                content_lines = new_content_lines\n+                break\n+        else:\n+            break\n+\n+    return ''.join(content_lines)\n+\n+\n+def upgrade_python_file(filename, contents, teardown):\n+    new_contents = fix_url_for(contents)\n+    if teardown:\n+        new_contents = fix_teardown_funcs(contents)\n+    make_diff(filename, contents, new_contents)\n+\n+\n+def upgrade_template_file(filename, contents):\n+    new_contents = fix_url_for(contents)\n+    make_diff(filename, contents, new_contents)\n+\n+\n+def scan_path(path=None, teardown=True):\n+    for dirpath, dirnames, filenames in os.walk(path):\n+        for filename in filenames:\n+            filename = os.path.join(dirpath, filename)\n+            with open(filename) as f:\n+                contents = f.read()\n+            if filename.endswith('.py'):\n+                upgrade_python_file(filename, contents, teardown)\n+            elif '{% for' or '{% if' or '{{ url_for' in contents:\n+                upgrade_template_file(filename, contents)\n+\n+\n+def main():\n+    \"\"\"Entrypoint\"\"\"\n+    if ast is None:\n+        error('Python 2.6 or later is required to run the upgrade script.\\n'\n+              'The runtime requirements for Flask 0.7 however are still '\n+              'Python 2.5.')\n+\n+    parser = OptionParser()\n+    parser.add_option('-T', '--no-teardown-detection', dest='no_teardown',\n+                      action='store_true', help='Do not attempt to '\n+                      'detect teardown function rewrites.')\n+    options, args = parser.parse_args()\n+    if not args:\n+        args = ['.']\n+\n+    for path in args:\n+        scan_path(path, teardown=not options.no_teardown)\n+\n+\n+if __name__ == '__main__':\n+    main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#5e91b0c352d6493b2669c6da413fd0ed65cb6b7c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 65 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 4 | Methods Changed: 6 | Complexity Δ (Sum/Max): 18/18 | Churn Δ: 66 | Churn Cumulative: 237 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 1 | DMM Complexity: 0.717391304347826\n\nDIFF:\n@@ -28,10 +28,18 @@ except ImportError:\n     ast = None\n \n \n+_from_import_re = re.compile(r'^\\s*from flask import\\s+')\n+_direct_module_usage_re = re.compile(r'flask\\.Module')\n _string_re_part = r\"('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\" \\\n                   r'|\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")'\n _url_for_re = re.compile(r'\\b(url_for\\()(%s)' % _string_re_part)\n _after_request_re = re.compile(r'((?:@\\S+\\.(?:app_)?))(after_request)(\\b\\s*$)(?m)')\n+_module_constructor_re = re.compile(r'Module\\(__name__\\s*(?:,\\s*(%s))?' %\n+                                    _string_re_part)\n+_blueprint_related = [\n+    (re.compile(r'request\\.module'), 'request.blueprint'),\n+    (re.compile(r'register_module'), 'register_blueprint')\n+]\n \n \n def error(message):\n@@ -124,10 +132,66 @@ def fix_teardown_funcs(contents):\n     return ''.join(content_lines)\n \n \n+def get_module_autoname(filename):\n+    directory, filename = os.path.split(filename)\n+    if filename != '__init__.py':\n+        return os.path.splitext(filename)[0]\n+    return os.path.basename(directory)\n+\n+\n+def rewrite_from_imports(prefix, fromlist, lineiter):\n+    import_block = [prefix, fromlist]\n+    if fromlist[0] == '(' and fromlist[-1] != ')':\n+        for line in lineiter:\n+            import_block.append(line)\n+            if line.rstrip().endswith(')'):\n+                break\n+    elif fromlist[-1] == '\\\\':\n+        for line in lineiter:\n+            import_block.append(line)\n+            if line.rstrip().endswith('\\\\'):\n+                break\n+\n+    return ''.join(import_block).replace('Module', 'Blueprint')\n+\n+\n+def rewrite_blueprint_imports(contents):\n+    new_file = []\n+    lineiter = iter(contents.splitlines(True))\n+    for line in lineiter:\n+        match = _from_import_re.search(line)\n+        if match is not None:\n+            new_file.extend(rewrite_from_imports(match.group(),\n+                                                 line[match.end():],\n+                                                 lineiter))\n+            continue\n+        new_file.append(_direct_module_usage_re.sub('flask.Blueprint', line))\n+    return ''.join(new_file)\n+\n+\n+def rewrite_for_blueprints(contents, filename):\n+    found_constructor = []\n+    def handle_match(match):\n+        found_constructor[:] = [True]\n+        name_param = match.group(1)\n+        if name_param is None:\n+            return 'Blueprint(%r, __name__' % get_module_autoname(filename)\n+        return 'Blueprint(%s, __name__' % name_param\n+    new_contents = _module_constructor_re.sub(handle_match, contents)\n+\n+    if found_constructor:\n+        new_contents = rewrite_blueprint_imports(new_contents)\n+\n+    for pattern, replacement in _blueprint_related:\n+        new_contents = pattern.sub(replacement, new_contents)\n+    return new_contents\n+\n+\n def upgrade_python_file(filename, contents, teardown):\n     new_contents = fix_url_for(contents)\n     if teardown:\n-        new_contents = fix_teardown_funcs(contents)\n+        new_contents = fix_teardown_funcs(new_contents)\n+    new_contents = rewrite_for_blueprints(new_contents, filename)\n     make_diff(filename, contents, new_contents)\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#479e242afc0665306745ea1845ba47ceaaede770", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 242 | Contributors (this commit): 1 | Commits (past 90d): 3 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -29,7 +29,6 @@ except ImportError:\n \n \n _from_import_re = re.compile(r'^\\s*from flask import\\s+')\n-_direct_module_usage_re = re.compile(r'flask\\.Module')\n _string_re_part = r\"('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\" \\\n                   r'|\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")'\n _url_for_re = re.compile(r'\\b(url_for\\()(%s)' % _string_re_part)\n@@ -164,8 +163,8 @@ def rewrite_blueprint_imports(contents):\n             new_file.extend(rewrite_from_imports(match.group(),\n                                                  line[match.end():],\n                                                  lineiter))\n-            continue\n-        new_file.append(_direct_module_usage_re.sub('flask.Blueprint', line))\n+        else:\n+            new_file.append(line)\n     return ''.join(new_file)\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#6d072f00adb12569380becd17f277b5456ad07c0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 98 | Lines Deleted: 15 | Files Changed: 1 | Hunks: 17 | Methods Changed: 14 | Complexity Δ (Sum/Max): 24/24 | Churn Δ: 113 | Churn Cumulative: 355 | Contributors (this commit): 1 | Commits (past 90d): 4 | Contributors (cumulative): 1 | DMM Complexity: 0.589041095890411\n\nDIFF:\n@@ -32,9 +32,12 @@ _from_import_re = re.compile(r'^\\s*from flask import\\s+')\n _string_re_part = r\"('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\" \\\n                   r'|\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")'\n _url_for_re = re.compile(r'\\b(url_for\\()(%s)' % _string_re_part)\n+_render_template_re = re.compile(r'\\b(render_template\\()(%s)' % _string_re_part)\n _after_request_re = re.compile(r'((?:@\\S+\\.(?:app_)?))(after_request)(\\b\\s*$)(?m)')\n-_module_constructor_re = re.compile(r'Module\\(__name__\\s*(?:,\\s*(%s))?' %\n+_module_constructor_re = re.compile(r'([a-zA-Z0-9_][a-zA-Z0-9_]*)\\s*=\\s*Module'\n+                                    r'\\(__name__\\s*(?:,\\s*(%s))?' %\n                                     _string_re_part)\n+_mod_route_re = re.compile(r'([a-zA-Z0-9_][a-zA-Z0-9_]*)\\.route')\n _blueprint_related = [\n     (re.compile(r'request\\.module'), 'request.blueprint'),\n     (re.compile(r'register_module'), 'register_blueprint')\n@@ -168,29 +171,66 @@ def rewrite_blueprint_imports(contents):\n     return ''.join(new_file)\n \n \n-def rewrite_for_blueprints(contents, filename):\n-    found_constructor = []\n+def rewrite_render_template_calls(contents, module_declarations):\n+    mapping = dict(module_declarations)\n+    annotated_lines = []\n+\n+    def make_line_annotations():\n+        if not annotated_lines:\n+            last_index = 0\n+            for line in contents.splitlines(True):\n+                last_index += len(line)\n+                annotated_lines.append((last_index, line))\n+\n+    def backtrack_module_name(call_start):\n+        make_line_annotations()\n+        for idx, (line_end, line) in enumerate(annotated_lines):\n+            if line_end > call_start:\n+                for _, line in reversed(annotated_lines[:idx]):\n+                    match = _mod_route_re.search(line)\n+                    if match is not None:\n+                        shortname = match.group(1)\n+                        return mapping.get(shortname)\n+\n     def handle_match(match):\n-        found_constructor[:] = [True]\n-        name_param = match.group(1)\n+        template_name = ast.literal_eval(match.group(2))\n+        modname = backtrack_module_name(match.start())\n+        if modname is not None and template_name.startswith(modname + '/'):\n+            template_name = modname + ':' + template_name[len(modname) + 1:]\n+        return match.group(1) + repr(template_name)\n+    return _render_template_re.sub(handle_match, contents)\n+\n+\n+def rewrite_for_blueprints(contents, filename, template_bundles=False):\n+    modules_declared = []\n+    def handle_match(match):\n+        target = match.group(1)\n+        name_param = match.group(2)\n         if name_param is None:\n-            return 'Blueprint(%r, __name__' % get_module_autoname(filename)\n-        return 'Blueprint(%s, __name__' % name_param\n+            modname = get_module_autoname(filename)\n+        else:\n+            modname = ast.literal_eval(name_param)\n+        modules_declared.append((target, modname))\n+        return '%s = %s' % (target, 'Blueprint(%r, __name__' % modname)\n     new_contents = _module_constructor_re.sub(handle_match, contents)\n \n-    if found_constructor:\n+    if modules_declared:\n         new_contents = rewrite_blueprint_imports(new_contents)\n+        if template_bundles:\n+            new_contents = rewrite_render_template_calls(new_contents,\n+                                                         modules_declared)\n \n     for pattern, replacement in _blueprint_related:\n         new_contents = pattern.sub(replacement, new_contents)\n     return new_contents\n \n \n-def upgrade_python_file(filename, contents, teardown):\n+def upgrade_python_file(filename, contents, teardown, template_bundles):\n     new_contents = fix_url_for(contents)\n     if teardown:\n         new_contents = fix_teardown_funcs(new_contents)\n-    new_contents = rewrite_for_blueprints(new_contents, filename)\n+    new_contents = rewrite_for_blueprints(new_contents, filename,\n+                                          template_bundles)\n     make_diff(filename, contents, new_contents)\n \n \n@@ -199,18 +239,45 @@ def upgrade_template_file(filename, contents):\n     make_diff(filename, contents, new_contents)\n \n \n-def scan_path(path=None, teardown=True):\n+def walk_path(path):\n     for dirpath, dirnames, filenames in os.walk(path):\n         for filename in filenames:\n             filename = os.path.join(dirpath, filename)\n+            if filename.endswith('.py'):\n+                yield filename, 'python'\n+            else:\n                 with open(filename) as f:\n                     contents = f.read()\n-            if filename.endswith('.py'):\n-                upgrade_python_file(filename, contents, teardown)\n-            elif '{% for' or '{% if' or '{{ url_for' in contents:\n+                if '{% for' or '{% if' or '{{ url_for' in contents:\n+                    yield filename, 'template'\n+\n+\n+def scan_path(path=None, teardown=True, template_bundles=True):\n+    for filename, type in walk_path(path):\n+        with open(filename) as f:\n+            contents = f.read()\n+        if type == 'python':\n+            upgrade_python_file(filename, contents, teardown,\n+                                template_bundles)\n+        elif type == 'template':\n             upgrade_template_file(filename, contents)\n \n \n+def autodetect_template_bundles(paths):\n+    folders_with_templates = set()\n+    for path in paths:\n+        for filename, type in walk_path(path):\n+            if type == 'template':\n+                fullpath = filename.replace(os.path.sep, '/')\n+                index = fullpath.find('/templates/')\n+                if index >= 0:\n+                    folder = fullpath[:index]\n+                else:\n+                    folder = posixpath.dirname(fullpath)\n+                folders_with_templates.add(folder)\n+    return len(folders_with_templates) > 1\n+\n+\n def main():\n     \"\"\"Entrypoint\"\"\"\n     if ast is None:\n@@ -222,12 +289,28 @@ def main():\n     parser.add_option('-T', '--no-teardown-detection', dest='no_teardown',\n                       action='store_true', help='Do not attempt to '\n                       'detect teardown function rewrites.')\n+    parser.add_option('-b', '--bundled-templates', dest='bundled_tmpl',\n+                      action='store_true', help='Indicate to the system '\n+                      'that templates are bundled with modules.  Default '\n+                      'is auto detect.')\n+    parser.add_option('-B', '--no-bundled-templates', dest='no_bundled_tmpl',\n+                      action='store_true', help='Indicate to the system '\n+                      'that templates are not bundled with modules.  '\n+                      'Default is auto detect')\n     options, args = parser.parse_args()\n     if not args:\n         args = ['.']\n \n+    if options.no_bundled_tmpl:\n+        template_bundles = False\n+    elif options.bundled_tmpl:\n+        template_bundles = True\n+    else:\n+        template_bundles = autodetect_template_bundles(args)\n+\n     for path in args:\n-        scan_path(path, teardown=not options.no_teardown)\n+        scan_path(path, teardown=not options.no_teardown,\n+                  template_bundles=template_bundles)\n \n \n if __name__ == '__main__':\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#670d2bcf7aaf6be3701aa58fb2ad39d3bb80e071", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 30 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 2 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 30 | Churn Cumulative: 30 | Contributors (this commit): 1 | Commits (past 90d): 1 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -0,0 +1,30 @@\n+from flask import Flask, Module\n+\n+\n+mod = Module(__name__)\n+mod2 = Module(__name__, 'testmod2')\n+\n+app = Flask(__name__)\n+app.register_module(mod)\n+app.register_module(mod2)\n+\n+\n+@app.after_request\n+def after_request(response):\n+    g.db.close()\n+    return response\n+\n+\n+@mod.route('/')\n+def index():\n+    return render_template('test/index.html')\n+\n+\n+@mod2.route('/')\n+def index():\n+    return render_template('testmod2/index.html')\n+\n+\n+@mod2.route('/')\n+def index():\n+    return render_template('something-else/index.html')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#cbfacd8962587d864e89d876e772fb4c1234f94d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 360 | Contributors (this commit): 1 | Commits (past 90d): 5 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -11,6 +11,11 @@\n     This will also attempt to find `after_request` functions that don't modify\n     the response and appear to be better suited for `teardown_request`.\n \n+    This application is indeed an incredible hack, but because what it\n+    attempts to accomplish is impossible to do statically it tries to support\n+    the most common patterns at least.  The diff it generates should be\n+    hand reviewed and not applied blindly without making backups.\n+\n     :copyright: (c) Copyright 2011 by Armin Ronacher.\n     :license: see LICENSE for more details.\n \"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#10104e98cf89b1e57f8359b0209307fefaee2ea1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 363 | Contributors (this commit): 1 | Commits (past 90d): 6 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -45,7 +45,8 @@ _module_constructor_re = re.compile(r'([a-zA-Z0-9_][a-zA-Z0-9_]*)\\s*=\\s*Module'\n _mod_route_re = re.compile(r'([a-zA-Z0-9_][a-zA-Z0-9_]*)\\.route')\n _blueprint_related = [\n     (re.compile(r'request\\.module'), 'request.blueprint'),\n-    (re.compile(r'register_module'), 'register_blueprint')\n+    (re.compile(r'register_module'), 'register_blueprint'),\n+    (re.compile(r'app\\.modules'), 'app.blueprints')\n ]\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#17d1ade6b956a1dc508f096f951fc52800b2a20e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 365 | Contributors (this commit): 1 | Commits (past 90d): 7 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -46,7 +46,7 @@ _mod_route_re = re.compile(r'([a-zA-Z0-9_][a-zA-Z0-9_]*)\\.route')\n _blueprint_related = [\n     (re.compile(r'request\\.module'), 'request.blueprint'),\n     (re.compile(r'register_module'), 'register_blueprint'),\n-    (re.compile(r'app\\.modules'), 'app.blueprints')\n+    (re.compile(r'(app|application)\\.modules'), '\\\\1.blueprints')\n ]\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#aa863efd9294dcd8afef6e5fa590ae2f88cbb0a2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 11 | Files Changed: 1 | Hunks: 5 | Methods Changed: 3 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 20 | Churn Cumulative: 385 | Contributors (this commit): 1 | Commits (past 90d): 8 | Contributors (cumulative): 1 | DMM Complexity: 0.0\n\nDIFF:\n@@ -33,6 +33,9 @@ except ImportError:\n     ast = None\n \n \n+TEMPLATE_LOOKAHEAD = 4096\n+\n+\n _from_import_re = re.compile(r'^\\s*from flask import\\s+')\n _string_re_part = r\"('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\" \\\n                   r'|\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")'\n@@ -50,11 +53,6 @@ _blueprint_related = [\n ]\n \n \n-def error(message):\n-    print >> sys.stderr, 'error:', message\n-    sys.exit(1)\n-\n-\n def make_diff(filename, old, new):\n     for line in difflib.unified_diff(old.splitlines(), new.splitlines(),\n                      posixpath.normpath(posixpath.join('a', filename)),\n@@ -253,7 +251,7 @@ def walk_path(path):\n                 yield filename, 'python'\n             else:\n                 with open(filename) as f:\n-                    contents = f.read()\n+                    contents = f.read(TEMPLATE_LOOKAHEAD)\n                 if '{% for' or '{% if' or '{{ url_for' in contents:\n                     yield filename, 'template'\n \n@@ -286,11 +284,6 @@ def autodetect_template_bundles(paths):\n \n def main():\n     \"\"\"Entrypoint\"\"\"\n-    if ast is None:\n-        error('Python 2.6 or later is required to run the upgrade script.\\n'\n-              'The runtime requirements for Flask 0.7 however are still '\n-              'Python 2.5.')\n-\n     parser = OptionParser()\n     parser.add_option('-T', '--no-teardown-detection', dest='no_teardown',\n                       action='store_true', help='Do not attempt to '\n@@ -307,6 +300,11 @@ def main():\n     if not args:\n         args = ['.']\n \n+    if ast is None:\n+        parser.error('Python 2.6 or later is required to run the upgrade script.\\n'\n+                     'The runtime requirements for Flask 0.7 however are still '\n+                     'Python 2.5.')\n+\n     if options.no_bundled_tmpl:\n         template_bundles = False\n     elif options.bundled_tmpl:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#9770054dee42df5e5a1f4dcf5c46e444ac86cb76", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 5 | Churn Cumulative: 390 | Contributors (this commit): 1 | Commits (past 90d): 9 | Contributors (cumulative): 1 | DMM Complexity: 0.0\n\nDIFF:\n@@ -245,11 +245,14 @@ def upgrade_template_file(filename, contents):\n \n def walk_path(path):\n     for dirpath, dirnames, filenames in os.walk(path):\n+        dirnames[:] = [x for x in dirnames if not x.startswith('.')]\n         for filename in filenames:\n             filename = os.path.join(dirpath, filename)\n             if filename.endswith('.py'):\n                 yield filename, 'python'\n-            else:\n+            # skip files that are diffs.  These might be false positives\n+            # when run multiple times.\n+            elif not filename.endswith(('.diff', '.patch', '.udiff')):\n                 with open(filename) as f:\n                     contents = f.read(TEMPLATE_LOOKAHEAD)\n                 if '{% for' or '{% if' or '{{ url_for' in contents:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#6094c8536bb9ac90abbca5c970bdc1bd645395ba", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 392 | Contributors (this commit): 1 | Commits (past 90d): 10 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -287,7 +287,7 @@ def autodetect_template_bundles(paths):\n \n def main():\n     \"\"\"Entrypoint\"\"\"\n-    parser = OptionParser()\n+    parser = OptionParser(usage='%prog [options] [paths]')\n     parser.add_option('-T', '--no-teardown-detection', dest='no_teardown',\n                       action='store_true', help='Do not attempt to '\n                       'detect teardown function rewrites.')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#99bb902cc351c32c4646d6baeaa3de3bc9086718", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 12 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 6 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 15 | Churn Cumulative: 437 | Contributors (this commit): 1 | Commits (past 90d): 13 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -35,21 +35,23 @@ except ImportError:\n \n TEMPLATE_LOOKAHEAD = 4096\n \n-\n-_from_import_re = re.compile(r'^\\s*from flask import\\s+')\n+_app_re_part = r'((?:[a-zA-Z_][a-zA-Z0-9_]*app)|app|application)'\n _string_re_part = r\"('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\" \\\n                   r'|\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")'\n+\n+_from_import_re = re.compile(r'^\\s*from flask import\\s+')\n _url_for_re = re.compile(r'\\b(url_for\\()(%s)' % _string_re_part)\n _render_template_re = re.compile(r'\\b(render_template\\()(%s)' % _string_re_part)\n _after_request_re = re.compile(r'((?:@\\S+\\.(?:app_)?))(after_request)(\\b\\s*$)(?m)')\n _module_constructor_re = re.compile(r'([a-zA-Z0-9_][a-zA-Z0-9_]*)\\s*=\\s*Module'\n                                     r'\\(__name__\\s*(?:,\\s*(%s))?' %\n                                     _string_re_part)\n+_error_handler_re = re.compile(r'%s\\.error_handlers\\[\\s*(\\d+)\\s*\\]' % _app_re_part)\n _mod_route_re = re.compile(r'([a-zA-Z0-9_][a-zA-Z0-9_]*)\\.route')\n _blueprint_related = [\n     (re.compile(r'request\\.module'), 'request.blueprint'),\n     (re.compile(r'register_module'), 'register_blueprint'),\n-    (re.compile(r'(app|application)\\.modules'), '\\\\1.blueprints')\n+    (re.compile(r'%s\\.modules' % _app_re_part), '\\\\1.blueprints')\n ]\n \n \n@@ -235,6 +237,8 @@ def upgrade_python_file(filename, contents, teardown, template_bundles):\n         new_contents = fix_teardown_funcs(new_contents)\n     new_contents = rewrite_for_blueprints(new_contents, filename,\n                                           template_bundles)\n+    new_contents = _error_handler_re.sub('\\\\1.error_handler_spec[None][\\\\2]',\n+                                         new_contents)\n     make_diff(filename, contents, new_contents)\n \n \n\n@@ -9,6 +9,11 @@ app.register_module(mod)\n app.register_module(mod2)\n \n \n+def handle_404(error):\n+    return 'Testing', 404\n+app.error_handlers[404] = handle_404\n+\n+\n @app.after_request\n def after_request(response):\n     g.db.close()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#b4ffa4d9ac9cd652e94a97fa633f021d2f934582", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 4 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 6 | Churn Cumulative: 443 | Contributors (this commit): 1 | Commits (past 90d): 15 | Contributors (cumulative): 2 | DMM Complexity: 0.0\n\nDIFF:\n@@ -44,7 +44,7 @@ _url_for_re = re.compile(r'\\b(url_for\\()(%s)' % _string_re_part)\n _render_template_re = re.compile(r'\\b(render_template\\()(%s)' % _string_re_part)\n _after_request_re = re.compile(r'((?:@\\S+\\.(?:app_)?))(after_request)(\\b\\s*$)(?m)')\n _module_constructor_re = re.compile(r'([a-zA-Z0-9_][a-zA-Z0-9_]*)\\s*=\\s*Module'\n-                                    r'\\(__name__\\s*(?:,\\s*(%s))?' %\n+                                    r'\\(__name__\\s*(?:,\\s*(?:name\\s*=\\s*)?(%s))?' %\n                                     _string_re_part)\n _error_handler_re = re.compile(r'%s\\.error_handlers\\[\\s*(\\d+)\\s*\\]' % _app_re_part)\n _mod_route_re = re.compile(r'([a-zA-Z0-9_][a-zA-Z0-9_]*)\\.route')\n@@ -248,10 +248,13 @@ def upgrade_template_file(filename, contents):\n \n \n def walk_path(path):\n+    this_file = os.path.realpath(__file__).rstrip('c')\n     for dirpath, dirnames, filenames in os.walk(path):\n         dirnames[:] = [x for x in dirnames if not x.startswith('.')]\n         for filename in filenames:\n             filename = os.path.join(dirpath, filename)\n+            if os.path.realpath(filename) == this_file:\n+                continue\n             if filename.endswith('.py'):\n                 yield filename, 'python'\n             # skip files that are diffs.  These might be false positives\n\n@@ -3,6 +3,7 @@ from flask import Flask, Module\n \n mod = Module(__name__)\n mod2 = Module(__name__, 'testmod2')\n+mod3 = Module(__name__, name='somemod', subdomain='meh')\n \n app = Flask(__name__)\n app.register_module(mod)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
