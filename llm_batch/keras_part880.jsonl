{"custom_id": "keras#90568daee498ec53123a46ebf11d11974cb66f1d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 20 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 20 | Churn Cumulative: 118 | Contributors (this commit): 6 | Commits (past 90d): 3 | Contributors (cumulative): 9 | DMM Complexity: 1.0\n\nDIFF:\n@@ -199,6 +199,9 @@ class MeanMetricWrapper(Mean):\n             self._direction = \"down\"\n \n     def update_state(self, y_true, y_pred, sample_weight=None):\n+        y_true = backend.cast(y_true, self.dtype)\n+        y_pred = backend.cast(y_pred, self.dtype)\n+\n         mask = backend.get_keras_mask(y_pred)\n         values = self._fn(y_true, y_pred, **self._fn_kwargs)\n         if sample_weight is not None and mask is not None:\n\n@@ -1,6 +1,9 @@\n import numpy as np\n \n from keras.src import backend\n+from keras.src import layers\n+from keras.src import metrics\n+from keras.src import models\n from keras.src import testing\n from keras.src.backend.common.keras_tensor import KerasTensor\n from keras.src.metrics import reduction_metrics\n@@ -174,3 +177,17 @@ class MetricWrapperTest(testing.TestCase):\n             KerasTensor((None, 5)),\n         )\n         self.assertAllEqual(result.shape, ())\n+\n+    def test_binary_accuracy_with_boolean_inputs(self):\n+        inp = layers.Input(shape=(1,))\n+        out = inp > 0.5\n+        model = models.Model(inputs=inp, outputs=out)\n+\n+        x = np.random.rand(32, 1)\n+        y = x > 0.5\n+\n+        res = model.predict(x)\n+        metric = metrics.BinaryAccuracy()\n+        metric.update_state(y, res)\n+        result = metric.result()\n+        assert result == 1.0\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#592c118d321551fe30d37d1a19d6006f51872d00", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 25 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 5 | Methods Changed: 2 | Complexity Δ (Sum/Max): 3/2 | Churn Δ: 25 | Churn Cumulative: 51 | Contributors (this commit): 4 | Commits (past 90d): 3 | Contributors (cumulative): 7 | DMM Complexity: 1.0\n\nDIFF:\n@@ -2,6 +2,7 @@ from keras.src import backend\n from keras.src import ops\n from keras.src.api_export import keras_export\n from keras.src.layers.layer import Layer\n+from keras.src.saving.serialization_lib import deserialize_keras_object\n \n \n @keras_export(\"keras.layers.Masking\")\n@@ -45,6 +46,9 @@ class Masking(Layer):\n \n     def __init__(self, mask_value=0.0, **kwargs):\n         super().__init__(**kwargs)\n+        # `mask_value` can be a serialized tensor, hence verify it\n+        if isinstance(mask_value, dict) and mask_value.get(\"config\", None):\n+            mask_value = deserialize_keras_object(mask_value)\n         self.mask_value = mask_value\n         self.supports_masking = True\n         self.built = True\n\n@@ -3,7 +3,9 @@ import pytest\n \n from keras.src import layers\n from keras.src import models\n+from keras.src import ops\n from keras.src import testing\n+from keras.src.saving import load_model\n \n \n class MaskingTest(testing.TestCase):\n@@ -57,3 +59,22 @@ class MaskingTest(testing.TestCase):\n             ]\n         )\n         model(x)\n+\n+    @pytest.mark.requires_trainable_backend\n+    def test_masking_with_tensor(self):\n+        model = models.Sequential(\n+            [\n+                layers.Masking(mask_value=ops.convert_to_tensor([0.0])),\n+                layers.LSTM(1),\n+            ]\n+        )\n+        x = np.array(\n+            [\n+                [[0.0, 0.0], [1.0, 2.0], [0.0, 0.0]],\n+                [[2.0, 2.0], [0.0, 0.0], [2.0, 1.0]],\n+            ]\n+        )\n+        model(x)\n+        model.save(\"model.keras\")\n+        reload_model = load_model(\"model.keras\")\n+        reload_model(x)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#6097d53589120d545e4822bf4ee70eeeefb0333a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 167 | Contributors (this commit): 4 | Commits (past 90d): 2 | Contributors (cumulative): 4 | DMM Complexity: None\n\nDIFF:\n@@ -136,7 +136,7 @@ class KerasTensor:\n             \"used when constructing Keras Functional models \"\n             \"or Keras Functions. You can only use it as input to a Keras layer \"\n             \"or a Keras operation (from the namespaces `keras.layers` \"\n-            \"and `keras.operations`). \"\n+            \"and `keras.ops`). \"\n             \"You are likely doing something like:\\n\\n\"\n             \"```\\n\"\n             \"x = Input(...)\\n\"\n@@ -159,7 +159,7 @@ class KerasTensor:\n             \"used when constructing Keras Functional models \"\n             \"or Keras Functions. You can only use it as input to a Keras layer \"\n             \"or a Keras operation (from the namespaces `keras.layers` \"\n-            \"and `keras.operations`). \"\n+            \"and `keras.ops`). \"\n             \"You are likely doing something like:\\n\\n\"\n             \"```\\n\"\n             \"x = Input(...)\\n\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#8d292daf0248ac02d68e8895a70bc288aba4e55f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 26 | Lines Deleted: 34 | Files Changed: 1 | Hunks: 5 | Methods Changed: 3 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 60 | Churn Cumulative: 376 | Contributors (this commit): 11 | Commits (past 90d): 5 | Contributors (cumulative): 11 | DMM Complexity: 0.0\n\nDIFF:\n@@ -85,6 +85,28 @@ class JAXTrainer(base_trainer.Trainer):\n             metrics_variables,\n         )\n \n+    def _update_metrics_variables(\n+        self, metrics_variables, unscaled_loss, x, y, y_pred, sample_weight\n+    ):\n+        with backend.StatelessScope(\n+            state_mapping=[\n+                (ref_v, v)\n+                for ref_v, v in zip(self.metrics_variables, metrics_variables)\n+            ]\n+        ) as scope:\n+            self._loss_tracker.update_state(\n+                unscaled_loss, sample_weight=tree.flatten(x)[0].shape[0]\n+            )\n+            logs = self.compute_metrics(x, y, y_pred, sample_weight)\n+\n+        new_metrics_variables = []\n+        for ref_v in self.metrics_variables:\n+            new_v = scope.get_current_value(ref_v)\n+            if new_v is None:\n+                new_v = ref_v.value\n+            new_metrics_variables.append(new_v)\n+        return logs, new_metrics_variables\n+\n     def train_step(self, state, data):\n         (\n             trainable_variables,\n@@ -117,24 +139,9 @@ class JAXTrainer(base_trainer.Trainer):\n             optimizer_variables, grads, trainable_variables\n         )\n \n-        with backend.StatelessScope(\n-            state_mapping=[\n-                (ref_v, v)\n-                for ref_v, v in zip(self.metrics_variables, metrics_variables)\n-            ]\n-        ) as scope:\n-            self._loss_tracker.update_state(\n-                unscaled_loss, sample_weight=tree.flatten(x)[0].shape[0]\n+        logs, metrics_variables = self._update_metrics_variables(\n+            metrics_variables, unscaled_loss, x, y, y_pred, sample_weight\n         )\n-            logs = self.compute_metrics(x, y, y_pred, sample_weight)\n-\n-        new_metrics_variables = []\n-        for ref_v in self.metrics_variables:\n-            new_v = scope.get_current_value(ref_v)\n-            if new_v is None:\n-                new_v = ref_v.value\n-            new_metrics_variables.append(new_v)\n-        metrics_variables = new_metrics_variables\n \n         state = self._enforce_jax_state_sharding(\n             trainable_variables,\n@@ -164,24 +171,9 @@ class JAXTrainer(base_trainer.Trainer):\n             aux\n         )\n \n-        with backend.StatelessScope(\n-            state_mapping=[\n-                (ref_v, v)\n-                for ref_v, v in zip(self.metrics_variables, metrics_variables)\n-            ]\n-        ) as scope:\n-            self._loss_tracker.update_state(\n-                unscaled_loss, sample_weight=tree.flatten(x)[0].shape[0]\n+        logs, metrics_variables = self._update_metrics_variables(\n+            metrics_variables, unscaled_loss, x, y, y_pred, sample_weight\n         )\n-            logs = self.compute_metrics(x, y, y_pred, sample_weight)\n-\n-        new_metrics_variables = []\n-        for ref_v in self.metrics_variables:\n-            new_v = scope.get_current_value(ref_v)\n-            if new_v is None:\n-                new_v = ref_v.value\n-            new_metrics_variables.append(new_v)\n-        metrics_variables = new_metrics_variables\n \n         (\n             trainable_variables,\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#d7d2e437db55b89a969d86ba6cba7d8e07936423", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 6 | Methods Changed: 4 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 8 | Churn Cumulative: 302 | Contributors (this commit): 10 | Commits (past 90d): 13 | Contributors (cumulative): 10 | DMM Complexity: None\n\nDIFF:\n@@ -158,7 +158,6 @@ class MultiHeadAttention(Layer):\n         self.seed = seed\n \n         self._inverse_sqrt_key_dim = 1.0 / math.sqrt(float(self._key_dim))\n-        self._return_attention_scores = False\n \n         # Check for flash attention constraints\n         if self._flash_attention and self._dropout > 0.0:\n@@ -419,6 +418,7 @@ class MultiHeadAttention(Layer):\n         value,\n         attention_mask=None,\n         training=None,\n+        return_attention_scores=False,\n     ):\n         \"\"\"Applies Dot-product attention with query, key, value tensors.\n \n@@ -442,7 +442,7 @@ class MultiHeadAttention(Layer):\n           attention_scores: Multi-headed attention weights.\n         \"\"\"\n         # Check for flash attention constraints\n-        if self._flash_attention and self._return_attention_scores:\n+        if self._flash_attention and return_attention_scores:\n             raise ValueError(\n                 \"Returning attention scores is not supported when flash \"\n                 \"attention is enabled. Please disable flash attention to access\"\n@@ -452,7 +452,7 @@ class MultiHeadAttention(Layer):\n         # Determine whether to use dot-product attention\n         use_dot_product_attention = not (\n             self._dropout > 0.0\n-            or self._return_attention_scores\n+            or return_attention_scores\n             or (len(query.shape) != 4)\n         )\n \n@@ -525,7 +525,6 @@ class MultiHeadAttention(Layer):\n         training=None,\n         use_causal_mask=False,\n     ):\n-        self._return_attention_scores = return_attention_scores\n         if key is None:\n             key = value\n \n@@ -562,6 +561,7 @@ class MultiHeadAttention(Layer):\n             value,\n             attention_mask,\n             training,\n+            return_attention_scores,\n         )\n         attention_output = self._output_dense(attention_output)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#3de22701154154dfa519a07fcd545461f3064d1d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 424 | Lines Deleted: 0 | Files Changed: 5 | Hunks: 5 | Methods Changed: 18 | Complexity Δ (Sum/Max): 40/32 | Churn Δ: 424 | Churn Cumulative: 1304 | Contributors (this commit): 7 | Commits (past 90d): 50 | Contributors (cumulative): 23 | DMM Complexity: 0.7225806451612903\n\nDIFF:\n@@ -172,6 +172,9 @@ from keras.src.layers.preprocessing.image_preprocessing.random_contrast import (\n from keras.src.layers.preprocessing.image_preprocessing.random_crop import (\n     RandomCrop,\n )\n+from keras.src.layers.preprocessing.image_preprocessing.random_erasing import (\n+    RandomErasing,\n+)\n from keras.src.layers.preprocessing.image_preprocessing.random_flip import (\n     RandomFlip,\n )\n\n@@ -172,6 +172,9 @@ from keras.src.layers.preprocessing.image_preprocessing.random_contrast import (\n from keras.src.layers.preprocessing.image_preprocessing.random_crop import (\n     RandomCrop,\n )\n+from keras.src.layers.preprocessing.image_preprocessing.random_erasing import (\n+    RandomErasing,\n+)\n from keras.src.layers.preprocessing.image_preprocessing.random_flip import (\n     RandomFlip,\n )\n\n@@ -116,6 +116,9 @@ from keras.src.layers.preprocessing.image_preprocessing.random_contrast import (\n from keras.src.layers.preprocessing.image_preprocessing.random_crop import (\n     RandomCrop,\n )\n+from keras.src.layers.preprocessing.image_preprocessing.random_erasing import (\n+    RandomErasing,\n+)\n from keras.src.layers.preprocessing.image_preprocessing.random_flip import (\n     RandomFlip,\n )\n\n@@ -0,0 +1,324 @@\n+from keras.src.api_export import keras_export\n+from keras.src.layers.preprocessing.image_preprocessing.base_image_preprocessing_layer import (  # noqa: E501\n+    BaseImagePreprocessingLayer,\n+)\n+from keras.src.random import SeedGenerator\n+\n+\n+@keras_export(\"keras.layers.RandomErasing\")\n+class RandomErasing(BaseImagePreprocessingLayer):\n+    \"\"\"Random Erasing data augmentation technique.\n+\n+    Random Erasing is a data augmentation method where random patches of\n+    an image are erased (replaced by a constant value or noise)\n+    during training to improve generalization.\n+\n+    Args:\n+        factor: A single float or a tuple of two floats.\n+            `factor` controls the extent to which the image hue is impacted.\n+            `factor=0.0` makes this layer perform a no-op operation,\n+            while a value of `1.0` performs the most aggressive\n+            erasing available. If a tuple is used, a `factor` is\n+            sampled between the two values for every image augmented. If a\n+            single float is used, a value between `0.0` and the passed float is\n+            sampled. Default is 1.0.\n+        scale: A tuple of two floats representing the aspect ratio range of\n+            the erased patch. This defines the width-to-height ratio of\n+            the patch to be erased. It can help control the rw shape of\n+            the erased region. Default is (0.02, 0.33).\n+        fill_value: A value to fill the erased region with. This can be set to\n+            a constant value or `None` to sample a random value\n+            from a normal distribution. Default is `None`.\n+        value_range: the range of values the incoming images will have.\n+            Represented as a two-number tuple written `[low, high]`. This is\n+            typically either `[0, 1]` or `[0, 255]` depending on how your\n+            preprocessing pipeline is set up.\n+        seed: Integer. Used to create a random seed.\n+\n+    References:\n+       - [Random Erasing paper](https://arxiv.org/abs/1708.04896).\n+    \"\"\"\n+\n+    _USE_BASE_FACTOR = False\n+    _FACTOR_BOUNDS = (0, 1)\n+\n+    def __init__(\n+        self,\n+        factor=1.0,\n+        scale=(0.02, 0.33),\n+        fill_value=None,\n+        value_range=(0, 255),\n+        seed=None,\n+        data_format=None,\n+        **kwargs,\n+    ):\n+        super().__init__(data_format=data_format, **kwargs)\n+        self._set_factor(factor)\n+        self.scale = self._set_factor_by_name(scale, \"scale\")\n+        self.fill_value = fill_value\n+        self.value_range = value_range\n+        self.seed = seed\n+        self.generator = SeedGenerator(seed)\n+\n+        if self.data_format == \"channels_first\":\n+            self.height_axis = -2\n+            self.width_axis = -1\n+            self.channel_axis = -3\n+        else:\n+            self.height_axis = -3\n+            self.width_axis = -2\n+            self.channel_axis = -1\n+\n+    def _set_factor_by_name(self, factor, name):\n+        error_msg = (\n+            f\"The `{name}` argument should be a number \"\n+            \"(or a list of two numbers) \"\n+            \"in the range \"\n+            f\"[{self._FACTOR_BOUNDS[0]}, {self._FACTOR_BOUNDS[1]}]. \"\n+            f\"Received: factor={factor}\"\n+        )\n+        if isinstance(factor, (tuple, list)):\n+            if len(factor) != 2:\n+                raise ValueError(error_msg)\n+            if (\n+                factor[0] > self._FACTOR_BOUNDS[1]\n+                or factor[1] < self._FACTOR_BOUNDS[0]\n+            ):\n+                raise ValueError(error_msg)\n+            lower, upper = sorted(factor)\n+        elif isinstance(factor, (int, float)):\n+            if (\n+                factor < self._FACTOR_BOUNDS[0]\n+                or factor > self._FACTOR_BOUNDS[1]\n+            ):\n+                raise ValueError(error_msg)\n+            factor = abs(factor)\n+            lower, upper = [max(-factor, self._FACTOR_BOUNDS[0]), factor]\n+        else:\n+            raise ValueError(error_msg)\n+        return lower, upper\n+\n+    def _compute_crop_bounds(self, batch_size, image_length, crop_ratio, seed):\n+        crop_length = self.backend.cast(\n+            crop_ratio * image_length, dtype=self.compute_dtype\n+        )\n+\n+        start_pos = self.backend.random.uniform(\n+            shape=[batch_size],\n+            minval=0,\n+            maxval=1,\n+            dtype=self.compute_dtype,\n+            seed=seed,\n+        ) * (image_length - crop_length)\n+\n+        end_pos = start_pos + crop_length\n+\n+        return start_pos, end_pos\n+\n+    def _generate_batch_mask(self, images_shape, box_corners):\n+        def _generate_grid_xy(image_height, image_width):\n+            grid_y, grid_x = self.backend.numpy.meshgrid(\n+                self.backend.numpy.arange(\n+                    image_height, dtype=self.compute_dtype\n+                ),\n+                self.backend.numpy.arange(\n+                    image_width, dtype=self.compute_dtype\n+                ),\n+                indexing=\"ij\",\n+            )\n+            if self.data_format == \"channels_last\":\n+                grid_y = self.backend.cast(\n+                    grid_y[None, :, :, None], dtype=self.compute_dtype\n+                )\n+                grid_x = self.backend.cast(\n+                    grid_x[None, :, :, None], dtype=self.compute_dtype\n+                )\n+            else:\n+                grid_y = self.backend.cast(\n+                    grid_y[None, None, :, :], dtype=self.compute_dtype\n+                )\n+                grid_x = self.backend.cast(\n+                    grid_x[None, None, :, :], dtype=self.compute_dtype\n+                )\n+            return grid_x, grid_y\n+\n+        image_height, image_width = (\n+            images_shape[self.height_axis],\n+            images_shape[self.width_axis],\n+        )\n+        grid_x, grid_y = _generate_grid_xy(image_height, image_width)\n+\n+        x0, x1, y0, y1 = box_corners\n+\n+        x0 = x0[:, None, None, None]\n+        y0 = y0[:, None, None, None]\n+        x1 = x1[:, None, None, None]\n+        y1 = y1[:, None, None, None]\n+\n+        batch_masks = (\n+            (grid_x >= x0) & (grid_x < x1) & (grid_y >= y0) & (grid_y < y1)\n+        )\n+        batch_masks = self.backend.numpy.repeat(\n+            batch_masks, images_shape[self.channel_axis], axis=self.channel_axis\n+        )\n+\n+        return batch_masks\n+\n+    def _get_fill_value(self, images, images_shape, seed):\n+        fill_value = self.fill_value\n+        if fill_value is None:\n+            fill_value = (\n+                self.backend.random.normal(\n+                    images_shape,\n+                    dtype=self.compute_dtype,\n+                    seed=seed,\n+                )\n+                * self.value_range[1]\n+            )\n+        else:\n+            error_msg = (\n+                \"The `fill_value` argument should be a number \"\n+                \"(or a list of three numbers) \"\n+            )\n+            if isinstance(fill_value, (tuple, list)):\n+                if len(fill_value) != 3:\n+                    raise ValueError(error_msg)\n+                fill_value = self.backend.numpy.full_like(\n+                    images, fill_value, dtype=self.compute_dtype\n+                )\n+            elif isinstance(fill_value, (int, float)):\n+                fill_value = (\n+                    self.backend.numpy.ones(\n+                        images_shape, dtype=self.compute_dtype\n+                    )\n+                    * fill_value\n+                )\n+            else:\n+                raise ValueError(error_msg)\n+        fill_value = self.backend.numpy.clip(\n+            fill_value, self.value_range[0], self.value_range[1]\n+        )\n+        return fill_value\n+\n+    def get_random_transformation(self, data, training=True, seed=None):\n+        if not training:\n+            return None\n+\n+        if isinstance(data, dict):\n+            images = data[\"images\"]\n+        else:\n+            images = data\n+\n+        images_shape = self.backend.shape(images)\n+        rank = len(images_shape)\n+        if rank == 3:\n+            batch_size = 1\n+        elif rank == 4:\n+            batch_size = images_shape[0]\n+        else:\n+            raise ValueError(\n+                \"Expected the input image to be rank 3 or 4. Received \"\n+                f\"inputs.shape={images_shape}\"\n+            )\n+\n+        image_height = images_shape[self.height_axis]\n+        image_width = images_shape[self.width_axis]\n+\n+        seed = seed or self._get_seed_generator(self.backend._backend)\n+\n+        mix_weight = self.backend.random.uniform(\n+            shape=(batch_size, 2),\n+            minval=self.scale[0],\n+            maxval=self.scale[1],\n+            dtype=self.compute_dtype,\n+            seed=seed,\n+        )\n+\n+        mix_weight = self.backend.numpy.sqrt(mix_weight)\n+\n+        x0, x1 = self._compute_crop_bounds(\n+            batch_size, image_width, mix_weight[:, 0], seed\n+        )\n+        y0, y1 = self._compute_crop_bounds(\n+            batch_size, image_height, mix_weight[:, 1], seed\n+        )\n+\n+        batch_masks = self._generate_batch_mask(\n+            images_shape,\n+            (x0, x1, y0, y1),\n+        )\n+\n+        erase_probability = self.backend.random.uniform(\n+            shape=(batch_size,),\n+            minval=self.factor[0],\n+            maxval=self.factor[1],\n+            seed=seed,\n+        )\n+\n+        random_threshold = self.backend.random.uniform(\n+            shape=(batch_size,),\n+            minval=0.0,\n+            maxval=1.0,\n+            seed=seed,\n+        )\n+        apply_erasing = random_threshold < erase_probability\n+\n+        fill_value = self._get_fill_value(images, images_shape, seed)\n+\n+        return {\n+            \"apply_erasing\": apply_erasing,\n+            \"batch_masks\": batch_masks,\n+            \"fill_value\": fill_value,\n+        }\n+\n+    def transform_images(self, images, transformation=None, training=True):\n+        if training:\n+            images = self.backend.cast(images, self.compute_dtype)\n+            batch_masks = transformation[\"batch_masks\"]\n+            apply_erasing = transformation[\"apply_erasing\"]\n+            fill_value = transformation[\"fill_value\"]\n+\n+            erased_images = self.backend.numpy.where(\n+                batch_masks,\n+                fill_value,\n+                images,\n+            )\n+\n+            images = self.backend.numpy.where(\n+                apply_erasing[:, None, None, None],\n+                erased_images,\n+                images,\n+            )\n+\n+        images = self.backend.cast(images, self.compute_dtype)\n+        return images\n+\n+    def transform_labels(self, labels, transformation, training=True):\n+        return labels\n+\n+    def transform_bounding_boxes(\n+        self,\n+        bounding_boxes,\n+        transformation,\n+        training=True,\n+    ):\n+        return bounding_boxes\n+\n+    def transform_segmentation_masks(\n+        self, segmentation_masks, transformation, training=True\n+    ):\n+        return segmentation_masks\n+\n+    def compute_output_shape(self, input_shape):\n+        return input_shape\n+\n+    def get_config(self):\n+        config = {\n+            \"factor\": self.factor,\n+            \"scale\": self.scale,\n+            \"fill_value\": self.fill_value,\n+            \"value_range\": self.value_range,\n+            \"seed\": self.seed,\n+        }\n+        base_config = super().get_config()\n+        return {**base_config, **config}\n\n@@ -0,0 +1,91 @@\n+import numpy as np\n+import pytest\n+from tensorflow import data as tf_data\n+\n+from keras.src import backend\n+from keras.src import layers\n+from keras.src import testing\n+\n+\n+class RandomErasingTest(testing.TestCase):\n+    @pytest.mark.requires_trainable_backend\n+    def test_layer(self):\n+        self.run_layer_test(\n+            layers.RandomErasing,\n+            init_kwargs={\n+                \"factor\": 1.0,\n+                \"scale\": 0.5,\n+                \"fill_value\": 0,\n+                \"value_range\": (0, 255),\n+                \"seed\": 1,\n+            },\n+            input_shape=(8, 3, 4, 3),\n+            supports_masking=False,\n+            expected_output_shape=(8, 3, 4, 3),\n+        )\n+\n+    def test_random_erasing_inference(self):\n+        seed = 3481\n+        layer = layers.RandomErasing()\n+\n+        np.random.seed(seed)\n+        inputs = np.random.randint(0, 255, size=(224, 224, 3))\n+        output = layer(inputs, training=False)\n+        self.assertAllClose(inputs, output)\n+\n+    def test_random_erasing_no_op(self):\n+        seed = 3481\n+        layer = layers.RandomErasing(factor=0)\n+\n+        np.random.seed(seed)\n+        inputs = np.random.randint(0, 255, size=(224, 224, 3))\n+        output = layer(inputs)\n+        self.assertAllClose(inputs, output)\n+\n+        layer = layers.RandomErasing(scale=0)\n+\n+        np.random.seed(seed)\n+        inputs = np.random.randint(0, 255, size=(224, 224, 3))\n+        output = layer(inputs)\n+        self.assertAllClose(inputs, output)\n+\n+    def test_random_erasing_basic(self):\n+        data_format = backend.config.image_data_format()\n+        if data_format == \"channels_last\":\n+            inputs = np.ones((2, 2, 1))\n+            expected_output = np.array([[[[0.0], [1.0]], [[1.0], [1.0]]]])\n+\n+        else:\n+            inputs = np.ones((1, 2, 2))\n+\n+            expected_output = np.array(\n+                [[[[0.0, 0.0], [1.0, 1.0]], [[1.0, 1.0], [1.0, 1.0]]]]\n+            )\n+\n+        layer = layers.RandomErasing(data_format=data_format)\n+\n+        transformation = {\n+            \"apply_erasing\": np.asarray([True]),\n+            \"batch_masks\": np.asarray(\n+                [[[[True], [False]], [[False], [False]]]]\n+            ),\n+            \"fill_value\": 0,\n+        }\n+\n+        output = layer.transform_images(inputs, transformation)\n+\n+        print(output)\n+\n+        self.assertAllClose(expected_output, output)\n+\n+    def test_tf_data_compatibility(self):\n+        data_format = backend.config.image_data_format()\n+        if data_format == \"channels_last\":\n+            input_data = np.random.random((2, 8, 8, 3))\n+        else:\n+            input_data = np.random.random((2, 3, 8, 8))\n+        layer = layers.RandomErasing(data_format=data_format)\n+\n+        ds = tf_data.Dataset.from_tensor_slices(input_data).batch(2).map(layer)\n+        for output in ds.take(1):\n+            output.numpy()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#d0b27d073e15df71ca8485699c7357365b499476", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 209 | Lines Deleted: 68 | Files Changed: 3 | Hunks: 28 | Methods Changed: 3 | Complexity Δ (Sum/Max): 10/6 | Churn Δ: 277 | Churn Cumulative: 2757 | Contributors (this commit): 9 | Commits (past 90d): 7 | Contributors (cumulative): 18 | DMM Complexity: 0.16911764705882354\n\nDIFF:\n@@ -231,72 +231,137 @@ def resize(\n         pad_width = max(width, pad_width)\n         img_box_hstart = int(float(pad_height - height) / 2)\n         img_box_wstart = int(float(pad_width - width) / 2)\n+\n         if data_format == \"channels_last\":\n+            if img_box_hstart > 0:\n                 if len(images.shape) == 4:\n-                padded_img = (\n+                    padded_img = np.concatenate(\n+                        [\n                             np.ones(\n-                        (\n-                            batch_size,\n-                            pad_height + height,\n-                            pad_width + width,\n-                            channels,\n-                        ),\n+                                (batch_size, img_box_hstart, width, channels),\n                                 dtype=images.dtype,\n                             )\n-                    * fill_value\n-                )\n-                padded_img[\n-                    :,\n-                    img_box_hstart : img_box_hstart + height,\n-                    img_box_wstart : img_box_wstart + width,\n-                    :,\n-                ] = images\n-            else:\n-                padded_img = (\n+                            * fill_value,\n+                            images,\n                             np.ones(\n-                        (pad_height + height, pad_width + width, channels),\n+                                (batch_size, img_box_hstart, width, channels),\n                                 dtype=images.dtype,\n                             )\n-                    * fill_value\n+                            * fill_value,\n+                        ],\n+                        axis=1,\n                     )\n-                padded_img[\n-                    img_box_hstart : img_box_hstart + height,\n-                    img_box_wstart : img_box_wstart + width,\n-                    :,\n-                ] = images\n                 else:\n+                    padded_img = np.concatenate(\n+                        [\n+                            np.ones(\n+                                (img_box_hstart, width, channels),\n+                                dtype=images.dtype,\n+                            )\n+                            * fill_value,\n+                            images,\n+                            np.ones(\n+                                (img_box_hstart, width, channels),\n+                                dtype=images.dtype,\n+                            )\n+                            * fill_value,\n+                        ],\n+                        axis=0,\n+                    )\n+            elif img_box_wstart > 0:\n                 if len(images.shape) == 4:\n-                padded_img = (\n+                    padded_img = np.concatenate(\n+                        [\n                             np.ones(\n-                        (\n-                            batch_size,\n-                            channels,\n-                            pad_height + height,\n-                            pad_width + width,\n-                        ),\n+                                (batch_size, height, img_box_wstart, channels),\n                                 dtype=images.dtype,\n                             )\n-                    * fill_value\n+                            * fill_value,\n+                            images,\n+                            np.ones(\n+                                (batch_size, height, img_box_wstart, channels),\n+                                dtype=images.dtype,\n+                            )\n+                            * fill_value,\n+                        ],\n+                        axis=2,\n                     )\n-                padded_img[\n-                    :,\n-                    :,\n-                    img_box_hstart : img_box_hstart + height,\n-                    img_box_wstart : img_box_wstart + width,\n-                ] = images\n                 else:\n-                padded_img = (\n+                    padded_img = np.concatenate(\n+                        [\n                             np.ones(\n-                        (channels, pad_height + height, pad_width + width),\n+                                (height, img_box_wstart, channels),\n                                 dtype=images.dtype,\n                             )\n-                    * fill_value\n+                            * fill_value,\n+                            images,\n+                            np.ones(\n+                                (height, img_box_wstart, channels),\n+                                dtype=images.dtype,\n                             )\n-                padded_img[\n-                    :,\n-                    img_box_hstart : img_box_hstart + height,\n-                    img_box_wstart : img_box_wstart + width,\n-                ] = images\n+                            * fill_value,\n+                        ],\n+                        axis=1,\n+                    )\n+            else:\n+                padded_img = images\n+        else:\n+            if img_box_hstart > 0:\n+                if len(images.shape) == 4:\n+                    padded_img = np.concatenate(\n+                        [\n+                            np.ones(\n+                                (batch_size, channels, img_box_hstart, width)\n+                            )\n+                            * fill_value,\n+                            images,\n+                            np.ones(\n+                                (batch_size, channels, img_box_hstart, width)\n+                            )\n+                            * fill_value,\n+                        ],\n+                        axis=2,\n+                    )\n+                else:\n+                    padded_img = np.concatenate(\n+                        [\n+                            np.ones((channels, img_box_hstart, width))\n+                            * fill_value,\n+                            images,\n+                            np.ones((channels, img_box_hstart, width))\n+                            * fill_value,\n+                        ],\n+                        axis=1,\n+                    )\n+            elif img_box_wstart > 0:\n+                if len(images.shape) == 4:\n+                    padded_img = np.concatenate(\n+                        [\n+                            np.ones(\n+                                (batch_size, channels, height, img_box_wstart)\n+                            )\n+                            * fill_value,\n+                            images,\n+                            np.ones(\n+                                (batch_size, channels, height, img_box_wstart)\n+                            )\n+                            * fill_value,\n+                        ],\n+                        axis=3,\n+                    )\n+                else:\n+                    padded_img = np.concatenate(\n+                        [\n+                            np.ones((channels, height, img_box_wstart))\n+                            * fill_value,\n+                            images,\n+                            np.ones((channels, height, img_box_wstart))\n+                            * fill_value,\n+                        ],\n+                        axis=2,\n+                    )\n+            else:\n+                padded_img = images\n         images = padded_img\n \n     return np.array(\n\n@@ -224,38 +224,89 @@ def resize(\n         if len(images.shape) == 4:\n             batch_size = images.shape[0]\n             channels = images.shape[1]\n-            padded_img = (\n+            if img_box_hstart > 0:\n+                padded_img = torch.cat(\n+                    [\n                         torch.ones(\n-                    (\n-                        batch_size,\n-                        channels,\n-                        pad_height + height,\n-                        pad_width + width,\n-                    ),\n+                            (batch_size, channels, img_box_hstart, width),\n                             dtype=images.dtype,\n+                            device=images.device,\n                         )\n-                * fill_value\n+                        * fill_value,\n+                        images,\n+                        torch.ones(\n+                            (batch_size, channels, img_box_hstart, width),\n+                            dtype=images.dtype,\n+                            device=images.device,\n                         )\n-            padded_img[\n-                :,\n-                :,\n-                img_box_hstart : img_box_hstart + height,\n-                img_box_wstart : img_box_wstart + width,\n-            ] = images\n+                        * fill_value,\n+                    ],\n+                    axis=2,\n+                )\n+            else:\n+                padded_img = images\n+\n+            if img_box_wstart > 0:\n+                padded_img = torch.cat(\n+                    [\n+                        torch.ones(\n+                            (batch_size, channels, height, img_box_wstart),\n+                            dtype=images.dtype,\n+                            device=images.device,\n+                        ),\n+                        padded_img,\n+                        torch.ones(\n+                            (batch_size, channels, height, img_box_wstart),\n+                            dtype=images.dtype,\n+                            device=images.device,\n+                        )\n+                        * fill_value,\n+                    ],\n+                    axis=3,\n+                )\n+\n         else:\n             channels = images.shape[0]\n-            padded_img = (\n+            if img_box_wstart > 0:\n+                padded_img = torch.cat(\n+                    [\n                         torch.ones(\n-                    (channels, pad_height + height, pad_width + width),\n+                            (channels, img_box_hstart, width),\n                             dtype=images.dtype,\n+                            device=images.device,\n                         )\n-                * fill_value\n+                        * fill_value,\n+                        images,\n+                        torch.ones(\n+                            (channels, img_box_hstart, width),\n+                            dtype=images.dtype,\n+                            device=images.device,\n+                        )\n+                        * fill_value,\n+                    ],\n+                    axis=1,\n+                )\n+            else:\n+                padded_img = images\n+            if img_box_wstart > 0:\n+                torch.cat(\n+                    [\n+                        torch.ones(\n+                            (channels, height, img_box_wstart),\n+                            dtype=images.dtype,\n+                            device=images.device,\n+                        )\n+                        * fill_value,\n+                        padded_img,\n+                        torch.ones(\n+                            (channels, height, img_box_wstart),\n+                            dtype=images.dtype,\n+                            device=images.device,\n+                        )\n+                        * fill_value,\n+                    ],\n+                    axis=2,\n                 )\n-            padded_img[\n-                :,\n-                img_box_hstart : img_box_hstart + height,\n-                img_box_wstart : img_box_wstart + width,\n-            ] = images\n         images = padded_img\n \n     resized = torchvision.transforms.functional.resize(\n\n@@ -791,6 +791,31 @@ class ImageOpsCorrectnessTest(testing.TestCase):\n         )\n         self.assertEqual(out.shape, (2, 3, 25, 25))\n \n+        x = np.ones((2, 3, 10, 10)) * 128\n+        out = kimage.resize(\n+            x, size=(4, 4), pad_to_aspect_ratio=True, fill_value=fill_value\n+        )\n+        self.assertEqual(out.shape, (2, 3, 4, 4))\n+        self.assertAllClose(out[:, 0, :, :], np.ones((2, 4, 4)) * 128)\n+\n+        x = np.ones((2, 3, 10, 8)) * 128\n+        out = kimage.resize(\n+            x, size=(4, 4), pad_to_aspect_ratio=True, fill_value=fill_value\n+        )\n+        self.assertEqual(out.shape, (2, 3, 4, 4))\n+        self.assertAllClose(\n+            out,\n+            np.concatenate(\n+                [\n+                    np.ones((2, 3, 4, 1)) * 96.25,\n+                    np.ones((2, 3, 4, 2)) * 128.0,\n+                    np.ones((2, 3, 4, 1)) * 96.25,\n+                ],\n+                axis=3,\n+            ),\n+            atol=1.0,\n+        )\n+\n     @parameterized.named_parameters(\n         named_product(\n             interpolation=[\"bilinear\", \"nearest\"],\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#71ad1d99dd488403fba2a6498a9becbce954d3ef", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 239 | Contributors (this commit): 4 | Commits (past 90d): 4 | Contributors (cumulative): 4 | DMM Complexity: None\n\nDIFF:\n@@ -58,7 +58,7 @@ class RandomZoom(BaseImagePreprocessingLayer):\n             directions by preserving the aspect ratio. Defaults to `None`.\n         fill_mode: Points outside the boundaries of the input are filled\n             according to the given mode. Available methods are `\"constant\"`,\n-            `\"nearest\"`, `\"wrap\"` and `\"reflect\"`. Defaults to `\"constant\"`.\n+            `\"nearest\"`, `\"wrap\"` and `\"reflect\"`. Defaults to `\"reflect\"`.\n             - `\"reflect\"`: `(d c b a | a b c d | d c b a)`\n                 The input is extended by reflecting about the edge of the last\n                 pixel.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#aee7dceafeae0836995401c9116c4e37ac438283", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 55 | Lines Deleted: 5 | Files Changed: 4 | Hunks: 8 | Methods Changed: 4 | Complexity Δ (Sum/Max): 4/1 | Churn Δ: 60 | Churn Cumulative: 2780 | Contributors (this commit): 17 | Commits (past 90d): 38 | Contributors (cumulative): 42 | DMM Complexity: 1.0\n\nDIFF:\n@@ -353,7 +353,14 @@ def arctanh(x):\n \n \n def argmax(x, axis=None, keepdims=False):\n+    if x.ndim == 0:\n         return jnp.argmax(x, axis=axis, keepdims=keepdims)\n+    x_float = x.astype(jnp.float32)\n+    is_negative_zero = (x_float == 0.0) & jnp.signbit(x_float)\n+    x_adjusted = jnp.where(\n+        is_negative_zero, -jnp.finfo(x_float.dtype).tiny, x_float\n+    )\n+    return jnp.argmax(x_adjusted, axis=axis, keepdims=keepdims)\n \n \n def argmin(x, axis=None, keepdims=False):\n\n@@ -245,8 +245,14 @@ def arctanh(x):\n \n \n def argmax(x, axis=None, keepdims=False):\n-    axis = standardize_axis_for_numpy(axis)\n+    if x.ndim == 0:\n         return np.argmax(x, axis=axis, keepdims=keepdims).astype(\"int32\")\n+    x_float = x.astype(np.float32)\n+    is_negative_zero = (x_float == 0.0) & np.signbit(x_float)\n+    x_adjusted = np.where(\n+        is_negative_zero, -np.finfo(x_float.dtype).tiny, x_float\n+    )\n+    return np.argmax(x_adjusted, axis=axis, keepdims=keepdims).astype(\"int32\")\n \n \n def argmin(x, axis=None, keepdims=False):\n\n@@ -837,12 +837,39 @@ def _keepdims(x, y, axis):\n \n \n def argmax(x, axis=None, keepdims=False):\n-    _x = x\n+    x_float = tf.cast(x, tf.float32)\n+    is_negative_zero = tf.logical_and(\n+        tf.equal(x_float, 0.0),\n+        tf.less(\n+            tf.bitwise.bitwise_and(\n+                tf.bitcast(x_float, tf.int32),\n+                # tf.float32 sign bit\n+                tf.constant(0x80000000, dtype=tf.int32),\n+            ),\n+            0,\n+        ),\n+    )\n+    non_zero_mask = tf.not_equal(x_float, 0.0)\n+    masked_abs = (\n+        tf.abs(x_float)\n+        + (1.0 - tf.cast(non_zero_mask, tf.float32)) * tf.float32.max\n+    )\n+    min_non_zero = tf.reduce_min(masked_abs) - 1e-9\n+    x_adjusted = tf.where(is_negative_zero, -min_non_zero, x_float)\n     if axis is None:\n-        x = tf.reshape(x, [-1])\n-    y = tf.argmax(x, axis=axis, output_type=\"int32\")\n+        x_adjusted = tf.reshape(x_adjusted, [-1])\n+        y = tf.argmax(x_adjusted, axis=0, output_type=tf.int32)\n         if keepdims:\n-        y = _keepdims(_x, y, axis)\n+            y = tf.reshape(y, [1, 1])\n+    else:\n+        rank = tf.rank(x_adjusted)\n+        axis_tensor = tf.convert_to_tensor(axis, dtype=tf.int32)\n+        positive_axis = tf.cond(\n+            axis_tensor < 0, lambda: axis_tensor + rank, lambda: axis_tensor\n+        )\n+        y = tf.argmax(x_adjusted, axis=positive_axis, output_type=tf.int32)\n+        if keepdims:\n+            y = tf.expand_dims(y, axis=positive_axis)\n     return y\n \n \n\n@@ -1142,6 +1142,16 @@ class NumpyOneInputOpsDynamicShapeTest(testing.TestCase):\n         self.assertEqual(knp.argmax(x, axis=1).shape, (None, 3))\n         self.assertEqual(knp.argmax(x, keepdims=True).shape, (None, 3, 3))\n \n+    @pytest.mark.skipif(\n+        keras.config.backend() == \"openvino\",\n+        reason=\"OpenVINO doesn't support this change\",\n+    )\n+    def test_argmax_negative_zero(self):\n+        input_data = np.array(\n+            [-1.0, -0.0, 1.401298464324817e-45], dtype=np.float32\n+        )\n+        self.assertEqual(knp.argmax(input_data), 2)\n+\n     def test_argmin(self):\n         x = KerasTensor((None, 3))\n         self.assertEqual(knp.argmin(x).shape, ())\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#734cd03b9413e65dea392e25c420676dd04f080a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 50 | Lines Deleted: 2 | Files Changed: 3 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 3/1 | Churn Δ: 52 | Churn Cumulative: 1772 | Contributors (this commit): 15 | Commits (past 90d): 31 | Contributors (cumulative): 30 | DMM Complexity: 1.0\n\nDIFF:\n@@ -364,7 +364,20 @@ def argmax(x, axis=None, keepdims=False):\n \n \n def argmin(x, axis=None, keepdims=False):\n-    return jnp.argmin(x, axis=axis, keepdims=keepdims)\n+    x_64 = jnp.asarray(x, dtype=jnp.float64)\n+    if axis is not None:\n+        min_mask = x_64 == jnp.min(x_64, axis=axis, keepdims=True)\n+        indices = jnp.argmin(\n+            jnp.where(min_mask, x_64, jnp.inf), axis=axis, keepdims=keepdims\n+        ).astype(\"int32\")\n+    else:\n+        min_mask = (x_64 < x_64.min()) | (\n+            (x_64 == x_64.min()) & (jnp.signbit(x_64))\n+        )\n+        indices = jnp.argmin(\n+            jnp.where(min_mask, x_64, jnp.inf), axis=axis, keepdims=keepdims\n+        ).astype(\"int32\")\n+    return indices\n \n \n def argsort(x, axis=-1):\n\n@@ -257,7 +257,20 @@ def argmax(x, axis=None, keepdims=False):\n \n def argmin(x, axis=None, keepdims=False):\n     axis = standardize_axis_for_numpy(axis)\n-    return np.argmin(x, axis=axis, keepdims=keepdims).astype(\"int32\")\n+    x_64 = np.asarray(x, dtype=np.float64)\n+    if axis is not None:\n+        min_mask = x_64 == np.min(x_64, axis=axis, keepdims=True)\n+        indices = np.argmin(\n+            np.where(min_mask, x_64, np.inf), axis=axis, keepdims=keepdims\n+        ).astype(\"int32\")\n+    else:\n+        min_mask = (x_64 < x_64.min()) | (\n+            (x_64 == x_64.min()) & (np.signbit(x_64))\n+        )\n+        indices = np.argmin(\n+            np.where(min_mask, x_64, np.inf), axis=axis, keepdims=keepdims\n+        ).astype(\"int32\")\n+    return indices\n \n \n def argsort(x, axis=-1):\n\n@@ -1152,6 +1152,28 @@ class NumpyOneInputOpsDynamicShapeTest(testing.TestCase):\n         )\n         self.assertEqual(knp.argmax(input_data), 2)\n \n+    @pytest.mark.skipif(\n+        keras.config.backend() == \"openvino\"\n+        or keras.config.backend() == \"tensorflow\",\n+        reason=\"\"\"\n+        OpenVINO and TensorFlow don't support this \n+        change, TensorFlow behavior for this case is under\n+        evaluation and may change within this PR\n+        \"\"\",\n+    )\n+    def test_argmin_negative_zero(self):\n+        input_data = np.array(\n+            [\n+                0.0,\n+                1.1754943508222875e-38,\n+                -1.401298464324817e-45,\n+                0.0,\n+                459367.0,\n+            ],\n+            dtype=np.float32,\n+        )\n+        self.assertEqual(knp.argmin(input_data), 2)\n+\n     def test_argmin(self):\n         x = KerasTensor((None, 3))\n         self.assertEqual(knp.argmin(x).shape, ())\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
