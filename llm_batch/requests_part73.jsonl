{"custom_id": "requests#1511dfa637643bae5b6111a20ecb80ec9ae26032", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 3 | Files Changed: 3 | Hunks: 5 | Methods Changed: 3 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 14 | Churn Cumulative: 7601 | Contributors (this commit): 99 | Commits (past 90d): 24 | Contributors (cumulative): 142 | DMM Complexity: 0.8\n\nDIFF:\n@@ -12,7 +12,7 @@ This module implements the Requests API.\n \"\"\"\n \n from . import sessions\n-from .compat import builtin_str\n+\n \n def request(method, url, **kwargs):\n     \"\"\"Constructs and sends a :class:`Request <Request>`.\n@@ -41,7 +41,7 @@ def request(method, url, **kwargs):\n     \"\"\"\n \n     session = sessions.Session()\n-    return session.request(method=builtin_str(method), url=url, **kwargs)\n+    return session.request(method=method, url=url, **kwargs)\n \n \n def get(url, **kwargs):\n\n@@ -12,7 +12,7 @@ import os\n from collections import Mapping\n from datetime import datetime\n \n-from .compat import cookielib, OrderedDict, urljoin, urlparse, urlunparse\n+from .compat import cookielib, OrderedDict, urljoin, urlparse, urlunparse, builtin_str\n from .cookies import cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar\n from .models import Request, PreparedRequest\n from .hooks import default_hooks, dispatch_hook\n@@ -309,6 +309,9 @@ class Session(SessionRedirectMixin):\n         :param cert: (optional) if String, path to ssl client cert file (.pem).\n             If Tuple, ('cert', 'key') pair.\n         \"\"\"\n+\n+        method = builtin_str(method)\n+\n         # Create the Request.\n         req = Request(\n             method = method.upper(),\n\n@@ -434,6 +434,11 @@ class RequestsTestCase(unittest.TestCase):\n         assert b'name=\"stuff\"' in prep.body\n         assert b'name=\"b\\'stuff\\'\"' not in prep.body\n     \n+    def test_unicode_method_name(self):\n+        files = {'file': open('test_requests.py', 'rb')}\n+        r = requests.request(method=u'POST', url=httpbin('post'), files=files)\n+        assert r.status_code == 200\n+\n     def test_custom_content_type(self):\n         r = requests.post(httpbin('post'),\n                           data={'stuff': json.dumps({'a': 123})},\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#3ef41153498917bc4d01123b2f7a8fbd8e7bcf63", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 151 | Lines Deleted: 106 | Files Changed: 7 | Hunks: 16 | Methods Changed: 13 | Complexity Δ (Sum/Max): 3/20 | Churn Δ: 257 | Churn Cumulative: 5621 | Contributors (this commit): 12 | Commits (past 90d): 19 | Contributors (cumulative): 36 | DMM Complexity: 0.1\n\nDIFF:\n@@ -461,6 +461,13 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n \n         conn = None\n \n+        # Merge the proxy headers. Only do this in HTTP. We have to copy the\n+        # headers dict so we can safely change it without those changes being\n+        # reflected in anyone else's copy.\n+        if self.scheme == 'http':\n+            headers = headers.copy()\n+            headers.update(self.proxy_headers)\n+\n         try:\n             # Request a connection from the queue\n             conn = self._get_conn(timeout=pool_timeout)\n\n@@ -29,7 +29,7 @@ import ssl\n import select\n from cStringIO import StringIO\n \n-from .. import connectionpool\n+from .. import connection\n from .. import util\n \n __all__ = ['inject_into_urllib3', 'extract_from_urllib3']\n@@ -52,20 +52,20 @@ _openssl_verify = {\n \n \n orig_util_HAS_SNI = util.HAS_SNI\n-orig_connectionpool_ssl_wrap_socket = connectionpool.ssl_wrap_socket\n+orig_connection_ssl_wrap_socket = connection.ssl_wrap_socket\n \n \n def inject_into_urllib3():\n     'Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.'\n \n-    connectionpool.ssl_wrap_socket = ssl_wrap_socket\n+    connection.ssl_wrap_socket = ssl_wrap_socket\n     util.HAS_SNI = HAS_SNI\n \n \n def extract_from_urllib3():\n     'Undo monkey-patching by :func:`inject_into_urllib3`.'\n \n-    connectionpool.ssl_wrap_socket = orig_connectionpool_ssl_wrap_socket\n+    connection.ssl_wrap_socket = orig_connection_ssl_wrap_socket\n     util.HAS_SNI = orig_util_HAS_SNI\n \n \n\n@@ -1,98 +1,13 @@\n-\"\"\"The match_hostname() function from Python 3.2, essential when using SSL.\"\"\"\n+try:\n+    # Python 3.2+\n+    from ssl import CertificateError, match_hostname\n+except ImportError:\n+    try:\n+        # Backport of the function from a pypi module\n+        from backports.ssl_match_hostname import CertificateError, match_hostname\n+    except ImportError:\n+        # Our vendored copy\n+        from _implementation import CertificateError, match_hostname\n \n-import re\n-\n-__version__ = '3.2.2'\n-\n-class CertificateError(ValueError):\n-    pass\n-\n-def _dnsname_match(dn, hostname, max_wildcards=1):\n-    \"\"\"Matching according to RFC 6125, section 6.4.3\n-\n-    http://tools.ietf.org/html/rfc6125#section-6.4.3\n-    \"\"\"\n-    pats = []\n-    if not dn:\n-        return False\n-\n-    parts = dn.split(r'.')\n-    leftmost = parts[0]\n-\n-    wildcards = leftmost.count('*')\n-    if wildcards > max_wildcards:\n-        # Issue #17980: avoid denials of service by refusing more\n-        # than one wildcard per fragment.  A survery of established\n-        # policy among SSL implementations showed it to be a\n-        # reasonable choice.\n-        raise CertificateError(\n-            \"too many wildcards in certificate DNS name: \" + repr(dn))\n-\n-    # speed up common case w/o wildcards\n-    if not wildcards:\n-        return dn.lower() == hostname.lower()\n-\n-    # RFC 6125, section 6.4.3, subitem 1.\n-    # The client SHOULD NOT attempt to match a presented identifier in which\n-    # the wildcard character comprises a label other than the left-most label.\n-    if leftmost == '*':\n-        # When '*' is a fragment by itself, it matches a non-empty dotless\n-        # fragment.\n-        pats.append('[^.]+')\n-    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n-        # RFC 6125, section 6.4.3, subitem 3.\n-        # The client SHOULD NOT attempt to match a presented identifier\n-        # where the wildcard character is embedded within an A-label or\n-        # U-label of an internationalized domain name.\n-        pats.append(re.escape(leftmost))\n-    else:\n-        # Otherwise, '*' matches any dotless string, e.g. www*\n-        pats.append(re.escape(leftmost).replace(r'\\*', '[^.]*'))\n-\n-    # add the remaining fragments, ignore any wildcards\n-    for frag in parts[1:]:\n-        pats.append(re.escape(frag))\n-\n-    pat = re.compile(r'\\A' + r'\\.'.join(pats) + r'\\Z', re.IGNORECASE)\n-    return pat.match(hostname)\n-\n-\n-def match_hostname(cert, hostname):\n-    \"\"\"Verify that *cert* (in decoded format as returned by\n-    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n-    rules are followed, but IP addresses are not accepted for *hostname*.\n-\n-    CertificateError is raised on failure. On success, the function\n-    returns nothing.\n-    \"\"\"\n-    if not cert:\n-        raise ValueError(\"empty or no certificate\")\n-    dnsnames = []\n-    san = cert.get('subjectAltName', ())\n-    for key, value in san:\n-        if key == 'DNS':\n-            if _dnsname_match(value, hostname):\n-                return\n-            dnsnames.append(value)\n-    if not dnsnames:\n-        # The subject is only checked when there is no dNSName entry\n-        # in subjectAltName\n-        for sub in cert.get('subject', ()):\n-            for key, value in sub:\n-                # XXX according to RFC 2818, the most specific Common Name\n-                # must be used.\n-                if key == 'commonName':\n-                    if _dnsname_match(value, hostname):\n-                        return\n-                    dnsnames.append(value)\n-    if len(dnsnames) > 1:\n-        raise CertificateError(\"hostname %r \"\n-            \"doesn't match either of %s\"\n-            % (hostname, ', '.join(map(repr, dnsnames))))\n-    elif len(dnsnames) == 1:\n-        raise CertificateError(\"hostname %r \"\n-            \"doesn't match %r\"\n-            % (hostname, dnsnames[0]))\n-    else:\n-        raise CertificateError(\"no appropriate commonName or \"\n-            \"subjectAltName fields were found\")\n+# Not needed, but documenting what we provide.\n+__all__ = ('CertificateError', 'match_hostname')\n\n@@ -0,0 +1,105 @@\n+\"\"\"The match_hostname() function from Python 3.3.3, essential when using SSL.\"\"\"\n+\n+# Note: This file is under the PSF license as the code comes from the python\n+# stdlib.   http://docs.python.org/3/license.html\n+\n+import re\n+\n+__version__ = '3.4.0.2'\n+\n+class CertificateError(ValueError):\n+    pass\n+\n+\n+def _dnsname_match(dn, hostname, max_wildcards=1):\n+    \"\"\"Matching according to RFC 6125, section 6.4.3\n+\n+    http://tools.ietf.org/html/rfc6125#section-6.4.3\n+    \"\"\"\n+    pats = []\n+    if not dn:\n+        return False\n+\n+    # Ported from python3-syntax:\n+    # leftmost, *remainder = dn.split(r'.')\n+    parts = dn.split(r'.')\n+    leftmost = parts[0]\n+    remainder = parts[1:]\n+\n+    wildcards = leftmost.count('*')\n+    if wildcards > max_wildcards:\n+        # Issue #17980: avoid denials of service by refusing more\n+        # than one wildcard per fragment.  A survey of established\n+        # policy among SSL implementations showed it to be a\n+        # reasonable choice.\n+        raise CertificateError(\n+            \"too many wildcards in certificate DNS name: \" + repr(dn))\n+\n+    # speed up common case w/o wildcards\n+    if not wildcards:\n+        return dn.lower() == hostname.lower()\n+\n+    # RFC 6125, section 6.4.3, subitem 1.\n+    # The client SHOULD NOT attempt to match a presented identifier in which\n+    # the wildcard character comprises a label other than the left-most label.\n+    if leftmost == '*':\n+        # When '*' is a fragment by itself, it matches a non-empty dotless\n+        # fragment.\n+        pats.append('[^.]+')\n+    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n+        # RFC 6125, section 6.4.3, subitem 3.\n+        # The client SHOULD NOT attempt to match a presented identifier\n+        # where the wildcard character is embedded within an A-label or\n+        # U-label of an internationalized domain name.\n+        pats.append(re.escape(leftmost))\n+    else:\n+        # Otherwise, '*' matches any dotless string, e.g. www*\n+        pats.append(re.escape(leftmost).replace(r'\\*', '[^.]*'))\n+\n+    # add the remaining fragments, ignore any wildcards\n+    for frag in remainder:\n+        pats.append(re.escape(frag))\n+\n+    pat = re.compile(r'\\A' + r'\\.'.join(pats) + r'\\Z', re.IGNORECASE)\n+    return pat.match(hostname)\n+\n+\n+def match_hostname(cert, hostname):\n+    \"\"\"Verify that *cert* (in decoded format as returned by\n+    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n+    rules are followed, but IP addresses are not accepted for *hostname*.\n+\n+    CertificateError is raised on failure. On success, the function\n+    returns nothing.\n+    \"\"\"\n+    if not cert:\n+        raise ValueError(\"empty or no certificate\")\n+    dnsnames = []\n+    san = cert.get('subjectAltName', ())\n+    for key, value in san:\n+        if key == 'DNS':\n+            if _dnsname_match(value, hostname):\n+                return\n+            dnsnames.append(value)\n+    if not dnsnames:\n+        # The subject is only checked when there is no dNSName entry\n+        # in subjectAltName\n+        for sub in cert.get('subject', ()):\n+            for key, value in sub:\n+                # XXX according to RFC 2818, the most specific Common Name\n+                # must be used.\n+                if key == 'commonName':\n+                    if _dnsname_match(value, hostname):\n+                        return\n+                    dnsnames.append(value)\n+    if len(dnsnames) > 1:\n+        raise CertificateError(\"hostname %r \"\n+            \"doesn't match either of %s\"\n+            % (hostname, ', '.join(map(repr, dnsnames))))\n+    elif len(dnsnames) == 1:\n+        raise CertificateError(\"hostname %r \"\n+            \"doesn't match %r\"\n+            % (hostname, dnsnames[0]))\n+    else:\n+        raise CertificateError(\"no appropriate commonName or \"\n+            \"subjectAltName fields were found\")\n\n@@ -245,12 +245,11 @@ class ProxyManager(PoolManager):\n         u = parse_url(url)\n \n         if u.scheme == \"http\":\n-            # It's too late to set proxy headers on per-request basis for\n-            # tunnelled HTTPS connections, should use\n-            # constructor's proxy_headers instead.\n+            # For proxied HTTPS requests, httplib sets the necessary headers\n+            # on the CONNECT to the proxy. For HTTP, we'll definitely\n+            # need to set 'Host' at the very least.\n             kw['headers'] = self._set_proxy_headers(url, kw.get('headers',\n                                                                 self.headers))\n-            kw['headers'].update(self.proxy_headers)\n \n         return super(ProxyManager, self).urlopen(method, url, redirect, **kw)\n \n\n@@ -90,6 +90,7 @@ class HTTPResponse(io.IOBase):\n         self._body = body if body and isinstance(body, basestring) else None\n         self._fp = None\n         self._original_response = original_response\n+        self._fp_bytes_read = 0\n \n         self._pool = pool\n         self._connection = connection\n@@ -129,6 +130,14 @@ class HTTPResponse(io.IOBase):\n         if self._fp:\n             return self.read(cache_content=True)\n \n+    def tell(self):\n+        \"\"\"\n+        Obtain the number of bytes pulled over the wire so far. May differ from\n+        the amount of content returned by :meth:``HTTPResponse.read`` if bytes\n+        are encoded on the wire (e.g, compressed).\n+        \"\"\"\n+        return self._fp_bytes_read\n+\n     def read(self, amt=None, decode_content=None, cache_content=False):\n         \"\"\"\n         Similar to :meth:`httplib.HTTPResponse.read`, but with two additional\n@@ -183,6 +192,8 @@ class HTTPResponse(io.IOBase):\n                     self._fp.close()\n                     flush_decoder = True\n \n+            self._fp_bytes_read += len(data)\n+\n             try:\n                 if decode_content and self._decoder:\n                     data = self._decoder.decompress(data)\n\n@@ -426,7 +426,7 @@ def get_host(url):\n \n \n def make_headers(keep_alive=None, accept_encoding=None, user_agent=None,\n-                 basic_auth=None):\n+                 basic_auth=None, proxy_basic_auth=None):\n     \"\"\"\n     Shortcuts for generating request headers.\n \n@@ -447,6 +447,10 @@ def make_headers(keep_alive=None, accept_encoding=None, user_agent=None,\n         Colon-separated username:password string for 'authorization: basic ...'\n         auth header.\n \n+    :param proxy_basic_auth:\n+        Colon-separated username:password string for 'proxy-authorization: basic ...'\n+        auth header.\n+\n     Example: ::\n \n         >>> make_headers(keep_alive=True, user_agent=\"Batman/1.0\")\n@@ -474,6 +478,10 @@ def make_headers(keep_alive=None, accept_encoding=None, user_agent=None,\n         headers['authorization'] = 'Basic ' + \\\n             b64encode(six.b(basic_auth)).decode('utf-8')\n \n+    if proxy_basic_auth:\n+        headers['proxy-authorization'] = 'Basic ' + \\\n+            b64encode(six.b(proxy_basic_auth)).decode('utf-8')\n+\n     return headers\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#512beb8795f49ed474e3d679dda9524853853378", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 43 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 6/5 | Churn Δ: 43 | Churn Cumulative: 12946 | Contributors (this commit): 148 | Commits (past 90d): 28 | Contributors (cumulative): 189 | DMM Complexity: 1.0\n\nDIFF:\n@@ -489,6 +489,19 @@ class Response(object):\n     server's response to an HTTP request.\n     \"\"\"\n \n+    __attrs__ = [\n+        '_content',\n+        'status_code',\n+        'headers',\n+        'url',\n+        'history',\n+        'encoding',\n+        'reason',\n+        'cookies',\n+        'elapsed',\n+        'request',\n+    ]\n+\n     def __init__(self):\n         super(Response, self).__init__()\n \n@@ -528,6 +541,24 @@ class Response(object):\n         #: and the arrival of the response (as a timedelta)\n         self.elapsed = datetime.timedelta(0)\n \n+    def __getstate__(self):\n+        # Consume everything; accessing the content attribute makes\n+        # sure the content has been fully read.\n+        if not self._content_consumed:\n+            self.content\n+\n+        return dict(\n+            (attr, getattr(self, attr, None))\n+            for attr in self.__attrs__\n+        )\n+\n+    def __setstate__(self, state):\n+        for name, value in state.items():\n+            setattr(self, name, value)\n+\n+        # pickled objects do not have .raw\n+        setattr(self, '_content_consumed', True)\n+\n     def __repr__(self):\n         return '<Response [%s]>' % (self.status_code)\n \n\n@@ -547,6 +547,18 @@ class RequestsTestCase(unittest.TestCase):\n         assert next(iter(r))\n         io.close()\n \n+    def test_request_and_response_are_pickleable(self):\n+        r = requests.get(httpbin('get'))\n+\n+        # verify we can pickle the original request\n+        assert pickle.loads(pickle.dumps(r.request))\n+\n+        # verify we can pickle the response and that we have access to\n+        # the original request.\n+        pr = pickle.loads(pickle.dumps(r))\n+        assert r.request.url == pr.request.url\n+        assert r.request.headers == pr.request.headers\n+\n     def test_get_auth_from_url(self):\n         url = 'http://user:pass@complex.url.com/path?query=yes'\n         assert ('user', 'pass') == requests.utils.get_auth_from_url(url)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b149be5d864cc7f65ac22113db3d0e4d2ed2b49e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 17 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): -2/1 | Churn Δ: 17 | Churn Cumulative: 12963 | Contributors (this commit): 148 | Commits (past 90d): 34 | Contributors (cumulative): 189 | DMM Complexity: 0.7692307692307693\n\nDIFF:\n@@ -320,6 +320,11 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         except UnicodeDecodeError:\n             pass\n \n+        # Don't do any URL preparation for oddball schemes\n+        if ':' in url and not url.lower().startswith('http'):\n+            self.url = url\n+            return\n+\n         # Support for unicode domain names and paths.\n         scheme, auth, host, port, path, query, fragment = parse_url(url)\n \n\n@@ -683,6 +683,18 @@ class RequestsTestCase(unittest.TestCase):\n \n         assert p.headers['Content-Length'] == length\n \n+    def test_oddball_schemes_dont_check_URLs(self):\n+        test_urls = (\n+            'data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==',\n+            'file:///etc/passwd',\n+            'magnet:?xt=urn:btih:be08f00302bc2d1d3cfa3af02024fa647a271431',\n+        )\n+        for test_url in test_urls:\n+            req = requests.Request('GET', test_url)\n+            preq = req.prepare()\n+            assert test_url == preq.url\n+\n+\n class TestContentEncodingDetection(unittest.TestCase):\n \n     def test_none(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#cfbbd15de72a616fd9c648e1a0724acf2528db1b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 2 | Churn Cumulative: 657 | Contributors (this commit): 16 | Commits (past 90d): 6 | Contributors (cumulative): 16 | DMM Complexity: None\n\nDIFF:\n@@ -278,7 +278,7 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n         remove_cookie_by_name(self, name)\n \n     def set_cookie(self, cookie, *args, **kwargs):\n-        if cookie.value.startswith('\"') and cookie.value.endswith('\"'):\n+        if hasattr(cookie.value, 'startswith') and cookie.value.startswith('\"') and cookie.value.endswith('\"'):\n             cookie.value = cookie.value.replace('\\\\\"', '')\n         return super(RequestsCookieJar, self).set_cookie(cookie, *args, **kwargs)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#8c8938e8cb7ffded42cf463f652831ca7e88e5fc", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 13 | Churn Cumulative: 3260 | Contributors (this commit): 59 | Commits (past 90d): 20 | Contributors (cumulative): 67 | DMM Complexity: 1.0\n\nDIFF:\n@@ -14,7 +14,7 @@ from .models import Response\n from .packages.urllib3.poolmanager import PoolManager, proxy_from_url\n from .packages.urllib3.response import HTTPResponse\n from .packages.urllib3.util import Timeout as TimeoutSauce\n-from .compat import urlparse, basestring, urldefrag, unquote\n+from .compat import urlparse, basestring, urldefrag, unquote, urlunparse\n from .utils import (DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers,\n                     except_on_missing_scheme, get_auth_from_url)\n from .structures import CaseInsensitiveDict\n@@ -206,7 +206,12 @@ class HTTPAdapter(BaseAdapter):\n \n             conn = self.proxy_manager[proxy].connection_from_url(url)\n         else:\n-            conn = self.poolmanager.connection_from_url(url.lower())\n+            # Only scheme should be lower case\n+            parsed = urlparse(url)\n+            parsed = (parsed.scheme, parsed.netloc, parsed.path,\n+                    parsed.params, parsed.query, parsed.fragment)\n+            url = urlunparse(parsed)\n+            conn = self.poolmanager.connection_from_url(url)\n \n         return conn\n \n@@ -232,7 +237,7 @@ class HTTPAdapter(BaseAdapter):\n         :param proxies: A dictionary of schemes to proxy URLs.\n         \"\"\"\n         proxies = proxies or {}\n-        scheme = urlparse(request.url).scheme.lower()\n+        scheme = urlparse(request.url).scheme\n         proxy = proxies.get(scheme)\n \n         if proxy and scheme != 'https':\n\n@@ -94,7 +94,7 @@ class SessionRedirectMixin(object):\n \n             # The scheme should be lower case...\n             parsed = urlparse(url)\n-            parsed = (parsed.scheme.lower(), parsed.netloc, parsed.path,\n+            parsed = (parsed.scheme, parsed.netloc, parsed.path,\n                       parsed.params, parsed.query, parsed.fragment)\n             url = urlunparse(parsed)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4972133a9bcbf98182a26d796e98c74453a224f9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 8 | Files Changed: 2 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 12 | Churn Cumulative: 3272 | Contributors (this commit): 59 | Commits (past 90d): 22 | Contributors (cumulative): 67 | DMM Complexity: 0.5\n\nDIFF:\n@@ -14,7 +14,7 @@ from .models import Response\n from .packages.urllib3.poolmanager import PoolManager, proxy_from_url\n from .packages.urllib3.response import HTTPResponse\n from .packages.urllib3.util import Timeout as TimeoutSauce\n-from .compat import urlparse, basestring, urldefrag, unquote, urlunparse\n+from .compat import urlparse, basestring, urldefrag, unquote\n from .utils import (DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers,\n                     except_on_missing_scheme, get_auth_from_url)\n from .structures import CaseInsensitiveDict\n@@ -208,9 +208,7 @@ class HTTPAdapter(BaseAdapter):\n         else:\n             # Only scheme should be lower case\n             parsed = urlparse(url)\n-            parsed = (parsed.scheme, parsed.netloc, parsed.path,\n-                    parsed.params, parsed.query, parsed.fragment)\n-            url = urlunparse(parsed)\n+            url = parsed.geturl()\n             conn = self.poolmanager.connection_from_url(url)\n \n         return conn\n\n@@ -12,7 +12,7 @@ import os\n from collections import Mapping\n from datetime import datetime\n \n-from .compat import cookielib, OrderedDict, urljoin, urlparse, urlunparse, builtin_str\n+from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n from .cookies import cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar\n from .models import Request, PreparedRequest\n from .hooks import default_hooks, dispatch_hook\n@@ -94,9 +94,7 @@ class SessionRedirectMixin(object):\n \n             # The scheme should be lower case...\n             parsed = urlparse(url)\n-            parsed = (parsed.scheme, parsed.netloc, parsed.path,\n-                      parsed.params, parsed.query, parsed.fragment)\n-            url = urlunparse(parsed)\n+            url = parsed.geturl()\n \n             # Facilitate non-RFC2616-compliant 'location' headers\n             # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#470af31f4a5e9edfae1c818f5104ee83f5f541cb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 8 | Churn Cumulative: 2574 | Contributors (this commit): 50 | Commits (past 90d): 13 | Contributors (cumulative): 50 | DMM Complexity: 0.0\n\nDIFF:\n@@ -112,10 +112,16 @@ class SessionRedirectMixin(object):\n                 method = 'GET'\n \n             # Do what the browsers do, despite standards...\n-            if (resp.status_code in (codes.moved, codes.found) and\n+            # First, turn 302s into GETs.\n+            if (resp.status_code == codes.found and\n                     method not in ('GET', 'HEAD')):\n                 method = 'GET'\n \n+            # Second, if a POST is responded to with a 301, turn it into a GET.\n+            # This bizarre behaviour is explained in Issue 1704.\n+            if (resp.status_code == codes.moved) and (method == 'POST'):\n+                method = 'GET'\n+\n             prepared_request.method = method\n \n             # https://github.com/kennethreitz/requests/issues/1084\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#3369d87da96e38772faa773b755189320ab5b81c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 2579 | Contributors (this commit): 50 | Commits (past 90d): 14 | Contributors (cumulative): 50 | DMM Complexity: 1.0\n\nDIFF:\n@@ -113,13 +113,12 @@ class SessionRedirectMixin(object):\n \n             # Do what the browsers do, despite standards...\n             # First, turn 302s into GETs.\n-            if (resp.status_code == codes.found and\n-                    method not in ('GET', 'HEAD')):\n+            if resp.status_code == codes.found and method != 'HEAD':\n                 method = 'GET'\n \n             # Second, if a POST is responded to with a 301, turn it into a GET.\n             # This bizarre behaviour is explained in Issue 1704.\n-            if (resp.status_code == codes.moved) and (method == 'POST'):\n+            if resp.status_code == codes.moved and method == 'POST':\n                 method = 'GET'\n \n             prepared_request.method = method\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#3a9d9f22791dfe8947d9b08ff83c80a5ed49bd95", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 9 | Churn Cumulative: 1194 | Contributors (this commit): 27 | Commits (past 90d): 5 | Contributors (cumulative): 27 | DMM Complexity: 1.0\n\nDIFF:\n@@ -63,6 +63,7 @@ class HTTPDigestAuth(AuthBase):\n         self.last_nonce = ''\n         self.nonce_count = 0\n         self.chal = {}\n+        self.pos = None\n \n     def build_digest_header(self, method, url):\n \n@@ -150,6 +151,10 @@ class HTTPDigestAuth(AuthBase):\n     def handle_401(self, r, **kwargs):\n         \"\"\"Takes the given response and tries digest-auth, if needed.\"\"\"\n \n+        if self.pos is not None:\n+            # Rewind the file position indicator of the body to where\n+            # it was to resend the request.\n+            r.request.body.seek(self.pos)\n         num_401_calls = getattr(self, 'num_401_calls', 1)\n         s_auth = r.headers.get('www-authenticate', '')\n \n@@ -181,5 +186,9 @@ class HTTPDigestAuth(AuthBase):\n         # If we have a saved nonce, skip the 401\n         if self.last_nonce:\n             r.headers['Authorization'] = self.build_digest_header(r.method, r.url)\n+        try:\n+            self.pos = r.body.tell()\n+        except AttributeError:\n+            pass\n         r.register_hook('response', self.handle_401)\n         return r\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#2bbd7ba1c2c5a56c0957be64b5f94f6a4b0243ca", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 6 | Churn Cumulative: 2585 | Contributors (this commit): 50 | Commits (past 90d): 16 | Contributors (cumulative): 50 | DMM Complexity: 0.0\n\nDIFF:\n@@ -330,7 +330,11 @@ class Session(SessionRedirectMixin):\n         prep = self.prepare_request(req)\n \n         # Add param cookies to session cookies\n-        self.cookies = cookiejar_from_dict(cookies, cookiejar=self.cookies, overwrite=False)\n+        if isinstance(cookies, dict):\n+            self.cookies = cookiejar_from_dict(\n+                cookies, cookiejar=self.cookies, overwrite=False)\n+        elif isinstance(cookies, cookielib.CookieJar):\n+            self.cookies.update(cookies)\n \n         proxies = proxies or {}\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e3c771f36bbec5d116181229b58182435a2da461", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 8 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 8 | Churn Cumulative: 3986 | Contributors (this commit): 65 | Commits (past 90d): 16 | Contributors (cumulative): 65 | DMM Complexity: 1.0\n\nDIFF:\n@@ -188,6 +188,14 @@ class RequestsTestCase(unittest.TestCase):\n         # Make sure the session cj is still the custom one\n         assert s.cookies is cj\n     \n+    def test_param_cookiejar_works(self):\n+        cj = cookielib.CookieJar()\n+        cookiejar_from_dict({'foo' : 'bar'}, cj)\n+        s = requests.session()\n+        r = s.get(httpbin('cookies'), cookies=cj)\n+        # Make sure the cookie was sent\n+        assert r.json()['cookies']['foo'] == 'bar'\n+\n     def test_requests_in_history_are_not_overridden(self):\n         resp = requests.get(httpbin('redirect/3'))\n         urls = [r.url for r in resp.history]\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e40c1637c915e112fabaffb39fcd73beed56ff4b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 23 | Lines Deleted: 7 | Files Changed: 2 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 2/4 | Churn Δ: 30 | Churn Cumulative: 3272 | Contributors (this commit): 58 | Commits (past 90d): 24 | Contributors (cumulative): 66 | DMM Complexity: 1.0\n\nDIFF:\n@@ -421,3 +421,22 @@ def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):\n                 cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))\n \n     return cookiejar\n+\n+\n+def merge_cookies(cookiejar, cookies):\n+    \"\"\"Add cookies to cookiejar and returns a merged CookieJar.\n+\n+    :param cookiejar: CookieJar object to add the cookies to.\n+    :param cookies: Dictionary or CookieJar object to be added.\n+    \"\"\"\n+    if not isinstance(cookiejar, cookielib.CookieJar):\n+        raise ValueError('You can only merge into CookieJar')\n+    \n+    if isinstance(cookies, dict):\n+        cookiejar.update(\n+            cookiejar_from_dict(\n+                cookies, cookiejar=cookiejar, overwrite=False))\n+    elif isinstance(cookies, cookielib.CookieJar):\n+        cookiejar.update(cookies)\n+\n+    return cookiejar\n\n@@ -12,8 +12,9 @@ import os\n from collections import Mapping\n from datetime import datetime\n \n-from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n-from .cookies import cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar\n+from .compat import cookielib, OrderedDict, urljoin, urlparse, urlunparse, builtin_str\n+from .cookies import (\n+    cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)\n from .models import Request, PreparedRequest\n from .hooks import default_hooks, dispatch_hook\n from .utils import to_key_val_list, default_headers\n@@ -330,11 +331,7 @@ class Session(SessionRedirectMixin):\n         prep = self.prepare_request(req)\n \n         # Add param cookies to session cookies\n-        if isinstance(cookies, dict):\n-            self.cookies = cookiejar_from_dict(\n-                cookies, cookiejar=self.cookies, overwrite=False)\n-        elif isinstance(cookies, cookielib.CookieJar):\n-            self.cookies.update(cookies)\n+        self.cookies = merge_cookies(self.cookies, cookies)\n \n         proxies = proxies or {}\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#30018e604c0f89a0dad7d8b7e6f2a227916ee8c9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 681 | Contributors (this commit): 16 | Commits (past 90d): 9 | Contributors (cumulative): 16 | DMM Complexity: 0.0\n\nDIFF:\n@@ -433,9 +433,8 @@ def merge_cookies(cookiejar, cookies):\n         raise ValueError('You can only merge into CookieJar')\n     \n     if isinstance(cookies, dict):\n-        cookiejar.update(\n-            cookiejar_from_dict(\n-                cookies, cookiejar=cookiejar, overwrite=False))\n+        cookiejar = cookiejar_from_dict(\n+            cookies, cookiejar=cookiejar, overwrite=False)\n     elif isinstance(cookies, cookielib.CookieJar):\n         cookiejar.update(cookies)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#1adba3c9e94a7408584d0d819da6aa47b34ed0bd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 13 | Lines Deleted: 10 | Files Changed: 3 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 23 | Churn Cumulative: 7286 | Contributors (this commit): 101 | Commits (past 90d): 42 | Contributors (cumulative): 131 | DMM Complexity: 1.0\n\nDIFF:\n@@ -432,10 +432,13 @@ def merge_cookies(cookiejar, cookies):\n     if not isinstance(cookiejar, cookielib.CookieJar):\n         raise ValueError('You can only merge into CookieJar')\n     \n-    if isinstance(cookies, dict):\n-        cookiejar = cookiejar_from_dict(\n-            cookies, cookiejar=cookiejar, overwrite=False)\n-    elif isinstance(cookies, cookielib.CookieJar):\n-        cookiejar.update(cookies)\n+    merged_cookie = RequestsCookieJar()\n+    merged_cookie.update(cookiejar)\n \n-    return cookiejar\n+    if isinstance(cookies, dict):\n+        merged_cookie = cookiejar_from_dict(\n+            cookies, cookiejar=merged_cookie, overwrite=False)\n+    elif isinstance(cookies, cookielib.CookieJar):\n+        merged_cookie.update(cookies)\n+\n+    return merged_cookie\n\n@@ -246,9 +246,8 @@ class Session(SessionRedirectMixin):\n             cookies = cookiejar_from_dict(cookies)\n \n         # Merge with session cookies\n-        merged_cookies = RequestsCookieJar()\n-        merged_cookies.update(self.cookies)\n-        merged_cookies.update(cookies)\n+        merged_cookies = merge_cookies(\n+            merge_cookies(RequestsCookieJar(), self.cookies), cookies)\n \n \n         # Set environment's basic authentication if not explicitly set.\n\n@@ -186,7 +186,8 @@ class RequestsTestCase(unittest.TestCase):\n         # Make sure the cookie was sent\n         assert r.json()['cookies']['foo'] == 'bar'\n         # Make sure the session cj is still the custom one\n-        assert s.cookies is cj\n+        assert isinstance(s.cookies, cookielib.CookieJar)\n+        assert s.cookies['foo'] == 'bar'\n     \n     def test_param_cookiejar_works(self):\n         cj = cookielib.CookieJar()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#5fcaf45c33c35aa36794bddf97da82545ada5fff", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 12 | Lines Deleted: 9 | Files Changed: 2 | Hunks: 5 | Methods Changed: 2 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 21 | Churn Cumulative: 4706 | Contributors (this commit): 75 | Commits (past 90d): 27 | Contributors (cumulative): 81 | DMM Complexity: 0.0\n\nDIFF:\n@@ -432,13 +432,17 @@ def merge_cookies(cookiejar, cookies):\n     if not isinstance(cookiejar, cookielib.CookieJar):\n         raise ValueError('You can only merge into CookieJar')\n     \n-    merged_cookie = RequestsCookieJar()\n-    merged_cookie.update(cookiejar)\n-\n     if isinstance(cookies, dict):\n-        merged_cookie = cookiejar_from_dict(\n-            cookies, cookiejar=merged_cookie, overwrite=False)\n+        cookiejar = cookiejar_from_dict(\n+            cookies, cookiejar=cookiejar, overwrite=False)\n     elif isinstance(cookies, cookielib.CookieJar):\n-        merged_cookie.update(cookies)\n+        try:\n+            if hasattr(cookiejar, 'update'):\n+                cookiejar.update(cookies)\n+            else:\n+                raise CookieJarError\n+        except CookieJarError:\n+            for cookie_in_jar in cookies:\n+                cookiejar.set_cookie(cookie_in_jar)\n \n-    return merged_cookie\n+    return cookiejar\n\n@@ -186,8 +186,7 @@ class RequestsTestCase(unittest.TestCase):\n         # Make sure the cookie was sent\n         assert r.json()['cookies']['foo'] == 'bar'\n         # Make sure the session cj is still the custom one\n-        assert isinstance(s.cookies, cookielib.CookieJar)\n-        assert s.cookies['foo'] == 'bar'\n+        assert s.cookies is cj\n     \n     def test_param_cookiejar_works(self):\n         cj = cookielib.CookieJar()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#8b2255d0f8b0bb472ec2193e4ac5c4d28336a5eb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 718 | Contributors (this commit): 16 | Commits (past 90d): 12 | Contributors (cumulative): 16 | DMM Complexity: None\n\nDIFF:\n@@ -437,9 +437,9 @@ def merge_cookies(cookiejar, cookies):\n             cookies, cookiejar=cookiejar, overwrite=False)\n     elif isinstance(cookies, cookielib.CookieJar):\n         try:\n-            if hasattr(cookiejar, 'update'):\n+            try:\n                 cookiejar.update(cookies)\n-            else:\n+            except AttributeError:\n                 raise CookieJarError\n         except CookieJarError:\n             for cookie_in_jar in cookies:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#8eb40c777e4a5d0967205404a170615eb96ca237", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 3 | Churn Cumulative: 721 | Contributors (this commit): 16 | Commits (past 90d): 13 | Contributors (cumulative): 16 | DMM Complexity: 1.0\n\nDIFF:\n@@ -436,12 +436,9 @@ def merge_cookies(cookiejar, cookies):\n         cookiejar = cookiejar_from_dict(\n             cookies, cookiejar=cookiejar, overwrite=False)\n     elif isinstance(cookies, cookielib.CookieJar):\n-        try:\n         try:\n             cookiejar.update(cookies)\n         except AttributeError:\n-                raise CookieJarError\n-        except CookieJarError:\n             for cookie_in_jar in cookies:\n                 cookiejar.set_cookie(cookie_in_jar)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c26a6c310cf8489bb55be5b4b9899d06a2bddda9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 2603 | Contributors (this commit): 50 | Commits (past 90d): 18 | Contributors (cumulative): 50 | DMM Complexity: None\n\nDIFF:\n@@ -12,7 +12,7 @@ import os\n from collections import Mapping\n from datetime import datetime\n \n-from .compat import cookielib, OrderedDict, urljoin, urlparse, urlunparse, builtin_str\n+from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n from .cookies import (\n     cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)\n from .models import Request, PreparedRequest\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b825bbd4a21d7d6e2a0ce17527b25139b26808a2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 9 | Churn Cumulative: 527 | Contributors (this commit): 4 | Commits (past 90d): 1 | Contributors (cumulative): 4 | DMM Complexity: 1.0\n\nDIFF:\n@@ -5,7 +5,16 @@\n # the MIT License: http://www.opensource.org/licenses/mit-license.php\n \n from collections import MutableMapping\n+try:\n     from threading import RLock\n+except ImportError: # Platform-specific: No threads available\n+    class RLock:\n+        def __enter__(self):\n+            pass\n+\n+        def __exit__(self, exc_type, exc_value, traceback):\n+            pass\n+\n \n try: # Python 2.7+\n     from collections import OrderedDict\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#649dac1029ad51e01091a06feac81f199249cfc3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 1196 | Contributors (this commit): 28 | Commits (past 90d): 6 | Contributors (cumulative): 28 | DMM Complexity: None\n\nDIFF:\n@@ -144,7 +144,7 @@ class HTTPDigestAuth(AuthBase):\n         if entdig:\n             base += ', digest=\"%s\"' % entdig\n         if qop:\n-            base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+            base += ', qop=\"auth\", nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n \n         return 'Digest %s' % (base)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#fecb35a08ec77d6392bdc609ab1ea21943e40228", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 10 | Churn Cumulative: 5198 | Contributors (this commit): 84 | Commits (past 90d): 22 | Contributors (cumulative): 93 | DMM Complexity: 1.0\n\nDIFF:\n@@ -144,7 +144,7 @@ class HTTPDigestAuth(AuthBase):\n         if entdig:\n             base += ', digest=\"%s\"' % entdig\n         if qop:\n-            base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+            base += ', qop=\"auth\", nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n \n         return 'Digest %s' % (base)\n \n\n@@ -320,6 +320,14 @@ class RequestsTestCase(unittest.TestCase):\n         r = s.get(url)\n         assert r.status_code == 401\n \n+    def test_DIGESTAUTH_QUOTES_QOP_VALUE(self):\n+\n+        auth = HTTPDigestAuth('user', 'pass')\n+        url = httpbin('digest-auth', 'auth', 'user', 'pass')\n+\n+        r = requests.get(url, auth=auth)\n+        assert '\"auth\"' in r.request.headers['Authorization']\n+\n     def test_POSTBIN_GET_POST_FILES(self):\n \n         url = httpbin('post')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4f786e4f6240d3518d1add2faf49166301580732", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 12 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 3 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 12 | Churn Cumulative: 4012 | Contributors (this commit): 65 | Commits (past 90d): 16 | Contributors (cumulative): 65 | DMM Complexity: 1.0\n\nDIFF:\n@@ -563,6 +563,18 @@ class RequestsTestCase(unittest.TestCase):\n         url = 'http://user:pass@complex.url.com/path?query=yes'\n         assert ('user', 'pass') == requests.utils.get_auth_from_url(url)\n \n+    def test_get_auth_from_url_encoded_spaces(self):\n+        url = 'http://user:pass%20pass@complex.url.com/path?query=yes'\n+        assert ('user', 'pass pass') == requests.utils.get_auth_from_url(url)\n+\n+    def test_get_auth_from_url_not_encoded_spaces(self):\n+        url = 'http://user:pass pass@complex.url.com/path?query=yes'\n+        assert ('user', 'pass pass') == requests.utils.get_auth_from_url(url)\n+\n+    def test_get_auth_from_url_percent_chars(self):\n+        url = 'http://user%user:pass@complex.url.com/path?query=yes'\n+        assert ('user%user', 'pass') == requests.utils.get_auth_from_url(url)\n+\n     def test_cannot_send_unprepared_requests(self):\n         r = requests.Request(url=HTTPBIN)\n         with pytest.raises(ValueError):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
