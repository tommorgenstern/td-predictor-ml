{"custom_id": "requests#1451ba0c6d395c41f86da35036fa361c3a41bc90", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 10 | Files Changed: 2 | Hunks: 7 | Methods Changed: 4 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 14 | Churn Cumulative: 10072 | Contributors (this commit): 98 | Commits (past 90d): 88 | Contributors (cumulative): 113 | DMM Complexity: 1.0\n\nDIFF:\n@@ -528,7 +528,6 @@ class Response(object):\n \n         return content\n \n-    @property\n     def json(self):\n         \"\"\"Returns the json-encoded content of a response, if any.\"\"\"\n \n@@ -539,14 +538,8 @@ class Response(object):\n             # a best guess).\n             encoding = guess_json_utf(self.content)\n             if encoding is not None:\n-                try:\n                 return json.loads(self.content.decode(encoding))\n-                except (ValueError, UnicodeDecodeError):\n-                    pass\n-        try:\n         return json.loads(self.text or self.content)\n-        except ValueError:\n-            return None\n \n     @property\n     def links(self):\n\n@@ -62,7 +62,7 @@ def merge_kwargs(local_kwarg, default_kwarg):\n \n class SessionRedirectMixin(object):\n \n-    def resolve_redirects(self, resp, req, stream=False, timeout=None, verify=True, cert=None):\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n         i = 0\n@@ -125,7 +125,8 @@ class SessionRedirectMixin(object):\n                     stream=stream,\n                     timeout=timeout,\n                     verify=verify,\n-                    cert=cert\n+                    cert=cert,\n+                    proxies=proxies\n                 )\n \n             i += 1\n@@ -255,7 +256,7 @@ class Session(SessionRedirectMixin):\n         resp = self.send(prep, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\n \n         # Redirect resolving generator.\n-        gen = self.resolve_redirects(resp, req, stream, timeout, verify, cert)\n+        gen = self.resolve_redirects(resp, req, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\n \n         # Resolve redirects if allowed.\n         history = [r for r in gen] if allow_redirects else []\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c65a52a1d0021055b407d913c216330822307f3c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 8338 | Contributors (this commit): 90 | Commits (past 90d): 59 | Contributors (cumulative): 90 | DMM Complexity: None\n\nDIFF:\n@@ -190,7 +190,7 @@ class Request(RequestHooksMixin):\n         return '<Request [%s]>' % (self.method)\n \n     def prepare(self):\n-        \"\"\"Constructs a PreparedRequest and returns it.\"\"\"\n+        \"\"\"Constructs a PreparedRequest for transmission and returns it.\"\"\"\n         p = PreparedRequest()\n \n         p.prepare_method(self.method)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#92209d9ebe2d8ef6bdb30f897e8cee67e956a5ef", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 2573 | Contributors (this commit): 23 | Commits (past 90d): 5 | Contributors (cumulative): 23 | DMM Complexity: None\n\nDIFF:\n@@ -215,8 +215,6 @@ class RequestsTestCase(unittest.TestCase):\n             pass\n \n     def test_request_ok_set(self):\n-\n-\n         r = requests.get(httpbin('status', '404'))\n         self.assertEqual(r.ok, False)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b95ad3f6a8dea9c443e46a20ae8f2a9610831751", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 603 | Files Changed: 1 | Hunks: 1 | Methods Changed: 10 | Complexity Δ (Sum/Max): -77/0 | Churn Δ: 603 | Churn Cumulative: 1208 | Contributors (this commit): 1 | Commits (past 90d): 4 | Contributors (cumulative): 1 | DMM Complexity: 0.851145038167939\n\nDIFF:\n@@ -1,603 +0,0 @@\n-\n-    def old_request(self, method, url,\n-        params=None,\n-        data=None,\n-        headers=None,\n-        cookies=None,\n-        files=None,\n-        auth=None,\n-        timeout=None,\n-        allow_redirects=True,\n-        proxies=None,\n-        hooks=None,\n-        return_response=True,\n-        config=None,\n-        prefetch=None,\n-        verify=None,\n-        cert=None):\n-\n-        \"\"\"Constructs and sends a :class:`Request <Request>`.\n-        Returns :class:`Response <Response>` object.\n-\n-        :param method: method for the new :class:`Request` object.\n-        :param url: URL for the new :class:`Request` object.\n-        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.\n-        :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.\n-        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n-        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n-        :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n-        :param auth: (optional) Auth tuple or callable to enable Basic/Digest/Custom HTTP Auth.\n-        :param timeout: (optional) Float describing the timeout of the request.\n-        :param allow_redirects: (optional) Boolean. Set to True by default.\n-        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n-        :param config: (optional) A configuration dictionary. See ``request.defaults`` for allowed keys and their default values.\n-        :param prefetch: (optional) whether to immediately download the response content. Defaults to ``True``.\n-        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n-        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n-        \"\"\"\n-\n-        method = str(method).upper()\n-\n-        # Default empty dicts for dict params.\n-        data = [] if data is None else data\n-        files = [] if files is None else files\n-        headers = {} if headers is None else headers\n-        params = {} if params is None else params\n-        hooks = {} if hooks is None else hooks\n-        prefetch = prefetch if prefetch is not None else self.prefetch\n-\n-        # use session's hooks as defaults\n-        for key, cb in list(self.hooks.items()):\n-            hooks.setdefault(key, cb)\n-\n-        # Expand header values.\n-        if headers:\n-            for k, v in list(headers.items() or {}):\n-                headers[k] = header_expand(v)\n-\n-        args = dict(\n-            method=method,\n-            url=url,\n-            data=data,\n-            params=from_key_val_list(params),\n-            headers=from_key_val_list(headers),\n-            cookies=cookies,\n-            files=files,\n-            auth=auth,\n-            hooks=from_key_val_list(hooks),\n-            timeout=timeout,\n-            allow_redirects=allow_redirects,\n-            proxies=from_key_val_list(proxies),\n-            config=from_key_val_list(config),\n-            prefetch=prefetch,\n-            verify=verify,\n-            cert=cert,\n-            _poolmanager=self.poolmanager\n-        )\n-\n-        # merge session cookies into passed-in ones\n-        dead_cookies = None\n-        # passed-in cookies must become a CookieJar:\n-        if not isinstance(cookies, cookielib.CookieJar):\n-            args['cookies'] = cookiejar_from_dict(cookies)\n-            # support unsetting cookies that have been passed in with None values\n-            # this is only meaningful when `cookies` is a dict ---\n-            # for a real CookieJar, the client should use session.cookies.clear()\n-            if cookies is not None:\n-                dead_cookies = [name for name in cookies if cookies[name] is None]\n-        # merge the session's cookies into the passed-in cookies:\n-        for cookie in self.cookies:\n-            args['cookies'].set_cookie(cookie)\n-        # remove the unset cookies from the jar we'll be using with the current request\n-        # (but not from the session's own store of cookies):\n-        if dead_cookies is not None:\n-            for name in dead_cookies:\n-                remove_cookie_by_name(args['cookies'], name)\n-\n-        # Merge local kwargs with session kwargs.\n-        for attr in self.__attrs__:\n-            # we already merged cookies:\n-            if attr == 'cookies':\n-                continue\n-\n-            session_val = getattr(self, attr, None)\n-            local_val = args.get(attr)\n-            args[attr] = merge_kwargs(local_val, session_val)\n-\n-        # Arguments manipulation hook.\n-        args = dispatch_hook('args', args['hooks'], args)\n-\n-        # Create the (empty) response.\n-        r = Request(**args)\n-\n-        # Give the response some context.\n-        r.session = self\n-\n-        # Don't send if asked nicely.\n-        if not return_response:\n-            return r\n-\n-        # Send the HTTP Request.\n-        return self._send_request(r, **args)\n-\n-\n-class OldRequest(object):\n-    \"\"\"The :class:`Request <Request>` object. It carries out all functionality\n-    of Requests. Recommended interface is with the Requests functions.\n-    \"\"\"\n-\n-    def __init__(self,\n-        url=None,\n-        headers=dict(),\n-        files=None,\n-        method=None,\n-        data=dict(),\n-        params=dict(),\n-        auth=None,\n-        cookies=None,\n-        timeout=None,\n-        redirect=False,\n-        allow_redirects=False,\n-        proxies=None,\n-        hooks=None,\n-        config=None,\n-        prefetch=True,\n-        _poolmanager=None,\n-        verify=None,\n-        session=None,\n-        cert=None):\n-\n-        #: Dictionary of configurations for this request.\n-        self.config = dict(config or [])\n-\n-        #: Float describes the timeout of the request.\n-        #  (Use socket.setdefaulttimeout() as fallback)\n-        self.timeout = timeout\n-\n-        # URL\n-\n-        #: Dictionary of HTTP Headers to attach to the :class:`Request <Request>`.\n-        self.headers = dict(headers or [])\n-\n-        #: Dictionary of files to multipart upload (``{filename: content}``).\n-        self.files = None\n-\n-        #: HTTP Method to use.\n-        self.method = method\n-\n-        #: Dictionary, bytes or file stream of request body data to attach to the\n-        #: :class:`Request <Request>`.\n-        self.data = None\n-\n-        #: Dictionary of querystring data to attach to the\n-        #: :class:`Request <Request>`. The dictionary values can be lists for representing\n-        #: multivalued query parameters.\n-        self.params = None\n-\n-        #: True if :class:`Request <Request>` is part of a redirect chain (disables history\n-        #: and HTTPError storage).\n-        self.redirect = redirect\n-\n-        #: Set to True if full redirects are allowed (e.g. re-POST-ing of data at new ``Location``)\n-        self.allow_redirects = allow_redirects\n-\n-        # Dictionary mapping protocol to the URL of the proxy (e.g. {'http': 'foo.bar:3128'})\n-        self.proxies = dict(proxies or [])\n-\n-        for proxy_type, uri_ref in list(self.proxies.items()):\n-            if not uri_ref:\n-                del self.proxies[proxy_type]\n-\n-        # If no proxies are given, allow configuration by environment variables\n-        # HTTP_PROXY and HTTPS_PROXY.\n-        if not self.proxies and self.config.get('trust_env'):\n-            self.proxies = get_environ_proxies(self.url)\n-\n-        self.data = data\n-        self.params = params\n-        self.files = files\n-\n-        #: :class:`Response <Response>` instance, containing\n-        #: content and metadata of HTTP Response, once :attr:`sent <send>`.\n-        self.response = Response()\n-\n-        #: Authentication tuple or object to attach to :class:`Request <Request>`.\n-        self.auth = auth\n-\n-        # #: CookieJar to attach to :class:`Request <Request>`.\n-        # if isinstance(cookies, cookielib.CookieJar):\n-        #     self.cookies = cookies\n-        # else:\n-        #     self.cookies = cookiejar_from_dict(cookies)\n-\n-        #: True if Request has been sent.\n-        self.sent = False\n-\n-        #: Event-handling hooks.\n-        self.hooks = {}\n-\n-        for event in HOOKS:\n-            self.hooks[event] = []\n-\n-        hooks = hooks or {}\n-\n-        for (k, v) in list(hooks.items()):\n-            self.register_hook(event=k, hook=v)\n-\n-        #: Session.\n-        self.session = session\n-\n-        #: SSL Verification.\n-        self.verify = verify\n-\n-        #: SSL Certificate\n-        self.cert = cert\n-\n-        #: Prefetch response content\n-        self.prefetch = prefetch\n-\n-        # if headers:\n-        #     headers = CaseInsensitiveDict(self.headers)\n-        # else:\n-        #     headers = CaseInsensitiveDict()\n-\n-        # Add configured base headers.\n-        for (k, v) in list(self.config.get('base_headers', {}).items()):\n-            if k not in headers:\n-                headers[k] = v\n-\n-        self.headers = headers\n-        self._poolmanager = _poolmanager\n-\n-    def __repr__(self):\n-        return '<Request [%s]>' % (self.method)\n-\n-    def _build_response(self, resp):\n-        \"\"\"Build internal :class:`Response <Response>` object\n-        from given response.\n-        \"\"\"\n-\n-        def build(resp):\n-\n-            response = Response()\n-\n-            # Pass settings over.\n-            response.config = self.config\n-\n-            if resp:\n-\n-                # Fallback to None if there's no status_code, for whatever reason.\n-                # response.status_code = getattr(resp, 'status', None)\n-\n-                # Make headers case-insensitive.\n-                # response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))\n-\n-                # Set encoding.\n-                # response.encoding = get_encoding_from_headers(response.headers)\n-\n-                # Add new cookies from the server.\n-                extract_cookies_to_jar(self.cookies, self, resp)\n-\n-                # Save cookies in Response.\n-                response.cookies = self.cookies\n-\n-                # Save cookies in Session.\n-                for cookie in self.cookies:\n-                    self.session.cookies.set_cookie(cookie)\n-\n-                # No exceptions were harmed in the making of this request.\n-                response.error = getattr(resp, 'error', None)\n-\n-            # Save original response for later.\n-            response.raw = resp\n-            if isinstance(self.full_url, bytes):\n-                response.url = self.full_url.decode('utf-8')\n-            else:\n-                response.url = self.full_url\n-\n-            return response\n-\n-        history = []\n-\n-        r = build(resp)\n-        # TODO: session level shit\n-        if r.status_code in REDIRECT_STATI and not self.redirect:\n-\n-            while (('location' in r.headers and r.status_code in REDIRECT_STATI) and\n-                   ((r.status_code is codes.see_other) or (self.allow_redirects))):\n-\n-                r.content  # Consume socket so it can be released\n-\n-                if not len(history) < self.config.get('max_redirects'):\n-                    raise TooManyRedirects()\n-\n-                # Release the connection back into the pool.\n-                r.raw.release_conn()\n-\n-                history.append(r)\n-\n-                url = r.headers['location']\n-                data = self.data\n-                files = self.files\n-\n-                # Handle redirection without scheme (see: RFC 1808 Section 4)\n-                if url.startswith('//'):\n-                    parsed_rurl = urlparse(r.url)\n-                    url = '%s:%s' % (parsed_rurl.scheme, url)\n-\n-                # Facilitate non-RFC2616-compliant 'location' headers\n-                # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n-                if not urlparse(url).netloc:\n-                    url = urljoin(r.url,\n-                                  # Compliant with RFC3986, we percent\n-                                  # encode the url.\n-                                  requote_uri(url))\n-\n-                # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n-                if r.status_code is codes.see_other:\n-                    method = 'GET'\n-                    data = None\n-                    files = None\n-                else:\n-                    method = self.method\n-\n-                # Do what the browsers do, despite standards...\n-                if r.status_code in (codes.moved, codes.found) and self.method == 'POST':\n-                    method = 'GET'\n-                    data = None\n-                    files = None\n-\n-                if (r.status_code == 303) and self.method != 'HEAD':\n-                    method = 'GET'\n-                    data = None\n-                    files = None\n-\n-                # Remove the cookie headers that were sent.\n-                headers = self.headers\n-                try:\n-                    del headers['Cookie']\n-                except KeyError:\n-                    pass\n-\n-                request = Request(\n-                    url=url,\n-                    headers=headers,\n-                    files=files,\n-                    method=method,\n-                    params=self.session.params,\n-                    auth=self.auth,\n-                    cookies=self.cookies,\n-                    redirect=True,\n-                    data=data,\n-                    config=self.config,\n-                    timeout=self.timeout,\n-                    _poolmanager=self._poolmanager,\n-                    proxies=self.proxies,\n-                    verify=self.verify,\n-                    session=self.session,\n-                    cert=self.cert,\n-                    prefetch=self.prefetch\n-                )\n-\n-                request.send()\n-                r = request.response\n-\n-            r.history = history\n-\n-        self.response = r\n-        self.response.request = self\n-\n-\n-    def register_hook(self, event, hook):\n-        \"\"\"Properly register a hook.\"\"\"\n-        if isinstance(hook, collections.Callable):\n-            self.hooks[event].append(hook)\n-        elif hasattr(hook, '__iter__'):\n-            self.hooks[event].extend(h for h in hook if isinstance(h, collections.Callable))\n-\n-    def deregister_hook(self, event, hook):\n-        \"\"\"Deregister a previously registered hook.\n-        Returns True if the hook existed, False if not.\n-        \"\"\"\n-\n-        try:\n-            self.hooks[event].remove(hook)\n-            return True\n-        except ValueError:\n-            return False\n-\n-    def send(self, anyway=False, prefetch=None):\n-        \"\"\"Sends the request. Returns True if successful, False if not.\n-        If there was an HTTPError during transmission,\n-        self.response.status_code will contain the HTTPError code.\n-\n-        Once a request is successfully sent, `sent` will equal True.\n-\n-        :param anyway: If True, request will be sent, even if it has\n-        already been sent.\n-\n-        :param prefetch: If not None, will override the request's own setting\n-        for prefetch.\n-        \"\"\"\n-\n-        # Build the URL\n-        url = self.full_url\n-\n-        # Pre-request hook.\n-        r = dispatch_hook('pre_request', self.hooks, self)\n-        self.__dict__.update(r.__dict__)\n-\n-        # Logging\n-        log.info('Sending %s: %s' % (self, url))\n-\n-        # Use .netrc auth if none was provided.\n-        if not self.auth and self.config.get('trust_env'):\n-            self.auth = get_netrc_auth(url)\n-\n-        # if self.auth:\n-        #     if isinstance(self.auth, tuple) and len(self.auth) == 2:\n-        #         # special-case basic HTTP auth\n-        #         self.auth = HTTPBasicAuth(*self.auth)\n-\n-        #     # Allow auth to make its changes.\n-        #     r = self.auth(self)\n-\n-        #     # Update self to reflect the auth changes.\n-        #     self.__dict__.update(r.__dict__)\n-\n-        # # Nottin' on you.\n-        # body = None\n-        # content_type = None\n-\n-        # # Multi-part file uploads.\n-        # if self.files:\n-        #     (body, content_type) = self._encode_files(self.files)\n-        # else:\n-        #     if self.data:\n-\n-        #         body = self._encode_params(self.data)\n-        #         if isinstance(self.data, str) or isinstance(self.data, builtin_str) or hasattr(self.data, 'read'):\n-        #             content_type = None\n-        #         else:\n-        #             content_type = 'application/x-www-form-urlencoded'\n-\n-        # self.headers['Content-Length'] = '0'\n-        # if hasattr(body, 'seek') and hasattr(body, 'tell'):\n-        #     body.seek(0, 2)\n-        #     self.headers['Content-Length'] = str(body.tell())\n-        #     body.seek(0, 0)\n-        # elif body is not None:\n-        #     self.headers['Content-Length'] = str(len(body))\n-\n-        # # Add content-type if it wasn't explicitly provided.\n-        # if (content_type) and (not 'content-type' in self.headers):\n-        #     self.headers['Content-Type'] = content_type\n-\n-        _p = urlparse(url)\n-        no_proxy = filter(lambda x: x.strip(), self.proxies.get('no', '').split(','))\n-        proxy = self.proxies.get(_p.scheme)\n-\n-        if proxy and not any(map(_p.hostname.endswith, no_proxy)):\n-            conn = poolmanager.ProxyManager(self.get_connection_for_url(proxy))\n-            _proxy = urlparse(proxy)\n-            if '@' in _proxy.netloc:\n-                auth, url = _proxy.netloc.split('@', 1)\n-                self.proxy_auth = HTTPProxyAuth(*auth.split(':', 1))\n-                r = self.proxy_auth(self)\n-                self.__dict__.update(r.__dict__)\n-        else:\n-            conn = self.get_connection_for_url(url)\n-\n-        if not self.config.get('keep_alive'):\n-            self.headers['Connection'] = 'close'\n-\n-        # if url.startswith('https') and self.verify:\n-\n-        #     cert_loc = None\n-\n-        #     # Allow self-specified cert location.\n-        #     if self.verify is not True:\n-        #         cert_loc = self.verify\n-\n-        #     # Look for configuration.\n-        #     if not cert_loc and self.config.get('trust_env'):\n-        #         cert_loc = os.environ.get('REQUESTS_CA_BUNDLE')\n-\n-        #     # Curl compatibility.\n-        #     if not cert_loc and self.config.get('trust_env'):\n-        #         cert_loc = os.environ.get('CURL_CA_BUNDLE')\n-\n-        #     if not cert_loc:\n-        #         cert_loc = DEFAULT_CA_BUNDLE_PATH\n-\n-        #     if not cert_loc:\n-        #         raise Exception(\"Could not find a suitable SSL CA certificate bundle.\")\n-\n-        #     conn.cert_reqs = 'CERT_REQUIRED'\n-        #     conn.ca_certs = cert_loc\n-        # else:\n-        #     conn.cert_reqs = 'CERT_NONE'\n-        #     conn.ca_certs = None\n-\n-        # if self.cert:\n-        #     if len(self.cert) == 2:\n-        #         conn.cert_file = self.cert[0]\n-        #         conn.key_file = self.cert[1]\n-        #     else:\n-        #         conn.cert_file = self.cert\n-\n-        if not self.sent or anyway:\n-\n-            # Skip if 'cookie' header is explicitly set.\n-            # if 'cookie' not in self.headers:\n-            #     cookie_header = get_cookie_header(self.cookies, self)\n-            #     if cookie_header is not None:\n-            #         self.headers['Cookie'] = cookie_header\n-\n-            # Pre-send hook.\n-            r = dispatch_hook('pre_send', self.hooks, self)\n-            self.__dict__.update(r.__dict__)\n-\n-            # catch urllib3 exceptions and throw Requests exceptions\n-            # try:\n-            #     # Send the request.\n-            #     r = conn.urlopen(\n-            #         method=self.method,\n-            #         url=self.path_url,\n-            #         body=body,\n-            #         headers=self.headers,\n-            #         redirect=False,\n-            #         assert_same_host=False,\n-            #         preload_content=False,\n-            #         decode_content=False,\n-            #         retries=self.config.get('max_retries', 0),\n-            #         timeout=self.timeout,\n-            #     )\n-            #     self.sent = True\n-\n-            # except socket.error as sockerr:\n-            #     raise ConnectionError(sockerr)\n-\n-            # except MaxRetryError as e:\n-            #     raise ConnectionError(e)\n-\n-            # except (_SSLError, _HTTPError) as e:\n-            #     if isinstance(e, _SSLError):\n-            #         raise SSLError(e)\n-            #     elif isinstance(e, TimeoutError):\n-            #         raise Timeout(e)\n-            #     else:\n-            #         raise Timeout('Request timed out.')\n-\n-            # build_response can throw TooManyRedirects\n-            self._build_response(r)\n-\n-            # Response manipulation hook.\n-            self.response = dispatch_hook('response', self.hooks, self.response)\n-\n-            # Post-request hook.\n-            r = dispatch_hook('post_request', self.hooks, self)\n-            self.__dict__.update(r.__dict__)\n-\n-            # If prefetch is True, mark content as consumed.\n-            if prefetch is None:\n-                prefetch = self.prefetch\n-            if prefetch:\n-                # Save the response.\n-                self.response.content\n-\n-            return self.sent\n-\n-    def get_connection_for_url(self, url):\n-        # Check to see if keep_alive is allowed.\n-        try:\n-            if self.config.get('keep_alive'):\n-                conn = self._poolmanager.connection_from_url(url)\n-            else:\n-                conn = connectionpool.connection_from_url(url)\n-            return conn\n-        except LocationParseError as e:\n-            raise InvalidURL(e)\n-\n-    def prepare(self):\n-        return deepcopy(self)\n\\ No newline at end of file\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4c647cd8b743822dc1af652ec5f96285d86a0d5d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 455 | Contributors (this commit): 5 | Commits (past 90d): 7 | Contributors (cumulative): 5 | DMM Complexity: None\n\nDIFF:\n@@ -43,7 +43,7 @@ is at <http://python-requests.org>.\n \n __title__ = 'requests'\n __version__ = '1.0.0'\n-__build__ = 0x00000\n+__build__ = 0x01000\n __author__ = 'Kenneth Reitz'\n __license__ = 'Apache 2.0'\n __copyright__ = 'Copyright 2012 Kenneth Reitz'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#88b5ebceb61d65197ada96a8b2e42ef1afa31af8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 369 | Contributors (this commit): 10 | Commits (past 90d): 10 | Contributors (cumulative): 10 | DMM Complexity: None\n\nDIFF:\n@@ -50,7 +50,7 @@ setup(\n         'Programming Language :: Python :: 2.6',\n         'Programming Language :: Python :: 2.7',\n         'Programming Language :: Python :: 3',\n-        'Programming Language :: Python :: 3.0',\n+        # 'Programming Language :: Python :: 3.0',\n         'Programming Language :: Python :: 3.1',\n         'Programming Language :: Python :: 3.2',\n         'Programming Language :: Python :: 3.3',\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#910b2312d644aa3edf5d03f5dc760474a949b71d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 286 | Contributors (this commit): 1 | Commits (past 90d): 17 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -62,7 +62,7 @@ class HTTPAdapter(BaseAdapter):\n \n             # Allow self-specified cert location.\n             if verify is not True:\n-                cert_loc = self.verify\n+                cert_loc = verify\n \n             # Look for configuration.\n             if not cert_loc and self.config.get('trust_env'):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#1e64fbcb559d3ca51790ec1e04385c5bfb625dc9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 8 | Files Changed: 2 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/4 | Churn Δ: 18 | Churn Cumulative: 2040 | Contributors (this commit): 23 | Commits (past 90d): 49 | Contributors (cumulative): 24 | DMM Complexity: None\n\nDIFF:\n@@ -64,14 +64,6 @@ class HTTPAdapter(BaseAdapter):\n             if verify is not True:\n                 cert_loc = verify\n \n-            # Look for configuration.\n-            if not cert_loc and self.config.get('trust_env'):\n-                cert_loc = os.environ.get('REQUESTS_CA_BUNDLE')\n-\n-            # Curl compatibility.\n-            if not cert_loc and self.config.get('trust_env'):\n-                cert_loc = os.environ.get('CURL_CA_BUNDLE')\n-\n             if not cert_loc:\n                 cert_loc = DEFAULT_CA_BUNDLE_PATH\n \n\n@@ -8,6 +8,7 @@ This module provides a Session object to manage and persist settings across\n requests (cookies, auth, proxies).\n \n \"\"\"\n+import os\n \n from .compat import cookielib\n from .cookies import cookiejar_from_dict\n@@ -226,6 +227,15 @@ class Session(SessionRedirectMixin):\n             if not auth:\n                 auth = get_netrc_auth(url)\n \n+            # Look for configuration.\n+            if not verify and verify is not False:\n+                verify = os.environ.get('REQUESTS_CA_BUNDLE')\n+\n+            # Curl compatibility.\n+            if not verify and verify is not False:\n+                verify = os.environ.get('CURL_CA_BUNDLE')\n+\n+\n         # Merge all the kwargs.\n         params = merge_kwargs(params, self.params)\n         headers = merge_kwargs(headers, self.headers)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#8b1b706903bb2bafd470ebfe46467daff0d95ff7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): -4/0 | Churn Δ: 2 | Churn Cumulative: 1748 | Contributors (this commit): 23 | Commits (past 90d): 32 | Contributors (cumulative): 23 | DMM Complexity: None\n\nDIFF:\n@@ -76,7 +76,7 @@ class SessionRedirectMixin(object):\n \n             resp.content  # Consume socket so it can be released\n \n-            if i > self.max_redirects:\n+            if i >= self.max_redirects:\n                 raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n \n             # Release the connection back into the pool.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#5152c98223d46c76cb7e88cb833b0087daf83d54", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 298 | Contributors (this commit): 1 | Commits (past 90d): 19 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -13,7 +13,7 @@ import socket\n \n from .models import Response\n from .auth import HTTPProxyAuth\n-from .packages.urllib3.poolmanager import PoolManager\n+from .packages.urllib3.poolmanager import PoolManager, ProxyManager\n from .hooks import dispatch_hook\n from .compat import urlparse\n from .utils import DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers\n@@ -119,7 +119,7 @@ class HTTPAdapter(BaseAdapter):\n         proxy = proxies.get(urlparse(url).scheme)\n \n         if proxy:\n-            conn = self.poolmanager.ProxyManager(self.poolmanager.proxy_from_url(proxy))\n+            conn = ProxyManager(self.poolmanager.proxy_from_url(proxy))\n         else:\n             conn = self.poolmanager.connection_from_url(url)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b30b09e84c5709149e796af5cb07671db823af53", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 459 | Contributors (this commit): 5 | Commits (past 90d): 8 | Contributors (cumulative): 5 | DMM Complexity: None\n\nDIFF:\n@@ -42,8 +42,8 @@ is at <http://python-requests.org>.\n \"\"\"\n \n __title__ = 'requests'\n-__version__ = '1.0.0'\n-__build__ = 0x01000\n+__version__ = '1.0.1'\n+__build__ = 0x01001\n __author__ = 'Kenneth Reitz'\n __license__ = 'Apache 2.0'\n __copyright__ = 'Copyright 2012 Kenneth Reitz'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#5eb3a17b55992163e5958fc30775194d96b8f7ed", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 302 | Contributors (this commit): 1 | Commits (past 90d): 20 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -13,7 +13,7 @@ import socket\n \n from .models import Response\n from .auth import HTTPProxyAuth\n-from .packages.urllib3.poolmanager import PoolManager, ProxyManager\n+from .packages.urllib3.poolmanager import PoolManager, proxy_from_url\n from .hooks import dispatch_hook\n from .compat import urlparse\n from .utils import DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers\n@@ -119,7 +119,7 @@ class HTTPAdapter(BaseAdapter):\n         proxy = proxies.get(urlparse(url).scheme)\n \n         if proxy:\n-            conn = ProxyManager(self.poolmanager.proxy_from_url(proxy))\n+            conn = proxy_from_url(proxy)\n         else:\n             conn = self.poolmanager.connection_from_url(url)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f549efd43d4d9d9b8338b64317c15d4b6739e42e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 463 | Contributors (this commit): 5 | Commits (past 90d): 9 | Contributors (cumulative): 5 | DMM Complexity: None\n\nDIFF:\n@@ -42,8 +42,8 @@ is at <http://python-requests.org>.\n \"\"\"\n \n __title__ = 'requests'\n-__version__ = '1.0.1'\n-__build__ = 0x01001\n+__version__ = '1.0.2'\n+__build__ = 0x01002\n __author__ = 'Kenneth Reitz'\n __license__ = 'Apache 2.0'\n __copyright__ = 'Copyright 2012 Kenneth Reitz'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#916e6fcd64d16252cb884106a0dd225a7a1c2549", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 8 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 8 | Churn Cumulative: 2581 | Contributors (this commit): 24 | Commits (past 90d): 6 | Contributors (cumulative): 24 | DMM Complexity: 1.0\n\nDIFF:\n@@ -3,6 +3,7 @@\n \n \"\"\"Tests for Requests.\"\"\"\n \n+import json\n import os\n import unittest\n \n@@ -243,6 +244,13 @@ class RequestsTestCase(unittest.TestCase):\n         self.assertEqual(r.status_code, 200)\n         self.assertEqual(r.url, httpbin('get?test=foo&test=baz'))\n \n+    def test_different_encodings_dont_break_post(self):\n+        r = requests.post(httpbin('post'),\n+                          data={'stuff': json.dumps({'a': 123})},\n+                          params={'blah': 'asdf1234'},\n+                          files={'file': ('test_requests.py', open(__file__, 'rb'))})\n+        self.assertEqual(r.status_code, 200)\n+\n \n \n if __name__ == '__main__':\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#8c01865d62df56a8cd9f9e776febf456d91d2010", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 8 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 12 | Churn Cumulative: 8350 | Contributors (this commit): 91 | Commits (past 90d): 60 | Contributors (cumulative): 91 | DMM Complexity: 0.0\n\nDIFF:\n@@ -28,7 +28,7 @@ from .utils import (\n     guess_json_utf)\n from .compat import (\n     cookielib, urlparse, urlunparse, urljoin, urlsplit, urlencode, str, bytes,\n-    StringIO, is_py2, chardet, json, builtin_str, urldefrag, basestring)\n+    StringIO, is_py2, is_py3, chardet, json, builtin_str, urldefrag, basestring)\n \n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n CONTENT_CHUNK_SIZE = 10 * 1024\n@@ -222,13 +222,9 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n \n     def prepare_method(self, method):\n         \"\"\"Prepares the given HTTP method.\"\"\"\n-        try:\n-            method = unicode(method)\n-        except NameError:\n-            # We're on Python 3.\n-            method = str(method)\n-\n-        self.method = method.upper()\n+        self.method = method\n+        if self.method is not None:\n+            self.method = self.method.upper()\n \n     def prepare_url(self, url, params):\n         \"\"\"Prepares the given HTTP URL.\"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e355d6ac6cbc8278ec5935986216e32541b80dd1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 8 | Churn Cumulative: 1756 | Contributors (this commit): 24 | Commits (past 90d): 33 | Contributors (cumulative): 24 | DMM Complexity: None\n\nDIFF:\n@@ -71,10 +71,6 @@ class SessionRedirectMixin(object):\n         # ((resp.status_code is codes.see_other))\n         while (('location' in resp.headers and resp.status_code in REDIRECT_STATI)):\n \n-            # Persist cookies.\n-            for cookie in resp.cookies:\n-                self.cookies.set_cookie(cookie)\n-\n             resp.content  # Consume socket so it can be released\n \n             if i >= self.max_redirects:\n@@ -265,6 +261,10 @@ class Session(SessionRedirectMixin):\n         # Send the request.\n         resp = self.send(prep, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\n \n+        # Persist cookies.\n+        for cookie in resp.cookies:\n+            self.cookies.set_cookie(cookie)\n+\n         # Redirect resolving generator.\n         gen = self.resolve_redirects(resp, req, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#68d394952a8d37fae23abcadc54ca76dffacb376", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 19 | Files Changed: 3 | Hunks: 12 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 29 | Churn Cumulative: 10369 | Contributors (this commit): 109 | Commits (past 90d): 96 | Contributors (cumulative): 130 | DMM Complexity: None\n\nDIFF:\n@@ -8,11 +8,9 @@ This module contains the transport adapters that Requests uses to define\n and maintain connections.\n \"\"\"\n \n-import os\n import socket\n \n from .models import Response\n-from .auth import HTTPProxyAuth\n from .packages.urllib3.poolmanager import PoolManager, proxy_from_url\n from .hooks import dispatch_hook\n from .compat import urlparse\n@@ -83,7 +81,6 @@ class HTTPAdapter(BaseAdapter):\n             else:\n                 conn.cert_file = cert\n \n-\n     def build_response(self, req, resp):\n         response = Response()\n \n@@ -125,7 +122,6 @@ class HTTPAdapter(BaseAdapter):\n \n         return conn\n \n-\n     def close(self):\n         \"\"\"Dispose of any internal state.\n \n\n@@ -11,24 +11,21 @@ import collections\n import logging\n \n from io import BytesIO\n-from .hooks import dispatch_hook, default_hooks\n+from .hooks import default_hooks\n from .structures import CaseInsensitiveDict\n from .status_codes import codes\n \n-from .auth import HTTPBasicAuth, HTTPProxyAuth\n-from .cookies import cookiejar_from_dict, extract_cookies_to_jar, get_cookie_header\n+from .auth import HTTPBasicAuth\n+from .cookies import cookiejar_from_dict, get_cookie_header\n from .packages.urllib3.filepost import encode_multipart_formdata\n-from .exceptions import (\n-    ConnectionError, HTTPError, RequestException, Timeout, TooManyRedirects,\n-    URLRequired, SSLError, MissingSchema, InvalidSchema, InvalidURL)\n+from .exceptions import HTTPError, RequestException, MissingSchema, InvalidURL\n from .utils import (\n-    get_encoding_from_headers, stream_untransfer, guess_filename, requote_uri,\n-    stream_decode_response_unicode, get_netrc_auth, get_environ_proxies,\n-    to_key_val_list, DEFAULT_CA_BUNDLE_PATH, parse_header_links, iter_slices,\n-    guess_json_utf)\n+    stream_untransfer, guess_filename, requote_uri,\n+    stream_decode_response_unicode, to_key_val_list, parse_header_links,\n+    iter_slices, guess_json_utf)\n from .compat import (\n-    cookielib, urlparse, urlunparse, urljoin, urlsplit, urlencode, str, bytes,\n-    StringIO, is_py2, is_py3, chardet, json, builtin_str, urldefrag, basestring)\n+    cookielib, urlparse, urlunparse, urlsplit, urlencode, str, bytes, StringIO,\n+    is_py2, chardet, json, builtin_str, basestring)\n \n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n CONTENT_CHUNK_SIZE = 10 * 1024\n@@ -385,7 +382,6 @@ class Response(object):\n         #: up here. The list is sorted from the oldest to the most recent request.\n         self.history = []\n \n-\n         self.reason = None\n \n         #: A CookieJar of Cookies the server sent back.\n\n@@ -20,7 +20,7 @@ from netrc import netrc, NetrcParseError\n \n from . import __version__\n from .compat import parse_http_list as _parse_list_header\n-from .compat import quote, quote_plus, urlparse, basestring, bytes, str, OrderedDict\n+from .compat import quote, urlparse, bytes, str, OrderedDict\n from .cookies import RequestsCookieJar, cookiejar_from_dict\n \n _hush_pyflakes = (RequestsCookieJar,)\n@@ -254,7 +254,6 @@ def unquote_header_value(value, is_filename=False):\n     return value\n \n \n-\n def dict_from_cookiejar(cj):\n     \"\"\"Returns a key/value dictionary from a CookieJar.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c60b72e2d0c505b016741c419894e1feaeb96d9d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 467 | Contributors (this commit): 5 | Commits (past 90d): 10 | Contributors (cumulative): 5 | DMM Complexity: None\n\nDIFF:\n@@ -42,8 +42,8 @@ is at <http://python-requests.org>.\n \"\"\"\n \n __title__ = 'requests'\n-__version__ = '1.0.2'\n-__build__ = 0x01002\n+__version__ = '1.0.3'\n+__build__ = 0x01003\n __author__ = 'Kenneth Reitz'\n __license__ = 'Apache 2.0'\n __copyright__ = 'Copyright 2012 Kenneth Reitz'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#6acce57271efce8c17cea2f1eece943f429e3879", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 1760 | Contributors (this commit): 24 | Commits (past 90d): 34 | Contributors (cumulative): 24 | DMM Complexity: None\n\nDIFF:\n@@ -379,7 +379,7 @@ class Session(SessionRedirectMixin):\n             setattr(self, attr, value)\n \n \n-def session(**kwargs):\n+def session():\n     \"\"\"Returns a :class:`Session` for context-management.\"\"\"\n \n-    return Session(**kwargs)\n+    return Session()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#14da5cf180c4776f6a4aeeb8a6979ee885fc8c82", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 2 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 7 | Churn Cumulative: 1767 | Contributors (this commit): 24 | Commits (past 90d): 35 | Contributors (cumulative): 24 | DMM Complexity: 1.0\n\nDIFF:\n@@ -365,7 +365,12 @@ class Session(SessionRedirectMixin):\n                 return adapter\n \n         # Nothing matches :-/\n-        raise InvalidSchema('No connection adapters were found for \\'%s\\'' % url)\n+        raise InvalidSchema(\"No connection adapters were found for '%s'\" % url)\n+\n+    def close(self):\n+        \"\"\"Closes all adapters and as such the session\"\"\"\n+        for _, v in self.adapters.items():\n+            v.close()\n \n     def mount(self, prefix, adapter):\n         \"\"\"Registers a connection adapter to a prefix.\"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#7e594eb1219616b3f18950e965f53419ab656680", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 8374 | Contributors (this commit): 92 | Commits (past 90d): 61 | Contributors (cumulative): 92 | DMM Complexity: None\n\nDIFF:\n@@ -194,8 +194,8 @@ class Request(RequestHooksMixin):\n         p.prepare_url(self.url, self.params)\n         p.prepare_headers(self.headers)\n         p.prepare_cookies(self.cookies)\n-        p.prepare_auth(self.auth)\n         p.prepare_body(self.data, self.files)\n+        p.prepare_auth(self.auth)\n \n         return p\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
