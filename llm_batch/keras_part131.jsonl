{"custom_id": "keras#0272587c2903d6a0c9bb0b1466db2a01aee36a96", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 15 | Files Changed: 1 | Hunks: 11 | Methods Changed: 5 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 30 | Churn Cumulative: 10660 | Contributors (this commit): 55 | Commits (past 90d): 6 | Contributors (cumulative): 55 | DMM Complexity: None\n\nDIFF:\n@@ -170,7 +170,7 @@ class SpatialDropout2D(Dropout):\n         elif self.dim_ordering == 'tf':\n             noise_shape = (input_shape[0], 1, 1, input_shape[3])\n         else:\n-            raise Exception('Invalid dim_ordering: ' + self.dim_ordering)\n+            raise ValueError('Invalid dim_ordering:', self.dim_ordering)\n         return noise_shape\n \n \n@@ -218,7 +218,7 @@ class SpatialDropout3D(Dropout):\n         elif self.dim_ordering == 'tf':\n             noise_shape = (input_shape[0], 1, 1, 1, input_shape[4])\n         else:\n-            raise Exception('Invalid dim_ordering: ' + self.dim_ordering)\n+            raise ValueError('Invalid dim_ordering:', self.dim_ordering)\n         return noise_shape\n \n \n@@ -428,7 +428,7 @@ class Flatten(Layer):\n \n     def get_output_shape_for(self, input_shape):\n         if not all(input_shape[1:]):\n-            raise Exception('The shape of the input to \"Flatten\" '\n+            raise ValueError('The shape of the input to \"Flatten\" '\n                              'is not fully defined '\n                              '(got ' + str(input_shape[1:]) + '. '\n                              'Make sure to pass a complete \"input_shape\" '\n@@ -542,11 +542,11 @@ class Lambda(Layer):\n \n         if output_shape is None:\n             self._output_shape = None\n-        elif type(output_shape) in {tuple, list}:\n+        elif isinstance(output_shape, (tuple, list)):\n             self._output_shape = tuple(output_shape)\n         else:\n-            if not hasattr(output_shape, '__call__'):\n-                raise Exception('In Lambda, `output_shape` '\n+            if not callable(output_shape):\n+                raise TypeError('In Lambda, `output_shape` '\n                                 'must be a list, a tuple, or a function.')\n             self._output_shape = output_shape\n         super(Lambda, self).__init__(**kwargs)\n@@ -554,14 +554,14 @@ class Lambda(Layer):\n     def get_output_shape_for(self, input_shape):\n         if self._output_shape is None:\n             # if TensorFlow, we can infer the output shape directly:\n-            if K._BACKEND == 'tensorflow':\n-                if type(input_shape) is list:\n+            if K.backend() == 'tensorflow':\n+                if isinstance(input_shape, list):\n                     xs = [K.placeholder(shape=shape) for shape in input_shape]\n                     x = self.call(xs)\n                 else:\n                     x = K.placeholder(shape=input_shape)\n                     x = self.call(x)\n-                if type(x) is list:\n+                if isinstance(x, list):\n                     return [K.int_shape(x_elem) for x_elem in x]\n                 else:\n                     return K.int_shape(x)\n@@ -572,16 +572,16 @@ class Lambda(Layer):\n                           'If the expected output shape is different, specify it via the `output_shape` argument.'\n                           .format(self.name, input_shape))\n             return input_shape\n-        elif type(self._output_shape) in {tuple, list}:\n-            if type(input_shape) is list:\n+        elif isinstance(self._output_shape, (tuple, list)):\n+            if isinstance(input_shape, list):\n                 nb_samples = input_shape[0][0]\n             else:\n                 nb_samples = input_shape[0] if input_shape else None\n             return (nb_samples,) + tuple(self._output_shape)\n         else:\n             shape = self._output_shape(input_shape)\n-            if type(shape) not in {list, tuple}:\n-                raise Exception('output_shape function must return a tuple')\n+            if not isinstance(shape, (list, tuple)):\n+                raise ValueError('output_shape function must return a tuple')\n             return tuple(shape)\n \n     def call(self, x, mask=None):\n@@ -625,7 +625,7 @@ class Lambda(Layer):\n         elif function_type == 'lambda':\n             function = func_load(config['function'], globs=globals())\n         else:\n-            raise Exception('Unknown function type: ' + function_type)\n+            raise TypeError('Unknown function type:', function_type)\n \n         output_shape_type = config.pop('output_shape_type')\n         if output_shape_type == 'function':\n@@ -1221,7 +1221,7 @@ class TimeDistributedDense(Layer):\n             if hasattr(K, 'int_shape'):\n                 input_length = K.int_shape(x)[1]\n                 if not input_length:\n-                    raise Exception(\n+                    raise ValueError(\n                         'Layer ' + self.name +\n                         ' requires to know the length of its input, '\n                         'but it could not be inferred automatically. '\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#577735597212a111028c2c39db2f621823346ab5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 43 | Lines Deleted: 41 | Files Changed: 1 | Hunks: 38 | Methods Changed: 16 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 84 | Churn Cumulative: 3053 | Contributors (this commit): 46 | Commits (past 90d): 18 | Contributors (cumulative): 46 | DMM Complexity: 0.75\n\nDIFF:\n@@ -71,7 +71,7 @@ def placeholder(shape=None, ndim=None, dtype=_FLOATX, sparse=False, name=None):\n     '''Instantiate an input data placeholder variable.\n     '''\n     if shape is None and ndim is None:\n-        raise Exception('Specify either a shape or ndim value.')\n+        raise ValueError('Specify either a shape or ndim value.')\n     if shape is not None:\n         ndim = len(shape)\n     else:\n@@ -231,7 +231,7 @@ def batch_dot(x, y, axes=None):\n \n         output_shape = (100, 30)\n     '''\n-    if type(axes) == int:\n+    if isinstance(axes, int):\n         axes = (axes, axes)\n     if axes is None:\n         # behaves like tf.batch_matmul as default\n@@ -521,7 +521,7 @@ def concatenate(tensors, axis=-1):\n         elif axis == 1:\n             return th_sparse_module.basic.hstack(tensors, format='csr')\n         else:\n-            raise Exception('Invalid concat axis for sparse matrix: ' + axis)\n+            raise ValueError('Invalid concat axis for sparse matrix:', axis)\n     else:\n         return T.concatenate([to_dense(x) for x in tensors], axis=axis)\n \n@@ -565,7 +565,7 @@ def resize_images(X, height_factor, width_factor, dim_ordering):\n         output = repeat_elements(output, width_factor, axis=2)\n         return output\n     else:\n-        raise Exception('Invalid dim_ordering: ' + dim_ordering)\n+        raise ValueError('Invalid dim_ordering:', dim_ordering)\n \n \n def resize_volumes(X, depth_factor, height_factor, width_factor, dim_ordering):\n@@ -586,7 +586,7 @@ def resize_volumes(X, depth_factor, height_factor, width_factor, dim_ordering):\n         output = repeat_elements(output, width_factor, axis=3)\n         return output\n     else:\n-        raise Exception('Invalid dim_ordering: ' + dim_ordering)\n+        raise ValueError('Invalid dim_ordering:', dim_ordering)\n \n \n def repeat(x, n):\n@@ -712,7 +712,7 @@ def spatial_2d_padding(x, padding=(1, 1), dim_ordering='default'):\n                    slice(padding[1], input_shape[2] + padding[1]),\n                    slice(None))\n     else:\n-        raise Exception('Invalid dim_ordering: ' + dim_ordering)\n+        raise ValueError('Invalid dim_ordering:', dim_ordering)\n     return T.set_subtensor(output[indices], x)\n \n \n@@ -752,7 +752,7 @@ def asymmetric_spatial_2d_padding(x, top_pad=1, bottom_pad=1,\n                    slice(left_pad, input_shape[2] + left_pad),\n                    slice(None))\n     else:\n-        raise Exception('Invalid dim_ordering: ' + dim_ordering)\n+        raise ValueError('Invalid dim_ordering:', dim_ordering)\n     return T.set_subtensor(output[indices], x)\n \n \n@@ -792,7 +792,7 @@ def spatial_3d_padding(x, padding=(1, 1, 1), dim_ordering='default'):\n                    slice(padding[2], input_shape[3] + padding[2]),\n                    slice(None))\n     else:\n-        raise Exception('Invalid dim_ordering: ' + dim_ordering)\n+        raise ValueError('Invalid dim_ordering:', dim_ordering)\n     return T.set_subtensor(output[indices], x)\n \n \n@@ -815,7 +815,7 @@ def one_hot(indices, nb_classes):\n def reverse(x, axes):\n     '''Reverse a tensor along the the specified axes\n     '''\n-    if type(axes) == int:\n+    if isinstance(axes, int):\n         axes = [axes]\n     slices = [slice(None, None, -1) if i in axes else slice(None, None, None) for i in range(x.ndim)]\n     return x[slices]\n@@ -826,8 +826,8 @@ def reverse(x, axes):\n \n def get_value(x):\n     if not hasattr(x, 'get_value'):\n-        raise Exception(\"'get_value() can only be called on a variable. \" +\n-                        \"If you have an expression instead, use eval().\")\n+        raise TypeError('get_value() can only be called on a variable. '\n+                        'If you have an expression instead, use eval().')\n     return x.get_value()\n \n \n@@ -870,7 +870,7 @@ class Function(object):\n                                         **kwargs)\n \n     def __call__(self, inputs):\n-        assert type(inputs) in {list, tuple}\n+        assert isinstance(inputs, (list, tuple))\n         return self.function(*inputs)\n \n \n@@ -879,7 +879,7 @@ def function(inputs, outputs, updates=[], **kwargs):\n         function_args = inspect.getargspec(theano.function)[0]\n         for key in kwargs.keys():\n             if key not in function_args:\n-                msg = \"Invalid argument '%s' passed to K.function\" % key\n+                msg = 'Invalid argument \"%s\" passed to K.function' % key\n                 raise ValueError(msg)\n     return Function(inputs, outputs, updates=updates, **kwargs)\n \n@@ -940,7 +940,8 @@ def rnn(step_function, inputs, initial_states,\n \n     if unroll:\n         if input_length is None:\n-            raise Exception('When specifying `unroll=True`, an `input_length` '\n+            raise ValueError('When specifying `unroll=True`, '\n+                             'an `input_length` '\n                              'must be provided to `rnn`.')\n \n     axes = [1, 0] + list(range(2, ndim))\n@@ -1007,7 +1008,7 @@ def rnn(step_function, inputs, initial_states,\n                 go_backwards=go_backwards)\n \n             # deal with Theano API inconsistency\n-            if type(results) is list:\n+            if isinstance(results, list):\n                 outputs = results[0]\n                 states = results[1:]\n             else:\n@@ -1044,7 +1045,7 @@ def rnn(step_function, inputs, initial_states,\n                 go_backwards=go_backwards)\n \n             # deal with Theano API inconsistency\n-            if type(results) is list:\n+            if isinstance(results, list):\n                 outputs = results[0]\n                 states = results[1:]\n             else:\n@@ -1089,10 +1090,13 @@ def in_test_phase(x, alt):\n # NN OPERATIONS\n \n def _assert_has_capability(module, func):\n-    assert hasattr(module, func), ('It looks like like your version of '\n+    if not hasattr(module, func):\n+        raise EnvironmentError(\n+            'It looks like like your version of '\n             'Theano is out of date. '\n             'Install the latest version with:\\n'\n-                                   'pip install git+git://github.com/Theano/Theano.git --upgrade --no-deps')\n+            'pip install git+git://github.com/Theano/Theano.git '\n+            '--upgrade --no-deps')\n \n \n def elu(x, alpha=1.0):\n@@ -1177,7 +1181,7 @@ def dropout(x, level, noise_shape=None, seed=None):\n         seed: random seed to ensure determinism.\n     '''\n     if level < 0. or level >= 1:\n-        raise Exception('Dropout level must be in interval [0, 1[.')\n+        raise ValueError('Dropout level must be in interval [0, 1[.')\n     if seed is None:\n         seed = np.random.randint(1, 10e6)\n \n@@ -1267,7 +1271,7 @@ def _preprocess_border_mode(border_mode):\n     elif border_mode == 'full':\n         th_border_mode = 'full'\n     else:\n-        raise Exception('Border mode not supported: ' + str(border_mode))\n+        raise ValueError('Border mode not supported:', str(border_mode))\n     return th_border_mode\n \n \n@@ -1387,7 +1391,7 @@ def conv2d(x, kernel, strides=(1, 1), border_mode='valid',\n     if dim_ordering == 'default':\n         dim_ordering = image_dim_ordering()\n     if dim_ordering not in {'th', 'tf'}:\n-        raise Exception('Unknown dim_ordering ' + str(dim_ordering))\n+        raise ValueError('Unknown dim_ordering ', dim_ordering)\n \n     x = _preprocess_conv2d_input(x, dim_ordering)\n     kernel = _preprocess_conv2d_kernel(kernel, dim_ordering)\n@@ -1435,7 +1439,7 @@ def deconv2d(x, kernel, output_shape, strides=(1, 1),\n     if dim_ordering == 'default':\n         dim_ordering = image_dim_ordering()\n     if dim_ordering not in {'th', 'tf'}:\n-        raise Exception('Unknown dim_ordering ' + str(dim_ordering))\n+        raise ValueError('Unknown dim_ordering ' + dim_ordering)\n \n     x = _preprocess_conv2d_input(x, dim_ordering)\n     kernel = _preprocess_conv2d_kernel(kernel, dim_ordering)\n@@ -1486,12 +1490,12 @@ def conv3d(x, kernel, strides=(1, 1, 1),\n     if dim_ordering == 'default':\n         dim_ordering = image_dim_ordering()\n     if dim_ordering not in {'th', 'tf'}:\n-        raise Exception('Unknown dim_ordering ' + str(dim_ordering))\n+        raise ValueError('Unknown dim_ordering:', dim_ordering)\n \n     # TODO: remove this if statement when Theano without AbstractConv3d is deprecated\n     if not hasattr(T.nnet, 'conv3d'):\n         if filter_dilation != (1, 1, 1):\n-            raise Exception('conv3d with filter dilation requires Theano '\n+            raise ValueError('conv3d with filter dilation requires Theano '\n                              '0.9.0dev3 or newer.')\n \n         return _old_theano_conv3d(x, kernel, strides, border_mode,\n@@ -1527,10 +1531,9 @@ def _old_theano_conv3d(x, kernel, strides=(1, 1, 1),\n     if dim_ordering == 'default':\n         dim_ordering = image_dim_ordering()\n     if dim_ordering not in {'th', 'tf'}:\n-        raise Exception('Unknown dim_ordering ' + str(dim_ordering))\n-\n+        raise ValueError('Unknown dim_ordering:', dim_ordering)\n     if border_mode not in {'same', 'valid'}:\n-        raise Exception('Invalid border mode: ' + str(border_mode))\n+        raise ValueError('Invalid border mode:', border_mode)\n \n     if dim_ordering == 'tf':\n         # TF uses the last dimension as channel dimension,\n@@ -1586,7 +1589,7 @@ def pool2d(x, pool_size, strides=(1, 1), border_mode='valid',\n     if dim_ordering == 'default':\n         dim_ordering = image_dim_ordering()\n     if dim_ordering not in {'th', 'tf'}:\n-        raise Exception('Unknown dim_ordering ' + str(dim_ordering))\n+        raise ValueError('Unknown dim_ordering:', dim_ordering)\n \n     assert pool_size[0] >= 1 and pool_size[1] >= 1\n \n@@ -1597,10 +1600,10 @@ def pool2d(x, pool_size, strides=(1, 1), border_mode='valid',\n     elif border_mode == 'valid':\n         padding = (0, 0)\n     else:\n-        raise Exception('Invalid border mode: ' + str(border_mode))\n+        raise ValueError('Invalid border mode:', border_mode)\n \n     if dim_ordering not in {'th', 'tf'}:\n-        raise Exception('Unknown dim_ordering ' + str(dim_ordering))\n+        raise ValueError('Unknown dim_ordering:', dim_ordering)\n \n     if dim_ordering == 'tf':\n         x = x.dimshuffle((0, 3, 1, 2))\n@@ -1634,7 +1637,7 @@ def pool2d(x, pool_size, strides=(1, 1), border_mode='valid',\n                                     padding=padding,\n                                     mode='average_exc_pad')\n     else:\n-        raise Exception('Invalid pooling mode: ' + str(pool_mode))\n+        raise ValueError('Invalid pooling mode:', pool_mode)\n \n     if border_mode == 'same':\n         expected_width = (x.shape[2] + strides[0] - 1) // strides[0]\n@@ -1654,7 +1657,7 @@ def pool3d(x, pool_size, strides=(1, 1, 1), border_mode='valid',\n     if dim_ordering == 'default':\n         dim_ordering = image_dim_ordering()\n     if dim_ordering not in {'th', 'tf'}:\n-        raise Exception('Unknown dim_ordering ' + str(dim_ordering))\n+        raise ValueError('Unknown dim_ordering:', dim_ordering)\n \n     # TODO: remove this if statement when Theano without pool_3d is deprecated\n     #       (pool_3d was introduced after 0.9.0dev3)\n@@ -1670,10 +1673,9 @@ def pool3d(x, pool_size, strides=(1, 1, 1), border_mode='valid',\n     elif border_mode == 'valid':\n         padding = (0, 0, 0)\n     else:\n-        raise Exception('Invalid border mode: ' + str(border_mode))\n-\n+        raise ValueError('Invalid border mode:', border_mode)\n     if dim_ordering not in {'th', 'tf'}:\n-        raise Exception('Unknown dim_ordering ' + str(dim_ordering))\n+        raise ValueError('Unknown dim_ordering:', dim_ordering)\n \n     if dim_ordering == 'tf':\n         x = x.dimshuffle((0, 4, 1, 2, 3))\n@@ -1707,7 +1709,7 @@ def pool3d(x, pool_size, strides=(1, 1, 1), border_mode='valid',\n                                     padding=padding,\n                                     mode='average_exc_pad')\n     else:\n-        raise Exception('Invalid pooling mode: ' + str(pool_mode))\n+        raise ValueError('Invalid pooling mode:', pool_mode)\n \n     if border_mode == 'same':\n         expected_width = (x.shape[2] + strides[0] - 1) // strides[0]\n@@ -1731,19 +1733,19 @@ def _old_theano_pool3d(x, pool_size, strides=(1, 1, 1), border_mode='valid',\n     if dim_ordering == 'default':\n         dim_ordering = image_dim_ordering()\n     if dim_ordering not in {'th', 'tf'}:\n-        raise Exception('Unknown dim_ordering ' + str(dim_ordering))\n+        raise ValueError('Unknown dim_ordering:', dim_ordering)\n \n     if border_mode == 'same':\n         # TODO: add implementation for border_mode=\"same\"\n-        raise Exception('border_mode=\"same\" not supported with Theano.')\n+        raise ValueError('border_mode=\"same\" not supported with Theano.')\n     elif border_mode == 'valid':\n         ignore_border = True\n         padding = (0, 0)\n     else:\n-        raise Exception('Invalid border mode: ' + str(border_mode))\n+        raise ValueError('Invalid border mode:', border_mode)\n \n     if dim_ordering not in {'th', 'tf'}:\n-        raise Exception('Unknown dim_ordering ' + str(dim_ordering))\n+        raise ValueError('Unknown dim_ordering:', dim_ordering)\n \n     if dim_ordering == 'tf':\n         x = x.dimshuffle((0, 4, 1, 2, 3))\n@@ -1782,7 +1784,7 @@ def _old_theano_pool3d(x, pool_size, strides=(1, 1, 1), border_mode='valid',\n                                 padding=padding,\n                                 mode='average_exc_pad')\n     else:\n-        raise Exception('Invalid pooling mode: ' + str(pool_mode))\n+        raise ValueError('Invalid pooling mode:', pool_mode)\n \n     if dim_ordering == 'tf':\n         pool_out = pool_out.dimshuffle((0, 2, 3, 4, 1))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#74329d0c1d26301be82955fbf8e524cb6508c953", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 31 | Lines Deleted: 17 | Files Changed: 1 | Hunks: 18 | Methods Changed: 12 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 48 | Churn Cumulative: 3527 | Contributors (this commit): 46 | Commits (past 90d): 26 | Contributors (cumulative): 46 | DMM Complexity: 0.0\n\nDIFF:\n@@ -176,7 +176,9 @@ def variable(value, dtype=_FLOATX, name=None):\n         indices = np.concatenate((np.expand_dims(sparse_coo.row, 1),\n                                   np.expand_dims(sparse_coo.col, 1)), 1)\n         # SparseTensor doesn't need initialization\n-        v = tf.SparseTensor(indices=indices, values=sparse_coo.data, shape=sparse_coo.shape)\n+        v = tf.SparseTensor(indices=indices,\n+                            values=sparse_coo.data,\n+                            shape=sparse_coo.shape)\n         v._dims = len(sparse_coo.shape)\n         return v\n     v = tf.Variable(value, dtype=_convert_string_dtype(dtype), name=name)\n@@ -201,6 +203,7 @@ def _initialize_variables():\n         else:\n             sess.run(tf.initialize_variables(uninitialized_variables))\n \n+\n def placeholder(shape=None, ndim=None, dtype=_FLOATX, sparse=False, name=None):\n     '''Instantiates a placeholder.\n \n@@ -383,7 +386,8 @@ def dot(x, y):\n         y_permute_dim = [y_permute_dim.pop(-2)] + y_permute_dim\n         xt = tf.reshape(x, [-1, x_shape[-1]])\n         yt = tf.reshape(tf.transpose(y, perm=y_permute_dim), [y_shape[-2], -1])\n-        return tf.reshape(tf.matmul(xt, yt), x_shape[:-1] + y_shape[:-2] + y_shape[-1:])\n+        return tf.reshape(tf.matmul(xt, yt),\n+                          x_shape[:-1] + y_shape[:-2] + y_shape[-1:])\n     if is_sparse(x):\n         out = tf.sparse_tensor_dense_matmul(x, y)\n     else:\n@@ -429,7 +433,7 @@ def batch_dot(x, y, axes=None):\n \n         output_shape = (100, 30)\n     '''\n-    if type(axes) == int:\n+    if isinstance(axes, int):\n         axes = (axes, axes)\n     if axes is not None:\n         adj_x = None if axes[0] == ndim(x) - 1 else True\n@@ -466,9 +470,9 @@ def gather(reference, indices):\n # ELEMENT-WISE OPERATIONS\n \n def _normalize_axis(axis, ndim):\n-    if type(axis) is tuple:\n+    if isinstance(axis, tuple):\n         axis = list(axis)\n-    if type(axis) is list:\n+    if isinstance(axis, list):\n         for i, a in enumerate(axis):\n             if a is not None and a < 0:\n                 axis[i] = a % ndim\n@@ -799,7 +803,7 @@ def resize_images(X, height_factor, width_factor, dim_ordering):\n                     original_shape[2] * width_factor if original_shape[2] is not None else None, None))\n         return X\n     else:\n-        raise Exception('Invalid dim_ordering: ' + dim_ordering)\n+        raise ValueError('Invalid dim_ordering:', dim_ordering)\n \n \n def resize_volumes(X, depth_factor, height_factor, width_factor, dim_ordering):\n@@ -820,7 +824,7 @@ def resize_volumes(X, depth_factor, height_factor, width_factor, dim_ordering):\n         output = repeat_elements(output, width_factor, axis=3)\n         return output\n     else:\n-        raise Exception('Invalid dim_ordering: ' + dim_ordering)\n+        raise ValueError('Invalid dim_ordering:', dim_ordering)\n \n \n def repeat_elements(x, rep, axis):\n@@ -869,7 +873,7 @@ def arange(start, stop=None, step=1, dtype='int32'):\n \n \n def tile(x, n):\n-    if not hasattr(n, 'shape') and not hasattr(n, '__len__') and not hasattr(n, '_shape'):\n+    if isinstance(n, int):\n         n = [n]\n     return tf.tile(x, n)\n \n@@ -1004,7 +1008,7 @@ def one_hot(indices, nb_classes):\n def reverse(x, axes):\n     '''Reverse a tensor along the the specified axes\n     '''\n-    if type(axes) == int:\n+    if isinstance(axes, int):\n         axes = [axes]\n     dims = [True if i in axes else False for i in range(len(x.get_shape()._dims))]\n     return tf.reverse(x, dims)\n@@ -1064,7 +1068,8 @@ def batch_set_value(tuples):\n                 assign_placeholder = x._assign_placeholder\n                 assign_op = x._assign_op\n             else:\n-                assign_placeholder = tf.placeholder(tf_dtype, shape=value.shape)\n+                assign_placeholder = tf.placeholder(tf_dtype,\n+                                                    shape=value.shape)\n                 assign_op = x.assign(assign_placeholder)\n                 x._assign_placeholder = assign_placeholder\n                 x._assign_op = assign_op\n@@ -1089,9 +1094,15 @@ def print_tensor(x, message=''):\n class Function(object):\n \n     def __init__(self, inputs, outputs, updates=[]):\n-        assert type(inputs) in {list, tuple}, 'Input to a TensorFlow backend function should be a list or tuple.'\n-        assert type(outputs) in {list, tuple}, 'Output to a TensorFlow backend function should be a list or tuple.'\n-        assert type(updates) in {list, tuple}, 'Updates in a TensorFlow backend function should be a list or tuple.'\n+        if not isinstance(inputs, (list, tuple)):\n+            raise TypeError('`inputs` to a TensorFlow backend function '\n+                            'should be a list or tuple.')\n+        if not isinstance(outputs, (list, tuple)):\n+            raise TypeError('`outputs` of a TensorFlow backend function '\n+                            'should be a list or tuple.')\n+        if not isinstance(updates, (list, tuple)):\n+            raise TypeError('`updates` in a TensorFlow backend function '\n+                            'should be a list or tuple.')\n         self.inputs = list(inputs)\n         self.outputs = list(outputs)\n         with tf.control_dependencies(self.outputs):\n@@ -1116,7 +1127,8 @@ class Function(object):\n                 value = (indices, sparse_coo.data, sparse_coo.shape)\n             feed_dict[tensor] = value\n         session = get_session()\n-        updated = session.run(self.outputs + [self.updates_op], feed_dict=feed_dict)\n+        updated = session.run(self.outputs + [self.updates_op],\n+                              feed_dict=feed_dict)\n         return updated[:len(self.outputs)]\n \n \n@@ -1652,7 +1664,7 @@ def _preprocess_border_mode(border_mode):\n     elif border_mode == 'valid':\n         padding = 'VALID'\n     else:\n-        raise Exception('Invalid border mode: ' + str(border_mode))\n+        raise ValueError('Invalid border mode:', border_mode)\n     return padding\n \n \n@@ -1854,7 +1866,7 @@ def pool2d(x, pool_size, strides=(1, 1),\n     elif pool_mode == 'avg':\n         x = tf.nn.avg_pool(x, pool_size, strides, padding=padding)\n     else:\n-        raise Exception('Invalid pooling mode: ' + str(pool_mode))\n+        raise ValueError('Invalid pooling mode:', pool_mode)\n \n     return _postprocess_conv2d_output(x, dim_ordering)\n \n@@ -1886,7 +1898,7 @@ def pool3d(x, pool_size, strides=(1, 1, 1), border_mode='valid',\n     elif pool_mode == 'avg':\n         x = tf.nn.avg_pool3d(x, pool_size, strides, padding=padding)\n     else:\n-        raise Exception('Invalid pooling mode: ' + str(pool_mode))\n+        raise ValueError('Invalid pooling mode:', pool_mode)\n \n     return _postprocess_conv3d_output(x, dim_ordering)\n \n@@ -1914,12 +1926,14 @@ def random_binomial(shape, p=0.0, dtype=_FLOATX, seed=None):\n                      tf.ones(shape, dtype=dtype),\n                      tf.zeros(shape, dtype=dtype))\n \n+\n # CTC\n # tensorflow has a native implemenation, but it uses sparse tensors\n # and therefore requires a wrapper for Keras. The functions below convert\n # dense to sparse tensors and also wraps up the beam search code that is\n # in tensorflow's CTC implementation\n \n+\n def ctc_label_dense_to_sparse(labels, label_lengths):\n     # undocumented feature soon to be made public\n     from tensorflow.python.ops import functional_ops\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#a0a0308061bcedd2913a8b755297f12958a8f4bd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 999 | Contributors (this commit): 10 | Commits (past 90d): 2 | Contributors (cumulative): 10 | DMM Complexity: None\n\nDIFF:\n@@ -242,12 +242,12 @@ class KerasClassifier(BaseWrapper):\n             y = to_categorical(y)\n \n         outputs = self.model.evaluate(X, y, **kwargs)\n-        if type(outputs) is not list:\n+        if not isinstance(outputs, list):\n             outputs = [outputs]\n         for name, output in zip(self.model.metrics_names, outputs):\n             if name == 'acc':\n                 return output\n-        raise Exception('The model is not configured to compute accuracy. '\n+        raise ValueError('The model is not configured to compute accuracy. '\n                          'You should pass `metrics=[\"accuracy\"]` to '\n                          'the `model.compile()` method.')\n \n@@ -290,6 +290,6 @@ class KerasRegressor(BaseWrapper):\n         '''\n         kwargs = self.filter_sk_params(Sequential.evaluate, kwargs)\n         loss = self.model.evaluate(X, y, **kwargs)\n-        if type(loss) is list:\n+        if isinstance(loss, list):\n             return loss[0]\n         return loss\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#edae1785327dd7a418ac06c2fe85a8c1f6ea05b7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 28 | Lines Deleted: 34 | Files Changed: 2 | Hunks: 15 | Methods Changed: 6 | Complexity Δ (Sum/Max): -5/0 | Churn Δ: 62 | Churn Cumulative: 955 | Contributors (this commit): 22 | Commits (past 90d): 7 | Contributors (cumulative): 27 | DMM Complexity: 0.0\n\nDIFF:\n@@ -12,7 +12,7 @@ def get_from_module(identifier, module_params, module_name,\n     if isinstance(identifier, six.string_types):\n         res = module_params.get(identifier)\n         if not res:\n-            raise Exception('Invalid ' + str(module_name) + ': ' +\n+            raise ValueError('Invalid ' + str(module_name) + ': ' +\n                              str(identifier))\n         if instantiate and not kwargs:\n             return res()\n@@ -20,13 +20,13 @@ def get_from_module(identifier, module_params, module_name,\n             return res(**kwargs)\n         else:\n             return res\n-    elif type(identifier) is dict:\n+    elif isinstance(identifier, dict):\n         name = identifier.pop('name')\n         res = module_params.get(name)\n         if res:\n             return res(**identifier)\n         else:\n-            raise Exception('Invalid ' + str(module_name) + ': ' +\n+            raise ValueError('Invalid ' + str(module_name) + ': ' +\n                              str(identifier))\n     return identifier\n \n@@ -51,32 +51,22 @@ def func_load(code, defaults=None, closure=None, globs=None):\n     if isinstance(code, (tuple, list)):  # unpack previous dump\n         code, defaults, closure = code\n     code = marshal.loads(code.encode('raw_unicode_escape'))\n-    if closure is not None:\n-        closure = func_reconstruct_closure(closure)\n     if globs is None:\n         globs = globals()\n-    return python_types.FunctionType(code, globs, name=code.co_name, argdefs=defaults, closure=closure)\n-\n-\n-def func_reconstruct_closure(values):\n-    '''Deserialization helper that reconstructs a closure.'''\n-    nums = range(len(values))\n-    src = [\"def func(arg):\"]\n-    src += [\"  _%d = arg[%d]\" % (n, n) for n in nums]\n-    src += [\"  return lambda:(%s)\" % ','.join([\"_%d\" % n for n in nums]), \"\"]\n-    src = '\\n'.join(src)\n-    try:\n-        exec(src, globals())\n-    except:\n-        raise SyntaxError(src)\n-    return func(values).__closure__\n+    return python_types.FunctionType(code, globs,\n+                                     name=code.co_name,\n+                                     argdefs=defaults,\n+                                     closure=closure)\n \n \n class Progbar(object):\n+\n     def __init__(self, target, width=30, verbose=1, interval=0.01):\n-        '''\n-            @param target: total number of steps expected\n-            @param interval: minimum visual progress update interval (in seconds)\n+        '''Dislays a progress bar.\n+\n+        # Arguments:\n+            target: Total number of steps expected.\n+            interval: Minimum visual progress update interval (in seconds).\n         '''\n         self.width = width\n         self.target = target\n@@ -90,15 +80,18 @@ class Progbar(object):\n         self.verbose = verbose\n \n     def update(self, current, values=[], force=False):\n-        '''\n-            @param current: index of current step\n-            @param values: list of tuples (name, value_for_last_step).\n+        '''Updates the progress bar.\n+\n+        # Arguments\n+            current: Index of current step.\n+            values: List of tuples (name, value_for_last_step).\n                 The progress bar will display averages for these values.\n-            @param force: force visual progress update\n+            force: Whether to force visual progress update.\n         '''\n         for k, v in values:\n             if k not in self.sum_values:\n-                self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n+                self.sum_values[k] = [v * (current - self.seen_so_far),\n+                                      current - self.seen_so_far]\n                 self.unique_values.append(k)\n             else:\n                 self.sum_values[k][0] += v * (current - self.seen_so_far)\n@@ -111,8 +104,8 @@ class Progbar(object):\n                 return\n \n             prev_total_width = self.total_width\n-            sys.stdout.write(\"\\b\" * prev_total_width)\n-            sys.stdout.write(\"\\r\")\n+            sys.stdout.write('\\b' * prev_total_width)\n+            sys.stdout.write('\\r')\n \n             numdigits = int(np.floor(np.log10(self.target))) + 1\n             barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n@@ -142,7 +135,7 @@ class Progbar(object):\n                 info += ' - %ds' % (now - self.start)\n             for k in self.unique_values:\n                 info += ' - %s:' % k\n-                if type(self.sum_values[k]) is list:\n+                if isinstance(self.sum_values[k], list):\n                     avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                     if abs(avg) > 1e-3:\n                         info += ' %.4f' % avg\n@@ -153,13 +146,13 @@ class Progbar(object):\n \n             self.total_width += len(info)\n             if prev_total_width > self.total_width:\n-                info += ((prev_total_width - self.total_width) * \" \")\n+                info += ((prev_total_width - self.total_width) * ' ')\n \n             sys.stdout.write(info)\n             sys.stdout.flush()\n \n             if current >= self.target:\n-                sys.stdout.write(\"\\n\")\n+                sys.stdout.write('\\n')\n \n         if self.verbose == 2:\n             if current >= self.target:\n\n@@ -34,7 +34,8 @@ def layer_from_config(config, custom_objects={}):\n     return layer_class.from_config(config['config'])\n \n \n-def print_summary(layers, relevant_nodes=None, line_length=100, positions=[.33, .55, .67, 1.]):\n+def print_summary(layers, relevant_nodes=None,\n+                  line_length=100, positions=[.33, .55, .67, 1.]):\n     '''Prints a summary of a layer\n \n     # Arguments\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#c0ee5b859c5e082671c65801b38c9e5cd9b3387b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 5 | Churn Cumulative: 3532 | Contributors (this commit): 46 | Commits (past 90d): 27 | Contributors (cumulative): 46 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1108,7 +1108,7 @@ class Function(object):\n         with tf.control_dependencies(self.outputs):\n             updates_ops = []\n             for update in updates:\n-                if type(update) is tuple:\n+                if isinstance(update, tuple):\n                     p, new_p = update\n                     updates_ops.append(tf.assign(p, new_p))\n                 else:\n@@ -1117,7 +1117,8 @@ class Function(object):\n             self.updates_op = tf.group(*updates_ops)\n \n     def __call__(self, inputs):\n-        assert type(inputs) in {list, tuple}\n+        if not isinstance(inputs, (list, tuple)):\n+            raise TypeError('`inputs` should be a list or tuple.')\n         feed_dict = {}\n         for tensor, value in zip(self.inputs, inputs):\n             if is_sparse(tensor):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#3f3e0aa90e9547e749fadcbf4d07bc7554f9e564", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 43 | Lines Deleted: 31 | Files Changed: 1 | Hunks: 29 | Methods Changed: 16 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 74 | Churn Cumulative: 8023 | Contributors (this commit): 53 | Commits (past 90d): 12 | Contributors (cumulative): 53 | DMM Complexity: 0.5\n\nDIFF:\n@@ -27,7 +27,7 @@ def save_model(model, filepath, overwrite=True):\n             return obj.item()\n \n         # misc functions (e.g. loss function)\n-        if hasattr(obj, '__call__'):\n+        if callable(obj):\n             return obj.__name__\n \n         # if obj is a python 'type'\n@@ -109,7 +109,7 @@ def save_model(model, filepath, overwrite=True):\n def load_model(filepath, custom_objects={}):\n \n     def deserialize(obj):\n-        if type(obj) is list:\n+        if isinstance(obj, list):\n             deserialized = []\n             for value in obj:\n                 if value in custom_objects:\n@@ -117,7 +117,7 @@ def load_model(filepath, custom_objects={}):\n                 else:\n                     deserialized.append(value)\n             return deserialized\n-        if type(obj) is dict:\n+        if isinstance(obj, dict):\n             deserialized = {}\n             for key, value in obj.items():\n                 if value in custom_objects:\n@@ -184,8 +184,9 @@ def load_model(filepath, custom_objects={}):\n def model_from_config(config, custom_objects={}):\n     from keras.utils.layer_utils import layer_from_config\n     if isinstance(config, list):\n-        raise Exception('`model_fom_config` expects a dictionary, not a list. '\n-                        'Maybe you meant to use `Sequential.from_config(config)`?')\n+        raise TypeError('`model_fom_config` expects a dictionary, not a list. '\n+                        'Maybe you meant to use '\n+                        '`Sequential.from_config(config)`?')\n     return layer_from_config(config, custom_objects=custom_objects)\n \n \n@@ -273,7 +274,7 @@ class Sequential(Model):\n             layer: layer instance.\n         '''\n         if not isinstance(layer, Layer):\n-            raise ValueError('The added layer must be '\n+            raise TypeError('The added layer must be '\n                             'an instance of class Layer. '\n                             'Found: ' + str(layer))\n         if not self.outputs:\n@@ -281,7 +282,8 @@ class Sequential(Model):\n             if len(layer.inbound_nodes) == 0:\n                 # create an input layer\n                 if not hasattr(layer, 'batch_input_shape'):\n-                    raise Exception('The first layer in a Sequential model must '\n+                    raise ValueError('The first layer in a '\n+                                     'Sequential model must '\n                                      'get an `input_shape` or '\n                                      '`batch_input_shape` argument.')\n                 batch_input_shape = layer.batch_input_shape\n@@ -292,14 +294,15 @@ class Sequential(Model):\n                 layer.create_input_layer(batch_input_shape, input_dtype)\n \n             if len(layer.inbound_nodes) != 1:\n-                raise Exception('A layer added to a Sequential model must '\n+                raise ValueError('A layer added to a Sequential model must '\n                                  'not already be connected somewhere else. '\n                                  'Model received layer ' + layer.name +\n-                                ' which has ' + str(len(layer.inbound_nodes)) +\n+                                 ' which has ' +\n+                                 str(len(layer.inbound_nodes)) +\n                                  ' pre-existing inbound connections.')\n \n             if len(layer.inbound_nodes[0].output_tensors) != 1:\n-                raise Exception('All layers in a Sequential model '\n+                raise ValueError('All layers in a Sequential model '\n                                  'should have a single output tensor. '\n                                  'For multi-output layers, '\n                                  'use the functional API.')\n@@ -322,8 +325,8 @@ class Sequential(Model):\n                  output_shapes=[self.outputs[0]._keras_shape])\n         else:\n             output_tensor = layer(self.outputs[0])\n-            if type(output_tensor) is list:\n-                raise Exception('All layers in a Sequential model '\n+            if isinstance(output_tensor, list):\n+                raise TypeError('All layers in a Sequential model '\n                                 'should have a single output tensor. '\n                                 'For multi-output layers, '\n                                 'use the functional API.')\n@@ -340,7 +343,7 @@ class Sequential(Model):\n         '''Removes the last layer in the model.\n         '''\n         if not self.layers:\n-            raise Exception('There are no layers in the model.')\n+            raise TypeError('There are no layers in the model.')\n \n         self.layers.pop()\n         if not self.layers:\n@@ -379,10 +382,11 @@ class Sequential(Model):\n \n     def build(self, input_shape=None):\n         if not self.inputs or not self.outputs:\n-            raise Exception('Sequential model cannot be built: model is empty.'\n+            raise TypeError('Sequential model cannot be built: model is empty.'\n                             ' Add some layers first.')\n         # actually create the model\n-        self.model = Model(self.inputs, self.outputs[0], name=self.name + '_model')\n+        self.model = Model(self.inputs, self.outputs[0],\n+                           name=self.name + '_model')\n         self.model.trainable = self.trainable\n \n         # mirror model attributes\n@@ -629,7 +633,8 @@ class Sequential(Model):\n             and validation metrics values (if applicable).\n         '''\n         if self.model is None:\n-            raise Exception('The model needs to be compiled before being used.')\n+            raise RuntimeError('The model needs to be compiled '\n+                               'before being used.')\n         if 'show_accuracy' in kwargs:\n             kwargs.pop('show_accuracy')\n             warnings.warn('The \"show_accuracy\" argument is deprecated, '\n@@ -638,7 +643,7 @@ class Sequential(Model):\n                           '`model.compile(optimizer, loss, '\n                           'metrics=[\"accuracy\"])`')\n         if kwargs:\n-            raise Exception('Received unknown keyword arguments: ' +\n+            raise TypeError('Received unknown keyword arguments: ' +\n                             str(kwargs))\n         return self.model.fit(x, y,\n                               batch_size=batch_size,\n@@ -670,7 +675,8 @@ class Sequential(Model):\n             the display labels for the scalar outputs.\n         '''\n         if self.model is None:\n-            raise Exception('The model needs to be compiled before being used.')\n+            raise RuntimeError('The model needs to be compiled '\n+                               'before being used.')\n         if 'show_accuracy' in kwargs:\n             kwargs.pop('show_accuracy')\n             warnings.warn('The \"show_accuracy\" argument is deprecated, '\n@@ -679,7 +685,7 @@ class Sequential(Model):\n                           '`model.compile(optimizer, loss, '\n                           'metrics=[\"accuracy\"])`')\n         if kwargs:\n-            raise Exception('Received unknown keyword arguments: ' +\n+            raise TypeError('Received unknown keyword arguments: ' +\n                             str(kwargs))\n         return self.model.evaluate(x, y,\n                                    batch_size=batch_size,\n@@ -728,7 +734,8 @@ class Sequential(Model):\n             the display labels for the scalar outputs.\n         '''\n         if self.model is None:\n-            raise Exception('The model needs to be compiled before being used.')\n+            raise RuntimeError('The model needs to be compiled '\n+                               'before being used.')\n         if 'accuracy' in kwargs:\n             kwargs.pop('accuracy')\n             warnings.warn('The \"accuracy\" argument is deprecated, '\n@@ -737,7 +744,7 @@ class Sequential(Model):\n                           '`model.compile(optimizer, loss, '\n                           'metrics=[\"accuracy\"])`')\n         if kwargs:\n-            raise Exception('Received unknown keyword arguments: ' +\n+            raise TypeError('Received unknown keyword arguments: ' +\n                             str(kwargs))\n         return self.model.train_on_batch(x, y,\n                                          sample_weight=sample_weight,\n@@ -760,7 +767,8 @@ class Sequential(Model):\n             the display labels for the scalar outputs.\n         '''\n         if self.model is None:\n-            raise Exception('The model needs to be compiled before being used.')\n+            raise RuntimeError('The model needs to be compiled '\n+                               'before being used.')\n         if 'accuracy' in kwargs:\n             kwargs.pop('accuracy')\n             warnings.warn('The \"accuracy\" argument is deprecated, '\n@@ -769,7 +777,7 @@ class Sequential(Model):\n                           '`model.compile(optimizer, loss, '\n                           'metrics=[\"accuracy\"])`')\n         if kwargs:\n-            raise Exception('Received unknown keyword arguments: ' +\n+            raise TypeError('Received unknown keyword arguments: ' +\n                             str(kwargs))\n         return self.model.test_on_batch(x, y,\n                                         sample_weight=sample_weight)\n@@ -876,9 +884,11 @@ class Sequential(Model):\n         ```\n         '''\n         if self.model is None:\n-            raise Exception('The model needs to be compiled before being used.')\n+            raise RuntimeError('The model needs to be compiled '\n+                               'before being used.')\n         if nb_worker > 1 and not pickle_safe:\n-            warnings.warn('The \"nb_worker\" argument is deprecated when pickle_safe is False')\n+            warnings.warn('The \"nb_worker\" argument is deprecated '\n+                          'when pickle_safe is False')\n             nb_worker = 1  # For backward compatibility\n         if 'show_accuracy' in kwargs:\n             kwargs.pop('show_accuracy')\n@@ -892,7 +902,7 @@ class Sequential(Model):\n             warnings.warn('The \"nb_val_worker\" argument is deprecated, '\n                           'please remove it from your code.')\n         if kwargs:\n-            raise Exception('Received unknown keyword arguments: ' +\n+            raise TypeError('Received unknown keyword arguments: ' +\n                             str(kwargs))\n         return self.model.fit_generator(generator,\n                                         samples_per_epoch,\n@@ -927,9 +937,11 @@ class Sequential(Model):\n                 easily to children processes.\n         '''\n         if self.model is None:\n-            raise Exception('The model needs to be compiled before being used.')\n+            raise RuntimeError('The model needs to be compiled '\n+                               'before being used.')\n         if nb_worker > 1 and not pickle_safe:\n-            warnings.warn('The \"nb_worker\" argument is deprecated when pickle_safe is False')\n+            warnings.warn('The \"nb_worker\" argument is deprecated '\n+                          'when pickle_safe is False')\n             nb_worker = 1  # For backward compatibility\n         if 'show_accuracy' in kwargs:\n             kwargs.pop('show_accuracy')\n@@ -942,7 +954,7 @@ class Sequential(Model):\n             kwargs.pop('verbose')\n             warnings.warn('The \"verbose\" argument is deprecated.')\n         if kwargs:\n-            raise Exception('Received unknown keyword arguments: ' +\n+            raise TypeError('Received unknown keyword arguments: ' +\n                             str(kwargs))\n         return self.model.evaluate_generator(generator,\n                                              val_samples,\n@@ -973,7 +985,8 @@ class Sequential(Model):\n         if self.model is None:\n             self.build()\n         if nb_worker > 1 and not pickle_safe:\n-            warnings.warn('The \"nb_worker\" argument is deprecated when pickle_safe is False')\n+            warnings.warn('The \"nb_worker\" argument is deprecated '\n+                          'when pickle_safe is False')\n             nb_worker = 1  # For backward compatibility\n         return self.model.predict_generator(generator, val_samples,\n                                             max_q_size=max_q_size,\n@@ -1009,7 +1022,6 @@ class Sequential(Model):\n         '''\n         from keras.utils.layer_utils import layer_from_config\n         from keras.layers import Merge\n-        assert type(config) is list\n \n         if not layer_cache:\n             layer_cache = {}\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
