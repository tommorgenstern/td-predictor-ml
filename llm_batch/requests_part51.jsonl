{"custom_id": "requests#ec852c1e5a71c11b1e894b6a846f4e09a5029662", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 339 | Contributors (this commit): 9 | Commits (past 90d): 5 | Contributors (cumulative): 9 | DMM Complexity: None\n\nDIFF:\n@@ -54,6 +54,7 @@ setup(\n     include_package_data=True,\n     install_requires=requires,\n     license=open('LICENSE').read(),\n+    zip_safe=False,\n     classifiers=(\n         'Development Status :: 5 - Production/Stable',\n         'Intended Audience :: Developers',\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#32aa3eb0129ddce47cef3ffcecadfb15b970fcca", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 114 | Contributors (this commit): 6 | Commits (past 90d): 1 | Contributors (cumulative): 6 | DMM Complexity: None\n\nDIFF:\n@@ -10,7 +10,7 @@ _codes = {\n     102: ('processing',),\n     103: ('checkpoint',),\n     122: ('uri_too_long', 'request_uri_too_long'),\n-    200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\\\o/'),\n+    200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\\\o/', '✓'),\n     201: ('created',),\n     202: ('accepted',),\n     203: ('non_authoritative_info', 'non_authoritative_information'),\n@@ -65,7 +65,7 @@ _codes = {\n     499: ('client_closed_request',),\n \n     # Server Error.\n-    500: ('internal_server_error', 'server_error', '/o\\\\'),\n+    500: ('internal_server_error', 'server_error', '/o\\\\', '✗'),\n     501: ('not_implemented',),\n     502: ('bad_gateway',),\n     503: ('service_unavailable', 'unavailable'),\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#a02f3dec02897bc4ab11329640aa79efbb4969f6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 8 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 9 | Churn Cumulative: 1597 | Contributors (this commit): 34 | Commits (past 90d): 11 | Contributors (cumulative): 34 | DMM Complexity: 0.0\n\nDIFF:\n@@ -540,10 +540,17 @@ def default_user_agent():\n     else:\n         _implementation_version = 'Unknown'\n         \n+    try:\n+        p_system = platform.system()\n+        p_release = platform.release()\n+    except IOError:\n+        p_system = 'Unknown'\n+        p_release = 'Unknown'\n+\n     return \" \".join([\n             'python-requests/%s' % __version__,\n             '%s/%s' % (_implementation, _implementation_version),\n-            '%s/%s' % (platform.system(), platform.release()),\n+            '%s/%s' % (p_system, p_release),\n         ])\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c8b2f7a37babe3033bd762a81f648bda02717e45", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 5790 | Contributors (this commit): 87 | Commits (past 90d): 22 | Contributors (cumulative): 87 | DMM Complexity: None\n\nDIFF:\n@@ -97,7 +97,7 @@ class Request(object):\n         #: :class:`Request <Request>`.\n         self.data = None\n \n-        #: Dictionary or byte of querystring data to attach to the\n+        #: Dictionary of querystring data to attach to the\n         #: :class:`Request <Request>`. The dictionary values can be lists for representing\n         #: multivalued query parameters.\n         self.params = None\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#0792acc1305b42a8d3f3160f1e23fd4751ec9dc8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 27 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 10 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 27 | Churn Cumulative: 1080 | Contributors (this commit): 20 | Commits (past 90d): 3 | Contributors (cumulative): 20 | DMM Complexity: None\n\nDIFF:\n@@ -73,15 +73,42 @@ class Session(object):\n         verify=True,\n         cert=None):\n \n+        #: A case-insensitive dictionary of headers to be sent on each\n+        #: :class:`Request <Request>` sent from this\n+        #: :class:`Session <Session>`.\n         self.headers = from_key_val_list(headers or [])\n+\n+        #: Authentication tuple or object to attach to\n+        #: :class:`Request <Request>`.\n         self.auth = auth\n+\n+        #: Float describing the timeout of the each :class:`Request <Request>`.\n         self.timeout = timeout\n+\n+        #: Dictionary mapping protocol to the URL of the proxy (e.g.\n+        #: {'http': 'foo.bar:3128'}) to be used on each\n+        #: :class:`Request <Request>`.\n         self.proxies = from_key_val_list(proxies or [])\n+\n+        #: Event-handling hooks.\n         self.hooks = from_key_val_list(hooks or {})\n+\n+        #: Dictionary of querystring data to attach to each\n+        #: :class:`Request <Request>`. The dictionary values may be lists for\n+        #: representing multivalued query parameters.\n         self.params = from_key_val_list(params or [])\n+\n+        #: Dictionary of configuration parameters for this\n+        #: :class:`Session <Session>`.\n         self.config = from_key_val_list(config or {})\n+\n+        #: Prefetch response content.\n         self.prefetch = prefetch\n+\n+        #: SSL Verification.\n         self.verify = verify\n+\n+        #: SSL certificate.\n         self.cert = cert\n \n         for (k, v) in list(defaults.items()):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b76326bf94382c9b44062435fd985d68b2e60edb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 530 | Contributors (this commit): 9 | Commits (past 90d): 8 | Contributors (cumulative): 9 | DMM Complexity: 1.0\n\nDIFF:\n@@ -32,9 +32,10 @@ class MockRequest(object):\n     def __init__(self, request):\n         self._r = request\n         self._new_headers = {}\n+        self.type = urlparse(self._r.full_url).scheme\n \n     def get_type(self):\n-        return urlparse(self._r.full_url).scheme\n+        return self.type\n \n     def get_host(self):\n         return urlparse(self._r.full_url).netloc\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#8da100f652793f95f7dfdad588c925dfac9e71a1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 47 | Lines Deleted: 5 | Files Changed: 3 | Hunks: 7 | Methods Changed: 4 | Complexity Δ (Sum/Max): 5/4 | Churn Δ: 52 | Churn Cumulative: 7534 | Contributors (this commit): 102 | Commits (past 90d): 37 | Contributors (cumulative): 123 | DMM Complexity: 0.05263157894736842\n\nDIFF:\n@@ -119,7 +119,7 @@ class Request(object):\n         # If no proxies are given, allow configuration by environment variables\n         # HTTP_PROXY and HTTPS_PROXY.\n         if not self.proxies and self.config.get('trust_env'):\n-            self.proxies = get_environ_proxies()\n+            self.proxies = get_environ_proxies(self.url)\n \n         self.data = data\n         self.params = params\n\n@@ -502,7 +502,7 @@ def requote_uri(uri):\n     return quote(unquote_unreserved(uri), safe=\"!#$%&'()*+,/:;=?@[]~\")\n \n \n-def get_environ_proxies():\n+def get_environ_proxies(url):\n     \"\"\"Return a dict of environment proxies.\"\"\"\n \n     proxy_keys = [\n@@ -510,11 +510,29 @@ def get_environ_proxies():\n         'http',\n         'https',\n         'ftp',\n-        'socks',\n-        'no'\n+        'socks'\n     ]\n \n     get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n+\n+    # First check whether no_proxy is defined. If it is, check that the URL\n+    # we're getting isn't in the no_proxy list.\n+    no_proxy = get_proxy('no_proxy')\n+\n+    if no_proxy:\n+        # We need to check whether we match here. We need to see if we match\n+        # the end of the netloc, both with and without the port.\n+        no_proxy = no_proxy.split(',')\n+        netloc = urlparse(url).netloc\n+\n+        for host in no_proxy:\n+            if netloc.endswith(host) or netloc.split(':')[0].endswith(host):\n+                # The URL does match something in no_proxy, so we don't want\n+                # to apply the proxies on this URL.\n+                return {}\n+\n+    # If we get here, we either didn't have no_proxy set or we're not going\n+    # anywhere that no_proxy applies to.\n     proxies = [(key, get_proxy(key + '_proxy')) for key in proxy_keys]\n     return dict([(key, val) for (key, val) in proxies if val])\n \n\n@@ -9,6 +9,7 @@ import random\n \n # Path hack.\n sys.path.insert(0, os.path.abspath('..'))\n+from requests.utils import get_environ_proxies\n import requests.utils\n from requests.compat import is_py3, bytes\n \n@@ -20,7 +21,7 @@ else:\n     byteschr = chr\n \n \n-class GuessJSONUTFTests(unittest.TestCase):\n+class UtilityTests(unittest.TestCase):\n     \"\"\"Tests for the JSON UTF encoding guessing code.\"\"\"\n \n     codecs = (\n@@ -73,5 +74,28 @@ class GuessJSONUTFTests(unittest.TestCase):\n                         continue\n                     raise\n \n+    def test_get_environ_proxies_respects_no_proxy(self):\n+        '''This test confirms that the no_proxy environment setting is\n+        respected by get_environ_proxies().'''\n+\n+        # Set up some example environment settings.\n+        os.environ['http_proxy'] = 'http://www.example.com/'\n+        os.environ['no_proxy'] = r'localhost,.0.0.1:8080'\n+\n+        # Set up expected proxy return values.\n+        proxy_yes = {'http': 'http://www.example.com/'}\n+        proxy_no = {}\n+\n+        # Check that we get the right things back.\n+        self.assertEqual(proxy_yes,\n+                         get_environ_proxies('http://www.google.com/'))\n+        self.assertEqual(proxy_no,\n+                         get_environ_proxies('http://localhost/test'))\n+        self.assertEqual(proxy_no,\n+                         get_environ_proxies('http://127.0.0.1:8080/'))\n+        self.assertEqual(proxy_yes,\n+                         get_environ_proxies('http://127.0.0.1:8081/'))\n+\n+\n if __name__ == '__main__':\n     unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c02520ed99d5aead74d70bcae70d3d1fa6424012", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 21 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 21 | Churn Cumulative: 142 | Contributors (this commit): 2 | Commits (past 90d): 7 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -78,6 +78,17 @@ class UtilityTests(unittest.TestCase):\n         '''This test confirms that the no_proxy environment setting is\n         respected by get_environ_proxies().'''\n \n+        # Store the current environment settings.\n+        try:\n+            old_http_proxy = os.environ['http_proxy']\n+        except KeyError:\n+            old_http_proxy = None\n+\n+        try:\n+            old_no_proxy = os.environ['no_proxy']\n+        except KeyError:\n+            old_no_proxy = None\n+\n         # Set up some example environment settings.\n         os.environ['http_proxy'] = 'http://www.example.com/'\n         os.environ['no_proxy'] = r'localhost,.0.0.1:8080'\n@@ -96,6 +107,16 @@ class UtilityTests(unittest.TestCase):\n         self.assertEqual(proxy_yes,\n                          get_environ_proxies('http://127.0.0.1:8081/'))\n \n+        # Return the settings to what they were.\n+        if old_http_proxy:\n+            os.environ['http_proxy'] = old_http_proxy\n+        else:\n+            del os.environ['http_proxy']\n+\n+        if old_no_proxy:\n+            os.environ['no_proxy'] = old_no_proxy\n+        else:\n+            del os.environ['no_proxy']\n \n if __name__ == '__main__':\n     unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c5fddb95edd7694c0164ae2a5279ceeebe475511", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): -4/0 | Churn Δ: 2 | Churn Cumulative: 1623 | Contributors (this commit): 35 | Commits (past 90d): 10 | Contributors (cumulative): 35 | DMM Complexity: None\n\nDIFF:\n@@ -29,6 +29,8 @@ CERTIFI_BUNDLE_PATH = None\n try:\n     # see if requests's own CA certificate bundle is installed\n     from . import certs\n+    path = certs.where()\n+    if os.path.exists(path):\n         CERTIFI_BUNDLE_PATH = certs.where()\n except ImportError:\n     pass\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#20cd46426fda1b048afa90955f445424efa4be46", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 1625 | Contributors (this commit): 36 | Commits (past 90d): 11 | Contributors (cumulative): 36 | DMM Complexity: None\n\nDIFF:\n@@ -29,6 +29,8 @@ CERTIFI_BUNDLE_PATH = None\n try:\n     # see if requests's own CA certificate bundle is installed\n     from . import certs\n+    path = certs.where()\n+    if os.path.exists(path):\n         CERTIFI_BUNDLE_PATH = certs.where()\n except ImportError:\n     pass\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#18be26fc2a7f8d41b691762d826f235ae04f24fd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 3 | Churn Cumulative: 1628 | Contributors (this commit): 37 | Commits (past 90d): 12 | Contributors (cumulative): 37 | DMM Complexity: 1.0\n\nDIFF:\n@@ -473,7 +473,6 @@ def unquote_unreserved(uri):\n     \"\"\"Un-escape any percent-escape sequences in a URI that are unreserved\n     characters. This leaves all reserved, illegal and non-ASCII bytes encoded.\n     \"\"\"\n-    try:\n     parts = uri.split('%')\n     for i in range(1, len(parts)):\n         h = parts[i][0:2]\n@@ -486,8 +485,6 @@ def unquote_unreserved(uri):\n         else:\n             parts[i] = '%' + parts[i]\n     return ''.join(parts)\n-    except ValueError:\n-        return uri\n \n \n def requote_uri(uri):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#8269ee726656cc76e67f02e7f37b90c8d01f5520", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 25 | Lines Deleted: 8 | Files Changed: 4 | Hunks: 10 | Methods Changed: 6 | Complexity Δ (Sum/Max): 2/1 | Churn Δ: 33 | Churn Cumulative: 3409 | Contributors (this commit): 48 | Commits (past 90d): 15 | Contributors (cumulative): 72 | DMM Complexity: 1.0\n\nDIFF:\n@@ -12,10 +12,8 @@ This module implements the Requests API.\n \"\"\"\n \n from . import sessions\n-from .safe_mode import catch_exceptions_if_in_safe_mode\n \n \n-@catch_exceptions_if_in_safe_mode\n def request(method, url, **kwargs):\n     \"\"\"Constructs and sends a :class:`Request <Request>`.\n     Returns :class:`Response <Response>` object.\n\n@@ -18,17 +18,17 @@ import socket\n \n \n def catch_exceptions_if_in_safe_mode(function):\n-    \"\"\"New implementation of safe_mode. We catch all exceptions at the API level\n+    \"\"\"New implementation of safe_mode. We catch all exceptions at the Session level\n     and then return a blank Response object with the error field filled. This decorator\n-    wraps request() in api.py.\n+    wraps Session._send_request() in sessions.py.\n     \"\"\"\n \n-    def wrapped(method, url, **kwargs):\n+    def wrapped(*args, **kwargs):\n         # if save_mode, we catch exceptions and fill error field\n         if (kwargs.get('config') and kwargs.get('config').get('safe_mode')) or (kwargs.get('session')\n                                             and kwargs.get('session').config.get('safe_mode')):\n             try:\n-                return function(method, url, **kwargs)\n+                return function(*args, **kwargs)\n             except (RequestException, ConnectionError, HTTPError,\n                     socket.timeout, socket.gaierror) as e:\n                 r = Response()\n@@ -36,5 +36,5 @@ def catch_exceptions_if_in_safe_mode(function):\n                 r.raw = HTTPResponse()  # otherwise, tests fail\n                 r.status_code = 0  # with this status_code, content returns None\n                 return r\n-        return function(method, url, **kwargs)\n+        return function(*args, **kwargs)\n     return wrapped\n\n@@ -17,6 +17,7 @@ from .models import Request\n from .hooks import dispatch_hook\n from .utils import header_expand, from_key_val_list\n from .packages.urllib3.poolmanager import PoolManager\n+from .safe_mode import catch_exceptions_if_in_safe_mode\n \n \n def merge_kwargs(local_kwarg, default_kwarg):\n@@ -265,7 +266,12 @@ class Session(object):\n             return r\n \n         # Send the HTTP Request.\n-        r.send(prefetch=prefetch)\n+        return self._send_request(r, **args)\n+\n+    @catch_exceptions_if_in_safe_mode\n+    def _send_request(self, r, **kwargs):\n+        # Send the request.\n+        r.send(prefetch=kwargs.get(\"prefetch\"))\n \n         # Return the response.\n         return r.response\n\n@@ -930,6 +930,19 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n         self.assertTrue(ds1.prefetch)\n         self.assertFalse(ds2.prefetch)\n     \n+    def test_session_connection_error_with_safe_mode(self):\n+        config = {\"safe_mode\":True}\n+\n+        s = requests.session()\n+        r = s.get(\"http://localhost:1/nope\", timeout=0.1, config=config)\n+        self.assertFalse(r.ok)\n+        self.assertTrue(r.content is None)\n+\n+        s2 = requests.session(config=config)\n+        r2 = s2.get(\"http://localhost:1/nope\", timeout=0.1)\n+        self.assertFalse(r2.ok)\n+        self.assertTrue(r2.content is None)\n+\n     def test_connection_error(self):\n         try:\n             get('http://localhost:1/nope')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#d5f9a2a51c884099294f75ae9148ec0f64b0bab4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 5 | Methods Changed: 3 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 8 | Churn Cumulative: 7028 | Contributors (this commit): 92 | Commits (past 90d): 30 | Contributors (cumulative): 112 | DMM Complexity: None\n\nDIFF:\n@@ -9,6 +9,7 @@ This module contains the primary objects that power Requests.\n \n import os\n import socket\n+import collections\n from datetime import datetime\n from io import BytesIO\n \n@@ -467,10 +468,10 @@ class Request(object):\n \n     def register_hook(self, event, hook):\n         \"\"\"Properly register a hook.\"\"\"\n-        if callable(hook):\n+        if isinstance(hook, collections.Callable):\n             self.hooks[event].append(hook)\n         elif hasattr(hook, '__iter__'):\n-            self.hooks[event].extend(h for h in hook if callable(h))\n+            self.hooks[event].extend(h for h in hook if isinstance(h, collections.Callable))\n \n     def deregister_hook(self, event, hook):\n         \"\"\"Deregister a previously registered hook.\n\n@@ -11,6 +11,7 @@ import json\n import unittest\n import pickle\n import tempfile\n+import collections\n \n import requests\n from requests.compat import str, StringIO\n@@ -805,7 +806,7 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n \n         def assert_hooks_are_callable(hooks):\n             for h in hooks['args']:\n-                self.assertTrue(callable(h))\n+                self.assertTrue(isinstance(h, collections.Callable))\n \n         hooks = [add_foo_header, add_bar_header]\n         r = requests.models.Request()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#31f74bd02eb89592c1173a301c402132e171153f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 22 | Lines Deleted: 8 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 30 | Churn Cumulative: 800 | Contributors (this commit): 15 | Commits (past 90d): 6 | Contributors (cumulative): 15 | DMM Complexity: 0.0\n\nDIFF:\n@@ -92,14 +92,28 @@ class OAuth1(AuthBase):\n             # Omit body data in the signing and since it will always\n             # be empty (cant add paras to body if multipart) and we wish\n             # to preserve body.\n-            r.url, r.headers, _ = self.client.sign(\n-                unicode(r.full_url), unicode(r.method), None, r.headers)\n-        elif decoded_body is not None and contenttype in (CONTENT_TYPE_FORM_URLENCODED, ''):\n-            # Normal signing\n-            if not contenttype:\n-                r.headers['Content-Type'] = CONTENT_TYPE_FORM_URLENCODED\n-            r.url, r.headers, r.data = self.client.sign(\n-                unicode(r.full_url), unicode(r.method), r.data, r.headers)\n+            r.url, r.headers, _ = self.client.sign(unicode(r.full_url),\n+                                                   unicode(r.method),\n+                                                   None,\n+                                                   r.headers)\n+        elif (decoded_body is not None and \n+                                  contenttype == CONTENT_TYPE_FORM_URLENCODED):\n+            # If the Content-Type header is urlencoded and there are no\n+            # illegal characters in the body, assume that the content actually\n+            # is urlencoded, and so should be part of the signature.\n+            r.url, r.headers, r.data = self.client.sign(unicode(r.full_url),\n+                                                        unicode(r.method),\n+                                                        r.data,\n+                                                        r.headers)\n+        elif r.data:\n+            # The data we passed was either definitely not urlencoded\n+            # (because extract_params returned nothing) or doesn't have a\n+            # content header that assures us that it is. Assume then that the\n+            # data shouldn't be part of the signature.\n+            r.url, r.headers, _ = self.client.sign(unicode(r.full_url),\n+                                                   unicode(r.method),\n+                                                   None,\n+                                                   r.headers)\n         else:\n             _oauth_signed = False\n         if _oauth_signed:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f003025a37f9d546570e52f7d355c6f5d1a81617", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 4 | Churn Cumulative: 5801 | Contributors (this commit): 87 | Commits (past 90d): 20 | Contributors (cumulative): 87 | DMM Complexity: 0.0\n\nDIFF:\n@@ -541,6 +541,10 @@ class Request(object):\n                 else:\n                     content_type = 'application/x-www-form-urlencoded'\n \n+        self.headers['Content-Length'] = '0'\n+        if body is not None:\n+            self.headers['Content-Length'] = str(len(body))\n+\n         # Add content-type if it wasn't explicitly provided.\n         if (content_type) and (not 'content-type' in self.headers):\n             self.headers['Content-Type'] = content_type\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#61f16d1ddcf4729945ce7b0b9bfbd94b75dc4b92", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 6 | Churn Cumulative: 5807 | Contributors (this commit): 87 | Commits (past 90d): 21 | Contributors (cumulative): 87 | DMM Complexity: 0.0\n\nDIFF:\n@@ -542,7 +542,11 @@ class Request(object):\n                     content_type = 'application/x-www-form-urlencoded'\n \n         self.headers['Content-Length'] = '0'\n-        if body is not None:\n+        if isinstance(body, file):\n+            body.seek(0, 2)\n+            self.headers['Content-Length'] = str(body.tell())\n+            body.seek(0, 0)\n+        elif body is not None:\n             self.headers['Content-Length'] = str(len(body))\n \n         # Add content-type if it wasn't explicitly provided.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b93fbd30c32b122bf7aba7db6663ca5a292b17d3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 2 | Churn Cumulative: 5809 | Contributors (this commit): 87 | Commits (past 90d): 22 | Contributors (cumulative): 87 | DMM Complexity: None\n\nDIFF:\n@@ -542,7 +542,7 @@ class Request(object):\n                     content_type = 'application/x-www-form-urlencoded'\n \n         self.headers['Content-Length'] = '0'\n-        if isinstance(body, file):\n+        if hasattr(body, 'seek') and hasattr(body, 'tell'):\n             body.seek(0, 2)\n             self.headers['Content-Length'] = str(body.tell())\n             body.seek(0, 0)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#a1b6ef3f8563ee1b535b82eada0bd43fa0e5ae1a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 0 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 0 | Churn Cumulative: 576 | Contributors (this commit): 11 | Commits (past 90d): 1 | Contributors (cumulative): 11 | DMM Complexity: None\n\nDIFF:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f02573f743458f015d93c67e9b6169b9516fe275", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 4 | Churn Cumulative: 804 | Contributors (this commit): 16 | Commits (past 90d): 3 | Contributors (cumulative): 16 | DMM Complexity: 1.0\n\nDIFF:\n@@ -105,7 +105,7 @@ class OAuth1(AuthBase):\n                                                         unicode(r.method),\n                                                         r.data,\n                                                         r.headers)\n-        elif r.data:\n+        else:\n             # The data we passed was either definitely not urlencoded\n             # (because extract_params returned nothing) or doesn't have a\n             # content header that assures us that it is. Assume then that the\n@@ -114,8 +114,6 @@ class OAuth1(AuthBase):\n                                                    unicode(r.method),\n                                                    None,\n                                                    r.headers)\n-        else:\n-            _oauth_signed = False\n         if _oauth_signed:\n             # Both flows add params to the URL by using r.full_url,\n             # so this prevents adding it again later\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4d06e4019f3a30a38fbdc3f59156f08f74d6c76e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 2875 | Files Changed: 13 | Hunks: 12 | Methods Changed: 107 | Complexity Δ (Sum/Max): -278/0 | Churn Δ: 2875 | Churn Cumulative: 5772 | Contributors (this commit): 4 | Commits (past 90d): 14 | Contributors (cumulative): 16 | DMM Complexity: 0.33034571062740076\n\nDIFF:\n@@ -1,23 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-requests._oauth\n-~~~~~~~~~~~~~~~\n-\n-This module contains the path hack necessary for oauthlib to be vendored into\n-requests while allowing upstream changes.\n-\"\"\"\n-\n-import os\n-import sys\n-\n-try:\n-    from oauthlib.oauth1 import rfc5849\n-    from oauthlib.common import extract_params\n-    from oauthlib.oauth1.rfc5849 import (Client, SIGNATURE_HMAC, SIGNATURE_TYPE_AUTH_HEADER)\n-except ImportError:\n-    from .packages import oauthlib\n-    sys.modules['oauthlib'] = oauthlib\n-    from oauthlib.oauth1 import rfc5849\n-    from oauthlib.common import extract_params\n-    from oauthlib.oauth1.rfc5849 import (Client, SIGNATURE_HMAC, SIGNATURE_TYPE_AUTH_HEADER)\n\n\n@@ -1,229 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from __future__ import absolute_import\n-\n-\"\"\"\n-oauthlib.common\n-~~~~~~~~~~~~~~\n-\n-This module provides data structures and utilities common\n-to all implementations of OAuth.\n-\"\"\"\n-\n-import random\n-import re\n-import string\n-import time\n-import urllib\n-import urlparse\n-\n-UNICODE_ASCII_CHARACTER_SET = (string.ascii_letters.decode('ascii') +\n-    string.digits.decode('ascii'))\n-\n-always_safe = (u'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n-               u'abcdefghijklmnopqrstuvwxyz'\n-               u'0123456789' u'_.-')\n-\n-\n-def quote(s, safe=u'/'):\n-    encoded = s.encode(\"utf-8\")\n-    quoted = urllib.quote(encoded, safe)\n-    return quoted.decode(\"utf-8\")\n-\n-\n-def unquote(s):\n-    encoded = s.encode(\"utf-8\")\n-    unquoted = urllib.unquote(encoded)\n-    return unquoted.decode(\"utf-8\")\n-\n-\n-def urlencode(params):\n-    utf8_params = encode_params_utf8(params)\n-    urlencoded = urllib.urlencode(utf8_params)\n-    return urlencoded.decode(\"utf-8\")\n-\n-\n-def encode_params_utf8(params):\n-    \"\"\"Ensures that all parameters in a list of 2-element tuples are encoded to\n-    bytestrings using UTF-8\n-    \"\"\"\n-    encoded = []\n-    for k, v in params:\n-        encoded.append((\n-            k.encode('utf-8') if isinstance(k, unicode) else k,\n-            v.encode('utf-8') if isinstance(v, unicode) else v))\n-    return encoded\n-\n-\n-def decode_params_utf8(params):\n-    \"\"\"Ensures that all parameters in a list of 2-element tuples are decoded to\n-    unicode using UTF-8.\n-    \"\"\"\n-    decoded = []\n-    for k, v in params:\n-        decoded.append((\n-            k.decode('utf-8') if isinstance(k, str) else k,\n-            v.decode('utf-8') if isinstance(v, str) else v))\n-    return decoded\n-\n-\n-urlencoded = set(always_safe) | set(u'=&;%+~')\n-\n-\n-def urldecode(query):\n-    \"\"\"Decode a query string in x-www-form-urlencoded format into a sequence\n-    of two-element tuples.\n-\n-    Unlike urlparse.parse_qsl(..., strict_parsing=True) urldecode will enforce\n-    correct formatting of the query string by validation. If validation fails\n-    a ValueError will be raised. urllib.parse_qsl will only raise errors if\n-    any of name-value pairs omits the equals sign.\n-    \"\"\"\n-    # Check if query contains invalid characters\n-    if query and not set(query) <= urlencoded:\n-        raise ValueError('Invalid characters in query string.')\n-\n-    # Check for correctly hex encoded values using a regular expression\n-    # All encoded values begin with % followed by two hex characters\n-    # correct = %00, %A0, %0A, %FF\n-    # invalid = %G0, %5H, %PO\n-    invalid_hex = u'%[^0-9A-Fa-f]|%[0-9A-Fa-f][^0-9A-Fa-f]'\n-    if len(re.findall(invalid_hex, query)):\n-        raise ValueError('Invalid hex encoding in query string.')\n-\n-    query = query.decode('utf-8') if isinstance(query, str) else query\n-    # We want to allow queries such as \"c2\" whereas urlparse.parse_qsl\n-    # with the strict_parsing flag will not.\n-    params = urlparse.parse_qsl(query, keep_blank_values=True)\n-\n-    # unicode all the things\n-    return decode_params_utf8(params)\n-\n-\n-def extract_params(raw):\n-    \"\"\"Extract parameters and return them as a list of 2-tuples.\n-\n-    Will successfully extract parameters from urlencoded query strings,\n-    dicts, or lists of 2-tuples. Empty strings/dicts/lists will return an\n-    empty list of parameters. Any other input will result in a return\n-    value of None.\n-    \"\"\"\n-    if isinstance(raw, basestring):\n-        try:\n-            params = urldecode(raw)\n-        except ValueError:\n-            params = None\n-    elif hasattr(raw, '__iter__'):\n-        try:\n-            dict(raw)\n-        except ValueError:\n-            params = None\n-        except TypeError:\n-            params = None\n-        else:\n-            params = list(raw.items() if isinstance(raw, dict) else raw)\n-            params = decode_params_utf8(params)\n-    else:\n-        params = None\n-\n-    return params\n-\n-\n-def generate_nonce():\n-    \"\"\"Generate pseudorandom nonce that is unlikely to repeat.\n-\n-    Per `section 3.3`_ of the OAuth 1 RFC 5849 spec.\n-    Per `section 3.2.1`_ of the MAC Access Authentication spec.\n-\n-    A random 64-bit number is appended to the epoch timestamp for both\n-    randomness and to decrease the likelihood of collisions.\n-\n-    .. _`section 3.2.1`: http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01#section-3.2.1\n-    .. _`section 3.3`: http://tools.ietf.org/html/rfc5849#section-3.3\n-    \"\"\"\n-    return unicode(unicode(random.getrandbits(64)) + generate_timestamp())\n-\n-\n-def generate_timestamp():\n-    \"\"\"Get seconds since epoch (UTC).\n-\n-    Per `section 3.3`_ of the OAuth 1 RFC 5849 spec.\n-    Per `section 3.2.1`_ of the MAC Access Authentication spec.\n-\n-    .. _`section 3.2.1`: http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01#section-3.2.1\n-    .. _`section 3.3`: http://tools.ietf.org/html/rfc5849#section-3.3\n-    \"\"\"\n-    return unicode(int(time.time()))\n-\n-\n-def generate_token(length=30, chars=UNICODE_ASCII_CHARACTER_SET):\n-    \"\"\"Generates a non-guessable OAuth token\n-\n-    OAuth (1 and 2) does not specify the format of tokens except that they\n-    should be strings of random characters. Tokens should not be guessable\n-    and entropy when generating the random characters is important. Which is\n-    why SystemRandom is used instead of the default random.choice method.\n-    \"\"\"\n-    rand = random.SystemRandom()\n-    return u''.join(rand.choice(chars) for x in range(length))\n-\n-\n-def add_params_to_qs(query, params):\n-    \"\"\"Extend a query with a list of two-tuples.\"\"\"\n-    queryparams = urlparse.parse_qsl(query, keep_blank_values=True)\n-    queryparams.extend(params)\n-    return urlencode(queryparams)\n-\n-\n-def add_params_to_uri(uri, params):\n-    \"\"\"Add a list of two-tuples to the uri query components.\"\"\"\n-    sch, net, path, par, query, fra = urlparse.urlparse(uri)\n-    query = add_params_to_qs(query, params)\n-    return urlparse.urlunparse((sch, net, path, par, query, fra))\n-\n-def safe_string_equals(a, b):\n-    \"\"\" Near-constant time string comparison. \n-\n-    Used in order to avoid timing attacks on sensitive information such\n-    as secret keys during request verification (`rootLabs`_).\n-\n-    .. _`rootLabs`: http://rdist.root.org/2010/01/07/timing-independent-array-comparison/\n-    \n-    \"\"\"\n-    if len(a) != len(b):\n-        return False\n-\n-    result = 0\n-    for x, y in zip(a, b):\n-        result |= ord(x) ^ ord(y)\n-    return result == 0\n-\n-class Request(object):\n-    \"\"\"A malleable representation of a signable HTTP request.\n-\n-    Body argument may contain any data, but parameters will only be decoded if\n-    they are one of:\n-\n-    * urlencoded query string\n-    * dict\n-    * list of 2-tuples\n-\n-    Anything else will be treated as raw body data to be passed through\n-    unmolested.\n-    \"\"\"\n-\n-    def __init__(self, uri, http_method=u'GET', body=None, headers=None):\n-        self.uri = uri\n-        self.http_method = http_method\n-        self.headers = headers or {}\n-        self.body = body\n-        self.decoded_body = extract_params(body)\n-        self.oauth_params = []\n-\n-    @property\n-    def uri_query(self):\n-        return urlparse.urlparse(self.uri).query\n-\n-    @property\n-    def uri_query_params(self):\n-        return urlparse.parse_qsl(self.uri_query, keep_blank_values=True,\n-                                  strict_parsing=True)\n\n@@ -1,13 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from __future__ import absolute_import\n-\n-\"\"\"\n-oauthlib.oauth1\n-~~~~~~~~~~~~~~\n-\n-This module is a wrapper for the most recent implementation of OAuth 1.0 Client\n-and Server classes.\n-\"\"\"\n-\n-from .rfc5849 import Client, Server\n-\n\n@@ -1,889 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from __future__ import absolute_import\n-\n-\"\"\"\n-oauthlib.oauth1.rfc5849\n-~~~~~~~~~~~~~~\n-\n-This module is an implementation of various logic needed\n-for signing and checking OAuth 1.0 RFC 5849 requests.\n-\"\"\"\n-\n-import logging\n-import time\n-import urlparse\n-\n-from oauthlib.common import Request, urlencode, generate_nonce\n-from oauthlib.common import generate_timestamp\n-from . import parameters, signature, utils\n-\n-logger = logging.getLogger(__name__)\n-\n-SIGNATURE_HMAC = u\"HMAC-SHA1\"\n-SIGNATURE_RSA = u\"RSA-SHA1\"\n-SIGNATURE_PLAINTEXT = u\"PLAINTEXT\"\n-SIGNATURE_METHODS = (SIGNATURE_HMAC, SIGNATURE_RSA, SIGNATURE_PLAINTEXT)\n-\n-SIGNATURE_TYPE_AUTH_HEADER = u'AUTH_HEADER'\n-SIGNATURE_TYPE_QUERY = u'QUERY'\n-SIGNATURE_TYPE_BODY = u'BODY'\n-\n-CONTENT_TYPE_FORM_URLENCODED = u'application/x-www-form-urlencoded'\n-\n-\n-class Client(object):\n-    \"\"\"A client used to sign OAuth 1.0 RFC 5849 requests\"\"\"\n-    def __init__(self, client_key,\n-            client_secret=None,\n-            resource_owner_key=None,\n-            resource_owner_secret=None,\n-            callback_uri=None,\n-            signature_method=SIGNATURE_HMAC,\n-            signature_type=SIGNATURE_TYPE_AUTH_HEADER,\n-            rsa_key=None, verifier=None):\n-        self.client_key = client_key\n-        self.client_secret = client_secret\n-        self.resource_owner_key = resource_owner_key\n-        self.resource_owner_secret = resource_owner_secret\n-        self.signature_method = signature_method\n-        self.signature_type = signature_type\n-        self.callback_uri = callback_uri\n-        self.rsa_key = rsa_key\n-        self.verifier = verifier\n-\n-        if self.signature_method == SIGNATURE_RSA and self.rsa_key is None:\n-            raise ValueError('rsa_key is required when using RSA signature method.')\n-\n-    def get_oauth_signature(self, request):\n-        \"\"\"Get an OAuth signature to be used in signing a request\n-        \"\"\"\n-        if self.signature_method == SIGNATURE_PLAINTEXT:\n-            # fast-path\n-            return signature.sign_plaintext(self.client_secret,\n-                self.resource_owner_secret)\n-\n-        uri, headers, body = self._render(request)\n-\n-        collected_params = signature.collect_parameters(\n-            uri_query=urlparse.urlparse(uri).query,\n-            body=body,\n-            headers=headers)\n-        logger.debug(\"Collected params: {0}\".format(collected_params))\n-\n-        normalized_params = signature.normalize_parameters(collected_params)\n-        normalized_uri = signature.normalize_base_string_uri(request.uri)\n-        logger.debug(\"Normalized params: {0}\".format(normalized_params))\n-        logger.debug(\"Normalized URI: {0}\".format(normalized_uri))\n-\n-        base_string = signature.construct_base_string(request.http_method,\n-            normalized_uri, normalized_params)\n-\n-        logger.debug(\"Base signing string: {0}\".format(base_string))\n-\n-        if self.signature_method == SIGNATURE_HMAC:\n-            sig = signature.sign_hmac_sha1(base_string, self.client_secret,\n-                self.resource_owner_secret)\n-        elif self.signature_method == SIGNATURE_RSA:\n-            sig = signature.sign_rsa_sha1(base_string, self.rsa_key)\n-        else:\n-            sig = signature.sign_plaintext(self.client_secret,\n-                self.resource_owner_secret)\n-\n-        logger.debug(\"Signature: {0}\".format(sig))\n-        return sig\n-\n-    def get_oauth_params(self):\n-        \"\"\"Get the basic OAuth parameters to be used in generating a signature.\n-        \"\"\"\n-        params = [\n-            (u'oauth_nonce', generate_nonce()),\n-            (u'oauth_timestamp', generate_timestamp()),\n-            (u'oauth_version', u'1.0'),\n-            (u'oauth_signature_method', self.signature_method),\n-            (u'oauth_consumer_key', self.client_key),\n-        ]\n-        if self.resource_owner_key:\n-            params.append((u'oauth_token', self.resource_owner_key))\n-        if self.callback_uri:\n-            params.append((u'oauth_callback', self.callback_uri))\n-        if self.verifier:\n-            params.append((u'oauth_verifier', self.verifier))\n-\n-        return params\n-\n-    def _render(self, request, formencode=False):\n-        \"\"\"Render a signed request according to signature type\n-\n-        Returns a 3-tuple containing the request URI, headers, and body.\n-\n-        If the formencode argument is True and the body contains parameters, it\n-        is escaped and returned as a valid formencoded string.\n-        \"\"\"\n-        # TODO what if there are body params on a header-type auth?\n-        # TODO what if there are query params on a body-type auth?\n-\n-        uri, headers, body = request.uri, request.headers, request.body\n-\n-        # TODO: right now these prepare_* methods are very narrow in scope--they\n-        # only affect their little thing. In some cases (for example, with\n-        # header auth) it might be advantageous to allow these methods to touch\n-        # other parts of the request, like the headers—so the prepare_headers\n-        # method could also set the Content-Type header to x-www-form-urlencoded\n-        # like the spec requires. This would be a fundamental change though, and\n-        # I'm not sure how I feel about it.\n-        if self.signature_type == SIGNATURE_TYPE_AUTH_HEADER:\n-            headers = parameters.prepare_headers(request.oauth_params, request.headers)\n-        elif self.signature_type == SIGNATURE_TYPE_BODY and request.decoded_body is not None:\n-            body = parameters.prepare_form_encoded_body(request.oauth_params, request.decoded_body)\n-            if formencode:\n-                body = urlencode(body)\n-            headers['Content-Type'] = u'application/x-www-form-urlencoded'\n-        elif self.signature_type == SIGNATURE_TYPE_QUERY:\n-            uri = parameters.prepare_request_uri_query(request.oauth_params, request.uri)\n-        else:\n-            raise ValueError('Unknown signature type specified.')\n-\n-        return uri, headers, body\n-\n-    def sign(self, uri, http_method=u'GET', body=None, headers=None):\n-        \"\"\"Sign a request\n-\n-        Signs an HTTP request with the specified parts.\n-\n-        Returns a 3-tuple of the signed request's URI, headers, and body.\n-        Note that http_method is not returned as it is unaffected by the OAuth\n-        signing process.\n-\n-        The body argument may be a dict, a list of 2-tuples, or a formencoded\n-        string. The Content-Type header must be 'application/x-www-form-urlencoded'\n-        if it is present.\n-\n-        If the body argument is not one of the above, it will be returned\n-        verbatim as it is unaffected by the OAuth signing process. Attempting to\n-        sign a request with non-formencoded data using the OAuth body signature\n-        type is invalid and will raise an exception.\n-\n-        If the body does contain parameters, it will be returned as a properly-\n-        formatted formencoded string.\n-\n-        All string data MUST be unicode. This includes strings inside body\n-        dicts, for example.\n-        \"\"\"\n-        # normalize request data\n-        request = Request(uri, http_method, body, headers)\n-\n-        # sanity check\n-        content_type = request.headers.get('Content-Type', None)\n-        multipart = content_type and content_type.startswith('multipart/')\n-        should_have_params = content_type == CONTENT_TYPE_FORM_URLENCODED\n-        has_params = request.decoded_body is not None\n-        # 3.4.1.3.1.  Parameter Sources\n-        # [Parameters are collected from the HTTP request entity-body, but only\n-        # if [...]:\n-        #    *  The entity-body is single-part.\n-        if multipart and has_params:\n-            raise ValueError(\"Headers indicate a multipart body but body contains parameters.\")\n-        #    *  The entity-body follows the encoding requirements of the\n-        #       \"application/x-www-form-urlencoded\" content-type as defined by\n-        #       [W3C.REC-html40-19980424].\n-        elif should_have_params and not has_params:\n-            raise ValueError(\"Headers indicate a formencoded body but body was not decodable.\")\n-        #    *  The HTTP request entity-header includes the \"Content-Type\"\n-        #       header field set to \"application/x-www-form-urlencoded\".\n-        elif not should_have_params and has_params:\n-            raise ValueError(\"Body contains parameters but Content-Type header was not set.\")\n-\n-        # 3.5.2.  Form-Encoded Body\n-        # Protocol parameters can be transmitted in the HTTP request entity-\n-        # body, but only if the following REQUIRED conditions are met:\n-        # o  The entity-body is single-part.\n-        # o  The entity-body follows the encoding requirements of the\n-        #    \"application/x-www-form-urlencoded\" content-type as defined by\n-        #    [W3C.REC-html40-19980424].\n-        # o  The HTTP request entity-header includes the \"Content-Type\" header\n-        #    field set to \"application/x-www-form-urlencoded\".\n-        elif self.signature_type == SIGNATURE_TYPE_BODY and not (\n-                should_have_params and has_params and not multipart):\n-            raise ValueError('Body signatures may only be used with form-urlencoded content')\n-\n-        # generate the basic OAuth parameters\n-        request.oauth_params = self.get_oauth_params()\n-\n-        # generate the signature\n-        request.oauth_params.append((u'oauth_signature', self.get_oauth_signature(request)))\n-\n-        # render the signed request and return it\n-        return self._render(request, formencode=True)\n-\n-\n-class Server(object):\n-    \"\"\"A server base class used to verify OAuth 1.0 RFC 5849 requests\n-\n-    OAuth providers should inherit from Server and implement the methods\n-    and properties outlined below. Further details are provided in the\n-    documentation for each method and property.\n-\n-    Methods used to check the format of input parameters. Common tests include\n-    length, character set, membership, range or pattern. These tests are\n-    referred to as `whitelisting or blacklisting`_. Whitelisting is better\n-    but blacklisting can be usefull to spot malicious activity.\n-    The following have methods a default implementation:\n-\n-    - check_client_key\n-    - check_request_token\n-    - check_access_token\n-    - check_nonce\n-    - check_verifier\n-    - check_realm\n-\n-    The methods above default to whitelist input parameters, checking that they\n-    are alphanumerical and between a minimum and maximum length. Rather than\n-    overloading the methods a few properties can be used to configure these\n-    methods.\n-\n-    @ safe_characters -> (character set)\n-    @ client_key_length -> (min, max)\n-    @ request_token_length -> (min, max)\n-    @ access_token_length -> (min, max)\n-    @ nonce_length -> (min, max)\n-    @ verifier_length -> (min, max)\n-    @ realms -> [list, of, realms]\n-\n-    Methods used to validate input parameters. These checks usually hit either\n-    persistent or temporary storage such as databases or the filesystem. See\n-    each methods documentation for detailed usage.\n-    The following methods must be implemented:\n-\n-    - validate_client\n-    - validate_request_token\n-    - validate_access_token\n-    - validate_nonce_and_timestamp\n-    - validate_redirect_uri\n-    - validate_requested_realm\n-    - validate_realm\n-    - validate_verifier\n-\n-    Method used to retrieve sensitive information from storage.\n-    The following methods must be implemented:\n-\n-    - get_client_secret\n-    - get_request_token_secret\n-    - get_access_token_secret\n-    - get_rsa_key\n-\n-    To prevent timing attacks it is necessary to not exit early even if the\n-    client key or resource owner key is invalid. Instead dummy values should\n-    be used during the remaining verification process. It is very important\n-    that the dummy client and token are valid input parameters to the methods\n-    get_client_secret, get_rsa_key and get_(access/request)_token_secret and\n-    that the running time of those methods when given a dummy value remain\n-    equivalent to the running time when given a valid client/resource owner.\n-    The following properties must be implemented:\n-\n-    @ dummy_client\n-    @ dummy_request_token\n-    @ dummy_access_token\n-\n-    .. _`whitelisting or blacklisting`: http://www.schneier.com/blog/archives/2011/01/whitelisting_vs.html\n-    \"\"\"\n-\n-    def __init__(self):\n-        pass\n-\n-    @property\n-    def allowed_signature_methods(self):\n-        return SIGNATURE_METHODS\n-\n-    @property\n-    def safe_characters(self):\n-        return set(utils.UNICODE_ASCII_CHARACTER_SET)\n-\n-    @property\n-    def client_key_length(self):\n-        return 20, 30\n-\n-    @property\n-    def request_token_length(self):\n-        return 20, 30\n-\n-    @property\n-    def access_token_length(self):\n-        return 20, 30\n-\n-    @property\n-    def timestamp_lifetime(self):\n-        return 600\n-\n-    @property\n-    def nonce_length(self):\n-        return 20, 30\n-\n-    @property\n-    def verifier_length(self):\n-        return 20, 30\n-\n-    @property\n-    def realms(self):\n-        return []\n-\n-    @property\n-    def enforce_ssl(self):\n-        return True\n-\n-    def check_client_key(self, client_key):\n-        \"\"\"Check that the client key only contains safe characters\n-        and is no shorter than lower and no longer than upper.\n-        \"\"\"\n-        lower, upper = self.client_key_length\n-        return (set(client_key) <= self.safe_characters and\n-                lower <= len(client_key) <= upper)\n-\n-    def check_request_token(self, request_token):\n-        \"\"\"Checks that the request token contains only safe characters\n-        and is no shorter than lower and no longer than upper.\n-        \"\"\"\n-        lower, upper = self.request_token_length\n-        return (set(request_token) <= self.safe_characters and\n-                lower <= len(request_token) <= upper)\n-\n-    def check_access_token(self, request_token):\n-        \"\"\"Checks that the token contains only safe characters\n-        and is no shorter than lower and no longer than upper.\n-        \"\"\"\n-        lower, upper = self.access_token_length\n-        return (set(request_token) <= self.safe_characters and\n-                lower <= len(request_token) <= upper)\n-\n-    def check_nonce(self, nonce):\n-        \"\"\"Checks that the nonce only contains only safe characters\n-        and is no shorter than lower and no longer than upper.\n-        \"\"\"\n-        lower, upper = self.nonce_length\n-        return (set(nonce) <= self.safe_characters and\n-                lower <= len(nonce) <= upper)\n-\n-    def check_verifier(self, verifier):\n-        \"\"\"Checks that the verifier contains only safe characters\n-        and is no shorter than lower and no longer than upper.\n-        \"\"\"\n-        lower, upper = self.verifier_length\n-        return (set(verifier) <= self.safe_characters and\n-                lower <= len(verifier) <= upper)\n-\n-    def check_realm(self, realm):\n-        \"\"\"Check that the realm is one of a set allowed realms.\n-        \"\"\"\n-        return realm in self.realms\n-\n-    def get_client_secret(self, client_key):\n-        \"\"\"Retrieves the client secret associated with the client key.\n-\n-        This method must allow the use of a dummy client_key value.\n-        Fetching the secret using the dummy key must take the same amount of\n-        time as fetching a secret for a valid client.\n-\n-        Note that the returned key must be in plaintext.\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    @property\n-    def dummy_client(self):\n-        \"\"\"Dummy client used when an invalid client key is supplied.\n-\n-        The dummy client should be associated with either a client secret,\n-        a rsa key or both depending on which signature methods are supported.\n-        Providers should make sure that\n-\n-        get_client_secret(dummy_client)\n-        get_rsa_key(dummy_client)\n-\n-        return a valid secret or key for the dummy client.\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    def get_request_token_secret(self, client_key, request_token):\n-        \"\"\"Retrieves the shared secret associated with the request token.\n-\n-        This method must allow the use of a dummy values and the running time\n-        must be roughly equivalent to that of the running time of valid values.\n-\n-        Note that the returned key must be in plaintext.\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    def get_access_token_secret(self, client_key, access_token):\n-        \"\"\"Retrieves the shared secret associated with the access token.\n-\n-        This method must allow the use of a dummy values and the running time\n-        must be roughly equivalent to that of the running time of valid values.\n-\n-        Note that the returned key must be in plaintext.\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    @property\n-    def dummy_request_token(self):\n-        \"\"\"Dummy request token used when an invalid token was supplied.\n-\n-        The dummy request token should be associated with a request token\n-        secret such that get_request_token_secret(.., dummy_request_token)\n-        returns a valid secret.\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    @property\n-    def dummy_access_token(self):\n-        \"\"\"Dummy access token used when an invalid token was supplied.\n-\n-        The dummy access token should be associated with an access token\n-        secret such that get_access_token_secret(.., dummy_access_token)\n-        returns a valid secret.\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    def get_rsa_key(self, client_key):\n-        \"\"\"Retrieves a previously stored client provided RSA key.\n-\n-        This method must allow the use of a dummy client_key value. Fetching\n-        the rsa key using the dummy key must take the same aount of time\n-        as fetching a key for a valid client.\n-\n-        Note that the key must be returned in plaintext.\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    def get_signature_type_and_params(self, request):\n-        \"\"\"Extracts parameters from query, headers and body. Signature type\n-        is set to the source in which parameters were found.\n-        \"\"\"\n-        header_params = signature.collect_parameters(headers=request.headers,\n-                exclude_oauth_signature=False)\n-        body_params = signature.collect_parameters(body=request.body,\n-                exclude_oauth_signature=False)\n-        query_params = signature.collect_parameters(uri_query=request.uri_query,\n-                exclude_oauth_signature=False)\n-\n-        params = []\n-        params.extend(header_params)\n-        params.extend(body_params)\n-        params.extend(query_params)\n-        signature_types_with_oauth_params = filter(lambda s: s[2], (\n-            (SIGNATURE_TYPE_AUTH_HEADER, params,\n-                utils.filter_oauth_params(header_params)),\n-            (SIGNATURE_TYPE_BODY, params,\n-                utils.filter_oauth_params(body_params)),\n-            (SIGNATURE_TYPE_QUERY, params,\n-                utils.filter_oauth_params(query_params))\n-        ))\n-\n-        if len(signature_types_with_oauth_params) > 1:\n-            raise ValueError('oauth_ params must come from only 1 signature type but were found in %s' % ', '.join(\n-                [s[0] for s in signature_types_with_oauth_params]))\n-        try:\n-            signature_type, params, oauth_params = signature_types_with_oauth_params[0]\n-        except IndexError:\n-            raise ValueError('oauth_ params are missing. Could not determine signature type.')\n-\n-        return signature_type, params, oauth_params\n-\n-    def validate_client_key(self, client_key):\n-        \"\"\"Validates that supplied client key is a registered and valid client.\n-\n-        Note that if the dummy client is supplied it should validate in same\n-        or nearly the same amount of time as a valid one.\n-\n-        Bad:\n-\n-            if client_key == self.dummy_client:\n-                return False\n-            else:\n-                return storage.has_client(client_key)\n-\n-        Good:\n-\n-            return storage.has_client(client_key) and client_key != self.dummy_client\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    def validate_request_token(self, client_key, request_token):\n-        \"\"\"Validates that supplied request token is registered and valid.\n-\n-        Note that if the dummy request_token is supplied it should validate in\n-        the same nearly the same amount of time as a valid one.\n-\n-        Bad:\n-\n-            if request_token == self.dummy_request_token:\n-                return False\n-            else:\n-                return storage.has_request_token(request_token)\n-\n-        Good:\n-\n-            return (storage.has_request_token(request_token) and\n-                    request_token != self.dummy_request_token)\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    def validate_access_token(self, client_key, access_token):\n-        \"\"\"Validates that supplied access token is registered and valid.\n-\n-        Note that if the dummy access token is supplied it should validate in\n-        the same or nearly the same amount of time as a valid one.\n-\n-        Bad:\n-\n-            if access_token == self.dummy_access_token:\n-                return False\n-            else:\n-                return storage.has_access_token(access_token)\n-\n-        Good:\n-\n-            return (storage.has_access_token(access_token) and\n-                    access_token != self.dummy_access_token)\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    def validate_timestamp_and_nonce(self, client_key, timestamp, nonce,\n-        request_token=None, access_token=None):\n-        \"\"\"Validates that the nonce has not been used before.\n-\n-        Per `Section 3.3`_ of the spec.\n-\n-        \"A nonce is a random string, uniquely generated by the client to allow\n-        the server to verify that a request has never been made before and\n-        helps prevent replay attacks when requests are made over a non-secure\n-        channel.  The nonce value MUST be unique across all requests with the\n-        same timestamp, client credentials, and token combinations.\"\n-\n-        .. _`Section 3.3`: http://tools.ietf.org/html/rfc5849#section-3.3\n-\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    def validate_redirect_uri(self, client_key, redirect_uri):\n-        \"\"\"Validates the client supplied redirection URI.\n-\n-        It is highly recommended that OAuth providers require their clients\n-        to register all redirection URIs prior to using them in requests and\n-        register them as absolute URIs. See `CWE-601`_ for more information\n-        about open redirection attacks.\n-\n-        By requiring registration of all redirection URIs it should be\n-        straightforward for the provider to verify whether the supplied\n-        redirect_uri is valid or not.\n-\n-        .. _`CWE-601`: http://cwe.mitre.org/top25/index.html#CWE-601\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-\n-    def validate_requested_realm(self, client_key, realm):\n-        \"\"\"Validates that the client may request access to the realm.\n-\n-        This method is invoked when obtaining a request token and should\n-        tie a realm to the request token and after user authorization\n-        this realm restriction should transfer to the access token.\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    def validate_realm(self, client_key, access_token, uri=None,\n-            required_realm=None):\n-        \"\"\"Validates access to the request realm.\n-\n-        How providers choose to use the realm parameter is outside the OAuth\n-        specification but it is commonly used to restrict access to a subset\n-        of protected resources such as \"photos\".\n-\n-        required_realm is a convenience parameter which can be used to provide\n-        a per view method pre-defined list of allowed realms.\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    def validate_verifier(self, client_key, request_token, verifier):\n-        \"\"\"Validates a verification code.\n-\n-        OAuth providers issue a verification code to clients after the\n-        resource owner authorizes access. This code is used by the client to\n-        obtain token credentials and the provider must verify that the\n-        verifier is valid and associated with the client as well as the\n-        resource owner.\n-        \"\"\"\n-        raise NotImplementedError(\"Subclasses must implement this function.\")\n-\n-    def verify_request(self, uri, http_method=u'GET', body=None,\n-            headers=None, require_resource_owner=True, require_verifier=False,\n-            require_realm=False, required_realm=None):\n-        \"\"\"Verifies a request ensuring that the following is true:\n-\n-        Per `section 3.2`_ of the spec.\n-\n-        - all mandated OAuth parameters are supplied\n-        - parameters are only supplied in one source which may be the URI\n-          query, the Authorization header or the body\n-        - all parameters are checked and validated, see comments and the\n-          methods and properties of this class for further details.\n-        - the supplied signature is verified against a recalculated one\n-\n-        A ValueError will be raised if any parameter is missing,\n-        supplied twice or invalid. A HTTP 400 Response should be returned\n-        upon catching an exception.\n-\n-        A HTTP 401 Response should be returned if verify_request returns False.\n-\n-        `Timing attacks`_ are prevented through the use of dummy credentials to\n-        create near constant time verification even if an invalid credential\n-        is used. Early exit on invalid credentials would enable attackers\n-        to perform `enumeration attacks`_. Near constant time string comparison\n-        is used to prevent secret key guessing. Note that timing attacks can\n-        only be prevented through near constant time execution, not by adding\n-        a random delay which would only require more samples to be gathered.\n-\n-        .. _`section 3.2`: http://tools.ietf.org/html/rfc5849#section-3.2\n-        .. _`Timing attacks`: http://rdist.root.org/2010/07/19/exploiting-remote-timing-attacks/\n-        .. _`enumeration attacks`: http://www.sans.edu/research/security-laboratory/article/attacks-browsing\n-        \"\"\"\n-        # Only include body data from x-www-form-urlencoded requests\n-        headers = headers or {}\n-        if (u\"Content-Type\" in headers and\n-                headers[u\"Content-Type\"] == CONTENT_TYPE_FORM_URLENCODED):\n-            request = Request(uri, http_method, body, headers)\n-        else:\n-            request = Request(uri, http_method, u'', headers)\n-\n-        if self.enforce_ssl and not request.uri.lower().startswith(\"https://\"):\n-            raise ValueError(\"Insecure transport, only HTTPS is allowed.\")\n-\n-        signature_type, params, oauth_params = self.get_signature_type_and_params(request)\n-\n-        # The server SHOULD return a 400 (Bad Request) status code when\n-        # receiving a request with duplicated protocol parameters.\n-        if len(dict(oauth_params)) != len(oauth_params):\n-            raise ValueError(\"Duplicate OAuth entries.\")\n-\n-        oauth_params = dict(oauth_params)\n-        request_signature = oauth_params.get(u'oauth_signature')\n-        client_key = oauth_params.get(u'oauth_consumer_key')\n-        resource_owner_key = oauth_params.get(u'oauth_token')\n-        nonce = oauth_params.get(u'oauth_nonce')\n-        timestamp = oauth_params.get(u'oauth_timestamp')\n-        callback_uri = oauth_params.get(u'oauth_callback')\n-        verifier = oauth_params.get(u'oauth_verifier')\n-        signature_method = oauth_params.get(u'oauth_signature_method')\n-        realm = dict(params).get(u'realm')\n-\n-        # The server SHOULD return a 400 (Bad Request) status code when\n-        # receiving a request with missing parameters.\n-        if not all((request_signature, client_key, nonce,\n-                    timestamp, signature_method)):\n-            raise ValueError(\"Missing OAuth parameters.\")\n-\n-        # OAuth does not mandate a particular signature method, as each\n-        # implementation can have its own unique requirements.  Servers are\n-        # free to implement and document their own custom methods.\n-        # Recommending any particular method is beyond the scope of this\n-        # specification.  Implementers should review the Security\n-        # Considerations section (`Section 4`_) before deciding on which\n-        # method to support.\n-        # .. _`Section 4`: http://tools.ietf.org/html/rfc5849#section-4\n-        if not signature_method in self.allowed_signature_methods:\n-            raise ValueError(\"Invalid signature method.\")\n-\n-        # Servers receiving an authenticated request MUST validate it by:\n-        #   If the \"oauth_version\" parameter is present, ensuring its value is\n-        #   \"1.0\".\n-        if u'oauth_version' in oauth_params and oauth_params[u'oauth_version'] != u'1.0':\n-            raise ValueError(\"Invalid OAuth version.\")\n-\n-        # The timestamp value MUST be a positive integer. Unless otherwise\n-        # specified by the server's documentation, the timestamp is expressed\n-        # in the number of seconds since January 1, 1970 00:00:00 GMT.\n-        if len(timestamp) != 10:\n-            raise ValueError(\"Invalid timestamp size\")\n-        try:\n-            ts = int(timestamp)\n-\n-        except ValueError:\n-            raise ValueError(\"Timestamp must be an integer\")\n-\n-        else:\n-            # To avoid the need to retain an infinite number of nonce values for\n-            # future checks, servers MAY choose to restrict the time period after\n-            # which a request with an old timestamp is rejected.\n-            if time.time() - ts > self.timestamp_lifetime:\n-                raise ValueError(\"Request too old, over 10 minutes.\")\n-\n-        # Provider specific validation of parameters, used to enforce\n-        # restrictions such as character set and length.\n-        if not self.check_client_key(client_key):\n-            raise ValueError(\"Invalid client key.\")\n-\n-        if not resource_owner_key and require_resource_owner:\n-            raise ValueError(\"Missing resource owner.\")\n-\n-        if (require_resource_owner and not require_verifier and\n-            not self.check_access_token(resource_owner_key)):\n-            raise ValueError(\"Invalid resource owner key.\")\n-\n-        if (require_resource_owner and require_verifier and\n-            not self.check_request_token(resource_owner_key)):\n-            raise ValueError(\"Invalid resource owner key.\")\n-\n-        if not self.check_nonce(nonce):\n-            raise ValueError(\"Invalid nonce.\")\n-\n-        if realm and not self.check_realm(realm):\n-            raise ValueError(\"Invalid realm. Allowed are %s\" % self.realms)\n-\n-        if not verifier and require_verifier:\n-            raise ValueError(\"Missing verifier.\")\n-\n-        if require_verifier and not self.check_verifier(verifier):\n-            raise ValueError(\"Invalid verifier.\")\n-\n-        # Servers receiving an authenticated request MUST validate it by:\n-        #   If using the \"HMAC-SHA1\" or \"RSA-SHA1\" signature methods, ensuring\n-        #   that the combination of nonce/timestamp/token (if present)\n-        #   received from the client has not been used before in a previous\n-        #   request (the server MAY reject requests with stale timestamps as\n-        #   described in `Section 3.3`_).\n-        # .._`Section 3.3`: http://tools.ietf.org/html/rfc5849#section-3.3\n-        #\n-        # We check this before validating client and resource owner for\n-        # increased security and performance, both gained by doing less work.\n-        if require_verifier:\n-            token = {\"request_token\": resource_owner_key}\n-        else:\n-            token = {\"access_token\": resource_owner_key}\n-        if not self.validate_timestamp_and_nonce(client_key, timestamp,\n-                nonce, **token):\n-                return False\n-\n-        # The server SHOULD return a 401 (Unauthorized) status code when\n-        # receiving a request with invalid client credentials.\n-        # Note: This is postponed in order to avoid timing attacks, instead\n-        # a dummy client is assigned and used to maintain near constant\n-        # time request verification.\n-        #\n-        # Note that early exit would enable client enumeration\n-        valid_client = self.validate_client_key(client_key)\n-        if not valid_client:\n-            client_key = self.dummy_client\n-\n-        # Ensure a valid redirection uri is used\n-        valid_redirect = self.validate_redirect_uri(client_key, callback_uri)\n-\n-        # The server SHOULD return a 401 (Unauthorized) status code when\n-        # receiving a request with invalid or expired token.\n-        # Note: This is postponed in order to avoid timing attacks, instead\n-        # a dummy token is assigned and used to maintain near constant\n-        # time request verification.\n-        #\n-        # Note that early exit would enable resource owner enumeration\n-        if resource_owner_key:\n-            if require_verifier:\n-                valid_resource_owner = self.validate_request_token(\n-                    client_key, resource_owner_key)\n-            else:\n-                valid_resource_owner = self.validate_access_token(\n-                    client_key, resource_owner_key)\n-            if not valid_resource_owner:\n-                resource_owner_key = self.dummy_resource_owner\n-        else:\n-            valid_resource_owner = True\n-\n-        # Note that `realm`_ is only used in authorization headers and how\n-        # it should be interepreted is not included in the OAuth spec.\n-        # However they could be seen as a scope or realm to which the\n-        # client has access and as such every client should be checked\n-        # to ensure it is authorized access to that scope or realm.\n-        # .. _`realm`: http://tools.ietf.org/html/rfc2617#section-1.2\n-        #\n-        # Note that early exit would enable client realm access enumeration.\n-        #\n-        # The require_realm indicates this is the first step in the OAuth\n-        # workflow where a client requests access to a specific realm.\n-        #\n-        # Clients obtaining an access token will not supply a realm and it will\n-        # not be checked. Instead the previously requested realm should be\n-        # transferred from the request token to the access token.\n-        #\n-        # Access to protected resources will always validate the realm but note\n-        # that the realm is now tied to the access token and not provided by\n-        # the client.\n-        if require_realm and not resource_owner_key:\n-            valid_realm = self.validate_requested_realm(client_key, realm)\n-        elif require_verifier:\n-            valid_realm = True\n-        else:\n-            valid_realm = self.validate_realm(client_key, resource_owner_key,\n-                    uri=request.uri, required_realm=required_realm)\n-\n-        # The server MUST verify (Section 3.2) the validity of the request,\n-        # ensure that the resource owner has authorized the provisioning of\n-        # token credentials to the client, and ensure that the temporary\n-        # credentials have not expired or been used before.  The server MUST\n-        # also verify the verification code received from the client.\n-        # .. _`Section 3.2`: http://tools.ietf.org/html/rfc5849#section-3.2\n-        #\n-        # Note that early exit would enable resource owner authorization\n-        # verifier enumertion.\n-        if verifier:\n-            valid_verifier = self.validate_verifier(client_key,\n-                resource_owner_key, verifier)\n-        else:\n-            valid_verifier = True\n-\n-        # Parameters to Client depend on signature method which may vary\n-        # for each request. Note that HMAC-SHA1 and PLAINTEXT share parameters\n-\n-        request.params = filter(lambda x: x[0] != \"oauth_signature\", params)\n-        request.signature = request_signature\n-\n-        # ---- RSA Signature verification ----\n-        if signature_method == SIGNATURE_RSA:\n-            # The server verifies the signature per `[RFC3447] section 8.2.2`_\n-            # .. _`[RFC3447] section 8.2.2`: http://tools.ietf.org/html/rfc3447#section-8.2.1\n-            rsa_key = self.get_rsa_key(client_key)\n-            valid_signature = signature.verify_rsa_sha1(request, rsa_key)\n-\n-        # ---- HMAC or Plaintext Signature verification ----\n-        else:\n-            # Servers receiving an authenticated request MUST validate it by:\n-            #   Recalculating the request signature independently as described in\n-            #   `Section 3.4`_ and comparing it to the value received from the\n-            #   client via the \"oauth_signature\" parameter.\n-            # .. _`Section 3.4`: http://tools.ietf.org/html/rfc5849#section-3.4\n-            client_secret = self.get_client_secret(client_key)\n-            if require_verifier:\n-                resource_owner_secret = self.get_request_token_secret(\n-                    client_key, resource_owner_key)\n-            else:\n-                resource_owner_secret = self.get_access_token_secret(\n-                    client_key, resource_owner_key)\n-\n-            if signature_method == SIGNATURE_HMAC:\n-                valid_signature = signature.verify_hmac_sha1(request,\n-                    client_secret, resource_owner_secret)\n-            else:\n-                valid_signature = signature.verify_plaintext(request,\n-                    client_secret, resource_owner_secret)\n-\n-        # We delay checking validity until the very end, using dummy values for\n-        # calculations and fetching secrets/keys to ensure the flow of every\n-        # request remains almost identical regardless of whether valid values\n-        # have been supplied. This ensures near constant time execution and\n-        # prevents malicious users from guessing sensitive information\n-        v = all((valid_client, valid_resource_owner, valid_realm,\n-                    valid_redirect, valid_verifier, valid_signature))\n-        logger = logging.getLogger(\"oauthlib\")\n-        if not v:\n-            logger.info(\"[Failure] OAuthLib request verification failed.\")\n-            logger.info(\"Valid client:\\t%s\" % valid_client)\n-            logger.info(\"Valid token:\\t%s\\t(Required: %s\" % (valid_resource_owner, require_resource_owner))\n-            logger.info(\"Valid realm:\\t%s\\t(Required: %s)\" % (valid_realm, require_realm))\n-            logger.info(\"Valid callback:\\t%s\" % valid_redirect)\n-            logger.info(\"Valid verifier:\\t%s\\t(Required: %s)\" % (valid_verifier, require_verifier))\n-            logger.info(\"Valid signature:\\t%s\" % valid_signature)\n-        return v\n\n@@ -1,134 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from __future__ import absolute_import\n-\n-\"\"\"\n-oauthlib.parameters\n-~~~~~~~~~~~~~~~~~~~\n-\n-This module contains methods related to `section 3.5`_ of the OAuth 1.0a spec.\n-\n-.. _`section 3.5`: http://tools.ietf.org/html/rfc5849#section-3.5\n-\"\"\"\n-\n-from urlparse import urlparse, urlunparse\n-from . import utils\n-from oauthlib.common import extract_params, urlencode\n-\n-\n-# TODO: do we need filter_params now that oauth_params are handled by Request?\n-#       We can easily pass in just oauth protocol params.\n-@utils.filter_params\n-def prepare_headers(oauth_params, headers=None, realm=None):\n-    \"\"\"**Prepare the Authorization header.**\n-    Per `section 3.5.1`_ of the spec.\n-\n-    Protocol parameters can be transmitted using the HTTP \"Authorization\"\n-    header field as defined by `RFC2617`_ with the auth-scheme name set to\n-    \"OAuth\" (case insensitive).\n-\n-    For example::\n-\n-        Authorization: OAuth realm=\"Example\",\n-            oauth_consumer_key=\"0685bd9184jfhq22\",\n-            oauth_token=\"ad180jjd733klru7\",\n-            oauth_signature_method=\"HMAC-SHA1\",\n-            oauth_signature=\"wOJIO9A2W5mFwDgiDvZbTSMK%2FPY%3D\",\n-            oauth_timestamp=\"137131200\",\n-            oauth_nonce=\"4572616e48616d6d65724c61686176\",\n-            oauth_version=\"1.0\"\n-\n-\n-    .. _`section 3.5.1`: http://tools.ietf.org/html/rfc5849#section-3.5.1\n-    .. _`RFC2617`: http://tools.ietf.org/html/rfc2617\n-    \"\"\"\n-    headers = headers or {}\n-\n-    # Protocol parameters SHALL be included in the \"Authorization\" header\n-    # field as follows:\n-    authorization_header_parameters_parts = []\n-    for oauth_parameter_name, value in oauth_params:\n-        # 1.  Parameter names and values are encoded per Parameter Encoding\n-        #     (`Section 3.6`_)\n-        #\n-        # .. _`Section 3.6`: http://tools.ietf.org/html/rfc5849#section-3.6\n-        escaped_name = utils.escape(oauth_parameter_name)\n-        escaped_value = utils.escape(value)\n-\n-        # 2.  Each parameter's name is immediately followed by an \"=\" character\n-        #     (ASCII code 61), a \"\"\" character (ASCII code 34), the parameter\n-        #     value (MAY be empty), and another \"\"\" character (ASCII code 34).\n-        part = u'{0}=\"{1}\"'.format(escaped_name, escaped_value)\n-\n-        authorization_header_parameters_parts.append(part)\n-\n-    # 3.  Parameters are separated by a \",\" character (ASCII code 44) and\n-    #     OPTIONAL linear whitespace per `RFC2617`_.\n-    #\n-    # .. _`RFC2617`: http://tools.ietf.org/html/rfc2617\n-    authorization_header_parameters = ', '.join(\n-        authorization_header_parameters_parts)\n-\n-    # 4.  The OPTIONAL \"realm\" parameter MAY be added and interpreted per\n-    #     `RFC2617 section 1.2`_.\n-    #\n-    # .. _`RFC2617 section 1.2`: http://tools.ietf.org/html/rfc2617#section-1.2\n-    if realm:\n-        # NOTE: realm should *not* be escaped\n-        authorization_header_parameters = (u'realm=\"%s\", ' % realm +\n-            authorization_header_parameters)\n-\n-    # the auth-scheme name set to \"OAuth\" (case insensitive).\n-    authorization_header = u'OAuth %s' % authorization_header_parameters\n-\n-    # contribute the Authorization header to the given headers\n-    full_headers = {}\n-    full_headers.update(headers)\n-    full_headers[u'Authorization'] = authorization_header\n-    return full_headers\n-\n-\n-def _append_params(oauth_params, params):\n-    \"\"\"Append OAuth params to an existing set of parameters.\n-\n-    Both params and oauth_params is must be lists of 2-tuples.\n-\n-    Per `section 3.5.2`_ and `3.5.3`_ of the spec.\n-\n-    .. _`section 3.5.2`: http://tools.ietf.org/html/rfc5849#section-3.5.2\n-    .. _`3.5.3`: http://tools.ietf.org/html/rfc5849#section-3.5.3\n-\n-    \"\"\"\n-    merged = list(params)\n-    merged.extend(oauth_params)\n-    # The request URI / entity-body MAY include other request-specific\n-    # parameters, in which case, the protocol parameters SHOULD be appended\n-    # following the request-specific parameters, properly separated by an \"&\"\n-    # character (ASCII code 38)\n-    merged.sort(key=lambda i: i[0].startswith('oauth_'))\n-    return merged\n-\n-\n-def prepare_form_encoded_body(oauth_params, body):\n-    \"\"\"Prepare the Form-Encoded Body.\n-\n-    Per `section 3.5.2`_ of the spec.\n-\n-    .. _`section 3.5.2`: http://tools.ietf.org/html/rfc5849#section-3.5.2\n-\n-    \"\"\"\n-    # append OAuth params to the existing body\n-    return _append_params(oauth_params, body)\n-\n-\n-def prepare_request_uri_query(oauth_params, uri):\n-    \"\"\"Prepare the Request URI Query.\n-\n-    Per `section 3.5.3`_ of the spec.\n-\n-    .. _`section 3.5.3`: http://tools.ietf.org/html/rfc5849#section-3.5.3\n-\n-    \"\"\"\n-    # append OAuth params to the existing set of query components\n-    sch, net, path, par, query, fra = urlparse(uri)\n-    query = urlencode(_append_params(oauth_params, extract_params(query) or []))\n-    return urlunparse((sch, net, path, par, query, fra))\n\n@@ -1,551 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from __future__ import absolute_import\n-\"\"\"\n-oauthlib.oauth1.rfc5849.signature\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-This module represents a direct implementation of `section 3.4`_ of the spec.\n-\n-Terminology:\n- * Client: software interfacing with an OAuth API\n- * Server: the API provider\n- * Resource Owner: the user who is granting authorization to the client\n-\n-Steps for signing a request:\n-\n-1. Collect parameters from the uri query, auth header, & body\n-2. Normalize those parameters\n-3. Normalize the uri\n-4. Pass the normalized uri, normalized parameters, and http method to\n-   construct the base string\n-5. Pass the base string and any keys needed to a signing function\n-\n-.. _`section 3.4`: http://tools.ietf.org/html/rfc5849#section-3.4\n-\"\"\"\n-import binascii\n-import hashlib\n-import hmac\n-import urlparse\n-from . import utils\n-from oauthlib.common import extract_params, safe_string_equals\n-\n-\n-def construct_base_string(http_method, base_string_uri,\n-        normalized_encoded_request_parameters):\n-    \"\"\"**String Construction**\n-    Per `section 3.4.1.1`_ of the spec.\n-\n-    For example, the HTTP request::\n-\n-        POST /request?b5=%3D%253D&a3=a&c%40=&a2=r%20b HTTP/1.1\n-        Host: example.com\n-        Content-Type: application/x-www-form-urlencoded\n-        Authorization: OAuth realm=\"Example\",\n-            oauth_consumer_key=\"9djdj82h48djs9d2\",\n-            oauth_token=\"kkk9d7dh3k39sjv7\",\n-            oauth_signature_method=\"HMAC-SHA1\",\n-            oauth_timestamp=\"137131201\",\n-            oauth_nonce=\"7d8f3e4a\",\n-            oauth_signature=\"bYT5CMsGcbgUdFHObYMEfcx6bsw%3D\"\n-\n-        c2&a3=2+q\n-\n-    is represented by the following signature base string (line breaks\n-    are for display purposes only)::\n-\n-        POST&http%3A%2F%2Fexample.com%2Frequest&a2%3Dr%2520b%26a3%3D2%2520q\n-        %26a3%3Da%26b5%3D%253D%25253D%26c%2540%3D%26c2%3D%26oauth_consumer_\n-        key%3D9djdj82h48djs9d2%26oauth_nonce%3D7d8f3e4a%26oauth_signature_m\n-        ethod%3DHMAC-SHA1%26oauth_timestamp%3D137131201%26oauth_token%3Dkkk\n-        9d7dh3k39sjv7\n-\n-    .. _`section 3.4.1.1`: http://tools.ietf.org/html/rfc5849#section-3.4.1.1\n-    \"\"\"\n-\n-    # The signature base string is constructed by concatenating together,\n-    # in order, the following HTTP request elements:\n-\n-    # 1.  The HTTP request method in uppercase.  For example: \"HEAD\",\n-    #     \"GET\", \"POST\", etc.  If the request uses a custom HTTP method, it\n-    #     MUST be encoded (`Section 3.6`_).\n-    #\n-    # .. _`Section 3.6`: http://tools.ietf.org/html/rfc5849#section-3.6\n-    base_string = utils.escape(http_method.upper())\n-\n-    # 2.  An \"&\" character (ASCII code 38).\n-    base_string += u'&'\n-\n-    # 3.  The base string URI from `Section 3.4.1.2`_, after being encoded\n-    #     (`Section 3.6`_).\n-    #\n-    # .. _`Section 3.4.1.2`: http://tools.ietf.org/html/rfc5849#section-3.4.1.2\n-    # .. _`Section 3.4.6`: http://tools.ietf.org/html/rfc5849#section-3.4.6\n-    base_string += utils.escape(base_string_uri)\n-\n-    # 4.  An \"&\" character (ASCII code 38).\n-    base_string += u'&'\n-\n-    # 5.  The request parameters as normalized in `Section 3.4.1.3.2`_, after\n-    #     being encoded (`Section 3.6`).\n-    #\n-    # .. _`Section 3.4.1.3.2`: http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2\n-    # .. _`Section 3.4.6`: http://tools.ietf.org/html/rfc5849#section-3.4.6\n-    base_string += utils.escape(normalized_encoded_request_parameters)\n-\n-    return base_string\n-\n-\n-def normalize_base_string_uri(uri):\n-    \"\"\"**Base String URI**\n-    Per `section 3.4.1.2`_ of the spec.\n-\n-    For example, the HTTP request::\n-\n-        GET /r%20v/X?id=123 HTTP/1.1\n-        Host: EXAMPLE.COM:80\n-\n-    is represented by the base string URI: \"http://example.com/r%20v/X\".\n-\n-    In another example, the HTTPS request::\n-\n-        GET /?q=1 HTTP/1.1\n-        Host: www.example.net:8080\n-\n-    is represented by the base string URI: \"https://www.example.net:8080/\".\n-\n-    .. _`section 3.4.1.2`: http://tools.ietf.org/html/rfc5849#section-3.4.1.2\n-    \"\"\"\n-    if not isinstance(uri, unicode):\n-        raise ValueError('uri must be a unicode object.')\n-\n-    # FIXME: urlparse does not support unicode\n-    scheme, netloc, path, params, query, fragment = urlparse.urlparse(uri)\n-\n-    # The scheme, authority, and path of the request resource URI `RFC3986`\n-    # are included by constructing an \"http\" or \"https\" URI representing\n-    # the request resource (without the query or fragment) as follows:\n-    #\n-    # .. _`RFC2616`: http://tools.ietf.org/html/rfc3986\n-\n-    # 1.  The scheme and host MUST be in lowercase.\n-    scheme = scheme.lower()\n-    netloc = netloc.lower()\n-\n-    # 2.  The host and port values MUST match the content of the HTTP\n-    #     request \"Host\" header field.\n-    # TODO: enforce this constraint\n-\n-    # 3.  The port MUST be included if it is not the default port for the\n-    #     scheme, and MUST be excluded if it is the default.  Specifically,\n-    #     the port MUST be excluded when making an HTTP request `RFC2616`_\n-    #     to port 80 or when making an HTTPS request `RFC2818`_ to port 443.\n-    #     All other non-default port numbers MUST be included.\n-    #\n-    # .. _`RFC2616`: http://tools.ietf.org/html/rfc2616\n-    # .. _`RFC2818`: http://tools.ietf.org/html/rfc2818\n-    default_ports = (\n-        (u'http', u'80'),\n-        (u'https', u'443'),\n-    )\n-    if u':' in netloc:\n-        host, port = netloc.split(u':', 1)\n-        if (scheme, port) in default_ports:\n-            netloc = host\n-\n-    return urlparse.urlunparse((scheme, netloc, path, u'', u'', u''))\n-\n-\n-# ** Request Parameters **\n-#\n-#    Per `section 3.4.1.3`_ of the spec.\n-#\n-#    In order to guarantee a consistent and reproducible representation of\n-#    the request parameters, the parameters are collected and decoded to\n-#    their original decoded form.  They are then sorted and encoded in a\n-#    particular manner that is often different from their original\n-#    encoding scheme, and concatenated into a single string.\n-#\n-#    .. _`section 3.4.1.3`: http://tools.ietf.org/html/rfc5849#section-3.4.1.3\n-\n-def collect_parameters(uri_query='', body=[], headers=None,\n-        exclude_oauth_signature=True):\n-    \"\"\"**Parameter Sources**\n-\n-    Parameters starting with `oauth_` will be unescaped.\n-\n-    Body parameters must be supplied as a dict, a list of 2-tuples, or a\n-    formencoded query string.\n-\n-    Headers must be supplied as a dict.\n-\n-    Per `section 3.4.1.3.1`_ of the spec.\n-\n-    For example, the HTTP request::\n-\n-        POST /request?b5=%3D%253D&a3=a&c%40=&a2=r%20b HTTP/1.1\n-        Host: example.com\n-        Content-Type: application/x-www-form-urlencoded\n-        Authorization: OAuth realm=\"Example\",\n-            oauth_consumer_key=\"9djdj82h48djs9d2\",\n-            oauth_token=\"kkk9d7dh3k39sjv7\",\n-            oauth_signature_method=\"HMAC-SHA1\",\n-            oauth_timestamp=\"137131201\",\n-            oauth_nonce=\"7d8f3e4a\",\n-            oauth_signature=\"djosJKDKJSD8743243%2Fjdk33klY%3D\"\n-\n-        c2&a3=2+q\n-\n-    contains the following (fully decoded) parameters used in the\n-    signature base sting::\n-\n-        +------------------------+------------------+\n-        |          Name          |       Value      |\n-        +------------------------+------------------+\n-        |           b5           |       =%3D       |\n-        |           a3           |         a        |\n-        |           c@           |                  |\n-        |           a2           |        r b       |\n-        |   oauth_consumer_key   | 9djdj82h48djs9d2 |\n-        |       oauth_token      | kkk9d7dh3k39sjv7 |\n-        | oauth_signature_method |     HMAC-SHA1    |\n-        |     oauth_timestamp    |     137131201    |\n-        |       oauth_nonce      |     7d8f3e4a     |\n-        |           c2           |                  |\n-        |           a3           |        2 q       |\n-        +------------------------+------------------+\n-\n-    Note that the value of \"b5\" is \"=%3D\" and not \"==\".  Both \"c@\" and\n-    \"c2\" have empty values.  While the encoding rules specified in this\n-    specification for the purpose of constructing the signature base\n-    string exclude the use of a \"+\" character (ASCII code 43) to\n-    represent an encoded space character (ASCII code 32), this practice\n-    is widely used in \"application/x-www-form-urlencoded\" encoded values,\n-    and MUST be properly decoded, as demonstrated by one of the \"a3\"\n-    parameter instances (the \"a3\" parameter is used twice in this\n-    request).\n-\n-    .. _`section 3.4.1.3.1`: http://tools.ietf.org/html/rfc5849#section-3.4.1.3.1\n-    \"\"\"\n-    headers = headers or {}\n-    params = []\n-\n-    # The parameters from the following sources are collected into a single\n-    # list of name/value pairs:\n-\n-    # *  The query component of the HTTP request URI as defined by\n-    #    `RFC3986, Section 3.4`_.  The query component is parsed into a list\n-    #    of name/value pairs by treating it as an\n-    #    \"application/x-www-form-urlencoded\" string, separating the names\n-    #    and values and decoding them as defined by\n-    #    `W3C.REC-html40-19980424`_, Section 17.13.4.\n-    #\n-    # .. _`RFC3986, Section 3.4`: http://tools.ietf.org/html/rfc3986#section-3.4\n-    # .. _`W3C.REC-html40-19980424`: http://tools.ietf.org/html/rfc5849#ref-W3C.REC-html40-19980424\n-    if uri_query:\n-        params.extend(urlparse.parse_qsl(uri_query, keep_blank_values=True))\n-\n-    # *  The OAuth HTTP \"Authorization\" header field (`Section 3.5.1`_) if\n-    #    present.  The header's content is parsed into a list of name/value\n-    #    pairs excluding the \"realm\" parameter if present.  The parameter\n-    #    values are decoded as defined by `Section 3.5.1`_.\n-    #\n-    # .. _`Section 3.5.1`: http://tools.ietf.org/html/rfc5849#section-3.5.1\n-    if headers:\n-        headers_lower = dict((k.lower(), v) for k, v in headers.items())\n-        authorization_header = headers_lower.get(u'authorization')\n-        if authorization_header is not None:\n-            params.extend([i for i in utils.parse_authorization_header(\n-                authorization_header) if i[0] != u'realm'])\n-\n-    # *  The HTTP request entity-body, but only if all of the following\n-    #    conditions are met:\n-    #     *  The entity-body is single-part.\n-    #\n-    #     *  The entity-body follows the encoding requirements of the\n-    #        \"application/x-www-form-urlencoded\" content-type as defined by\n-    #        `W3C.REC-html40-19980424`_.\n-\n-    #     *  The HTTP request entity-header includes the \"Content-Type\"\n-    #        header field set to \"application/x-www-form-urlencoded\".\n-    #\n-    # .._`W3C.REC-html40-19980424`: http://tools.ietf.org/html/rfc5849#ref-W3C.REC-html40-19980424\n-\n-    # TODO: enforce header param inclusion conditions\n-    bodyparams = extract_params(body) or []\n-    params.extend(bodyparams)\n-\n-    # ensure all oauth params are unescaped\n-    unescaped_params = []\n-    for k, v in params:\n-        if k.startswith(u'oauth_'):\n-            v = utils.unescape(v)\n-        unescaped_params.append((k, v))\n-\n-    # The \"oauth_signature\" parameter MUST be excluded from the signature\n-    # base string if present.\n-    if exclude_oauth_signature:\n-        unescaped_params = filter(lambda i: i[0] != u'oauth_signature',\n-            unescaped_params)\n-\n-    return unescaped_params\n-\n-\n-def normalize_parameters(params):\n-    \"\"\"**Parameters Normalization**\n-    Per `section 3.4.1.3.2`_ of the spec.\n-\n-    For example, the list of parameters from the previous section would\n-    be normalized as follows:\n-\n-    Encoded::\n-\n-    +------------------------+------------------+\n-    |          Name          |       Value      |\n-    +------------------------+------------------+\n-    |           b5           |     %3D%253D     |\n-    |           a3           |         a        |\n-    |          c%40          |                  |\n-    |           a2           |       r%20b      |\n-    |   oauth_consumer_key   | 9djdj82h48djs9d2 |\n-    |       oauth_token      | kkk9d7dh3k39sjv7 |\n-    | oauth_signature_method |     HMAC-SHA1    |\n-    |     oauth_timestamp    |     137131201    |\n-    |       oauth_nonce      |     7d8f3e4a     |\n-    |           c2           |                  |\n-    |           a3           |       2%20q      |\n-    +------------------------+------------------+\n-\n-    Sorted::\n-\n-    +------------------------+------------------+\n-    |          Name          |       Value      |\n-    +------------------------+------------------+\n-    |           a2           |       r%20b      |\n-    |           a3           |       2%20q      |\n-    |           a3           |         a        |\n-    |           b5           |     %3D%253D     |\n-    |          c%40          |                  |\n-    |           c2           |                  |\n-    |   oauth_consumer_key   | 9djdj82h48djs9d2 |\n-    |       oauth_nonce      |     7d8f3e4a     |\n-    | oauth_signature_method |     HMAC-SHA1    |\n-    |     oauth_timestamp    |     137131201    |\n-    |       oauth_token      | kkk9d7dh3k39sjv7 |\n-    +------------------------+------------------+\n-\n-    Concatenated Pairs::\n-\n-    +-------------------------------------+\n-    |              Name=Value             |\n-    +-------------------------------------+\n-    |               a2=r%20b              |\n-    |               a3=2%20q              |\n-    |                 a3=a                |\n-    |             b5=%3D%253D             |\n-    |                c%40=                |\n-    |                 c2=                 |\n-    | oauth_consumer_key=9djdj82h48djs9d2 |\n-    |         oauth_nonce=7d8f3e4a        |\n-    |   oauth_signature_method=HMAC-SHA1  |\n-    |      oauth_timestamp=137131201      |\n-    |     oauth_token=kkk9d7dh3k39sjv7    |\n-    +-------------------------------------+\n-\n-    and concatenated together into a single string (line breaks are for\n-    display purposes only)::\n-\n-        a2=r%20b&a3=2%20q&a3=a&b5=%3D%253D&c%40=&c2=&oauth_consumer_key=9dj\n-        dj82h48djs9d2&oauth_nonce=7d8f3e4a&oauth_signature_method=HMAC-SHA1\n-        &oauth_timestamp=137131201&oauth_token=kkk9d7dh3k39sjv7\n-\n-    .. _`section 3.4.1.3.2`: http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2\n-    \"\"\"\n-\n-    # The parameters collected in `Section 3.4.1.3`_ are normalized into a\n-    # single string as follows:\n-    #\n-    # .. _`Section 3.4.1.3`: http://tools.ietf.org/html/rfc5849#section-3.4.1.3\n-\n-    # 1.  First, the name and value of each parameter are encoded\n-    #     (`Section 3.6`_).\n-    #\n-    # .. _`Section 3.6`: http://tools.ietf.org/html/rfc5849#section-3.6\n-    key_values = [(utils.escape(k), utils.escape(v)) for k, v in params]\n-\n-    # 2.  The parameters are sorted by name, using ascending byte value\n-    #     ordering.  If two or more parameters share the same name, they\n-    #     are sorted by their value.\n-    key_values.sort()\n-\n-    # 3.  The name of each parameter is concatenated to its corresponding\n-    #     value using an \"=\" character (ASCII code 61) as a separator, even\n-    #     if the value is empty.\n-    parameter_parts = [u'{0}={1}'.format(k, v) for k, v in key_values]\n-\n-    # 4.  The sorted name/value pairs are concatenated together into a\n-    #     single string by using an \"&\" character (ASCII code 38) as\n-    #     separator.\n-    return u'&'.join(parameter_parts)\n-\n-\n-def sign_hmac_sha1(base_string, client_secret, resource_owner_secret):\n-    \"\"\"**HMAC-SHA1**\n-\n-    The \"HMAC-SHA1\" signature method uses the HMAC-SHA1 signature\n-    algorithm as defined in `RFC2104`_::\n-\n-        digest = HMAC-SHA1 (key, text)\n-\n-    Per `section 3.4.2`_ of the spec.\n-\n-    .. _`RFC2104`: http://tools.ietf.org/html/rfc2104\n-    .. _`section 3.4.2`: http://tools.ietf.org/html/rfc5849#section-3.4.2\n-    \"\"\"\n-\n-    # The HMAC-SHA1 function variables are used in following way:\n-\n-    # text is set to the value of the signature base string from\n-    # `Section 3.4.1.1`_.\n-    #\n-    # .. _`Section 3.4.1.1`: http://tools.ietf.org/html/rfc5849#section-3.4.1.1\n-    text = base_string\n-\n-    # key is set to the concatenated values of:\n-    # 1.  The client shared-secret, after being encoded (`Section 3.6`_).\n-    #\n-    # .. _`Section 3.6`: http://tools.ietf.org/html/rfc5849#section-3.6\n-    key = utils.escape(client_secret or u'')\n-\n-    # 2.  An \"&\" character (ASCII code 38), which MUST be included\n-    #     even when either secret is empty.\n-    key += u'&'\n-\n-    # 3.  The token shared-secret, after being encoded (`Section 3.6`_).\n-    #\n-    # .. _`Section 3.6`: http://tools.ietf.org/html/rfc5849#section-3.6\n-    key += utils.escape(resource_owner_secret or u'')\n-\n-    # FIXME: HMAC does not support unicode!\n-    key_utf8 = key.encode('utf-8')\n-    text_utf8 = text.encode('utf-8')\n-    signature = hmac.new(key_utf8, text_utf8, hashlib.sha1)\n-\n-    # digest  is used to set the value of the \"oauth_signature\" protocol\n-    #         parameter, after the result octet string is base64-encoded\n-    #         per `RFC2045, Section 6.8`.\n-    #\n-    # .. _`RFC2045, Section 6.8`: http://tools.ietf.org/html/rfc2045#section-6.8\n-    return binascii.b2a_base64(signature.digest())[:-1].decode('utf-8')\n-\n-\n-def sign_rsa_sha1(base_string, rsa_private_key):\n-    \"\"\"**RSA-SHA1**\n-\n-    Per `section 3.4.3`_ of the spec.\n-\n-    The \"RSA-SHA1\" signature method uses the RSASSA-PKCS1-v1_5 signature\n-    algorithm as defined in `RFC3447, Section 8.2`_ (also known as\n-    PKCS#1), using SHA-1 as the hash function for EMSA-PKCS1-v1_5.  To\n-    use this method, the client MUST have established client credentials\n-    with the server that included its RSA public key (in a manner that is\n-    beyond the scope of this specification).\n-\n-    NOTE: this method requires the python-rsa library.\n-\n-    .. _`section 3.4.3`: http://tools.ietf.org/html/rfc5849#section-3.4.3\n-    .. _`RFC3447, Section 8.2`: http://tools.ietf.org/html/rfc3447#section-8.2\n-\n-    \"\"\"\n-    # TODO: finish RSA documentation\n-    from Crypto.PublicKey import RSA\n-    from Crypto.Signature import PKCS1_v1_5\n-    from Crypto.Hash import SHA\n-    key = RSA.importKey(rsa_private_key)\n-    h = SHA.new(base_string)\n-    p = PKCS1_v1_5.new(key)\n-    return binascii.b2a_base64(p.sign(h))[:-1].decode('utf-8')\n-\n-\n-def sign_plaintext(client_secret, resource_owner_secret):\n-    \"\"\"Sign a request using plaintext.\n-\n-    Per `section 3.4.4`_ of the spec.\n-\n-    The \"PLAINTEXT\" method does not employ a signature algorithm.  It\n-    MUST be used with a transport-layer mechanism such as TLS or SSL (or\n-    sent over a secure channel with equivalent protections).  It does not\n-    utilize the signature base string or the \"oauth_timestamp\" and\n-    \"oauth_nonce\" parameters.\n-\n-    .. _`section 3.4.4`: http://tools.ietf.org/html/rfc5849#section-3.4.4\n-\n-    \"\"\"\n-\n-    # The \"oauth_signature\" protocol parameter is set to the concatenated\n-    # value of:\n-\n-    # 1.  The client shared-secret, after being encoded (`Section 3.6`_).\n-    #\n-    # .. _`Section 3.6`: http://tools.ietf.org/html/rfc5849#section-3.6\n-    signature = utils.escape(client_secret or u'')\n-\n-    # 2.  An \"&\" character (ASCII code 38), which MUST be included even\n-    #     when either secret is empty.\n-    signature += u'&'\n-\n-    # 3.  The token shared-secret, after being encoded (`Section 3.6`_).\n-    #\n-    # .. _`Section 3.6`: http://tools.ietf.org/html/rfc5849#section-3.6\n-    signature += utils.escape(resource_owner_secret or u'')\n-\n-    return signature\n-\n-\n-def verify_hmac_sha1(request, client_secret=None, \n-    resource_owner_secret=None):\n-    \"\"\"Verify a HMAC-SHA1 signature.\n-\n-    Per `section 3.4`_ of the spec.\n-\n-    .. _`section 3.4`: http://tools.ietf.org/html/rfc5849#section-3.4\n-    \"\"\"\n-    norm_params = normalize_parameters(request.params)\n-    uri = normalize_base_string_uri(request.uri)\n-    base_string = construct_base_string(request.http_method, uri, norm_params)\n-    signature = sign_hmac_sha1(base_string, client_secret,\n-        resource_owner_secret)\n-    return safe_string_equals(signature, request.signature)\n-\n-\n-def verify_rsa_sha1(request, rsa_public_key):\n-    \"\"\"Verify a RSASSA-PKCS #1 v1.5 base64 encoded signature.\n-\n-    Per `section 3.4.3`_ of the spec.\n-\n-    Note this method requires the PyCrypto library.\n-\n-    .. _`section 3.4.3`: http://tools.ietf.org/html/rfc5849#section-3.4.3\n-\n-    \"\"\"\n-    from Crypto.PublicKey import RSA\n-    from Crypto.Signature import PKCS1_v1_5\n-    from Crypto.Hash import SHA\n-    key = RSA.importKey(rsa_public_key)\n-    norm_params = normalize_parameters(request.params)\n-    uri = normalize_base_string_uri(request.uri)\n-    message = construct_base_string(request.http_method, uri, norm_params)\n-    h = SHA.new(message)\n-    p = PKCS1_v1_5.new(key)\n-    sig = binascii.a2b_base64(request.signature)\n-    return p.verify(h, sig)\n-\n-\n-def verify_plaintext(request, client_secret=None, resource_owner_secret=None):\n-    \"\"\"Verify a PLAINTEXT signature.\n-\n-    Per `section 3.4`_ of the spec.\n-\n-    .. _`section 3.4`: http://tools.ietf.org/html/rfc5849#section-3.4\n-    \"\"\"\n-    signature = sign_plaintext(client_secret, resource_owner_secret)\n-    return safe_string_equals(signature, request.signature)\n\n@@ -1,99 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-oauthlib.utils\n-~~~~~~~~~~~~~~\n-\n-This module contains utility methods used by various parts of the OAuth\n-spec.\n-\"\"\"\n-\n-import string\n-import urllib2\n-\n-from oauthlib.common import quote, unquote\n-\n-UNICODE_ASCII_CHARACTER_SET = (string.ascii_letters.decode('ascii') +\n-    string.digits.decode('ascii'))\n-\n-\n-def filter_params(target):\n-    \"\"\"Decorator which filters params to remove non-oauth_* parameters\n-\n-    Assumes the decorated method takes a params dict or list of tuples as its\n-    first argument.\n-    \"\"\"\n-    def wrapper(params, *args, **kwargs):\n-        params = filter_oauth_params(params)\n-        return target(params, *args, **kwargs)\n-\n-    wrapper.__doc__ = target.__doc__\n-    return wrapper\n-\n-\n-def filter_oauth_params(params):\n-    \"\"\"Removes all non oauth parameters from a dict or a list of params.\"\"\"\n-    is_oauth = lambda kv: kv[0].startswith(u\"oauth_\")\n-    if isinstance(params, dict):\n-        return filter(is_oauth, params.items())\n-    else:\n-        return filter(is_oauth, params)\n-\n-\n-def escape(u):\n-    \"\"\"Escape a unicode string in an OAuth-compatible fashion.\n-\n-    Per `section 3.6`_ of the spec.\n-\n-    .. _`section 3.6`: http://tools.ietf.org/html/rfc5849#section-3.6\n-\n-    \"\"\"\n-    if not isinstance(u, unicode):\n-        raise ValueError('Only unicode objects are escapable.')\n-    # Letters, digits, and the characters '_.-' are already treated as safe\n-    # by urllib.quote(). We need to add '~' to fully support rfc5849.\n-    return quote(u, safe='~')\n-\n-\n-def unescape(u):\n-    if not isinstance(u, unicode):\n-        raise ValueError('Only unicode objects are unescapable.')\n-    return unquote(u)\n-\n-\n-def urlencode(query):\n-    \"\"\"Encode a sequence of two-element tuples or dictionary into a URL query string.\n-\n-    Operates using an OAuth-safe escape() method, in contrast to urllib.urlencode.\n-    \"\"\"\n-    # Convert dictionaries to list of tuples\n-    if isinstance(query, dict):\n-        query = query.items()\n-    return u\"&\".join([u'='.join([escape(k), escape(v)]) for k, v in query])\n-\n-\n-def parse_keqv_list(l):\n-    \"\"\"A unicode-safe version of urllib2.parse_keqv_list\"\"\"\n-    encoded_list = [u.encode('utf-8') for u in l]\n-    encoded_parsed = urllib2.parse_keqv_list(encoded_list)\n-    return dict((k.decode('utf-8'),\n-        v.decode('utf-8')) for k, v in encoded_parsed.items())\n-\n-\n-def parse_http_list(u):\n-    \"\"\"A unicode-safe version of urllib2.parse_http_list\"\"\"\n-    encoded_str = u.encode('utf-8')\n-    encoded_list = urllib2.parse_http_list(encoded_str)\n-    return [s.decode('utf-8') for s in encoded_list]\n-\n-\n-def parse_authorization_header(authorization_header):\n-    \"\"\"Parse an OAuth authorization header into a list of 2-tuples\"\"\"\n-    auth_scheme = u'OAuth '\n-    if authorization_header.startswith(auth_scheme):\n-        authorization_header = authorization_header.replace(auth_scheme, u'', 1)\n-    items = parse_http_list(authorization_header)\n-    try:\n-        return parse_keqv_list(items).items()\n-    except ValueError:\n-        raise ValueError('Malformed authorization header')\n\n@@ -1,13 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from __future__ import absolute_import\n-\n-\"\"\"\n-oauthlib.oauth2\n-~~~~~~~~~~~~~~\n-\n-This module is a wrapper for the most recent implementation of OAuth 2.0 Client\n-and Server classes.\n-\"\"\"\n-\n-from .draft25 import Client, Server\n-\n\n@@ -1,497 +0,0 @@\n-\"\"\"\n-oauthlib.oauth2.draft_25\n-~~~~~~~~~~~~~~\n-\n-This module is an implementation of various logic needed\n-for signing and checking OAuth 2.0 draft 25 requests.\n-\"\"\"\n-from tokens import prepare_bearer_uri, prepare_bearer_headers\n-from tokens import prepare_bearer_body, prepare_mac_header\n-from parameters import prepare_grant_uri, prepare_token_request\n-from parameters import parse_authorization_code_response\n-from parameters import parse_implicit_response, parse_token_response\n-\n-\n-AUTH_HEADER = u'auth_header'\n-URI_QUERY = u'query'\n-BODY = u'body'\n-\n-\n-class Client(object):\n-\n-    def __init__(self, client_id,\n-            default_redirect_uri=None,\n-            token_type=None,\n-            access_token=None,\n-            refresh_token=None):\n-        \"\"\"Initialize a client with commonly used attributes.\"\"\"\n-\n-        self.client_id = client_id\n-        self.default_redirect_uri = default_redirect_uri\n-        self.token_type = token_type\n-        self.access_token = access_token\n-        self.refresh_token = refresh_token\n-        self.token_types = {\n-            u'bearer': self._add_bearer_token,\n-            u'mac': self._add_mac_token\n-        }\n-\n-    def add_token(self, uri, http_method=u'GET', body=None, headers=None,\n-            token_placement=AUTH_HEADER):\n-        \"\"\"Add token to the request uri, body or authorization header.\n-\n-        The access token type provides the client with the information\n-        required to successfully utilize the access token to make a protected\n-        resource request (along with type-specific attributes).  The client\n-        MUST NOT use an access token if it does not understand the token\n-        type.\n-\n-        For example, the \"bearer\" token type defined in\n-        [I-D.ietf-oauth-v2-bearer] is utilized by simply including the access\n-        token string in the request:\n-\n-        GET /resource/1 HTTP/1.1\n-        Host: example.com\n-        Authorization: Bearer mF_9.B5f-4.1JqM\n-\n-        while the \"mac\" token type defined in [I-D.ietf-oauth-v2-http-mac] is\n-        utilized by issuing a MAC key together with the access token which is\n-        used to sign certain components of the HTTP requests:\n-\n-        GET /resource/1 HTTP/1.1\n-        Host: example.com\n-        Authorization: MAC id=\"h480djs93hd8\",\n-                            nonce=\"274312:dj83hs9s\",\n-                            mac=\"kDZvddkndxvhGRXZhvuDjEWhGeE=\"\n-\n-        .. _`I-D.ietf-oauth-v2-bearer`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#ref-I-D.ietf-oauth-v2-bearer\n-        .. _`I-D.ietf-oauth-v2-http-mac`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#ref-I-D.ietf-oauth-v2-http-mac\n-        \"\"\"\n-        return self.token_types[self.token_type](uri, http_method, body,\n-                    headers, token_placement)\n-\n-    def prepare_refresh_body(self, body=u'', refresh_token=None, scope=None):\n-        \"\"\"Prepare an access token request, using a refresh token.\n-\n-        If the authorization server issued a refresh token to the client, the\n-        client makes a refresh request to the token endpoint by adding the\n-        following parameters using the \"application/x-www-form-urlencoded\"\n-        format in the HTTP request entity-body:\n-\n-        grant_type\n-                REQUIRED.  Value MUST be set to \"refresh_token\".\n-        refresh_token\n-                REQUIRED.  The refresh token issued to the client.\n-        scope\n-                OPTIONAL.  The scope of the access request as described by\n-                Section 3.3.  The requested scope MUST NOT include any scope\n-                not originally granted by the resource owner, and if omitted is\n-                treated as equal to the scope originally granted by the\n-                resource owner.\n-        \"\"\"\n-        refresh_token = refresh_token or self.refresh_token\n-        return prepare_token_request(u'refresh_token', body=body, scope=scope,\n-                refresh_token=refresh_token)\n-\n-    def _add_bearer_token(self, uri, http_method=u'GET', body=None,\n-            headers=None, token_placement=AUTH_HEADER):\n-        \"\"\"Add a bearer token to the request uri, body or authorization header.\"\"\"\n-        if token_placement == AUTH_HEADER:\n-            headers = prepare_bearer_headers(self.token, headers)\n-\n-        if token_placement == URI_QUERY:\n-            uri = prepare_bearer_uri(self.token, uri)\n-\n-        if token_placement == BODY:\n-            body = prepare_bearer_body(self.token, body)\n-\n-        return uri, headers, body\n-\n-    def _add_mac_token(self, uri, http_method=u'GET', body=None,\n-            headers=None, token_placement=AUTH_HEADER):\n-        \"\"\"Add a MAC token to the request authorization header.\"\"\"\n-        headers = prepare_mac_header(self.token, uri, self.key, http_method,\n-                        headers=headers, body=body, ext=self.ext,\n-                        hash_algorithm=self.hash_algorithm)\n-        return uri, headers, body\n-\n-    def _populate_attributes(self, response):\n-        \"\"\"Add commonly used values such as access_token to self.\"\"\"\n-\n-        if u'access_token' in response:\n-            self.access_token = response.get(u'access_token')\n-\n-        if u'refresh_token' in response:\n-            self.refresh_token = response.get(u'refresh_token')\n-\n-        if u'token_type' in response:\n-            self.token_type = response.get(u'token_type')\n-\n-        if u'expires_in' in response:\n-            self.expires_in = response.get(u'expires_in')\n-\n-        if u'code' in response:\n-            self.code = response.get(u'code')\n-\n-    def prepare_request_uri(self, *args, **kwargs):\n-        \"\"\"Abstract method used to create request URIs.\"\"\"\n-        raise NotImplementedError(\"Must be implemented by inheriting classes.\")\n-\n-    def prepare_request_body(self, *args, **kwargs):\n-        \"\"\"Abstract method used to create request bodies.\"\"\"\n-        raise NotImplementedError(\"Must be implemented by inheriting classes.\")\n-\n-    def parse_request_uri_response(self, *args, **kwargs):\n-        \"\"\"Abstract method used to parse redirection responses.\"\"\"\n-\n-    def parse_request_body_response(self, *args, **kwargs):\n-        \"\"\"Abstract method used to parse JSON responses.\"\"\"\n-\n-\n-class WebApplicationClient(Client):\n-    \"\"\"A client utilizing the authorization code grant workflow.\n-\n-    A web application is a confidential client running on a web\n-    server.  Resource owners access the client via an HTML user\n-    interface rendered in a user-agent on the device used by the\n-    resource owner.  The client credentials as well as any access\n-    token issued to the client are stored on the web server and are\n-    not exposed to or accessible by the resource owner.\n-\n-    The authorization code grant type is used to obtain both access\n-    tokens and refresh tokens and is optimized for confidential clients.\n-    As a redirection-based flow, the client must be capable of\n-    interacting with the resource owner's user-agent (typically a web\n-    browser) and capable of receiving incoming requests (via redirection)\n-    from the authorization server.\n-    \"\"\"\n-\n-    def prepare_request_uri(self, uri, redirect_uri=None, scope=None,\n-            state=None, **kwargs):\n-        \"\"\"Prepare the authorization code request URI\n-\n-        The client constructs the request URI by adding the following\n-        parameters to the query component of the authorization endpoint URI\n-        using the \"application/x-www-form-urlencoded\" format as defined by\n-        [`W3C.REC-html401-19991224`_]:\n-\n-        response_type\n-                REQUIRED.  Value MUST be set to \"code\".\n-        client_id\n-                REQUIRED.  The client identifier as described in `Section 2.2`_.\n-        redirect_uri\n-                OPTIONAL.  As described in `Section 3.1.2`_.\n-        scope\n-                OPTIONAL.  The scope of the access request as described by\n-                `Section 3.3`_.\n-        state\n-                RECOMMENDED.  An opaque value used by the client to maintain\n-                state between the request and callback.  The authorization\n-                server includes this value when redirecting the user-agent back\n-                to the client.  The parameter SHOULD be used for preventing\n-                cross-site request forgery as described in `Section 10.12`_.\n-\n-        .. _`W3C.REC-html401-19991224`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#ref-W3C.REC-html401-19991224\n-        .. _`Section 2.2`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-2.2\n-        .. _`Section 3.1.2`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-3.1.2\n-        .. _`Section 3.3`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-3.3\n-        .. _`Section 10.12`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-10.12\n-        \"\"\"\n-        redirect_uri = redirect_uri or self.default_redirect_uri\n-        return prepare_grant_uri(uri, self.client_id, u'code',\n-                redirect_uri=redirect_uri, scope=scope, state=state, **kwargs)\n-\n-    def prepare_request_body(self, code, body=u'', redirect_uri=None, **kwargs):\n-        \"\"\"Prepare the access token request body.\n-\n-        The client makes a request to the token endpoint by adding the\n-        following parameters using the \"application/x-www-form-urlencoded\"\n-        format in the HTTP request entity-body:\n-\n-        grant_type\n-                REQUIRED.  Value MUST be set to \"authorization_code\".\n-        code\n-                REQUIRED.  The authorization code received from the\n-                authorization server.\n-        redirect_uri\n-                REQUIRED, if the \"redirect_uri\" parameter was included in the\n-                authorization request as described in Section 4.1.1, and their\n-                values MUST be identical.\n-\n-        .. _`Section 4.1.1`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-4.1.1\n-        \"\"\"\n-        redirect_uri = redirect_uri or self.default_redirect_uri\n-        code = code or self.code\n-        return prepare_token_request(u'authorization_code', code=code, body=body,\n-                                         redirect_uri=redirect_uri, **kwargs)\n-\n-    def parse_request_uri_response(self, uri, state=None):\n-        \"\"\"Parse the URI query for code and state.\n-\n-        If the resource owner grants the access request, the authorization\n-        server issues an authorization code and delivers it to the client by\n-        adding the following parameters to the query component of the\n-        redirection URI using the \"application/x-www-form-urlencoded\" format:\n-\n-        code\n-                REQUIRED.  The authorization code generated by the\n-                authorization server.  The authorization code MUST expire\n-                shortly after it is issued to mitigate the risk of leaks.  A\n-                maximum authorization code lifetime of 10 minutes is\n-                RECOMMENDED.  The client MUST NOT use the authorization code\n-                more than once.  If an authorization code is used more than\n-                once, the authorization server MUST deny the request and SHOULD\n-                revoke (when possible) all tokens previously issued based on\n-                that authorization code.  The authorization code is bound to\n-                the client identifier and redirection URI.\n-        state\n-                REQUIRED if the \"state\" parameter was present in the client\n-                authorization request.  The exact value received from the\n-                client.\n-        \"\"\"\n-        response = parse_authorization_code_response(uri, state=state)\n-        self._populate_attributes(response)\n-        return response\n-\n-    def parse_request_body_response(self, body, scope=None):\n-        \"\"\"Parse the JSON response body.\n-\n-        If the access token request is valid and authorized, the\n-        authorization server issues an access token and optional refresh\n-        token as described in `Section 5.1`_.  If the request client\n-        authentication failed or is invalid, the authorization server returns\n-        an error response as described in `Section 5.2`_.\n-\n-        .. `Section 5.1`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-5.1\n-        .. `Section 5.2`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-5.2\n-        \"\"\"\n-        response = parse_token_response(body, scope=scope)\n-        self._populate_attributes(response)\n-        return response\n-\n-\n-class UserAgentClient(Client):\n-    \"\"\"A public client utilizing the implicit code grant workflow.\n-\n-    A user-agent-based application is a public client in which the\n-    client code is downloaded from a web server and executes within a\n-    user-agent (e.g. web browser) on the device used by the resource\n-    owner.  Protocol data and credentials are easily accessible (and\n-    often visible) to the resource owner.  Since such applications\n-    reside within the user-agent, they can make seamless use of the\n-    user-agent capabilities when requesting authorization.\n-\n-    The implicit grant type is used to obtain access tokens (it does not\n-    support the issuance of refresh tokens) and is optimized for public\n-    clients known to operate a particular redirection URI.  These clients\n-    are typically implemented in a browser using a scripting language\n-    such as JavaScript.\n-\n-    As a redirection-based flow, the client must be capable of\n-    interacting with the resource owner's user-agent (typically a web\n-    browser) and capable of receiving incoming requests (via redirection)\n-    from the authorization server.\n-\n-    Unlike the authorization code grant type in which the client makes\n-    separate requests for authorization and access token, the client\n-    receives the access token as the result of the authorization request.\n-\n-    The implicit grant type does not include client authentication, and\n-    relies on the presence of the resource owner and the registration of\n-    the redirection URI.  Because the access token is encoded into the\n-    redirection URI, it may be exposed to the resource owner and other\n-    applications residing on the same device.\n-    \"\"\"\n-\n-    def prepare_request_uri(self, uri, redirect_uri=None, scope=None,\n-            state=None, **kwargs):\n-        \"\"\"Prepare the implicit grant request URI.\n-\n-        The client constructs the request URI by adding the following\n-        parameters to the query component of the authorization endpoint URI\n-        using the \"application/x-www-form-urlencoded\" format:\n-\n-        response_type\n-                REQUIRED.  Value MUST be set to \"token\".\n-        client_id\n-                REQUIRED.  The client identifier as described in Section 2.2.\n-        redirect_uri\n-                OPTIONAL.  As described in Section 3.1.2.\n-        scope\n-                OPTIONAL.  The scope of the access request as described by\n-                Section 3.3.\n-        state\n-                RECOMMENDED.  An opaque value used by the client to maintain\n-                state between the request and callback.  The authorization\n-                server includes this value when redirecting the user-agent back\n-                to the client.  The parameter SHOULD be used for preventing\n-                cross-site request forgery as described in Section 10.12.\n-        \"\"\"\n-        redirect_uri = redirect_uri or self.default_redirect_uri\n-        return prepare_grant_uri(uri, self.client_id, u'token',\n-                redirect_uri=redirect_uri, state=state, scope=scope, **kwargs)\n-\n-    def parse_request_uri_response(self, uri, state=None, scope=None):\n-        \"\"\"Parse the response URI fragment.\n-\n-        If the resource owner grants the access request, the authorization\n-        server issues an access token and delivers it to the client by adding\n-        the following parameters to the fragment component of the redirection\n-        URI using the \"application/x-www-form-urlencoded\" format:\n-\n-        access_token\n-                REQUIRED.  The access token issued by the authorization server.\n-        token_type\n-                REQUIRED.  The type of the token issued as described in\n-                `Section 7.1`_.  Value is case insensitive.\n-        expires_in\n-                RECOMMENDED.  The lifetime in seconds of the access token.  For\n-                example, the value \"3600\" denotes that the access token will\n-                expire in one hour from the time the response was generated.\n-                If omitted, the authorization server SHOULD provide the\n-                expiration time via other means or document the default value.\n-        scope\n-                OPTIONAL, if identical to the scope requested by the client,\n-                otherwise REQUIRED.  The scope of the access token as described\n-                by `Section 3.3`_.\n-        state\n-                REQUIRED if the \"state\" parameter was present in the client\n-                authorization request.  The exact value received from the\n-                client.\n-\n-        .. _`Section 7.1`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-7.1\n-        .. _`Section 3.3`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-3.3\n-        \"\"\"\n-        response = parse_implicit_response(uri, state=state, scope=scope)\n-        self._populate_attributes(response)\n-        return response\n-\n-\n-class NativeApplicationClient(Client):\n-    \"\"\"A public client utilizing the client credentials grant workflow.\n-\n-    A native application is a public client installed and executed on\n-    the device used by the resource owner.  Protocol data and\n-    credentials are accessible to the resource owner.  It is assumed\n-    that any client authentication credentials included in the\n-    application can be extracted.  On the other hand, dynamically\n-    issued credentials such as access tokens or refresh tokens can\n-    receive an acceptable level of protection.  At a minimum, these\n-    credentials are protected from hostile servers with which the\n-    application may interact with.  On some platforms these\n-    credentials might be protected from other applications residing on\n-    the same device.\n-\n-    The client can request an access token using only its client\n-    credentials (or other supported means of authentication) when the\n-    client is requesting access to the protected resources under its\n-    control, or those of another resource owner which has been previously\n-    arranged with the authorization server (the method of which is beyond\n-    the scope of this specification).\n-\n-    The client credentials grant type MUST only be used by confidential\n-    clients.\n-\n-    Since the client authentication is used as the authorization grant,\n-    no additional authorization request is needed.\n-    \"\"\"\n-\n-    def prepare_request_body(self, body=u'', scope=None, **kwargs):\n-        \"\"\"Add the client credentials to the request body.\n-\n-        The client makes a request to the token endpoint by adding the\n-        following parameters using the \"application/x-www-form-urlencoded\"\n-        format in the HTTP request entity-body:\n-\n-        grant_type\n-                REQUIRED.  Value MUST be set to \"client_credentials\".\n-        scope\n-                OPTIONAL.  The scope of the access request as described by\n-                `Section 3.3`_.\n-\n-        .. _`Section 3.3`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-3.3\n-        \"\"\"\n-        return prepare_token_request(u'client_credentials', body=body,\n-                                     scope=scope, **kwargs)\n-\n-    def parse_request_body_response(self, body, scope=None):\n-        \"\"\"Parse the JSON response body.\n-\n-        If the access token request is valid and authorized, the\n-        authorization server issues an access token as described in\n-        `Section 5.1`_.  A refresh token SHOULD NOT be included.  If the request\n-        failed client authentication or is invalid, the authorization server\n-        returns an error response as described in `Section 5.2`_.\n-\n-        .. `Section 5.1`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-5.1\n-        .. `Section 5.2`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-5.2\n-        \"\"\"\n-        response = parse_token_response(body, scope=scope)\n-        self._populate_attributes(response)\n-        return response\n-\n-\n-class PasswordCredentialsClient(Client):\n-    \"\"\"A public client using the resource owner password and username directly.\n-\n-    The resource owner password credentials grant type is suitable in\n-    cases where the resource owner has a trust relationship with the\n-    client, such as the device operating system or a highly privileged\n-    application.  The authorization server should take special care when\n-    enabling this grant type, and only allow it when other flows are not\n-    viable.\n-\n-    The grant type is suitable for clients capable of obtaining the\n-    resource owner's credentials (username and password, typically using\n-    an interactive form).  It is also used to migrate existing clients\n-    using direct authentication schemes such as HTTP Basic or Digest\n-    authentication to OAuth by converting the stored credentials to an\n-    access token.\n-\n-    The method through which the client obtains the resource owner\n-    credentials is beyond the scope of this specification.  The client\n-    MUST discard the credentials once an access token has been obtained.\n-    \"\"\"\n-\n-    def prepare_request_body(self, username, password, body=u'', scope=None,\n-            **kwargs):\n-        \"\"\"Add the resource owner password and username to the request body.\n-\n-        The client makes a request to the token endpoint by adding the\n-        following parameters using the \"application/x-www-form-urlencoded\"\n-        format in the HTTP request entity-body:\n-\n-        grant_type\n-                REQUIRED.  Value MUST be set to \"password\".\n-        username\n-                REQUIRED.  The resource owner username.\n-        password\n-                REQUIRED.  The resource owner password.\n-        scope\n-                OPTIONAL.  The scope of the access request as described by\n-                `Section 3.3`_.\n-\n-        .. _`Section 3.3`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-3.3\n-        \"\"\"\n-        return prepare_token_request(u'password', body=body, username=username,\n-                password=password, scope=scope, **kwargs)\n-\n-    def parse_request_body_response(self, body, scope=None):\n-        \"\"\"Parse the JSON response body.\n-\n-        If the access token request is valid and authorized, the\n-        authorization server issues an access token and optional refresh\n-        token as described in `Section 5.1`_.  If the request failed client\n-        authentication or is invalid, the authorization server returns an\n-        error response as described in `Section 5.2`_.\n-\n-        .. `Section 5.1`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-5.1\n-        .. `Section 5.2`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-5.2\n-        \"\"\"\n-        response = parse_token_response(body, scope=scope)\n-        self._populate_attributes(response)\n-        return response\n-\n-\n-class Server(object):\n-    pass\n\n@@ -1,256 +0,0 @@\n-\"\"\"\n-oauthlib.oauth2_draft28.parameters\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-This module contains methods related to `Section 4`_ of the OAuth 2 draft.\n-\n-.. _`Section 4`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-4\n-\"\"\"\n-\n-import json\n-import urlparse\n-from oauthlib.common import add_params_to_uri, add_params_to_qs\n-\n-\n-def prepare_grant_uri(uri, client_id, response_type, redirect_uri=None,\n-            scope=None, state=None, **kwargs):\n-    \"\"\"Prepare the authorization grant request URI.\n-\n-    The client constructs the request URI by adding the following\n-    parameters to the query component of the authorization endpoint URI\n-    using the \"application/x-www-form-urlencoded\" format as defined by\n-    [W3C.REC-html401-19991224]:\n-\n-    response_type\n-            REQUIRED.  Value MUST be set to \"code\".\n-    client_id\n-            REQUIRED.  The client identifier as described in `Section 2.2`_.\n-    redirect_uri\n-            OPTIONAL.  As described in `Section 3.1.2`_.\n-    scope\n-            OPTIONAL.  The scope of the access request as described by\n-            `Section 3.3`_.\n-    state\n-            RECOMMENDED.  An opaque value used by the client to maintain\n-            state between the request and callback.  The authorization\n-            server includes this value when redirecting the user-agent back\n-            to the client.  The parameter SHOULD be used for preventing\n-            cross-site request forgery as described in `Section 10.12`_.\n-\n-    GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz\n-        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\n-    Host: server.example.com\n-\n-    .. _`W3C.REC-html401-19991224`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#ref-W3C.REC-html401-19991224\n-    .. _`Section 2.2`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-2.2\n-    .. _`Section 3.1.2`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-3.1.2\n-    .. _`Section 3.3`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-3.3\n-    .. _`section 10.12`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-10.12\n-    \"\"\"\n-    params = [((u'response_type', response_type)),\n-              ((u'client_id', client_id))]\n-\n-    if redirect_uri:\n-        params.append((u'redirect_uri', redirect_uri))\n-    if scope:\n-        params.append((u'scope', scope))\n-    if state:\n-        params.append((u'state', state))\n-\n-    for k in kwargs:\n-        params.append((unicode(k), kwargs[k]))\n-\n-    return add_params_to_uri(uri, params)\n-\n-\n-def prepare_token_request(grant_type, body=u'', **kwargs):\n-    \"\"\"Prepare the access token request.\n-\n-    The client makes a request to the token endpoint by adding the\n-    following parameters using the \"application/x-www-form-urlencoded\"\n-    format in the HTTP request entity-body:\n-\n-    grant_type\n-            REQUIRED.  Value MUST be set to \"authorization_code\".\n-    code\n-            REQUIRED.  The authorization code received from the\n-            authorization server.\n-    redirect_uri\n-            REQUIRED, if the \"redirect_uri\" parameter was included in the\n-            authorization request as described in `Section 4.1.1`_, and their\n-            values MUST be identical.\n-\n-    grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA\n-    &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\n-\n-    .. _`Section 4.1.1`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-4.1.1\n-    \"\"\"\n-    params = [(u'grant_type', grant_type)]\n-    for k in kwargs:\n-        params.append((unicode(k), kwargs[k]))\n-\n-    return add_params_to_qs(body, params)\n-\n-\n-def parse_authorization_code_response(uri, state=None):\n-    \"\"\"Parse authorization grant response URI into a dict.\n-\n-    If the resource owner grants the access request, the authorization\n-    server issues an authorization code and delivers it to the client by\n-    adding the following parameters to the query component of the\n-    redirection URI using the \"application/x-www-form-urlencoded\" format:\n-\n-    code\n-            REQUIRED.  The authorization code generated by the\n-            authorization server.  The authorization code MUST expire\n-            shortly after it is issued to mitigate the risk of leaks.  A\n-            maximum authorization code lifetime of 10 minutes is\n-            RECOMMENDED.  The client MUST NOT use the authorization code\n-            more than once.  If an authorization code is used more than\n-            once, the authorization server MUST deny the request and SHOULD\n-            revoke (when possible) all tokens previously issued based on\n-            that authorization code.  The authorization code is bound to\n-            the client identifier and redirection URI.\n-    state\n-            REQUIRED if the \"state\" parameter was present in the client\n-            authorization request.  The exact value received from the\n-            client.\n-\n-    For example, the authorization server redirects the user-agent by\n-    sending the following HTTP response:\n-\n-    HTTP/1.1 302 Found\n-    Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA\n-            &state=xyz\n-\n-    \"\"\"\n-    query = urlparse.urlparse(uri).query\n-    params = dict(urlparse.parse_qsl(query))\n-\n-    if not u'code' in params:\n-        raise KeyError(\"Missing code parameter in response.\")\n-\n-    if state and params.get(u'state', None) != state:\n-        raise ValueError(\"Mismatching or missing state in response.\")\n-\n-    return params\n-\n-\n-def parse_implicit_response(uri, state=None, scope=None):\n-    \"\"\"Parse the implicit token response URI into a dict.\n-\n-    If the resource owner grants the access request, the authorization\n-    server issues an access token and delivers it to the client by adding\n-    the following parameters to the fragment component of the redirection\n-    URI using the \"application/x-www-form-urlencoded\" format:\n-\n-    access_token\n-            REQUIRED.  The access token issued by the authorization server.\n-    token_type\n-            REQUIRED.  The type of the token issued as described in\n-            Section 7.1.  Value is case insensitive.\n-    expires_in\n-            RECOMMENDED.  The lifetime in seconds of the access token.  For\n-            example, the value \"3600\" denotes that the access token will\n-            expire in one hour from the time the response was generated.\n-            If omitted, the authorization server SHOULD provide the\n-            expiration time via other means or document the default value.\n-    scope\n-            OPTIONAL, if identical to the scope requested by the client,\n-            otherwise REQUIRED.  The scope of the access token as described\n-            by Section 3.3.\n-    state\n-            REQUIRED if the \"state\" parameter was present in the client\n-            authorization request.  The exact value received from the\n-            client.\n-\n-    HTTP/1.1 302 Found\n-    Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA\n-            &state=xyz&token_type=example&expires_in=3600\n-    \"\"\"\n-    fragment = urlparse.urlparse(uri).fragment\n-    params = dict(urlparse.parse_qsl(fragment, keep_blank_values=True))\n-    validate_token_parameters(params, scope)\n-\n-    if state and params.get(u'state', None) != state:\n-        raise ValueError(\"Mismatching or missing state in params.\")\n-\n-    return params\n-\n-\n-def parse_token_response(body, scope=None):\n-    \"\"\"Parse the JSON token response body into a dict.\n-\n-    The authorization server issues an access token and optional refresh\n-    token, and constructs the response by adding the following parameters\n-    to the entity body of the HTTP response with a 200 (OK) status code:\n-\n-    access_token\n-            REQUIRED.  The access token issued by the authorization server.\n-    token_type\n-            REQUIRED.  The type of the token issued as described in\n-            `Section 7.1`_.  Value is case insensitive.\n-    expires_in\n-            RECOMMENDED.  The lifetime in seconds of the access token.  For\n-            example, the value \"3600\" denotes that the access token will\n-            expire in one hour from the time the response was generated.\n-            If omitted, the authorization server SHOULD provide the\n-            expiration time via other means or document the default value.\n-    refresh_token\n-            OPTIONAL.  The refresh token which can be used to obtain new\n-            access tokens using the same authorization grant as described\n-            in `Section 6`_.\n-    scope\n-            OPTIONAL, if identical to the scope requested by the client,\n-            otherwise REQUIRED.  The scope of the access token as described\n-            by `Section 3.3`_.\n-\n-    The parameters are included in the entity body of the HTTP response\n-    using the \"application/json\" media type as defined by [`RFC4627`_].  The\n-    parameters are serialized into a JSON structure by adding each\n-    parameter at the highest structure level.  Parameter names and string\n-    values are included as JSON strings.  Numerical values are included\n-    as JSON numbers.  The order of parameters does not matter and can\n-    vary.\n-\n-    For example:\n-\n-        HTTP/1.1 200 OK\n-        Content-Type: application/json;charset=UTF-8\n-        Cache-Control: no-store\n-        Pragma: no-cache\n-\n-        {\n-        \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n-        \"token_type\":\"example\",\n-        \"expires_in\":3600,\n-        \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n-        \"example_parameter\":\"example_value\"\n-        }\n-\n-    .. _`Section 7.1`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-7.1\n-    .. _`Section 6`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-6\n-    .. _`Section 3.3`: http://tools.ietf.org/html/draft-ietf-oauth-v2-28#section-3.3\n-    .. _`RFC4627`: http://tools.ietf.org/html/rfc4627\n-    \"\"\"\n-    params = json.loads(body)\n-    validate_token_parameters(params, scope)\n-    return params\n-\n-\n-def validate_token_parameters(params, scope=None):\n-    \"\"\"Ensures token precence, token type, expiration and scope in params.\"\"\"\n-\n-    if not u'access_token' in params:\n-        raise KeyError(\"Missing access token parameter.\")\n-\n-    if not u'token_type' in params:\n-        raise KeyError(\"Missing token type parameter.\")\n-\n-    # If the issued access token scope is different from the one requested by\n-    # the client, the authorization server MUST include the \"scope\" response\n-    # parameter to inform the client of the actual scope granted.\n-    # http://tools.ietf.org/html/draft-ietf-oauth-v2-25#section-3.3\n-    new_scope = params.get(u'scope', None)\n-    if scope and new_scope and scope != new_scope:\n-        raise Warning(\"Scope has changed to %s.\" % new_scope)\n\n@@ -1,132 +0,0 @@\n-from __future__ import absolute_import\n-\"\"\"\n-oauthlib.oauth2.draft25.tokens\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-This module contains methods for adding two types of access tokens to requests.\n-\n-- Bearer http://tools.ietf.org/html/draft-ietf-oauth-saml2-bearer-08\n-- MAC http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-00\n-\n-\"\"\"\n-from binascii import b2a_base64\n-import hashlib\n-import hmac\n-from urlparse import urlparse\n-\n-from oauthlib.common import add_params_to_uri, add_params_to_qs\n-from . import utils\n-\n-\n-def prepare_mac_header(token, uri, key, http_method, nonce=None, headers=None,\n-        body=None, ext=u'', hash_algorithm=u'hmac-sha-1'):\n-    \"\"\"Add an `MAC Access Authentication`_ signature to headers.\n-\n-    Unlike OAuth 1, this HMAC signature does not require inclusion of the request\n-    payload/body, neither does it use a combination of client_secret and\n-    token_secret but rather a mac_key provided together with the access token.\n-\n-    Currently two algorithms are supported, \"hmac-sha-1\" and \"hmac-sha-256\",\n-    `extension algorithms`_ are not supported.\n-\n-    Example MAC Authorization header, linebreaks added for clarity\n-\n-    Authorization: MAC id=\"h480djs93hd8\",\n-                       nonce=\"1336363200:dj83hs9s\",\n-                       mac=\"bhCQXTVyfj5cmA9uKkPFx1zeOXM=\"\n-\n-    .. _`MAC Access Authentication`: http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01\n-    .. _`extension algorithms`: http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01#section-7.1\n-\n-    :param uri: Request URI.\n-    :param headers: Request headers as a dictionary.\n-    :param http_method: HTTP Request method.\n-    :param key: MAC given provided by token endpoint.\n-    :param algorithm: HMAC algorithm provided by token endpoint.\n-    :return: headers dictionary with the authorization field added.\n-    \"\"\"\n-    http_method = http_method.upper()\n-    host, port = utils.host_from_uri(uri)\n-\n-    if hash_algorithm.lower() == u'hmac-sha-1':\n-        h = hashlib.sha1\n-    else:\n-        h = hashlib.sha256\n-\n-    nonce = nonce or u'{0}:{1}'.format(utils.generate_nonce(), utils.generate_timestamp())\n-    sch, net, path, par, query, fra = urlparse(uri)\n-\n-    if query:\n-        request_uri = path + u'?' + query\n-    else:\n-        request_uri = path\n-\n-    # Hash the body/payload\n-    if body is not None:\n-        bodyhash = b2a_base64(h(body).digest())[:-1].decode('utf-8')\n-    else:\n-        bodyhash = u''\n-\n-    # Create the normalized base string\n-    base = []\n-    base.append(nonce)\n-    base.append(http_method.upper())\n-    base.append(request_uri)\n-    base.append(host)\n-    base.append(port)\n-    base.append(bodyhash)\n-    base.append(ext)\n-    base_string = '\\n'.join(base) + u'\\n'\n-\n-    # hmac struggles with unicode strings - http://bugs.python.org/issue5285\n-    if isinstance(key, unicode):\n-        key = key.encode('utf-8')\n-    sign = hmac.new(key, base_string, h)\n-    sign = b2a_base64(sign.digest())[:-1].decode('utf-8')\n-\n-    header = []\n-    header.append(u'MAC id=\"%s\"' % token)\n-    header.append(u'nonce=\"%s\"' % nonce)\n-    if bodyhash:\n-        header.append(u'bodyhash=\"%s\"' % bodyhash)\n-    if ext:\n-        header.append(u'ext=\"%s\"' % ext)\n-    header.append(u'mac=\"%s\"' % sign)\n-\n-    headers = headers or {}\n-    headers[u'Authorization'] = u', '.join(header)\n-    return headers\n-\n-\n-def prepare_bearer_uri(token, uri):\n-    \"\"\"Add a `Bearer Token`_ to the request URI.\n-    Not recommended, use only if client can't use authorization header or body.\n-\n-    http://www.example.com/path?access_token=h480djs93hd8\n-\n-    .. _`Bearer Token`: http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-18\n-    \"\"\"\n-    return add_params_to_uri(uri, [((u'access_token', token))])\n-\n-\n-def prepare_bearer_headers(token, headers=None):\n-    \"\"\"Add a `Bearer Token`_ to the request URI.\n-    Recommended method of passing bearer tokens.\n-\n-    Authorization: Bearer h480djs93hd8\n-\n-    .. _`Bearer Token`: http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-18\n-    \"\"\"\n-    headers = headers or {}\n-    headers[u'Authorization'] = u'Bearer %s' % token\n-    return headers\n-\n-\n-def prepare_bearer_body(token, body=u''):\n-    \"\"\"Add a `Bearer Token`_ to the request body.\n-\n-    access_token=h480djs93hd8\n-\n-    .. _`Bearer Token`: http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-18\n-    \"\"\"\n-    return add_params_to_qs(body, [((u'access_token', token))])\n\n@@ -1,39 +0,0 @@\n-\"\"\"\n-oauthlib.utils\n-~~~~~~~~~~~~~~\n-\n-This module contains utility methods used by various parts of the OAuth 2 spec.\n-\"\"\"\n-\n-import urllib\n-import urlparse\n-\n-\n-def host_from_uri(uri):\n-    \"\"\"Extract hostname and port from URI.\n-\n-    Will use default port for HTTP and HTTPS if none is present in the URI.\n-    \"\"\"\n-    default_ports = {\n-        u'HTTP': u'80',\n-        u'HTTPS': u'443',\n-    }\n-\n-    sch, netloc, path, par, query, fra = urlparse.urlparse(uri)\n-    if u':' in netloc:\n-        netloc, port = netloc.split(u':', 1)\n-    else:\n-        port = default_ports.get(sch.upper())\n-\n-    return netloc, port\n-\n-\n-def escape(u):\n-    \"\"\"Escape a string in an OAuth-compatible fashion.\n-\n-    TODO: verify whether this can in fact be used for OAuth 2\n-\n-    \"\"\"\n-    if not isinstance(u, unicode):\n-        raise ValueError('Only unicode objects are escapable.')\n-    return urllib.quote(u.encode('utf-8'), safe='~')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
