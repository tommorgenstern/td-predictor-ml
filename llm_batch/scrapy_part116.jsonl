{"custom_id": "scrapy#b3c96c698defe87f826713c4e9b90683ae21f41e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 284 | Contributors (this commit): 1 | Commits (past 90d): 8 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -171,7 +171,7 @@ def _add_auth_header(request, target):\n             host = urlparse(target['url']).hostname\n             a = netrc.netrc().authenticators(host)\n             request.add_header('Authorization', basic_auth_header(a[0], a[2]))\n-        except (netrc.NetrcParseError, TypeError):\n+        except (netrc.NetrcParseError, IOError, TypeError):\n             pass\n \n def _http_post(request):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#5ded8251d21e77d259da5548333138a358f8114e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 138 | Contributors (this commit): 1 | Commits (past 90d): 8 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -16,12 +16,13 @@ class ExecutionQueue(object):\n         self._queue = queue\n         self._keepalive = keep_alive\n \n+    @defer.inlineCallbacks\n     def _append_next(self):\n         \"\"\"Called when there are no more items left in self.spider_requests.\n         This method is meant to be overriden in subclasses to add new (spider,\n         requests) tuples to self.spider_requests. It can return a Deferred.\n         \"\"\"\n-        msg = self._queue.pop()\n+        msg = yield self._queue.pop()\n         if msg:\n             name = msg.pop('name')\n             msg = stringify_dict(msg) # see #250\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#7c712eeda1d9ebc51dba403a017b54428ae3e9a0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1597 | Files Changed: 8 | Hunks: 9 | Methods Changed: 53 | Complexity Δ (Sum/Max): -275/0 | Churn Δ: 1599 | Churn Cumulative: 3481 | Contributors (this commit): 4 | Commits (past 90d): 20 | Contributors (cumulative): 11 | DMM Complexity: 0.5254691689008043\n\nDIFF:\n@@ -102,10 +102,7 @@ else:\n try:\n     import json\n except ImportError:\n-    try:\n     import simplejson as json\n-    except ImportError:\n-        import scrapy.xlib.simplejson as json\n \n \n def _get_data(package, resource):\n\n@@ -1,437 +0,0 @@\n-r\"\"\"JSON (JavaScript Object Notation) <http://json.org> is a subset of\n-JavaScript syntax (ECMA-262 3rd edition) used as a lightweight data\n-interchange format.\n-\n-:mod:`simplejson` exposes an API familiar to users of the standard library\n-:mod:`marshal` and :mod:`pickle` modules. It is the externally maintained\n-version of the :mod:`json` library contained in Python 2.6, but maintains\n-compatibility with Python 2.4 and Python 2.5 and (currently) has\n-significant performance advantages, even without using the optional C\n-extension for speedups.\n-\n-Encoding basic Python object hierarchies::\n-\n-    >>> import simplejson as json\n-    >>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n-    '[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n-    >>> print json.dumps(\"\\\"foo\\bar\")\n-    \"\\\"foo\\bar\"\n-    >>> print json.dumps(u'\\u1234')\n-    \"\\u1234\"\n-    >>> print json.dumps('\\\\')\n-    \"\\\\\"\n-    >>> print json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True)\n-    {\"a\": 0, \"b\": 0, \"c\": 0}\n-    >>> from StringIO import StringIO\n-    >>> io = StringIO()\n-    >>> json.dump(['streaming API'], io)\n-    >>> io.getvalue()\n-    '[\"streaming API\"]'\n-\n-Compact encoding::\n-\n-    >>> import simplejson as json\n-    >>> json.dumps([1,2,3,{'4': 5, '6': 7}], separators=(',',':'))\n-    '[1,2,3,{\"4\":5,\"6\":7}]'\n-\n-Pretty printing::\n-\n-    >>> import simplejson as json\n-    >>> s = json.dumps({'4': 5, '6': 7}, sort_keys=True, indent='    ')\n-    >>> print '\\n'.join([l.rstrip() for l in  s.splitlines()])\n-    {\n-        \"4\": 5,\n-        \"6\": 7\n-    }\n-\n-Decoding JSON::\n-\n-    >>> import simplejson as json\n-    >>> obj = [u'foo', {u'bar': [u'baz', None, 1.0, 2]}]\n-    >>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]') == obj\n-    True\n-    >>> json.loads('\"\\\\\"foo\\\\bar\"') == u'\"foo\\x08ar'\n-    True\n-    >>> from StringIO import StringIO\n-    >>> io = StringIO('[\"streaming API\"]')\n-    >>> json.load(io)[0] == 'streaming API'\n-    True\n-\n-Specializing JSON object decoding::\n-\n-    >>> import simplejson as json\n-    >>> def as_complex(dct):\n-    ...     if '__complex__' in dct:\n-    ...         return complex(dct['real'], dct['imag'])\n-    ...     return dct\n-    ...\n-    >>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n-    ...     object_hook=as_complex)\n-    (1+2j)\n-    >>> from decimal import Decimal\n-    >>> json.loads('1.1', parse_float=Decimal) == Decimal('1.1')\n-    True\n-\n-Specializing JSON object encoding::\n-\n-    >>> import simplejson as json\n-    >>> def encode_complex(obj):\n-    ...     if isinstance(obj, complex):\n-    ...         return [obj.real, obj.imag]\n-    ...     raise TypeError(repr(o) + \" is not JSON serializable\")\n-    ...\n-    >>> json.dumps(2 + 1j, default=encode_complex)\n-    '[2.0, 1.0]'\n-    >>> json.JSONEncoder(default=encode_complex).encode(2 + 1j)\n-    '[2.0, 1.0]'\n-    >>> ''.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j))\n-    '[2.0, 1.0]'\n-\n-\n-Using simplejson.tool from the shell to validate and pretty-print::\n-\n-    $ echo '{\"json\":\"obj\"}' | python -m simplejson.tool\n-    {\n-        \"json\": \"obj\"\n-    }\n-    $ echo '{ 1.2:3.4}' | python -m simplejson.tool\n-    Expecting property name: line 1 column 2 (char 2)\n-\"\"\"\n-__version__ = '2.1.1'\n-__all__ = [\n-    'dump', 'dumps', 'load', 'loads',\n-    'JSONDecoder', 'JSONDecodeError', 'JSONEncoder',\n-    'OrderedDict',\n-]\n-\n-__author__ = 'Bob Ippolito <bob@redivi.com>'\n-\n-from decimal import Decimal\n-\n-from decoder import JSONDecoder, JSONDecodeError\n-from encoder import JSONEncoder\n-def _import_OrderedDict():\n-    import collections\n-    try:\n-        return collections.OrderedDict\n-    except AttributeError:\n-        import ordered_dict\n-        return ordered_dict.OrderedDict\n-OrderedDict = _import_OrderedDict()\n-\n-def _import_c_make_encoder():\n-    try:\n-        from scrapy.xlib.simplejson._speedups import make_encoder\n-        return make_encoder\n-    except ImportError:\n-        return None\n-\n-_default_encoder = JSONEncoder(\n-    skipkeys=False,\n-    ensure_ascii=True,\n-    check_circular=True,\n-    allow_nan=True,\n-    indent=None,\n-    separators=None,\n-    encoding='utf-8',\n-    default=None,\n-    use_decimal=False,\n-)\n-\n-def dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True,\n-        allow_nan=True, cls=None, indent=None, separators=None,\n-        encoding='utf-8', default=None, use_decimal=False, **kw):\n-    \"\"\"Serialize ``obj`` as a JSON formatted stream to ``fp`` (a\n-    ``.write()``-supporting file-like object).\n-\n-    If ``skipkeys`` is true then ``dict`` keys that are not basic types\n-    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)\n-    will be skipped instead of raising a ``TypeError``.\n-\n-    If ``ensure_ascii`` is false, then the some chunks written to ``fp``\n-    may be ``unicode`` instances, subject to normal Python ``str`` to\n-    ``unicode`` coercion rules. Unless ``fp.write()`` explicitly\n-    understands ``unicode`` (as in ``codecs.getwriter()``) this is likely\n-    to cause an error.\n-\n-    If ``check_circular`` is false, then the circular reference check\n-    for container types will be skipped and a circular reference will\n-    result in an ``OverflowError`` (or worse).\n-\n-    If ``allow_nan`` is false, then it will be a ``ValueError`` to\n-    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)\n-    in strict compliance of the JSON specification, instead of using the\n-    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n-\n-    If *indent* is a string, then JSON array elements and object members\n-    will be pretty-printed with a newline followed by that string repeated\n-    for each level of nesting. ``None`` (the default) selects the most compact\n-    representation without any newlines. For backwards compatibility with\n-    versions of simplejson earlier than 2.1.0, an integer is also accepted\n-    and is converted to a string with that many spaces.\n-\n-    If ``separators`` is an ``(item_separator, dict_separator)`` tuple\n-    then it will be used instead of the default ``(', ', ': ')`` separators.\n-    ``(',', ':')`` is the most compact JSON representation.\n-\n-    ``encoding`` is the character encoding for str instances, default is UTF-8.\n-\n-    ``default(obj)`` is a function that should return a serializable version\n-    of obj or raise TypeError. The default simply raises TypeError.\n-\n-    If *use_decimal* is true (default: ``False``) then decimal.Decimal\n-    will be natively serialized to JSON with full precision.\n-\n-    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n-    ``.default()`` method to serialize additional types), specify it with\n-    the ``cls`` kwarg.\n-\n-    \"\"\"\n-    # cached encoder\n-    if (not skipkeys and ensure_ascii and\n-        check_circular and allow_nan and\n-        cls is None and indent is None and separators is None and\n-        encoding == 'utf-8' and default is None and not kw):\n-        iterable = _default_encoder.iterencode(obj)\n-    else:\n-        if cls is None:\n-            cls = JSONEncoder\n-        iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii,\n-            check_circular=check_circular, allow_nan=allow_nan, indent=indent,\n-            separators=separators, encoding=encoding,\n-            default=default, use_decimal=use_decimal, **kw).iterencode(obj)\n-    # could accelerate with writelines in some versions of Python, at\n-    # a debuggability cost\n-    for chunk in iterable:\n-        fp.write(chunk)\n-\n-\n-def dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True,\n-        allow_nan=True, cls=None, indent=None, separators=None,\n-        encoding='utf-8', default=None, use_decimal=False, **kw):\n-    \"\"\"Serialize ``obj`` to a JSON formatted ``str``.\n-\n-    If ``skipkeys`` is false then ``dict`` keys that are not basic types\n-    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)\n-    will be skipped instead of raising a ``TypeError``.\n-\n-    If ``ensure_ascii`` is false, then the return value will be a\n-    ``unicode`` instance subject to normal Python ``str`` to ``unicode``\n-    coercion rules instead of being escaped to an ASCII ``str``.\n-\n-    If ``check_circular`` is false, then the circular reference check\n-    for container types will be skipped and a circular reference will\n-    result in an ``OverflowError`` (or worse).\n-\n-    If ``allow_nan`` is false, then it will be a ``ValueError`` to\n-    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in\n-    strict compliance of the JSON specification, instead of using the\n-    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n-\n-    If ``indent`` is a string, then JSON array elements and object members\n-    will be pretty-printed with a newline followed by that string repeated\n-    for each level of nesting. ``None`` (the default) selects the most compact\n-    representation without any newlines. For backwards compatibility with\n-    versions of simplejson earlier than 2.1.0, an integer is also accepted\n-    and is converted to a string with that many spaces.\n-\n-    If ``separators`` is an ``(item_separator, dict_separator)`` tuple\n-    then it will be used instead of the default ``(', ', ': ')`` separators.\n-    ``(',', ':')`` is the most compact JSON representation.\n-\n-    ``encoding`` is the character encoding for str instances, default is UTF-8.\n-\n-    ``default(obj)`` is a function that should return a serializable version\n-    of obj or raise TypeError. The default simply raises TypeError.\n-\n-    If *use_decimal* is true (default: ``False``) then decimal.Decimal\n-    will be natively serialized to JSON with full precision.\n-\n-    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n-    ``.default()`` method to serialize additional types), specify it with\n-    the ``cls`` kwarg.\n-\n-    \"\"\"\n-    # cached encoder\n-    if (not skipkeys and ensure_ascii and\n-        check_circular and allow_nan and\n-        cls is None and indent is None and separators is None and\n-        encoding == 'utf-8' and default is None and not use_decimal\n-        and not kw):\n-        return _default_encoder.encode(obj)\n-    if cls is None:\n-        cls = JSONEncoder\n-    return cls(\n-        skipkeys=skipkeys, ensure_ascii=ensure_ascii,\n-        check_circular=check_circular, allow_nan=allow_nan, indent=indent,\n-        separators=separators, encoding=encoding, default=default,\n-        use_decimal=use_decimal, **kw).encode(obj)\n-\n-\n-_default_decoder = JSONDecoder(encoding=None, object_hook=None,\n-                               object_pairs_hook=None)\n-\n-\n-def load(fp, encoding=None, cls=None, object_hook=None, parse_float=None,\n-        parse_int=None, parse_constant=None, object_pairs_hook=None,\n-        use_decimal=False, **kw):\n-    \"\"\"Deserialize ``fp`` (a ``.read()``-supporting file-like object containing\n-    a JSON document) to a Python object.\n-\n-    *encoding* determines the encoding used to interpret any\n-    :class:`str` objects decoded by this instance (``'utf-8'`` by\n-    default).  It has no effect when decoding :class:`unicode` objects.\n-\n-    Note that currently only encodings that are a superset of ASCII work,\n-    strings of other encodings should be passed in as :class:`unicode`.\n-\n-    *object_hook*, if specified, will be called with the result of every\n-    JSON object decoded and its return value will be used in place of the\n-    given :class:`dict`.  This can be used to provide custom\n-    deserializations (e.g. to support JSON-RPC class hinting).\n-\n-    *object_pairs_hook* is an optional function that will be called with\n-    the result of any object literal decode with an ordered list of pairs.\n-    The return value of *object_pairs_hook* will be used instead of the\n-    :class:`dict`.  This feature can be used to implement custom decoders\n-    that rely on the order that the key and value pairs are decoded (for\n-    example, :func:`collections.OrderedDict` will remember the order of\n-    insertion). If *object_hook* is also defined, the *object_pairs_hook*\n-    takes priority.\n-\n-    *parse_float*, if specified, will be called with the string of every\n-    JSON float to be decoded.  By default, this is equivalent to\n-    ``float(num_str)``. This can be used to use another datatype or parser\n-    for JSON floats (e.g. :class:`decimal.Decimal`).\n-\n-    *parse_int*, if specified, will be called with the string of every\n-    JSON int to be decoded.  By default, this is equivalent to\n-    ``int(num_str)``.  This can be used to use another datatype or parser\n-    for JSON integers (e.g. :class:`float`).\n-\n-    *parse_constant*, if specified, will be called with one of the\n-    following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This\n-    can be used to raise an exception if invalid JSON numbers are\n-    encountered.\n-\n-    If *use_decimal* is true (default: ``False``) then it implies\n-    parse_float=decimal.Decimal for parity with ``dump``.\n-\n-    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n-    kwarg.\n-\n-    \"\"\"\n-    return loads(fp.read(),\n-        encoding=encoding, cls=cls, object_hook=object_hook,\n-        parse_float=parse_float, parse_int=parse_int,\n-        parse_constant=parse_constant, object_pairs_hook=object_pairs_hook,\n-        use_decimal=use_decimal, **kw)\n-\n-\n-def loads(s, encoding=None, cls=None, object_hook=None, parse_float=None,\n-        parse_int=None, parse_constant=None, object_pairs_hook=None,\n-        use_decimal=False, **kw):\n-    \"\"\"Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON\n-    document) to a Python object.\n-\n-    *encoding* determines the encoding used to interpret any\n-    :class:`str` objects decoded by this instance (``'utf-8'`` by\n-    default).  It has no effect when decoding :class:`unicode` objects.\n-\n-    Note that currently only encodings that are a superset of ASCII work,\n-    strings of other encodings should be passed in as :class:`unicode`.\n-\n-    *object_hook*, if specified, will be called with the result of every\n-    JSON object decoded and its return value will be used in place of the\n-    given :class:`dict`.  This can be used to provide custom\n-    deserializations (e.g. to support JSON-RPC class hinting).\n-\n-    *object_pairs_hook* is an optional function that will be called with\n-    the result of any object literal decode with an ordered list of pairs.\n-    The return value of *object_pairs_hook* will be used instead of the\n-    :class:`dict`.  This feature can be used to implement custom decoders\n-    that rely on the order that the key and value pairs are decoded (for\n-    example, :func:`collections.OrderedDict` will remember the order of\n-    insertion). If *object_hook* is also defined, the *object_pairs_hook*\n-    takes priority.\n-\n-    *parse_float*, if specified, will be called with the string of every\n-    JSON float to be decoded.  By default, this is equivalent to\n-    ``float(num_str)``. This can be used to use another datatype or parser\n-    for JSON floats (e.g. :class:`decimal.Decimal`).\n-\n-    *parse_int*, if specified, will be called with the string of every\n-    JSON int to be decoded.  By default, this is equivalent to\n-    ``int(num_str)``.  This can be used to use another datatype or parser\n-    for JSON integers (e.g. :class:`float`).\n-\n-    *parse_constant*, if specified, will be called with one of the\n-    following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This\n-    can be used to raise an exception if invalid JSON numbers are\n-    encountered.\n-\n-    If *use_decimal* is true (default: ``False``) then it implies\n-    parse_float=decimal.Decimal for parity with ``dump``.\n-\n-    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n-    kwarg.\n-\n-    \"\"\"\n-    if (cls is None and encoding is None and object_hook is None and\n-            parse_int is None and parse_float is None and\n-            parse_constant is None and object_pairs_hook is None\n-            and not use_decimal and not kw):\n-        return _default_decoder.decode(s)\n-    if cls is None:\n-        cls = JSONDecoder\n-    if object_hook is not None:\n-        kw['object_hook'] = object_hook\n-    if object_pairs_hook is not None:\n-        kw['object_pairs_hook'] = object_pairs_hook\n-    if parse_float is not None:\n-        kw['parse_float'] = parse_float\n-    if parse_int is not None:\n-        kw['parse_int'] = parse_int\n-    if parse_constant is not None:\n-        kw['parse_constant'] = parse_constant\n-    if use_decimal:\n-        if parse_float is not None:\n-            raise TypeError(\"use_decimal=True implies parse_float=Decimal\")\n-        kw['parse_float'] = Decimal\n-    return cls(encoding=encoding, **kw).decode(s)\n-\n-\n-def _toggle_speedups(enabled):\n-    import simplejson.decoder as dec\n-    import simplejson.encoder as enc\n-    import simplejson.scanner as scan\n-    c_make_encoder = _import_c_make_encoder()\n-    if enabled:\n-        dec.scanstring = dec.c_scanstring or dec.py_scanstring\n-        enc.c_make_encoder = c_make_encoder\n-        enc.encode_basestring_ascii = (enc.c_encode_basestring_ascii or \n-            enc.py_encode_basestring_ascii)\n-        scan.make_scanner = scan.c_make_scanner or scan.py_make_scanner\n-    else:\n-        dec.scanstring = dec.py_scanstring\n-        enc.c_make_encoder = None\n-        enc.encode_basestring_ascii = enc.py_encode_basestring_ascii\n-        scan.make_scanner = scan.py_make_scanner\n-    dec.make_scanner = scan.make_scanner\n-    global _default_decoder\n-    _default_decoder = JSONDecoder(\n-        encoding=None,\n-        object_hook=None,\n-        object_pairs_hook=None,\n-    )\n-    global _default_encoder\n-    _default_encoder = JSONEncoder(\n-       skipkeys=False,\n-       ensure_ascii=True,\n-       check_circular=True,\n-       allow_nan=True,\n-       indent=None,\n-       separators=None,\n-       encoding='utf-8',\n-       default=None,\n-   )\n\n@@ -1,421 +0,0 @@\n-\"\"\"Implementation of JSONDecoder\n-\"\"\"\n-import re\n-import sys\n-import struct\n-\n-from scrapy.xlib.simplejson.scanner import make_scanner\n-def _import_c_scanstring():\n-    try:\n-        from scrapy.xlib.simplejson._speedups import scanstring\n-        return scanstring\n-    except ImportError:\n-        return None\n-c_scanstring = _import_c_scanstring()\n-\n-__all__ = ['JSONDecoder']\n-\n-FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\n-\n-def _floatconstants():\n-    _BYTES = '7FF80000000000007FF0000000000000'.decode('hex')\n-    # The struct module in Python 2.4 would get frexp() out of range here\n-    # when an endian is specified in the format string. Fixed in Python 2.5+\n-    if sys.byteorder != 'big':\n-        _BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]\n-    nan, inf = struct.unpack('dd', _BYTES)\n-    return nan, inf, -inf\n-\n-NaN, PosInf, NegInf = _floatconstants()\n-\n-\n-class JSONDecodeError(ValueError):\n-    \"\"\"Subclass of ValueError with the following additional properties:\n-    \n-    msg: The unformatted error message\n-    doc: The JSON document being parsed\n-    pos: The start index of doc where parsing failed\n-    end: The end index of doc where parsing failed (may be None)\n-    lineno: The line corresponding to pos\n-    colno: The column corresponding to pos\n-    endlineno: The line corresponding to end (may be None)\n-    endcolno: The column corresponding to end (may be None)\n-    \n-    \"\"\"\n-    def __init__(self, msg, doc, pos, end=None):\n-        ValueError.__init__(self, errmsg(msg, doc, pos, end=end))\n-        self.msg = msg\n-        self.doc = doc\n-        self.pos = pos\n-        self.end = end\n-        self.lineno, self.colno = linecol(doc, pos)\n-        if end is not None:\n-            self.endlineno, self.endcolno = linecol(doc, pos)\n-        else:\n-            self.endlineno, self.endcolno = None, None\n-\n-\n-def linecol(doc, pos):\n-    lineno = doc.count('\\n', 0, pos) + 1\n-    if lineno == 1:\n-        colno = pos\n-    else:\n-        colno = pos - doc.rindex('\\n', 0, pos)\n-    return lineno, colno\n-\n-\n-def errmsg(msg, doc, pos, end=None):\n-    # Note that this function is called from _speedups\n-    lineno, colno = linecol(doc, pos)\n-    if end is None:\n-        #fmt = '{0}: line {1} column {2} (char {3})'\n-        #return fmt.format(msg, lineno, colno, pos)\n-        fmt = '%s: line %d column %d (char %d)'\n-        return fmt % (msg, lineno, colno, pos)\n-    endlineno, endcolno = linecol(doc, end)\n-    #fmt = '{0}: line {1} column {2} - line {3} column {4} (char {5} - {6})'\n-    #return fmt.format(msg, lineno, colno, endlineno, endcolno, pos, end)\n-    fmt = '%s: line %d column %d - line %d column %d (char %d - %d)'\n-    return fmt % (msg, lineno, colno, endlineno, endcolno, pos, end)\n-\n-\n-_CONSTANTS = {\n-    '-Infinity': NegInf,\n-    'Infinity': PosInf,\n-    'NaN': NaN,\n-}\n-\n-STRINGCHUNK = re.compile(r'(.*?)([\"\\\\\\x00-\\x1f])', FLAGS)\n-BACKSLASH = {\n-    '\"': u'\"', '\\\\': u'\\\\', '/': u'/',\n-    'b': u'\\b', 'f': u'\\f', 'n': u'\\n', 'r': u'\\r', 't': u'\\t',\n-}\n-\n-DEFAULT_ENCODING = \"utf-8\"\n-\n-def py_scanstring(s, end, encoding=None, strict=True,\n-        _b=BACKSLASH, _m=STRINGCHUNK.match):\n-    \"\"\"Scan the string s for a JSON string. End is the index of the\n-    character in s after the quote that started the JSON string.\n-    Unescapes all valid JSON string escape sequences and raises ValueError\n-    on attempt to decode an invalid string. If strict is False then literal\n-    control characters are allowed in the string.\n-\n-    Returns a tuple of the decoded string and the index of the character in s\n-    after the end quote.\"\"\"\n-    if encoding is None:\n-        encoding = DEFAULT_ENCODING\n-    chunks = []\n-    _append = chunks.append\n-    begin = end - 1\n-    while 1:\n-        chunk = _m(s, end)\n-        if chunk is None:\n-            raise JSONDecodeError(\n-                \"Unterminated string starting at\", s, begin)\n-        end = chunk.end()\n-        content, terminator = chunk.groups()\n-        # Content is contains zero or more unescaped string characters\n-        if content:\n-            if not isinstance(content, unicode):\n-                content = unicode(content, encoding)\n-            _append(content)\n-        # Terminator is the end of string, a literal control character,\n-        # or a backslash denoting that an escape sequence follows\n-        if terminator == '\"':\n-            break\n-        elif terminator != '\\\\':\n-            if strict:\n-                msg = \"Invalid control character %r at\" % (terminator,)\n-                #msg = \"Invalid control character {0!r} at\".format(terminator)\n-                raise JSONDecodeError(msg, s, end)\n-            else:\n-                _append(terminator)\n-                continue\n-        try:\n-            esc = s[end]\n-        except IndexError:\n-            raise JSONDecodeError(\n-                \"Unterminated string starting at\", s, begin)\n-        # If not a unicode escape sequence, must be in the lookup table\n-        if esc != 'u':\n-            try:\n-                char = _b[esc]\n-            except KeyError:\n-                msg = \"Invalid \\\\escape: \" + repr(esc)\n-                raise JSONDecodeError(msg, s, end)\n-            end += 1\n-        else:\n-            # Unicode escape sequence\n-            esc = s[end + 1:end + 5]\n-            next_end = end + 5\n-            if len(esc) != 4:\n-                msg = \"Invalid \\\\uXXXX escape\"\n-                raise JSONDecodeError(msg, s, end)\n-            uni = int(esc, 16)\n-            # Check for surrogate pair on UCS-4 systems\n-            if 0xd800 <= uni <= 0xdbff and sys.maxunicode > 65535:\n-                msg = \"Invalid \\\\uXXXX\\\\uXXXX surrogate pair\"\n-                if not s[end + 5:end + 7] == '\\\\u':\n-                    raise JSONDecodeError(msg, s, end)\n-                esc2 = s[end + 7:end + 11]\n-                if len(esc2) != 4:\n-                    raise JSONDecodeError(msg, s, end)\n-                uni2 = int(esc2, 16)\n-                uni = 0x10000 + (((uni - 0xd800) << 10) | (uni2 - 0xdc00))\n-                next_end += 6\n-            char = unichr(uni)\n-            end = next_end\n-        # Append the unescaped character\n-        _append(char)\n-    return u''.join(chunks), end\n-\n-\n-# Use speedup if available\n-scanstring = c_scanstring or py_scanstring\n-\n-WHITESPACE = re.compile(r'[ \\t\\n\\r]*', FLAGS)\n-WHITESPACE_STR = ' \\t\\n\\r'\n-\n-def JSONObject((s, end), encoding, strict, scan_once, object_hook,\n-        object_pairs_hook, memo=None,\n-        _w=WHITESPACE.match, _ws=WHITESPACE_STR):\n-    # Backwards compatibility\n-    if memo is None:\n-        memo = {}\n-    memo_get = memo.setdefault\n-    pairs = []\n-    # Use a slice to prevent IndexError from being raised, the following\n-    # check will raise a more specific ValueError if the string is empty\n-    nextchar = s[end:end + 1]\n-    # Normally we expect nextchar == '\"'\n-    if nextchar != '\"':\n-        if nextchar in _ws:\n-            end = _w(s, end).end()\n-            nextchar = s[end:end + 1]\n-        # Trivial empty object\n-        if nextchar == '}':\n-            if object_pairs_hook is not None:\n-                result = object_pairs_hook(pairs)\n-                return result, end\n-            pairs = {}\n-            if object_hook is not None:\n-                pairs = object_hook(pairs)\n-            return pairs, end + 1\n-        elif nextchar != '\"':\n-            raise JSONDecodeError(\"Expecting property name\", s, end)\n-    end += 1\n-    while True:\n-        key, end = scanstring(s, end, encoding, strict)\n-        key = memo_get(key, key)\n-\n-        # To skip some function call overhead we optimize the fast paths where\n-        # the JSON key separator is \": \" or just \":\".\n-        if s[end:end + 1] != ':':\n-            end = _w(s, end).end()\n-            if s[end:end + 1] != ':':\n-                raise JSONDecodeError(\"Expecting : delimiter\", s, end)\n-\n-        end += 1\n-\n-        try:\n-            if s[end] in _ws:\n-                end += 1\n-                if s[end] in _ws:\n-                    end = _w(s, end + 1).end()\n-        except IndexError:\n-            pass\n-\n-        try:\n-            value, end = scan_once(s, end)\n-        except StopIteration:\n-            raise JSONDecodeError(\"Expecting object\", s, end)\n-        pairs.append((key, value))\n-\n-        try:\n-            nextchar = s[end]\n-            if nextchar in _ws:\n-                end = _w(s, end + 1).end()\n-                nextchar = s[end]\n-        except IndexError:\n-            nextchar = ''\n-        end += 1\n-\n-        if nextchar == '}':\n-            break\n-        elif nextchar != ',':\n-            raise JSONDecodeError(\"Expecting , delimiter\", s, end - 1)\n-\n-        try:\n-            nextchar = s[end]\n-            if nextchar in _ws:\n-                end += 1\n-                nextchar = s[end]\n-                if nextchar in _ws:\n-                    end = _w(s, end + 1).end()\n-                    nextchar = s[end]\n-        except IndexError:\n-            nextchar = ''\n-\n-        end += 1\n-        if nextchar != '\"':\n-            raise JSONDecodeError(\"Expecting property name\", s, end - 1)\n-\n-    if object_pairs_hook is not None:\n-        result = object_pairs_hook(pairs)\n-        return result, end\n-    pairs = dict(pairs)\n-    if object_hook is not None:\n-        pairs = object_hook(pairs)\n-    return pairs, end\n-\n-def JSONArray((s, end), scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):\n-    values = []\n-    nextchar = s[end:end + 1]\n-    if nextchar in _ws:\n-        end = _w(s, end + 1).end()\n-        nextchar = s[end:end + 1]\n-    # Look-ahead for trivial empty array\n-    if nextchar == ']':\n-        return values, end + 1\n-    _append = values.append\n-    while True:\n-        try:\n-            value, end = scan_once(s, end)\n-        except StopIteration:\n-            raise JSONDecodeError(\"Expecting object\", s, end)\n-        _append(value)\n-        nextchar = s[end:end + 1]\n-        if nextchar in _ws:\n-            end = _w(s, end + 1).end()\n-            nextchar = s[end:end + 1]\n-        end += 1\n-        if nextchar == ']':\n-            break\n-        elif nextchar != ',':\n-            raise JSONDecodeError(\"Expecting , delimiter\", s, end)\n-\n-        try:\n-            if s[end] in _ws:\n-                end += 1\n-                if s[end] in _ws:\n-                    end = _w(s, end + 1).end()\n-        except IndexError:\n-            pass\n-\n-    return values, end\n-\n-class JSONDecoder(object):\n-    \"\"\"Simple JSON <http://json.org> decoder\n-\n-    Performs the following translations in decoding by default:\n-\n-    +---------------+-------------------+\n-    | JSON          | Python            |\n-    +===============+===================+\n-    | object        | dict              |\n-    +---------------+-------------------+\n-    | array         | list              |\n-    +---------------+-------------------+\n-    | string        | unicode           |\n-    +---------------+-------------------+\n-    | number (int)  | int, long         |\n-    +---------------+-------------------+\n-    | number (real) | float             |\n-    +---------------+-------------------+\n-    | true          | True              |\n-    +---------------+-------------------+\n-    | false         | False             |\n-    +---------------+-------------------+\n-    | null          | None              |\n-    +---------------+-------------------+\n-\n-    It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\n-    their corresponding ``float`` values, which is outside the JSON spec.\n-\n-    \"\"\"\n-\n-    def __init__(self, encoding=None, object_hook=None, parse_float=None,\n-            parse_int=None, parse_constant=None, strict=True,\n-            object_pairs_hook=None):\n-        \"\"\"\n-        *encoding* determines the encoding used to interpret any\n-        :class:`str` objects decoded by this instance (``'utf-8'`` by\n-        default).  It has no effect when decoding :class:`unicode` objects.\n-\n-        Note that currently only encodings that are a superset of ASCII work,\n-        strings of other encodings should be passed in as :class:`unicode`.\n-\n-        *object_hook*, if specified, will be called with the result of every\n-        JSON object decoded and its return value will be used in place of the\n-        given :class:`dict`.  This can be used to provide custom\n-        deserializations (e.g. to support JSON-RPC class hinting).\n-\n-        *object_pairs_hook* is an optional function that will be called with\n-        the result of any object literal decode with an ordered list of pairs.\n-        The return value of *object_pairs_hook* will be used instead of the\n-        :class:`dict`.  This feature can be used to implement custom decoders\n-        that rely on the order that the key and value pairs are decoded (for\n-        example, :func:`collections.OrderedDict` will remember the order of\n-        insertion). If *object_hook* is also defined, the *object_pairs_hook*\n-        takes priority.\n-\n-        *parse_float*, if specified, will be called with the string of every\n-        JSON float to be decoded.  By default, this is equivalent to\n-        ``float(num_str)``. This can be used to use another datatype or parser\n-        for JSON floats (e.g. :class:`decimal.Decimal`).\n-\n-        *parse_int*, if specified, will be called with the string of every\n-        JSON int to be decoded.  By default, this is equivalent to\n-        ``int(num_str)``.  This can be used to use another datatype or parser\n-        for JSON integers (e.g. :class:`float`).\n-\n-        *parse_constant*, if specified, will be called with one of the\n-        following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This\n-        can be used to raise an exception if invalid JSON numbers are\n-        encountered.\n-\n-        *strict* controls the parser's behavior when it encounters an\n-        invalid control character in a string. The default setting of\n-        ``True`` means that unescaped control characters are parse errors, if\n-        ``False`` then control characters will be allowed in strings.\n-\n-        \"\"\"\n-        self.encoding = encoding\n-        self.object_hook = object_hook\n-        self.object_pairs_hook = object_pairs_hook\n-        self.parse_float = parse_float or float\n-        self.parse_int = parse_int or int\n-        self.parse_constant = parse_constant or _CONSTANTS.__getitem__\n-        self.strict = strict\n-        self.parse_object = JSONObject\n-        self.parse_array = JSONArray\n-        self.parse_string = scanstring\n-        self.memo = {}\n-        self.scan_once = make_scanner(self)\n-\n-    def decode(self, s, _w=WHITESPACE.match):\n-        \"\"\"Return the Python representation of ``s`` (a ``str`` or ``unicode``\n-        instance containing a JSON document)\n-\n-        \"\"\"\n-        obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n-        end = _w(s, end).end()\n-        if end != len(s):\n-            raise JSONDecodeError(\"Extra data\", s, end, len(s))\n-        return obj\n-\n-    def raw_decode(self, s, idx=0):\n-        \"\"\"Decode a JSON document from ``s`` (a ``str`` or ``unicode``\n-        beginning with a JSON document) and return a 2-tuple of the Python\n-        representation and the index in ``s`` where the document ended.\n-\n-        This can be used to decode a JSON document from a string that may\n-        have extraneous data at the end.\n-\n-        \"\"\"\n-        try:\n-            obj, end = self.scan_once(s, idx)\n-        except StopIteration:\n-            raise JSONDecodeError(\"No JSON object could be decoded\", s, idx)\n-        return obj, end\n\n@@ -1,501 +0,0 @@\n-\"\"\"Implementation of JSONEncoder\n-\"\"\"\n-import re\n-from decimal import Decimal\n-\n-def _import_speedups():\n-    try:\n-        from scrapy.xlib.simplejson import _speedups\n-        return _speedups.encode_basestring_ascii, _speedups.make_encoder\n-    except ImportError:\n-        return None, None\n-c_encode_basestring_ascii, c_make_encoder = _import_speedups()\n-\n-from scrapy.xlib.simplejson.decoder import PosInf\n-\n-ESCAPE = re.compile(r'[\\x00-\\x1f\\\\\"\\b\\f\\n\\r\\t]')\n-ESCAPE_ASCII = re.compile(r'([\\\\\"]|[^\\ -~])')\n-HAS_UTF8 = re.compile(r'[\\x80-\\xff]')\n-ESCAPE_DCT = {\n-    '\\\\': '\\\\\\\\',\n-    '\"': '\\\\\"',\n-    '\\b': '\\\\b',\n-    '\\f': '\\\\f',\n-    '\\n': '\\\\n',\n-    '\\r': '\\\\r',\n-    '\\t': '\\\\t',\n-}\n-for i in range(0x20):\n-    #ESCAPE_DCT.setdefault(chr(i), '\\\\u{0:04x}'.format(i))\n-    ESCAPE_DCT.setdefault(chr(i), '\\\\u%04x' % (i,))\n-\n-FLOAT_REPR = repr\n-\n-def encode_basestring(s):\n-    \"\"\"Return a JSON representation of a Python string\n-\n-    \"\"\"\n-    if isinstance(s, str) and HAS_UTF8.search(s) is not None:\n-        s = s.decode('utf-8')\n-    def replace(match):\n-        return ESCAPE_DCT[match.group(0)]\n-    return u'\"' + ESCAPE.sub(replace, s) + u'\"'\n-\n-\n-def py_encode_basestring_ascii(s):\n-    \"\"\"Return an ASCII-only JSON representation of a Python string\n-\n-    \"\"\"\n-    if isinstance(s, str) and HAS_UTF8.search(s) is not None:\n-        s = s.decode('utf-8')\n-    def replace(match):\n-        s = match.group(0)\n-        try:\n-            return ESCAPE_DCT[s]\n-        except KeyError:\n-            n = ord(s)\n-            if n < 0x10000:\n-                #return '\\\\u{0:04x}'.format(n)\n-                return '\\\\u%04x' % (n,)\n-            else:\n-                # surrogate pair\n-                n -= 0x10000\n-                s1 = 0xd800 | ((n >> 10) & 0x3ff)\n-                s2 = 0xdc00 | (n & 0x3ff)\n-                #return '\\\\u{0:04x}\\\\u{1:04x}'.format(s1, s2)\n-                return '\\\\u%04x\\\\u%04x' % (s1, s2)\n-    return '\"' + str(ESCAPE_ASCII.sub(replace, s)) + '\"'\n-\n-\n-encode_basestring_ascii = (\n-    c_encode_basestring_ascii or py_encode_basestring_ascii)\n-\n-class JSONEncoder(object):\n-    \"\"\"Extensible JSON <http://json.org> encoder for Python data structures.\n-\n-    Supports the following objects and types by default:\n-\n-    +-------------------+---------------+\n-    | Python            | JSON          |\n-    +===================+===============+\n-    | dict              | object        |\n-    +-------------------+---------------+\n-    | list, tuple       | array         |\n-    +-------------------+---------------+\n-    | str, unicode      | string        |\n-    +-------------------+---------------+\n-    | int, long, float  | number        |\n-    +-------------------+---------------+\n-    | True              | true          |\n-    +-------------------+---------------+\n-    | False             | false         |\n-    +-------------------+---------------+\n-    | None              | null          |\n-    +-------------------+---------------+\n-\n-    To extend this to recognize other objects, subclass and implement a\n-    ``.default()`` method with another method that returns a serializable\n-    object for ``o`` if possible, otherwise it should call the superclass\n-    implementation (to raise ``TypeError``).\n-\n-    \"\"\"\n-    item_separator = ', '\n-    key_separator = ': '\n-    def __init__(self, skipkeys=False, ensure_ascii=True,\n-            check_circular=True, allow_nan=True, sort_keys=False,\n-            indent=None, separators=None, encoding='utf-8', default=None,\n-            use_decimal=False):\n-        \"\"\"Constructor for JSONEncoder, with sensible defaults.\n-\n-        If skipkeys is false, then it is a TypeError to attempt\n-        encoding of keys that are not str, int, long, float or None.  If\n-        skipkeys is True, such items are simply skipped.\n-\n-        If ensure_ascii is true, the output is guaranteed to be str\n-        objects with all incoming unicode characters escaped.  If\n-        ensure_ascii is false, the output will be unicode object.\n-\n-        If check_circular is true, then lists, dicts, and custom encoded\n-        objects will be checked for circular references during encoding to\n-        prevent an infinite recursion (which would cause an OverflowError).\n-        Otherwise, no such check takes place.\n-\n-        If allow_nan is true, then NaN, Infinity, and -Infinity will be\n-        encoded as such.  This behavior is not JSON specification compliant,\n-        but is consistent with most JavaScript based encoders and decoders.\n-        Otherwise, it will be a ValueError to encode such floats.\n-\n-        If sort_keys is true, then the output of dictionaries will be\n-        sorted by key; this is useful for regression tests to ensure\n-        that JSON serializations can be compared on a day-to-day basis.\n-\n-        If indent is a string, then JSON array elements and object members\n-        will be pretty-printed with a newline followed by that string repeated\n-        for each level of nesting. ``None`` (the default) selects the most compact\n-        representation without any newlines. For backwards compatibility with\n-        versions of simplejson earlier than 2.1.0, an integer is also accepted\n-        and is converted to a string with that many spaces.\n-\n-        If specified, separators should be a (item_separator, key_separator)\n-        tuple.  The default is (', ', ': ').  To get the most compact JSON\n-        representation you should specify (',', ':') to eliminate whitespace.\n-\n-        If specified, default is a function that gets called for objects\n-        that can't otherwise be serialized.  It should return a JSON encodable\n-        version of the object or raise a ``TypeError``.\n-\n-        If encoding is not None, then all input strings will be\n-        transformed into unicode using that encoding prior to JSON-encoding.\n-        The default is UTF-8.\n-        \n-        If use_decimal is true (not the default), ``decimal.Decimal`` will\n-        be supported directly by the encoder. For the inverse, decode JSON\n-        with ``parse_float=decimal.Decimal``.\n-\n-        \"\"\"\n-\n-        self.skipkeys = skipkeys\n-        self.ensure_ascii = ensure_ascii\n-        self.check_circular = check_circular\n-        self.allow_nan = allow_nan\n-        self.sort_keys = sort_keys\n-        self.use_decimal = use_decimal\n-        if isinstance(indent, (int, long)):\n-            indent = ' ' * indent\n-        self.indent = indent\n-        if separators is not None:\n-            self.item_separator, self.key_separator = separators\n-        if default is not None:\n-            self.default = default\n-        self.encoding = encoding\n-\n-    def default(self, o):\n-        \"\"\"Implement this method in a subclass such that it returns\n-        a serializable object for ``o``, or calls the base implementation\n-        (to raise a ``TypeError``).\n-\n-        For example, to support arbitrary iterators, you could\n-        implement default like this::\n-\n-            def default(self, o):\n-                try:\n-                    iterable = iter(o)\n-                except TypeError:\n-                    pass\n-                else:\n-                    return list(iterable)\n-                return JSONEncoder.default(self, o)\n-\n-        \"\"\"\n-        raise TypeError(repr(o) + \" is not JSON serializable\")\n-\n-    def encode(self, o):\n-        \"\"\"Return a JSON string representation of a Python data structure.\n-\n-        >>> from simplejson import JSONEncoder\n-        >>> JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n-        '{\"foo\": [\"bar\", \"baz\"]}'\n-\n-        \"\"\"\n-        # This is for extremely simple cases and benchmarks.\n-        if isinstance(o, basestring):\n-            if isinstance(o, str):\n-                _encoding = self.encoding\n-                if (_encoding is not None\n-                        and not (_encoding == 'utf-8')):\n-                    o = o.decode(_encoding)\n-            if self.ensure_ascii:\n-                return encode_basestring_ascii(o)\n-            else:\n-                return encode_basestring(o)\n-        # This doesn't pass the iterator directly to ''.join() because the\n-        # exceptions aren't as detailed.  The list call should be roughly\n-        # equivalent to the PySequence_Fast that ''.join() would do.\n-        chunks = self.iterencode(o, _one_shot=True)\n-        if not isinstance(chunks, (list, tuple)):\n-            chunks = list(chunks)\n-        if self.ensure_ascii:\n-            return ''.join(chunks)\n-        else:\n-            return u''.join(chunks)\n-\n-    def iterencode(self, o, _one_shot=False):\n-        \"\"\"Encode the given object and yield each string\n-        representation as available.\n-\n-        For example::\n-\n-            for chunk in JSONEncoder().iterencode(bigobject):\n-                mysocket.write(chunk)\n-\n-        \"\"\"\n-        if self.check_circular:\n-            markers = {}\n-        else:\n-            markers = None\n-        if self.ensure_ascii:\n-            _encoder = encode_basestring_ascii\n-        else:\n-            _encoder = encode_basestring\n-        if self.encoding != 'utf-8':\n-            def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):\n-                if isinstance(o, str):\n-                    o = o.decode(_encoding)\n-                return _orig_encoder(o)\n-\n-        def floatstr(o, allow_nan=self.allow_nan,\n-                _repr=FLOAT_REPR, _inf=PosInf, _neginf=-PosInf):\n-            # Check for specials. Note that this type of test is processor\n-            # and/or platform-specific, so do tests which don't depend on\n-            # the internals.\n-\n-            if o != o:\n-                text = 'NaN'\n-            elif o == _inf:\n-                text = 'Infinity'\n-            elif o == _neginf:\n-                text = '-Infinity'\n-            else:\n-                return _repr(o)\n-\n-            if not allow_nan:\n-                raise ValueError(\n-                    \"Out of range float values are not JSON compliant: \" +\n-                    repr(o))\n-\n-            return text\n-\n-\n-        key_memo = {}\n-        if (_one_shot and c_make_encoder is not None\n-                and not self.indent and not self.sort_keys):\n-            _iterencode = c_make_encoder(\n-                markers, self.default, _encoder, self.indent,\n-                self.key_separator, self.item_separator, self.sort_keys,\n-                self.skipkeys, self.allow_nan, key_memo, self.use_decimal)\n-        else:\n-            _iterencode = _make_iterencode(\n-                markers, self.default, _encoder, self.indent, floatstr,\n-                self.key_separator, self.item_separator, self.sort_keys,\n-                self.skipkeys, _one_shot, self.use_decimal)\n-        try:\n-            return _iterencode(o, 0)\n-        finally:\n-            key_memo.clear()\n-\n-\n-class JSONEncoderForHTML(JSONEncoder):\n-    \"\"\"An encoder that produces JSON safe to embed in HTML.\n-\n-    To embed JSON content in, say, a script tag on a web page, the\n-    characters &, < and > should be escaped. They cannot be escaped\n-    with the usual entities (e.g. &amp;) because they are not expanded\n-    within <script> tags.\n-    \"\"\"\n-\n-    def encode(self, o):\n-        # Override JSONEncoder.encode because it has hacks for\n-        # performance that make things more complicated.\n-        chunks = self.iterencode(o, True)\n-        if self.ensure_ascii:\n-            return ''.join(chunks)\n-        else:\n-            return u''.join(chunks)\n-\n-    def iterencode(self, o, _one_shot=False):\n-        chunks = super(JSONEncoderForHTML, self).iterencode(o, _one_shot)\n-        for chunk in chunks:\n-            chunk = chunk.replace('&', '\\\\u0026')\n-            chunk = chunk.replace('<', '\\\\u003c')\n-            chunk = chunk.replace('>', '\\\\u003e')\n-            yield chunk\n-\n-\n-def _make_iterencode(markers, _default, _encoder, _indent, _floatstr,\n-        _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot,\n-        _use_decimal,\n-        ## HACK: hand-optimized bytecode; turn globals into locals\n-        False=False,\n-        True=True,\n-        ValueError=ValueError,\n-        basestring=basestring,\n-        Decimal=Decimal,\n-        dict=dict,\n-        float=float,\n-        id=id,\n-        int=int,\n-        isinstance=isinstance,\n-        list=list,\n-        long=long,\n-        str=str,\n-        tuple=tuple,\n-    ):\n-\n-    def _iterencode_list(lst, _current_indent_level):\n-        if not lst:\n-            yield '[]'\n-            return\n-        if markers is not None:\n-            markerid = id(lst)\n-            if markerid in markers:\n-                raise ValueError(\"Circular reference detected\")\n-            markers[markerid] = lst\n-        buf = '['\n-        if _indent is not None:\n-            _current_indent_level += 1\n-            newline_indent = '\\n' + (_indent * _current_indent_level)\n-            separator = _item_separator + newline_indent\n-            buf += newline_indent\n-        else:\n-            newline_indent = None\n-            separator = _item_separator\n-        first = True\n-        for value in lst:\n-            if first:\n-                first = False\n-            else:\n-                buf = separator\n-            if isinstance(value, basestring):\n-                yield buf + _encoder(value)\n-            elif value is None:\n-                yield buf + 'null'\n-            elif value is True:\n-                yield buf + 'true'\n-            elif value is False:\n-                yield buf + 'false'\n-            elif isinstance(value, (int, long)):\n-                yield buf + str(value)\n-            elif isinstance(value, float):\n-                yield buf + _floatstr(value)\n-            elif _use_decimal and isinstance(value, Decimal):\n-                yield buf + str(value)\n-            else:\n-                yield buf\n-                if isinstance(value, (list, tuple)):\n-                    chunks = _iterencode_list(value, _current_indent_level)\n-                elif isinstance(value, dict):\n-                    chunks = _iterencode_dict(value, _current_indent_level)\n-                else:\n-                    chunks = _iterencode(value, _current_indent_level)\n-                for chunk in chunks:\n-                    yield chunk\n-        if newline_indent is not None:\n-            _current_indent_level -= 1\n-            yield '\\n' + (_indent * _current_indent_level)\n-        yield ']'\n-        if markers is not None:\n-            del markers[markerid]\n-\n-    def _iterencode_dict(dct, _current_indent_level):\n-        if not dct:\n-            yield '{}'\n-            return\n-        if markers is not None:\n-            markerid = id(dct)\n-            if markerid in markers:\n-                raise ValueError(\"Circular reference detected\")\n-            markers[markerid] = dct\n-        yield '{'\n-        if _indent is not None:\n-            _current_indent_level += 1\n-            newline_indent = '\\n' + (_indent * _current_indent_level)\n-            item_separator = _item_separator + newline_indent\n-            yield newline_indent\n-        else:\n-            newline_indent = None\n-            item_separator = _item_separator\n-        first = True\n-        if _sort_keys:\n-            items = dct.items()\n-            items.sort(key=lambda kv: kv[0])\n-        else:\n-            items = dct.iteritems()\n-        for key, value in items:\n-            if isinstance(key, basestring):\n-                pass\n-            # JavaScript is weakly typed for these, so it makes sense to\n-            # also allow them.  Many encoders seem to do something like this.\n-            elif isinstance(key, float):\n-                key = _floatstr(key)\n-            elif key is True:\n-                key = 'true'\n-            elif key is False:\n-                key = 'false'\n-            elif key is None:\n-                key = 'null'\n-            elif isinstance(key, (int, long)):\n-                key = str(key)\n-            elif _skipkeys:\n-                continue\n-            else:\n-                raise TypeError(\"key \" + repr(key) + \" is not a string\")\n-            if first:\n-                first = False\n-            else:\n-                yield item_separator\n-            yield _encoder(key)\n-            yield _key_separator\n-            if isinstance(value, basestring):\n-                yield _encoder(value)\n-            elif value is None:\n-                yield 'null'\n-            elif value is True:\n-                yield 'true'\n-            elif value is False:\n-                yield 'false'\n-            elif isinstance(value, (int, long)):\n-                yield str(value)\n-            elif isinstance(value, float):\n-                yield _floatstr(value)\n-            elif _use_decimal and isinstance(value, Decimal):\n-                yield str(value)\n-            else:\n-                if isinstance(value, (list, tuple)):\n-                    chunks = _iterencode_list(value, _current_indent_level)\n-                elif isinstance(value, dict):\n-                    chunks = _iterencode_dict(value, _current_indent_level)\n-                else:\n-                    chunks = _iterencode(value, _current_indent_level)\n-                for chunk in chunks:\n-                    yield chunk\n-        if newline_indent is not None:\n-            _current_indent_level -= 1\n-            yield '\\n' + (_indent * _current_indent_level)\n-        yield '}'\n-        if markers is not None:\n-            del markers[markerid]\n-\n-    def _iterencode(o, _current_indent_level):\n-        if isinstance(o, basestring):\n-            yield _encoder(o)\n-        elif o is None:\n-            yield 'null'\n-        elif o is True:\n-            yield 'true'\n-        elif o is False:\n-            yield 'false'\n-        elif isinstance(o, (int, long)):\n-            yield str(o)\n-        elif isinstance(o, float):\n-            yield _floatstr(o)\n-        elif isinstance(o, (list, tuple)):\n-            for chunk in _iterencode_list(o, _current_indent_level):\n-                yield chunk\n-        elif isinstance(o, dict):\n-            for chunk in _iterencode_dict(o, _current_indent_level):\n-                yield chunk\n-        elif _use_decimal and isinstance(o, Decimal):\n-            yield str(o)\n-        else:\n-            if markers is not None:\n-                markerid = id(o)\n-                if markerid in markers:\n-                    raise ValueError(\"Circular reference detected\")\n-                markers[markerid] = o\n-            o = _default(o)\n-            for chunk in _iterencode(o, _current_indent_level):\n-                yield chunk\n-            if markers is not None:\n-                del markers[markerid]\n-\n-    return _iterencode\n\n@@ -1,119 +0,0 @@\n-\"\"\"Drop-in replacement for collections.OrderedDict by Raymond Hettinger\n-\n-http://code.activestate.com/recipes/576693/\n-\n-\"\"\"\n-from UserDict import DictMixin\n-\n-# Modified from original to support Python 2.4, see\n-# http://code.google.com/p/simplejson/issues/detail?id=53\n-try:\n-    all\n-except NameError:\n-    def all(seq):\n-        for elem in seq:\n-            if not elem:\n-                return False\n-        return True\n-\n-class OrderedDict(dict, DictMixin):\n-\n-    def __init__(self, *args, **kwds):\n-        if len(args) > 1:\n-            raise TypeError('expected at most 1 arguments, got %d' % len(args))\n-        try:\n-            self.__end\n-        except AttributeError:\n-            self.clear()\n-        self.update(*args, **kwds)\n-\n-    def clear(self):\n-        self.__end = end = []\n-        end += [None, end, end]         # sentinel node for doubly linked list\n-        self.__map = {}                 # key --> [key, prev, next]\n-        dict.clear(self)\n-\n-    def __setitem__(self, key, value):\n-        if key not in self:\n-            end = self.__end\n-            curr = end[1]\n-            curr[2] = end[1] = self.__map[key] = [key, curr, end]\n-        dict.__setitem__(self, key, value)\n-\n-    def __delitem__(self, key):\n-        dict.__delitem__(self, key)\n-        key, prev, next = self.__map.pop(key)\n-        prev[2] = next\n-        next[1] = prev\n-\n-    def __iter__(self):\n-        end = self.__end\n-        curr = end[2]\n-        while curr is not end:\n-            yield curr[0]\n-            curr = curr[2]\n-\n-    def __reversed__(self):\n-        end = self.__end\n-        curr = end[1]\n-        while curr is not end:\n-            yield curr[0]\n-            curr = curr[1]\n-\n-    def popitem(self, last=True):\n-        if not self:\n-            raise KeyError('dictionary is empty')\n-        # Modified from original to support Python 2.4, see\n-        # http://code.google.com/p/simplejson/issues/detail?id=53\n-        if last:\n-            key = reversed(self).next()\n-        else:\n-            key = iter(self).next()\n-        value = self.pop(key)\n-        return key, value\n-\n-    def __reduce__(self):\n-        items = [[k, self[k]] for k in self]\n-        tmp = self.__map, self.__end\n-        del self.__map, self.__end\n-        inst_dict = vars(self).copy()\n-        self.__map, self.__end = tmp\n-        if inst_dict:\n-            return (self.__class__, (items,), inst_dict)\n-        return self.__class__, (items,)\n-\n-    def keys(self):\n-        return list(self)\n-\n-    setdefault = DictMixin.setdefault\n-    update = DictMixin.update\n-    pop = DictMixin.pop\n-    values = DictMixin.values\n-    items = DictMixin.items\n-    iterkeys = DictMixin.iterkeys\n-    itervalues = DictMixin.itervalues\n-    iteritems = DictMixin.iteritems\n-\n-    def __repr__(self):\n-        if not self:\n-            return '%s()' % (self.__class__.__name__,)\n-        return '%s(%r)' % (self.__class__.__name__, self.items())\n-\n-    def copy(self):\n-        return self.__class__(self)\n-\n-    @classmethod\n-    def fromkeys(cls, iterable, value=None):\n-        d = cls()\n-        for key in iterable:\n-            d[key] = value\n-        return d\n-\n-    def __eq__(self, other):\n-        if isinstance(other, OrderedDict):\n-            return len(self)==len(other) and \\\n-                   all(p==q for p, q in  zip(self.items(), other.items()))\n-        return dict.__eq__(self, other)\n-\n-    def __ne__(self, other):\n-        return not self == other\n\n@@ -1,77 +0,0 @@\n-\"\"\"JSON token scanner\n-\"\"\"\n-import re\n-def _import_c_make_scanner():\n-    try:\n-        from scrapy.xlib.simplejson._speedups import make_scanner\n-        return make_scanner\n-    except ImportError:\n-        return None\n-c_make_scanner = _import_c_make_scanner()\n-\n-__all__ = ['make_scanner']\n-\n-NUMBER_RE = re.compile(\n-    r'(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?',\n-    (re.VERBOSE | re.MULTILINE | re.DOTALL))\n-\n-def py_make_scanner(context):\n-    parse_object = context.parse_object\n-    parse_array = context.parse_array\n-    parse_string = context.parse_string\n-    match_number = NUMBER_RE.match\n-    encoding = context.encoding\n-    strict = context.strict\n-    parse_float = context.parse_float\n-    parse_int = context.parse_int\n-    parse_constant = context.parse_constant\n-    object_hook = context.object_hook\n-    object_pairs_hook = context.object_pairs_hook\n-    memo = context.memo\n-\n-    def _scan_once(string, idx):\n-        try:\n-            nextchar = string[idx]\n-        except IndexError:\n-            raise StopIteration\n-\n-        if nextchar == '\"':\n-            return parse_string(string, idx + 1, encoding, strict)\n-        elif nextchar == '{':\n-            return parse_object((string, idx + 1), encoding, strict,\n-                _scan_once, object_hook, object_pairs_hook, memo)\n-        elif nextchar == '[':\n-            return parse_array((string, idx + 1), _scan_once)\n-        elif nextchar == 'n' and string[idx:idx + 4] == 'null':\n-            return None, idx + 4\n-        elif nextchar == 't' and string[idx:idx + 4] == 'true':\n-            return True, idx + 4\n-        elif nextchar == 'f' and string[idx:idx + 5] == 'false':\n-            return False, idx + 5\n-\n-        m = match_number(string, idx)\n-        if m is not None:\n-            integer, frac, exp = m.groups()\n-            if frac or exp:\n-                res = parse_float(integer + (frac or '') + (exp or ''))\n-            else:\n-                res = parse_int(integer)\n-            return res, m.end()\n-        elif nextchar == 'N' and string[idx:idx + 3] == 'NaN':\n-            return parse_constant('NaN'), idx + 3\n-        elif nextchar == 'I' and string[idx:idx + 8] == 'Infinity':\n-            return parse_constant('Infinity'), idx + 8\n-        elif nextchar == '-' and string[idx:idx + 9] == '-Infinity':\n-            return parse_constant('-Infinity'), idx + 9\n-        else:\n-            raise StopIteration\n-\n-    def scan_once(string, idx):\n-        try:\n-            return _scan_once(string, idx)\n-        finally:\n-            memo.clear()\n-\n-    return scan_once\n-\n-make_scanner = c_make_scanner or py_make_scanner\n\n@@ -1,39 +0,0 @@\n-r\"\"\"Command-line tool to validate and pretty-print JSON\n-\n-Usage::\n-\n-    $ echo '{\"json\":\"obj\"}' | python -m simplejson.tool\n-    {\n-        \"json\": \"obj\"\n-    }\n-    $ echo '{ 1.2:3.4}' | python -m simplejson.tool\n-    Expecting property name: line 1 column 2 (char 2)\n-\n-\"\"\"\n-import sys\n-import simplejson as json\n-\n-def main():\n-    if len(sys.argv) == 1:\n-        infile = sys.stdin\n-        outfile = sys.stdout\n-    elif len(sys.argv) == 2:\n-        infile = open(sys.argv[1], 'rb')\n-        outfile = sys.stdout\n-    elif len(sys.argv) == 3:\n-        infile = open(sys.argv[1], 'rb')\n-        outfile = open(sys.argv[2], 'wb')\n-    else:\n-        raise SystemExit(sys.argv[0] + \" [infile [outfile]]\")\n-    try:\n-        obj = json.load(infile,\n-                        object_pairs_hook=json.OrderedDict,\n-                        use_decimal=True)\n-    except ValueError, e:\n-        raise SystemExit(e)\n-    json.dump(obj, outfile, sort_keys=True, indent='    ', use_decimal=True)\n-    outfile.write('\\n')\n-\n-\n-if __name__ == '__main__':\n-    main()\n\n@@ -117,6 +117,8 @@ setup_args = {\n try:\n     from setuptools import setup\n     setup_args['install_requires'] = ['Twisted>=2.5', 'lxml']\n+    if sys.version_info < (2, 6):\n+        setup_args['install_requires'] += ['simplejson']\n except ImportError:\n     from distutils.core import setup\n  \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
