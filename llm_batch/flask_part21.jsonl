{"custom_id": "flask#02a131746074203dc8d747308f4d2c7ece8aa743", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 72 | Lines Deleted: 2 | Files Changed: 3 | Hunks: 10 | Methods Changed: 10 | Complexity Δ (Sum/Max): 10/7 | Churn Δ: 74 | Churn Cumulative: 5027 | Contributors (this commit): 17 | Commits (past 90d): 63 | Contributors (cumulative): 27 | DMM Complexity: 1.0\n\nDIFF:\n@@ -291,6 +291,13 @@ class Flask(_PackageBoundObject):\n         #: function here, use the :meth:`before_request` decorator.\n         self.before_request_funcs = {}\n \n+        #: A lists of functions that should be called at the beginning of the\n+        #: first request to this instance.  To register a function here, use\n+        #: the :meth:`before_first_request` decorator.\n+        #:\n+        #: .. versionadded:: 0.8\n+        self.before_first_request_funcs = []\n+\n         #: A dictionary with lists of functions that should be called after\n         #: each request.  The key of the dictionary is the name of the blueprint\n         #: this function is active for, `None` for all requests.  This can for\n@@ -386,6 +393,7 @@ class Flask(_PackageBoundObject):\n         # tracks internally if the application already handled at least one\n         # request.\n         self._got_first_request = False\n+        self._before_request_lock = Lock()\n \n         # register the static folder for the application.  Do that even\n         # if the folder does not exist.  First of all it might be created\n@@ -474,6 +482,15 @@ class Flask(_PackageBoundObject):\n \n         return rv\n \n+    @property\n+    def got_first_request(self):\n+        \"\"\"This attribute is set to `True` if the application started\n+        handling the first request.\n+\n+        .. versionadded:: 0.8\n+        \"\"\"\n+        return self._got_first_request\n+\n     def create_jinja_environment(self):\n         \"\"\"Creates the Jinja2 environment based on :attr:`jinja_options`\n         and :meth:`select_jinja_autoescape`.  Since 0.7 this also adds\n@@ -581,7 +598,13 @@ class Flask(_PackageBoundObject):\n             self.debug = options.pop('debug')\n         options.setdefault('use_reloader', self.debug)\n         options.setdefault('use_debugger', self.debug)\n-        return run_simple(host, port, self, **options)\n+        try:\n+            run_simple(host, port, self, **options)\n+        finally:\n+            # reset the first request information if the development server\n+            # resetted normally.  This makes it possible to restart the server\n+            # without reloader and that stuff from an interactive shell.\n+            self._got_first_request = False\n \n     def test_client(self, use_cookies=True):\n         \"\"\"Creates a test client for this application.  For information\n@@ -940,6 +963,15 @@ class Flask(_PackageBoundObject):\n         self.before_request_funcs.setdefault(None, []).append(f)\n         return f\n \n+    @setupmethod\n+    def before_first_request(self, f):\n+        \"\"\"Registers a function to be run before the first request to this\n+        instance of the application.\n+\n+        .. versionadded:: 0.8\n+        \"\"\"\n+        self.before_first_request_funcs.append(f)\n+\n     @setupmethod\n     def after_request(self, f):\n         \"\"\"Register a function to be run after each request.  Your function\n@@ -1131,7 +1163,7 @@ class Flask(_PackageBoundObject):\n \n         .. versionadded:: 0.7\n         \"\"\"\n-        self._got_first_request = True\n+        self.try_trigger_before_first_request_functions()\n         try:\n             request_started.send(self)\n             rv = self.preprocess_request()\n@@ -1144,6 +1176,22 @@ class Flask(_PackageBoundObject):\n         request_finished.send(self, response=response)\n         return response\n \n+    def try_trigger_before_first_request_functions(self):\n+        \"\"\"Called before each request and will ensure that it triggers\n+        the :attr:`before_first_request_funcs` and only exactly once per\n+        application instance (which means process usually).\n+\n+        .. versionadded:: 0.8\n+        \"\"\"\n+        if self._got_first_request:\n+            return\n+        with self._before_request_lock:\n+            if self._got_first_request:\n+                return\n+            self._got_first_request = True\n+            for func in self.before_first_request_funcs:\n+                func()\n+\n     def make_default_options_response(self):\n         \"\"\"This method is called to create the default `OPTIONS` response.\n         This can be changed through subclassing to change the default\n\n@@ -199,6 +199,13 @@ class Blueprint(_PackageBoundObject):\n             .setdefault(None, []).append(f))\n         return f\n \n+    def before_app_first_request(self, f):\n+        \"\"\"Like :meth:`Flask.before_first_request`.  Such a function is\n+        executed before the first request to the application.\n+        \"\"\"\n+        self.record_once(lambda s: s.app.before_first_request_funcs.append(f))\n+        return f\n+\n     def after_request(self, f):\n         \"\"\"Like :meth:`Flask.after_request` but for a blueprint.  This function\n         is only executed after each request that is handled by a function of\n\n@@ -950,6 +950,7 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n         @app.route('/')\n         def index():\n             return 'Awesome'\n+        self.assert_(not app.got_first_request)\n         self.assertEqual(app.test_client().get('/').data, 'Awesome')\n         try:\n             @app.route('/foo')\n@@ -965,6 +966,20 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n         def working():\n             return 'Meh'\n         self.assertEqual(app.test_client().get('/foo').data, 'Meh')\n+        self.assert_(app.got_first_request)\n+\n+    def test_before_first_request_functions(self):\n+        got = []\n+        app = flask.Flask(__name__)\n+        @app.before_first_request\n+        def foo():\n+            got.append(42)\n+        c = app.test_client()\n+        c.get('/')\n+        self.assertEqual(got, [42])\n+        c.get('/')\n+        self.assertEqual(got, [42])\n+        self.assert_(app.got_first_request)\n \n \n class JSONTestCase(unittest.TestCase):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ae00f6d149c353e1ecb683ccbf01be221324a646", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 21 | Lines Deleted: 3 | Files Changed: 3 | Hunks: 5 | Methods Changed: 4 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 24 | Churn Cumulative: 2616 | Contributors (this commit): 15 | Commits (past 90d): 32 | Contributors (cumulative): 17 | DMM Complexity: 1.0\n\nDIFF:\n@@ -17,6 +17,7 @@ import sys, os\n # add these directories to sys.path here. If the directory is relative to the\n # documentation root, use os.path.abspath to make it absolute, like shown here.\n sys.path.append(os.path.abspath('_themes'))\n+sys.path.append(os.path.abspath('.'))\n \n # -- General configuration -----------------------------------------------------\n \n@@ -25,7 +26,8 @@ sys.path.append(os.path.abspath('_themes'))\n \n # Add any Sphinx extension module names here, as strings. They can be extensions\n # coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\n-extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']\n+extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx',\n+              'flaskdocext']\n \n # Add any paths that contain templates here, relative to this directory.\n templates_path = ['_templates']\n\n@@ -0,0 +1,16 @@\n+import re\n+import inspect\n+\n+\n+_internal_mark_re = re.compile(r'^\\s*:internal:\\s*$(?m)')\n+\n+\n+def skip_member(app, what, name, obj, skip, options):\n+    docstring = inspect.getdoc(obj)\n+    if skip:\n+        return True\n+    return _internal_mark_re.search(docstring or '') is not None\n+\n+\n+def setup(app):\n+    app.connect('autodoc-skip-member', skip_member)\n\n@@ -257,7 +257,7 @@ class Flask(_PackageBoundObject):\n         #: to load a config from files.\n         self.config = Config(self.root_path, self.default_config)\n \n-        #: Prepare the deferred setup of the logger.\n+        # Prepare the deferred setup of the logger.\n         self._logger = None\n         self.logger_name = self.import_name\n \n@@ -1181,7 +1181,7 @@ class Flask(_PackageBoundObject):\n         the :attr:`before_first_request_funcs` and only exactly once per\n         application instance (which means process usually).\n \n-        .. versionadded:: 0.8\n+        :internal:\n         \"\"\"\n         if self._got_first_request:\n             return\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#505cd663cd75b5593a1c9db0eded5298bd67139a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 161 | Contributors (this commit): 1 | Commits (past 90d): 6 | Contributors (cumulative): 1 | DMM Complexity: 0.0\n\nDIFF:\n@@ -16,6 +16,8 @@ import re\n from datetime import datetime, date\n from subprocess import Popen, PIPE\n \n+_date_clean_re = re.compile(r'(\\d+)(st|nd|rd|th)')\n+\n \n def parse_changelog():\n     with open('CHANGES') as f:\n@@ -52,8 +54,7 @@ def bump_version(version):\n \n \n def parse_date(string):\n-    string = string.replace('th ', ' ').replace('nd ', ' ') \\\n-                   .replace('rd ', ' ').replace('st ', ' ')\n+    string = _date_clean_re.sub(r'\\1', string)\n     return datetime.strptime(string, '%B %d %Y')\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#acac64e36a046cebae07bee7f3e8106b4a80288a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 5 | Files Changed: 2 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 10 | Churn Cumulative: 4591 | Contributors (this commit): 17 | Commits (past 90d): 54 | Contributors (cumulative): 25 | DMM Complexity: None\n\nDIFF:\n@@ -216,7 +216,7 @@ class Flask(_PackageBoundObject):\n         'LOGGER_NAME':                          None,\n         'SERVER_NAME':                          None,\n         'MAX_CONTENT_LENGTH':                   None,\n-        'TRAP_BAD_REQUEST_KEY_ERRORS':          False,\n+        'TRAP_BAD_REQUEST_ERRORS':              False,\n         'TRAP_HTTP_EXCEPTIONS':                 False\n     })\n \n@@ -1054,7 +1054,7 @@ class Flask(_PackageBoundObject):\n     def trap_http_exception(self, e):\n         \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n         this will return `False` for all exceptions except for a bad request\n-        key error if ``TRAP_BAD_REQUEST_KEY_ERRORS`` is set to `True`.  It\n+        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to `True`.  It\n         also returns `True` if ``TRAP_HTTP_EXCEPTIONS`` is set to `True`.\n \n         This is called for all HTTP exceptions raised by a view function.\n@@ -1067,8 +1067,8 @@ class Flask(_PackageBoundObject):\n         \"\"\"\n         if self.config['TRAP_HTTP_EXCEPTIONS']:\n             return True\n-        if self.config['TRAP_BAD_REQUEST_KEY_ERRORS']:\n-            return isinstance(e, BadRequest) and isinstance(e, LookupError)\n+        if self.config['TRAP_BAD_REQUEST_ERRORS']:\n+            return isinstance(e, BadRequest)\n         return False\n \n     def handle_user_exception(self, e):\n\n@@ -601,7 +601,7 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n         c = app.test_client()\n         assert c.get('/fail').status_code == 400\n \n-        app.config['TRAP_BAD_REQUEST_KEY_ERRORS'] = True\n+        app.config['TRAP_BAD_REQUEST_ERRORS'] = True\n         c = app.test_client()\n         try:\n             c.get('/fail')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ce701319756abef4d09c585828a630b8fdef89fc", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 22 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 4 | Methods Changed: 4 | Complexity Δ (Sum/Max): 4/2 | Churn Δ: 22 | Churn Cumulative: 2567 | Contributors (this commit): 13 | Commits (past 90d): 34 | Contributors (cumulative): 15 | DMM Complexity: 1.0\n\nDIFF:\n@@ -10,6 +10,7 @@\n \"\"\"\n \n from werkzeug.wrappers import Request as RequestBase, Response as ResponseBase\n+from werkzeug.exceptions import BadRequest\n from werkzeug.utils import cached_property\n \n from .debughelpers import attach_enctype_error_multidict\n@@ -96,9 +97,21 @@ class Request(RequestBase):\n             _assert_have_json()\n         if self.mimetype == 'application/json':\n             request_charset = self.mimetype_params.get('charset')\n+            try:\n                 if request_charset is not None:\n                     return json.loads(self.data, encoding=request_charset)\n                 return json.loads(self.data)\n+            except ValueError, e:\n+                return self.on_json_loading_failed(e)\n+\n+    def on_json_loading_failed(self, e):\n+        \"\"\"Called if decoding of the JSON data failed.  The return value of\n+        this method is used by :attr:`json` when an error ocurred.  The\n+        default implementation raises a :class:`~werkzeug.exceptions.BadRequest`.\n+\n+        .. versionadded:: 0.8\n+        \"\"\"\n+        raise BadRequest()\n \n     def _load_form_data(self):\n         RequestBase._load_form_data(self)\n\n@@ -984,6 +984,15 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n \n class JSONTestCase(unittest.TestCase):\n \n+    def test_json_bad_requests(self):\n+        app = flask.Flask(__name__)\n+        @app.route('/json', methods=['POST'])\n+        def return_json():\n+            return unicode(flask.request.json)\n+        c = app.test_client()\n+        rv = c.post('/json', data='malformed', content_type='application/json')\n+        self.assertEqual(rv.status_code, 400)\n+\n     def test_json_body_encoding(self):\n         app = flask.Flask(__name__)\n         app.testing = True\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#68473291344629dff3955fdc07776f2fca7b9b69", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 68 | Lines Deleted: 2 | Files Changed: 3 | Hunks: 5 | Methods Changed: 5 | Complexity Δ (Sum/Max): 9/4 | Churn Δ: 70 | Churn Cumulative: 4740 | Contributors (this commit): 17 | Commits (past 90d): 63 | Contributors (cumulative): 26 | DMM Complexity: 1.0\n\nDIFF:\n@@ -18,7 +18,7 @@ from itertools import chain\n from functools import update_wrapper\n \n from werkzeug.datastructures import ImmutableDict\n-from werkzeug.routing import Map, Rule\n+from werkzeug.routing import Map, Rule, RequestRedirect\n from werkzeug.exceptions import HTTPException, InternalServerError, \\\n      MethodNotAllowed, BadRequest\n \n@@ -1134,6 +1134,22 @@ class Flask(_PackageBoundObject):\n             return InternalServerError()\n         return handler(e)\n \n+    def raise_routing_exception(self, request):\n+        \"\"\"Exceptions that are recording during routing are reraised with\n+        this method.  During debug we are not reraising redirect requests\n+        for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising\n+        a different error instead to help debug situations.\n+\n+        :internal:\n+        \"\"\"\n+        if not self.debug \\\n+           or not isinstance(request.routing_exception, RequestRedirect) \\\n+           or request.method in ('GET', 'HEAD', 'OPTIONS'):\n+            raise request.routing_exception\n+\n+        from .debughelpers import FormDataRoutingRedirect\n+        raise FormDataRoutingRedirect(request)\n+\n     def dispatch_request(self):\n         \"\"\"Does the request dispatching.  Matches the URL and returns the\n         return value of the view or error handler.  This does not have to\n@@ -1146,7 +1162,7 @@ class Flask(_PackageBoundObject):\n         \"\"\"\n         req = _request_ctx_stack.top.request\n         if req.routing_exception is not None:\n-            raise req.routing_exception\n+            self.raise_routing_exception(req)\n         rule = req.url_rule\n         # if we provide automatic options for this URL and the\n         # request came with the OPTIONS method, reply automatically\n\n@@ -33,6 +33,32 @@ class DebugFilesKeyError(KeyError, AssertionError):\n         return self.msg\n \n \n+class FormDataRoutingRedirect(AssertionError):\n+    \"\"\"This exception is raised by Flask in debug mode if it detects a\n+    redirect caused by the routing system when the request method is not\n+    GET, HEAD or OPTIONS.  Reasoning: form data will be dropped.\n+    \"\"\"\n+\n+    def __init__(self, request):\n+        exc = request.routing_exception\n+        buf = ['A request was sent to this URL (%s) but a redirect was '\n+               'issued automatically by the routing system to \"%s\".'\n+               % (request.url, exc.new_url)]\n+\n+        # In case just a slash was appended we can be extra helpful\n+        if request.base_url + '/' == exc.new_url.split('?')[0]:\n+            buf.append('  The URL was defined with a trailing slash so '\n+                       'Flask will automatically redirect to the URL '\n+                       'with the trailing slash if it was accessed '\n+                       'without one.')\n+\n+        buf.append('  Make sure to directly send your %s-request to this URL '\n+                   'since we can\\'t make browsers or HTTP clients redirect '\n+                   'with form data.' % request.method)\n+        buf.append('\\n\\nNote: this exception is only raised in debug mode')\n+        AssertionError.__init__(self, ''.join(buf).encode('utf-8'))\n+\n+\n def attach_enctype_error_multidict(request):\n     \"\"\"Since Flask 0.8 we're monkeypatching the files object in case a\n     request is detected that does not use multipart form data but the files\n\n@@ -981,6 +981,30 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n         self.assertEqual(got, [42])\n         self.assert_(app.got_first_request)\n \n+    def test_routing_redirect_debugging(self):\n+        app = flask.Flask(__name__)\n+        app.debug = True\n+        @app.route('/foo/', methods=['GET', 'POST'])\n+        def foo():\n+            return 'success'\n+        with app.test_client() as c:\n+            try:\n+                c.post('/foo', data={})\n+            except AssertionError, e:\n+                self.assert_('http://localhost/foo/' in str(e))\n+                self.assert_('Make sure to directly send your POST-request '\n+                             'to this URL' in str(e))\n+            else:\n+                self.fail('Expected exception')\n+\n+            rv = c.get('/foo', data={}, follow_redirects=True)\n+            self.assertEqual(rv.data, 'success')\n+\n+        app.debug = False\n+        with app.test_client() as c:\n+            rv = c.post('/foo', data={}, follow_redirects=True)\n+            self.assertEqual(rv.data, 'success')\n+\n \n class JSONTestCase(unittest.TestCase):\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#63876614b6734e6404f17c9d3d22b71b3f43d158", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 216 | Contributors (this commit): 4 | Commits (past 90d): 11 | Contributors (cumulative): 4 | DMM Complexity: None\n\nDIFF:\n@@ -91,7 +91,9 @@ class Request(RequestBase):\n     @cached_property\n     def json(self):\n         \"\"\"If the mimetype is `application/json` this will contain the\n-        parsed JSON data.\n+        parsed JSON data.  Otherwise this will be `None`.\n+\n+        This requires Python 2.6 or an installed version of simplejson.\n         \"\"\"\n         if __debug__:\n             _assert_have_json()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#153ecbc9202f249c4037602115ed2c2b5785550d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 89 | Lines Deleted: 8 | Files Changed: 2 | Hunks: 8 | Methods Changed: 5 | Complexity Δ (Sum/Max): 8/6 | Churn Δ: 97 | Churn Cumulative: 4741 | Contributors (this commit): 17 | Commits (past 90d): 59 | Contributors (cumulative): 25 | DMM Complexity: 0.0\n\nDIFF:\n@@ -11,6 +11,7 @@\n \n from __future__ import with_statement\n \n+import os\n import sys\n from threading import Lock\n from datetime import timedelta\n@@ -103,14 +104,33 @@ class Flask(_PackageBoundObject):\n         pick up SQL queries in `yourapplication.app` and not\n         `yourapplication.views.frontend`)\n \n-    .. versionadded:: 0.5\n-       The `static_path` parameter was added.\n+    .. versionadded:: 0.7\n+       The `static_url_path`, `static_folder`, and `template_folder`\n+       parameters were added.\n+\n+    .. versionadded:: 0.8\n+       The `instance_path` and `instance_relative_config` parameters were\n+       added.\n \n     :param import_name: the name of the application package\n-    :param static_path: can be used to specify a different path for the\n-                        static files on the web.  Defaults to ``/static``.\n-                        This does not affect the folder the files are served\n-                        *from*.\n+    :param static_url_path: can be used to specify a different path for the\n+                            static files on the web.  Defaults to the name\n+                            of the `static_folder` folder.\n+    :param static_folder: the folder with static files that should be served\n+                          at `static_url_path`.  Defaults to the ``'static'``\n+                          folder in the root path of the application.\n+    :param template_folder: the folder that contains the templates that should\n+                            be used by the application.  Defaults to\n+                            ``'templates'`` folder in the root path of the\n+                            application.\n+    :param instance_path: An alternative instance path for the application.\n+                          By default the folder ``'instance'`` next to the\n+                          package or module is assumed to be the instance\n+                          path.\n+    :param instance_relative_config: if set to `True` relative filenames\n+                                     for loading the config are assumed to\n+                                     be relative to the instance path instead\n+                                     of the application root.\n     \"\"\"\n \n     #: The class that is used for request objects.  See :class:`~flask.Request`\n@@ -238,7 +258,8 @@ class Flask(_PackageBoundObject):\n     session_interface = SecureCookieSessionInterface()\n \n     def __init__(self, import_name, static_path=None, static_url_path=None,\n-                 static_folder='static', template_folder='templates'):\n+                 static_folder='static', template_folder='templates',\n+                 instance_path=None, instance_relative_config=False):\n         _PackageBoundObject.__init__(self, import_name,\n                                      template_folder=template_folder)\n         if static_path is not None:\n@@ -251,11 +272,21 @@ class Flask(_PackageBoundObject):\n             self.static_url_path = static_url_path\n         if static_folder is not None:\n             self.static_folder = static_folder\n+        if instance_path is None:\n+            instance_path = self.auto_find_instance_path()\n+        elif not os.path.isabs(instance_path):\n+            raise ValueError('If an instance path is provided it must be '\n+                             'absolute.  A relative path was given instead.')\n+\n+        #: Holds the path to the instance folder.\n+        #:\n+        #: .. versionadded:: 0.8\n+        self.instance_path = instance_path\n \n         #: The configuration dictionary as :class:`Config`.  This behaves\n         #: exactly like a regular dictionary but supports additional methods\n         #: to load a config from files.\n-        self.config = Config(self.root_path, self.default_config)\n+        self.config = self.make_config(instance_relative_config)\n \n         # Prepare the deferred setup of the logger.\n         self._logger = None\n@@ -491,6 +522,38 @@ class Flask(_PackageBoundObject):\n         \"\"\"\n         return self._got_first_request\n \n+    def make_config(self, instance_relative=False):\n+        \"\"\"Used to create the config attribute by the Flask constructor.\n+        The `instance_relative` parameter is passed in from the constructor\n+        of Flask (there named `instance_relative_config`) and indicates if\n+        the config should be relative to the instance path or the root path\n+        of the application.\n+\n+        .. versionadded:: 0.8\n+        \"\"\"\n+        root_path = self.root_path\n+        if instance_relative:\n+            root_path = self.instance_path\n+        return Config(root_path, self.default_config)\n+\n+    def auto_find_instance_path(self):\n+        \"\"\"Tries to locate the instance path if it was not provided to the\n+        constructor of the application class.  It will basically calculate\n+        the path to a folder named ``instance`` next to your main file or\n+        the package.\n+\n+        .. versionadded:: 0.8\n+        \"\"\"\n+        root_mod = sys.modules[self.import_name.split('.')[0]]\n+        instance_path = None\n+        if hasattr(root_mod, '__path__'):\n+            package_dir = os.path.dirname(root_mod.__file__)\n+            instance_path = os.path.join(package_dir, os.path.pardir)\n+        else:\n+            instance_path = os.path.dirname(root_mod.__file__)\n+        basedir = os.path.normpath(os.path.abspath(instance_path))\n+        return os.path.join(basedir, 'instance')\n+\n     def create_jinja_environment(self):\n         \"\"\"Creates the Jinja2 environment based on :attr:`jinja_options`\n         and :meth:`select_jinja_autoescape`.  Since 0.7 this also adds\n\n@@ -1005,6 +1005,24 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n             rv = c.post('/foo', data={}, follow_redirects=True)\n             self.assertEqual(rv.data, 'success')\n \n+    def test_basic_instance_paths(self):\n+        here = os.path.abspath(os.path.dirname(__file__))\n+        app = flask.Flask(__name__)\n+        self.assertEqual(app.instance_path, os.path.join(here, 'instance'))\n+\n+        app = flask.Flask(__name__, instance_path=here)\n+        self.assertEqual(app.instance_path, here)\n+\n+        try:\n+            flask.Flask(__name__, instance_path='instance')\n+        except ValueError, e:\n+            self.assert_('must be absolute' in str(e))\n+        else:\n+            self.fail('Expected value error')\n+\n+        from blueprintapp import app\n+        self.assertEqual(app.instance_path, os.path.join(here, 'instance'))\n+\n \n class JSONTestCase(unittest.TestCase):\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#187cb80dcc1b087f1a7b7d4d67afbd531ad01cd2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 2/1 | Churn Δ: 17 | Churn Cumulative: 3213 | Contributors (this commit): 20 | Commits (past 90d): 45 | Contributors (cumulative): 26 | DMM Complexity: 1.0\n\nDIFF:\n@@ -554,6 +554,17 @@ class Flask(_PackageBoundObject):\n         basedir = os.path.normpath(os.path.abspath(instance_path))\n         return os.path.join(basedir, 'instance')\n \n+    def open_instance_resource(self, resource, mode='rb'):\n+        \"\"\"Opens a resource from the application's instance folder\n+        (:attr:`instance_path`).  Otherwise works like\n+        :meth:`open_resource`.  Instance resources can also be opened for\n+        writing.\n+\n+        :param resource: the name of the resource.  To access resources within\n+                         subfolders use forward slashes as separator.\n+        \"\"\"\n+        return open(os.path.join(self.instance_path, resource), mode)\n+\n     def create_jinja_environment(self):\n         \"\"\"Creates the Jinja2 environment based on :attr:`jinja_options`\n         and :meth:`select_jinja_autoescape`.  Since 0.7 this also adds\n\n@@ -565,7 +565,7 @@ class _PackageBoundObject(object):\n             raise RuntimeError('No static folder for this object')\n         return send_from_directory(self.static_folder, filename)\n \n-    def open_resource(self, resource):\n+    def open_resource(self, resource, mode='rb'):\n         \"\"\"Opens a resource from the application's resource folder.  To see\n         how this works, consider the following folder structure::\n \n@@ -587,4 +587,6 @@ class _PackageBoundObject(object):\n         :param resource: the name of the resource.  To access resources within\n                          subfolders use forward slashes as separator.\n         \"\"\"\n-        return open(os.path.join(self.root_path, resource), 'rb')\n+        if mode not in ('r', 'rb'):\n+            raise ValueError('Resources can only be opened for reading')\n+        return open(os.path.join(self.root_path, resource), mode)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#175d43b2f9c7825b0df4c1049ab571cb1877a807", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 93 | Lines Deleted: 9 | Files Changed: 3 | Hunks: 11 | Methods Changed: 12 | Complexity Δ (Sum/Max): 13/7 | Churn Δ: 102 | Churn Cumulative: 5712 | Contributors (this commit): 23 | Commits (past 90d): 74 | Contributors (cumulative): 37 | DMM Complexity: 1.0\n\nDIFF:\n@@ -447,6 +447,23 @@ class Flask(_PackageBoundObject):\n     error_handlers = property(_get_error_handlers, _set_error_handlers)\n     del _get_error_handlers, _set_error_handlers\n \n+    @locked_cached_property\n+    def name(self):\n+        \"\"\"The name of the application.  This is usually the import name\n+        with the difference that it's guessed from the run file if the\n+        import name is main.  This name is used as a display name when\n+        Flask needs the name of the application.  It can be set and overriden\n+        to change the value.\n+\n+        .. versionadded:: 0.8\n+        \"\"\"\n+        if self.import_name == '__main__':\n+            fn = getattr(sys.modules['__main__'], '__file__', None)\n+            if fn is None:\n+                return 'unknown'\n+            return os.path.splitext(os.path.basename(fn))[0]\n+        return self.import_name\n+\n     @property\n     def propagate_exceptions(self):\n         \"\"\"Returns the value of the `PROPAGATE_EXCEPTIONS` configuration\n@@ -545,14 +562,26 @@ class Flask(_PackageBoundObject):\n         .. versionadded:: 0.8\n         \"\"\"\n         root_mod = sys.modules[self.import_name.split('.')[0]]\n-        instance_path = None\n+        # we're not using root_mod.__file__ here since the module could be\n+        # virtual.  We're trusting the _PackageBoundObject to have calculated\n+        # the proper name.\n+        package_path = self.root_path\n         if hasattr(root_mod, '__path__'):\n-            package_dir = os.path.dirname(root_mod.__file__)\n-            instance_path = os.path.join(package_dir, os.path.pardir)\n+            package_path = os.path.dirname(package_path)\n+        site_parent, site_folder = os.path.split(package_path)\n+\n+        py_prefix = os.path.abspath(sys.prefix)\n+        if package_path.startswith(py_prefix):\n+            base_dir = py_prefix\n+        elif site_folder == 'site-packages':\n+            parent, folder = os.path.split(site_parent)\n+            if folder.lower() == 'lib':\n+                base_dir = parent\n             else:\n-            instance_path = os.path.dirname(root_mod.__file__)\n-        basedir = os.path.normpath(os.path.abspath(instance_path))\n-        return os.path.join(basedir, 'instance')\n+                base_dir = site_parent\n+        else:\n+            return os.path.join(package_path, 'instance')\n+        return os.path.join(base_dir, 'share', self.name + '-instance')\n \n     def open_instance_resource(self, resource, mode='rb'):\n         \"\"\"Opens a resource from the application's instance folder\n\n@@ -466,7 +466,7 @@ def send_from_directory(directory, filename, **options):\n     return send_file(filename, conditional=True, **options)\n \n \n-def _get_package_path(name):\n+def get_package_path(name):\n     \"\"\"Returns the path to a package or cwd if that cannot be found.\"\"\"\n     try:\n         return os.path.abspath(os.path.dirname(sys.modules[name].__file__))\n@@ -512,7 +512,7 @@ class _PackageBoundObject(object):\n         self.template_folder = template_folder\n \n         #: Where is the app root located?\n-        self.root_path = _get_package_path(self.import_name)\n+        self.root_path = get_package_path(self.import_name)\n \n         self._static_folder = None\n         self._static_url_path = None\n\n@@ -1005,7 +1005,10 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n             rv = c.post('/foo', data={}, follow_redirects=True)\n             self.assertEqual(rv.data, 'success')\n \n-    def test_basic_instance_paths(self):\n+\n+class InstanceTestCase(unittest.TestCase):\n+\n+    def test_uninstalled_module_paths(self):\n         here = os.path.abspath(os.path.dirname(__file__))\n         app = flask.Flask(__name__)\n         self.assertEqual(app.instance_path, os.path.join(here, 'instance'))\n@@ -1020,9 +1023,60 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n         else:\n             self.fail('Expected value error')\n \n+    def test_uninstalled_package_paths(self):\n         from blueprintapp import app\n+        here = os.path.abspath(os.path.dirname(__file__))\n         self.assertEqual(app.instance_path, os.path.join(here, 'instance'))\n \n+    def test_installed_module_paths(self):\n+        import types\n+        expected_prefix = os.path.abspath('foo')\n+        mod = types.ModuleType('myapp')\n+        mod.__file__ = os.path.join(expected_prefix, 'lib',\n+                                    'site-packages', 'myapp.py')\n+        sys.modules['myapp'] = mod\n+        try:\n+            mod.app = flask.Flask(mod.__name__)\n+            self.assertEqual(mod.app.instance_path,\n+                             os.path.join(expected_prefix, 'share',\n+                                          'myapp-instance'))\n+        finally:\n+            sys.modules['myapp'] = None\n+\n+    def test_installed_package_paths(self):\n+        import types\n+        expected_prefix = os.path.abspath('foo')\n+        package_path = os.path.join(expected_prefix, 'lib',\n+                                    'site-packages', 'myapp')\n+        mod = types.ModuleType('myapp')\n+        mod.__path__ = [package_path]\n+        mod.__file__ = os.path.join(package_path, '__init__.py')\n+        sys.modules['myapp'] = mod\n+        try:\n+            mod.app = flask.Flask(mod.__name__)\n+            self.assertEqual(mod.app.instance_path,\n+                             os.path.join(expected_prefix, 'share',\n+                                          'myapp-instance'))\n+        finally:\n+            sys.modules['myapp'] = None\n+\n+    def test_prefix_installed_paths(self):\n+        import types\n+        expected_prefix = os.path.abspath(sys.prefix)\n+        package_path = os.path.join(expected_prefix, 'lib',\n+                                    'site-packages', 'myapp')\n+        mod = types.ModuleType('myapp')\n+        mod.__path__ = [package_path]\n+        mod.__file__ = os.path.join(package_path, '__init__.py')\n+        sys.modules['myapp'] = mod\n+        try:\n+            mod.app = flask.Flask(mod.__name__)\n+            self.assertEqual(mod.app.instance_path,\n+                             os.path.join(expected_prefix, 'share',\n+                                          'myapp-instance'))\n+        finally:\n+            sys.modules['myapp'] = None\n+\n \n class JSONTestCase(unittest.TestCase):\n \n@@ -2114,6 +2168,7 @@ def suite():\n     suite.addTest(unittest.makeSuite(SubdomainTestCase))\n     suite.addTest(unittest.makeSuite(ViewTestCase))\n     suite.addTest(unittest.makeSuite(DeprecationsTestCase))\n+    suite.addTest(unittest.makeSuite(InstanceTestCase))\n     if flask.json_available:\n         suite.addTest(unittest.makeSuite(JSONTestCase))\n     if flask.signals_available:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#e328eba97cc87a34e846693b62d17bdedaf27134", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 4 | Methods Changed: 4 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 8 | Churn Cumulative: 4858 | Contributors (this commit): 17 | Commits (past 90d): 64 | Contributors (cumulative): 25 | DMM Complexity: 0.0\n\nDIFF:\n@@ -577,6 +577,8 @@ class Flask(_PackageBoundObject):\n             parent, folder = os.path.split(site_parent)\n             if folder.lower() == 'lib':\n                 base_dir = parent\n+            elif os.path.basename(parent).lower() == 'lib':\n+                base_dir = os.path.dirname(parent)\n             else:\n                 base_dir = site_parent\n         else:\n\n@@ -1032,7 +1032,7 @@ class InstanceTestCase(unittest.TestCase):\n         import types\n         expected_prefix = os.path.abspath('foo')\n         mod = types.ModuleType('myapp')\n-        mod.__file__ = os.path.join(expected_prefix, 'lib',\n+        mod.__file__ = os.path.join(expected_prefix, 'lib', 'python2.5',\n                                     'site-packages', 'myapp.py')\n         sys.modules['myapp'] = mod\n         try:\n@@ -1046,7 +1046,7 @@ class InstanceTestCase(unittest.TestCase):\n     def test_installed_package_paths(self):\n         import types\n         expected_prefix = os.path.abspath('foo')\n-        package_path = os.path.join(expected_prefix, 'lib',\n+        package_path = os.path.join(expected_prefix, 'lib', 'python2.5',\n                                     'site-packages', 'myapp')\n         mod = types.ModuleType('myapp')\n         mod.__path__ = [package_path]\n@@ -1063,7 +1063,7 @@ class InstanceTestCase(unittest.TestCase):\n     def test_prefix_installed_paths(self):\n         import types\n         expected_prefix = os.path.abspath(sys.prefix)\n-        package_path = os.path.join(expected_prefix, 'lib',\n+        package_path = os.path.join(expected_prefix, 'lib', 'python2.5',\n                                     'site-packages', 'myapp')\n         mod = types.ModuleType('myapp')\n         mod.__path__ = [package_path]\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#74f4af59f631ef154ffe6f34d8e525a05f97d4a6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 2400 | Contributors (this commit): 14 | Commits (past 90d): 37 | Contributors (cumulative): 14 | DMM Complexity: None\n\nDIFF:\n@@ -575,8 +575,10 @@ class Flask(_PackageBoundObject):\n             base_dir = py_prefix\n         elif site_folder == 'site-packages':\n             parent, folder = os.path.split(site_parent)\n+            # Windows like installations\n             if folder.lower() == 'lib':\n                 base_dir = parent\n+            # UNIX like installations\n             elif os.path.basename(parent).lower() == 'lib':\n                 base_dir = os.path.dirname(parent)\n             else:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#fb1a6730cfbf63b6d6ccda93381f0823d8b6c85a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 22 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 3/2 | Churn Δ: 23 | Churn Cumulative: 4883 | Contributors (this commit): 17 | Commits (past 90d): 67 | Contributors (cumulative): 25 | DMM Complexity: 0.8888888888888888\n\nDIFF:\n@@ -568,8 +568,12 @@ class Flask(_PackageBoundObject):\n         package_path = self.root_path\n         if hasattr(root_mod, '__path__'):\n             package_path = os.path.dirname(package_path)\n-        site_parent, site_folder = os.path.split(package_path)\n \n+        # leave the egg wrapper folder or the actual .egg on the filesystem\n+        if os.path.basename(package_path).endswith('.egg'):\n+            package_path = os.path.dirname(package_path)\n+\n+        site_parent, site_folder = os.path.split(package_path)\n         py_prefix = os.path.abspath(sys.prefix)\n         if package_path.startswith(py_prefix):\n             base_dir = py_prefix\n\n@@ -1077,6 +1077,23 @@ class InstanceTestCase(unittest.TestCase):\n         finally:\n             sys.modules['myapp'] = None\n \n+    def test_egg_installed_paths(self):\n+        import types\n+        expected_prefix = os.path.abspath(sys.prefix)\n+        package_path = os.path.join(expected_prefix, 'lib', 'python2.5',\n+                                    'site-packages', 'MyApp.egg', 'myapp')\n+        mod = types.ModuleType('myapp')\n+        mod.__path__ = [package_path]\n+        mod.__file__ = os.path.join(package_path, '__init__.py')\n+        sys.modules['myapp'] = mod\n+        try:\n+            mod.app = flask.Flask(mod.__name__)\n+            self.assertEqual(mod.app.instance_path,\n+                             os.path.join(expected_prefix, 'share',\n+                                          'myapp-instance'))\n+        finally:\n+            sys.modules['myapp'] = None\n+\n \n class JSONTestCase(unittest.TestCase):\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#b3aaf6d5ca4fa53cc78456b2df01ab4d11cec84a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 46 | Lines Deleted: 33 | Files Changed: 3 | Hunks: 8 | Methods Changed: 6 | Complexity Δ (Sum/Max): 3/8 | Churn Δ: 79 | Churn Cumulative: 5824 | Contributors (this commit): 23 | Commits (past 90d): 82 | Contributors (cumulative): 37 | DMM Complexity: 0.5555555555555556\n\nDIFF:\n@@ -24,7 +24,8 @@ from werkzeug.exceptions import HTTPException, InternalServerError, \\\n      MethodNotAllowed, BadRequest\n \n from .helpers import _PackageBoundObject, url_for, get_flashed_messages, \\\n-    locked_cached_property, _tojson_filter, _endpoint_from_view_func\n+    locked_cached_property, _tojson_filter, _endpoint_from_view_func, \\\n+    find_package\n from .wrappers import Request, Response\n from .config import ConfigAttribute, Config\n from .ctx import RequestContext\n@@ -561,35 +562,10 @@ class Flask(_PackageBoundObject):\n \n         .. versionadded:: 0.8\n         \"\"\"\n-        root_mod = sys.modules[self.import_name.split('.')[0]]\n-        # we're not using root_mod.__file__ here since the module could be\n-        # virtual.  We're trusting the _PackageBoundObject to have calculated\n-        # the proper name.\n-        package_path = self.root_path\n-        if hasattr(root_mod, '__path__'):\n-            package_path = os.path.dirname(package_path)\n-\n-        # leave the egg wrapper folder or the actual .egg on the filesystem\n-        if os.path.basename(package_path).endswith('.egg'):\n-            package_path = os.path.dirname(package_path)\n-\n-        site_parent, site_folder = os.path.split(package_path)\n-        py_prefix = os.path.abspath(sys.prefix)\n-        if package_path.startswith(py_prefix):\n-            base_dir = py_prefix\n-        elif site_folder == 'site-packages':\n-            parent, folder = os.path.split(site_parent)\n-            # Windows like installations\n-            if folder.lower() == 'lib':\n-                base_dir = parent\n-            # UNIX like installations\n-            elif os.path.basename(parent).lower() == 'lib':\n-                base_dir = os.path.dirname(parent)\n-            else:\n-                base_dir = site_parent\n-        else:\n+        prefix, package_path = find_package(self.import_name)\n+        if prefix is None:\n             return os.path.join(package_path, 'instance')\n-        return os.path.join(base_dir, 'share', self.name + '-instance')\n+        return os.path.join(prefix, 'var', self.name + '-instance')\n \n     def open_instance_resource(self, resource, mode='rb'):\n         \"\"\"Opens a resource from the application's instance folder\n\n@@ -474,6 +474,43 @@ def get_package_path(name):\n         return os.getcwd()\n \n \n+def find_package(import_name):\n+    \"\"\"Finds a package and returns the prefix (or None if the package is\n+    not installed) as well as the folder that contains the package or\n+    module as a tuple.\n+    \"\"\"\n+    root_mod = sys.modules[import_name.split('.')[0]]\n+    package_path = getattr(root_mod, '__file__', None)\n+    if package_path is None:\n+        package_path = os.getcwd()\n+    else:\n+        package_path = os.path.abspath(os.path.dirname(package_path))\n+    if hasattr(root_mod, '__path__'):\n+        package_path = os.path.dirname(package_path)\n+\n+    # leave the egg wrapper folder or the actual .egg on the filesystem\n+    test_package_path = package_path\n+    if os.path.basename(test_package_path).endswith('.egg'):\n+        test_package_path = os.path.dirname(test_package_path)\n+\n+    site_parent, site_folder = os.path.split(test_package_path)\n+    py_prefix = os.path.abspath(sys.prefix)\n+    if test_package_path.startswith(py_prefix):\n+        return py_prefix, package_path\n+    elif site_folder.lower() == 'site-packages':\n+        parent, folder = os.path.split(site_parent)\n+        # Windows like installations\n+        if folder.lower() == 'lib':\n+            base_dir = parent\n+        # UNIX like installations\n+        elif os.path.basename(parent).lower() == 'lib':\n+            base_dir = os.path.dirname(parent)\n+        else:\n+            base_dir = site_parent\n+        return base_dir, package_path\n+    return None, package_path\n+\n+\n class locked_cached_property(object):\n     \"\"\"A decorator that converts a function into a lazy property.  The\n     function wrapped is called the first time to retrieve the result\n\n@@ -1038,7 +1038,7 @@ class InstanceTestCase(unittest.TestCase):\n         try:\n             mod.app = flask.Flask(mod.__name__)\n             self.assertEqual(mod.app.instance_path,\n-                             os.path.join(expected_prefix, 'share',\n+                             os.path.join(expected_prefix, 'var',\n                                           'myapp-instance'))\n         finally:\n             sys.modules['myapp'] = None\n@@ -1055,7 +1055,7 @@ class InstanceTestCase(unittest.TestCase):\n         try:\n             mod.app = flask.Flask(mod.__name__)\n             self.assertEqual(mod.app.instance_path,\n-                             os.path.join(expected_prefix, 'share',\n+                             os.path.join(expected_prefix, 'var',\n                                           'myapp-instance'))\n         finally:\n             sys.modules['myapp'] = None\n@@ -1072,7 +1072,7 @@ class InstanceTestCase(unittest.TestCase):\n         try:\n             mod.app = flask.Flask(mod.__name__)\n             self.assertEqual(mod.app.instance_path,\n-                             os.path.join(expected_prefix, 'share',\n+                             os.path.join(expected_prefix, 'var',\n                                           'myapp-instance'))\n         finally:\n             sys.modules['myapp'] = None\n@@ -1089,7 +1089,7 @@ class InstanceTestCase(unittest.TestCase):\n         try:\n             mod.app = flask.Flask(mod.__name__)\n             self.assertEqual(mod.app.instance_path,\n-                             os.path.join(expected_prefix, 'share',\n+                             os.path.join(expected_prefix, 'var',\n                                           'myapp-instance'))\n         finally:\n             sys.modules['myapp'] = None\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
