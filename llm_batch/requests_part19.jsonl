{"custom_id": "requests#0cf0bde15853a704ed3fb4fd928187bdc90a3e9a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 50 | Lines Deleted: 9 | Files Changed: 1 | Hunks: 7 | Methods Changed: 6 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 59 | Churn Cumulative: 135 | Contributors (this commit): 2 | Commits (past 90d): 11 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -12,9 +12,30 @@ requests (cookies, auth, proxies).\n import cookielib\n \n from . import api\n+from .config import get_config\n from .utils import add_dict_to_cookiejar\n \n \n+def merge_kwargs(local_kwargs, default_kwargs):\n+    \"\"\"Merges kwarg dictionaries.\n+    \"\"\"\n+\n+    # Bypass if not a dictionary (e.g. timeout)\n+    if not hasattr(local_kwargs, 'items'):\n+        return local_kwargs\n+\n+    kwargs = default_kwargs.copy()\n+    kwargs.update(local_kwargs)\n+\n+    # Remove keys that are set to None.\n+    for (k,v) in local_kwargs.items():\n+        if v is None:\n+            del kwargs[k]\n+\n+    return kwargs\n+\n+\n+\n class Session(object):\n     \"\"\"A Requests session.\"\"\"\n \n@@ -23,19 +44,39 @@ class Session(object):\n         'config'\n     ]\n \n-    def __init__(self, **kwargs):\n+    def __init__(self,\n+        headers=None,\n+        cookies=None,\n+        auth=None,\n+        timeout=None,\n+        proxies=None,\n+        hooks=None,\n+        config=None):\n \n         # Set up a CookieJar to be used by default\n-        self.cookies = cookielib.FileCookieJar()\n-        self.config = kwargs.get('config') or dict()\n+        # self.cookies = cookielib.FileCookieJar()\n+        # self.config = kwargs.get('config')\n+        # self.configs =\n+        self.headers = headers\n+        self.cookies = cookies\n+        self.auth = auth\n+        self.timeout = timeout\n+        self.proxies = proxies\n+        self.hooks = hooks\n+        self.config = get_config(config)\n+        # print self.config\n \n         # Map args from kwargs to instance-local variables\n-        map(lambda k, v: (k in self.__attrs__) and setattr(self, k, v),\n-                kwargs.iterkeys(), kwargs.itervalues())\n+        # map(lambda k, v: (k in self.__attrs__) and setattr(self, k, v),\n+                # kwargs.iterkeys(), kwargs.itervalues())\n \n         # Map and wrap requests.api methods\n         self._map_api_methods()\n \n+\n+    def get(url, **kwargs):\n+\n+\n     def __repr__(self):\n         return '<requests-client at 0x%x>' % (id(self))\n \n@@ -61,10 +102,10 @@ class Session(object):\n \n                 # If a session request has a cookie_dict, inject the\n                 # values into the existing CookieJar instead.\n-                if isinstance(kwargs.get('cookies', None), dict):\n-                    kwargs['cookies'] = add_dict_to_cookiejar(\n-                        inst_attrs['cookies'], kwargs['cookies']\n-                    )\n+                # if isinstance(kwargs.get('cookies', None), dict):\n+                #     kwargs['cookies'] = add_dict_to_cookiejar(\n+                #         inst_attrs['cookies'], kwargs['cookies']\n+                #     )\n \n                 if kwargs.get('headers', None) and inst_attrs.get('headers', None):\n                     kwargs['headers'].update(inst_attrs['headers'])\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#351a711ce9a9771f61555b5057d4f249d9afc423", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 23 | Lines Deleted: 18 | Files Changed: 3 | Hunks: 12 | Methods Changed: 3 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 41 | Churn Cumulative: 5492 | Contributors (this commit): 23 | Commits (past 90d): 118 | Contributors (cumulative): 30 | DMM Complexity: 1.0\n\nDIFF:\n@@ -4,7 +4,7 @@\n requests.config\n ~~~~~~~~~~~~~~~\n \n-This module provides the Requests settings feature set.\n+This module provides the Requests configuration defaults.\n \n settings parameters:\n \n@@ -18,27 +18,34 @@ settings parameters:\n \n \"\"\"\n \n-def merge_configs(config, default_config=None):\n-    \"\"\"Merge two given configurations.\"\"\"\n+def get_config(config=None, default_config=None):\n+    \"\"\"Merges two given configurations.\"\"\"\n+\n+    # Allow raw calls.\n+    if config is None:\n+        config=dict()\n \n     # Use the module-level defaults, if none is given.\n     if default_config is None:\n-        default_config = config.copy()\n+        default_config = defaults.copy()\n+\n \n     d = default_config.copy()\n     d.update(config)\n \n     return d\n \n+\n # Module-level defaults.\n-config = dict()\n+defaults = dict()\n \n-config['base_headers'] = {'User-Agent': 'python-requests.org'}\n-config['accept_gzip'] = True\n-config['proxies'] = {}\n-config['verbose'] = None\n-config['timeout'] = None\n-config['max_redirects'] = 30\n-config['decode_unicode'] = True\n+defaults['base_headers'] = {'User-Agent': 'python-requests.org'}\n+defaults['accept_gzip'] = True\n+defaults['proxies'] = {}\n+defaults['verbose'] = None\n+defaults['timeout'] = None\n+defaults['max_redirects'] = 30\n+defaults['decode_unicode'] = True\n+defaults['keepalive'] = True\n \n \n\n@@ -20,7 +20,6 @@ __copyright__ = 'Copyright 2011 Kenneth Reitz'\n \n \n from api import *\n-from config import settings\n from exceptions import *\n from models import Request, Response\n from sessions import session\n\n@@ -7,18 +7,15 @@ requests.models\n \"\"\"\n \n import urllib\n-import urllib2\n-import socket\n import zlib\n \n from urlparse import urlparse, urlunparse, urljoin\n-from datetime import datetime\n \n \n from .packages import urllib3\n # print dir(urllib3)\n \n-from .config import settings\n+from .config import get_config\n from .structures import CaseInsensitiveDict\n from .utils import *\n from .status_codes import codes\n@@ -36,7 +33,7 @@ class Request(object):\n     def __init__(self,\n         url=None, headers=dict(), files=None, method=None, data=dict(),\n         params=dict(), auth=None, cookies=None, timeout=None, redirect=False,\n-        allow_redirects=False, proxies=None):\n+        allow_redirects=False, proxies=None, config=None):\n \n         #: Float describ the timeout of the request.\n         #  (Use socket.setdefaulttimeout() as fallback)\n@@ -72,6 +69,8 @@ class Request(object):\n         # Dictionary mapping protocol to the URL of the proxy (e.g. {'http': 'foo.bar:3128'})\n         self.proxies = proxies\n \n+        self.config = get_config(config)\n+\n         self.data = data\n         self._enc_data = encode_params(data)\n         self.params = params\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#802bcc9ba3f21f65d5eab48588b930222845ce23", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 36 | Lines Deleted: 16 | Files Changed: 4 | Hunks: 16 | Methods Changed: 6 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 52 | Churn Cumulative: 3386 | Contributors (this commit): 18 | Commits (past 90d): 130 | Contributors (cumulative): 27 | DMM Complexity: 0.9\n\nDIFF:\n\n@@ -11,7 +11,7 @@ This module impliments the Requests API.\n \n \"\"\"\n \n-import config\n+from ._config import get_config\n from .models import Request, Response\n from .status_codes import codes\n from .hooks import dispatch_hook\n@@ -24,7 +24,7 @@ __all__ = ('request', 'get', 'head', 'post', 'patch', 'put', 'delete')\n def request(method, url,\n     params=None, data=None, headers=None, cookies=None, files=None, auth=None,\n     timeout=None, allow_redirects=False, proxies=None, hooks=None,\n-    _connection=None):\n+    config=None, _connection=None):\n \n     \"\"\"Constructs and sends a :class:`Request <Request>`.\n     Returns :class:`Response <Response>` object.\n@@ -44,6 +44,7 @@ def request(method, url,\n     \"\"\"\n \n     method = str(method).upper()\n+    config = get_config(config)\n \n     if cookies is None:\n         cookies = {}\n@@ -64,9 +65,9 @@ def request(method, url,\n         cookies=cookies,\n         files=files,\n         auth=auth,\n-        timeout=timeout or config.settings.timeout,\n+        timeout=timeout or config.get('timeout'),\n         allow_redirects=allow_redirects,\n-        proxies=proxies or config.settings.proxies,\n+        proxies=proxies or config.get('proxies'),\n     )\n \n     # Arguments manipulation hook.\n\n@@ -15,7 +15,7 @@ from urlparse import urlparse, urlunparse, urljoin\n from .packages import urllib3\n # print dir(urllib3)\n \n-from .config import get_config\n+from ._config import get_config\n from .structures import CaseInsensitiveDict\n from .utils import *\n from .status_codes import codes\n@@ -91,15 +91,15 @@ class Request(object):\n \n         # Header manipulation and defaults.\n \n-        if settings.accept_gzip:\n-            settings.base_headers.update({'Accept-Encoding': 'gzip'})\n+        if self.config.get('accept_gzip'):\n+            self.headers.update({'Accept-Encoding': 'gzip'})\n \n         if headers:\n             headers = CaseInsensitiveDict(self.headers)\n         else:\n             headers = CaseInsensitiveDict()\n \n-        for (k, v) in settings.base_headers.items():\n+        for (k, v) in self.config.get('base_headers').items():\n             if k not in headers:\n                 headers[k] = v\n \n\n@@ -12,23 +12,31 @@ requests (cookies, auth, proxies).\n import cookielib\n \n from . import api\n-from .config import get_config\n+from ._config import get_config\n from .utils import add_dict_to_cookiejar\n \n \n-def merge_kwargs(local_kwargs, default_kwargs):\n+def merge_kwargs(local_kwarg, default_kwarg):\n     \"\"\"Merges kwarg dictionaries.\n+\n+    If a key in the dictionary is set to None, i\n     \"\"\"\n \n     # Bypass if not a dictionary (e.g. timeout)\n-    if not hasattr(local_kwargs, 'items'):\n-        return local_kwargs\n+    if not hasattr(local_kwarg, 'items'):\n+        return local_kwarg\n \n-    kwargs = default_kwargs.copy()\n-    kwargs.update(local_kwargs)\n+    kwargs = default_kwarg.copy()\n+    kwargs.update(local_kwarg)\n+\n+    # from clint.textui import colored\n+\n+\n+    # print colored.red(default_kwarg)\n+    # print colored.red(local_kwarg)\n \n     # Remove keys that are set to None.\n-    for (k,v) in local_kwargs.items():\n+    for (k,v) in local_kwarg.items():\n         if v is None:\n             del kwargs[k]\n \n@@ -74,8 +82,19 @@ class Session(object):\n         self._map_api_methods()\n \n \n-    def get(url, **kwargs):\n+    def get(self, url, **kwargs):\n \n+        _kwargs = {}\n+        for attr in self.__attrs__:\n+            default_attr = getattr(self, attr)\n+            local_attr = kwargs.get(attr)\n+\n+            new_attr = merge_kwargs(local_attr, default_attr)\n+\n+            if new_attr is not None:\n+                _kwargs[attr] = new_attr\n+\n+        return api.get(url, **_kwargs)\n \n     def __repr__(self):\n         return '<requests-client at 0x%x>' % (id(self))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#7881aaa759ce05fa944a1530db8ba889ffaf68e4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 8 | Files Changed: 1 | Hunks: 4 | Methods Changed: 4 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 11 | Churn Cumulative: 214 | Contributors (this commit): 2 | Commits (past 90d): 14 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -19,22 +19,17 @@ from .utils import add_dict_to_cookiejar\n def merge_kwargs(local_kwarg, default_kwarg):\n     \"\"\"Merges kwarg dictionaries.\n \n-    If a key in the dictionary is set to None, i\n+    If a local key in the dictionary is set to None, it will be removed.\n     \"\"\"\n \n     # Bypass if not a dictionary (e.g. timeout)\n     if not hasattr(local_kwarg, 'items'):\n         return local_kwarg\n \n+    # Update new values.\n     kwargs = default_kwarg.copy()\n     kwargs.update(local_kwarg)\n \n-    # from clint.textui import colored\n-\n-\n-    # print colored.red(default_kwarg)\n-    # print colored.red(local_kwarg)\n-\n     # Remove keys that are set to None.\n     for (k,v) in local_kwarg.items():\n         if v is None:\n@@ -130,7 +125,7 @@ class Session(object):\n                         _kwargs[attr] = new_attr\n \n                 # Make sure we didn't miss anything.\n-                for (k, v) in kwargs:\n+                for (k, v) in kwargs.items():\n                     if k not in _kwargs:\n                         _kwargs[k] = v\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#1758070cdc0ab3757f67f7eff0efecc0a1e753c9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 10 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 11 | Churn Cumulative: 225 | Contributors (this commit): 2 | Commits (past 90d): 15 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -56,10 +56,6 @@ class Session(object):\n         hooks=None,\n         config=None):\n \n-        # Set up a CookieJar to be used by default\n-        # self.cookies = cookielib.FileCookieJar()\n-        # self.config = kwargs.get('config')\n-        # self.configs =\n         self.headers = headers\n         self.cookies = cookies\n         self.auth = auth\n@@ -67,13 +63,8 @@ class Session(object):\n         self.proxies = proxies\n         self.hooks = hooks\n         self.config = get_config(config)\n-        # print self.config\n \n-        # Map args from kwargs to instance-local variables\n-        # map(lambda k, v: (k in self.__attrs__) and setattr(self, k, v),\n-                # kwargs.iterkeys(), kwargs.itervalues())\n-\n-        # Map and wrap requests.api methods\n+        # Map and wrap requests.api methods.\n         self._map_api_methods()\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e2af50b7c9183b65766c6d84ad760c2a689f00ad", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 15 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): -3/0 | Churn Δ: 15 | Churn Cumulative: 240 | Contributors (this commit): 2 | Commits (past 90d): 16 | Contributors (cumulative): 2 | DMM Complexity: 0.0\n\nDIFF:\n@@ -67,21 +67,6 @@ class Session(object):\n         # Map and wrap requests.api methods.\n         self._map_api_methods()\n \n-\n-    def get(self, url, **kwargs):\n-\n-        _kwargs = {}\n-        for attr in self.__attrs__:\n-            default_attr = getattr(self, attr)\n-            local_attr = kwargs.get(attr)\n-\n-            new_attr = merge_kwargs(local_attr, default_attr)\n-\n-            if new_attr is not None:\n-                _kwargs[attr] = new_attr\n-\n-        return api.get(url, **_kwargs)\n-\n     def __repr__(self):\n         return '<requests-client at 0x%x>' % (id(self))\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#ae4e85f11c39d0b2786a6b9df81c16cbfbe2a6e4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 5 | Files Changed: 4 | Hunks: 10 | Methods Changed: 8 | Complexity Δ (Sum/Max): 4/3 | Churn Δ: 21 | Churn Cumulative: 3477 | Contributors (this commit): 18 | Commits (past 90d): 138 | Contributors (cumulative): 27 | DMM Complexity: 0.0\n\nDIFF:\n@@ -47,5 +47,6 @@ defaults['timeout'] = None\n defaults['max_redirects'] = 30\n defaults['decode_unicode'] = True\n defaults['keepalive'] = True\n+defaults['max_connections'] = 10\n \n \n\n@@ -24,7 +24,7 @@ __all__ = ('request', 'get', 'head', 'post', 'patch', 'put', 'delete')\n def request(method, url,\n     params=None, data=None, headers=None, cookies=None, files=None, auth=None,\n     timeout=None, allow_redirects=False, proxies=None, hooks=None,\n-    config=None, _connection=None):\n+    config=None, _pools=None):\n \n     \"\"\"Constructs and sends a :class:`Request <Request>`.\n     Returns :class:`Response <Response>` object.\n@@ -40,7 +40,7 @@ def request(method, url,\n     :param timeout: (optional) Float describing the timeout of the request.\n     :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n     :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n-    :param _connection: (optional) An HTTP Connection to re-use.\n+    :param _pools: (optional) An HTTP PoolManager to use.\n     \"\"\"\n \n     method = str(method).upper()\n@@ -80,7 +80,7 @@ def request(method, url,\n     r = dispatch_hook('pre_request', hooks, r)\n \n     # Send the HTTP Request.\n-    r.send(connection=_connection)\n+    r.send(pools=_pools)\n \n     # Post-request hook.\n     r = dispatch_hook('post_request', hooks, r)\n\n@@ -227,7 +227,7 @@ class Request(object):\n \n \n \n-    def send(self, connection=None, anyway=False):\n+    def send(self, pools=None, anyway=False):\n         \"\"\"Sends the shit.\"\"\"\n \n         # Safety check.\n@@ -254,12 +254,13 @@ class Request(object):\n \n             try:\n                 # Create a new HTTP connection, since one wasn't passed in.\n-                if not connection:\n+                if not pools:\n                     connection = urllib3.connection_from_url(url, timeout=self.timeout)\n \n                     # One-off request. Delay fetching the content until needed.\n                     do_block = False\n                 else:\n+                    connection = pools.connection_from_url(url, timeout=self.timeout)\n                     # Part of a connection pool, so no fancy stuff. Sorry!\n                     do_block = True\n \n\n@@ -14,6 +14,7 @@ import cookielib\n from . import api\n from ._config import get_config\n from .utils import add_dict_to_cookiejar\n+from .packages.urllib3.poolmanager import PoolManager\n \n \n def merge_kwargs(local_kwarg, default_kwarg):\n@@ -64,6 +65,10 @@ class Session(object):\n         self.hooks = hooks\n         self.config = get_config(config)\n \n+        self.__pool = PoolManager(\n+            num_pools=self.config.get('max_connections')\n+        )\n+\n         # Map and wrap requests.api methods.\n         self._map_api_methods()\n \n@@ -105,6 +110,10 @@ class Session(object):\n                     if k not in _kwargs:\n                         _kwargs[k] = v\n \n+                # Add in PoolManager, if neccesary.\n+                if self.config.get('keepalive'):\n+                    _kwargs['_pool'] = self.__pool\n+\n                 # TODO: Persist cookies.\n \n                 return func(*args, **_kwargs)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#a699ddd14a305d933105de7900a079034bbc545f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 6 | Methods Changed: 8 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 11 | Churn Cumulative: 2819 | Contributors (this commit): 17 | Commits (past 90d): 112 | Contributors (cumulative): 19 | DMM Complexity: 1.0\n\nDIFF:\n@@ -122,6 +122,7 @@ class Request(object):\n         def build(resp):\n \n             response = Response()\n+            response.config = self.config\n             response.status_code = getattr(resp, 'status', None)\n \n             try:\n@@ -236,7 +237,6 @@ class Request(object):\n         # Build the final URL.\n         url = build_url(self.url, self.params)\n \n-        print url\n         # Setup Files.\n         if self.files:\n             pass\n@@ -260,7 +260,7 @@ class Request(object):\n                     # One-off request. Delay fetching the content until needed.\n                     do_block = False\n                 else:\n-                    connection = pools.connection_from_url(url, timeout=self.timeout)\n+                    connection = pools.connection_from_url(url)\n                     # Part of a connection pool, so no fancy stuff. Sorry!\n                     do_block = True\n \n@@ -344,6 +344,9 @@ class Response(object):\n         #: A dictionary of Cookies the server sent back.\n         self.cookies = None\n \n+        #: A dictionary of configuration.\n+        self.config = None\n+\n     def __repr__(self):\n         return '<Response [%s]>' % (self.status_code)\n \n@@ -407,7 +410,7 @@ class Response(object):\n                 pass\n \n         # Decode unicode content.\n-        if settings.decode_unicode:\n+        if self.config.get('decode_unicode'):\n             self._content = get_unicode_from_response(self)\n \n         self._content_consumed = True\n\n@@ -112,7 +112,7 @@ class Session(object):\n \n                 # Add in PoolManager, if neccesary.\n                 if self.config.get('keepalive'):\n-                    _kwargs['_pool'] = self.__pool\n+                    _kwargs['_pools'] = self.__pool\n \n                 # TODO: Persist cookies.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#dfe0e9382d69f0ae995c7499b73efe2426881e10", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 5 | Methods Changed: 2 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 11 | Churn Cumulative: 2579 | Contributors (this commit): 17 | Commits (past 90d): 95 | Contributors (cumulative): 17 | DMM Complexity: 0.0\n\nDIFF:\n@@ -122,15 +122,18 @@ class Request(object):\n         def build(resp):\n \n             response = Response()\n+\n+            # Pass settings over.\n             response.config = self.config\n+\n+            # Fallback to None if there's no staus_code, for whatever reason.\n             response.status_code = getattr(resp, 'status', None)\n \n-            try:\n+            # Make headers case-insensitive.\n             response.headers = CaseInsensitiveDict(getattr(resp, 'headers', None))\n-                response.raw = resp\n \n-            except AttributeError:\n-                pass\n+            # Save original resopnse for later.\n+            response.raw = resp\n \n             if is_error:\n                 response.error = resp\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f52c0032a325b593f6e9fc0485ad6bd0ce871f12", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 31 | Lines Deleted: 12 | Files Changed: 3 | Hunks: 14 | Methods Changed: 8 | Complexity Δ (Sum/Max): 2/1 | Churn Δ: 43 | Churn Cumulative: 1110 | Contributors (this commit): 1 | Commits (past 90d): 10 | Contributors (cumulative): 3 | DMM Complexity: 0.875\n\nDIFF:\n@@ -29,6 +29,8 @@ from .exceptions import (\n \n log = logging.getLogger(__name__)\n \n+_Default = object()\n+\n \n ## Connection objects (extension of httplib)\n \n@@ -178,15 +180,19 @@ class HTTPConnectionPool(ConnectionPool):\n             log.warning(\"HttpConnectionPool is full, discarding connection: %s\"\n                         % self.host)\n \n-    def _make_request(self, conn, method, url, **httplib_request_kw):\n+    def _make_request(self, conn, method, url, timeout=_Default,\n+                      **httplib_request_kw):\n         \"\"\"\n         Perform a request on a given httplib connection object taken from our\n         pool.\n         \"\"\"\n         self.num_requests += 1\n \n+        if timeout is _Default:\n+            timeout = self.timeout\n+\n         conn.request(method, url, **httplib_request_kw)\n-        conn.sock.settimeout(self.timeout)\n+        conn.sock.settimeout(timeout)\n         httplib_response = conn.getresponse()\n \n         log.debug(\"\\\"%s %s %s\\\" %s %s\" %\n@@ -202,8 +208,8 @@ class HTTPConnectionPool(ConnectionPool):\n                 get_host(url) == (self.scheme, self.host, self.port))\n \n     def urlopen(self, method, url, body=None, headers=None, retries=3,\n-                redirect=True, assert_same_host=True, pool_timeout=None,\n-                release_conn=None, **response_kw):\n+                redirect=True, assert_same_host=True, timeout=_Default,\n+                pool_timeout=None, release_conn=None, **response_kw):\n         \"\"\"\n         Get a connection from the pool and perform an HTTP request.\n \n@@ -233,6 +239,9 @@ class HTTPConnectionPool(ConnectionPool):\n             consistent else will raise HostChangedError. When False, you can\n             use the pool on an HTTP proxy and request foreign hosts.\n \n+        timeout\n+            If specified, overrides the default timeout for this one request.\n+\n         pool_timeout\n             If set and the pool is set to block=True, then this method will\n             block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n@@ -273,6 +282,7 @@ class HTTPConnectionPool(ConnectionPool):\n         try:\n             # Make the request on the httplib connection object\n             httplib_response = self._make_request(conn, method, url,\n+                                                  timeout=timeout,\n                                                   body=body, headers=headers)\n             # Import httplib's response into our own wrapper object\n             response = HTTPResponse.from_httplib(httplib_response,\n\n@@ -34,18 +34,14 @@ class PoolManager(object):\n         self.pools = RecentlyUsedContainer(num_pools)\n         self.recently_used_pools = []\n \n-    def connection_from_url(self, url):\n+    def connection_from_host(self, host, port=80, scheme='http'):\n         \"\"\"\n-        Similar to connectionpool.connection_from_url but doesn't pass any\n-        additional keywords to the ConnectionPool constructor. Additional\n-        keywords are taken from the PoolManager constructor.\n+        Get a ConnectionPool based on the host, port, and scheme.\n         \"\"\"\n-        scheme, host, port = get_host(url)\n+        pool_key = (scheme, host, port)\n \n         # If the scheme, host, or port doesn't match existing open connections,\n         # open a new ConnectionPool.\n-        pool_key = (scheme, host, port or port_by_scheme.get(scheme, 80))\n-\n         pool = self.pools.get(pool_key)\n         if pool:\n             return pool\n@@ -58,7 +54,19 @@ class PoolManager(object):\n \n         return pool\n \n+    def connection_from_url(self, url):\n+        \"\"\"\n+        Similar to connectionpool.connection_from_url but doesn't pass any\n+        additional keywords to the ConnectionPool constructor. Additional\n+        keywords are taken from the PoolManager constructor.\n+        \"\"\"\n+        scheme, host, port = get_host(url)\n+\n+        port = port or port_by_scheme.get(scheme, 80)\n+\n+        return  self.connection_from_host(host, port=port, scheme=scheme)\n+\n     def urlopen(self, method, url, **kw):\n-        \"Same as HTTP(S)ConnectionPool.urlopen\"\n+        \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n         conn = self.connection_from_url(url)\n         return conn.urlopen(method, url, **kw)\n\n@@ -83,6 +83,7 @@ class HTTPResponse(object):\n             return\n \n         self._pool._put_conn(self._connection)\n+        self._connection = None\n \n     @property\n     def data(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#cff3b7f9bd96b6837914ebb0fcf79ba874569ca5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 850 | Contributors (this commit): 1 | Commits (past 90d): 6 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -284,6 +284,7 @@ class HTTPConnectionPool(ConnectionPool):\n             httplib_response = self._make_request(conn, method, url,\n                                                   timeout=timeout,\n                                                   body=body, headers=headers)\n+\n             # Import httplib's response into our own wrapper object\n             response = HTTPResponse.from_httplib(httplib_response,\n                                                  pool=self,\n@@ -309,7 +310,8 @@ class HTTPConnectionPool(ConnectionPool):\n         finally:\n             if release_conn:\n                 # Put the connection back to be reused\n-                self._put_conn(conn)\n+                response.release_conn() # Equivalent to self._put_conn(conn) but\n+                                        # tracks release state.\n \n         if not conn:\n             log.warn(\"Retrying (%d attempts remain) after connection \"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#111336459e408778d2915ba61a24c9c961e9aa54", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 37 | Lines Deleted: 18 | Files Changed: 4 | Hunks: 18 | Methods Changed: 9 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 55 | Churn Cumulative: 6218 | Contributors (this commit): 23 | Commits (past 90d): 155 | Contributors (cumulative): 34 | DMM Complexity: 0.0\n\nDIFF:\n@@ -68,6 +68,7 @@ def request(method, url,\n         timeout=timeout or config.get('timeout'),\n         allow_redirects=allow_redirects,\n         proxies=proxies or config.get('proxies'),\n+        _pools=_pools\n     )\n \n     # Arguments manipulation hook.\n@@ -80,7 +81,7 @@ def request(method, url,\n     r = dispatch_hook('pre_request', hooks, r)\n \n     # Send the HTTP Request.\n-    r.send(pools=_pools)\n+    r.send()\n \n     # Post-request hook.\n     r = dispatch_hook('post_request', hooks, r)\n\n@@ -18,6 +18,8 @@ __author__ = 'Kenneth Reitz'\n __license__ = 'ISC'\n __copyright__ = 'Copyright 2011 Kenneth Reitz'\n \n+import logging\n+logging.basicConfig()\n \n from api import *\n from exceptions import *\n\n@@ -20,6 +20,7 @@ from .structures import CaseInsensitiveDict\n from .utils import *\n from .status_codes import codes\n from .exceptions import RequestException, Timeout, URLRequired, TooManyRedirects\n+from .packages.urllib3.poolmanager import PoolManager\n \n \n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n@@ -33,7 +34,7 @@ class Request(object):\n     def __init__(self,\n         url=None, headers=dict(), files=None, method=None, data=dict(),\n         params=dict(), auth=None, cookies=None, timeout=None, redirect=False,\n-        allow_redirects=False, proxies=None, config=None):\n+        allow_redirects=False, proxies=None, config=None, _pools=None):\n \n         #: Float describ the timeout of the request.\n         #  (Use socket.setdefaulttimeout() as fallback)\n@@ -43,10 +44,10 @@ class Request(object):\n         self.url = url\n \n         #: Dictonary of HTTP Headers to attach to the :class:`Request <Request>`.\n-        self.headers = headers\n+        self.headers = headers or {}\n \n         #: Dictionary of files to multipart upload (``{filename: content}``).\n-        self.files = files\n+        self.files = files or {}\n \n         #: HTTP Method to use.\n         self.method = method\n@@ -105,6 +106,8 @@ class Request(object):\n \n         self.headers = headers\n \n+        self._pools = _pools\n+\n     def __repr__(self):\n         return '<Request [%s]>' % (self.method)\n \n@@ -164,15 +167,11 @@ class Request(object):\n                 (self.allow_redirects))\n             ):\n \n-                # print r.headers['location']\n-                # print dir(r.raw._original_response.fp)\n-                # print '--'\n-\n                 # We already redirected. Don't keep it alive.\n                 # r.raw.close()\n \n                 # Woah, this is getting crazy.\n-                if len(history) >= settings.max_redirects:\n+                if len(history) >= self.config.get('max_redirects'):\n                     raise TooManyRedirects()\n \n                 # Add the old request to the history collector.\n@@ -212,6 +211,8 @@ class Request(object):\n                     params=None,\n                     auth=self.auth,\n                     cookies=self.cookies,\n+                    _pools=self._pools,\n+                    config=self.config,\n \n                     # Flag as part of a redirect loop.\n                     redirect=True\n@@ -232,7 +233,7 @@ class Request(object):\n \n \n \n-    def send(self, pools=None, anyway=False):\n+    def send(self, anyway=False):\n         \"\"\"Sends the shit.\"\"\"\n \n         # Safety check.\n@@ -258,13 +259,25 @@ class Request(object):\n \n             try:\n                 # Create a new HTTP connection, since one wasn't passed in.\n-                if not pools:\n-                    connection = urllib3.connection_from_url(url, timeout=self.timeout)\n+                if not self._pools:\n+                    # Create a pool manager for this one connection.\n+                    pools = PoolManager(\n+                        num_pools=self.config.get('max_connections'),\n+                        maxsize=1\n+                    )\n+\n+                    # Create a connection.\n+                    connection = pools.connection_from_url(url, timeout=self.timeout)\n \n                     # One-off request. Delay fetching the content until needed.\n                     do_block = False\n                 else:\n-                    connection = pools.connection_from_url(url)\n+                    # Create a connection.\n+                    connection = self._pools.connection_from_url(url)\n+\n+                    # Syntax sugar.\n+                    pools = self._pools\n+\n                     # Part of a connection pool, so no fancy stuff. Sorry!\n                     do_block = True\n \n@@ -276,12 +289,14 @@ class Request(object):\n                     headers=self.headers,\n                     redirect=False,\n                     assert_same_host=False,\n-                    # preload_content=True\n-                    # preload_content=False\n                     preload_content=do_block,\n                     decode_content=False\n                 )\n \n+                # Set the pools manager for redirections, if allowed.\n+                if self.config.get('keepalive') and pools:\n+                    self._pools = pools\n+\n                 # Extract cookies.\n                 # if self.cookiejar is not None:\n                     # self.cookiejar.extract_cookies(resp, req)\n\n@@ -65,8 +65,9 @@ class Session(object):\n         self.hooks = hooks\n         self.config = get_config(config)\n \n-        self.__pool = PoolManager(\n-            num_pools=self.config.get('max_connections')\n+        self.__pools = PoolManager(\n+            num_pools=10,\n+            maxsize=1\n         )\n \n         # Map and wrap requests.api methods.\n@@ -112,7 +113,7 @@ class Session(object):\n \n                 # Add in PoolManager, if neccesary.\n                 if self.config.get('keepalive'):\n-                    _kwargs['_pools'] = self.__pool\n+                    _kwargs['_pools'] = self.__pools\n \n                 # TODO: Persist cookies.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#a7d280cb3d9e24ceb9330b7157cf4e4d985c7a60", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 2631 | Contributors (this commit): 17 | Commits (past 90d): 98 | Contributors (cumulative): 17 | DMM Complexity: 1.0\n\nDIFF:\n@@ -260,11 +260,11 @@ class Request(object):\n             try:\n                 # Create a new HTTP connection, since one wasn't passed in.\n                 if not self._pools:\n+\n                     # Create a pool manager for this one connection.\n                     pools = PoolManager(\n                         num_pools=self.config.get('max_connections'),\n-                        maxsize=1\n-                    )\n+                        maxsize=1)\n \n                     # Create a connection.\n                     connection = pools.connection_from_url(url, timeout=self.timeout)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#1c5ce723d8ac41a97209c8c936d218c28f682157", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 20 | Lines Deleted: 9 | Files Changed: 1 | Hunks: 8 | Methods Changed: 1 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 29 | Churn Cumulative: 2660 | Contributors (this commit): 17 | Commits (past 90d): 99 | Contributors (cumulative): 17 | DMM Complexity: 0.0\n\nDIFF:\n@@ -8,12 +8,10 @@ requests.models\n \n import urllib\n import zlib\n-\n from urlparse import urlparse, urlunparse, urljoin\n \n-\n from .packages import urllib3\n-# print dir(urllib3)\n+from .packages.urllib3.filepost import encode_multipart_formdata\n \n from ._config import get_config\n from .structures import CaseInsensitiveDict\n@@ -242,13 +240,24 @@ class Request(object):\n         # Build the final URL.\n         url = build_url(self.url, self.params)\n \n-        # Setup Files.\n+        body = None\n+        content_type = None\n+\n+        # Multi-part file uploads.\n         if self.files:\n-            pass\n+            if not isinstance(self.data, basestring):\n+                fields = self.data.copy()\n+                for (k, v) in self.files.items():\n+                    fields.update({k: (None, v.read()))\n+                (body, content_type) = encode_multipart_formdata(fields)\n \n         # Setup form data.\n-        elif self.data:\n-            pass\n+        if self.data and (not body):\n+            if isinstance(self.data, basestring):\n+                body = self.data\n+            else:\n+                body = urlencode(self.data)\n+                content_type = 'application/x-www-form-urlencoded'\n \n         # Setup cookies.\n         elif self.cookies:\n@@ -264,10 +273,12 @@ class Request(object):\n                     # Create a pool manager for this one connection.\n                     pools = PoolManager(\n                         num_pools=self.config.get('max_connections'),\n-                        maxsize=1)\n+                        maxsize=1,\n+                        timeout=self.timeout\n+                    )\n \n                     # Create a connection.\n-                    connection = pools.connection_from_url(url, timeout=self.timeout)\n+                    connection = pools.connection_from_url(url)\n \n                     # One-off request. Delay fetching the content until needed.\n                     do_block = False\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#8ac2fe6eb170633b8b42e1af9b86e94729b339c2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 4 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 9 | Churn Cumulative: 2669 | Contributors (this commit): 17 | Commits (past 90d): 100 | Contributors (cumulative): 17 | DMM Complexity: 0.0\n\nDIFF:\n@@ -248,7 +248,7 @@ class Request(object):\n             if not isinstance(self.data, basestring):\n                 fields = self.data.copy()\n                 for (k, v) in self.files.items():\n-                    fields.update({k: (None, v.read()))\n+                    fields.update({k: (k, v.read())})\n                 (body, content_type) = encode_multipart_formdata(fields)\n \n         # Setup form data.\n@@ -256,13 +256,16 @@ class Request(object):\n             if isinstance(self.data, basestring):\n                 body = self.data\n             else:\n-                body = urlencode(self.data)\n+                body = encode_params(self.data)\n                 content_type = 'application/x-www-form-urlencoded'\n \n         # Setup cookies.\n         elif self.cookies:\n             pass\n \n+        if (content_type) and (not 'content-type' in self.headers):\n+            self.headers['Content-Type'] = content_type\n+\n         # Only send the Request if new or forced.\n         if (anyway) or (not self.sent):\n \n@@ -296,7 +299,7 @@ class Request(object):\n                 r = connection.urlopen(\n                     method=self.method,\n                     url=url,\n-                    body=self.data,\n+                    body=body,\n                     headers=self.headers,\n                     redirect=False,\n                     assert_same_host=False,\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#2f9e287f7d1b9dfe5322c7c17a5a32a21a502aa0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 2670 | Contributors (this commit): 17 | Commits (past 90d): 101 | Contributors (cumulative): 17 | DMM Complexity: None\n\nDIFF:\n@@ -263,6 +263,7 @@ class Request(object):\n         elif self.cookies:\n             pass\n \n+        # Add content-type if it wasn't explicitly provided.\n         if (content_type) and (not 'content-type' in self.headers):\n             self.headers['Content-Type'] = content_type\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#14bd9ebb455ab1fd8a08868b37d4b271658b0dee", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 43 | Lines Deleted: 5 | Files Changed: 3 | Hunks: 9 | Methods Changed: 6 | Complexity Δ (Sum/Max): 6/6 | Churn Δ: 48 | Churn Cumulative: 4037 | Contributors (this commit): 19 | Commits (past 90d): 167 | Contributors (cumulative): 30 | DMM Complexity: 0.5333333333333333\n\nDIFF:\n@@ -49,7 +49,7 @@ def request(method, url,\n     if cookies is None:\n         cookies = {}\n \n-    cookies = cookiejar_from_dict(cookies)\n+    # cookies = cookiejar_from_dict(cookies)\n \n     # Expand header values\n     if headers:\n\n@@ -8,6 +8,7 @@ requests.models\n \n import urllib\n import zlib\n+from Cookie import SimpleCookie\n from urlparse import urlparse, urlunparse, urljoin\n \n from .packages import urllib3\n@@ -133,6 +134,22 @@ class Request(object):\n             # Make headers case-insensitive.\n             response.headers = CaseInsensitiveDict(getattr(resp, 'headers', None))\n \n+            # Start off with our local cookies.\n+            cookies = self.cookies or dict()\n+\n+            # Add new cookies from the server.\n+            if 'set-cookie' in response.headers:\n+                cookie_header = response.headers['set-cookie']\n+\n+                c = SimpleCookie()\n+                c.load(cookie_header)\n+\n+                for k,v in c.items():\n+                    cookies.update({k: v.value})\n+\n+            # Save cookies in Response.\n+            response.cookies = cookies\n+\n             # Save original resopnse for later.\n             response.raw = resp\n \n@@ -240,6 +257,7 @@ class Request(object):\n         # Build the final URL.\n         url = build_url(self.url, self.params)\n \n+        # Nottin' on you.\n         body = None\n         content_type = None\n \n@@ -296,6 +314,20 @@ class Request(object):\n                     # Part of a connection pool, so no fancy stuff. Sorry!\n                     do_block = True\n \n+                if self.cookies:\n+                    # Skip if 'cookie' header is explicitly set.\n+                    if 'cookie' not in self.headers:\n+\n+                        # Simple cookie with our dict.\n+                        c = SimpleCookie()\n+                        c.load(self.cookies)\n+\n+                        # Turn it into a header.\n+                        cookie_header = c.output(header='').strip()\n+\n+                        # Attach Cookie header to request.\n+                        self.headers['Cookie'] = cookie_header\n+\n                 # Create the connection.\n                 r = connection.urlopen(\n                     method=self.method,\n@@ -313,7 +345,14 @@ class Request(object):\n                     self._pools = pools\n \n                 # Extract cookies.\n-                # if self.cookiejar is not None:\n+                if self.cookies is not None:\n+                    pass\n+                    # cookies = cookiejar_from_dict(self.cookies)\n+#                     >>> C = Cookie.SimpleCookie()\n+# >>> C[\"rocky\"] = \"road\"\n+# >>> C[\"rocky\"][\"path\"] = \"/cookie\"\n+# >>> print C.output(header=\"Cookie:\")\n+# Cookie: rocky=road; Path=/cookie\n                     # self.cookiejar.extract_cookies(resp, req)\n \n             # except (urllib2.HTTPError, urllib2.URLError), why:\n@@ -332,7 +371,6 @@ class Request(object):\n                 self._build_response(r)\n                 self.response.ok = True\n \n-\n         self.sent = self.response.ok\n \n         return self.sent\n\n@@ -117,7 +117,7 @@ def header_expand(headers):\n     return ''.join(collector)\n \n \n-def dict_from_cookiejar(cj):\n+def dict_from_cookiejar(cookies):\n     \"\"\"Returns a key/value dictionary from a CookieJar.\n \n     :param cj: CookieJar object to extract cookies from.\n@@ -125,7 +125,7 @@ def dict_from_cookiejar(cj):\n \n     cookie_dict = {}\n \n-    for _, cookies in cj._cookies.items():\n+    for _, cookies in cookies.items():\n         for _, cookies in cookies.items():\n             for cookie in cookies.values():\n                 cookie_dict[cookie.name] = cookie.value\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#5c132c98ca605ca390e2a2ddbb42f01f749fa484", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 20 | Lines Deleted: 13 | Files Changed: 2 | Hunks: 8 | Methods Changed: 6 | Complexity Δ (Sum/Max): 2/3 | Churn Δ: 33 | Churn Cumulative: 3003 | Contributors (this commit): 17 | Commits (past 90d): 123 | Contributors (cumulative): 19 | DMM Complexity: 0.0\n\nDIFF:\n@@ -164,6 +164,7 @@ class Request(object):\n \n         # Create the lone response object.\n         r = build(resp)\n+        self.cookies.update(r.cookies)\n \n         # Store the HTTP response, just in case.\n         r._response = resp\n@@ -236,6 +237,7 @@ class Request(object):\n                 # Send her away!\n                 request.send()\n                 r = request.response\n+                self.cookies.update(r.cookies)\n \n             # Insert collected history.\n             r.history = history\n@@ -344,16 +346,6 @@ class Request(object):\n                 if self.config.get('keepalive') and pools:\n                     self._pools = pools\n \n-                # Extract cookies.\n-                if self.cookies is not None:\n-                    pass\n-                    # cookies = cookiejar_from_dict(self.cookies)\n-#                     >>> C = Cookie.SimpleCookie()\n-# >>> C[\"rocky\"] = \"road\"\n-# >>> C[\"rocky\"][\"path\"] = \"/cookie\"\n-# >>> print C.output(header=\"Cookie:\")\n-# Cookie: rocky=road; Path=/cookie\n-                    # self.cookiejar.extract_cookies(resp, req)\n \n             # except (urllib2.HTTPError, urllib2.URLError), why:\n             except Exception, why:\n\n@@ -58,7 +58,7 @@ class Session(object):\n         config=None):\n \n         self.headers = headers\n-        self.cookies = cookies\n+        self.cookies = cookies or {}\n         self.auth = auth\n         self.timeout = timeout\n         self.proxies = proxies\n@@ -96,10 +96,18 @@ class Session(object):\n \n                 # Merge local and session arguments.\n                 for attr in self.__attrs__:\n+                    # if attr == 'cookies':\n+                        # print getattr(self, attr)\n+                        # print kwargs.get(attr)\n+\n+                    # Merge local and session dictionaries.\n                     default_attr = getattr(self, attr)\n                     local_attr = kwargs.get(attr)\n \n-                    # Merge local and session dictionaries.\n+                    # Cookies persist.\n+                    if attr == 'cookies':\n+                        local_attr = local_attr or {}\n+\n                     new_attr = merge_kwargs(local_attr, default_attr)\n \n                     # Skip attributes that were set to None.\n@@ -116,8 +124,15 @@ class Session(object):\n                     _kwargs['_pools'] = self.__pools\n \n                 # TODO: Persist cookies.\n+                # print self.cookies\n \n-                return func(*args, **_kwargs)\n+                # print _kwargs.get('cookies')\n+                # print '%%%'\n+\n+                r = func(*args, **_kwargs)\n+                # print r.cookies\n+                self.cookies.update(r.cookies)\n+                return r\n             return wrapper_func\n \n         # Map and decorate each function available in requests.api\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
