{"custom_id": "flask#33850c0ebd23ae615e6823993d441f46d80b1ff0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 614 | Lines Deleted: 0 | Files Changed: 3 | Hunks: 3 | Methods Changed: 48 | Complexity Δ (Sum/Max): 97/49 | Churn Δ: 614 | Churn Cumulative: 614 | Contributors (this commit): 1 | Commits (past 90d): 3 | Contributors (cumulative): 3 | DMM Complexity: 0.8677966101694915\n\nDIFF:\n@@ -0,0 +1,30 @@\n+from flask import Flask, abort, redirect, request, session, \\\n+     render_template, url_for\n+\n+#: create a new flask applications.  We pass it the name of our module\n+#: so that flask knows where to look for templates and static files.\n+app = Flask(__name__)\n+\n+\n+@app.route('/', methods=['GET'])\n+def index():\n+    \"\"\"Show an overview page\"\"\"\n+    return render_template('index.html')\n+\n+\n+@app.route('/hello/', methods=['GET', 'POST'])\n+def hello_user():\n+    \"\"\"Ask the user for a name and redirect to :func:`hello`\"\"\"\n+    if request.method == 'POST':\n+        return redirect(url_for('hello', name=request.form['name']))\n+    return render_template('hello.html', name=None)\n+\n+\n+@app.route('/hello/<name>', methods=['GET'])\n+def hello(name):\n+    \"\"\"Greet name friendly\"\"\"\n+    return render_template('hello.html', name=name)\n+\n+\n+if __name__ == '__main__':\n+    app.run(debug=True)\n\n@@ -0,0 +1,228 @@\n+# -*- coding: utf-8 -*-\n+from __future__ import with_statement\n+import re\n+import time\n+import sqlite3\n+from hashlib import md5\n+from datetime import datetime\n+from contextlib import closing\n+from flask import Flask, request, session, url_for, redirect, \\\n+     render_template, abort, g, flash, generate_password_hash, \\\n+     check_password_hash\n+\n+\n+# configuration\n+DATABASE = '/tmp/minitwit.db'\n+PER_PAGE = 30\n+DEBUG = True\n+SECRET_KEY = 'development key'\n+\n+# create our little application :)\n+app = Flask(__name__)\n+\n+\n+def connect_db():\n+    \"\"\"Returns a new database connection to the database.\"\"\"\n+    return sqlite3.connect(DATABASE)\n+\n+\n+def init_db():\n+    \"\"\"Creates the database tables.\"\"\"\n+    with closing(connect_db()) as db:\n+        with app.open_resource('schema.sql') as f:\n+            db.cursor().executescript(f.read())\n+        db.commit()\n+\n+\n+def query_db(query, args=(), one=False):\n+    \"\"\"Queries the database and returns a list of dictionaries.\"\"\"\n+    cur = g.db.execute(query, args)\n+    rv = [dict((cur.description[idx][0], value)\n+               for idx, value in enumerate(row)) for row in cur.fetchall()]\n+    return (rv[0] if rv else None) if one else rv\n+\n+\n+def get_user_id(username):\n+    \"\"\"Convenience method to look up the id for a username\"\"\"\n+    rv = g.db.execute('select user_id from user where username = ?',\n+                       [username]).fetchone()\n+    return rv[0] if rv else None\n+\n+\n+def format_datetime(timestamp):\n+    \"\"\"Format a timestamp for display\"\"\"\n+    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')\n+\n+\n+def gravatar_url(email, size=80):\n+    \"\"\"Return the gravatar image for the given email address\"\"\"\n+    return 'http://www.gravatar.com/avatar/%s?d=identicon&s=%d' % \\\n+        (md5(email.lower().encode('utf-8')).hexdigest(), size)\n+\n+\n+@app.request_init\n+def before_request():\n+    \"\"\"Make sure we are connected to the database each request and look\n+    up the current user so that we know he's there.\n+    \"\"\"\n+    g.db = sqlite3.connect(DATABASE)\n+    if 'user_id' in session:\n+        g.user = query_db('select * from user where user_id = ?',\n+                          [session['user_id']], one=True)\n+\n+\n+@app.request_shutdown\n+def after_request(request):\n+    \"\"\"Closes the database again at the end of the request.\"\"\"\n+    g.db.close()\n+    return request\n+\n+\n+@app.route('/')\n+def timeline():\n+    if not 'user_id' in session:\n+        return redirect(url_for('public_timeline'))\n+    offset = request.args.get('offset', type=int)\n+    return render_template('timeline.html', messages=query_db('''\n+        select message.*, user.* from message, user\n+        where message.author_id = user.user_id and (\n+            user.user_id = ? or\n+            user.user_id in (select whom_id from follower\n+                                    where who_id = ?))\n+        order by message.pub_date desc limit ?''',\n+        [session['user_id'], session['user_id'], PER_PAGE]))\n+\n+\n+@app.route('/public')\n+def public_timeline():\n+    return render_template('timeline.html', messages=query_db('''\n+        select message.*, user.* from message, user\n+        where message.author_id = user.user_id\n+        order by message.pub_date desc limit ?''', [PER_PAGE]))\n+\n+\n+@app.route('/<username>')\n+def user_timeline(username):\n+    profile_user = query_db('select * from user where username = ?',\n+                            [username], one=True)\n+    if profile_user is None:\n+        abort(404)\n+    followd = False\n+    if 'user_id' in session:\n+        followed = query_db('''select 1 from follower where\n+            follower.who_id = ? and follower.whom_id = ?''',\n+            [session['user_id'], profile_user['user_id']], one=True) is not None\n+    return render_template('timeline.html', messages=query_db('''\n+            select message.*, user.* from message, user where\n+            user.user_id = message.author_id and user.user_id = ?\n+            order by message.pub_date desc limit ?''',\n+            [profile_user['user_id'], PER_PAGE]), followed=followed,\n+            profile_user=profile_user)\n+\n+\n+@app.route('/<username>/follow')\n+def follow_user(username):\n+    if not 'user_id' in session:\n+        abort(401)\n+    whom_id = get_user_id(username)\n+    if whom_id is None:\n+        abort(404)\n+    g.db.execute('insert into follower (who_id, whom_id) values (?, ?)',\n+                [session['user_id'], whom_id])\n+    g.db.commit()\n+    flash('You are now following \"%s\"' % username)\n+    return redirect(url_for('user_timeline', username=username))\n+\n+\n+@app.route('/<username>/unfollow')\n+def unfollow_user(username):\n+    if not 'user_id' in session:\n+        abort(401)\n+    whom_id = get_user_id(username)\n+    if whom_id is None:\n+        abort(404)\n+    g.db.execute('delete from follower where who_id=? and whom_id=?',\n+                [session['user_id'], whom_id])\n+    g.db.commit()\n+    flash('You are no longer following \"%s\"' % username)\n+    return redirect(url_for('user_timeline', username=username))\n+\n+\n+@app.route('/add_message')\n+def add_message():\n+    if 'user_id' not in session:\n+        abort(401)\n+    if request.form['text']:\n+        g.db.execute('''insert into message (author_id, text, pub_date)\n+            values (?, ?, ?)''', (session['user_id'], request.form['text'],\n+                                  int(time.time())))\n+        g.db.commit()\n+        flash('Your message was recorded')\n+    return redirect(url_for('timeline'))\n+\n+\n+@app.route('/login')\n+def login():\n+    if 'user_id' in session:\n+        return redirect(url_for('timeline'))\n+    error = None\n+    if request.method == 'POST':\n+        user = query_db('''select * from user where\n+            username = ?''', [request.form['username']], one=True)\n+        if user is None:\n+            error = 'Invalid username'\n+        elif not check_password_hash(user['pw_hash'],\n+                                     request.form['password']):\n+            error = 'Invalid password'\n+        else:\n+            flash('You were logged in')\n+            session['user_id'] = user['user_id']\n+            return redirect(url_for('timeline'))\n+    return render_template('login.html', error=error)\n+\n+\n+@app.route('/register')\n+def register():\n+    if 'user_id' in session:\n+        return redirect(url_for('timeline'))\n+    error = None\n+    if request.method == 'POST':\n+        if not request.form['username']:\n+            error = 'You have to enter a username'\n+        elif not request.form['email'] or \\\n+                 '@' not in request.form['email']:\n+            error = 'You have to enter a valid email address'\n+        elif not request.form['password']:\n+            error = 'You have to enter a password'\n+        elif request.form['password'] != request.form['password2']:\n+            error = 'The two passwords to not match'\n+        elif get_user_id(request.form['username']) is not None:\n+            error = 'The username is already taken'\n+        else:\n+            g.db.execute('''insert into user (\n+                username, email, pw_hash) values (?, ?, ?)''',\n+                [request.form['username'], request.form['email'],\n+                 generate_password_hash(request.form['password'])])\n+            g.db.commit()\n+            flash('You were successfully registered and can login now')\n+            return redirect(url_for('login'))\n+    return render_template('register.html', error=error)\n+\n+\n+@app.route('/logout')\n+def logout():\n+    flash('You were logged out')\n+    session.pop('user_id', None)\n+    return redirect(url_for('public_timeline'))\n+\n+\n+# add some filters to jinja and set the secret key and debug mode\n+# from the configuration.\n+app.jinja_env.filters['datetimeformat'] = format_datetime\n+app.jinja_env.filters['gravatar'] = gravatar_url\n+app.secret_key = SECRET_KEY\n+app.debug = DEBUG\n+\n+\n+if __name__ == '__main__':\n+    app.run()\n\n@@ -0,0 +1,356 @@\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+    flask\n+    ~~~~~\n+\n+    A microframework based on Werkzeug.  It's extensively documented\n+    and follows best practice patterns.\n+\n+    :copyright: (c) 2010 by Armin Ronacher.\n+    :license: BSD, see LICENSE for more details.\n+\"\"\"\n+import os\n+import sys\n+import pkg_resources\n+from threading import local\n+from jinja2 import Environment, PackageLoader\n+from werkzeug import Request, Response, LocalStack, LocalProxy\n+from werkzeug.routing import Map, Rule\n+from werkzeug.exceptions import HTTPException, InternalServerError\n+from werkzeug.contrib.securecookie import SecureCookie\n+\n+# try to import the json helpers\n+try:\n+    from simplejson import loads as load_json, dumps as dump_json\n+except ImportError:\n+    try:\n+        from json import loads as load_json, dumps as dump_json\n+    except ImportError:\n+        pass\n+\n+# utilities we import from Werkzeug and Jinja2 that are unused\n+# in the module but are exported as public interface.\n+from werkzeug import abort, redirect, secure_filename, cached_property, \\\n+     html, import_string, generate_password_hash, check_password_hash\n+from jinja2 import Markup, escape\n+\n+\n+class FlaskRequest(Request):\n+    \"\"\"The request object used by default in flask.  Remembers the\n+    matched endpoint and view arguments.\n+    \"\"\"\n+\n+    def __init__(self, environ):\n+        Request.__init__(self, environ)\n+        self.endpoint = None\n+        self.view_args = None\n+\n+\n+class FlaskResponse(Response):\n+    \"\"\"The response object that is used by default in flask.  Works like the\n+    response object from Werkzeug but is set to have a HTML mimetype by\n+    default.\n+    \"\"\"\n+    default_mimetype = 'text/html'\n+\n+\n+class _RequestGlobals(object):\n+    pass\n+\n+\n+class _RequestContext(object):\n+    \"\"\"The request context contains all request relevant information.  It is\n+    created at the beginning of the request and pushed to the\n+    `_request_ctx_stack` and removed at the end of it.  It will create the\n+    URL adapter and request object for the WSGI environment provided.\n+    \"\"\"\n+\n+    def __init__(self, app, environ):\n+        self.app = app\n+        self.url_adapter = app.url_map.bind_to_environ(environ)\n+        self.request = app.request_class(environ)\n+        self.session = app.open_session(self.request)\n+        self.g = _RequestGlobals()\n+        self.flashes = None\n+\n+\n+def url_for(endpoint, **values):\n+    \"\"\"Generates a URL to the given endpoint with the method provided.\n+\n+    :param endpoint: the endpoint of the URL (name of the function)\n+    :param values: the variable arguments of the URL rule\n+    \"\"\"\n+    return _request_ctx_stack.top.url_adapter.build(endpoint, values)\n+\n+\n+def jsonified(**values):\n+    \"\"\"Returns a json response\"\"\"\n+    return current_app.response_class(dump_json(values),\n+                                      mimetype='application/json')\n+\n+\n+def flash(message):\n+    \"\"\"Flashes a message to the next request.  In order to remove the\n+    flashed message from the session and to display it to the user,\n+    the template has to call :func:`get_flashed_messages`.\n+    \"\"\"\n+    session['_flashes'] = (session.get('_flashes', [])) + [message]\n+\n+\n+def get_flashed_messages():\n+    \"\"\"Pulls all flashed messages from the session and returns them.\n+    Further calls in the same request to the function will return\n+    the same messages.\n+    \"\"\"\n+    flashes = _request_ctx_stack.top.flashes\n+    if flashes is None:\n+        _request_ctx_stack.top.flashes = flashes = \\\n+            session.pop('_flashes', [])\n+    return flashes\n+\n+\n+def render_template(template_name, **context):\n+    \"\"\"Renders a template from the template folder with the given\n+    context.\n+    \"\"\"\n+    return current_app.jinja_env.get_template(template_name).render(context)\n+\n+\n+def render_template_string(source, **context):\n+    \"\"\"Renders a template from the given template source string\n+    with the given context.\n+    \"\"\"\n+    return current_app.jinja_env.from_string(source).render(context)\n+\n+\n+class Flask(object):\n+    \"\"\"The flask object implements a WSGI application and acts as the central\n+    object.  It is passed the name of the module or package of the application\n+    and optionally a configuration.  When it's created it sets up the\n+    template engine and provides ways to register view functions.\n+    \"\"\"\n+\n+    #: the class that is used for request objects\n+    request_class = FlaskRequest\n+\n+    #: the class that is used for response objects\n+    response_class = FlaskResponse\n+\n+    #: path for the static files.  If you don't want to use static files\n+    #: you can set this value to `None` in which case no URL rule is added\n+    #: and the development server will no longer serve any static files.\n+    static_path = '/static'\n+\n+    #: if a secret key is set, cryptographic components can use this to\n+    #: sign cookies and other things.  Set this to a complex random value\n+    #: when you want to use the secure cookie for instance.\n+    secret_key = None\n+\n+    #: The secure cookie uses this for the name of the session cookie\n+    session_cookie_name = 'session'\n+\n+    #: options that are passed directly to the Jinja2 environment\n+    jinja_options = dict(\n+        autoescape=True,\n+        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']\n+    )\n+\n+    def __init__(self, package_name):\n+        self.debug = False\n+        self.package_name = package_name\n+        self.view_functions = {}\n+        self.error_handlers = {}\n+        self.request_init_funcs = []\n+        self.request_shutdown_funcs = []\n+        self.url_map = Map()\n+\n+        if self.static_path is not None:\n+            self.url_map.add(Rule(self.static_path + '/<filename>',\n+                                  build_only=True, endpoint='static'))\n+\n+        self.jinja_env = Environment(loader=self.create_jinja_loader(),\n+                                     **self.jinja_options)\n+        self.jinja_env.globals.update(\n+            url_for=url_for,\n+            request=request,\n+            session=session,\n+            g=g,\n+            get_flashed_messages=get_flashed_messages\n+        )\n+\n+    def create_jinja_loader(self):\n+        \"\"\"Creates the Jinja loader.  By default just a package loader for\n+        the configured package is returned that looks up templates in the\n+        `templates` folder.  To add other loaders it's possible to\n+        override this method.\n+        \"\"\"\n+        return PackageLoader(self.package_name)\n+\n+    def run(self, host='localhost', port=5000, **options):\n+        \"\"\"Runs the application on a local development server\"\"\"\n+        from werkzeug import run_simple\n+        if 'debug' in options:\n+            self.debug = options.pop('debug')\n+        if self.static_path is not None:\n+            options['static_files'] = {\n+                self.static_path:   (self.package_name, 'static')\n+            }\n+        options.setdefault('use_reloader', self.debug)\n+        options.setdefault('use_debugger', self.debug)\n+        return run_simple(host, port, self, **options)\n+\n+    @cached_property\n+    def test(self):\n+        \"\"\"A test client for this application\"\"\"\n+        from werkzeug import Client\n+        return Client(self, self.response_class, use_cookies=True)\n+\n+    def open_resource(self, resource):\n+        \"\"\"Opens a resource from the application's resource folder\"\"\"\n+        return pkg_resources.resource_stream(self.package_name, resource)\n+\n+    def open_session(self, request):\n+        \"\"\"Creates or opens a new session.  Default implementation requires\n+        that `securecookie.secret_key` is set.\n+        \"\"\"\n+        key = self.secret_key\n+        if key is not None:\n+            return SecureCookie.load_cookie(request, self.session_cookie_name,\n+                                            secret_key=key)\n+\n+    def save_session(self, session, response):\n+        \"\"\"Saves the session if it needs updates.\"\"\"\n+        if session is not None:\n+            session.save_cookie(response, self.session_cookie_name)\n+\n+    def route(self, rule, **options):\n+        \"\"\"A decorator that is used to register a view function for a\n+        given URL rule.  Example::\n+\n+            @app.route('/')\n+            def index():\n+                return 'Hello World'\n+        \"\"\"\n+        def decorator(f):\n+            if 'endpoint' not in options:\n+                options['endpoint'] = f.__name__\n+            self.url_map.add(Rule(rule, **options))\n+            self.view_functions[options['endpoint']] = f\n+            return f\n+        return decorator\n+\n+    def errorhandler(self, code):\n+        \"\"\"A decorator that is used to register a function give a given\n+        error code.  Example::\n+\n+            @app.errorhandler(404)\n+            def page_not_found():\n+                return 'This page does not exist', 404\n+        \"\"\"\n+        def decorator(f):\n+            self.error_handlers[code] = f\n+            return f\n+        return decorator\n+\n+    def request_init(self, f):\n+        \"\"\"Registers a function to run before each request.\"\"\"\n+        self.request_init_funcs.append(f)\n+        return f\n+\n+    def request_shutdown(self, f):\n+        \"\"\"Register a function to be run after each request.\"\"\"\n+        self.request_shutdown_funcs.append(f)\n+        return f\n+\n+    def match_request(self):\n+        \"\"\"Matches the current request against the URL map and also\n+        stores the endpoint and view arguments on the request object\n+        is successful, otherwise the exception is stored.\n+        \"\"\"\n+        rv = _request_ctx_stack.top.url_adapter.match()\n+        request.endpoint, request.view_args = rv\n+        return rv\n+\n+    def dispatch_request(self):\n+        \"\"\"Does the request dispatching.  Matches the URL and returns the\n+        return value of the view or error handler.  This does not have to\n+        be a response object.  In order to convert the return value to a\n+        proper response object, call :func:`make_response`.\n+        \"\"\"\n+        try:\n+            endpoint, values = self.match_request()\n+            return self.view_functions[endpoint](**values)\n+        except HTTPException, e:\n+            handler = self.error_handlers.get(e.code)\n+            if handler is None:\n+                return e\n+            return handler(e)\n+        except Exception, e:\n+            handler = self.error_handlers.get(500)\n+            if self.debug or handler is None:\n+                raise\n+            return handler(e)\n+\n+    def make_response(self, rv):\n+        \"\"\"Converts the return value from a view function to a real\n+        response object that is an instance of :attr:`response_class`.\n+        \"\"\"\n+        if isinstance(rv, self.response_class):\n+            return rv\n+        if isinstance(rv, basestring):\n+            return self.response_class(rv)\n+        if isinstance(rv, tuple):\n+            return self.response_class(*rv)\n+        return self.response_class.force_type(rv, request.environ)\n+\n+    def preprocess_request(self):\n+        \"\"\"Called before the actual request dispatching and will\n+        call every as :func:`request_init` decorated function.\n+        If any of these function returns a value it's handled as\n+        if it was the return value from the view and further\n+        request handling is stopped.\n+        \"\"\"\n+        for func in self.request_init_funcs:\n+            rv = func()\n+            if rv is not None:\n+                return rv\n+\n+    def process_response(self, response):\n+        \"\"\"Can be overridden in order to modify the response object\n+        before it's sent to the WSGI server.\n+        \"\"\"\n+        session = _request_ctx_stack.top.session\n+        if session is not None:\n+            self.save_session(session, response)\n+        for handler in self.request_shutdown_funcs:\n+            response = handler(response)\n+        return response\n+\n+    def wsgi_app(self, environ, start_response):\n+        \"\"\"The actual WSGI application.  This is not implemented in\n+        `__call__` so that middlewares can be applied:\n+\n+            app.wsgi_app = MyMiddleware(app.wsgi_app)\n+        \"\"\"\n+        _request_ctx_stack.push(_RequestContext(self, environ))\n+        try:\n+            rv = self.preprocess_request()\n+            if rv is None:\n+                rv = self.dispatch_request()\n+            response = self.make_response(rv)\n+            response = self.process_response(response)\n+            return response(environ, start_response)\n+        finally:\n+            _request_ctx_stack.pop()\n+\n+    def __call__(self, environ, start_response):\n+        \"\"\"Shortcut for :attr:`wsgi_app`\"\"\"\n+        return self.wsgi_app(environ, start_response)\n+\n+\n+# context locals\n+_request_ctx_stack = LocalStack()\n+current_app = LocalProxy(lambda: _request_ctx_stack.top.app)\n+request = LocalProxy(lambda: _request_ctx_stack.top.request)\n+session = LocalProxy(lambda: _request_ctx_stack.top.session)\n+g = LocalProxy(lambda: _request_ctx_stack.top.g)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#b15ad394279fc3b7f998fa56857f334a7c0156f6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 19 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 19 | Churn Cumulative: 19 | Contributors (this commit): 1 | Commits (past 90d): 1 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -0,0 +1,19 @@\n+from setuptools import setup\n+\n+\n+setup(\n+    name='Flask',\n+    version='0.1',\n+    url='http://github.com/mitsuhiko/flask/',\n+    license='BSD',\n+    author='Armin Ronacher',\n+    author_email='armin.ronacher@active-4.com',\n+    description='A microframework based on Werkzeug, Jinja2 and good intentions',\n+    modules=['flask'],\n+    zip_safe=False,\n+    platforms='any',\n+    install_requires=[ # yes, as of now we need the development versions\n+        'Werkzeug==dev',\n+        'Jinja2==dev',\n+    ]\n+)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#4ec7d2a0d8eac4f915dc0d38a886cd57045bb0c4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 356 | Lines Deleted: 9 | Files Changed: 3 | Hunks: 15 | Methods Changed: 7 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 365 | Churn Cumulative: 949 | Contributors (this commit): 1 | Commits (past 90d): 5 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -0,0 +1,236 @@\n+# -*- coding: utf-8 -*-\n+#\n+# Flask documentation build configuration file, created by\n+# sphinx-quickstart on Tue Apr  6 15:24:58 2010.\n+#\n+# This file is execfile()d with the current directory set to its containing dir.\n+#\n+# Note that not all possible configuration values are present in this\n+# autogenerated file.\n+#\n+# All configuration values have a default; values that are commented out\n+# serve to show the default.\n+\n+import sys, os\n+\n+# If extensions (or modules to document with autodoc) are in another directory,\n+# add these directories to sys.path here. If the directory is relative to the\n+# documentation root, use os.path.abspath to make it absolute, like shown here.\n+#sys.path.append(os.path.abspath('.'))\n+\n+# -- General configuration -----------------------------------------------------\n+\n+# If your documentation needs a minimal Sphinx version, state it here.\n+#needs_sphinx = '1.0'\n+\n+# Add any Sphinx extension module names here, as strings. They can be extensions\n+# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\n+extensions = ['sphinx.ext.autodoc']\n+\n+# Add any paths that contain templates here, relative to this directory.\n+templates_path = ['_templates']\n+\n+# The suffix of source filenames.\n+source_suffix = '.rst'\n+\n+# The encoding of source files.\n+#source_encoding = 'utf-8-sig'\n+\n+# The master toctree document.\n+master_doc = 'index'\n+\n+# General information about the project.\n+project = u'Flask'\n+copyright = u'2010, Armin Ronacher'\n+\n+import pkg_resources\n+\n+# The version info for the project you're documenting, acts as replacement for\n+# |version| and |release|, also used in various other places throughout the\n+# built documents.\n+release = __import__('pkg_resources').get_distribution('Flask').version\n+version = '.'.join(release.split('.')[:2])\n+\n+# The language for content autogenerated by Sphinx. Refer to documentation\n+# for a list of supported languages.\n+#language = None\n+\n+# There are two options for replacing |today|: either, you set today to some\n+# non-false value, then it is used:\n+#today = ''\n+# Else, today_fmt is used as the format for a strftime call.\n+#today_fmt = '%B %d, %Y'\n+\n+# List of patterns, relative to source directory, that match files and\n+# directories to ignore when looking for source files.\n+exclude_patterns = ['_build']\n+\n+# The reST default role (used for this markup: `text`) to use for all documents.\n+#default_role = None\n+\n+# If true, '()' will be appended to :func: etc. cross-reference text.\n+#add_function_parentheses = True\n+\n+# If true, the current module name will be prepended to all description\n+# unit titles (such as .. function::).\n+#add_module_names = True\n+\n+# If true, sectionauthor and moduleauthor directives will be shown in the\n+# output. They are ignored by default.\n+#show_authors = False\n+\n+# The name of the Pygments (syntax highlighting) style to use.\n+pygments_style = 'sphinx'\n+\n+# A list of ignored prefixes for module index sorting.\n+#modindex_common_prefix = []\n+\n+\n+# -- Options for HTML output ---------------------------------------------------\n+\n+# The theme to use for HTML and HTML Help pages.  Major themes that come with\n+# Sphinx are currently 'default' and 'sphinxdoc'.\n+html_theme = 'nature'\n+\n+# Theme options are theme-specific and customize the look and feel of a theme\n+# further.  For a list of options available for each theme, see the\n+# documentation.\n+#html_theme_options = {}\n+\n+# Add any paths that contain custom themes here, relative to this directory.\n+#html_theme_path = []\n+\n+# The name for this set of Sphinx documents.  If None, it defaults to\n+# \"<project> v<release> documentation\".\n+#html_title = None\n+\n+# A shorter title for the navigation bar.  Default is the same as html_title.\n+#html_short_title = None\n+\n+# The name of an image file (relative to this directory) to place at the top\n+# of the sidebar.\n+#html_logo = None\n+\n+# The name of an image file (within the static path) to use as favicon of the\n+# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n+# pixels large.\n+#html_favicon = None\n+\n+# Add any paths that contain custom static files (such as style sheets) here,\n+# relative to this directory. They are copied after the builtin static files,\n+# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n+html_static_path = ['_static']\n+\n+# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n+# using the given strftime format.\n+#html_last_updated_fmt = '%b %d, %Y'\n+\n+# If true, SmartyPants will be used to convert quotes and dashes to\n+# typographically correct entities.\n+#html_use_smartypants = True\n+\n+# Custom sidebar templates, maps document names to template names.\n+#html_sidebars = {}\n+\n+# Additional templates that should be rendered to pages, maps page names to\n+# template names.\n+#html_additional_pages = {}\n+\n+# If false, no module index is generated.\n+#html_use_modindex = True\n+\n+# If false, no index is generated.\n+#html_use_index = True\n+\n+# If true, the index is split into individual pages for each letter.\n+#html_split_index = False\n+\n+# If true, links to the reST sources are added to the pages.\n+#html_show_sourcelink = True\n+\n+# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n+#html_show_sphinx = True\n+\n+# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n+#html_show_copyright = True\n+\n+# If true, an OpenSearch description file will be output, and all pages will\n+# contain a <link> tag referring to it.  The value of this option must be the\n+# base URL from which the finished HTML is served.\n+#html_use_opensearch = ''\n+\n+# If nonempty, this is the file name suffix for HTML files (e.g. \".xhtml\").\n+#html_file_suffix = ''\n+\n+# Output file base name for HTML help builder.\n+htmlhelp_basename = 'Flaskdoc'\n+\n+\n+# -- Options for LaTeX output --------------------------------------------------\n+\n+# The paper size ('letter' or 'a4').\n+#latex_paper_size = 'letter'\n+\n+# The font size ('10pt', '11pt' or '12pt').\n+#latex_font_size = '10pt'\n+\n+# Grouping the document tree into LaTeX files. List of tuples\n+# (source start file, target name, title, author, documentclass [howto/manual]).\n+latex_documents = [\n+  ('index', 'Flask.tex', u'Flask Documentation',\n+   u'Armin Ronacher', 'manual'),\n+]\n+\n+# The name of an image file (relative to this directory) to place at the top of\n+# the title page.\n+#latex_logo = None\n+\n+# For \"manual\" documents, if this is true, then toplevel headings are parts,\n+# not chapters.\n+#latex_use_parts = False\n+\n+# Additional stuff for the LaTeX preamble.\n+#latex_preamble = ''\n+\n+# Documents to append as an appendix to all manuals.\n+#latex_appendices = []\n+\n+# If false, no module index is generated.\n+#latex_use_modindex = True\n+\n+\n+# -- Options for Epub output ---------------------------------------------------\n+\n+# Bibliographic Dublin Core info.\n+#epub_title = ''\n+#epub_author = ''\n+#epub_publisher = ''\n+#epub_copyright = ''\n+\n+# The language of the text. It defaults to the language option\n+# or en if the language is not set.\n+#epub_language = ''\n+\n+# The scheme of the identifier. Typical schemes are ISBN or URL.\n+#epub_scheme = ''\n+\n+# The unique identifier of the text. This can be a ISBN number\n+# or the project homepage.\n+#epub_identifier = ''\n+\n+# A unique identification for the text.\n+#epub_uid = ''\n+\n+# HTML files that should be inserted before the pages created by sphinx.\n+# The format is a list of tuples containing the path and title.\n+#epub_pre_files = []\n+\n+# HTML files shat should be inserted after the pages created by sphinx.\n+# The format is a list of tuples containing the path and title.\n+#epub_post_files = []\n+\n+# A list of files that should not be packed into the epub file.\n+#epub_exclude_files = []\n+\n+# The depth of the table of contents in toc.ncx.\n+#epub_tocdepth = 3\n\n@@ -57,7 +57,7 @@ def format_datetime(timestamp):\n def gravatar_url(email, size=80):\n     \"\"\"Return the gravatar image for the given email address\"\"\"\n     return 'http://www.gravatar.com/avatar/%s?d=identicon&s=%d' % \\\n-        (md5(email.lower().encode('utf-8')).hexdigest(), size)\n+        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)\n \n \n @app.request_init\n\n@@ -125,9 +125,22 @@ def render_template_string(source, **context):\n \n class Flask(object):\n     \"\"\"The flask object implements a WSGI application and acts as the central\n-    object.  It is passed the name of the module or package of the application\n-    and optionally a configuration.  When it's created it sets up the\n-    template engine and provides ways to register view functions.\n+    object.  It is passed the name of the module or package of the\n+    application.  Once it is created it will act as a central registry for\n+    the view functions, the URL rules, template configuration and much more.\n+\n+    The name of the package is used to resolve resources from inside the\n+    package or the folder the module is contained in depending on if the\n+    package parameter resolves to an actual python package (a folder with\n+    an `__init__.py` file inside) or a standard module (just a `.py` file).\n+\n+    For more information about resource loading, see :func:`open_resource`.\n+\n+    Usually you create a :class:`Flask` instance in your main module or\n+    in the `__init__.py` file of your package like this::\n+\n+        from flask import Flask\n+        app = Flask(__name__)\n     \"\"\"\n \n     #: the class that is used for request objects\n@@ -156,11 +169,43 @@ class Flask(object):\n     )\n \n     def __init__(self, package_name):\n+        #: the debug flag.  Set this to `True` to enable debugging of\n+        #: the application.  In debug mode the debugger will kick in\n+        #: when an unhandled exception ocurrs and the integrated server\n+        #: will automatically reload the application if changes in the\n+        #: code are detected.\n         self.debug = False\n+\n+        #: the name of the package or module.  Do not change this once\n+        #: it was set by the constructor.\n         self.package_name = package_name\n+\n+        #: a dictionary of all view functions registered.  The keys will\n+        #: be function names which are also used to generate URLs and\n+        #: the values are the function objects themselves.\n+        #: to register a view function, use the :meth:`route` decorator.\n         self.view_functions = {}\n+\n+        #: a dictionary of all registered error handlers.  The key is\n+        #: be the error code as integer, the value the function that\n+        #: should handle that error.\n+        #: To register a error handler, use the :meth:`errorhandler`\n+        #: decorator.\n         self.error_handlers = {}\n+\n+        #: a list of functions that should be called at the beginning\n+        #: of the request before request dispatching kicks in.  This\n+        #: can for example be used to open database connections or\n+        #: getting hold of the currently logged in user.\n+        #: To register a function here, use the :meth:`request_init`\n+        #: decorator.\n         self.request_init_funcs = []\n+\n+        #: a list of functions that are called at the end of the\n+        #: request.  Tha function is passed the current response\n+        #: object and modify it in place or replace it.\n+        #: To register a function here use the :meth:`request_shtdown`\n+        #: decorator.\n         self.request_shutdown_funcs = []\n         self.url_map = Map()\n \n@@ -168,6 +213,9 @@ class Flask(object):\n             self.url_map.add(Rule(self.static_path + '/<filename>',\n                                   build_only=True, endpoint='static'))\n \n+        #: the Jinja2 environment.  It is created from the\n+        #: :attr:`jinja_options` and the loader that is returned\n+        #: by the :meth:`create_jinja_loader` function.\n         self.jinja_env = Environment(loader=self.create_jinja_loader(),\n                                      **self.jinja_options)\n         self.jinja_env.globals.update(\n@@ -187,7 +235,10 @@ class Flask(object):\n         return PackageLoader(self.package_name)\n \n     def run(self, host='localhost', port=5000, **options):\n-        \"\"\"Runs the application on a local development server\"\"\"\n+        \"\"\"Runs the application on a local development server.  If the\n+        :attr:`debug` flag is set the server will automatically reload\n+        for code changes and show a debugger in case an exception happened.\n+        \"\"\"\n         from werkzeug import run_simple\n         if 'debug' in options:\n             self.debug = options.pop('debug')\n@@ -206,12 +257,30 @@ class Flask(object):\n         return Client(self, self.response_class, use_cookies=True)\n \n     def open_resource(self, resource):\n-        \"\"\"Opens a resource from the application's resource folder\"\"\"\n+        \"\"\"Opens a resource from the application's resource folder.  To see\n+        how this works, consider the following folder structure::\n+\n+            /myapplication.py\n+            /schemal.sql\n+            /static\n+                /style.css\n+            /template\n+                /layout.html\n+                /index.html\n+\n+        If you want to open the `schema.sql` file you would do the\n+        following::\n+\n+            with app.open_resource('schema.sql') as f:\n+                contents = f.read()\n+                do_something_with(contents)\n+        \"\"\"\n         return pkg_resources.resource_stream(self.package_name, resource)\n \n     def open_session(self, request):\n-        \"\"\"Creates or opens a new session.  Default implementation requires\n-        that `securecookie.secret_key` is set.\n+        \"\"\"Creates or opens a new session.  Default implementation stores all\n+        session data in a signed cookie.  This requires that the\n+        :attr:`secret_key` is set.\n         \"\"\"\n         key = self.secret_key\n         if key is not None:\n@@ -219,7 +288,9 @@ class Flask(object):\n                                             secret_key=key)\n \n     def save_session(self, session, response):\n-        \"\"\"Saves the session if it needs updates.\"\"\"\n+        \"\"\"Saves the session if it needs updates.  For the default\n+        implementation, check :meth:`open_session`.\n+        \"\"\"\n         if session is not None:\n             session.save_cookie(response, self.session_cookie_name)\n \n@@ -230,6 +301,46 @@ class Flask(object):\n             @app.route('/')\n             def index():\n                 return 'Hello World'\n+\n+        Variables parts in the route can be specified with angular\n+        brackets (``/user/<username>``).  By default a variable part\n+        in the URL accepts any string without a slash however a differnt\n+        converter can be specified as well by using ``<converter:name>``.\n+\n+        Variable parts are passed to the view function as keyword\n+        arguments.\n+\n+        The following converters are possible:\n+\n+        =========== ===========================================\n+        `int`       accepts integers\n+        `float`     like `int` but for floating point values\n+        `path`      like the default but also accepts slashes\n+        =========== ===========================================\n+\n+        Here some examples::\n+\n+            @app.route('/')\n+            def index():\n+                pass\n+\n+            @app.route('/<username>')\n+            def show_user(username):\n+                pass\n+\n+            @app.route('/post/<int:post_id>')\n+            def show_post(post_id):\n+                pass\n+\n+        The :meth:`route` decorator accepts a couple of other arguments\n+        as well:\n+\n+        :param methods: a list of methods this rule should be limited\n+                        to (``GET``, ``POST`` etc.)\n+        :param subdomain: specifies the rule for the subdoain in case\n+                          subdomain matching is in use.\n+        :param strict_slashes: can be used to disable the strict slashes\n+                               setting for this rule.  See above.\n         \"\"\"\n         def decorator(f):\n             if 'endpoint' not in options:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#3b36bef2e6165bb4dad73d17f23ee1879e99f497", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 46 | Lines Deleted: 26 | Files Changed: 3 | Hunks: 15 | Methods Changed: 8 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 72 | Churn Cumulative: 1021 | Contributors (this commit): 2 | Commits (past 90d): 8 | Contributors (cumulative): 6 | DMM Complexity: 1.0\n\nDIFF:\n@@ -25,7 +25,7 @@ import sys, os\n \n # Add any Sphinx extension module names here, as strings. They can be extensions\n # coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\n-extensions = ['sphinx.ext.autodoc']\n+extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']\n \n # Add any paths that contain templates here, relative to this directory.\n templates_path = ['_templates']\n@@ -234,3 +234,8 @@ latex_documents = [\n \n # The depth of the table of contents in toc.ncx.\n #epub_tocdepth = 3\n+\n+intersphinx_mapping = {\n+    'http://docs.python.org/dev': None,\n+    'http://werkzeug.pocoo.org/documentation/dev/': None\n+}\n\n@@ -7,8 +7,8 @@ from hashlib import md5\n from datetime import datetime\n from contextlib import closing\n from flask import Flask, request, session, url_for, redirect, \\\n-     render_template, abort, g, flash, generate_password_hash, \\\n-     check_password_hash\n+     render_template, abort, g, flash\n+from werkzeug import check_password_hash, generate_password_hash\n \n \n # configuration\n\n@@ -13,25 +13,17 @@ import os\n import sys\n import pkg_resources\n from threading import local\n+from contextlib import contextmanager\n from jinja2 import Environment, PackageLoader\n-from werkzeug import Request, Response, LocalStack, LocalProxy\n+from werkzeug import Request, Response, LocalStack, LocalProxy, \\\n+     create_environ, cached_property\n from werkzeug.routing import Map, Rule\n from werkzeug.exceptions import HTTPException, InternalServerError\n from werkzeug.contrib.securecookie import SecureCookie\n \n-# try to import the json helpers\n-try:\n-    from simplejson import loads as load_json, dumps as dump_json\n-except ImportError:\n-    try:\n-        from json import loads as load_json, dumps as dump_json\n-    except ImportError:\n-        pass\n-\n # utilities we import from Werkzeug and Jinja2 that are unused\n # in the module but are exported as public interface.\n-from werkzeug import abort, redirect, secure_filename, cached_property, \\\n-     html, import_string, generate_password_hash, check_password_hash\n+from werkzeug import abort, redirect\n from jinja2 import Markup, escape\n \n \n@@ -83,12 +75,6 @@ def url_for(endpoint, **values):\n     return _request_ctx_stack.top.url_adapter.build(endpoint, values)\n \n \n-def jsonified(**values):\n-    \"\"\"Returns a json response\"\"\"\n-    return current_app.response_class(dump_json(values),\n-                                      mimetype='application/json')\n-\n-\n def flash(message):\n     \"\"\"Flashes a message to the next request.  In order to remove the\n     flashed message from the session and to display it to the user,\n@@ -113,6 +99,7 @@ def render_template(template_name, **context):\n     \"\"\"Renders a template from the template folder with the given\n     context.\n     \"\"\"\n+    current_app.update_template_context(context)\n     return current_app.jinja_env.get_template(template_name).render(context)\n \n \n@@ -120,6 +107,7 @@ def render_template_string(source, **context):\n     \"\"\"Renders a template from the given template source string\n     with the given context.\n     \"\"\"\n+    current_app.update_template_context(context)\n     return current_app.jinja_env.from_string(source).render(context)\n \n \n@@ -220,9 +208,6 @@ class Flask(object):\n                                      **self.jinja_options)\n         self.jinja_env.globals.update(\n             url_for=url_for,\n-            request=request,\n-            session=session,\n-            g=g,\n             get_flashed_messages=get_flashed_messages\n         )\n \n@@ -234,6 +219,15 @@ class Flask(object):\n         \"\"\"\n         return PackageLoader(self.package_name)\n \n+    def update_template_context(self, context):\n+        \"\"\"Update the template context with some commonly used variables.\n+        This injects request, session and g into the template context.\n+        \"\"\"\n+        reqctx = _request_ctx_stack.top\n+        context['request'] = reqctx.request\n+        context['session'] = reqctx.session\n+        context['g'] = reqctx.g\n+\n     def run(self, host='localhost', port=5000, **options):\n         \"\"\"Runs the application on a local development server.  If the\n         :attr:`debug` flag is set the server will automatically reload\n@@ -443,17 +437,38 @@ class Flask(object):\n \n             app.wsgi_app = MyMiddleware(app.wsgi_app)\n         \"\"\"\n-        _request_ctx_stack.push(_RequestContext(self, environ))\n-        try:\n+        with self.request_context(environ):\n             rv = self.preprocess_request()\n             if rv is None:\n                 rv = self.dispatch_request()\n             response = self.make_response(rv)\n             response = self.process_response(response)\n             return response(environ, start_response)\n+\n+    @contextmanager\n+    def request_context(self, environ):\n+        \"\"\"Creates a request context from the given environment and binds\n+        it to the current context.  This must be used in combination with\n+        the `with` statement because the request is only bound to the\n+        current context for the duration of the `with` block.\n+\n+        Example usage::\n+\n+            with app.request_context(environ):\n+                do_something_with(request)\n+        \"\"\"\n+        _request_ctx_stack.push(_RequestContext(self, environ))\n+        try:\n+            yield\n         finally:\n             _request_ctx_stack.pop()\n \n+    def test_request_context(self, *args, **kwargs):\n+        \"\"\"Creates a WSGI environment from the given values (see\n+        :func:`werkzeug.create_environ` for more information).\n+        \"\"\"\n+        return self.request_context(create_environ(*args, **kwargs))\n+\n     def __call__(self, environ, start_response):\n         \"\"\"Shortcut for :attr:`wsgi_app`\"\"\"\n         return self.wsgi_app(environ, start_response)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#4aa76212d1be9b17a57249549c2a73fb10b6cda8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 19 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 6 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 23 | Churn Cumulative: 801 | Contributors (this commit): 2 | Commits (past 90d): 8 | Contributors (cumulative): 4 | DMM Complexity: 1.0\n\nDIFF:\n@@ -148,7 +148,7 @@ def unfollow_user(username):\n     return redirect(url_for('user_timeline', username=username))\n \n \n-@app.route('/add_message')\n+@app.route('/add_message', methods=['POST'])\n def add_message():\n     if 'user_id' not in session:\n         abort(401)\n@@ -161,7 +161,7 @@ def add_message():\n     return redirect(url_for('timeline'))\n \n \n-@app.route('/login')\n+@app.route('/login', methods=['GET', 'POST'])\n def login():\n     if 'user_id' in session:\n         return redirect(url_for('timeline'))\n@@ -181,7 +181,7 @@ def login():\n     return render_template('login.html', error=error)\n \n \n-@app.route('/register')\n+@app.route('/register', methods=['GET', 'POST'])\n def register():\n     if 'user_id' in session:\n         return redirect(url_for('timeline'))\n\n@@ -326,11 +326,25 @@ class Flask(object):\n             def show_post(post_id):\n                 pass\n \n+        An important detail to keep in mind is how Flask deals with trailing\n+        slashes.  The idea is to keep each URL unique so the following rules\n+        apply:\n+\n+        1. If a rule ends with a slash and is requested without a slash\n+           by the user, the user is automatically redirected to the same\n+           page with a trailing slash attached.\n+        2. If a rule does not end with a trailing slash and the user request\n+           the page with a trailing slash, a 404 not found is raised.\n+\n+        This is consistent with how web servers deal with static files.  This\n+        also makes it possible to use relative link targets safely.\n+\n         The :meth:`route` decorator accepts a couple of other arguments\n         as well:\n \n         :param methods: a list of methods this rule should be limited\n-                        to (``GET``, ``POST`` etc.)\n+                        to (``GET``, ``POST`` etc.).  By default a rule\n+                        just listens for ``GET`` (and implicitly ``HEAD``).\n         :param subdomain: specifies the rule for the subdoain in case\n                           subdomain matching is in use.\n         :param strict_slashes: can be used to disable the strict slashes\n@@ -339,6 +353,7 @@ class Flask(object):\n         def decorator(f):\n             if 'endpoint' not in options:\n                 options['endpoint'] = f.__name__\n+            options.setdefault('methods', ('GET',))\n             self.url_map.add(Rule(rule, **options))\n             self.view_functions[options['endpoint']] = f\n             return f\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
