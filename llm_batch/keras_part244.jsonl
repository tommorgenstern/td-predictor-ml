{"custom_id": "keras#f0e197e7ff42b9b096b81a9449f8cb90c6bc7922", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 1390 | Contributors (this commit): 18 | Commits (past 90d): 5 | Contributors (cumulative): 18 | DMM Complexity: None\n\nDIFF:\n@@ -302,7 +302,7 @@ def validate_file(fpath, file_hash, algorithm='auto', chunk_size=65535):\n class Sequence(object):\n     \"\"\"Base object for fitting to a sequence of data, such as a dataset.\n \n-    Every `Sequence` must implements the `__getitem__` and the `__len__` methods.\n+    Every `Sequence` must implement the `__getitem__` and the `__len__` methods.\n     If you want to modify your dataset between epochs you may implement `on_epoch_end`.\n     The method `__getitem__` should return a complete batch.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#7ff9303041729bb69bd416e2ccb6e7a87ee7cc2a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 72 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 11 | Methods Changed: 10 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 75 | Churn Cumulative: 286 | Contributors (this commit): 14 | Commits (past 90d): 1 | Contributors (cumulative): 14 | DMM Complexity: None\n\nDIFF:\n@@ -15,7 +15,7 @@ def softmax(x, axis=-1):\n     \"\"\"Softmax activation function.\n \n     # Arguments\n-        x : Tensor.\n+        x: Input tensor.\n         axis: Integer, axis along which the softmax normalization is applied.\n \n     # Returns\n@@ -36,17 +36,38 @@ def softmax(x, axis=-1):\n \n \n def elu(x, alpha=1.0):\n+    \"\"\"Exponential linear unit.\n+\n+    # Arguments\n+        x: Input tensor.\n+        alpha: A scalar, slope of negative section.\n+\n+    # Returns\n+        The exponential linear activation: `x` if `x > 0` and\n+        `alpha * (exp(x)-1)` if `x < 0`.\n+\n+    # References\n+        - [Fast and Accurate Deep Network Learning by Exponential\n+        Linear Units (ELUs)](https://arxiv.org/abs/1511.07289)\n+    \"\"\"\n     return K.elu(x, alpha)\n \n \n def selu(x):\n-    \"\"\"Scaled Exponential Linear Unit. (Klambauer et al., 2017).\n+    \"\"\"Scaled Exponential Linear Unit (SELU).\n+\n+    SELU is equal to: `scale * elu(x, alpha)`, where alpha and scale\n+    are pre-defined constants. The values of `alpha` and `scale` are\n+    chosen so that the mean and variance of the inputs are preserved\n+    between two consecutive layers as long as the weights are initialized\n+    correctly (see `lecun_normal` initialization) and the number of inputs\n+    is \"large enough\" (see references for more information).\n \n     # Arguments\n         x: A tensor or variable to compute the activation function for.\n \n     # Returns\n-        Tensor with the same shape and dtype as `x`.\n+       The scaled exponential unit activation: `scale * elu(x, alpha)`.\n \n     # Note\n         - To be used together with the initialization \"lecun_normal\".\n@@ -61,30 +82,78 @@ def selu(x):\n \n \n def softplus(x):\n+    \"\"\"Softplus activation function.\n+\n+    # Arguments\n+        x: Input tensor.\n+\n+    # Returns\n+        The softplus activation: `log(exp(x) + 1`.\n+    \"\"\"\n     return K.softplus(x)\n \n \n def softsign(x):\n+    \"\"\"Softsign activation function.\n+\n+    # Arguments\n+        x: Input tensor.\n+\n+    # Returns\n+        The softplus activation: `x / (abs(x) + 1)`.\n+    \"\"\"\n     return K.softsign(x)\n \n \n def relu(x, alpha=0., max_value=None):\n+    \"\"\"(Leaky) Rectified Linear Unit.\n+\n+    # Arguments\n+        x: Input tensor.\n+        alpha: Slope of the negative part. Defaults to zero.\n+        max_value: Maximum value for the output.\n+\n+    # Returns\n+        The (leaky) rectified linear unit activation: `x` if `x > 0`,\n+        `alpha * x` if `x < 0`. If `max_value` is defined, the result\n+        is truncated to this value.\n+    \"\"\"\n     return K.relu(x, alpha=alpha, max_value=max_value)\n \n \n def tanh(x):\n+    \"\"\"Hyperbolic tangent activation function.\n+    \"\"\"\n     return K.tanh(x)\n \n \n def sigmoid(x):\n+    \"\"\"Sigmoid activation function.\n+    \"\"\"\n     return K.sigmoid(x)\n \n \n def hard_sigmoid(x):\n+    \"\"\"Hard sigmoid activation function.\n+\n+    Faster to compute than sigmoid activation.\n+\n+    # Arguments\n+        x: Input tensor.\n+\n+    # Returns\n+        Hard sigmoid activation:\n+\n+        - `0` if `x < -2.5`\n+        - `1` if `x > 2.5`\n+        - `0.2 * x + 0.5` if `-2.5 <= x <= 2.5`.\n+    \"\"\"\n     return K.hard_sigmoid(x)\n \n \n def linear(x):\n+    \"\"\"Linear (e.g. unit) activation function.\n+    \"\"\"\n     return x\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#712716b13104eaa0d21ab0f734aa474599603cff", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 4 | Methods Changed: 4 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 10 | Churn Cumulative: 296 | Contributors (this commit): 14 | Commits (past 90d): 2 | Contributors (cumulative): 14 | DMM Complexity: 1.0\n\nDIFF:\n@@ -32,7 +32,8 @@ def softmax(x, axis=-1):\n         s = K.sum(e, axis=axis, keepdims=True)\n         return e / s\n     else:\n-        raise ValueError('Cannot apply softmax to a tensor that is 1D')\n+        raise ValueError('Cannot apply softmax to a tensor that is 1D. '\n+                         'Received input: %s' % x)\n \n \n def elu(x, alpha=1.0):\n@@ -106,7 +107,7 @@ def softsign(x):\n \n \n def relu(x, alpha=0., max_value=None):\n-    \"\"\"(Leaky) Rectified Linear Unit.\n+    \"\"\"Rectified Linear Unit.\n \n     # Arguments\n         x: Input tensor.\n@@ -152,7 +153,7 @@ def hard_sigmoid(x):\n \n \n def linear(x):\n-    \"\"\"Linear (e.g. unit) activation function.\n+    \"\"\"Linear (i.e. identity) activation function.\n     \"\"\"\n     return x\n \n@@ -162,7 +163,8 @@ def serialize(activation):\n \n \n def deserialize(name, custom_objects=None):\n-    return deserialize_keras_object(name,\n+    return deserialize_keras_object(\n+        name,\n         module_objects=globals(),\n         custom_objects=custom_objects,\n         printable_module_name='activation function')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#ba8b3fca6e9e4e863bb80d134946be1b60463718", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 35 | Lines Deleted: 16 | Files Changed: 5 | Hunks: 16 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/1 | Churn Δ: 51 | Churn Cumulative: 5621 | Contributors (this commit): 66 | Commits (past 90d): 18 | Contributors (cumulative): 84 | DMM Complexity: 1.0\n\nDIFF:\n@@ -6,9 +6,9 @@ Results example: http://i.imgur.com/4nj4KjN.jpg\n '''\n from __future__ import print_function\n \n-from scipy.misc import imsave\n import numpy as np\n import time\n+from keras.preprocessing.image import save_img\n from keras.applications import vgg16\n from keras import backend as K\n \n@@ -40,6 +40,7 @@ def deprocess_image(x):\n     x = np.clip(x, 0, 255).astype('uint8')\n     return x\n \n+\n # build the VGG16 network with ImageNet weights\n model = vgg16.VGG16(weights='imagenet', include_top=False)\n print('Model loaded.')\n@@ -132,4 +133,4 @@ for i in range(n):\n                          (img_height + margin) * j: (img_height + margin) * j + img_height, :] = img\n \n # save the result to disk\n-imsave('stitched_filters_%dx%d.png' % (n, n), stitched_filters)\n+save_img('stitched_filters_%dx%d.png' % (n, n), stitched_filters)\n\n@@ -11,7 +11,7 @@ python deep_dream.py img/mypic.jpg results/dream\n '''\n from __future__ import print_function\n \n-from keras.preprocessing.image import load_img, img_to_array\n+from keras.preprocessing.image import load_img, save_img, img_to_array\n import numpy as np\n import scipy\n import argparse\n@@ -135,11 +135,6 @@ def gradient_ascent(x, iterations, step, max_loss=None):\n     return x\n \n \n-def save_img(img, fname):\n-    pil_img = deprocess_image(np.copy(img))\n-    scipy.misc.imsave(fname, pil_img)\n-\n-\n \"\"\"Process:\n \n - Load the original image.\n@@ -192,4 +187,4 @@ for shape in successive_shapes:\n     img += lost_detail\n     shrunk_original_img = resize_img(original_img, shape)\n \n-save_img(img, fname=result_prefix + '.png')\n+save_img(result_prefix + '.png', deprocess_image(np.copy(img)))\n\n@@ -47,12 +47,11 @@ import time\n import argparse\r\n import numpy as np\r\n from scipy.optimize import fmin_l_bfgs_b\r\n-from scipy.misc import imread, imsave\r\n \r\n from keras import backend as K\r\n from keras.layers import Input, AveragePooling2D\r\n from keras.models import Model\r\n-from keras.preprocessing.image import load_img, img_to_array\r\n+from keras.preprocessing.image import load_img, save_img, img_to_array\r\n from keras.applications import vgg19\r\n \r\n # Command line arguments\r\n@@ -83,7 +82,7 @@ use_content_img = content_img_path is not None\n num_labels = args.nlabels\r\n num_colors = 3  # RGB\r\n # determine image sizes based on target_mask\r\n-ref_img = imread(target_mask_path)\r\n+ref_img = img_to_array(load_img(target_mask_path))\r\n img_nrows, img_ncols = ref_img.shape[:2]\r\n \r\n total_variation_weight = 50.\r\n@@ -165,6 +164,7 @@ def load_mask_labels():\n     return (np.expand_dims(style_mask, axis=0),\r\n             np.expand_dims(target_mask, axis=0))\r\n \r\n+\r\n # Create tensor variables for images\r\n if K.image_data_format() == 'channels_first':\r\n     shape = (1, num_colors, img_nrows, img_ncols)\r\n@@ -284,6 +284,7 @@ def total_variation_loss(x):\n                      x[:, :img_nrows - 1, 1:, :])\r\n     return K.sum(K.pow(a + b, 1.25))\r\n \r\n+\r\n # Overall loss is the weighted sum of content_loss, style_loss and tv_loss\r\n # Each individual loss uses features from image/mask models.\r\n loss = K.variable(0)\r\n@@ -364,7 +365,7 @@ for i in range(50):\n     # save current generated image\r\n     img = deprocess_image(x.copy())\r\n     fname = target_img_prefix + '_at_iteration_%d.png' % i\r\n-    imsave(fname, img)\r\n+    save_img(fname, img)\r\n     end_time = time.time()\r\n     print('Image saved as', fname)\r\n     print('Iteration %d completed in %ds' % (i, end_time - start_time))\r\n\n@@ -50,8 +50,7 @@ keeping the generated image close enough to the original one.\n '''\n \n from __future__ import print_function\n-from keras.preprocessing.image import load_img, img_to_array\n-from scipy.misc import imsave\n+from keras.preprocessing.image import load_img, save_img, img_to_array\n import numpy as np\n from scipy.optimize import fmin_l_bfgs_b\n import time\n@@ -284,7 +283,7 @@ for i in range(iterations):\n     # save current generated image\n     img = deprocess_image(x.copy())\n     fname = result_prefix + '_at_iteration_%d.png' % i\n-    imsave(fname, img)\n+    save_img(fname, img)\n     end_time = time.time()\n     print('Image saved as', fname)\n     print('Iteration %d completed in %ds' % (i, end_time - start_time))\n\n@@ -358,6 +358,29 @@ def img_to_array(img, data_format=None):\n     return x\n \n \n+def save_img(path,\n+             x,\n+             data_format=None,\n+             file_format=None,\n+             scale=True, **kwargs):\n+    \"\"\"Save an image stored as a Numpy array to a path or file object.\n+\n+    # Arguments\n+        path: Path or file object.\n+        x: Numpy array.\n+        data_format: Image data format.  One of {\"channels_first\" or \"channels_last\"}.\n+            Default is 'channels_last'.\n+        file_format: Optional file format override.  If omitted, the\n+            format to use is determined from the filename extension.\n+            If a file object was used instead of a filename, this\n+            parameter should always be used.\n+        scale: Whether to rescale image values to be within [0, 255].\n+        **kwargs: Additional keyword arguments passed to PIL.Image.save().\n+    \"\"\"\n+    img = array_to_img(x, data_format=data_format, scale=scale)\n+    img.save(path, format=file_format, **kwargs)\n+\n+\n def load_img(path, grayscale=False, target_size=None,\n              interpolation='nearest'):\n     \"\"\"Loads an image into PIL format.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#7fe2a04754e7a8d25f45a67a90e0ebd23beeed14", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 259 | Lines Deleted: 148 | Files Changed: 1 | Hunks: 93 | Methods Changed: 19 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 407 | Churn Cumulative: 3774 | Contributors (this commit): 54 | Commits (past 90d): 15 | Contributors (cumulative): 54 | DMM Complexity: 0.2916666666666667\n\nDIFF:\n@@ -158,8 +158,8 @@ def random_zoom(x, zoom_range, row_axis=1, col_axis=2, channel_axis=0,\n         ValueError: if `zoom_range` isn't a tuple.\n     \"\"\"\n     if len(zoom_range) != 2:\n-        raise ValueError('`zoom_range` should be a tuple or list of two floats. '\n-                         'Received arg: ', zoom_range)\n+        raise ValueError('`zoom_range` should be a tuple or list of two'\n+                         ' floats. Received: ', zoom_range)\n \n     if zoom_range[0] == 1 and zoom_range[1] == 1:\n         zx, zy = 1, 1\n@@ -176,7 +176,7 @@ def random_zoom(x, zoom_range, row_axis=1, col_axis=2, channel_axis=0,\n \n \n def random_channel_shift(x, intensity, channel_axis=0):\n-    \"\"\"Perform a random channel shift.\n+    \"\"\"Performs a random channel shift.\n \n     # Arguments\n         x: Input tensor. Must be 3D.\n@@ -189,7 +189,10 @@ def random_channel_shift(x, intensity, channel_axis=0):\n     \"\"\"\n     x = np.rollaxis(x, channel_axis, 0)\n     min_x, max_x = np.min(x), np.max(x)\n-    channel_images = [np.clip(x_channel + np.random.uniform(-intensity, intensity), min_x, max_x)\n+    channel_images = [\n+        np.clip(x_channel + np.random.uniform(-intensity, intensity),\n+                min_x,\n+                max_x)\n         for x_channel in x]\n     x = np.stack(channel_images, axis=0)\n     x = np.rollaxis(x, 0, channel_axis + 1)\n@@ -197,7 +200,7 @@ def random_channel_shift(x, intensity, channel_axis=0):\n \n \n def random_brightness(x, brightness_range):\n-    \"\"\"Perform a random brightness shift.\n+    \"\"\"Performs a random brightness shift.\n \n     # Arguments\n         x: Input tensor. Must be 3D.\n@@ -212,8 +215,9 @@ def random_brightness(x, brightness_range):\n \n     \"\"\"\n     if len(brightness_range) != 2:\n-        raise ValueError('`brightness_range should be tuple or list of two floats. '\n-                         'Received arg: ', brightness_range)\n+        raise ValueError(\n+            '`brightness_range should be tuple or list of two floats. '\n+            'Received: %s' % brightness_range)\n \n     x = array_to_img(x)\n     x = imgenhancer_Brightness = ImageEnhance.Brightness(x)\n@@ -237,7 +241,7 @@ def apply_transform(x,\n                     channel_axis=0,\n                     fill_mode='nearest',\n                     cval=0.):\n-    \"\"\"Apply the image transformation specified by a matrix.\n+    \"\"\"Applies the image transformation specified by a matrix.\n \n     # Arguments\n         x: 2D numpy array, single image.\n@@ -280,8 +284,9 @@ def array_to_img(x, data_format=None, scale=True):\n     # Arguments\n         x: Input Numpy array.\n         data_format: Image data format.\n+            either \"channels_first\" or \"channels_last\".\n         scale: Whether to rescale image values\n-            to be within [0, 255].\n+            to be within `[0, 255]`.\n \n     # Returns\n         A PIL Image instance.\n@@ -329,7 +334,8 @@ def img_to_array(img, data_format=None):\n \n     # Arguments\n         img: PIL Image instance.\n-        data_format: Image data format.\n+        data_format: Image data format,\n+            either \"channels_first\" or \"channels_last\".\n \n     # Returns\n         A 3D Numpy array.\n@@ -363,19 +369,19 @@ def save_img(path,\n              data_format=None,\n              file_format=None,\n              scale=True, **kwargs):\n-    \"\"\"Save an image stored as a Numpy array to a path or file object.\n+    \"\"\"Saves an image stored as a Numpy array to a path or file object.\n \n     # Arguments\n         path: Path or file object.\n         x: Numpy array.\n-        data_format: Image data format.  One of {\"channels_first\" or \"channels_last\"}.\n-            Default is 'channels_last'.\n+        data_format: Image data format,\n+            either \"channels_first\" or \"channels_last\".\n         file_format: Optional file format override. If omitted, the\n             format to use is determined from the filename extension.\n             If a file object was used instead of a filename, this\n             parameter should always be used.\n-        scale: Whether to rescale image values to be within [0, 255].\n-        **kwargs: Additional keyword arguments passed to PIL.Image.save().\n+        scale: Whether to rescale image values to be within `[0, 255]`.\n+        **kwargs: Additional keyword arguments passed to `PIL.Image.save()`.\n     \"\"\"\n     img = array_to_img(x, data_format=data_format, scale=scale)\n     img.save(path, format=file_format, **kwargs)\n@@ -386,7 +392,7 @@ def load_img(path, grayscale=False, target_size=None,\n     \"\"\"Loads an image into PIL format.\n \n     # Arguments\n-        path: Path to image file\n+        path: Path to image file.\n         grayscale: Boolean, whether to load the image as grayscale.\n         target_size: Either `None` (default to original size)\n             or tuple of ints `(img_height, img_width)`.\n@@ -439,49 +445,63 @@ class ImageDataGenerator(object):\n      The data will be looped over (in batches).\n \n     # Arguments\n-        featurewise_center: Boolean. Set input mean to 0 over the dataset, feature-wise.\n+        featurewise_center: Boolean.\n+            Set input mean to 0 over the dataset, feature-wise.\n         samplewise_center: Boolean. Set each sample mean to 0.\n-        featurewise_std_normalization: Boolean. Divide inputs by std of the dataset, feature-wise.\n+        featurewise_std_normalization: Boolean.\n+            Divide inputs by std of the dataset, feature-wise.\n         samplewise_std_normalization: Boolean. Divide each input by its std.\n         zca_epsilon: epsilon for ZCA whitening. Default is 1e-6.\n         zca_whitening: Boolean. Apply ZCA whitening.\n         rotation_range: Int. Degree range for random rotations.\n-        width_shift_range: float, 1-D array-like or int\n+        width_shift_range: Float, 1-D array-like or int\n             float: fraction of total width, if < 1, or pixels if >= 1.\n             1-D array-like: random elements from the array.\n             int: integer number of pixels from interval\n                 `(-width_shift_range, +width_shift_range)`\n-            With `width_shift_range=2` possible values are integers [-1, 0, +1],\n+            With `width_shift_range=2` possible values\n+                are integers `[-1, 0, +1]`,\n             same as with `width_shift_range=[-1, 0, +1]`,\n             while with `width_shift_range=1.0` possible values are floats in\n             the interval [-1.0, +1.0).\n-        shear_range: Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)\n-        zoom_range: Float or [lower, upper]. Range for random zoom. If a float, `[lower, upper] = [1-zoom_range, 1+zoom_range]`.\n+        shear_range: Float. Shear Intensity\n+            (Shear angle in counter-clockwise direction in degrees)\n+        zoom_range: Float or [lower, upper]. Range for random zoom.\n+            If a float, `[lower, upper] = [1-zoom_range, 1+zoom_range]`.\n         channel_shift_range: Float. Range for random channel shifts.\n-        fill_mode: One of {\"constant\", \"nearest\", \"reflect\" or \"wrap\"}.  Default is 'nearest'.\n-        Points outside the boundaries of the input are filled according to the given mode:\n+        fill_mode: One of {\"constant\", \"nearest\", \"reflect\" or \"wrap\"}.\n+            Default is 'nearest'.\n+            Points outside the boundaries of the input are filled\n+            according to the given mode:\n             'constant': kkkkkkkk|abcd|kkkkkkkk (cval=k)\n             'nearest':  aaaaaaaa|abcd|dddddddd\n             'reflect':  abcddcba|abcd|dcbaabcd\n             'wrap':  abcdabcd|abcd|abcdabcd\n-        cval: Float or Int. Value used for points outside the boundaries when `fill_mode = \"constant\"`.\n+        cval: Float or Int.\n+            Value used for points outside the boundaries\n+            when `fill_mode = \"constant\"`.\n         horizontal_flip: Boolean. Randomly flip inputs horizontally.\n         vertical_flip: Boolean. Randomly flip inputs vertically.\n-        rescale: rescaling factor. Defaults to None. If None or 0, no rescaling is applied,\n-                otherwise we multiply the data by the value provided (before applying\n-                any other transformation).\n+        rescale: rescaling factor. Defaults to None.\n+            If None or 0, no rescaling is applied,\n+            otherwise we multiply the data by the value provided\n+            (before applying any other transformation).\n         preprocessing_function: function that will be implied on each input.\n             The function will run after the image is resized and augmented.\n             The function should take one argument:\n             one image (Numpy tensor with rank 3),\n             and should output a Numpy tensor with the same shape.\n-        data_format: One of {\"channels_first\", \"channels_last\"}.\n-            \"channels_last\" mode means that the images should have shape `(samples, height, width, channels)`,\n-            \"channels_first\" mode means that the images should have shape `(samples, channels, height, width)`.\n+        data_format: Image data format,\n+            either \"channels_first\" or \"channels_last\".\n+            \"channels_last\" mode means that the images should have shape\n+            `(samples, height, width, channels)`,\n+            \"channels_first\" mode means that the images should have shape\n+            `(samples, channels, height, width)`.\n             It defaults to the `image_data_format` value found in your\n             Keras config file at `~/.keras/keras.json`.\n             If you never set it, then it will be \"channels_last\".\n-        validation_split: Float. Fraction of images reserved for validation (strictly between 0 and 1).\n+        validation_split: Float. Fraction of images reserved for validation\n+            (strictly between 0 and 1).\n \n     # Examples\n     Example of using `.flow(x, y)`:\n@@ -633,9 +653,11 @@ class ImageDataGenerator(object):\n         self.preprocessing_function = preprocessing_function\n \n         if data_format not in {'channels_last', 'channels_first'}:\n-            raise ValueError('`data_format` should be `\"channels_last\"` (channel after row and '\n-                             'column) or `\"channels_first\"` (channel before row and column). '\n-                             'Received arg: ', data_format)\n+            raise ValueError(\n+                '`data_format` should be `\"channels_last\"` '\n+                '(channel after row and column) or '\n+                '`\"channels_first\"` (channel before row and column). '\n+                'Received: %s' % data_format)\n         self.data_format = data_format\n         if data_format == 'channels_first':\n             self.channel_axis = 1\n@@ -646,8 +668,9 @@ class ImageDataGenerator(object):\n             self.row_axis = 1\n             self.col_axis = 2\n         if validation_split and not 0 < validation_split < 1:\n-            raise ValueError('`validation_split` must be strictly between 0 and 1. '\n-                             ' Received arg: ', validation_split)\n+            raise ValueError(\n+                '`validation_split` must be strictly between 0 and 1. '\n+                ' Received: %s' % validation_split)\n         self._validation_split = validation_split\n \n         self.mean = None\n@@ -661,7 +684,7 @@ class ImageDataGenerator(object):\n         else:\n             raise ValueError('`zoom_range` should be a float or '\n                              'a tuple or list of two floats. '\n-                             'Received arg: ', zoom_range)\n+                             'Received: %s' % zoom_range)\n         if zca_whitening:\n             if not featurewise_center:\n                 self.featurewise_center = True\n@@ -691,37 +714,45 @@ class ImageDataGenerator(object):\n \n     def flow(self, x, y=None, batch_size=32, shuffle=True, seed=None,\n              save_to_dir=None, save_prefix='', save_format='png', subset=None):\n-        \"\"\"Takes numpy data & label arrays, and generates batches of\n-            augmented/normalized data.\n+        \"\"\"Takes numpy data & label arrays, and generates batches of augmented data.\n \n         # Arguments\n-               x: data. Numpy array of rank 4 or a tuple. If tuple, the first element\n-                should contain the images and the second element another numpy array\n-                or a list of numpy arrays of miscellaneous data that gets passed to the output\n-                without any modifications. Can be used to feed the model miscellaneous data\n+            x: Input data. Numpy array of rank 4 or a tuple.\n+                If tuple, the first element\n+                should contain the images and the second element\n+                another numpy array or a list of numpy arrays\n+                that gets passed to the output\n+                without any modifications.\n+                Can be used to feed the model miscellaneous data\n                 along with the images.\n \n                 In case of grayscale data, the channels axis of the image array\n                 should have value 1, and in case\n                 of RGB data, it should have value 3.\n-               y: labels.\n-               batch_size: int (default: 32).\n-               shuffle: boolean (default: True).\n-               seed: int (default: None).\n+            y: Labels.\n+            batch_size: Int (default: 32).\n+            shuffle: Boolean (default: True).\n+            seed: Int (default: None).\n             save_to_dir: None or str (default: None).\n                 This allows you to optionally specify a directory\n                 to which to save the augmented pictures being generated\n                 (useful for visualizing what you are doing).\n-               save_prefix: str (default: `''`). Prefix to use for filenames of saved pictures\n+            save_prefix: Str (default: `''`).\n+                Prefix to use for filenames of saved pictures\n                 (only relevant if `save_to_dir` is set).\n-                save_format: one of \"png\", \"jpeg\" (only relevant if `save_to_dir` is set). Default: \"png\".\n+                save_format: one of \"png\", \"jpeg\"\n+                (only relevant if `save_to_dir` is set). Default: \"png\".\n             subset: Subset of data (`\"training\"` or `\"validation\"`) if\n                 `validation_split` is set in `ImageDataGenerator`.\n \n         # Returns\n-            An Iterator yielding tuples of `(x, y)` where `x` is a numpy array of image data\n-             (in the case of a single image input) or a list of numpy arrays (in the case with\n-             additional inputs) and `y` is a numpy array of corresponding labels.\"\"\"\n+            An `Iterator` yielding tuples of `(x, y)`\n+                where `x` is a numpy array of image data\n+                (in the case of a single image input) or a list\n+                of numpy arrays (in the case with\n+                additional inputs) and `y` is a numpy array\n+                of corresponding labels.\n+        \"\"\"\n         return NumpyArrayIterator(\n             x, y, self,\n             batch_size=batch_size,\n@@ -743,52 +774,78 @@ class ImageDataGenerator(object):\n                             follow_links=False,\n                             subset=None,\n                             interpolation='nearest'):\n-        \"\"\"Takes the path to a directory, and generates batches of augmented/normalized data.\n+        \"\"\"Takes the path to a directory & generates batches of augmented data.\n \n         # Arguments\n-                directory: path to the target directory.\n+            directory: Path to the target directory.\n                 It should contain one subdirectory per class.\n-                 Any PNG, JPG, BMP, PPM or TIF images inside each of the subdirectories directory tree will be included in the generator.\n-                See [this script](https://gist.github.com/fchollet/0830affa1f7f19fd47b06d4cf89ed44d) for more details.\n-                target_size: tuple of integers `(height, width)`, default: `(256, 256)`.\n+                Any PNG, JPG, BMP, PPM or TIF images\n+                inside each of the subdirectories directory tree\n+                will be included in the generator.\n+                See [this script](https://gist.github.com/fchollet/0830affa1f7f19fd47b06d4cf89ed44d)\n+                for more details.\n+            target_size: Tuple of integers `(height, width)`,\n+                default: `(256, 256)`.\n                 The dimensions to which all images found will be resized.\n-                color_mode: one of \"grayscale\", \"rbg\". Default: \"rgb\".\n-                 Whether the images will be converted to have 1 or 3 color channels.\n-                classes: optional list of class subdirectories (e.g. `['dogs', 'cats']`). Default: None.\n+            color_mode: One of \"grayscale\", \"rbg\". Default: \"rgb\".\n+                Whether the images will be converted to\n+                have 1 or 3 color channels.\n+            classes: Optional list of class subdirectories\n+                (e.g. `['dogs', 'cats']`). Default: None.\n                 If not provided, the list of classes will be automatically\n-                 inferred from the subdirectory names/structure under `directory`,\n-                 where each subdirectory will be treated as a different class\n-                 (and the order of the classes, which will map to the label indices, will be alphanumeric).\n+                inferred from the subdirectory names/structure\n+                under `directory`, where each subdirectory will\n+                be treated as a different class\n+                (and the order of the classes, which will map to the label\n+                indices, will be alphanumeric).\n                 The dictionary containing the mapping from class names to class\n                 indices can be obtained via the attribute `class_indices`.\n-                class_mode: one of \"categorical\", \"binary\", \"sparse\", \"input\" or None. Default: \"categorical\".\n-                 Determines the type of label arrays that are returned: \"categorical\" will be 2D one-hot encoded labels,\n-                 \"binary\" will be 1D binary labels, \"sparse\" will be 1D integer labels, \"input\" will be images identical\n+            class_mode: One of \"categorical\", \"binary\", \"sparse\",\n+                \"input\", or None. Default: \"categorical\".\n+                Determines the type of label arrays that are returned:\n+                - \"categorical\" will be 2D one-hot encoded labels,\n+                - \"binary\" will be 1D binary labels,\n+                    \"sparse\" will be 1D integer labels,\n+                - \"input\" will be images identical\n                     to input images (mainly used to work with autoencoders).\n-                 If None, no labels are returned (the generator will only yield batches of image data, which is useful to use\n-                 `model.predict_generator()`, `model.evaluate_generator()`, etc.).\n+                If None, no labels are returned\n+                (the generator will only yield batches of image data,\n+                which is useful to use with `model.predict_generator()`,\n+                `model.evaluate_generator()`, etc.).\n                 Please note that in case of class_mode None,\n-                   the data still needs to reside in a subdirectory of `directory` for it to work correctly.\n-                batch_size: size of the batches of data (default: 32).\n-                shuffle: whether to shuffle the data (default: True)\n-                seed: optional random seed for shuffling and transformations.\n-                save_to_dir: None or str (default: None). This allows you to optionally specify a directory to which to save\n-                 the augmented pictures being generated (useful for visualizing what you are doing).\n-                save_prefix: str. Prefix to use for filenames of saved pictures (only relevant if `save_to_dir` is set).\n-                save_format: one of \"png\", \"jpeg\" (only relevant if `save_to_dir` is set). Default: \"png\".\n-                follow_links: whether to follow symlinks inside class subdirectories (default: False).\n+                the data still needs to reside in a subdirectory\n+                of `directory` for it to work correctly.\n+            batch_size: Size of the batches of data (default: 32).\n+            shuffle: Whether to shuffle the data (default: True)\n+            seed: Optional random seed for shuffling and transformations.\n+            save_to_dir: None or str (default: None).\n+                This allows you to optionally specify\n+                a directory to which to save\n+                the augmented pictures being generated\n+                (useful for visualizing what you are doing).\n+            save_prefix: Str. Prefix to use for filenames of saved pictures\n+                (only relevant if `save_to_dir` is set).\n+            save_format: One of \"png\", \"jpeg\"\n+                (only relevant if `save_to_dir` is set). Default: \"png\".\n+            follow_links: Whether to follow symlinks inside\n+                class subdirectories (default: False).\n             subset: Subset of data (`\"training\"` or `\"validation\"`) if\n                 `validation_split` is set in `ImageDataGenerator`.\n-                interpolation: Interpolation method used to resample the image if the\n+            interpolation: Interpolation method used to\n+                resample the image if the\n                 target size is different from that of the loaded image.\n-                 Supported methods are `\"nearest\"`, `\"bilinear\"`, and `\"bicubic\"`.\n+                Supported methods are `\"nearest\"`, `\"bilinear\"`,\n+                and `\"bicubic\"`.\n                 If PIL version 1.1.3 or newer is installed, `\"lanczos\"` is also\n-                 supported. If PIL version 3.4.0 or newer is installed, `\"box\"` and\n-                 `\"hamming\"` are also supported. By default, `\"nearest\"` is used.\n+                supported. If PIL version 3.4.0 or newer is installed,\n+                `\"box\"` and `\"hamming\"` are also supported.\n+                By default, `\"nearest\"` is used.\n \n         # Returns\n-            A DirectoryIterator yielding tuples of `(x, y)` where `x` is a numpy array containing a batch\n-            of images with shape `(batch_size, *target_size, channels)` and `y` is a numpy array of corresponding labels.\n+            A `DirectoryIterator` yielding tuples of `(x, y)`\n+                where `x` is a numpy array containing a batch\n+                of images with shape `(batch_size, *target_size, channels)`\n+                and `y` is a numpy array of corresponding labels.\n         \"\"\"\n         return DirectoryIterator(\n             directory, self,\n@@ -804,10 +861,10 @@ class ImageDataGenerator(object):\n             interpolation=interpolation)\n \n     def standardize(self, x):\n-        \"\"\"Apply the normalization configuration to a batch of inputs.\n+        \"\"\"Applies the normalization configuration to a batch of inputs.\n \n         # Arguments\n-            x: batch of inputs to be normalized.\n+            x: Batch of inputs to be normalized.\n \n         # Returns\n             The inputs, normalized.\n@@ -834,7 +891,8 @@ class ImageDataGenerator(object):\n                 x /= (self.std + K.epsilon())\n             else:\n                 warnings.warn('This ImageDataGenerator specifies '\n-                              '`featurewise_std_normalization`, but it hasn\\'t '\n+                              '`featurewise_std_normalization`, '\n+                              'but it hasn\\'t '\n                               'been fit on any training data. Fit it '\n                               'first by calling `.fit(numpy_data)`.')\n         if self.zca_whitening:\n@@ -850,11 +908,11 @@ class ImageDataGenerator(object):\n         return x\n \n     def random_transform(self, x, seed=None):\n-        \"\"\"Randomly augment a single image tensor.\n+        \"\"\"Randomly augments a single image tensor.\n \n         # Arguments\n             x: 3D tensor, single image.\n-            seed: random seed.\n+            seed: Random seed.\n \n         # Returns\n             A randomly transformed version of the input (same shape).\n@@ -867,10 +925,12 @@ class ImageDataGenerator(object):\n         if seed is not None:\n             np.random.seed(seed)\n \n-        # use composition of homographies\n+        # Use composition of homographies\n         # to generate final transform that needs to be applied\n         if self.rotation_range:\n-            theta = np.deg2rad(np.random.uniform(-self.rotation_range, self.rotation_range))\n+            theta = np.deg2rad(np.random.uniform(\n+                -self.rotation_range,\n+                self.rotation_range))\n         else:\n             theta = 0\n \n@@ -899,15 +959,19 @@ class ImageDataGenerator(object):\n             ty = 0\n \n         if self.shear_range:\n-            shear = np.deg2rad(np.random.uniform(-self.shear_range, self.shear_range))\n+            shear = np.deg2rad(np.random.uniform(\n+                -self.shear_range,\n+                self.shear_range))\n         else:\n             shear = 0\n \n         if self.zoom_range[0] == 1 and self.zoom_range[1] == 1:\n             zx, zy = 1, 1\n         else:\n-            zx, zy = np.random.uniform(self.zoom_range[0], self.zoom_range[1], 2)\n-\n+            zx, zy = np.random.uniform(\n+                self.zoom_range[0],\n+                self.zoom_range[1],\n+                2)\n         transform_matrix = None\n         if theta != 0:\n             rotation_matrix = np.array([[np.cos(theta), -np.sin(theta), 0],\n@@ -935,7 +999,8 @@ class ImageDataGenerator(object):\n \n         if transform_matrix is not None:\n             h, w = x.shape[img_row_axis], x.shape[img_col_axis]\n-            transform_matrix = transform_matrix_offset_center(transform_matrix, h, w)\n+            transform_matrix = transform_matrix_offset_center(\n+                transform_matrix, h, w)\n             x = apply_transform(x, transform_matrix, img_channel_axis,\n                                 fill_mode=self.fill_mode, cval=self.cval)\n \n@@ -960,17 +1025,22 @@ class ImageDataGenerator(object):\n             augment=False,\n             rounds=1,\n             seed=None):\n-        \"\"\"Compute the internal data stats related to the data-dependent transformations, based on an array of sample data.\n-        Only required if featurewise_center or featurewise_std_normalization or zca_whitening.\n+        \"\"\"Computes the internal data stats related to the data-dependent transformations, based on an array of sample data.\n+\n+        Only required if `featurewise_center` or\n+        `featurewise_std_normalization` or `zca_whitening` are set to True.\n \n         # Arguments\n-            x: sample data. Should have rank 4.\n+            x: Sample data. Should have rank 4.\n              In case of grayscale data,\n              the channels axis should have value 1, and in case\n              of RGB data, it should have value 3.\n-            augment: Boolean (default: False). Whether to fit on randomly augmented samples.\n-            rounds: int (default: 1). If augment, how many augmentation passes over the data to use.\n-            seed: int (default: None). Random seed.\n+            augment: Boolean (default: False).\n+                Whether to fit on randomly augmented samples.\n+            rounds: Int (default: 1).\n+                If using data augmentation (`augment=True`),\n+                this is how many augmentation passes over the data to use.\n+            seed: Int (default: None). Random seed.\n        \"\"\"\n         x = np.asarray(x, dtype=K.floatx())\n         if x.ndim != 4:\n@@ -979,18 +1049,23 @@ class ImageDataGenerator(object):\n         if x.shape[self.channel_axis] not in {1, 3, 4}:\n             warnings.warn(\n                 'Expected input to be images (as Numpy array) '\n-                'following the data format convention \"' + self.data_format + '\" '\n-                '(channels on axis ' + str(self.channel_axis) + '), i.e. expected '\n-                'either 1, 3 or 4 channels on axis ' + str(self.channel_axis) + '. '\n-                'However, it was passed an array with shape ' + str(x.shape) +\n-                ' (' + str(x.shape[self.channel_axis]) + ' channels).')\n+                'following the data format convention \"' +\n+                self.data_format + '\" (channels on axis ' +\n+                str(self.channel_axis) + '), i.e. expected '\n+                'either 1, 3 or 4 channels on axis ' +\n+                str(self.channel_axis) + '. '\n+                'However, it was passed an array with shape ' +\n+                str(x.shape) + ' (' + str(x.shape[self.channel_axis]) +\n+                ' channels).')\n \n         if seed is not None:\n             np.random.seed(seed)\n \n         x = np.copy(x)\n         if augment:\n-            ax = np.zeros(tuple([rounds * x.shape[0]] + list(x.shape)[1:]), dtype=K.floatx())\n+            ax = np.zeros(\n+                tuple([rounds * x.shape[0]] + list(x.shape)[1:]),\n+                dtype=K.floatx())\n             for r in range(rounds):\n                 for i in range(x.shape[0]):\n                     ax[i + r * x.shape[0]] = self.random_transform(x[i])\n@@ -1011,7 +1086,8 @@ class ImageDataGenerator(object):\n             x /= (self.std + K.epsilon())\n \n         if self.zca_whitening:\n-            flat_x = np.reshape(x, (x.shape[0], x.shape[1] * x.shape[2] * x.shape[3]))\n+            flat_x = np.reshape(\n+                x, (x.shape[0], x.shape[1] * x.shape[2] * x.shape[3]))\n             sigma = np.dot(flat_x.T, flat_x) / flat_x.shape[0]\n             u, s, _ = linalg.svd(sigma)\n             s_inv = 1. / np.sqrt(s[np.newaxis] + self.zca_epsilon)\n@@ -1101,7 +1177,7 @@ class Iterator(Sequence):\n         \"\"\"Gets a batch of transformed samples.\n \n         # Arguments\n-            index_array: array of sample indices to include in batch.\n+            index_array: Array of sample indices to include in batch.\n \n         # Returns\n             A batch of transformed samples.\n@@ -1113,8 +1189,10 @@ class NumpyArrayIterator(Iterator):\n     \"\"\"Iterator yielding data from a Numpy array.\n \n     # Arguments\n-        x: Numpy array of input data or tuple. If tuple, the second elements is either\n-            another numpy array or a list of numpy arrays, each of which gets passed\n+        x: Numpy array of input data or tuple.\n+            If tuple, the second elements is either\n+            another numpy array or a list of numpy arrays,\n+            each of which gets passed\n             through as an output without any modifications.\n         y: Numpy array of targets data.\n         image_data_generator: Instance of `ImageDataGenerator`\n@@ -1148,7 +1226,9 @@ class NumpyArrayIterator(Iterator):\n             x = x[0]\n             for xx in x_misc:\n                 if len(x) != len(xx):\n-                    raise ValueError('All of the arrays in `x` should have the same length. '\n+                    raise ValueError(\n+                        'All of the arrays in `x` '\n+                        'should have the same length. '\n                         'Found a pair with: len(x[0]) = %s, len(x[?]) = %s' %\n                         (len(x), len(xx)))\n         else:\n@@ -1186,10 +1266,12 @@ class NumpyArrayIterator(Iterator):\n         if self.x.shape[channels_axis] not in {1, 3, 4}:\n             warnings.warn('NumpyArrayIterator is set to use the '\n                           'data format convention \"' + data_format + '\" '\n-                          '(channels on axis ' + str(channels_axis) + '), i.e. expected '\n-                          'either 1, 3 or 4 channels on axis ' + str(channels_axis) + '. '\n-                          'However, it was passed an array with shape ' + str(self.x.shape) +\n-                          ' (' + str(self.x.shape[channels_axis]) + ' channels).')\n+                          '(channels on axis ' + str(channels_axis) +\n+                          '), i.e. expected either 1, 3 or 4 '\n+                          'channels on axis ' + str(channels_axis) + '. '\n+                          'However, it was passed an array with shape ' +\n+                          str(self.x.shape) + ' (' +\n+                          str(self.x.shape[channels_axis]) + ' channels).')\n         if y is not None:\n             self.y = np.asarray(y)\n         else:\n@@ -1199,27 +1281,33 @@ class NumpyArrayIterator(Iterator):\n         self.save_to_dir = save_to_dir\n         self.save_prefix = save_prefix\n         self.save_format = save_format\n-        super(NumpyArrayIterator, self).__init__(x.shape[0], batch_size, shuffle, seed)\n+        super(NumpyArrayIterator, self).__init__(x.shape[0],\n+                                                 batch_size,\n+                                                 shuffle,\n+                                                 seed)\n \n     def _get_batches_of_transformed_samples(self, index_array):\n         batch_x = np.zeros(tuple([len(index_array)] + list(self.x.shape)[1:]),\n                            dtype=K.floatx())\n         for i, j in enumerate(index_array):\n             x = self.x[j]\n-            x = self.image_data_generator.random_transform(x.astype(K.floatx()))\n+            x = self.image_data_generator.random_transform(\n+                x.astype(K.floatx()))\n             x = self.image_data_generator.standardize(x)\n             batch_x[i] = x\n \n         if self.save_to_dir:\n             for i, j in enumerate(index_array):\n                 img = array_to_img(batch_x[i], self.data_format, scale=True)\n-                fname = '{prefix}_{index}_{hash}.{format}'.format(prefix=self.save_prefix,\n+                fname = '{prefix}_{index}_{hash}.{format}'.format(\n+                    prefix=self.save_prefix,\n                     index=j,\n                     hash=np.random.randint(1e4),\n                     format=self.save_format)\n                 img.save(os.path.join(self.save_to_dir, fname))\n         batch_x_miscs = [xx[index_array] for xx in self.x_misc]\n-        output = (batch_x if batch_x_miscs == [] else [batch_x] + batch_x_miscs,)\n+        output = (batch_x if batch_x_miscs == []\n+                  else [batch_x] + batch_x_miscs,)\n         if self.y is None:\n             return output[0]\n         output += (self.y[index_array],)\n@@ -1241,33 +1329,38 @@ class NumpyArrayIterator(Iterator):\n \n \n def _iter_valid_files(directory, white_list_formats, follow_links):\n-    \"\"\"Count files with extension in `white_list_formats` contained in directory.\n+    \"\"\"Iterates on files with extension in `white_list_formats` contained in `directory`.\n \n     # Arguments\n-        directory: absolute path to the directory\n+        directory: Absolute path to the directory\n             containing files to be counted\n-        white_list_formats: set of strings containing allowed extensions for\n+        white_list_formats: Set of strings containing allowed extensions for\n             the files to be counted.\n-        follow_links: boolean.\n+        follow_links: Boolean.\n \n     # Yields\n-        tuple of (root, filename) with extension in `white_list_formats`.\n+        Tuple of (root, filename) with extension in `white_list_formats`.\n     \"\"\"\n     def _recursive_list(subpath):\n-        return sorted(os.walk(subpath, followlinks=follow_links), key=lambda x: x[0])\n+        return sorted(os.walk(subpath, followlinks=follow_links),\n+                      key=lambda x: x[0])\n \n     for root, _, files in _recursive_list(directory):\n         for fname in sorted(files):\n             for extension in white_list_formats:\n                 if fname.lower().endswith('.tiff'):\n-                    warnings.warn('Using \\'.tiff\\' files with multiple bands will cause distortion. '\n+                    warnings.warn('Using \\'.tiff\\' files with multiple bands '\n+                                  'will cause distortion. '\n                                   'Please verify your output.')\n                 if fname.lower().endswith('.' + extension):\n                     yield root, fname\n \n \n-def _count_valid_files_in_directory(directory, white_list_formats, split, follow_links):\n-    \"\"\"Count files with extension in `white_list_formats` contained in directory.\n+def _count_valid_files_in_directory(directory,\n+                                    white_list_formats,\n+                                    split,\n+                                    follow_links):\n+    \"\"\"Counts files with extension in `white_list_formats` contained in `directory`.\n \n     # Arguments\n         directory: absolute path to the directory\n@@ -1284,7 +1377,8 @@ def _count_valid_files_in_directory(directory, white_list_formats, split, follow\n         the count of files with extension in `white_list_formats` contained in\n         the directory.\n     \"\"\"\n-    num_files = len(list(_iter_valid_files(directory, white_list_formats, follow_links)))\n+    num_files = len(list(\n+        _iter_valid_files(directory, white_list_formats, follow_links)))\n     if split:\n         start, stop = int(split[0] * num_files), int(split[1] * num_files)\n     else:\n@@ -1294,11 +1388,12 @@ def _count_valid_files_in_directory(directory, white_list_formats, split, follow\n \n def _list_valid_filenames_in_directory(directory, white_list_formats, split,\n                                        class_indices, follow_links):\n-    \"\"\"List paths of files in `subdir` with extensions in `white_list_formats`.\n+    \"\"\"Lists paths of files in `subdir` with extensions in `white_list_formats`.\n \n     # Arguments\n         directory: absolute path to a directory containing the files to list.\n-            The directory name is used as class label and must be a key of `class_indices`.\n+            The directory name is used as class label\n+            and must be a key of `class_indices`.\n         white_list_formats: set of strings containing allowed extensions for\n             the files to be counted.\n         split: tuple of floats (e.g. `(0.2, 0.6)`) to only take into\n@@ -1312,22 +1407,28 @@ def _list_valid_filenames_in_directory(directory, white_list_formats, split,\n         classes: a list of class indices\n         filenames: the path of valid files in `directory`, relative from\n             `directory`'s parent (e.g., if `directory` is \"dataset/class1\",\n-            the filenames will be [\"class1/file1.jpg\", \"class1/file2.jpg\", ...]).\n+            the filenames will be\n+            `[\"class1/file1.jpg\", \"class1/file2.jpg\", ...]`).\n     \"\"\"\n     dirname = os.path.basename(directory)\n     if split:\n-        num_files = len(list(_iter_valid_files(directory, white_list_formats, follow_links)))\n+        num_files = len(list(\n+            _iter_valid_files(directory, white_list_formats, follow_links)))\n         start, stop = int(split[0] * num_files), int(split[1] * num_files)\n-        valid_files = list(_iter_valid_files(directory, white_list_formats, follow_links))[start: stop]\n+        valid_files = list(\n+            _iter_valid_files(\n+                directory, white_list_formats, follow_links))[start: stop]\n     else:\n-        valid_files = _iter_valid_files(directory, white_list_formats, follow_links)\n+        valid_files = _iter_valid_files(\n+            directory, white_list_formats, follow_links)\n \n     classes = []\n     filenames = []\n     for root, fname in valid_files:\n         classes.append(class_indices[dirname])\n         absolute_path = os.path.join(root, fname)\n-        relative_path = os.path.join(dirname, os.path.relpath(absolute_path, directory))\n+        relative_path = os.path.join(\n+            dirname, os.path.relpath(absolute_path, directory))\n         filenames.append(relative_path)\n \n     return classes, filenames\n@@ -1433,9 +1534,9 @@ class DirectoryIterator(Iterator):\n             split = None\n         self.subset = subset\n \n-        white_list_formats = {'png', 'jpg', 'jpeg', 'bmp', 'ppm', 'tif', 'tiff'}\n-\n-        # first, count the number of samples and classes\n+        white_list_formats = {'png', 'jpg', 'jpeg', 'bmp',\n+                              'ppm', 'tif', 'tiff'}\n+        # First, count the number of samples and classes.\n         self.samples = 0\n \n         if not classes:\n@@ -1455,16 +1556,18 @@ class DirectoryIterator(Iterator):\n                                     (os.path.join(directory, subdir)\n                                      for subdir in classes)))\n \n-        print('Found %d images belonging to %d classes.' % (self.samples, self.num_classes))\n+        print('Found %d images belonging to %d classes.' %\n+              (self.samples, self.num_classes))\n \n-        # second, build an index of the images in the different class subfolders\n+        # Second, build an index of the images\n+        # in the different class subfolders.\n         results = []\n-\n         self.filenames = []\n         self.classes = np.zeros((self.samples,), dtype='int32')\n         i = 0\n         for dirpath in (os.path.join(directory, subdir) for subdir in classes):\n-            results.append(pool.apply_async(_list_valid_filenames_in_directory,\n+            results.append(\n+                pool.apply_async(_list_valid_filenames_in_directory,\n                                  (dirpath, white_list_formats, split,\n                                   self.class_indices, follow_links)))\n         for res in results:\n@@ -1475,10 +1578,15 @@ class DirectoryIterator(Iterator):\n \n         pool.close()\n         pool.join()\n-        super(DirectoryIterator, self).__init__(self.samples, batch_size, shuffle, seed)\n+        super(DirectoryIterator, self).__init__(self.samples,\n+                                                batch_size,\n+                                                shuffle,\n+                                                seed)\n \n     def _get_batches_of_transformed_samples(self, index_array):\n-        batch_x = np.zeros((len(index_array),) + self.image_shape, dtype=K.floatx())\n+        batch_x = np.zeros(\n+            (len(index_array),) + self.image_shape,\n+            dtype=K.floatx())\n         grayscale = self.color_mode == 'grayscale'\n         # build batch of image data\n         for i, j in enumerate(index_array):\n@@ -1495,7 +1603,8 @@ class DirectoryIterator(Iterator):\n         if self.save_to_dir:\n             for i, j in enumerate(index_array):\n                 img = array_to_img(batch_x[i], self.data_format, scale=True)\n-                fname = '{prefix}_{index}_{hash}.{format}'.format(prefix=self.save_prefix,\n+                fname = '{prefix}_{index}_{hash}.{format}'.format(\n+                    prefix=self.save_prefix,\n                     index=j,\n                     hash=np.random.randint(1e7),\n                     format=self.save_format)\n@@ -1508,7 +1617,9 @@ class DirectoryIterator(Iterator):\n         elif self.class_mode == 'binary':\n             batch_y = self.classes[index_array].astype(K.floatx())\n         elif self.class_mode == 'categorical':\n-            batch_y = np.zeros((len(batch_x), self.num_classes), dtype=K.floatx())\n+            batch_y = np.zeros(\n+                (len(batch_x), self.num_classes),\n+                dtype=K.floatx())\n             for i, label in enumerate(self.classes[index_array]):\n                 batch_y[i, label] = 1.\n         else:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
