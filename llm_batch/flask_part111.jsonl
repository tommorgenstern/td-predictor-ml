{"custom_id": "flask#44ffe6c6d6c90a414de32db1b03d5978f8770271", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 276 | Lines Deleted: 262 | Files Changed: 18 | Hunks: 201 | Methods Changed: 211 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 538 | Churn Cumulative: 13790 | Contributors (this commit): 75 | Commits (past 90d): 46 | Contributors (cumulative): 149 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import functools\n import inspect\n import logging\n@@ -95,7 +97,7 @@ else:\n         return inspect.iscoroutinefunction(func)\n \n \n-def _make_timedelta(value: t.Union[timedelta, int, None]) -> t.Optional[timedelta]:\n+def _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n     if value is None or isinstance(value, timedelta):\n         return value\n \n@@ -280,7 +282,7 @@ class Flask(Scaffold):\n         \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n     )\n \n-    json_provider_class: t.Type[JSONProvider] = DefaultJSONProvider\n+    json_provider_class: type[JSONProvider] = DefaultJSONProvider\n     \"\"\"A subclass of :class:`~flask.json.provider.JSONProvider`. An\n     instance is created and assigned to :attr:`app.json` when creating\n     the app.\n@@ -348,7 +350,7 @@ class Flask(Scaffold):\n     #: client class. Defaults to :class:`~flask.testing.FlaskClient`.\n     #:\n     #: .. versionadded:: 0.7\n-    test_client_class: t.Optional[t.Type[\"FlaskClient\"]] = None\n+    test_client_class: type[FlaskClient] | None = None\n \n     #: The :class:`~click.testing.CliRunner` subclass, by default\n     #: :class:`~flask.testing.FlaskCliRunner` that is used by\n@@ -356,7 +358,7 @@ class Flask(Scaffold):\n     #: Flask app object as the first argument.\n     #:\n     #: .. versionadded:: 1.0\n-    test_cli_runner_class: t.Optional[t.Type[\"FlaskCliRunner\"]] = None\n+    test_cli_runner_class: type[FlaskCliRunner] | None = None\n \n     #: the session interface to use.  By default an instance of\n     #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n@@ -367,15 +369,15 @@ class Flask(Scaffold):\n     def __init__(\n         self,\n         import_name: str,\n-        static_url_path: t.Optional[str] = None,\n-        static_folder: t.Optional[t.Union[str, os.PathLike]] = \"static\",\n-        static_host: t.Optional[str] = None,\n+        static_url_path: str | None = None,\n+        static_folder: str | os.PathLike | None = \"static\",\n+        static_host: str | None = None,\n         host_matching: bool = False,\n         subdomain_matching: bool = False,\n-        template_folder: t.Optional[t.Union[str, os.PathLike]] = \"templates\",\n-        instance_path: t.Optional[str] = None,\n+        template_folder: str | os.PathLike | None = \"templates\",\n+        instance_path: str | None = None,\n         instance_relative_config: bool = False,\n-        root_path: t.Optional[str] = None,\n+        root_path: str | None = None,\n     ):\n         super().__init__(\n             import_name=import_name,\n@@ -435,8 +437,8 @@ class Flask(Scaffold):\n         #: Otherwise, its return value is returned by ``url_for``.\n         #:\n         #: .. versionadded:: 0.9\n-        self.url_build_error_handlers: t.List[\n-            t.Callable[[Exception, str, t.Dict[str, t.Any]], str]\n+        self.url_build_error_handlers: list[\n+            t.Callable[[Exception, str, dict[str, t.Any]], str]\n         ] = []\n \n         #: A list of functions that are called when the application context\n@@ -445,13 +447,13 @@ class Flask(Scaffold):\n         #: from databases.\n         #:\n         #: .. versionadded:: 0.9\n-        self.teardown_appcontext_funcs: t.List[ft.TeardownCallable] = []\n+        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []\n \n         #: A list of shell context processor functions that should be run\n         #: when a shell context is created.\n         #:\n         #: .. versionadded:: 0.11\n-        self.shell_context_processors: t.List[ft.ShellContextProcessorCallable] = []\n+        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []\n \n         #: Maps registered blueprint names to blueprint objects. The\n         #: dict retains the order the blueprints were registered in.\n@@ -459,7 +461,7 @@ class Flask(Scaffold):\n         #: not track how often they were attached.\n         #:\n         #: .. versionadded:: 0.7\n-        self.blueprints: t.Dict[str, \"Blueprint\"] = {}\n+        self.blueprints: dict[str, Blueprint] = {}\n \n         #: a place where extensions can store application specific state.  For\n         #: example this is where an extension could store database engines and\n@@ -734,7 +736,7 @@ class Flask(Scaffold):\n         :param context: the context as a dictionary that is updated in place\n                         to add extra variables.\n         \"\"\"\n-        names: t.Iterable[t.Optional[str]] = (None,)\n+        names: t.Iterable[str | None] = (None,)\n \n         # A template may be rendered outside a request context.\n         if request:\n@@ -785,9 +787,9 @@ class Flask(Scaffold):\n \n     def run(\n         self,\n-        host: t.Optional[str] = None,\n-        port: t.Optional[int] = None,\n-        debug: t.Optional[bool] = None,\n+        host: str | None = None,\n+        port: int | None = None,\n+        debug: bool | None = None,\n         load_dotenv: bool = True,\n         **options: t.Any,\n     ) -> None:\n@@ -906,7 +908,7 @@ class Flask(Scaffold):\n             # without reloader and that stuff from an interactive shell.\n             self._got_first_request = False\n \n-    def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> \"FlaskClient\":\n+    def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> FlaskClient:\n         \"\"\"Creates a test client for this application.  For information\n         about unit testing head over to :doc:`/testing`.\n \n@@ -964,7 +966,7 @@ class Flask(Scaffold):\n             self, self.response_class, use_cookies=use_cookies, **kwargs\n         )\n \n-    def test_cli_runner(self, **kwargs: t.Any) -> \"FlaskCliRunner\":\n+    def test_cli_runner(self, **kwargs: t.Any) -> FlaskCliRunner:\n         \"\"\"Create a CLI runner for testing CLI commands.\n         See :ref:`testing-cli`.\n \n@@ -982,7 +984,7 @@ class Flask(Scaffold):\n         return cls(self, **kwargs)  # type: ignore\n \n     @setupmethod\n-    def register_blueprint(self, blueprint: \"Blueprint\", **options: t.Any) -> None:\n+    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:\n         \"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n         arguments passed to this method will override the defaults set on the\n         blueprint.\n@@ -1009,7 +1011,7 @@ class Flask(Scaffold):\n         \"\"\"\n         blueprint.register(self, options)\n \n-    def iter_blueprints(self) -> t.ValuesView[\"Blueprint\"]:\n+    def iter_blueprints(self) -> t.ValuesView[Blueprint]:\n         \"\"\"Iterates over all blueprints by the order they were registered.\n \n         .. versionadded:: 0.11\n@@ -1020,9 +1022,9 @@ class Flask(Scaffold):\n     def add_url_rule(\n         self,\n         rule: str,\n-        endpoint: t.Optional[str] = None,\n-        view_func: t.Optional[ft.RouteCallable] = None,\n-        provide_automatic_options: t.Optional[bool] = None,\n+        endpoint: str | None = None,\n+        view_func: ft.RouteCallable | None = None,\n+        provide_automatic_options: bool | None = None,\n         **options: t.Any,\n     ) -> None:\n         if endpoint is None:\n@@ -1077,7 +1079,7 @@ class Flask(Scaffold):\n \n     @setupmethod\n     def template_filter(\n-        self, name: t.Optional[str] = None\n+        self, name: str | None = None\n     ) -> t.Callable[[T_template_filter], T_template_filter]:\n         \"\"\"A decorator that is used to register custom template filter.\n         You can specify a name for the filter, otherwise the function\n@@ -1099,7 +1101,7 @@ class Flask(Scaffold):\n \n     @setupmethod\n     def add_template_filter(\n-        self, f: ft.TemplateFilterCallable, name: t.Optional[str] = None\n+        self, f: ft.TemplateFilterCallable, name: str | None = None\n     ) -> None:\n         \"\"\"Register a custom template filter.  Works exactly like the\n         :meth:`template_filter` decorator.\n@@ -1111,7 +1113,7 @@ class Flask(Scaffold):\n \n     @setupmethod\n     def template_test(\n-        self, name: t.Optional[str] = None\n+        self, name: str | None = None\n     ) -> t.Callable[[T_template_test], T_template_test]:\n         \"\"\"A decorator that is used to register custom template test.\n         You can specify a name for the test, otherwise the function\n@@ -1140,7 +1142,7 @@ class Flask(Scaffold):\n \n     @setupmethod\n     def add_template_test(\n-        self, f: ft.TemplateTestCallable, name: t.Optional[str] = None\n+        self, f: ft.TemplateTestCallable, name: str | None = None\n     ) -> None:\n         \"\"\"Register a custom template test.  Works exactly like the\n         :meth:`template_test` decorator.\n@@ -1154,7 +1156,7 @@ class Flask(Scaffold):\n \n     @setupmethod\n     def template_global(\n-        self, name: t.Optional[str] = None\n+        self, name: str | None = None\n     ) -> t.Callable[[T_template_global], T_template_global]:\n         \"\"\"A decorator that is used to register a custom template global function.\n         You can specify a name for the global function, otherwise the function\n@@ -1178,7 +1180,7 @@ class Flask(Scaffold):\n \n     @setupmethod\n     def add_template_global(\n-        self, f: ft.TemplateGlobalCallable, name: t.Optional[str] = None\n+        self, f: ft.TemplateGlobalCallable, name: str | None = None\n     ) -> None:\n         \"\"\"Register a custom template global function. Works exactly like the\n         :meth:`template_global` decorator.\n@@ -1235,7 +1237,7 @@ class Flask(Scaffold):\n         self.shell_context_processors.append(f)\n         return f\n \n-    def _find_error_handler(self, e: Exception) -> t.Optional[ft.ErrorHandlerCallable]:\n+    def _find_error_handler(self, e: Exception) -> ft.ErrorHandlerCallable | None:\n         \"\"\"Return a registered error handler for an exception in this order:\n         blueprint handler for a specific code, app handler for a specific code,\n         blueprint handler for an exception class, app handler for an exception\n@@ -1260,7 +1262,7 @@ class Flask(Scaffold):\n \n     def handle_http_exception(\n         self, e: HTTPException\n-    ) -> t.Union[HTTPException, ft.ResponseReturnValue]:\n+    ) -> HTTPException | ft.ResponseReturnValue:\n         \"\"\"Handles an HTTP exception.  By default this will invoke the\n         registered error handlers and fall back to returning the\n         exception as response.\n@@ -1330,7 +1332,7 @@ class Flask(Scaffold):\n \n     def handle_user_exception(\n         self, e: Exception\n-    ) -> t.Union[HTTPException, ft.ResponseReturnValue]:\n+    ) -> HTTPException | ft.ResponseReturnValue:\n         \"\"\"This method is called whenever an exception occurs that\n         should be handled. A special case is :class:`~werkzeug\n         .exceptions.HTTPException` which is forwarded to the\n@@ -1404,7 +1406,7 @@ class Flask(Scaffold):\n             raise e\n \n         self.log_exception(exc_info)\n-        server_error: t.Union[InternalServerError, ft.ResponseReturnValue]\n+        server_error: InternalServerError | ft.ResponseReturnValue\n         server_error = InternalServerError(original_exception=e)\n         handler = self._find_error_handler(server_error)\n \n@@ -1415,9 +1417,7 @@ class Flask(Scaffold):\n \n     def log_exception(\n         self,\n-        exc_info: t.Union[\n-            t.Tuple[type, BaseException, TracebackType], t.Tuple[None, None, None]\n-        ],\n+        exc_info: (tuple[type, BaseException, TracebackType] | tuple[None, None, None]),\n     ) -> None:\n         \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n         if debugging is disabled and right before the handler is called.\n@@ -1430,7 +1430,7 @@ class Flask(Scaffold):\n             f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n         )\n \n-    def raise_routing_exception(self, request: Request) -> \"te.NoReturn\":\n+    def raise_routing_exception(self, request: Request) -> te.NoReturn:\n         \"\"\"Intercept routing exceptions and possibly do something else.\n \n         In debug mode, intercept a routing redirect and replace it with\n@@ -1480,7 +1480,7 @@ class Flask(Scaffold):\n         ):\n             return self.make_default_options_response()\n         # otherwise dispatch to the handler for that endpoint\n-        view_args: t.Dict[str, t.Any] = req.view_args  # type: ignore[assignment]\n+        view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]\n         return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)\n \n     def full_dispatch_request(self) -> Response:\n@@ -1503,7 +1503,7 @@ class Flask(Scaffold):\n \n     def finalize_request(\n         self,\n-        rv: t.Union[ft.ResponseReturnValue, HTTPException],\n+        rv: ft.ResponseReturnValue | HTTPException,\n         from_error_handler: bool = False,\n     ) -> Response:\n         \"\"\"Given the return value from a view function this finalizes\n@@ -1545,7 +1545,7 @@ class Flask(Scaffold):\n         rv.allow.update(methods)\n         return rv\n \n-    def should_ignore_error(self, error: t.Optional[BaseException]) -> bool:\n+    def should_ignore_error(self, error: BaseException | None) -> bool:\n         \"\"\"This is called to figure out if an error should be ignored\n         or not as far as the teardown system is concerned.  If this\n         function returns ``True`` then the teardown handlers will not be\n@@ -1596,10 +1596,10 @@ class Flask(Scaffold):\n         self,\n         endpoint: str,\n         *,\n-        _anchor: t.Optional[str] = None,\n-        _method: t.Optional[str] = None,\n-        _scheme: t.Optional[str] = None,\n-        _external: t.Optional[bool] = None,\n+        _anchor: str | None = None,\n+        _method: str | None = None,\n+        _scheme: str | None = None,\n+        _external: bool | None = None,\n         **values: t.Any,\n     ) -> str:\n         \"\"\"Generate a URL to the given endpoint with the given values.\n@@ -1871,9 +1871,7 @@ class Flask(Scaffold):\n \n         return rv\n \n-    def create_url_adapter(\n-        self, request: t.Optional[Request]\n-    ) -> t.Optional[MapAdapter]:\n+    def create_url_adapter(self, request: Request | None) -> MapAdapter | None:\n         \"\"\"Creates a URL adapter for the given request. The URL adapter\n         is created at a point where the request context is not yet set\n         up so the request is passed explicitly.\n@@ -1920,7 +1918,7 @@ class Flask(Scaffold):\n \n         .. versionadded:: 0.7\n         \"\"\"\n-        names: t.Iterable[t.Optional[str]] = (None,)\n+        names: t.Iterable[str | None] = (None,)\n \n         # url_for may be called outside a request context, parse the\n         # passed endpoint instead of using request.blueprints.\n@@ -1935,7 +1933,7 @@ class Flask(Scaffold):\n                     func(endpoint, values)\n \n     def handle_url_build_error(\n-        self, error: BuildError, endpoint: str, values: t.Dict[str, t.Any]\n+        self, error: BuildError, endpoint: str, values: dict[str, t.Any]\n     ) -> str:\n         \"\"\"Called by :meth:`.url_for` if a\n         :exc:`~werkzeug.routing.BuildError` was raised. If this returns\n@@ -1968,7 +1966,7 @@ class Flask(Scaffold):\n \n         raise error\n \n-    def preprocess_request(self) -> t.Optional[ft.ResponseReturnValue]:\n+    def preprocess_request(self) -> ft.ResponseReturnValue | None:\n         \"\"\"Called before the request is dispatched. Calls\n         :attr:`url_value_preprocessors` registered with the app and the\n         current blueprint (if any). Then calls :attr:`before_request_funcs`\n@@ -2024,7 +2022,7 @@ class Flask(Scaffold):\n         return response\n \n     def do_teardown_request(\n-        self, exc: t.Optional[BaseException] = _sentinel  # type: ignore\n+        self, exc: BaseException | None = _sentinel  # type: ignore\n     ) -> None:\n         \"\"\"Called after the request is dispatched and the response is\n         returned, right before the request context is popped.\n@@ -2057,7 +2055,7 @@ class Flask(Scaffold):\n         request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\n \n     def do_teardown_appcontext(\n-        self, exc: t.Optional[BaseException] = _sentinel  # type: ignore\n+        self, exc: BaseException | None = _sentinel  # type: ignore\n     ) -> None:\n         \"\"\"Called right before the application context is popped.\n \n@@ -2200,7 +2198,7 @@ class Flask(Scaffold):\n             start the response.\n         \"\"\"\n         ctx = self.request_context(environ)\n-        error: t.Optional[BaseException] = None\n+        error: BaseException | None = None\n         try:\n             try:\n                 ctx.push()\n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import os\n import typing as t\n from collections import defaultdict\n@@ -38,8 +40,8 @@ class BlueprintSetupState:\n \n     def __init__(\n         self,\n-        blueprint: \"Blueprint\",\n-        app: \"Flask\",\n+        blueprint: Blueprint,\n+        app: Flask,\n         options: t.Any,\n         first_registration: bool,\n     ) -> None:\n@@ -85,8 +87,8 @@ class BlueprintSetupState:\n     def add_url_rule(\n         self,\n         rule: str,\n-        endpoint: t.Optional[str] = None,\n-        view_func: t.Optional[t.Callable] = None,\n+        endpoint: str | None = None,\n+        view_func: t.Callable | None = None,\n         **options: t.Any,\n     ) -> None:\n         \"\"\"A helper method to register a rule (and optionally a view function)\n@@ -173,14 +175,14 @@ class Blueprint(Scaffold):\n         self,\n         name: str,\n         import_name: str,\n-        static_folder: t.Optional[t.Union[str, os.PathLike]] = None,\n-        static_url_path: t.Optional[str] = None,\n-        template_folder: t.Optional[t.Union[str, os.PathLike]] = None,\n-        url_prefix: t.Optional[str] = None,\n-        subdomain: t.Optional[str] = None,\n-        url_defaults: t.Optional[dict] = None,\n-        root_path: t.Optional[str] = None,\n-        cli_group: t.Optional[str] = _sentinel,  # type: ignore\n+        static_folder: str | os.PathLike | None = None,\n+        static_url_path: str | None = None,\n+        template_folder: str | os.PathLike | None = None,\n+        url_prefix: str | None = None,\n+        subdomain: str | None = None,\n+        url_defaults: dict | None = None,\n+        root_path: str | None = None,\n+        cli_group: str | None = _sentinel,  # type: ignore\n     ):\n         super().__init__(\n             import_name=import_name,\n@@ -199,14 +201,14 @@ class Blueprint(Scaffold):\n         self.name = name\n         self.url_prefix = url_prefix\n         self.subdomain = subdomain\n-        self.deferred_functions: t.List[DeferredSetupFunction] = []\n+        self.deferred_functions: list[DeferredSetupFunction] = []\n \n         if url_defaults is None:\n             url_defaults = {}\n \n         self.url_values_defaults = url_defaults\n         self.cli_group = cli_group\n-        self._blueprints: t.List[t.Tuple[\"Blueprint\", dict]] = []\n+        self._blueprints: list[tuple[Blueprint, dict]] = []\n \n     def _check_setup_finished(self, f_name: str) -> None:\n         if self._got_registered_once:\n@@ -242,7 +244,7 @@ class Blueprint(Scaffold):\n         self.record(update_wrapper(wrapper, func))\n \n     def make_setup_state(\n-        self, app: \"Flask\", options: dict, first_registration: bool = False\n+        self, app: Flask, options: dict, first_registration: bool = False\n     ) -> BlueprintSetupState:\n         \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n         object that is later passed to the register callback functions.\n@@ -251,7 +253,7 @@ class Blueprint(Scaffold):\n         return BlueprintSetupState(self, app, options, first_registration)\n \n     @setupmethod\n-    def register_blueprint(self, blueprint: \"Blueprint\", **options: t.Any) -> None:\n+    def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:\n         \"\"\"Register a :class:`~flask.Blueprint` on this blueprint. Keyword\n         arguments passed to this method will override the defaults set\n         on the blueprint.\n@@ -268,7 +270,7 @@ class Blueprint(Scaffold):\n             raise ValueError(\"Cannot register a blueprint on itself\")\n         self._blueprints.append((blueprint, options))\n \n-    def register(self, app: \"Flask\", options: dict) -> None:\n+    def register(self, app: Flask, options: dict) -> None:\n         \"\"\"Called by :meth:`Flask.register_blueprint` to register all\n         views and callbacks registered on the blueprint with the\n         application. Creates a :class:`.BlueprintSetupState` and calls\n@@ -408,9 +410,9 @@ class Blueprint(Scaffold):\n     def add_url_rule(\n         self,\n         rule: str,\n-        endpoint: t.Optional[str] = None,\n-        view_func: t.Optional[ft.RouteCallable] = None,\n-        provide_automatic_options: t.Optional[bool] = None,\n+        endpoint: str | None = None,\n+        view_func: ft.RouteCallable | None = None,\n+        provide_automatic_options: bool | None = None,\n         **options: t.Any,\n     ) -> None:\n         \"\"\"Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for\n@@ -437,7 +439,7 @@ class Blueprint(Scaffold):\n \n     @setupmethod\n     def app_template_filter(\n-        self, name: t.Optional[str] = None\n+        self, name: str | None = None\n     ) -> t.Callable[[T_template_filter], T_template_filter]:\n         \"\"\"Register a template filter, available in any template rendered by the\n         application. Equivalent to :meth:`.Flask.template_filter`.\n@@ -454,7 +456,7 @@ class Blueprint(Scaffold):\n \n     @setupmethod\n     def add_app_template_filter(\n-        self, f: ft.TemplateFilterCallable, name: t.Optional[str] = None\n+        self, f: ft.TemplateFilterCallable, name: str | None = None\n     ) -> None:\n         \"\"\"Register a template filter, available in any template rendered by the\n         application. Works like the :meth:`app_template_filter` decorator. Equivalent to\n@@ -471,7 +473,7 @@ class Blueprint(Scaffold):\n \n     @setupmethod\n     def app_template_test(\n-        self, name: t.Optional[str] = None\n+        self, name: str | None = None\n     ) -> t.Callable[[T_template_test], T_template_test]:\n         \"\"\"Register a template test, available in any template rendered by the\n         application. Equivalent to :meth:`.Flask.template_test`.\n@@ -490,7 +492,7 @@ class Blueprint(Scaffold):\n \n     @setupmethod\n     def add_app_template_test(\n-        self, f: ft.TemplateTestCallable, name: t.Optional[str] = None\n+        self, f: ft.TemplateTestCallable, name: str | None = None\n     ) -> None:\n         \"\"\"Register a template test, available in any template rendered by the\n         application. Works like the :meth:`app_template_test` decorator. Equivalent to\n@@ -509,7 +511,7 @@ class Blueprint(Scaffold):\n \n     @setupmethod\n     def app_template_global(\n-        self, name: t.Optional[str] = None\n+        self, name: str | None = None\n     ) -> t.Callable[[T_template_global], T_template_global]:\n         \"\"\"Register a template global, available in any template rendered by the\n         application. Equivalent to :meth:`.Flask.template_global`.\n@@ -528,7 +530,7 @@ class Blueprint(Scaffold):\n \n     @setupmethod\n     def add_app_template_global(\n-        self, f: ft.TemplateGlobalCallable, name: t.Optional[str] = None\n+        self, f: ft.TemplateGlobalCallable, name: str | None = None\n     ) -> None:\n         \"\"\"Register a template global, available in any template rendered by the\n         application. Works like the :meth:`app_template_global` decorator. Equivalent to\n@@ -589,7 +591,7 @@ class Blueprint(Scaffold):\n \n     @setupmethod\n     def app_errorhandler(\n-        self, code: t.Union[t.Type[Exception], int]\n+        self, code: type[Exception] | int\n     ) -> t.Callable[[T_error_handler], T_error_handler]:\n         \"\"\"Like :meth:`errorhandler`, but for every request, not only those handled by\n         the blueprint. Equivalent to :meth:`.Flask.errorhandler`.\n\n@@ -285,7 +285,7 @@ class ScriptInfo:\n         self.create_app = create_app\n         #: A dictionary with arbitrary data that can be associated with\n         #: this script info.\n-        self.data: t.Dict[t.Any, t.Any] = {}\n+        self.data: dict[t.Any, t.Any] = {}\n         self.set_debug_flag = set_debug_flag\n         self._loaded_app: Flask | None = None\n \n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import errno\n import json\n import os\n@@ -10,7 +12,7 @@ from werkzeug.utils import import_string\n class ConfigAttribute:\n     \"\"\"Makes an attribute forward to the config\"\"\"\n \n-    def __init__(self, name: str, get_converter: t.Optional[t.Callable] = None) -> None:\n+    def __init__(self, name: str, get_converter: t.Callable | None = None) -> None:\n         self.__name__ = name\n         self.get_converter = get_converter\n \n@@ -70,7 +72,7 @@ class Config(dict):\n     :param defaults: an optional dictionary of default values\n     \"\"\"\n \n-    def __init__(self, root_path: str, defaults: t.Optional[dict] = None) -> None:\n+    def __init__(self, root_path: str, defaults: dict | None = None) -> None:\n         super().__init__(defaults or {})\n         self.root_path = root_path\n \n@@ -191,7 +193,7 @@ class Config(dict):\n         self.from_object(d)\n         return True\n \n-    def from_object(self, obj: t.Union[object, str]) -> None:\n+    def from_object(self, obj: object | str) -> None:\n         \"\"\"Updates the values from the given object.  An object can be of one\n         of the following two types:\n \n@@ -278,7 +280,7 @@ class Config(dict):\n         return self.from_mapping(obj)\n \n     def from_mapping(\n-        self, mapping: t.Optional[t.Mapping[str, t.Any]] = None, **kwargs: t.Any\n+        self, mapping: t.Mapping[str, t.Any] | None = None, **kwargs: t.Any\n     ) -> bool:\n         \"\"\"Updates the config like :meth:`update` ignoring items with\n         non-upper keys.\n@@ -287,7 +289,7 @@ class Config(dict):\n \n         .. versionadded:: 0.11\n         \"\"\"\n-        mappings: t.Dict[str, t.Any] = {}\n+        mappings: dict[str, t.Any] = {}\n         if mapping is not None:\n             mappings.update(mapping)\n         mappings.update(kwargs)\n@@ -298,7 +300,7 @@ class Config(dict):\n \n     def get_namespace(\n         self, namespace: str, lowercase: bool = True, trim_namespace: bool = True\n-    ) -> t.Dict[str, t.Any]:\n+    ) -> dict[str, t.Any]:\n         \"\"\"Returns a dictionary containing a subset of configuration options\n         that match the specified namespace/prefix. Example usage::\n \n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import contextvars\n import sys\n import typing as t\n@@ -60,7 +62,7 @@ class _AppCtxGlobals:\n         except KeyError:\n             raise AttributeError(name) from None\n \n-    def get(self, name: str, default: t.Optional[t.Any] = None) -> t.Any:\n+    def get(self, name: str, default: t.Any | None = None) -> t.Any:\n         \"\"\"Get an attribute by name, or a default value. Like\n         :meth:`dict.get`.\n \n@@ -233,18 +235,18 @@ class AppContext:\n     running CLI commands.\n     \"\"\"\n \n-    def __init__(self, app: \"Flask\") -> None:\n+    def __init__(self, app: Flask) -> None:\n         self.app = app\n         self.url_adapter = app.create_url_adapter(None)\n         self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n-        self._cv_tokens: t.List[contextvars.Token] = []\n+        self._cv_tokens: list[contextvars.Token] = []\n \n     def push(self) -> None:\n         \"\"\"Binds the app context to the current context.\"\"\"\n         self._cv_tokens.append(_cv_app.set(self))\n         appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n \n-    def pop(self, exc: t.Optional[BaseException] = _sentinel) -> None:  # type: ignore\n+    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n         \"\"\"Pops the app context.\"\"\"\n         try:\n             if len(self._cv_tokens) == 1:\n@@ -262,15 +264,15 @@ class AppContext:\n \n         appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)\n \n-    def __enter__(self) -> \"AppContext\":\n+    def __enter__(self) -> AppContext:\n         self.push()\n         return self\n \n     def __exit__(\n         self,\n-        exc_type: t.Optional[type],\n-        exc_value: t.Optional[BaseException],\n-        tb: t.Optional[TracebackType],\n+        exc_type: type | None,\n+        exc_value: BaseException | None,\n+        tb: TracebackType | None,\n     ) -> None:\n         self.pop(exc_value)\n \n@@ -299,10 +301,10 @@ class RequestContext:\n \n     def __init__(\n         self,\n-        app: \"Flask\",\n+        app: Flask,\n         environ: dict,\n-        request: t.Optional[\"Request\"] = None,\n-        session: t.Optional[\"SessionMixin\"] = None,\n+        request: Request | None = None,\n+        session: SessionMixin | None = None,\n     ) -> None:\n         self.app = app\n         if request is None:\n@@ -314,16 +316,16 @@ class RequestContext:\n             self.url_adapter = app.create_url_adapter(self.request)\n         except HTTPException as e:\n             self.request.routing_exception = e\n-        self.flashes: t.Optional[t.List[t.Tuple[str, str]]] = None\n-        self.session: t.Optional[\"SessionMixin\"] = session\n+        self.flashes: list[tuple[str, str]] | None = None\n+        self.session: SessionMixin | None = session\n         # Functions that should be executed after the request on the response\n         # object.  These will be called before the regular \"after_request\"\n         # functions.\n-        self._after_request_functions: t.List[ft.AfterRequestCallable] = []\n+        self._after_request_functions: list[ft.AfterRequestCallable] = []\n \n-        self._cv_tokens: t.List[t.Tuple[contextvars.Token, t.Optional[AppContext]]] = []\n+        self._cv_tokens: list[tuple[contextvars.Token, AppContext | None]] = []\n \n-    def copy(self) -> \"RequestContext\":\n+    def copy(self) -> RequestContext:\n         \"\"\"Creates a copy of this request context with the same request object.\n         This can be used to move a request context to a different greenlet.\n         Because the actual request object is the same this cannot be used to\n@@ -382,7 +384,7 @@ class RequestContext:\n         if self.url_adapter is not None:\n             self.match_request()\n \n-    def pop(self, exc: t.Optional[BaseException] = _sentinel) -> None:  # type: ignore\n+    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore\n         \"\"\"Pops the request context and unbinds it by doing that.  This will\n         also trigger the execution of functions registered by the\n         :meth:`~flask.Flask.teardown_request` decorator.\n@@ -419,15 +421,15 @@ class RequestContext:\n                     f\"Popped wrong request context. ({ctx!r} instead of {self!r})\"\n                 )\n \n-    def __enter__(self) -> \"RequestContext\":\n+    def __enter__(self) -> RequestContext:\n         self.push()\n         return self\n \n     def __exit__(\n         self,\n-        exc_type: t.Optional[type],\n-        exc_value: t.Optional[BaseException],\n-        tb: t.Optional[TracebackType],\n+        exc_type: type | None,\n+        exc_value: BaseException | None,\n+        tb: TracebackType | None,\n     ) -> None:\n         self.pop(exc_value)\n \n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import typing as t\n \n from .app import Flask\n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import typing as t\n from contextvars import ContextVar\n \n@@ -18,7 +20,7 @@ class _FakeStack:\n         self.cv = cv\n \n     @property\n-    def top(self) -> t.Optional[t.Any]:\n+    def top(self) -> t.Any | None:\n         import warnings\n \n         warnings.warn(\n@@ -38,15 +40,15 @@ This typically means that you attempted to use functionality that needed\n the current application. To solve this, set up an application context\n with app.app_context(). See the documentation for more information.\\\n \"\"\"\n-_cv_app: ContextVar[\"AppContext\"] = ContextVar(\"flask.app_ctx\")\n+_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\n __app_ctx_stack = _FakeStack(\"app\", _cv_app)\n-app_ctx: \"AppContext\" = LocalProxy(  # type: ignore[assignment]\n+app_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n     _cv_app, unbound_message=_no_app_msg\n )\n-current_app: \"Flask\" = LocalProxy(  # type: ignore[assignment]\n+current_app: Flask = LocalProxy(  # type: ignore[assignment]\n     _cv_app, \"app\", unbound_message=_no_app_msg\n )\n-g: \"_AppCtxGlobals\" = LocalProxy(  # type: ignore[assignment]\n+g: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n     _cv_app, \"g\", unbound_message=_no_app_msg\n )\n \n@@ -57,15 +59,15 @@ This typically means that you attempted to use functionality that needed\n an active HTTP request. Consult the documentation on testing for\n information about how to avoid this problem.\\\n \"\"\"\n-_cv_request: ContextVar[\"RequestContext\"] = ContextVar(\"flask.request_ctx\")\n+_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\n __request_ctx_stack = _FakeStack(\"request\", _cv_request)\n-request_ctx: \"RequestContext\" = LocalProxy(  # type: ignore[assignment]\n+request_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n     _cv_request, unbound_message=_no_req_msg\n )\n-request: \"Request\" = LocalProxy(  # type: ignore[assignment]\n+request: Request = LocalProxy(  # type: ignore[assignment]\n     _cv_request, \"request\", unbound_message=_no_req_msg\n )\n-session: \"SessionMixin\" = LocalProxy(  # type: ignore[assignment]\n+session: SessionMixin = LocalProxy(  # type: ignore[assignment]\n     _cv_request, \"session\", unbound_message=_no_req_msg\n )\n \n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import os\n import pkgutil\n import socket\n@@ -50,9 +52,9 @@ def get_load_dotenv(default: bool = True) -> bool:\n \n \n def stream_with_context(\n-    generator_or_function: t.Union[\n-        t.Iterator[t.AnyStr], t.Callable[..., t.Iterator[t.AnyStr]]\n-    ]\n+    generator_or_function: (\n+        t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]]\n+    )\n ) -> t.Iterator[t.AnyStr]:\n     \"\"\"Request contexts disappear when the response is started on the server.\n     This is done for efficiency reasons and to make it less likely to encounter\n@@ -128,7 +130,7 @@ def stream_with_context(\n     return wrapped_g\n \n \n-def make_response(*args: t.Any) -> \"Response\":\n+def make_response(*args: t.Any) -> Response:\n     \"\"\"Sometimes it is necessary to set additional headers in a view.  Because\n     views do not have to return response objects but can return a value that\n     is converted into a response object by Flask itself, it becomes tricky to\n@@ -180,10 +182,10 @@ def make_response(*args: t.Any) -> \"Response\":\n def url_for(\n     endpoint: str,\n     *,\n-    _anchor: t.Optional[str] = None,\n-    _method: t.Optional[str] = None,\n-    _scheme: t.Optional[str] = None,\n-    _external: t.Optional[bool] = None,\n+    _anchor: str | None = None,\n+    _method: str | None = None,\n+    _scheme: str | None = None,\n+    _external: bool | None = None,\n     **values: t.Any,\n ) -> str:\n     \"\"\"Generate a URL to the given endpoint with the given values.\n@@ -232,8 +234,8 @@ def url_for(\n \n \n def redirect(\n-    location: str, code: int = 302, Response: t.Optional[t.Type[\"BaseResponse\"]] = None\n-) -> \"BaseResponse\":\n+    location: str, code: int = 302, Response: type[BaseResponse] | None = None\n+) -> BaseResponse:\n     \"\"\"Create a redirect response object.\n \n     If :data:`~flask.current_app` is available, it will use its\n@@ -255,9 +257,7 @@ def redirect(\n     return _wz_redirect(location, code=code, Response=Response)\n \n \n-def abort(\n-    code: t.Union[int, \"BaseResponse\"], *args: t.Any, **kwargs: t.Any\n-) -> \"te.NoReturn\":\n+def abort(code: int | BaseResponse, *args: t.Any, **kwargs: t.Any) -> te.NoReturn:\n     \"\"\"Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given\n     status code.\n \n@@ -338,7 +338,7 @@ def flash(message: str, category: str = \"message\") -> None:\n \n def get_flashed_messages(\n     with_categories: bool = False, category_filter: t.Iterable[str] = ()\n-) -> t.Union[t.List[str], t.List[t.Tuple[str, str]]]:\n+) -> list[str] | list[tuple[str, str]]:\n     \"\"\"Pulls all flashed messages from the session and returns them.\n     Further calls in the same request to the function will return\n     the same messages.  By default just the messages are returned,\n@@ -378,7 +378,7 @@ def get_flashed_messages(\n     return flashes\n \n \n-def _prepare_send_file_kwargs(**kwargs: t.Any) -> t.Dict[str, t.Any]:\n+def _prepare_send_file_kwargs(**kwargs: t.Any) -> dict[str, t.Any]:\n     if kwargs.get(\"max_age\") is None:\n         kwargs[\"max_age\"] = current_app.get_send_file_max_age\n \n@@ -392,17 +392,15 @@ def _prepare_send_file_kwargs(**kwargs: t.Any) -> t.Dict[str, t.Any]:\n \n \n def send_file(\n-    path_or_file: t.Union[os.PathLike, str, t.BinaryIO],\n-    mimetype: t.Optional[str] = None,\n+    path_or_file: os.PathLike | str | t.BinaryIO,\n+    mimetype: str | None = None,\n     as_attachment: bool = False,\n-    download_name: t.Optional[str] = None,\n+    download_name: str | None = None,\n     conditional: bool = True,\n-    etag: t.Union[bool, str] = True,\n-    last_modified: t.Optional[t.Union[datetime, int, float]] = None,\n-    max_age: t.Optional[\n-        t.Union[int, t.Callable[[t.Optional[str]], t.Optional[int]]]\n-    ] = None,\n-) -> \"Response\":\n+    etag: bool | str = True,\n+    last_modified: datetime | int | float | None = None,\n+    max_age: None | (int | t.Callable[[str | None], int | None]) = None,\n+) -> Response:\n     \"\"\"Send the contents of a file to the client.\n \n     The first argument can be a file path or a file-like object. Paths\n@@ -520,10 +518,10 @@ def send_file(\n \n \n def send_from_directory(\n-    directory: t.Union[os.PathLike, str],\n-    path: t.Union[os.PathLike, str],\n+    directory: os.PathLike | str,\n+    path: os.PathLike | str,\n     **kwargs: t.Any,\n-) -> \"Response\":\n+) -> Response:\n     \"\"\"Send a file from within a directory using :func:`send_file`.\n \n     .. code-block:: python\n@@ -627,8 +625,8 @@ class locked_cached_property(werkzeug.utils.cached_property):\n     def __init__(\n         self,\n         fget: t.Callable[[t.Any], t.Any],\n-        name: t.Optional[str] = None,\n-        doc: t.Optional[str] = None,\n+        name: str | None = None,\n+        doc: str | None = None,\n     ) -> None:\n         import warnings\n \n@@ -687,8 +685,8 @@ def is_ip(value: str) -> bool:\n \n \n @lru_cache(maxsize=None)\n-def _split_blueprint_path(name: str) -> t.List[str]:\n-    out: t.List[str] = [name]\n+def _split_blueprint_path(name: str) -> list[str]:\n+    out: list[str] = [name]\n \n     if \".\" in name:\n         out.extend(_split_blueprint_path(name.rpartition(\".\")[0]))\n\n@@ -72,7 +72,7 @@ class JSONProvider:\n         return self.loads(fp.read(), **kwargs)\n \n     def _prepare_response_obj(\n-        self, args: t.Tuple[t.Any, ...], kwargs: t.Dict[str, t.Any]\n+        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]\n     ) -> t.Any:\n         if args and kwargs:\n             raise TypeError(\"app.json.response() takes either args or kwargs, not both\")\n@@ -204,7 +204,7 @@ class DefaultJSONProvider(JSONProvider):\n         :param kwargs: Treat as a dict to serialize.\n         \"\"\"\n         obj = self._prepare_response_obj(args, kwargs)\n-        dump_args: t.Dict[str, t.Any] = {}\n+        dump_args: dict[str, t.Any] = {}\n \n         if (self.compact is None and self._app.debug) or self.compact is False:\n             dump_args.setdefault(\"indent\", 2)\n\n@@ -40,6 +40,8 @@ be processed before ``dict``.\n \n     app.session_interface.serializer.register(TagOrderedDict, index=0)\n \"\"\"\n+from __future__ import annotations\n+\n import typing as t\n from base64 import b64decode\n from base64 import b64encode\n@@ -61,9 +63,9 @@ class JSONTag:\n \n     #: The tag to mark the serialized object with. If ``None``, this tag is\n     #: only used as an intermediate step during tagging.\n-    key: t.Optional[str] = None\n+    key: str | None = None\n \n-    def __init__(self, serializer: \"TaggedJSONSerializer\") -> None:\n+    def __init__(self, serializer: TaggedJSONSerializer) -> None:\n         \"\"\"Create a tagger for the given serializer.\"\"\"\n         self.serializer = serializer\n \n@@ -244,17 +246,17 @@ class TaggedJSONSerializer:\n     ]\n \n     def __init__(self) -> None:\n-        self.tags: t.Dict[str, JSONTag] = {}\n-        self.order: t.List[JSONTag] = []\n+        self.tags: dict[str, JSONTag] = {}\n+        self.order: list[JSONTag] = []\n \n         for cls in self.default_tags:\n             self.register(cls)\n \n     def register(\n         self,\n-        tag_class: t.Type[JSONTag],\n+        tag_class: type[JSONTag],\n         force: bool = False,\n-        index: t.Optional[int] = None,\n+        index: int | None = None,\n     ) -> None:\n         \"\"\"Register a new tag with this serializer.\n \n@@ -283,7 +285,7 @@ class TaggedJSONSerializer:\n         else:\n             self.order.insert(index, tag)\n \n-    def tag(self, value: t.Any) -> t.Dict[str, t.Any]:\n+    def tag(self, value: t.Any) -> dict[str, t.Any]:\n         \"\"\"Convert a value to a tagged representation if necessary.\"\"\"\n         for tag in self.order:\n             if tag.check(value):\n@@ -291,7 +293,7 @@ class TaggedJSONSerializer:\n \n         return value\n \n-    def untag(self, value: t.Dict[str, t.Any]) -> t.Any:\n+    def untag(self, value: dict[str, t.Any]) -> t.Any:\n         \"\"\"Convert a tagged representation back to the original type.\"\"\"\n         if len(value) != 1:\n             return value\n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import logging\n import sys\n import typing as t\n@@ -50,7 +52,7 @@ default_handler.setFormatter(\n )\n \n \n-def create_logger(app: \"Flask\") -> logging.Logger:\n+def create_logger(app: Flask) -> logging.Logger:\n     \"\"\"Get the Flask app's logger and configure it if needed.\n \n     The logger name will be the same as\n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import importlib.util\n import os\n import pathlib\n@@ -70,16 +72,16 @@ class Scaffold:\n     \"\"\"\n \n     name: str\n-    _static_folder: t.Optional[str] = None\n-    _static_url_path: t.Optional[str] = None\n+    _static_folder: str | None = None\n+    _static_url_path: str | None = None\n \n     def __init__(\n         self,\n         import_name: str,\n-        static_folder: t.Optional[t.Union[str, os.PathLike]] = None,\n-        static_url_path: t.Optional[str] = None,\n-        template_folder: t.Optional[t.Union[str, os.PathLike]] = None,\n-        root_path: t.Optional[str] = None,\n+        static_folder: str | os.PathLike | None = None,\n+        static_url_path: str | None = None,\n+        template_folder: str | os.PathLike | None = None,\n+        root_path: str | None = None,\n     ):\n         #: The name of the package or module that this object belongs\n         #: to. Do not change this once it is set by the constructor.\n@@ -112,7 +114,7 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.view_functions: t.Dict[str, t.Callable] = {}\n+        self.view_functions: dict[str, t.Callable] = {}\n \n         #: A data structure of registered error handlers, in the format\n         #: ``{scope: {code: {class: handler}}}``. The ``scope`` key is\n@@ -127,9 +129,9 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.error_handler_spec: t.Dict[\n+        self.error_handler_spec: dict[\n             ft.AppOrBlueprintKey,\n-            t.Dict[t.Optional[int], t.Dict[t.Type[Exception], ft.ErrorHandlerCallable]],\n+            dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]],\n         ] = defaultdict(lambda: defaultdict(dict))\n \n         #: A data structure of functions to call at the beginning of\n@@ -142,8 +144,8 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.before_request_funcs: t.Dict[\n-            ft.AppOrBlueprintKey, t.List[ft.BeforeRequestCallable]\n+        self.before_request_funcs: dict[\n+            ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]\n         ] = defaultdict(list)\n \n         #: A data structure of functions to call at the end of each\n@@ -156,8 +158,8 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.after_request_funcs: t.Dict[\n-            ft.AppOrBlueprintKey, t.List[ft.AfterRequestCallable]\n+        self.after_request_funcs: dict[\n+            ft.AppOrBlueprintKey, list[ft.AfterRequestCallable]\n         ] = defaultdict(list)\n \n         #: A data structure of functions to call at the end of each\n@@ -171,8 +173,8 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.teardown_request_funcs: t.Dict[\n-            ft.AppOrBlueprintKey, t.List[ft.TeardownCallable]\n+        self.teardown_request_funcs: dict[\n+            ft.AppOrBlueprintKey, list[ft.TeardownCallable]\n         ] = defaultdict(list)\n \n         #: A data structure of functions to call to pass extra context\n@@ -186,8 +188,8 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.template_context_processors: t.Dict[\n-            ft.AppOrBlueprintKey, t.List[ft.TemplateContextProcessorCallable]\n+        self.template_context_processors: dict[\n+            ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]\n         ] = defaultdict(list, {None: [_default_template_ctx_processor]})\n \n         #: A data structure of functions to call to modify the keyword\n@@ -201,9 +203,9 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.url_value_preprocessors: t.Dict[\n+        self.url_value_preprocessors: dict[\n             ft.AppOrBlueprintKey,\n-            t.List[ft.URLValuePreprocessorCallable],\n+            list[ft.URLValuePreprocessorCallable],\n         ] = defaultdict(list)\n \n         #: A data structure of functions to call to modify the keyword\n@@ -217,8 +219,8 @@ class Scaffold:\n         #:\n         #: This data structure is internal. It should not be modified\n         #: directly and its format may change at any time.\n-        self.url_default_functions: t.Dict[\n-            ft.AppOrBlueprintKey, t.List[ft.URLDefaultCallable]\n+        self.url_default_functions: dict[\n+            ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]\n         ] = defaultdict(list)\n \n     def __repr__(self) -> str:\n@@ -228,7 +230,7 @@ class Scaffold:\n         raise NotImplementedError\n \n     @property\n-    def static_folder(self) -> t.Optional[str]:\n+    def static_folder(self) -> str | None:\n         \"\"\"The absolute path to the configured static folder. ``None``\n         if no static folder is set.\n         \"\"\"\n@@ -238,7 +240,7 @@ class Scaffold:\n             return None\n \n     @static_folder.setter\n-    def static_folder(self, value: t.Optional[t.Union[str, os.PathLike]]) -> None:\n+    def static_folder(self, value: str | os.PathLike | None) -> None:\n         if value is not None:\n             value = os.fspath(value).rstrip(r\"\\/\")\n \n@@ -253,7 +255,7 @@ class Scaffold:\n         return self.static_folder is not None\n \n     @property\n-    def static_url_path(self) -> t.Optional[str]:\n+    def static_url_path(self) -> str | None:\n         \"\"\"The URL prefix that the static route will be accessible from.\n \n         If it was not configured during init, it is derived from\n@@ -269,13 +271,13 @@ class Scaffold:\n         return None\n \n     @static_url_path.setter\n-    def static_url_path(self, value: t.Optional[str]) -> None:\n+    def static_url_path(self, value: str | None) -> None:\n         if value is not None:\n             value = value.rstrip(\"/\")\n \n         self._static_url_path = value\n \n-    def get_send_file_max_age(self, filename: t.Optional[str]) -> t.Optional[int]:\n+    def get_send_file_max_age(self, filename: str | None) -> int | None:\n         \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n         value for a given file path if it wasn't passed.\n \n@@ -299,7 +301,7 @@ class Scaffold:\n \n         return value\n \n-    def send_static_file(self, filename: str) -> \"Response\":\n+    def send_static_file(self, filename: str) -> Response:\n         \"\"\"The view function used to serve files from\n         :attr:`static_folder`. A route is automatically registered for\n         this view at :attr:`static_url_path` if :attr:`static_folder` is\n@@ -318,7 +320,7 @@ class Scaffold:\n         )\n \n     @cached_property\n-    def jinja_loader(self) -> t.Optional[FileSystemLoader]:\n+    def jinja_loader(self) -> FileSystemLoader | None:\n         \"\"\"The Jinja loader for this object's templates. By default this\n         is a class :class:`jinja2.loaders.FileSystemLoader` to\n         :attr:`template_folder` if it is set.\n@@ -440,9 +442,9 @@ class Scaffold:\n     def add_url_rule(\n         self,\n         rule: str,\n-        endpoint: t.Optional[str] = None,\n-        view_func: t.Optional[ft.RouteCallable] = None,\n-        provide_automatic_options: t.Optional[bool] = None,\n+        endpoint: str | None = None,\n+        view_func: ft.RouteCallable | None = None,\n+        provide_automatic_options: bool | None = None,\n         **options: t.Any,\n     ) -> None:\n         \"\"\"Register a rule for routing incoming requests and building\n@@ -668,7 +670,7 @@ class Scaffold:\n \n     @setupmethod\n     def errorhandler(\n-        self, code_or_exception: t.Union[t.Type[Exception], int]\n+        self, code_or_exception: type[Exception] | int\n     ) -> t.Callable[[T_error_handler], T_error_handler]:\n         \"\"\"Register a function to handle errors by code or exception class.\n \n@@ -713,7 +715,7 @@ class Scaffold:\n     @setupmethod\n     def register_error_handler(\n         self,\n-        code_or_exception: t.Union[t.Type[Exception], int],\n+        code_or_exception: type[Exception] | int,\n         f: ft.ErrorHandlerCallable,\n     ) -> None:\n         \"\"\"Alternative error attach function to the :meth:`errorhandler`\n@@ -727,8 +729,8 @@ class Scaffold:\n \n     @staticmethod\n     def _get_exc_class_and_code(\n-        exc_class_or_code: t.Union[t.Type[Exception], int]\n-    ) -> t.Tuple[t.Type[Exception], t.Optional[int]]:\n+        exc_class_or_code: type[Exception] | int,\n+    ) -> tuple[type[Exception], int | None]:\n         \"\"\"Get the exception class being handled. For HTTP status codes\n         or ``HTTPException`` subclasses, return both the exception and\n         status code.\n@@ -736,7 +738,7 @@ class Scaffold:\n         :param exc_class_or_code: Any exception class, or an HTTP status\n             code as an integer.\n         \"\"\"\n-        exc_class: t.Type[Exception]\n+        exc_class: type[Exception]\n \n         if isinstance(exc_class_or_code, int):\n             try:\n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import hashlib\n import typing as t\n from collections.abc import MutableMapping\n@@ -92,7 +94,7 @@ class NullSession(SecureCookieSession):\n     but fail on setting.\n     \"\"\"\n \n-    def _fail(self, *args: t.Any, **kwargs: t.Any) -> \"te.NoReturn\":\n+    def _fail(self, *args: t.Any, **kwargs: t.Any) -> te.NoReturn:\n         raise RuntimeError(\n             \"The session is unavailable because no secret \"\n             \"key was set.  Set the secret_key on the \"\n@@ -153,7 +155,7 @@ class SessionInterface:\n     #: .. versionadded:: 0.10\n     pickle_based = False\n \n-    def make_null_session(self, app: \"Flask\") -> NullSession:\n+    def make_null_session(self, app: Flask) -> NullSession:\n         \"\"\"Creates a null session which acts as a replacement object if the\n         real session support could not be loaded due to a configuration\n         error.  This mainly aids the user experience because the job of the\n@@ -174,11 +176,11 @@ class SessionInterface:\n         \"\"\"\n         return isinstance(obj, self.null_session_class)\n \n-    def get_cookie_name(self, app: \"Flask\") -> str:\n+    def get_cookie_name(self, app: Flask) -> str:\n         \"\"\"The name of the session cookie. Uses``app.config[\"SESSION_COOKIE_NAME\"]``.\"\"\"\n         return app.config[\"SESSION_COOKIE_NAME\"]\n \n-    def get_cookie_domain(self, app: \"Flask\") -> t.Optional[str]:\n+    def get_cookie_domain(self, app: Flask) -> str | None:\n         \"\"\"The value of the ``Domain`` parameter on the session cookie. If not set,\n         browsers will only send the cookie to the exact domain it was set from.\n         Otherwise, they will send it to any subdomain of the given value as well.\n@@ -191,7 +193,7 @@ class SessionInterface:\n         rv = app.config[\"SESSION_COOKIE_DOMAIN\"]\n         return rv if rv else None\n \n-    def get_cookie_path(self, app: \"Flask\") -> str:\n+    def get_cookie_path(self, app: Flask) -> str:\n         \"\"\"Returns the path for which the cookie should be valid.  The\n         default implementation uses the value from the ``SESSION_COOKIE_PATH``\n         config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n@@ -199,29 +201,27 @@ class SessionInterface:\n         \"\"\"\n         return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]\n \n-    def get_cookie_httponly(self, app: \"Flask\") -> bool:\n+    def get_cookie_httponly(self, app: Flask) -> bool:\n         \"\"\"Returns True if the session cookie should be httponly.  This\n         currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n         config var.\n         \"\"\"\n         return app.config[\"SESSION_COOKIE_HTTPONLY\"]\n \n-    def get_cookie_secure(self, app: \"Flask\") -> bool:\n+    def get_cookie_secure(self, app: Flask) -> bool:\n         \"\"\"Returns True if the cookie should be secure.  This currently\n         just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n         \"\"\"\n         return app.config[\"SESSION_COOKIE_SECURE\"]\n \n-    def get_cookie_samesite(self, app: \"Flask\") -> str:\n+    def get_cookie_samesite(self, app: Flask) -> str:\n         \"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n         ``SameSite`` attribute. This currently just returns the value of\n         the :data:`SESSION_COOKIE_SAMESITE` setting.\n         \"\"\"\n         return app.config[\"SESSION_COOKIE_SAMESITE\"]\n \n-    def get_expiration_time(\n-        self, app: \"Flask\", session: SessionMixin\n-    ) -> t.Optional[datetime]:\n+    def get_expiration_time(self, app: Flask, session: SessionMixin) -> datetime | None:\n         \"\"\"A helper method that returns an expiration date for the session\n         or ``None`` if the session is linked to the browser session.  The\n         default implementation returns now + the permanent session\n@@ -231,7 +231,7 @@ class SessionInterface:\n             return datetime.now(timezone.utc) + app.permanent_session_lifetime\n         return None\n \n-    def should_set_cookie(self, app: \"Flask\", session: SessionMixin) -> bool:\n+    def should_set_cookie(self, app: Flask, session: SessionMixin) -> bool:\n         \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n         should be set for this session cookie for this response. If the session\n         has been modified, the cookie is set. If the session is permanent and\n@@ -247,9 +247,7 @@ class SessionInterface:\n             session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n         )\n \n-    def open_session(\n-        self, app: \"Flask\", request: \"Request\"\n-    ) -> t.Optional[SessionMixin]:\n+    def open_session(self, app: Flask, request: Request) -> SessionMixin | None:\n         \"\"\"This is called at the beginning of each request, after\n         pushing the request context, before matching the URL.\n \n@@ -264,7 +262,7 @@ class SessionInterface:\n         raise NotImplementedError()\n \n     def save_session(\n-        self, app: \"Flask\", session: SessionMixin, response: \"Response\"\n+        self, app: Flask, session: SessionMixin, response: Response\n     ) -> None:\n         \"\"\"This is called at the end of each request, after generating\n         a response, before removing the request context. It is skipped\n@@ -295,9 +293,7 @@ class SecureCookieSessionInterface(SessionInterface):\n     serializer = session_json_serializer\n     session_class = SecureCookieSession\n \n-    def get_signing_serializer(\n-        self, app: \"Flask\"\n-    ) -> t.Optional[URLSafeTimedSerializer]:\n+    def get_signing_serializer(self, app: Flask) -> URLSafeTimedSerializer | None:\n         if not app.secret_key:\n             return None\n         signer_kwargs = dict(\n@@ -310,9 +306,7 @@ class SecureCookieSessionInterface(SessionInterface):\n             signer_kwargs=signer_kwargs,\n         )\n \n-    def open_session(\n-        self, app: \"Flask\", request: \"Request\"\n-    ) -> t.Optional[SecureCookieSession]:\n+    def open_session(self, app: Flask, request: Request) -> SecureCookieSession | None:\n         s = self.get_signing_serializer(app)\n         if s is None:\n             return None\n@@ -327,7 +321,7 @@ class SecureCookieSessionInterface(SessionInterface):\n             return self.session_class()\n \n     def save_session(\n-        self, app: \"Flask\", session: SessionMixin, response: \"Response\"\n+        self, app: Flask, session: SessionMixin, response: Response\n     ) -> None:\n         name = self.get_cookie_name(app)\n         domain = self.get_cookie_domain(app)\n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import typing as t\n \n from jinja2 import BaseLoader\n@@ -18,13 +20,13 @@ if t.TYPE_CHECKING:  # pragma: no cover\n     from .scaffold import Scaffold\n \n \n-def _default_template_ctx_processor() -> t.Dict[str, t.Any]:\n+def _default_template_ctx_processor() -> dict[str, t.Any]:\n     \"\"\"Default template context processor.  Injects `request`,\n     `session` and `g`.\n     \"\"\"\n     appctx = _cv_app.get(None)\n     reqctx = _cv_request.get(None)\n-    rv: t.Dict[str, t.Any] = {}\n+    rv: dict[str, t.Any] = {}\n     if appctx is not None:\n         rv[\"g\"] = appctx.g\n     if reqctx is not None:\n@@ -39,7 +41,7 @@ class Environment(BaseEnvironment):\n     name of the blueprint to referenced templates if necessary.\n     \"\"\"\n \n-    def __init__(self, app: \"Flask\", **options: t.Any) -> None:\n+    def __init__(self, app: Flask, **options: t.Any) -> None:\n         if \"loader\" not in options:\n             options[\"loader\"] = app.create_global_jinja_loader()\n         BaseEnvironment.__init__(self, **options)\n@@ -51,24 +53,22 @@ class DispatchingJinjaLoader(BaseLoader):\n     the blueprint folders.\n     \"\"\"\n \n-    def __init__(self, app: \"Flask\") -> None:\n+    def __init__(self, app: Flask) -> None:\n         self.app = app\n \n     def get_source(  # type: ignore\n         self, environment: Environment, template: str\n-    ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable]]:\n+    ) -> tuple[str, str | None, t.Callable | None]:\n         if self.app.config[\"EXPLAIN_TEMPLATE_LOADING\"]:\n             return self._get_source_explained(environment, template)\n         return self._get_source_fast(environment, template)\n \n     def _get_source_explained(\n         self, environment: Environment, template: str\n-    ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable]]:\n+    ) -> tuple[str, str | None, t.Callable | None]:\n         attempts = []\n-        rv: t.Optional[t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]]\n-        trv: t.Optional[\n-            t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]\n-        ] = None\n+        rv: tuple[str, str | None, t.Callable[[], bool] | None] | None\n+        trv: None | (tuple[str, str | None, t.Callable[[], bool] | None]) = None\n \n         for srcobj, loader in self._iter_loaders(template):\n             try:\n@@ -89,7 +89,7 @@ class DispatchingJinjaLoader(BaseLoader):\n \n     def _get_source_fast(\n         self, environment: Environment, template: str\n-    ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable]]:\n+    ) -> tuple[str, str | None, t.Callable | None]:\n         for _srcobj, loader in self._iter_loaders(template):\n             try:\n                 return loader.get_source(environment, template)\n@@ -99,7 +99,7 @@ class DispatchingJinjaLoader(BaseLoader):\n \n     def _iter_loaders(\n         self, template: str\n-    ) -> t.Generator[t.Tuple[\"Scaffold\", BaseLoader], None, None]:\n+    ) -> t.Generator[tuple[Scaffold, BaseLoader], None, None]:\n         loader = self.app.jinja_loader\n         if loader is not None:\n             yield self.app, loader\n@@ -109,7 +109,7 @@ class DispatchingJinjaLoader(BaseLoader):\n             if loader is not None:\n                 yield blueprint, loader\n \n-    def list_templates(self) -> t.List[str]:\n+    def list_templates(self) -> list[str]:\n         result = set()\n         loader = self.app.jinja_loader\n         if loader is not None:\n@@ -124,7 +124,7 @@ class DispatchingJinjaLoader(BaseLoader):\n         return list(result)\n \n \n-def _render(app: \"Flask\", template: Template, context: t.Dict[str, t.Any]) -> str:\n+def _render(app: Flask, template: Template, context: dict[str, t.Any]) -> str:\n     app.update_template_context(context)\n     before_render_template.send(\n         app, _async_wrapper=app.ensure_sync, template=template, context=context\n@@ -137,7 +137,7 @@ def _render(app: \"Flask\", template: Template, context: t.Dict[str, t.Any]) -> st\n \n \n def render_template(\n-    template_name_or_list: t.Union[str, Template, t.List[t.Union[str, Template]]],\n+    template_name_or_list: str | Template | list[str | Template],\n     **context: t.Any,\n ) -> str:\n     \"\"\"Render a template by name with the given context.\n@@ -164,7 +164,7 @@ def render_template_string(source: str, **context: t.Any) -> str:\n \n \n def _stream(\n-    app: \"Flask\", template: Template, context: t.Dict[str, t.Any]\n+    app: Flask, template: Template, context: dict[str, t.Any]\n ) -> t.Iterator[str]:\n     app.update_template_context(context)\n     before_render_template.send(\n@@ -187,7 +187,7 @@ def _stream(\n \n \n def stream_template(\n-    template_name_or_list: t.Union[str, Template, t.List[t.Union[str, Template]]],\n+    template_name_or_list: str | Template | list[str | Template],\n     **context: t.Any,\n ) -> t.Iterator[str]:\n     \"\"\"Render a template by name with the given context as a stream.\n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import typing as t\n from contextlib import contextmanager\n from contextlib import ExitStack\n@@ -43,11 +45,11 @@ class EnvironBuilder(werkzeug.test.EnvironBuilder):\n \n     def __init__(\n         self,\n-        app: \"Flask\",\n+        app: Flask,\n         path: str = \"/\",\n-        base_url: t.Optional[str] = None,\n-        subdomain: t.Optional[str] = None,\n-        url_scheme: t.Optional[str] = None,\n+        base_url: str | None = None,\n+        subdomain: str | None = None,\n+        url_scheme: str | None = None,\n         *args: t.Any,\n         **kwargs: t.Any,\n     ) -> None:\n@@ -104,12 +106,12 @@ class FlaskClient(Client):\n     Basic usage is outlined in the :doc:`/testing` chapter.\n     \"\"\"\n \n-    application: \"Flask\"\n+    application: Flask\n \n     def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n         super().__init__(*args, **kwargs)\n         self.preserve_context = False\n-        self._new_contexts: t.List[t.ContextManager[t.Any]] = []\n+        self._new_contexts: list[t.ContextManager[t.Any]] = []\n         self._context_stack = ExitStack()\n         self.environ_base = {\n             \"REMOTE_ADDR\": \"127.0.0.1\",\n@@ -199,7 +201,7 @@ class FlaskClient(Client):\n         buffered: bool = False,\n         follow_redirects: bool = False,\n         **kwargs: t.Any,\n-    ) -> \"TestResponse\":\n+    ) -> TestResponse:\n         if args and isinstance(\n             args[0], (werkzeug.test.EnvironBuilder, dict, BaseRequest)\n         ):\n@@ -238,7 +240,7 @@ class FlaskClient(Client):\n \n         return response\n \n-    def __enter__(self) -> \"FlaskClient\":\n+    def __enter__(self) -> FlaskClient:\n         if self.preserve_context:\n             raise RuntimeError(\"Cannot nest client invocations\")\n         self.preserve_context = True\n@@ -246,9 +248,9 @@ class FlaskClient(Client):\n \n     def __exit__(\n         self,\n-        exc_type: t.Optional[type],\n-        exc_value: t.Optional[BaseException],\n-        tb: t.Optional[TracebackType],\n+        exc_type: type | None,\n+        exc_value: BaseException | None,\n+        tb: TracebackType | None,\n     ) -> None:\n         self.preserve_context = False\n         self._context_stack.close()\n@@ -260,7 +262,7 @@ class FlaskCliRunner(CliRunner):\n     :meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.\n     \"\"\"\n \n-    def __init__(self, app: \"Flask\", **kwargs: t.Any) -> None:\n+    def __init__(self, app: Flask, **kwargs: t.Any) -> None:\n         self.app = app\n         super().__init__(**kwargs)\n \n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import typing as t\n \n if t.TYPE_CHECKING:  # pragma: no cover\n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import typing as t\n \n from . import typing as ft\n@@ -45,12 +47,12 @@ class View:\n     #: The methods this view is registered for. Uses the same default\n     #: (``[\"GET\", \"HEAD\", \"OPTIONS\"]``) as ``route`` and\n     #: ``add_url_rule`` by default.\n-    methods: t.ClassVar[t.Optional[t.Collection[str]]] = None\n+    methods: t.ClassVar[t.Collection[str] | None] = None\n \n     #: Control whether the ``OPTIONS`` method is handled automatically.\n     #: Uses the same default (``True``) as ``route`` and\n     #: ``add_url_rule`` by default.\n-    provide_automatic_options: t.ClassVar[t.Optional[bool]] = None\n+    provide_automatic_options: t.ClassVar[bool | None] = None\n \n     #: A list of decorators to apply, in order, to the generated view\n     #: function. Remember that ``@decorator`` syntax is applied bottom\n@@ -58,7 +60,7 @@ class View:\n     #: decorator.\n     #:\n     #: .. versionadded:: 0.8\n-    decorators: t.ClassVar[t.List[t.Callable]] = []\n+    decorators: t.ClassVar[list[t.Callable]] = []\n \n     #: Create a new instance of this view class for every request by\n     #: default. If a view subclass sets this to ``False``, the same\n\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import typing as t\n \n from werkzeug.exceptions import BadRequest\n@@ -37,20 +39,20 @@ class Request(RequestBase):\n     #: because the request was never internally bound.\n     #:\n     #: .. versionadded:: 0.6\n-    url_rule: t.Optional[\"Rule\"] = None\n+    url_rule: Rule | None = None\n \n     #: A dict of view arguments that matched the request.  If an exception\n     #: happened when matching, this will be ``None``.\n-    view_args: t.Optional[t.Dict[str, t.Any]] = None\n+    view_args: dict[str, t.Any] | None = None\n \n     #: If matching the URL failed, this is the exception that will be\n     #: raised / was raised as part of the request handling.  This is\n     #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n     #: something similar.\n-    routing_exception: t.Optional[Exception] = None\n+    routing_exception: Exception | None = None\n \n     @property\n-    def max_content_length(self) -> t.Optional[int]:  # type: ignore\n+    def max_content_length(self) -> int | None:  # type: ignore\n         \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\"\n         if current_app:\n             return current_app.config[\"MAX_CONTENT_LENGTH\"]\n@@ -58,7 +60,7 @@ class Request(RequestBase):\n             return None\n \n     @property\n-    def endpoint(self) -> t.Optional[str]:\n+    def endpoint(self) -> str | None:\n         \"\"\"The endpoint that matched the request URL.\n \n         This will be ``None`` if matching failed or has not been\n@@ -73,7 +75,7 @@ class Request(RequestBase):\n         return None\n \n     @property\n-    def blueprint(self) -> t.Optional[str]:\n+    def blueprint(self) -> str | None:\n         \"\"\"The registered name of the current blueprint.\n \n         This will be ``None`` if the endpoint is not part of a\n@@ -92,7 +94,7 @@ class Request(RequestBase):\n         return None\n \n     @property\n-    def blueprints(self) -> t.List[str]:\n+    def blueprints(self) -> list[str]:\n         \"\"\"The registered names of the current blueprint upwards through\n         parent blueprints.\n \n@@ -123,7 +125,7 @@ class Request(RequestBase):\n \n             attach_enctype_error_multidict(self)\n \n-    def on_json_loading_failed(self, e: t.Optional[ValueError]) -> t.Any:\n+    def on_json_loading_failed(self, e: ValueError | None) -> t.Any:\n         try:\n             return super().on_json_loading_failed(e)\n         except BadRequest as e:\n@@ -151,7 +153,7 @@ class Response(ResponseBase):\n         Added :attr:`max_cookie_size`.\n     \"\"\"\n \n-    default_mimetype: t.Optional[str] = \"text/html\"\n+    default_mimetype: str | None = \"text/html\"\n \n     json_module = json\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
