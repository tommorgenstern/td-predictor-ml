{"custom_id": "requests#a8555d811df0a4aaf2dd1f083ba0bc71679101ca", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 6 | Methods Changed: 4 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 14 | Churn Cumulative: 180 | Contributors (this commit): 1 | Commits (past 90d): 4 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -38,7 +38,7 @@ class CookieTests(TestBaseMixin, unittest.TestCase):\n         r = requests.get(\"http://github.com\")\n         c = r.cookies\n         # github should send us cookies\n-        self.assertGreaterEqual(len(c), 1)\n+        self.assertTrue(len(c) >= 1)\n \n         # github cookies should not be sent to httpbin.org:\n         r2 = requests.get(httpbin('cookies'), cookies=c)\n@@ -47,7 +47,7 @@ class CookieTests(TestBaseMixin, unittest.TestCase):\n         # let's do this again using the session object\n         s = requests.session()\n         s.get(\"http://github.com\")\n-        self.assertGreaterEqual(len(s.cookies), 1)\n+        self.assertTrue(len(s.cookies) >= 1)\n         r = s.get(httpbin('cookies'))\n         self.assertEqual(json.loads(r.text)['cookies'], {})\n         # we can set a cookie and get exactly that same-domain cookie back:\n@@ -79,12 +79,12 @@ class CookieTests(TestBaseMixin, unittest.TestCase):\n         r2 = requests.get(httpbin('cookies', 'set', 'very', 'well'), cookies=r.cookies)\n         expected_cookies = {'redirects': 'work', 'very': 'well'}\n         self.assertEqual(json.loads(r2.text)['cookies'], expected_cookies)\n-        self.assertIs(r.cookies, r2.cookies)\n+        self.assertTrue(r.cookies is r2.cookies)\n \n     def test_none_cookie(self):\n         \"\"\"Regression test: don't send a Cookie header with a string value of 'None'!\"\"\"\n         page = json.loads(requests.get(httpbin('headers')).text)\n-        self.assertNotIn('Cookie', page['headers'])\n+        self.assertTrue('Cookie' not in page['headers'])\n \n class LWPCookieJarTest(TestBaseMixin, unittest.TestCase):\n     \"\"\"Check store/load of cookies to FileCookieJar's, specifically LWPCookieJar's.\"\"\"\n@@ -142,12 +142,12 @@ class LWPCookieJarTest(TestBaseMixin, unittest.TestCase):\n         # github sets a cookie\n         requests.get(\"http://github.com\", cookies=cookiejar)\n         num_github_cookies = len(cookiejar)\n-        self.assertGreaterEqual(num_github_cookies, 1)\n+        self.assertTrue(num_github_cookies >= 1)\n         # httpbin sets another\n         requests.get(httpbin('cookies', 'set', 'key', 'value'), cookies=cookiejar)\n         num_total_cookies = len(cookiejar)\n-        self.assertGreaterEqual(num_total_cookies, 2)\n-        self.assertGreater(num_total_cookies, num_github_cookies)\n+        self.assertTrue(num_total_cookies >= 2)\n+        self.assertTrue(num_total_cookies > num_github_cookies)\n \n         # save and load\n         cookiejar.save(ignore_discard=True)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#853a07112b19fe6101ae5b6914e111230d465156", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 2 | Churn Cumulative: 5238 | Contributors (this commit): 58 | Commits (past 90d): 75 | Contributors (cumulative): 58 | DMM Complexity: 0.0\n\nDIFF:\n@@ -810,8 +810,6 @@ class Response(object):\n             #\n             # So we try blindly encoding.\n             content = str(self.content, errors='replace')\n-        except (UnicodeError, TypeError):\n-            pass\n \n         return content\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#41d1a427b06acd33ae69728f4dc63e56078719b0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 2 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 10 | Churn Cumulative: 524 | Contributors (this commit): 11 | Commits (past 90d): 30 | Contributors (cumulative): 11 | DMM Complexity: 1.0\n\nDIFF:\n@@ -847,5 +847,15 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n         r = requests.get(httpbin('status', '404'))\n         r.text\n \n+    def test_max_redirects(self):\n+        def unsafe_callable():\n+            requests.get(\"http://httpbin.org/redirect/3\", config=dict(max_redirects=2))\n+        self.assertRaises(requests.exceptions.TooManyRedirects, unsafe_callable)\n+\n+        # add safe mode\n+        response = requests.get(\"http://httpbin.org/redirect/3\", config=dict(safe_mode=True, max_redirects=2))\n+        self.assertTrue(response.content is None)\n+        self.assertTrue(isinstance(response.error, requests.exceptions.TooManyRedirects))\n+\n if __name__ == '__main__':\n     unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#9bf53676b87fa4951e23f67d2251f5dfae4e5206", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 2 | Churn Cumulative: 886 | Contributors (this commit): 14 | Commits (past 90d): 16 | Contributors (cumulative): 14 | DMM Complexity: 0.0\n\nDIFF:\n@@ -229,6 +229,8 @@ class Session(object):\n         r.send(prefetch=prefetch)\n \n         # Send any cookies back up the to the session.\n+        # (in safe mode, cookies may be None if the request didn't succeed)\n+        if r.response.cookies is not None:\n             for cookie in r.response.cookies:\n                 self.cookies.set_cookie(cookie)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#bcc4125a18f807bca14f4865e1770f9fc3b463f2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 3 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 689 | Contributors (this commit): 8 | Commits (past 90d): 23 | Contributors (cumulative): 11 | DMM Complexity: None\n\nDIFF:\n@@ -12,12 +12,14 @@ import hashlib\n \n from base64 import b64encode\n \n-from .compat import urlparse, str, is_py2\n+from .compat import urlparse, str\n from .utils import randombytes, parse_dict_header\n \n try:\n     from oauthlib.oauth1.rfc5849 import (Client, SIGNATURE_HMAC, SIGNATURE_TYPE_AUTH_HEADER)\n     from oauthlib.common import extract_params\n+    # hush pyflakes:\n+    SIGNATURE_HMAC; SIGNATURE_TYPE_AUTH_HEADER\n except (ImportError, SyntaxError):\n     SIGNATURE_HMAC = None\n     SIGNATURE_TYPE_AUTH_HEADER = None\n\n@@ -12,6 +12,8 @@ from requests.compat import is_py3\n \n try:\n     from setuptools import setup\n+    # hush pyflakes\n+    setup\n except ImportError:\n     from distutils.core import setup\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#35ec6bb613669dbbbba2afcc7aac4e467a5b4db8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 5239 | Contributors (this commit): 58 | Commits (past 90d): 74 | Contributors (cumulative): 58 | DMM Complexity: 0.0\n\nDIFF:\n@@ -526,6 +526,7 @@ class Request(object):\n                     conn = self._poolmanager.connection_from_url(url)\n                 else:\n                     conn = connectionpool.connection_from_url(url)\n+                    self.headers['Connection'] = 'close'\n             except LocationParseError as e:\n                 raise InvalidURL(e)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#0ba8c44260209ff518809a6b5b307d443e8dfe67", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 5/5 | Churn Δ: 16 | Churn Cumulative: 1337 | Contributors (this commit): 21 | Commits (past 90d): 31 | Contributors (cumulative): 21 | DMM Complexity: 1.0\n\nDIFF:\n@@ -446,3 +446,19 @@ def requote_uri(uri):\n     # Then quote only illegal characters (do not quote reserved, unreserved,\n     # or '%')\n     return quote(unquote_unreserved(uri), safe=\"!#$%&'()*+,/:;=?@[]~\")\n+\n+def get_environ_proxies():\n+    \"\"\"Return a dict of environment proxies.\"\"\"\n+\n+    proxy_keys = [\n+        'all',\n+        'http',\n+        'https',\n+        'ftp',\n+        'socks',\n+        'no'\n+    ]\n+\n+    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n+    proxies = [(key, get_proxy(key + '_proxy')) for key in proxy_keys]\n+    return dict([(key, val) for (key, val) in proxies if val])\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#abc38cf17f4e7149cff2da96fa364e4a5d39a632", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 5 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 7 | Churn Cumulative: 5246 | Contributors (this commit): 59 | Commits (past 90d): 75 | Contributors (cumulative): 59 | DMM Complexity: 1.0\n\nDIFF:\n@@ -28,7 +28,7 @@ from .exceptions import (\n     URLRequired, SSLError, MissingSchema, InvalidSchema, InvalidURL)\n from .utils import (\n     get_encoding_from_headers, stream_untransfer, guess_filename, requote_uri,\n-    stream_decode_response_unicode, get_netrc_auth,\n+    stream_decode_response_unicode, get_netrc_auth, get_environ_proxies,\n     DEFAULT_CA_BUNDLE_PATH)\n from .compat import (\n     cookielib, urlparse, urlunparse, urljoin, urlsplit, urlencode, str, bytes,\n@@ -112,10 +112,7 @@ class Request(object):\n         # If no proxies are given, allow configuration by environment variables\n         # HTTP_PROXY and HTTPS_PROXY.\n         if not self.proxies and self.config.get('trust_env'):\n-            if 'HTTP_PROXY' in os.environ:\n-                self.proxies['http'] = os.environ['HTTP_PROXY']\n-            if 'HTTPS_PROXY' in os.environ:\n-                self.proxies['https'] = os.environ['HTTPS_PROXY']\n+            self.proxies = get_environ_proxies()\n \n         self.data = data\n         self.params = params\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#8fedec785a9b8bb111384ebfcaf6d138a1c48979", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 44 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 6/6 | Churn Δ: 46 | Churn Cumulative: 768 | Contributors (this commit): 11 | Commits (past 90d): 37 | Contributors (cumulative): 12 | DMM Complexity: 1.0\n\nDIFF:\n@@ -86,6 +86,22 @@ class CookieTests(TestBaseMixin, unittest.TestCase):\n         page = json.loads(requests.get(httpbin('headers')).text)\n         self.assertTrue('Cookie' not in page['headers'])\n \n+    def test_secure_cookies(self):\n+        \"\"\"Test that secure cookies can only be sent via https.\"\"\"\n+        header = \"Set-Cookie: ThisIsA=SecureCookie; Path=/; Secure; HttpOnly\"\n+        url = 'https://httpbin.org/response-headers?%s' % (requests.utils.quote(header),)\n+        cookies = requests.get(url, verify=False).cookies\n+        self.assertEqual(len(cookies), 1)\n+        self.assertEqual(list(cookies)[0].secure, True)\n+\n+        secure_resp = requests.get('https://httpbin.org/cookies', cookies=cookies, verify=False)\n+        secure_cookies_sent = json.loads(secure_resp.text)['cookies']\n+        self.assertEqual(secure_cookies_sent, {'ThisIsA': 'SecureCookie'})\n+\n+        insecure_resp = requests.get('http://httpbin.org/cookies', cookies=cookies)\n+        insecure_cookies_sent = json.loads(insecure_resp.text)['cookies']\n+        self.assertEqual(insecure_cookies_sent, {})\n+\n class LWPCookieJarTest(TestBaseMixin, unittest.TestCase):\n     \"\"\"Check store/load of cookies to FileCookieJar's, specifically LWPCookieJar's.\"\"\"\n \n@@ -157,6 +173,31 @@ class LWPCookieJarTest(TestBaseMixin, unittest.TestCase):\n         r = requests.get(httpbin('cookies'), cookies=cookiejar_2)\n         self.assertEqual(json.loads(r.text)['cookies'], {'key': 'value'})\n \n+    def test_persistent_cookies(self):\n+        \"\"\"Test that we correctly interpret persistent cookies.\"\"\"\n+        # httpbin's normal cookie methods don't send persistent cookies,\n+        # so cook up the appropriate header and force it to send\n+        header = \"Set-Cookie: Persistent=CookiesAreScary; expires=Sun, 04-May-2032 04:56:50 GMT; path=/\"\n+        url = httpbin('response-headers?%s' % (requests.utils.quote(header),))\n+        cookiejar = self.COOKIEJAR_CLASS(self.cookiejar_filename)\n+\n+        requests.get(url, cookies=cookiejar)\n+        self.assertEqual(len(cookiejar), 1)\n+        self.assertCookieHas(list(cookiejar)[0], name='Persistent', value='CookiesAreScary')\n+\n+        requests.get(httpbin('cookies', 'set', 'ThisCookieIs', 'SessionOnly'), cookies=cookiejar)\n+        self.assertEqual(len(cookiejar), 2)\n+        self.assertEqual(len([c for c in cookiejar if c.name == 'Persistent']), 1)\n+        self.assertEqual(len([c for c in cookiejar if c.name == 'ThisCookieIs']), 1)\n+\n+        # save and load\n+        cookiejar.save()\n+        cookiejar_2 = self.COOKIEJAR_CLASS(self.cookiejar_filename)\n+        cookiejar_2.load()\n+        # we should only load the persistent cookie\n+        self.assertEqual(len(cookiejar_2), 1)\n+        self.assertCookieHas(list(cookiejar_2)[0], name='Persistent', value='CookiesAreScary')\n+\n class MozCookieJarTest(LWPCookieJarTest):\n     \"\"\"Same test, but substitute MozillaCookieJar.\"\"\"\n \n\n@@ -56,8 +56,9 @@ class TestBaseMixin(object):\n     def assertCookieHas(self, cookie, **kwargs):\n         \"\"\"Assert that a cookie has various specified properties.\"\"\"\n         for attr, expected_value in kwargs.items():\n-            message = 'Failed comparison for %s' % (attr,)\n-            self.assertEqual(getattr(cookie, attr), expected_value, message)\n+            cookie_attr = getattr(cookie, attr)\n+            message = 'Failed comparison for %s: %s != %s' % (attr, cookie_attr, expected_value)\n+            self.assertEqual(cookie_attr, expected_value, message)\n \n class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n     \"\"\"Requests test cases.\"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#ed7b14899fcc196acb5631819585dcc2be1b41f7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 18 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 6/4 | Churn Δ: 19 | Churn Cumulative: 5812 | Contributors (this commit): 61 | Commits (past 90d): 132 | Contributors (cumulative): 72 | DMM Complexity: 0.8181818181818182\n\nDIFF:\n@@ -32,7 +32,7 @@ from .utils import (\n     DEFAULT_CA_BUNDLE_PATH)\n from .compat import (\n     cookielib, urlparse, urlunparse, urljoin, urlsplit, urlencode, str, bytes,\n-    is_py2)\n+    StringIO, is_py2)\n \n # Import chardet if it is available.\n try:\n@@ -348,6 +348,8 @@ class Request(object):\n             else:\n                 fn = guess_filename(v) or k\n                 fp = v\n+            if isinstance(fp, bytes):\n+                fp = StringIO(fp)\n             fields.update({k: (fn, fp.read())})\n \n         (body, content_type) = encode_multipart_formdata(fields)\n\n@@ -329,6 +329,21 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n \n             self.assertEqual(post2.status_code, 200)\n \n+    def test_POSTBIN_GET_POST_FILES_STRINGS(self):\n+\n+        for service in SERVICES:\n+\n+            url = service('post')\n+\n+            post1 = post(url, files={'fname.txt': 'fdata'})\n+            self.assertEqual(post1.status_code, 200)\n+\n+            post2 = post(url, files={'fname.txt': 'fdata', 'fname2.txt':'more fdata'})\n+            self.assertEqual(post2.status_code, 200)\n+\n+            post3 = post(url, files={'fname.txt': 'fdata', 'fname2.txt':open(__file__,'rb')})\n+            self.assertEqual(post3.status_code, 200)\n+\n     def test_nonzero_evaluation(self):\n \n         for service in SERVICES:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#3288426f2bb4fc52f58ea6422444bc013ce31a8c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 11 | Churn Cumulative: 5823 | Contributors (this commit): 61 | Commits (past 90d): 134 | Contributors (cumulative): 72 | DMM Complexity: 1.0\n\nDIFF:\n@@ -348,7 +348,7 @@ class Request(object):\n             else:\n                 fn = guess_filename(v) or k\n                 fp = v\n-            if isinstance(fp, bytes):\n+            if isinstance(fp, (bytes, str)):\n                 fp = StringIO(fp)\n             fields.update({k: (fn, fp.read())})\n \n\n@@ -344,6 +344,15 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n             post3 = post(url, files={'fname.txt': 'fdata', 'fname2.txt':open(__file__,'rb')})\n             self.assertEqual(post3.status_code, 200)\n \n+            post4 = post(url, files={'fname.txt': u'fdata'})\n+            self.assertEqual(post4.status_code, 200)\n+\n+            post5 = post(url, files={'file': ('file.txt', 'more fdata')})\n+            self.assertEqual(post5.status_code, 200)\n+\n+            post6 = post(url, files={'fname.txt': u'\\xe9'})\n+            self.assertEqual(post6.status_code, 200)\n+\n     def test_nonzero_evaluation(self):\n \n         for service in SERVICES:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#64eb415ec0595f4ee5a59578dbbbb99200755c49", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 575 | Contributors (this commit): 12 | Commits (past 90d): 35 | Contributors (cumulative): 12 | DMM Complexity: None\n\nDIFF:\n@@ -344,13 +344,13 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n             post3 = post(url, files={'fname.txt': 'fdata', 'fname2.txt':open(__file__,'rb')})\n             self.assertEqual(post3.status_code, 200)\n \n-            post4 = post(url, files={'fname.txt': u'fdata'})\n+            post4 = post(url, files={'fname.txt': 'fdata'})\n             self.assertEqual(post4.status_code, 200)\n \n             post5 = post(url, files={'file': ('file.txt', 'more fdata')})\n             self.assertEqual(post5.status_code, 200)\n \n-            post6 = post(url, files={'fname.txt': u'\\xe9'})\n+            post6 = post(url, files={'fname.txt': '\\xe9'})\n             self.assertEqual(post6.status_code, 200)\n \n     def test_nonzero_evaluation(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b06690270500c9b550c989ed3ddf0115808e8796", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 7 | Churn Cumulative: 582 | Contributors (this commit): 12 | Commits (past 90d): 36 | Contributors (cumulative): 12 | DMM Complexity: 1.0\n\nDIFF:\n@@ -353,6 +353,13 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n             post6 = post(url, files={'fname.txt': '\\xe9'})\n             self.assertEqual(post6.status_code, 200)\n \n+            post7 = post(url, files={'fname.txt': 'fdata to verify'})\n+            rbody = json.loads(post7.text)\n+            self.assertTrue(rbody.get('files', None))\n+            self.assertTrue(rbody['files'].get('fname.txt'), None)\n+            self.assertEqual(rbody['files']['fname.txt'], 'fdata to verify')\n+\n+\n     def test_nonzero_evaluation(self):\n \n         for service in SERVICES:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#fe7348cc530fab7375939dce9672a05c6864a2fa", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 11 | Churn Cumulative: 5263 | Contributors (this commit): 60 | Commits (past 90d): 78 | Contributors (cumulative): 60 | DMM Complexity: 1.0\n\nDIFF:\n@@ -7,6 +7,7 @@ requests.models\n This module contains the primary objects that power Requests.\n \"\"\"\n \n+import json\n import os\n from datetime import datetime\n \n@@ -796,8 +797,6 @@ class Response(object):\n         if self.encoding is None:\n             if chardet is not None:\n                 encoding = chardet.detect(self.content)['encoding']\n-            else:\n-                raise ValueError(\"Can't detect page encoding.\")\n \n         # Decode unicode from given encoding.\n         try:\n@@ -811,6 +810,14 @@ class Response(object):\n \n         return content\n \n+    @property\n+    def json(self):\n+        \"\"\"Returns the json-encoded content of a request, if any.\"\"\"\n+        try:\n+            return json.loads(self.text or self.content)\n+        except ValueError:\n+            return None\n+\n     def raise_for_status(self, allow_redirects=True):\n         \"\"\"Raises stored :class:`HTTPError` or :class:`URLError`, if one occurred.\"\"\"\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#6b09e6ee347ea435e4d6199c533a5fc44b39c535", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 5 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 6 | Churn Cumulative: 5269 | Contributors (this commit): 60 | Commits (past 90d): 79 | Contributors (cumulative): 60 | DMM Complexity: 0.0\n\nDIFF:\n@@ -236,6 +236,7 @@ class Request(object):\n \n                 url = r.headers['location']\n                 data = self.data\n+                files = self.files\n \n                 # Handle redirection without scheme (see: RFC 1808 Section 4)\n                 if url.startswith('//'):\n@@ -254,6 +255,7 @@ class Request(object):\n                 if r.status_code is codes.see_other:\n                     method = 'GET'\n                     data = None\n+                    files = None\n                 else:\n                     method = self.method\n \n@@ -263,10 +265,12 @@ class Request(object):\n                     if r.status_code in (codes.moved, codes.found) and self.method == 'POST':\n                         method = 'GET'\n                         data = None\n+                        files = None\n \n                     if (r.status_code == 303) and self.method != 'HEAD':\n                         method = 'GET'\n                         data = None\n+                        files = None\n \n                 # Remove the cookie headers that were sent.\n                 headers = self.headers\n@@ -278,7 +282,7 @@ class Request(object):\n                 request = Request(\n                     url=url,\n                     headers=headers,\n-                    files=self.files,\n+                    files=files,\n                     method=method,\n                     params=self.session.params,\n                     auth=self.auth,\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#bca920c1c1a96e191ec7f9fcaec5f53e46edf08e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 341 | Contributors (this commit): 3 | Commits (past 90d): 12 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -15,8 +15,8 @@ requests\n \"\"\"\n \n __title__ = 'requests'\n-__version__ = '0.12.0'\n-__build__ = 0x001200\n+__version__ = '0.12.01'\n+__build__ = 0x001201\n __author__ = 'Kenneth Reitz'\n __license__ = 'ISC'\n __copyright__ = 'Copyright 2012 Kenneth Reitz'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#a3a928c7f173ceab284a3e01ded04c1d0fd91189", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 343 | Contributors (this commit): 3 | Commits (past 90d): 13 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -15,7 +15,7 @@ requests\n \"\"\"\n \n __title__ = 'requests'\n-__version__ = '0.12.01'\n+__version__ = '0.12.1'\n __build__ = 0x001201\n __author__ = 'Kenneth Reitz'\n __license__ = 'ISC'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#56ef079e6fac587cdd367c0442f1c7ebe5fe54b7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 10 | Churn Cumulative: 592 | Contributors (this commit): 12 | Commits (past 90d): 37 | Contributors (cumulative): 12 | DMM Complexity: 1.0\n\nDIFF:\n@@ -726,6 +726,16 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n         assert params3['b'] in r3.text\n         assert params3['c'] in r3.text\n \n+    def test_session_cookies_with_return_response_false(self):\n+        s = requests.session()\n+        # return_response=False as it does requests.async.get\n+        rq = get(httpbin('cookies', 'set', 'k', 'v'), return_response=False,\n+                 allow_redirects=True, session=s)\n+        rq.send(prefetch=True)\n+        c = rq.response.json.get('cookies')\n+        assert 'k' in c\n+        assert 'k' in s.cookies\n+\n     def test_session_pickling(self):\n \n         s = requests.session(\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#975430d5e622b9815e42963c3c0b0704e7d5a39c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 10 | Churn Cumulative: 21 | Contributors (this commit): 4 | Commits (past 90d): 4 | Contributors (cumulative): 4 | DMM Complexity: 1.0\n\nDIFF:\n@@ -12,6 +12,7 @@ import select\n has_poll = hasattr(select, \"poll\")\n \n from requests import async\n+import requests\n \n sys.path.append('.')\n from test_requests import httpbin, RequestsTestSuite, SERVICES\n@@ -63,5 +64,14 @@ class RequestsTestSuiteUsingAsyncApi(RequestsTestSuite):\n         \"\"\"Test to make sure we don't overwrite the poll\"\"\"\n         self.assertEqual(hasattr(select, \"poll\"), has_poll)\n \n+    def test_async_with_session_cookies(self):\n+        s = requests.Session(cookies={'initial': '42'})\n+        r1 = get(httpbin('cookies/set/async/yes'), session=s)\n+        r2 = get(httpbin('cookies/set/no_session/yes'))\n+        assert 'initial' in r1.cookies\n+        assert 'initial' not in r2.cookies and 'async' not in r2.cookies\n+        assert 'async' in s.cookies\n+        assert 'no_session' not in s.cookies\n+\n if __name__ == '__main__':\n     unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#33f10875848021071cf4328280fd5114fe8dc151", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 6 | Files Changed: 2 | Hunks: 2 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/2 | Churn Δ: 12 | Churn Cumulative: 6167 | Contributors (this commit): 63 | Commits (past 90d): 96 | Contributors (cumulative): 74 | DMM Complexity: 1.0\n\nDIFF:\n@@ -203,6 +203,12 @@ class Request(object):\n                 # Save cookies in Response.\n                 response.cookies = self.cookies\n \n+                # Save cookies in Session.\n+                # (in safe mode, cookies may be None if the request didn't succeed)\n+                if self.cookies is not None:\n+                    for cookie in self.cookies:\n+                        self.session.cookies.set_cookie(cookie)\n+\n                 # No exceptions were harmed in the making of this request.\n                 response.error = getattr(resp, 'error', None)\n \n\n@@ -228,12 +228,6 @@ class Session(object):\n         # Send the HTTP Request.\n         r.send(prefetch=prefetch)\n \n-        # Send any cookies back up the to the session.\n-        # (in safe mode, cookies may be None if the request didn't succeed)\n-        if r.response.cookies is not None:\n-            for cookie in r.response.cookies:\n-                self.cookies.set_cookie(cookie)\n-\n         # Return the response.\n         return r.response\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#cff70e75b77ab61a8a57a25a4921acc5a5ef6ce1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 40 | Lines Deleted: 25 | Files Changed: 4 | Hunks: 9 | Methods Changed: 6 | Complexity Δ (Sum/Max): 1/7 | Churn Δ: 65 | Churn Cumulative: 6634 | Contributors (this commit): 65 | Commits (past 90d): 92 | Contributors (cumulative): 82 | DMM Complexity: 1.0\n\nDIFF:\n@@ -12,7 +12,9 @@ This module implements the Requests API.\n \"\"\"\n \n from . import sessions\n+from .safe_mode import catch_exceptions_if_in_safe_mode\n \n+@catch_exceptions_if_in_safe_mode\n def request(method, url, **kwargs):\n     \"\"\"Constructs and sends a :class:`Request <Request>`.\n     Returns :class:`Response <Response>` object.\n\n@@ -94,9 +94,6 @@ def extract_cookies_to_jar(jar, request, response):\n     :param response: urllib3.HTTPResponse object\n     \"\"\"\n     # the _original_response field is the wrapped httplib.HTTPResponse object,\n-    # and in safe mode, it may be None if the request didn't actually complete.\n-    # in that case, just skip the cookie extraction.\n-    if response._original_response is not None:\n     req = MockRequest(request)\n     # pull out the HTTPMessage with the headers and put it in the mock:\n     res = MockResponse(response._original_response.msg)\n\n@@ -204,8 +204,6 @@ class Request(object):\n                 response.cookies = self.cookies\n \n                 # Save cookies in Session.\n-                # (in safe mode, cookies may be None if the request didn't succeed)\n-                if self.cookies is not None:\n                 for cookie in self.cookies:\n                     self.session.cookies.set_cookie(cookie)\n \n@@ -587,10 +585,7 @@ class Request(object):\n             r = dispatch_hook('pre_send', self.hooks, self)\n             self.__dict__.update(r.__dict__)\n \n-            try:\n-                # The inner try .. except re-raises certain exceptions as\n-                # internal exception types; the outer suppresses exceptions\n-                # when safe mode is set.\n+            # catch urllib3 exceptions and throw Requests exceptions\n             try:\n                 # Send the request.\n                 r = conn.urlopen(\n@@ -616,24 +611,8 @@ class Request(object):\n \n                 raise Timeout('Request timed out.')\n \n-            except RequestException as e:\n-                if self.config.get('safe_mode', False):\n-                    # In safe mode, catch the exception and attach it to\n-                    # a blank urllib3.HTTPResponse object.\n-                    r = HTTPResponse()\n-                    r.error = e\n-                else:\n-                    raise\n-\n             # build_response can throw TooManyRedirects\n-            try:\n             self._build_response(r)\n-            except RequestException as e:\n-                if self.config.get('safe_mode', False):\n-                    # In safe mode, catch the exception\n-                    self.response.error = e\n-                else:\n-                    raise\n \n             # Response manipulation hook.\n             self.response = dispatch_hook('response', self.hooks, self.response)\n\n@@ -0,0 +1,37 @@\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+requests.safe_mode\n+~~~~~~~~~~~~\n+\n+This module contains a decorator that implements safe_mode.\n+\n+:copyright: (c) 2012 by Kenneth Reitz.\n+:license: ISC, see LICENSE for more details.\n+\n+\"\"\"\n+\n+from .models import Response\n+from .exceptions import RequestException, ConnectionError, HTTPError\n+from .packages.urllib3.response import HTTPResponse\n+\n+def catch_exceptions_if_in_safe_mode(function):\n+    \"\"\"New implementation of safe_mode. We catch all exceptions at the API level\n+    and then return a blank Response object with the error field filled. This decorator\n+    wraps request() in api.py.\n+    \"\"\"\n+    \n+    def wrapped(method, url, **kwargs):\n+        # if save_mode, we catch exceptions and fill error field\n+        if (kwargs.get('config') and kwargs.get('config').get('safe_mode')) or (kwargs.get('session') \n+                                            and kwargs.get('session').config.get('safe_mode')):\n+            try:\n+                return function(method, url, **kwargs)\n+            except (RequestException, ConnectionError, HTTPError) as e:\n+                r = Response()\n+                r.error = e\n+                r.raw = HTTPResponse() # otherwise, tests fail\n+                r.status_code = 0 # with this status_code, content returns None\n+                return r\n+        return function(method, url, **kwargs)\n+    return wrapped\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#db43eb4cb9fcd1ad5565cc2bff5b8cdfec549648", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 42 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -12,8 +12,9 @@ This module contains a decorator that implements safe_mode.\n \"\"\"\n \n from .models import Response\n-from .exceptions import RequestException, ConnectionError, HTTPError\n from .packages.urllib3.response import HTTPResponse\n+from .exceptions import RequestException, ConnectionError, HTTPError\n+import socket\n \n def catch_exceptions_if_in_safe_mode(function):\n     \"\"\"New implementation of safe_mode. We catch all exceptions at the API level\n@@ -27,7 +28,7 @@ def catch_exceptions_if_in_safe_mode(function):\n                                             and kwargs.get('session').config.get('safe_mode')):\n             try:\n                 return function(method, url, **kwargs)\n-            except (RequestException, ConnectionError, HTTPError) as e:\n+            except (RequestException, ConnectionError, HTTPError, socket.timeout) as e:\n                 r = Response()\n                 r.error = e\n                 r.raw = HTTPResponse() # otherwise, tests fail\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#44663b5e8e54f170b4633307b79b1be69fd49f64", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 2 | Churn Cumulative: 287 | Contributors (this commit): 3 | Commits (past 90d): 6 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -140,7 +140,7 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n     Unlike a regular CookieJar, this class is pickleable.\n     \"\"\"\n \n-    def get(self, name, domain=None, path=None, default=None):\n+    def get(self, name, default=None, domain=None, path=None):\n         try:\n             return self._find(name, domain, path)\n         except KeyError:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#32327f8f7c2f457d38130b5df664ec8f29cf3053", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 106 | Files Changed: 1 | Hunks: 1 | Methods Changed: 6 | Complexity Δ (Sum/Max): -11/0 | Churn Δ: 106 | Churn Cumulative: 576 | Contributors (this commit): 11 | Commits (past 90d): 3 | Contributors (cumulative): 11 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,106 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-requests.async\n-~~~~~~~~~~~~~~\n-\n-This module contains an asynchronous replica of ``requests.api``, powered\n-by gevent. All API methods return a ``Request`` instance (as opposed to\n-``Response``). A list of requests can be sent with ``map()``.\n-\"\"\"\n-\n-try:\n-    import gevent\n-    from gevent import monkey as curious_george\n-    from gevent.pool import Pool\n-except ImportError:\n-    raise RuntimeError('Gevent is required for requests.async.')\n-\n-# Monkey-patch.\n-curious_george.patch_all(thread=False, select=False)\n-\n-from . import api\n-\n-\n-__all__ = (\n-    'map', 'imap',\n-    'get', 'options', 'head', 'post', 'put', 'patch', 'delete', 'request'\n-)\n-\n-\n-def patched(f):\n-    \"\"\"Patches a given API function to not send.\"\"\"\n-\n-    def wrapped(*args, **kwargs):\n-\n-        kwargs['return_response'] = False\n-        kwargs['prefetch'] = True\n-\n-        config = kwargs.get('config', {})\n-        config.update(safe_mode=True)\n-\n-        kwargs['config'] = config\n-\n-        return f(*args, **kwargs)\n-\n-    return wrapped\n-\n-\n-def send(r, pool=None, prefetch=False):\n-    \"\"\"Sends the request object using the specified pool. If a pool isn't\n-    specified this method blocks. Pools are useful because you can specify size\n-    and can hence limit concurrency.\"\"\"\n-\n-    if pool != None:\n-        return pool.spawn(r.send, prefetch=prefetch)\n-\n-    return gevent.spawn(r.send, prefetch=prefetch)\n-\n-\n-# Patched requests.api functions.\n-get = patched(api.get)\n-options = patched(api.options)\n-head = patched(api.head)\n-post = patched(api.post)\n-put = patched(api.put)\n-patch = patched(api.patch)\n-delete = patched(api.delete)\n-request = patched(api.request)\n-\n-\n-def map(requests, prefetch=True, size=None):\n-    \"\"\"Concurrently converts a list of Requests to Responses.\n-\n-    :param requests: a collection of Request objects.\n-    :param prefetch: If False, the content will not be downloaded immediately.\n-    :param size: Specifies the number of requests to make at a time. If None, no throttling occurs.\n-    \"\"\"\n-\n-    requests = list(requests)\n-\n-    pool = Pool(size) if size else None\n-    jobs = [send(r, pool, prefetch=prefetch) for r in requests]\n-    gevent.joinall(jobs)\n-\n-    return [r.response for r in requests]\n-\n-\n-def imap(requests, prefetch=True, size=2):\n-    \"\"\"Concurrently converts a generator object of Requests to\n-    a generator of Responses.\n-\n-    :param requests: a generator of Request objects.\n-    :param prefetch: If False, the content will not be downloaded immediately.\n-    :param size: Specifies the number of requests to make at a time. default is 2\n-    \"\"\"\n-\n-    pool = Pool(size)\n-\n-    def send(r):\n-        r.send(prefetch)\n-        return r.response\n-\n-    for r in pool.imap_unordered(send, requests):\n-        yield r\n-\n-    pool.join()\n\\ No newline at end of file\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#07f6675376a1772d3024a5fbc46c8bb296710b41", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 77 | Files Changed: 1 | Hunks: 1 | Methods Changed: 5 | Complexity Δ (Sum/Max): -6/0 | Churn Δ: 77 | Churn Cumulative: 98 | Contributors (this commit): 4 | Commits (past 90d): 5 | Contributors (cumulative): 4 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,77 +0,0 @@\n-#!/usr/bin/env python\n-# -*- coding: utf-8 -*-\n-\n-# Path hack.\n-import sys, os\n-sys.path.insert(0, os.path.abspath('..'))\n-\n-import sys\n-import unittest\n-\n-import select\n-has_poll = hasattr(select, \"poll\")\n-\n-from requests import async\n-import requests\n-\n-sys.path.append('.')\n-from test_requests import httpbin, RequestsTestSuite, SERVICES\n-\n-\n-class RequestsTestSuiteUsingAsyncApi(RequestsTestSuite):\n-    \"\"\"Requests async test cases.\"\"\"\n-\n-    def patched(f):\n-        \"\"\"Automatically send request after creation.\"\"\"\n-\n-        def wrapped(*args, **kwargs):\n-\n-            request = f(*args, **kwargs)\n-            return async.map([request])[0]\n-\n-        return wrapped\n-\n-    # Patched requests.api functions.\n-    global request\n-    request = patched(async.request)\n-\n-    global delete, get, head, options, patch, post, put\n-    delete = patched(async.delete)\n-    get = patched(async.get)\n-    head = patched(async.head)\n-    options = patched(async.options)\n-    patch = patched(async.patch)\n-    post = patched(async.post)\n-    put = patched(async.put)\n-\n-\n-    def test_entry_points(self):\n-\n-        async.request\n-\n-        async.delete\n-        async.get\n-        async.head\n-        async.options\n-        async.patch\n-        async.post\n-        async.put\n-\n-        async.map\n-        async.send\n-\n-    def test_select_poll(self):\n-        \"\"\"Test to make sure we don't overwrite the poll\"\"\"\n-        self.assertEqual(hasattr(select, \"poll\"), has_poll)\n-\n-    def test_async_with_session_cookies(self):\n-        s = requests.Session(cookies={'initial': '42'})\n-        r1 = get(httpbin('cookies/set/async/yes'), session=s)\n-        r2 = get(httpbin('cookies/set/no_session/yes'))\n-        assert 'initial' in r1.cookies\n-        assert 'initial' not in r2.cookies and 'async' not in r2.cookies\n-        assert 'async' in s.cookies\n-        assert 'no_session' not in s.cookies\n-\n-if __name__ == '__main__':\n-    unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#15694fa2f7cc18f256dc2866e6206686de1ab795", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 7 | Churn Cumulative: 239 | Contributors (this commit): 5 | Commits (past 90d): 10 | Contributors (cumulative): 5 | DMM Complexity: None\n\nDIFF:\n@@ -47,12 +47,6 @@ else:\n \n requires.append(chardet_package)\n \n-# The async API in requests.async requires the gevent package.\n-# This is also not a required dependency.\n-extras_require = {\n-        'async': ['gevent'],\n-}\n-\n setup(\n     name='requests',\n     version=requests.__version__,\n@@ -66,7 +60,6 @@ setup(\n     package_data={'': ['LICENSE', 'NOTICE']},\n     include_package_data=True,\n     install_requires=requires,\n-    extras_require=extras_require,\n     license=open(\"LICENSE\").read(),\n     classifiers=(\n         'Development Status :: 5 - Production/Stable',\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#3ee594140bb5bbbb8553cbd20c99c116d1954c0f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 1196 | Files Changed: 4 | Hunks: 4 | Methods Changed: 52 | Complexity Δ (Sum/Max): -140/0 | Churn Δ: 1196 | Churn Cumulative: 2431 | Contributors (this commit): 5 | Commits (past 90d): 10 | Contributors (cumulative): 8 | DMM Complexity: 0.29376854599406527\n\nDIFF:\n@@ -1,3 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-from .core import dict_from_string\n\\ No newline at end of file\n\n@@ -1,24 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-oreos.core\n-~~~~~~~~~~\n-\n-The creamy white center.\n-\"\"\"\n-\n-from .monkeys import SimpleCookie\n-\n-\n-def dict_from_string(s):\n-    \"\"\"Returns a MultiDict with Cookies.\"\"\"\n-\n-    cookies = dict()\n-\n-    c = SimpleCookie()\n-    c.load(s)\n-\n-    for k,v in c.items():\n-        cookies.update({k: v.value})\n-\n-    return cookies\n\\ No newline at end of file\n\n@@ -1,773 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-oreos.monkeys\n-~~~~~~~~~~~~~\n-\n-Monkeypatches.\n-\"\"\"\n-#!/usr/bin/env python\n-#\n-\n-####\n-# Copyright 2000 by Timothy O'Malley <timo@alum.mit.edu>\n-#\n-#                All Rights Reserved\n-#\n-# Permission to use, copy, modify, and distribute this software\n-# and its documentation for any purpose and without fee is hereby\n-# granted, provided that the above copyright notice appear in all\n-# copies and that both that copyright notice and this permission\n-# notice appear in supporting documentation, and that the name of\n-# Timothy O'Malley  not be used in advertising or publicity\n-# pertaining to distribution of the software without specific, written\n-# prior permission.\n-#\n-# Timothy O'Malley DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n-# SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n-# AND FITNESS, IN NO EVENT SHALL Timothy O'Malley BE LIABLE FOR\n-# ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n-# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n-# PERFORMANCE OF THIS SOFTWARE.\n-#\n-####\n-#\n-# Id: Cookie.py,v 2.29 2000/08/23 05:28:49 timo Exp\n-#   by Timothy O'Malley <timo@alum.mit.edu>\n-#\n-#  Cookie.py is a Python module for the handling of HTTP\n-#  cookies as a Python dictionary.  See RFC 2109 for more\n-#  information on cookies.\n-#\n-#  The original idea to treat Cookies as a dictionary came from\n-#  Dave Mitchell (davem@magnet.com) in 1995, when he released the\n-#  first version of nscookie.py.\n-#\n-####\n-\n-r\"\"\"\n-Here's a sample session to show how to use this module.\n-At the moment, this is the only documentation.\n-\n-The Basics\n-----------\n-\n-Importing is easy..\n-\n-   >>> import Cookie\n-\n-Most of the time you start by creating a cookie.  Cookies come in\n-three flavors, each with slightly different encoding semantics, but\n-more on that later.\n-\n-   >>> C = Cookie.SimpleCookie()\n-   >>> C = Cookie.SerialCookie()\n-   >>> C = Cookie.SmartCookie()\n-\n-[Note: Long-time users of Cookie.py will remember using\n-Cookie.Cookie() to create an Cookie object.  Although deprecated, it\n-is still supported by the code.  See the Backward Compatibility notes\n-for more information.]\n-\n-Once you've created your Cookie, you can add values just as if it were\n-a dictionary.\n-\n-   >>> C = Cookie.SmartCookie()\n-   >>> C[\"fig\"] = \"newton\"\n-   >>> C[\"sugar\"] = \"wafer\"\n-   >>> C.output()\n-   'Set-Cookie: fig=newton\\r\\nSet-Cookie: sugar=wafer'\n-\n-Notice that the printable representation of a Cookie is the\n-appropriate format for a Set-Cookie: header.  This is the\n-default behavior.  You can change the header and printed\n-attributes by using the .output() function\n-\n-   >>> C = Cookie.SmartCookie()\n-   >>> C[\"rocky\"] = \"road\"\n-   >>> C[\"rocky\"][\"path\"] = \"/cookie\"\n-   >>> print C.output(header=\"Cookie:\")\n-   Cookie: rocky=road; Path=/cookie\n-   >>> print C.output(attrs=[], header=\"Cookie:\")\n-   Cookie: rocky=road\n-\n-The load() method of a Cookie extracts cookies from a string.  In a\n-CGI script, you would use this method to extract the cookies from the\n-HTTP_COOKIE environment variable.\n-\n-   >>> C = Cookie.SmartCookie()\n-   >>> C.load(\"chips=ahoy; vienna=finger\")\n-   >>> C.output()\n-   'Set-Cookie: chips=ahoy\\r\\nSet-Cookie: vienna=finger'\n-\n-The load() method is darn-tootin smart about identifying cookies\n-within a string.  Escaped quotation marks, nested semicolons, and other\n-such trickeries do not confuse it.\n-\n-   >>> C = Cookie.SmartCookie()\n-   >>> C.load('keebler=\"E=everybody; L=\\\\\"Loves\\\\\"; fudge=\\\\012;\";')\n-   >>> print C\n-   Set-Cookie: keebler=\"E=everybody; L=\\\"Loves\\\"; fudge=\\012;\"\n-\n-Each element of the Cookie also supports all of the RFC 2109\n-Cookie attributes.  Here's an example which sets the Path\n-attribute.\n-\n-   >>> C = Cookie.SmartCookie()\n-   >>> C[\"oreo\"] = \"doublestuff\"\n-   >>> C[\"oreo\"][\"path\"] = \"/\"\n-   >>> print C\n-   Set-Cookie: oreo=doublestuff; Path=/\n-\n-Each dictionary element has a 'value' attribute, which gives you\n-back the value associated with the key.\n-\n-   >>> C = Cookie.SmartCookie()\n-   >>> C[\"twix\"] = \"none for you\"\n-   >>> C[\"twix\"].value\n-   'none for you'\n-\n-\n-A Bit More Advanced\n--------------------\n-\n-As mentioned before, there are three different flavors of Cookie\n-objects, each with different encoding/decoding semantics.  This\n-section briefly discusses the differences.\n-\n-SimpleCookie\n-\n-The SimpleCookie expects that all values should be standard strings.\n-Just to be sure, SimpleCookie invokes the str() builtin to convert\n-the value to a string, when the values are set dictionary-style.\n-\n-   >>> C = Cookie.SimpleCookie()\n-   >>> C[\"number\"] = 7\n-   >>> C[\"string\"] = \"seven\"\n-   >>> C[\"number\"].value\n-   '7'\n-   >>> C[\"string\"].value\n-   'seven'\n-   >>> C.output()\n-   'Set-Cookie: number=7\\r\\nSet-Cookie: string=seven'\n-\n-\n-SerialCookie\n-\n-The SerialCookie expects that all values should be serialized using\n-cPickle (or pickle, if cPickle isn't available).  As a result of\n-serializing, SerialCookie can save almost any Python object to a\n-value, and recover the exact same object when the cookie has been\n-returned.  (SerialCookie can yield some strange-looking cookie\n-values, however.)\n-\n-   >>> C = Cookie.SerialCookie()\n-   >>> C[\"number\"] = 7\n-   >>> C[\"string\"] = \"seven\"\n-   >>> C[\"number\"].value\n-   7\n-   >>> C[\"string\"].value\n-   'seven'\n-   >>> C.output()\n-   'Set-Cookie: number=\"I7\\\\012.\"\\r\\nSet-Cookie: string=\"S\\'seven\\'\\\\012p1\\\\012.\"'\n-\n-Be warned, however, if SerialCookie cannot de-serialize a value (because\n-it isn't a valid pickle'd object), IT WILL RAISE AN EXCEPTION.\n-\n-\n-SmartCookie\n-\n-The SmartCookie combines aspects of each of the other two flavors.\n-When setting a value in a dictionary-fashion, the SmartCookie will\n-serialize (ala cPickle) the value *if and only if* it isn't a\n-Python string.  String objects are *not* serialized.  Similarly,\n-when the load() method parses out values, it attempts to de-serialize\n-the value.  If it fails, then it fallsback to treating the value\n-as a string.\n-\n-   >>> C = Cookie.SmartCookie()\n-   >>> C[\"number\"] = 7\n-   >>> C[\"string\"] = \"seven\"\n-   >>> C[\"number\"].value\n-   7\n-   >>> C[\"string\"].value\n-   'seven'\n-   >>> C.output()\n-   'Set-Cookie: number=\"I7\\\\012.\"\\r\\nSet-Cookie: string=seven'\n-\n-\n-Backwards Compatibility\n------------------------\n-\n-In order to keep compatibilty with earlier versions of Cookie.py,\n-it is still possible to use Cookie.Cookie() to create a Cookie.  In\n-fact, this simply returns a SmartCookie.\n-\n-   >>> C = Cookie.Cookie()\n-   >>> print C.__class__.__name__\n-   SmartCookie\n-\n-\n-Finis.\n-\"\"\"  #\"\n-#     ^\n-#     |----helps out font-lock\n-\n-#\n-# Import our required modules\n-#\n-import string\n-\n-try:\n-    from cPickle import dumps, loads\n-except ImportError:\n-    from pickle import dumps, loads\n-\n-import re, warnings\n-\n-__all__ = [\"CookieError\",\"BaseCookie\",\"SimpleCookie\",\"SerialCookie\",\n-           \"SmartCookie\",\"Cookie\"]\n-\n-_nulljoin = ''.join\n-_semispacejoin = '; '.join\n-_spacejoin = ' '.join\n-\n-#\n-# Define an exception visible to External modules\n-#\n-class CookieError(Exception):\n-    pass\n-\n-\n-# These quoting routines conform to the RFC2109 specification, which in\n-# turn references the character definitions from RFC2068.  They provide\n-# a two-way quoting algorithm.  Any non-text character is translated\n-# into a 4 character sequence: a forward-slash followed by the\n-# three-digit octal equivalent of the character.  Any '\\' or '\"' is\n-# quoted with a preceeding '\\' slash.\n-#\n-# These are taken from RFC2068 and RFC2109.\n-#       _RFC2965Forbidden is the list of forbidden chars we accept anyway\n-#       _LegalChars       is the list of chars which don't require \"'s\n-#       _Translator       hash-table for fast quoting\n-#\n-_RFC2965Forbidden = \"[]:{}=\"\n-_LegalChars       = ( string.ascii_letters + string.digits + \n-                      \"!#$%&'*+-.^_`|~_@\" + _RFC2965Forbidden )\n-_Translator       = {\n-    '\\000' : '\\\\000',  '\\001' : '\\\\001',  '\\002' : '\\\\002',\n-    '\\003' : '\\\\003',  '\\004' : '\\\\004',  '\\005' : '\\\\005',\n-    '\\006' : '\\\\006',  '\\007' : '\\\\007',  '\\010' : '\\\\010',\n-    '\\011' : '\\\\011',  '\\012' : '\\\\012',  '\\013' : '\\\\013',\n-    '\\014' : '\\\\014',  '\\015' : '\\\\015',  '\\016' : '\\\\016',\n-    '\\017' : '\\\\017',  '\\020' : '\\\\020',  '\\021' : '\\\\021',\n-    '\\022' : '\\\\022',  '\\023' : '\\\\023',  '\\024' : '\\\\024',\n-    '\\025' : '\\\\025',  '\\026' : '\\\\026',  '\\027' : '\\\\027',\n-    '\\030' : '\\\\030',  '\\031' : '\\\\031',  '\\032' : '\\\\032',\n-    '\\033' : '\\\\033',  '\\034' : '\\\\034',  '\\035' : '\\\\035',\n-    '\\036' : '\\\\036',  '\\037' : '\\\\037',\n-\n-    # Because of the way browsers really handle cookies (as opposed\n-    # to what the RFC says) we also encode , and ;\n-\n-    ',' : '\\\\054', ';' : '\\\\073',\n-\n-    '\"' : '\\\\\"',       '\\\\' : '\\\\\\\\',\n-\n-    '\\177' : '\\\\177',  '\\200' : '\\\\200',  '\\201' : '\\\\201',\n-    '\\202' : '\\\\202',  '\\203' : '\\\\203',  '\\204' : '\\\\204',\n-    '\\205' : '\\\\205',  '\\206' : '\\\\206',  '\\207' : '\\\\207',\n-    '\\210' : '\\\\210',  '\\211' : '\\\\211',  '\\212' : '\\\\212',\n-    '\\213' : '\\\\213',  '\\214' : '\\\\214',  '\\215' : '\\\\215',\n-    '\\216' : '\\\\216',  '\\217' : '\\\\217',  '\\220' : '\\\\220',\n-    '\\221' : '\\\\221',  '\\222' : '\\\\222',  '\\223' : '\\\\223',\n-    '\\224' : '\\\\224',  '\\225' : '\\\\225',  '\\226' : '\\\\226',\n-    '\\227' : '\\\\227',  '\\230' : '\\\\230',  '\\231' : '\\\\231',\n-    '\\232' : '\\\\232',  '\\233' : '\\\\233',  '\\234' : '\\\\234',\n-    '\\235' : '\\\\235',  '\\236' : '\\\\236',  '\\237' : '\\\\237',\n-    '\\240' : '\\\\240',  '\\241' : '\\\\241',  '\\242' : '\\\\242',\n-    '\\243' : '\\\\243',  '\\244' : '\\\\244',  '\\245' : '\\\\245',\n-    '\\246' : '\\\\246',  '\\247' : '\\\\247',  '\\250' : '\\\\250',\n-    '\\251' : '\\\\251',  '\\252' : '\\\\252',  '\\253' : '\\\\253',\n-    '\\254' : '\\\\254',  '\\255' : '\\\\255',  '\\256' : '\\\\256',\n-    '\\257' : '\\\\257',  '\\260' : '\\\\260',  '\\261' : '\\\\261',\n-    '\\262' : '\\\\262',  '\\263' : '\\\\263',  '\\264' : '\\\\264',\n-    '\\265' : '\\\\265',  '\\266' : '\\\\266',  '\\267' : '\\\\267',\n-    '\\270' : '\\\\270',  '\\271' : '\\\\271',  '\\272' : '\\\\272',\n-    '\\273' : '\\\\273',  '\\274' : '\\\\274',  '\\275' : '\\\\275',\n-    '\\276' : '\\\\276',  '\\277' : '\\\\277',  '\\300' : '\\\\300',\n-    '\\301' : '\\\\301',  '\\302' : '\\\\302',  '\\303' : '\\\\303',\n-    '\\304' : '\\\\304',  '\\305' : '\\\\305',  '\\306' : '\\\\306',\n-    '\\307' : '\\\\307',  '\\310' : '\\\\310',  '\\311' : '\\\\311',\n-    '\\312' : '\\\\312',  '\\313' : '\\\\313',  '\\314' : '\\\\314',\n-    '\\315' : '\\\\315',  '\\316' : '\\\\316',  '\\317' : '\\\\317',\n-    '\\320' : '\\\\320',  '\\321' : '\\\\321',  '\\322' : '\\\\322',\n-    '\\323' : '\\\\323',  '\\324' : '\\\\324',  '\\325' : '\\\\325',\n-    '\\326' : '\\\\326',  '\\327' : '\\\\327',  '\\330' : '\\\\330',\n-    '\\331' : '\\\\331',  '\\332' : '\\\\332',  '\\333' : '\\\\333',\n-    '\\334' : '\\\\334',  '\\335' : '\\\\335',  '\\336' : '\\\\336',\n-    '\\337' : '\\\\337',  '\\340' : '\\\\340',  '\\341' : '\\\\341',\n-    '\\342' : '\\\\342',  '\\343' : '\\\\343',  '\\344' : '\\\\344',\n-    '\\345' : '\\\\345',  '\\346' : '\\\\346',  '\\347' : '\\\\347',\n-    '\\350' : '\\\\350',  '\\351' : '\\\\351',  '\\352' : '\\\\352',\n-    '\\353' : '\\\\353',  '\\354' : '\\\\354',  '\\355' : '\\\\355',\n-    '\\356' : '\\\\356',  '\\357' : '\\\\357',  '\\360' : '\\\\360',\n-    '\\361' : '\\\\361',  '\\362' : '\\\\362',  '\\363' : '\\\\363',\n-    '\\364' : '\\\\364',  '\\365' : '\\\\365',  '\\366' : '\\\\366',\n-    '\\367' : '\\\\367',  '\\370' : '\\\\370',  '\\371' : '\\\\371',\n-    '\\372' : '\\\\372',  '\\373' : '\\\\373',  '\\374' : '\\\\374',\n-    '\\375' : '\\\\375',  '\\376' : '\\\\376',  '\\377' : '\\\\377'\n-    }\n-\n-_idmap = ''.join(chr(x) for x in range(256))\n-\n-def _quote(str, LegalChars=_LegalChars,\n-           idmap=_idmap, translate=string.translate):\n-    #\n-    # If the string does not need to be double-quoted,\n-    # then just return the string.  Otherwise, surround\n-    # the string in doublequotes and precede quote (with a \\)\n-    # special characters.\n-    #\n-    if \"\" == translate(str, idmap, LegalChars):\n-        return str\n-    else:\n-        return '\"' + _nulljoin( map(_Translator.get, str, str) ) + '\"'\n-# end _quote\n-\n-\n-_OctalPatt = re.compile(r\"\\\\[0-3][0-7][0-7]\")\n-_QuotePatt = re.compile(r\"[\\\\].\")\n-\n-def _unquote(str):\n-    # If there aren't any doublequotes,\n-    # then there can't be any special characters.  See RFC 2109.\n-    if  len(str) < 2:\n-        return str\n-    if str[0] != '\"' or str[-1] != '\"':\n-        return str\n-\n-    # We have to assume that we must decode this string.\n-    # Down to work.\n-\n-    # Remove the \"s\n-    str = str[1:-1]\n-\n-    # Check for special sequences.  Examples:\n-    #    \\012 --> \\n\n-    #    \\\"   --> \"\n-    #\n-    i = 0\n-    n = len(str)\n-    res = []\n-    while 0 <= i < n:\n-        Omatch = _OctalPatt.search(str, i)\n-        Qmatch = _QuotePatt.search(str, i)\n-        if not Omatch and not Qmatch:              # Neither matched\n-            res.append(str[i:])\n-            break\n-        # else:\n-        j = k = -1\n-        if Omatch: j = Omatch.start(0)\n-        if Qmatch: k = Qmatch.start(0)\n-        if Qmatch and ( not Omatch or k < j ):     # QuotePatt matched\n-            res.append(str[i:k])\n-            res.append(str[k+1])\n-            i = k+2\n-        else:                                      # OctalPatt matched\n-            res.append(str[i:j])\n-            res.append( chr( int(str[j+1:j+4], 8) ) )\n-            i = j+4\n-    return _nulljoin(res)\n-# end _unquote\n-\n-# The _getdate() routine is used to set the expiration time in\n-# the cookie's HTTP header.      By default, _getdate() returns the\n-# current time in the appropriate \"expires\" format for a\n-# Set-Cookie header.     The one optional argument is an offset from\n-# now, in seconds.      For example, an offset of -3600 means \"one hour ago\".\n-# The offset may be a floating point number.\n-#\n-\n-_weekdayname = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n-\n-_monthname = [None,\n-              'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n-              'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n-\n-def _getdate(future=0, weekdayname=_weekdayname, monthname=_monthname):\n-    from time import gmtime, time\n-    now = time()\n-    year, month, day, hh, mm, ss, wd, y, z = gmtime(now + future)\n-    return \"%s, %02d-%3s-%4d %02d:%02d:%02d GMT\" % \\\n-           (weekdayname[wd], day, monthname[month], year, hh, mm, ss)\n-\n-\n-#\n-# A class to hold ONE key,value pair.\n-# In a cookie, each such pair may have several attributes.\n-#       so this class is used to keep the attributes associated\n-#       with the appropriate key,value pair.\n-# This class also includes a coded_value attribute, which\n-#       is used to hold the network representation of the\n-#       value.  This is most useful when Python objects are\n-#       pickled for network transit.\n-#\n-\n-class Morsel(dict):\n-    # RFC 2109 lists these attributes as reserved:\n-    #   path       comment         domain\n-    #   max-age    secure      version\n-    #\n-    # For historical reasons, these attributes are also reserved:\n-    #   expires\n-    #\n-    # This is an extension from Microsoft:\n-    #   httponly\n-    #\n-    # This dictionary provides a mapping from the lowercase\n-    # variant on the left to the appropriate traditional\n-    # formatting on the right.\n-    _reserved = { \"expires\" : \"expires\",\n-                   \"path\"        : \"Path\",\n-                   \"comment\" : \"Comment\",\n-                   \"domain\"      : \"Domain\",\n-                   \"max-age\" : \"Max-Age\",\n-                   \"secure\"      : \"secure\",\n-                   \"httponly\"  : \"httponly\",\n-                   \"version\" : \"Version\",\n-                   }\n-\n-    def __init__(self):\n-        # Set defaults\n-        self.key = self.value = self.coded_value = None\n-\n-        # Set default attributes\n-        for K in self._reserved:\n-            dict.__setitem__(self, K, \"\")\n-    # end __init__\n-\n-    def __setitem__(self, K, V):\n-        K = K.lower()\n-        if not K in self._reserved:\n-            raise CookieError(\"Invalid Attribute %s\" % K)\n-        dict.__setitem__(self, K, V)\n-    # end __setitem__\n-\n-    def isReservedKey(self, K):\n-        return K.lower() in self._reserved\n-    # end isReservedKey\n-\n-    def set(self, key, val, coded_val,\n-            LegalChars=_LegalChars,\n-            idmap=_idmap, translate=string.translate):\n-        # First we verify that the key isn't a reserved word\n-        # Second we make sure it only contains legal characters\n-        if key.lower() in self._reserved:\n-            raise CookieError(\"Attempt to set a reserved key: %s\" % key)\n-        if \"\" != translate(key, idmap, LegalChars):\n-            raise CookieError(\"Illegal key value: %s\" % key)\n-\n-        # It's a good key, so save it.\n-        self.key                 = key\n-        self.value               = val\n-        self.coded_value         = coded_val\n-    # end set\n-\n-    def output(self, attrs=None, header = \"Set-Cookie:\"):\n-        return \"%s %s\" % ( header, self.OutputString(attrs) )\n-\n-    __str__ = output\n-\n-    def __repr__(self):\n-        return '<%s: %s=%s>' % (self.__class__.__name__,\n-                                self.key, repr(self.value) )\n-\n-    def js_output(self, attrs=None):\n-        # Print javascript\n-        return \"\"\"\n-        <script type=\"text/javascript\">\n-        <!-- begin hiding\n-        document.cookie = \\\"%s\\\";\n-        // end hiding -->\n-        </script>\n-        \"\"\" % ( self.OutputString(attrs).replace('\"',r'\\\"'), )\n-    # end js_output()\n-\n-    def OutputString(self, attrs=None):\n-        # Build up our result\n-        #\n-        result = []\n-        RA = result.append\n-\n-        # First, the key=value pair\n-        RA(\"%s=%s\" % (self.key, self.coded_value))\n-\n-        # Now add any defined attributes\n-        if attrs is None:\n-            attrs = self._reserved\n-        items = self.items()\n-        items.sort()\n-        for K,V in items:\n-            if V == \"\": continue\n-            if K not in attrs: continue\n-            if K == \"expires\" and type(V) == type(1):\n-                RA(\"%s=%s\" % (self._reserved[K], _getdate(V)))\n-            elif K == \"max-age\" and type(V) == type(1):\n-                RA(\"%s=%d\" % (self._reserved[K], V))\n-            elif K == \"secure\":\n-                RA(str(self._reserved[K]))\n-            elif K == \"httponly\":\n-                RA(str(self._reserved[K]))\n-            else:\n-                RA(\"%s=%s\" % (self._reserved[K], V))\n-\n-        # Return the result\n-        return _semispacejoin(result)\n-    # end OutputString\n-# end Morsel class\n-\n-\n-\n-#\n-# Pattern for finding cookie\n-#\n-# This used to be strict parsing based on the RFC2109 and RFC2068\n-# specifications.  I have since discovered that MSIE 3.0x doesn't\n-# follow the character rules outlined in those specs.  As a\n-# result, the parsing rules here are less strict.\n-#\n-\n-_LegalCharsPatt  = r\"[\\w\\d!#%&'~_`><@,:/\\$\\*\\+\\-\\.\\^\\|\\)\\(\\?\\}\\{\\=\\[\\]\\_]\"\n-\n-_CookiePattern = re.compile(\n-    r\"(?x)\"                       # This is a Verbose pattern\n-    r\"(?P<key>\"                   # Start of group 'key'\n-    \"\"+ _LegalCharsPatt +\"+?\"     # Any word of at least one letter, nongreedy\n-    r\")\"                          # End of group 'key'\n-    r\"\\s*=\\s*\"                    # Equal Sign\n-    r\"(?P<val>\"                   # Start of group 'val'\n-    r'\"(?:[^\\\\\"]|\\\\.)*\"'            # Any doublequoted string\n-    r\"|\"                            # or\n-    r\"\\w{3},\\s[\\w\\d-]{9,11}\\s[\\d:]{8}\\sGMT\" # Special case for \"expires\" attr\n-    r\"|\"                            # or\n-    \"\"+ _LegalCharsPatt +\"*\"        # Any word or empty string\n-    r\")\"                          # End of group 'val'\n-    r\"\\s*;?\"                      # Probably ending in a semi-colon\n-    )\n-\n-\n-# At long last, here is the cookie class.\n-#   Using this class is almost just like using a dictionary.\n-# See this module's docstring for example usage.\n-#\n-class BaseCookie(dict):\n-    # A container class for a set of Morsels\n-    #\n-\n-    def value_decode(self, val):\n-        \"\"\"real_value, coded_value = value_decode(STRING)\n-        Called prior to setting a cookie's value from the network\n-        representation.  The VALUE is the value read from HTTP\n-        header.\n-        Override this function to modify the behavior of cookies.\n-        \"\"\"\n-        return val, val\n-    # end value_encode\n-\n-    def value_encode(self, val):\n-        \"\"\"real_value, coded_value = value_encode(VALUE)\n-        Called prior to setting a cookie's value from the dictionary\n-        representation.  The VALUE is the value being assigned.\n-        Override this function to modify the behavior of cookies.\n-        \"\"\"\n-        strval = str(val)\n-        return strval, strval\n-    # end value_encode\n-\n-    def __init__(self, input=None):\n-        if input: self.load(input)\n-    # end __init__\n-\n-    def __set(self, key, real_value, coded_value):\n-        \"\"\"Private method for setting a cookie's value\"\"\"\n-        M = self.get(key, Morsel())\n-        M.set(key, real_value, coded_value)\n-        dict.__setitem__(self, key, M)\n-    # end __set\n-\n-    def __setitem__(self, key, value):\n-        \"\"\"Dictionary style assignment.\"\"\"\n-        rval, cval = self.value_encode(value)\n-        self.__set(key, rval, cval)\n-    # end __setitem__\n-\n-    def output(self, attrs=None, header=\"Set-Cookie:\", sep=\"\\015\\012\"):\n-        \"\"\"Return a string suitable for HTTP.\"\"\"\n-        result = []\n-        items = self.items()\n-        items.sort()\n-        for K,V in items:\n-            result.append( V.output(attrs, header) )\n-        return sep.join(result)\n-    # end output\n-\n-    __str__ = output\n-\n-    def __repr__(self):\n-        L = []\n-        items = self.items()\n-        items.sort()\n-        for K,V in items:\n-            L.append( '%s=%s' % (K,repr(V.value) ) )\n-        return '<%s: %s>' % (self.__class__.__name__, _spacejoin(L))\n-\n-    def js_output(self, attrs=None):\n-        \"\"\"Return a string suitable for JavaScript.\"\"\"\n-        result = []\n-        items = self.items()\n-        items.sort()\n-        for K,V in items:\n-            result.append( V.js_output(attrs) )\n-        return _nulljoin(result)\n-    # end js_output\n-\n-    def load(self, rawdata):\n-        \"\"\"Load cookies from a string (presumably HTTP_COOKIE) or\n-        from a dictionary.  Loading cookies from a dictionary 'd'\n-        is equivalent to calling:\n-            map(Cookie.__setitem__, d.keys(), d.values())\n-        \"\"\"\n-        if type(rawdata) == type(\"\"):\n-            self.__ParseString(rawdata)\n-        else:\n-            # self.update() wouldn't call our custom __setitem__\n-            for k, v in rawdata.items():\n-                self[k] = v\n-        return\n-    # end load()\n-\n-    def __ParseString(self, str, patt=_CookiePattern):\n-        i = 0            # Our starting point\n-        n = len(str)     # Length of string\n-        M = None         # current morsel\n-\n-        while 0 <= i < n:\n-            # Start looking for a cookie\n-            match = patt.search(str, i)\n-            if not match: break          # No more cookies\n-\n-            K,V = match.group(\"key\"), match.group(\"val\")\n-            i = match.end(0)\n-\n-            # Parse the key, value in case it's metainfo\n-            if K[0] == \"$\":\n-                # We ignore attributes which pertain to the cookie\n-                # mechanism as a whole.  See RFC 2109.\n-                # (Does anyone care?)\n-                if M:\n-                    M[ K[1:] ] = V\n-            elif K.lower() in Morsel._reserved:\n-                if M:\n-                    M[ K ] = _unquote(V)\n-            else:\n-                rval, cval = self.value_decode(V)\n-                self.__set(K, rval, cval)\n-                M = self[K]\n-    # end __ParseString\n-# end BaseCookie class\n-\n-class SimpleCookie(BaseCookie):\n-    \"\"\"SimpleCookie\n-    SimpleCookie supports strings as cookie values.  When setting\n-    the value using the dictionary assignment notation, SimpleCookie\n-    calls the builtin str() to convert the value to a string.  Values\n-    received from HTTP are kept as strings.\n-    \"\"\"\n-    def value_decode(self, val):\n-        return _unquote( val ), val\n-    def value_encode(self, val):\n-        strval = str(val)\n-        return strval, _quote( strval )\n-# end SimpleCookie\n-\n-class SerialCookie(BaseCookie):\n-    \"\"\"SerialCookie\n-    SerialCookie supports arbitrary objects as cookie values. All\n-    values are serialized (using cPickle) before being sent to the\n-    client.  All incoming values are assumed to be valid Pickle\n-    representations.  IF AN INCOMING VALUE IS NOT IN A VALID PICKLE\n-    FORMAT, THEN AN EXCEPTION WILL BE RAISED.\n-\n-    Note: Large cookie values add overhead because they must be\n-    retransmitted on every HTTP transaction.\n-\n-    Note: HTTP has a 2k limit on the size of a cookie.  This class\n-    does not check for this limit, so be careful!!!\n-    \"\"\"\n-    def __init__(self, input=None):\n-        warnings.warn(\"SerialCookie class is insecure; do not use it\",\n-                      DeprecationWarning)\n-        BaseCookie.__init__(self, input)\n-    # end __init__\n-    def value_decode(self, val):\n-        # This could raise an exception!\n-        return loads( _unquote(val) ), val\n-    def value_encode(self, val):\n-        return val, _quote( dumps(val) )\n-# end SerialCookie\n-\n-class SmartCookie(BaseCookie):\n-    \"\"\"SmartCookie\n-    SmartCookie supports arbitrary objects as cookie values.  If the\n-    object is a string, then it is quoted.  If the object is not a\n-    string, however, then SmartCookie will use cPickle to serialize\n-    the object into a string representation.\n-\n-    Note: Large cookie values add overhead because they must be\n-    retransmitted on every HTTP transaction.\n-\n-    Note: HTTP has a 2k limit on the size of a cookie.  This class\n-    does not check for this limit, so be careful!!!\n-    \"\"\"\n-    def __init__(self, input=None):\n-        warnings.warn(\"Cookie/SmartCookie class is insecure; do not use it\",\n-                      DeprecationWarning)\n-        BaseCookie.__init__(self, input)\n-    # end __init__\n-    def value_decode(self, val):\n-        strval = _unquote(val)\n-        try:\n-            return loads(strval), val\n-        except:\n-            return strval, val\n-    def value_encode(self, val):\n-        if type(val) == type(\"\"):\n-            return val, _quote(val)\n-        else:\n-            return val, _quote( dumps(val) )\n-# end SmartCookie\n-\n-\n-###########################################################\n-# Backwards Compatibility:  Don't break any existing code!\n-\n-# We provide Cookie() as an alias for SmartCookie()\n-Cookie = SmartCookie\n-\n-#\n-###########################################################\n-\n-def _test():\n-    import doctest, Cookie\n-    return doctest.testmod(Cookie)\n-\n-if __name__ == \"__main__\":\n-    _test()\n-\n-\n-#Local Variables:\n-#tab-width: 4\n-#end:\n\n@@ -1,399 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-oreos.structures\n-~~~~~~~~~~~~~~~~\n-\n-The plastic blue packaging.\n-\n-This is mostly directly stolen from mitsuhiko/werkzeug.\n-\"\"\"\n-\n-__all__ = ('MultiDict',)\n-\n-class _Missing(object):\n-\n-    def __repr__(self):\n-        return 'no value'\n-\n-    def __reduce__(self):\n-        return '_missing'\n-\n-_missing = _Missing()\n-\n-\n-\n-def iter_multi_items(mapping):\n-    \"\"\"Iterates over the items of a mapping yielding keys and values\n-    without dropping any from more complex structures.\n-    \"\"\"\n-    if isinstance(mapping, MultiDict):\n-        for item in mapping.iteritems(multi=True):\n-            yield item\n-    elif isinstance(mapping, dict):\n-        for key, value in mapping.iteritems():\n-            if isinstance(value, (tuple, list)):\n-                for value in value:\n-                    yield key, value\n-            else:\n-                yield key, value\n-    else:\n-        for item in mapping:\n-            yield item\n-\n-\n-\n-class TypeConversionDict(dict):\n-    \"\"\"Works like a regular dict but the :meth:`get` method can perform\n-    type conversions.  :class:`MultiDict` and :class:`CombinedMultiDict`\n-    are subclasses of this class and provide the same feature.\n-\n-    .. versionadded:: 0.5\n-    \"\"\"\n-\n-    def get(self, key, default=None, type=None):\n-        \"\"\"Return the default value if the requested data doesn't exist.\n-        If `type` is provided and is a callable it should convert the value,\n-        return it or raise a :exc:`ValueError` if that is not possible.  In\n-        this case the function will return the default as if the value was not\n-        found:\n-\n-        >>> d = TypeConversionDict(foo='42', bar='blub')\n-        >>> d.get('foo', type=int)\n-        42\n-        >>> d.get('bar', -1, type=int)\n-        -1\n-\n-        :param key: The key to be looked up.\n-        :param default: The default value to be returned if the key can't\n-                        be looked up.  If not further specified `None` is\n-                        returned.\n-        :param type: A callable that is used to cast the value in the\n-                     :class:`MultiDict`.  If a :exc:`ValueError` is raised\n-                     by this callable the default value is returned.\n-        \"\"\"\n-        try:\n-            rv = self[key]\n-            if type is not None:\n-                rv = type(rv)\n-        except (KeyError, ValueError):\n-            rv = default\n-        return rv\n-\n-\n-class MultiDict(TypeConversionDict):\n-    \"\"\"A :class:`MultiDict` is a dictionary subclass customized to deal with\n-    multiple values for the same key which is for example used by the parsing\n-    functions in the wrappers.  This is necessary because some HTML form\n-    elements pass multiple values for the same key.\n-\n-    :class:`MultiDict` implements all standard dictionary methods.\n-    Internally, it saves all values for a key as a list, but the standard dict\n-    access methods will only return the first value for a key. If you want to\n-    gain access to the other values, too, you have to use the `list` methods as\n-    explained below.\n-\n-    Basic Usage:\n-\n-    >>> d = MultiDict([('a', 'b'), ('a', 'c')])\n-    >>> d\n-    MultiDict([('a', 'b'), ('a', 'c')])\n-    >>> d['a']\n-    'b'\n-    >>> d.getlist('a')\n-    ['b', 'c']\n-    >>> 'a' in d\n-    True\n-\n-    It behaves like a normal dict thus all dict functions will only return the\n-    first value when multiple values for one key are found.\n-\n-    From Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a\n-    subclass of the :exc:`~exceptions.BadRequest` HTTP exception and will\n-    render a page for a ``400 BAD REQUEST`` if caught in a catch-all for HTTP\n-    exceptions.\n-\n-    A :class:`MultiDict` can be constructed from an iterable of\n-    ``(key, value)`` tuples, a dict, a :class:`MultiDict` or from Werkzeug 0.2\n-    onwards some keyword parameters.\n-\n-    :param mapping: the initial value for the :class:`MultiDict`.  Either a\n-                    regular dict, an iterable of ``(key, value)`` tuples\n-                    or `None`.\n-    \"\"\"\n-\n-    def __init__(self, mapping=None):\n-        if isinstance(mapping, MultiDict):\n-            dict.__init__(self, ((k, l[:]) for k, l in mapping.iterlists()))\n-        elif isinstance(mapping, dict):\n-            tmp = {}\n-            for key, value in mapping.iteritems():\n-                if isinstance(value, (tuple, list)):\n-                    value = list(value)\n-                else:\n-                    value = [value]\n-                tmp[key] = value\n-            dict.__init__(self, tmp)\n-        else:\n-            tmp = {}\n-            for key, value in mapping or ():\n-                tmp.setdefault(key, []).append(value)\n-            dict.__init__(self, tmp)\n-\n-    def __getstate__(self):\n-        return dict(self.lists())\n-\n-    def __setstate__(self, value):\n-        dict.clear(self)\n-        dict.update(self, value)\n-\n-    def __iter__(self):\n-        return self.iterkeys()\n-\n-    def __getitem__(self, key):\n-        \"\"\"Return the first data value for this key;\n-        raises KeyError if not found.\n-\n-        :param key: The key to be looked up.\n-        :raise KeyError: if the key does not exist.\n-        \"\"\"\n-        if key in self:\n-            return dict.__getitem__(self, key)[0]\n-        raise KeyError(key)\n-\n-    def __setitem__(self, key, value):\n-        \"\"\"Like :meth:`add` but removes an existing key first.\n-\n-        :param key: the key for the value.\n-        :param value: the value to set.\n-        \"\"\"\n-        dict.__setitem__(self, key, [value])\n-\n-    def add(self, key, value):\n-        \"\"\"Adds a new value for the key.\n-\n-        .. versionadded:: 0.6\n-\n-        :param key: the key for the value.\n-        :param value: the value to add.\n-        \"\"\"\n-        dict.setdefault(self, key, []).append(value)\n-\n-    def getlist(self, key, type=None):\n-        \"\"\"Return the list of items for a given key. If that key is not in the\n-        `MultiDict`, the return value will be an empty list.  Just as `get`\n-        `getlist` accepts a `type` parameter.  All items will be converted\n-        with the callable defined there.\n-\n-        :param key: The key to be looked up.\n-        :param type: A callable that is used to cast the value in the\n-                     :class:`MultiDict`.  If a :exc:`ValueError` is raised\n-                     by this callable the value will be removed from the list.\n-        :return: a :class:`list` of all the values for the key.\n-        \"\"\"\n-        try:\n-            rv = dict.__getitem__(self, key)\n-        except KeyError:\n-            return []\n-        if type is None:\n-            return list(rv)\n-        result = []\n-        for item in rv:\n-            try:\n-                result.append(type(item))\n-            except ValueError:\n-                pass\n-        return result\n-\n-    def setlist(self, key, new_list):\n-        \"\"\"Remove the old values for a key and add new ones.  Note that the list\n-        you pass the values in will be shallow-copied before it is inserted in\n-        the dictionary.\n-\n-        >>> d = MultiDict()\n-        >>> d.setlist('foo', ['1', '2'])\n-        >>> d['foo']\n-        '1'\n-        >>> d.getlist('foo')\n-        ['1', '2']\n-\n-        :param key: The key for which the values are set.\n-        :param new_list: An iterable with the new values for the key.  Old values\n-                         are removed first.\n-        \"\"\"\n-        dict.__setitem__(self, key, list(new_list))\n-\n-    def setdefault(self, key, default=None):\n-        \"\"\"Returns the value for the key if it is in the dict, otherwise it\n-        returns `default` and sets that value for `key`.\n-\n-        :param key: The key to be looked up.\n-        :param default: The default value to be returned if the key is not\n-                        in the dict.  If not further specified it's `None`.\n-        \"\"\"\n-        if key not in self:\n-            self[key] = default\n-        else:\n-            default = self[key]\n-        return default\n-\n-    def setlistdefault(self, key, default_list=None):\n-        \"\"\"Like `setdefault` but sets multiple values.  The list returned\n-        is not a copy, but the list that is actually used internally.  This\n-        means that you can put new values into the dict by appending items\n-        to the list:\n-\n-        >>> d = MultiDict({\"foo\": 1})\n-        >>> d.setlistdefault(\"foo\").extend([2, 3])\n-        >>> d.getlist(\"foo\")\n-        [1, 2, 3]\n-\n-        :param key: The key to be looked up.\n-        :param default: An iterable of default values.  It is either copied\n-                        (in case it was a list) or converted into a list\n-                        before returned.\n-        :return: a :class:`list`\n-        \"\"\"\n-        if key not in self:\n-            default_list = list(default_list or ())\n-            dict.__setitem__(self, key, default_list)\n-        else:\n-            default_list = dict.__getitem__(self, key)\n-        return default_list\n-\n-    def items(self, multi=False):\n-        \"\"\"Return a list of ``(key, value)`` pairs.\n-\n-        :param multi: If set to `True` the list returned will have a\n-                      pair for each value of each key.  Otherwise it\n-                      will only contain pairs for the first value of\n-                      each key.\n-\n-        :return: a :class:`list`\n-        \"\"\"\n-        return list(self.iteritems(multi))\n-\n-    def lists(self):\n-        \"\"\"Return a list of ``(key, values)`` pairs, where values is the list of\n-        all values associated with the key.\n-\n-        :return: a :class:`list`\n-        \"\"\"\n-        return list(self.iterlists())\n-\n-    def values(self):\n-        \"\"\"Returns a list of the first value on every key's value list.\n-\n-        :return: a :class:`list`.\n-        \"\"\"\n-        return [self[key] for key in self.iterkeys()]\n-\n-    def listvalues(self):\n-        \"\"\"Return a list of all values associated with a key.  Zipping\n-        :meth:`keys` and this is the same as calling :meth:`lists`:\n-\n-        >>> d = MultiDict({\"foo\": [1, 2, 3]})\n-        >>> zip(d.keys(), d.listvalues()) == d.lists()\n-        True\n-\n-        :return: a :class:`list`\n-        \"\"\"\n-        return list(self.iterlistvalues())\n-\n-    def iteritems(self, multi=False):\n-        \"\"\"Like :meth:`items` but returns an iterator.\"\"\"\n-        for key, values in dict.iteritems(self):\n-            if multi:\n-                for value in values:\n-                    yield key, value\n-            else:\n-                yield key, values[0]\n-\n-    def iterlists(self):\n-        \"\"\"Like :meth:`items` but returns an iterator.\"\"\"\n-        for key, values in dict.iteritems(self):\n-            yield key, list(values)\n-\n-    def itervalues(self):\n-        \"\"\"Like :meth:`values` but returns an iterator.\"\"\"\n-        for values in dict.itervalues(self):\n-            yield values[0]\n-\n-    def iterlistvalues(self):\n-        \"\"\"Like :meth:`listvalues` but returns an iterator.\"\"\"\n-        return dict.itervalues(self)\n-\n-    def copy(self):\n-        \"\"\"Return a shallow copy of this object.\"\"\"\n-        return self.__class__(self)\n-\n-    def to_dict(self, flat=True):\n-        \"\"\"Return the contents as regular dict.  If `flat` is `True` the\n-        returned dict will only have the first item present, if `flat` is\n-        `False` all values will be returned as lists.\n-\n-        :param flat: If set to `False` the dict returned will have lists\n-                     with all the values in it.  Otherwise it will only\n-                     contain the first value for each key.\n-        :return: a :class:`dict`\n-        \"\"\"\n-        if flat:\n-            return dict(self.iteritems())\n-        return dict(self.lists())\n-\n-    def update(self, other_dict):\n-        \"\"\"update() extends rather than replaces existing key lists.\"\"\"\n-        for key, value in iter_multi_items(other_dict):\n-            MultiDict.add(self, key, value)\n-\n-    def pop(self, key, default=_missing):\n-        \"\"\"Pop the first item for a list on the dict.  Afterwards the\n-        key is removed from the dict, so additional values are discarded:\n-\n-        >>> d = MultiDict({\"foo\": [1, 2, 3]})\n-        >>> d.pop(\"foo\")\n-        1\n-        >>> \"foo\" in d\n-        False\n-\n-        :param key: the key to pop.\n-        :param default: if provided the value to return if the key was\n-                        not in the dictionary.\n-        \"\"\"\n-        try:\n-            return dict.pop(self, key)[0]\n-        except KeyError as e:\n-            if default is not _missing:\n-                return default\n-            raise KeyError(str(e))\n-\n-    def popitem(self):\n-        \"\"\"Pop an item from the dict.\"\"\"\n-        try:\n-            item = dict.popitem(self)\n-            return (item[0], item[1][0])\n-        except KeyError as e:\n-            raise KeyError(str(e))\n-\n-    def poplist(self, key):\n-        \"\"\"Pop the list for a key from the dict.  If the key is not in the dict\n-        an empty list is returned.\n-\n-        .. versionchanged:: 0.5\n-           If the key does no longer exist a list is returned instead of\n-           raising an error.\n-        \"\"\"\n-        return dict.pop(self, key, [])\n-\n-    def popitemlist(self):\n-        \"\"\"Pop a ``(key, list)`` tuple from the dict.\"\"\"\n-        try:\n-            return dict.popitem(self)\n-        except KeyError as e:\n-            raise KeyError(str(e))\n-\n-    def __copy__(self):\n-        return self.copy()\n-\n-    def __repr__(self):\n-        return '%s(%r)' % (self.__class__.__name__, self.items(multi=True))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
