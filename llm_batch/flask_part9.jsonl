{"custom_id": "flask#9983e847425621b5e474ae9da6822f1af0b0cc1f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 37 | Lines Deleted: 12 | Files Changed: 2 | Hunks: 18 | Methods Changed: 7 | Complexity Δ (Sum/Max): 5/4 | Churn Δ: 49 | Churn Cumulative: 3425 | Contributors (this commit): 8 | Commits (past 90d): 126 | Contributors (cumulative): 13 | DMM Complexity: 1.0\n\nDIFF:\n@@ -16,6 +16,7 @@ import mimetypes\n from datetime import datetime, timedelta\n \n from itertools import chain\n+from threading import Lock\n from jinja2 import Environment, PackageLoader, FileSystemLoader\n from werkzeug import Request as RequestBase, Response as ResponseBase, \\\n      LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \\\n@@ -50,6 +51,9 @@ try:\n except (ImportError, AttributeError):\n     pkg_resources = None\n \n+# a lock used for logger initialization\n+_logger_lock = Lock()\n+\n \n class Request(RequestBase):\n     \"\"\"The request object used by default in flask.  Remembers the\n@@ -839,6 +843,12 @@ class Flask(_PackageBoundObject):\n     #: `USE_X_SENDFILE` configuration key.  Defaults to `False`.\n     use_x_sendfile = ConfigAttribute('USE_X_SENDFILE')\n \n+    #: the name of the logger to use.  By default the logger name is the\n+    #: package name passed to the constructor.\n+    #:\n+    #: .. versionadded:: 0.4\n+    logger_name = ConfigAttribute('LOGGER_NAME')\n+\n     #: the logging format used for the debug logger.  This is only used when\n     #: the application is in debug mode, otherwise the attached logging\n     #: handler does the formatting.\n@@ -863,7 +873,8 @@ class Flask(_PackageBoundObject):\n         'SECRET_KEY':                           None,\n         'SESSION_COOKIE_NAME':                  'session',\n         'PERMANENT_SESSION_LIFETIME':           timedelta(days=31),\n-        'USE_X_SENDFILE':                       False\n+        'USE_X_SENDFILE':                       False,\n+        'LOGGER_NAME':                          None\n     })\n \n     def __init__(self, import_name):\n@@ -874,6 +885,10 @@ class Flask(_PackageBoundObject):\n         #: to load a config from files.\n         self.config = Config(self.root_path, self.default_config)\n \n+        #: prepare the deferred setup of the logger\n+        self._logger = None\n+        self.logger_name = self.import_name\n+\n         #: a dictionary of all view functions registered.  The keys will\n         #: be function names which are also used to generate URLs and\n         #: the values are the function objects themselves.\n@@ -952,7 +967,7 @@ class Flask(_PackageBoundObject):\n         )\n         self.jinja_env.filters['tojson'] = _tojson_filter\n \n-    @cached_property\n+    @property\n     def logger(self):\n         \"\"\"A :class:`logging.Logger` object for this application.  The\n         default configuration is to log to stderr if the application is\n@@ -965,6 +980,11 @@ class Flask(_PackageBoundObject):\n \n         .. versionadded:: 0.3\n         \"\"\"\n+        if self._logger and self._logger.name == self.logger_name:\n+            return self._logger\n+        with _logger_lock:\n+            if self._logger and self._logger.name == self.logger_name:\n+                return self._logger\n             from logging import getLogger, StreamHandler, Formatter, DEBUG\n             class DebugHandler(StreamHandler):\n                 def emit(x, record):\n@@ -973,8 +993,9 @@ class Flask(_PackageBoundObject):\n             handler = DebugHandler()\n             handler.setLevel(DEBUG)\n             handler.setFormatter(Formatter(self.debug_log_format))\n-        logger = getLogger(self.import_name)\n+            logger = getLogger(self.logger_name)\n             logger.addHandler(handler)\n+            self._logger = logger\n             return logger\n \n     def create_jinja_loader(self):\n@@ -1412,16 +1433,12 @@ class Flask(_PackageBoundObject):\n                 if rv is None:\n                     rv = self.dispatch_request()\n                 response = self.make_response(rv)\n-                response = self.process_response(response)\n             except Exception, e:\n                 response = self.make_response(self.handle_exception(e))\n             try:\n                 response = self.process_response(response)\n             except Exception, e:\n-                    self.logger.exception('after_request handler failed '\n-                                          'to postprocess error response. '\n-                                          'Depending on uncertain state?')\n-\n+                response = self.make_response(self.handle_exception(e))\n             return response(environ, start_response)\n \n     def request_context(self, environ):\n\n@@ -288,11 +288,11 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n         assert len(called) == 1\n \n     def test_after_request_handler_error(self):\n-        error_out = StringIO()\n+        called = []\n         app = flask.Flask(__name__)\n-        app.logger.addHandler(StreamHandler(error_out))\n         @app.after_request\n         def after_request(response):\n+            called.append(True)\n             1/0\n             return response\n         @app.route('/')\n@@ -301,7 +301,7 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n         rv = app.test_client().get('/')\n         assert rv.status_code == 500\n         assert 'Internal Server Error' in rv.data\n-        assert 'after_request handler failed' in error_out.getvalue()\n+        assert len(called) == 1\n \n     def test_error_handling(self):\n         app = flask.Flask(__name__)\n@@ -707,6 +707,14 @@ class SendfileTestCase(unittest.TestCase):\n \n class LoggingTestCase(unittest.TestCase):\n \n+    def test_logger_cache(self):\n+        app = flask.Flask(__name__)\n+        logger1 = app.logger\n+        assert app.logger is logger1\n+        assert logger1.name == __name__\n+        app.logger_name = __name__ + '/test_logger_cache'\n+        assert app.logger is not logger1\n+\n     def test_debug_log(self):\n         app = flask.Flask(__name__)\n         app.debug = True\n@@ -736,9 +744,9 @@ class LoggingTestCase(unittest.TestCase):\n                 assert False, 'debug log ate the exception'\n \n     def test_exception_logging(self):\n-        from logging import StreamHandler\n         out = StringIO()\n         app = flask.Flask(__name__)\n+        app.logger_name = 'flask_tests/test_exception_logging'\n         app.logger.addHandler(StreamHandler(out))\n \n         @app.route('/')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#1ffa295d933c7e0cd1ee14c1592c40f72b9f22bb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 14 | Churn Cumulative: 333 | Contributors (this commit): 2 | Commits (past 90d): 14 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -43,12 +43,20 @@ master_doc = 'index'\n project = u'Flask'\n copyright = u'2010, Armin Ronacher'\n \n-import pkg_resources\n-\n # The version info for the project you're documenting, acts as replacement for\n # |version| and |release|, also used in various other places throughout the\n # built documents.\n-release = __import__('pkg_resources').get_distribution('Flask').version\n+import pkg_resources\n+try:\n+    release = pkg_resources.get_distribution('Flask').version\n+except pkg_resources.DistributionNotFound:\n+    print 'To build the documentation, The distribution information of Flask'\n+    print 'Has to be available.  Either install the package into your'\n+    print 'development environment or run \"setup.py develop\" to setup the'\n+    print 'metadata.  A virtualenv is recommended!'\n+    sys.exit(1)\n+del pkg_resources\n+\n if 'dev' in release:\n     release = release.split('dev')[0] + 'dev'\n version = '.'.join(release.split('.')[:2])\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#12c2cb5e12895a0d16b37b7a9e9a96d69a34c36e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 2458 | Contributors (this commit): 9 | Commits (past 90d): 87 | Contributors (cumulative): 9 | DMM Complexity: None\n\nDIFF:\n@@ -1301,7 +1301,7 @@ class Flask(_PackageBoundObject):\n     def handle_exception(self, e):\n         \"\"\"Default exception handling that kicks in when an exception\n         occours that is not catched.  In debug mode the exception will\n-        be re-raised immediately, otherwise it is logged an the handler\n+        be re-raised immediately, otherwise it is logged and the handler\n         for an 500 internal server error is used.  If no such handler\n         exists, a default 500 internal server error message is displayed.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#cc7876f97fbc787ac7702453bdc62541f8ea47f6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 2460 | Contributors (this commit): 9 | Commits (past 90d): 88 | Contributors (cumulative): 9 | DMM Complexity: None\n\nDIFF:\n@@ -1302,7 +1302,7 @@ class Flask(_PackageBoundObject):\n         \"\"\"Default exception handling that kicks in when an exception\n         occours that is not catched.  In debug mode the exception will\n         be re-raised immediately, otherwise it is logged and the handler\n-        for an 500 internal server error is used.  If no such handler\n+        for a 500 internal server error is used.  If no such handler\n         exists, a default 500 internal server error message is displayed.\n \n         .. versionadded: 0.3\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#e67903d134039b2452b2a3806e10451491ce768d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 2462 | Contributors (this commit): 9 | Commits (past 90d): 89 | Contributors (cumulative): 9 | DMM Complexity: None\n\nDIFF:\n@@ -1287,7 +1287,7 @@ class Flask(_PackageBoundObject):\n         return f\n \n     def handle_http_exception(self, e):\n-        \"\"\"Handles an HTTP exception.  By default this will invoke the\n+        \"\"\"Handles a HTTP exception.  By default this will invoke the\n         registered error handlers and fall back to returning the\n         exception as response.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#88a031ab24b0e7e2a5190f9e48f80f2b21aba1a0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 2464 | Contributors (this commit): 9 | Commits (past 90d): 90 | Contributors (cumulative): 9 | DMM Complexity: None\n\nDIFF:\n@@ -1287,7 +1287,7 @@ class Flask(_PackageBoundObject):\n         return f\n \n     def handle_http_exception(self, e):\n-        \"\"\"Handles a HTTP exception.  By default this will invoke the\n+        \"\"\"Handles an HTTP exception.  By default this will invoke the\n         registered error handlers and fall back to returning the\n         exception as response.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#51a5add86d0fa9889b69d51d45d06a2ac4c5df9f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 21 | Lines Deleted: 21 | Files Changed: 1 | Hunks: 21 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 42 | Churn Cumulative: 2506 | Contributors (this commit): 9 | Commits (past 90d): 91 | Contributors (cumulative): 9 | DMM Complexity: None\n\nDIFF:\n@@ -448,11 +448,11 @@ else:\n class _PackageBoundObject(object):\n \n     def __init__(self, import_name):\n-        #: the name of the package or module.  Do not change this once\n+        #: The name of the package or module.  Do not change this once\n         #: it was set by the constructor.\n         self.import_name = import_name\n \n-        #: where is the app root located?\n+        #: Where is the app root located?\n         self.root_path = _get_package_path(self.import_name)\n \n     def open_resource(self, resource):\n@@ -788,20 +788,20 @@ class Flask(_PackageBoundObject):\n         app = Flask(__name__)\n     \"\"\"\n \n-    #: the class that is used for request objects.  See :class:`~flask.Request`\n+    #: The class that is used for request objects.  See :class:`~flask.Request`\n     #: for more information.\n     request_class = Request\n \n-    #: the class that is used for response objects.  See\n+    #: The class that is used for response objects.  See\n     #: :class:`~flask.Response` for more information.\n     response_class = Response\n \n-    #: path for the static files.  If you don't want to use static files\n+    #: Path for the static files.  If you don't want to use static files\n     #: you can set this value to `None` in which case no URL rule is added\n     #: and the development server will no longer serve any static files.\n     static_path = '/static'\n \n-    #: the debug flag.  Set this to `True` to enable debugging of the\n+    #: The debug flag.  Set this to `True` to enable debugging of the\n     #: application.  In debug mode the debugger will kick in when an unhandled\n     #: exception ocurrs and the integrated server will automatically reload\n     #: the application if changes in the code are detected.\n@@ -810,7 +810,7 @@ class Flask(_PackageBoundObject):\n     #: configuration key.  Defaults to `False`.\n     debug = ConfigAttribute('DEBUG')\n \n-    #: if a secret key is set, cryptographic components can use this to\n+    #: If a secret key is set, cryptographic components can use this to\n     #: sign cookies and other things.  Set this to a complex random value\n     #: when you want to use the secure cookie for instance.\n     #:\n@@ -818,7 +818,7 @@ class Flask(_PackageBoundObject):\n     #: `SECRET_KEY` configuration key.  Defaults to `None`.\n     secret_key = ConfigAttribute('SECRET_KEY')\n \n-    #: The secure cookie uses this for the name of the session cookie\n+    #: The secure cookie uses this for the name of the session cookie.\n     #:\n     #: This attribute can also be configured from the config with the\n     #: `SESSION_COOKIE_NAME` configuration key.  Defaults to ``'session'``\n@@ -843,13 +843,13 @@ class Flask(_PackageBoundObject):\n     #: `USE_X_SENDFILE` configuration key.  Defaults to `False`.\n     use_x_sendfile = ConfigAttribute('USE_X_SENDFILE')\n \n-    #: the name of the logger to use.  By default the logger name is the\n+    #: The name of the logger to use.  By default the logger name is the\n     #: package name passed to the constructor.\n     #:\n     #: .. versionadded:: 0.4\n     logger_name = ConfigAttribute('LOGGER_NAME')\n \n-    #: the logging format used for the debug logger.  This is only used when\n+    #: The logging format used for the debug logger.  This is only used when\n     #: the application is in debug mode, otherwise the attached logging\n     #: handler does the formatting.\n     #:\n@@ -861,13 +861,13 @@ class Flask(_PackageBoundObject):\n         '-' * 80\n     )\n \n-    #: options that are passed directly to the Jinja2 environment\n+    #: Options that are passed directly to the Jinja2 environment.\n     jinja_options = ImmutableDict(\n         autoescape=True,\n         extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']\n     )\n \n-    #: default configuration parameters\n+    #: Default configuration parameters.\n     default_config = ImmutableDict({\n         'DEBUG':                                False,\n         'SECRET_KEY':                           None,\n@@ -880,29 +880,29 @@ class Flask(_PackageBoundObject):\n     def __init__(self, import_name):\n         _PackageBoundObject.__init__(self, import_name)\n \n-        #: the configuration dictionary as :class:`Config`.  This behaves\n+        #: The configuration dictionary as :class:`Config`.  This behaves\n         #: exactly like a regular dictionary but supports additional methods\n         #: to load a config from files.\n         self.config = Config(self.root_path, self.default_config)\n \n-        #: prepare the deferred setup of the logger\n+        #: Prepare the deferred setup of the logger.\n         self._logger = None\n         self.logger_name = self.import_name\n \n-        #: a dictionary of all view functions registered.  The keys will\n+        #: A dictionary of all view functions registered.  The keys will\n         #: be function names which are also used to generate URLs and\n         #: the values are the function objects themselves.\n         #: to register a view function, use the :meth:`route` decorator.\n         self.view_functions = {}\n \n-        #: a dictionary of all registered error handlers.  The key is\n+        #: A dictionary of all registered error handlers.  The key is\n         #: be the error code as integer, the value the function that\n         #: should handle that error.\n         #: To register a error handler, use the :meth:`errorhandler`\n         #: decorator.\n         self.error_handlers = {}\n \n-        #: a dictionary with lists of functions that should be called at the\n+        #: A dictionary with lists of functions that should be called at the\n         #: beginning of the request.  The key of the dictionary is the name of\n         #: the module this function is active for, `None` for all requests.\n         #: This can for example be used to open database connections or\n@@ -910,7 +910,7 @@ class Flask(_PackageBoundObject):\n         #: function here, use the :meth:`before_request` decorator.\n         self.before_request_funcs = {}\n \n-        #: a dictionary with lists of functions that should be called after\n+        #: A dictionary with lists of functions that should be called after\n         #: each request.  The key of the dictionary is the name of the module\n         #: this function is active for, `None` for all requests.  This can for\n         #: example be used to open database connections or getting hold of the\n@@ -918,7 +918,7 @@ class Flask(_PackageBoundObject):\n         #: :meth:`before_request` decorator.\n         self.after_request_funcs = {}\n \n-        #: a dictionary with list of functions that are called without argument\n+        #: A dictionary with list of functions that are called without argument\n         #: to populate the template context.  They key of the dictionary is the\n         #: name of the module this function is active for, `None` for all\n         #: requests.  Each returns a dictionary that the template context is\n@@ -928,7 +928,7 @@ class Flask(_PackageBoundObject):\n             None: [_default_template_ctx_processor]\n         }\n \n-        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use\n+        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n         #: this to change the routing converters after the class was created\n         #: but before any routes are connected.  Example::\n         #:\n@@ -956,7 +956,7 @@ class Flask(_PackageBoundObject):\n                 self.static_path: target\n             })\n \n-        #: the Jinja2 environment.  It is created from the\n+        #: The Jinja2 environment.  It is created from the\n         #: :attr:`jinja_options` and the loader that is returned\n         #: by the :meth:`create_jinja_loader` function.\n         self.jinja_env = Environment(loader=self.create_jinja_loader(),\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#06ed3e1e8888b73794876d39a53382eb45a54fe2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 2508 | Contributors (this commit): 9 | Commits (past 90d): 92 | Contributors (cumulative): 9 | DMM Complexity: None\n\nDIFF:\n@@ -463,7 +463,7 @@ class _PackageBoundObject(object):\n             /schemal.sql\n             /static\n                 /style.css\n-            /template\n+            /templates\n                 /layout.html\n                 /index.html\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#f5fb4576577cbedcedba9eb16d9fdace18c9292c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 10 | Churn Cumulative: 2518 | Contributors (this commit): 9 | Commits (past 90d): 93 | Contributors (cumulative): 9 | DMM Complexity: None\n\nDIFF:\n@@ -810,6 +810,15 @@ class Flask(_PackageBoundObject):\n     #: configuration key.  Defaults to `False`.\n     debug = ConfigAttribute('DEBUG')\n \n+    #: The testing flask.  Set this to `True` to enable the test mode of\n+    #: Flask extensions (and in the future probably also Flask itself).\n+    #: For example this might activate unittest helpers that have an\n+    #: additional runtime cost which should not be enabled by default.\n+    #:\n+    #: This attribute can also be configured from the config with the\n+    #: `TESTING` configuration key.  Defaults to `False`.\n+    testing = ConfigAttribute('TESTING')\n+\n     #: If a secret key is set, cryptographic components can use this to\n     #: sign cookies and other things.  Set this to a complex random value\n     #: when you want to use the secure cookie for instance.\n@@ -870,6 +879,7 @@ class Flask(_PackageBoundObject):\n     #: Default configuration parameters.\n     default_config = ImmutableDict({\n         'DEBUG':                                False,\n+        'TESTING':                              False,\n         'SECRET_KEY':                           None,\n         'SESSION_COOKIE_NAME':                  'session',\n         'PERMANENT_SESSION_LIFETIME':           timedelta(days=31),\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#33a035bb0ec07a4ca92f1397e7caeb7714c57bd6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 2522 | Contributors (this commit): 9 | Commits (past 90d): 94 | Contributors (cumulative): 9 | DMM Complexity: None\n\nDIFF:\n@@ -300,7 +300,9 @@ def jsonify(*args, **kwargs):\n             \"id\": 42\n         }\n \n-    This requires Python 2.6 or an installed version of simplejson.\n+    This requires Python 2.6 or an installed version of simplejson.  For\n+    security reasons only objects are supported toplevel.  For more\n+    information about this, have a look at :ref:`json-security`.\n \n     .. versionadded:: 0.2\n     \"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#20c2e53893c202a4555bd7390672ee948fa6b1e0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 8 | Churn Cumulative: 2530 | Contributors (this commit): 9 | Commits (past 90d): 95 | Contributors (cumulative): 9 | DMM Complexity: None\n\nDIFF:\n@@ -213,7 +213,7 @@ def url_for(endpoint, **values):\n def get_template_attribute(template_name, attribute):\n     \"\"\"Loads a macro (or variable) a template exports.  This can be used to\n     invoke a macro from within Python code.  If you for example have a\n-    template named `_foo.html` with the following contents:\n+    template named `_cider.html` with the following contents:\n \n     .. sourcecode:: html+jinja\n \n@@ -221,7 +221,7 @@ def get_template_attribute(template_name, attribute):\n \n     You can access this from Python code like this::\n \n-        hello = get_template_attribute('_foo.html', 'hello')\n+        hello = get_template_attribute('_cider.html', 'hello')\n         return hello('World')\n \n     .. versionadded:: 0.2\n@@ -1062,8 +1062,8 @@ class Flask(_PackageBoundObject):\n         you want to access the context locals for testing::\n \n             with app.test_client() as c:\n-                rv = c.get('/?foo=42')\n-                assert request.args['foo'] == '42'\n+                rv = c.get('/?vodka=42')\n+                assert request.args['vodka'] == '42'\n \n         .. versionchanged:: 0.4\n            added support for `with` block usage for the client.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#d44b12774879cba83bf33c8ed7733157ab84d778", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 12 | Lines Deleted: 5 | Files Changed: 2 | Hunks: 8 | Methods Changed: 5 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 17 | Churn Cumulative: 3516 | Contributors (this commit): 9 | Commits (past 90d): 137 | Contributors (cumulative): 14 | DMM Complexity: 1.0\n\nDIFF:\n@@ -867,7 +867,7 @@ class Flask(_PackageBoundObject):\n     #: .. versionadded:: 0.3\n     debug_log_format = (\n         '-' * 80 + '\\n' +\n-        '%(levelname)s in %(module)s, %(pathname)s:%(lineno)d]:\\n' +\n+        '%(levelname)s in %(module)s [%(pathname)s:%(lineno)d]:\\n' +\n         '%(message)s\\n' +\n         '-' * 80\n     )\n@@ -997,15 +997,19 @@ class Flask(_PackageBoundObject):\n         with _logger_lock:\n             if self._logger and self._logger.name == self.logger_name:\n                 return self._logger\n-            from logging import getLogger, StreamHandler, Formatter, DEBUG\n+            from logging import getLogger, StreamHandler, Formatter, \\\n+                                Logger,  DEBUG\n+            class DebugLogger(Logger):\n+                def getEffectiveLevel(x):\n+                    return DEBUG if self.debug else Logger.getEffectiveLevel(x)\n             class DebugHandler(StreamHandler):\n                 def emit(x, record):\n-                    if self.debug:\n-                        StreamHandler.emit(x, record)\n+                    StreamHandler.emit(x, record) if self.debug else None\n             handler = DebugHandler()\n             handler.setLevel(DEBUG)\n             handler.setFormatter(Formatter(self.debug_log_format))\n             logger = getLogger(self.logger_name)\n+            logger.__class__ = DebugLogger\n             logger.addHandler(handler)\n             self._logger = logger\n             return logger\n\n@@ -718,9 +718,11 @@ class LoggingTestCase(unittest.TestCase):\n     def test_debug_log(self):\n         app = flask.Flask(__name__)\n         app.debug = True\n+\n         @app.route('/')\n         def index():\n             app.logger.warning('the standard library is dead')\n+            app.logger.debug('this is a debug statement')\n             return ''\n \n         @app.route('/exc')\n@@ -731,9 +733,10 @@ class LoggingTestCase(unittest.TestCase):\n         with catch_stderr() as err:\n             rv = c.get('/')\n             out = err.getvalue()\n-            assert 'WARNING in flask_tests,' in out\n+            assert 'WARNING in flask_tests [' in out\n             assert 'flask_tests.py' in out\n             assert 'the standard library is dead' in out\n+            assert 'this is a debug statement' in out\n \n         with catch_stderr() as err:\n             try:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#528ae04be024ea27881f4c45e23590c011a8ea66", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 111 | Contributors (this commit): 2 | Commits (past 90d): 13 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -50,7 +50,7 @@ def run_tests():\n \n setup(\n     name='Flask',\n-    version='0.4',\n+    version='0.5',\n     url='http://github.com/mitsuhiko/flask/',\n     license='BSD',\n     author='Armin Ronacher',\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#f195d9244756b9809bd2b00601b437f3e278b0b9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 25 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 4 | Methods Changed: 5 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 27 | Churn Cumulative: 3546 | Contributors (this commit): 9 | Commits (past 90d): 140 | Contributors (cumulative): 14 | DMM Complexity: 1.0\n\nDIFF:\n@@ -141,7 +141,8 @@ class _RequestContext(object):\n \n     def __init__(self, app, environ):\n         self.app = app\n-        self.url_adapter = app.url_map.bind_to_environ(environ)\n+        self.url_adapter = app.url_map.bind_to_environ(environ,\n+            server_name=app.config['SERVER_NAME'])\n         self.request = app.request_class(environ)\n         self.session = app.open_session(self.request)\n         if self.session is None:\n@@ -889,7 +890,8 @@ class Flask(_PackageBoundObject):\n         'SESSION_COOKIE_NAME':                  'session',\n         'PERMANENT_SESSION_LIFETIME':           timedelta(days=31),\n         'USE_X_SENDFILE':                       False,\n-        'LOGGER_NAME':                          None\n+        'LOGGER_NAME':                          None,\n+        'SERVER_NAME':                          None\n     })\n \n     def __init__(self, import_name):\n\n@@ -836,6 +836,26 @@ class ConfigTestCase(unittest.TestCase):\n             os.environ = env\n \n \n+class SubdomainTestCase(unittest.TestCase):\n+\n+    def test_basic_support(self):\n+        app = flask.Flask(__name__)\n+        app.config['SERVER_NAME'] = 'localhost'\n+        @app.route('/')\n+        def normal_index():\n+            return 'normal index'\n+        @app.route('/', subdomain='test')\n+        def test_index():\n+            return 'test index'\n+\n+        c = app.test_client()\n+        rv = c.get('/', 'http://localhost/')\n+        assert rv.data == 'normal index'\n+\n+        rv = c.get('/', 'http://test.localhost/')\n+        assert rv.data == 'test index'\n+\n+\n def suite():\n     from minitwit_tests import MiniTwitTestCase\n     from flaskr_tests import FlaskrTestCase\n@@ -847,6 +867,7 @@ def suite():\n     suite.addTest(unittest.makeSuite(SendfileTestCase))\n     suite.addTest(unittest.makeSuite(LoggingTestCase))\n     suite.addTest(unittest.makeSuite(ConfigTestCase))\n+    suite.addTest(unittest.makeSuite(SubdomainTestCase))\n     if flask.json_available:\n         suite.addTest(unittest.makeSuite(JSONTestCase))\n     suite.addTest(unittest.makeSuite(MiniTwitTestCase))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#7ea1b801cc1f7d09ee18e8d70957c9d34b870700", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 16 | Churn Cumulative: 2567 | Contributors (this commit): 9 | Commits (past 90d): 99 | Contributors (cumulative): 9 | DMM Complexity: None\n\nDIFF:\n@@ -67,7 +67,21 @@ class Request(RequestBase):\n     :attr:`~flask.Flask.request_class` to your subclass.\n     \"\"\"\n \n-    endpoint = view_args = routing_exception = None\n+    #: the endpoint that matched the request.  This in combination with\n+    #: :attr:`view_args` can be used to reconstruct the same or a\n+    #: modified URL.  If an exception happened when matching, this will\n+    #: be `None`.\n+    endpoint = None\n+\n+    #: a dict of view arguments that matched the request.  If an exception\n+    #: happened when matching, this will be `None`.\n+    view_args = None\n+\n+    #: if matching the URL failed, this is the exception that will be\n+    #: raised / was raised as part of the request handling.  This is\n+    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n+    #: something similar.\n+    routing_exception = None\n \n     @property\n     def module(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#bcd746e8cf0fc5f405c5f32b80517a4390de6fd9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 2 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 11 | Churn Cumulative: 1006 | Contributors (this commit): 5 | Commits (past 90d): 43 | Contributors (cumulative): 5 | DMM Complexity: 1.0\n\nDIFF:\n@@ -855,6 +855,17 @@ class SubdomainTestCase(unittest.TestCase):\n         rv = c.get('/', 'http://test.localhost/')\n         assert rv.data == 'test index'\n \n+    def test_subdomain_matching(self):\n+        app = flask.Flask(__name__)\n+        app.config['SERVER_NAME'] = 'localhost'\n+        @app.route('/', subdomain='<user>')\n+        def index(user):\n+            return 'index for %s' % user\n+\n+        c = app.test_client()\n+        rv = c.get('/', 'http://mitsuhiko.localhost/')\n+        assert rv.data == 'index for mitsuhiko'\n+\n \n def suite():\n     from minitwit_tests import MiniTwitTestCase\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#3ab318a7ddca819e13d6d161b008b62b6583453e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 28 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 28 | Churn Cumulative: 2595 | Contributors (this commit): 9 | Commits (past 90d): 100 | Contributors (cumulative): 9 | DMM Complexity: None\n\nDIFF:\n@@ -806,6 +806,34 @@ class Flask(_PackageBoundObject):\n \n         from flask import Flask\n         app = Flask(__name__)\n+\n+    .. admonition:: About the First Parameter\n+\n+        The idea of the first parameter is to give Flask an idea what\n+        belongs to your application.  This name is used to find resources\n+        on the file system, can be used by extensions to improve debugging\n+        information and a lot more.\n+\n+        So it's important what you provide there.  If you are using a single\n+        module, `__name__` is always the correct value.  If you however are\n+        using a package, it's usually recommended to hardcode the name of\n+        your package there.\n+\n+        For example if your application is defined in `yourapplication/app.py`\n+        you should create it with one of the two versions below::\n+\n+            app = Flask('yourapplication')\n+            app = Flask(__name__.split('.')[0])\n+\n+        Why is that?  The application will work even with `__name__`, thanks\n+        to how resources are looked up.  However it will make debugging more\n+        painful.  Certain extensions can make assumptions based on the\n+        import name of your application.  For example the Flask-SQLAlchemy\n+        extension will look for the code in your application that triggered\n+        an SQL query in debug mode.  If the import name is not properly set\n+        up, that debugging information is lost.  (For example it would only\n+        pick up SQL queries in `yourapplicaiton.app` and not\n+        `yourapplication.views.frontend`)\n     \"\"\"\n \n     #: The class that is used for request objects.  See :class:`~flask.Request`\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#a154c87cfca3e21316552b2ec558029f9c96122a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 10 | Churn Cumulative: 2605 | Contributors (this commit): 9 | Commits (past 90d): 101 | Contributors (cumulative): 9 | DMM Complexity: None\n\nDIFF:\n@@ -1090,6 +1090,16 @@ class Flask(_PackageBoundObject):\n         :attr:`debug` flag is set the server will automatically reload\n         for code changes and show a debugger in case an exception happened.\n \n+        .. admonition:: Keep in Mind\n+\n+           Flask will supress any server error with a generic error page\n+           unless it is in debug mode.  As such to enable just the\n+           interactive debugger without the code reloading, you ahve to\n+           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n+           Setting ``use_debugger`` to `True` without being in debug mode\n+           won't catch any exceptions because there won't be any to\n+           catch.\n+\n         :param host: the hostname to listen on.  set this to ``'0.0.0.0'``\n                      to have the server available externally as well.\n         :param port: the port of the webserver\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#ee16a68bbd7caf4c8e79c5d6859f72ad38539bbf", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 1573 | Files Changed: 1 | Hunks: 1 | Methods Changed: 75 | Complexity Δ (Sum/Max): -168/0 | Churn Δ: 1573 | Churn Cumulative: 4178 | Contributors (this commit): 10 | Commits (past 90d): 102 | Contributors (cumulative): 10 | DMM Complexity: 0.10262008733624454\n\nDIFF:\n@@ -1,1573 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\"\"\"\n-    flask\n-    ~~~~~\n-\n-    A microframework based on Werkzeug.  It's extensively documented\n-    and follows best practice patterns.\n-\n-    :copyright: (c) 2010 by Armin Ronacher.\n-    :license: BSD, see LICENSE for more details.\n-\"\"\"\n-from __future__ import with_statement\n-import os\n-import sys\n-import mimetypes\n-from datetime import datetime, timedelta\n-\n-# this is a workaround for appengine.  Do not remove this import\n-import werkzeug\n-\n-from itertools import chain\n-from threading import Lock\n-from jinja2 import Environment, PackageLoader, FileSystemLoader\n-from werkzeug import Request as RequestBase, Response as ResponseBase, \\\n-     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \\\n-     ImmutableDict, cached_property, wrap_file, Headers, \\\n-     import_string\n-from werkzeug.routing import Map, Rule\n-from werkzeug.exceptions import HTTPException, InternalServerError\n-from werkzeug.contrib.securecookie import SecureCookie\n-\n-# try to load the best simplejson implementation available.  If JSON\n-# is not installed, we add a failing class.\n-json_available = True\n-try:\n-    import simplejson as json\n-except ImportError:\n-    try:\n-        import json\n-    except ImportError:\n-        json_available = False\n-\n-# utilities we import from Werkzeug and Jinja2 that are unused\n-# in the module but are exported as public interface.\n-from werkzeug import abort, redirect\n-from jinja2 import Markup, escape\n-\n-# use pkg_resource if that works, otherwise fall back to cwd.  The\n-# current working directory is generally not reliable with the notable\n-# exception of google appengine.\n-try:\n-    import pkg_resources\n-    pkg_resources.resource_stream\n-except (ImportError, AttributeError):\n-    pkg_resources = None\n-\n-# a lock used for logger initialization\n-_logger_lock = Lock()\n-\n-\n-class Request(RequestBase):\n-    \"\"\"The request object used by default in flask.  Remembers the\n-    matched endpoint and view arguments.\n-\n-    It is what ends up as :class:`~flask.request`.  If you want to replace\n-    the request object used you can subclass this and set\n-    :attr:`~flask.Flask.request_class` to your subclass.\n-    \"\"\"\n-\n-    #: the endpoint that matched the request.  This in combination with\n-    #: :attr:`view_args` can be used to reconstruct the same or a\n-    #: modified URL.  If an exception happened when matching, this will\n-    #: be `None`.\n-    endpoint = None\n-\n-    #: a dict of view arguments that matched the request.  If an exception\n-    #: happened when matching, this will be `None`.\n-    view_args = None\n-\n-    #: if matching the URL failed, this is the exception that will be\n-    #: raised / was raised as part of the request handling.  This is\n-    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or\n-    #: something similar.\n-    routing_exception = None\n-\n-    @property\n-    def module(self):\n-        \"\"\"The name of the current module\"\"\"\n-        if self.endpoint and '.' in self.endpoint:\n-            return self.endpoint.rsplit('.', 1)[0]\n-\n-    @cached_property\n-    def json(self):\n-        \"\"\"If the mimetype is `application/json` this will contain the\n-        parsed JSON data.\n-        \"\"\"\n-        if __debug__:\n-            _assert_have_json()\n-        if self.mimetype == 'application/json':\n-            return json.loads(self.data)\n-\n-\n-class Response(ResponseBase):\n-    \"\"\"The response object that is used by default in flask.  Works like the\n-    response object from Werkzeug but is set to have a HTML mimetype by\n-    default.  Quite often you don't have to create this object yourself because\n-    :meth:`~flask.Flask.make_response` will take care of that for you.\n-\n-    If you want to replace the response object used you can subclass this and\n-    set :attr:`~flask.Flask.response_class` to your subclass.\n-    \"\"\"\n-    default_mimetype = 'text/html'\n-\n-\n-class _RequestGlobals(object):\n-    pass\n-\n-\n-class Session(SecureCookie):\n-    \"\"\"Expands the session with support for switching between permanent\n-    and non-permanent sessions.\n-    \"\"\"\n-\n-    def _get_permanent(self):\n-        return self.get('_permanent', False)\n-\n-    def _set_permanent(self, value):\n-        self['_permanent'] = bool(value)\n-\n-    permanent = property(_get_permanent, _set_permanent)\n-    del _get_permanent, _set_permanent\n-\n-\n-class _NullSession(Session):\n-    \"\"\"Class used to generate nicer error messages if sessions are not\n-    available.  Will still allow read-only access to the empty session\n-    but fail on setting.\n-    \"\"\"\n-\n-    def _fail(self, *args, **kwargs):\n-        raise RuntimeError('the session is unavailable because no secret '\n-                           'key was set.  Set the secret_key on the '\n-                           'application to something unique and secret')\n-    __setitem__ = __delitem__ = clear = pop = popitem = \\\n-        update = setdefault = _fail\n-    del _fail\n-\n-\n-class _RequestContext(object):\n-    \"\"\"The request context contains all request relevant information.  It is\n-    created at the beginning of the request and pushed to the\n-    `_request_ctx_stack` and removed at the end of it.  It will create the\n-    URL adapter and request object for the WSGI environment provided.\n-    \"\"\"\n-\n-    def __init__(self, app, environ):\n-        self.app = app\n-        self.url_adapter = app.url_map.bind_to_environ(environ,\n-            server_name=app.config['SERVER_NAME'])\n-        self.request = app.request_class(environ)\n-        self.session = app.open_session(self.request)\n-        if self.session is None:\n-            self.session = _NullSession()\n-        self.g = _RequestGlobals()\n-        self.flashes = None\n-\n-        try:\n-            self.request.endpoint, self.request.view_args = \\\n-                self.url_adapter.match()\n-        except HTTPException, e:\n-            self.request.routing_exception = e\n-\n-    def push(self):\n-        \"\"\"Binds the request context.\"\"\"\n-        _request_ctx_stack.push(self)\n-\n-    def pop(self):\n-        \"\"\"Pops the request context.\"\"\"\n-        _request_ctx_stack.pop()\n-\n-    def __enter__(self):\n-        self.push()\n-        return self\n-\n-    def __exit__(self, exc_type, exc_value, tb):\n-        # do not pop the request stack if we are in debug mode and an\n-        # exception happened.  This will allow the debugger to still\n-        # access the request object in the interactive shell.  Furthermore\n-        # the context can be force kept alive for the test client.\n-        if not self.request.environ.get('flask._preserve_context') and \\\n-           (tb is None or not self.app.debug):\n-            self.pop()\n-\n-\n-def url_for(endpoint, **values):\n-    \"\"\"Generates a URL to the given endpoint with the method provided.\n-    The endpoint is relative to the active module if modules are in use.\n-\n-    Here some examples:\n-\n-    ==================== ======================= =============================\n-    Active Module        Target Endpoint         Target Function\n-    ==================== ======================= =============================\n-    `None`               ``'index'``             `index` of the application\n-    `None`               ``'.index'``            `index` of the application\n-    ``'admin'``          ``'index'``             `index` of the `admin` module\n-    any                  ``'.index'``            `index` of the application\n-    any                  ``'admin.index'``       `index` of the `admin` module\n-    ==================== ======================= =============================\n-\n-    Variable arguments that are unknown to the target endpoint are appended\n-    to the generated URL as query arguments.\n-\n-    For more information, head over to the :ref:`Quickstart <url-building>`.\n-\n-    :param endpoint: the endpoint of the URL (name of the function)\n-    :param values: the variable arguments of the URL rule\n-    :param _external: if set to `True`, an absolute URL is generated.\n-    \"\"\"\n-    ctx = _request_ctx_stack.top\n-    if '.' not in endpoint:\n-        mod = ctx.request.module\n-        if mod is not None:\n-            endpoint = mod + '.' + endpoint\n-    elif endpoint.startswith('.'):\n-        endpoint = endpoint[1:]\n-    external = values.pop('_external', False)\n-    return ctx.url_adapter.build(endpoint, values, force_external=external)\n-\n-\n-def get_template_attribute(template_name, attribute):\n-    \"\"\"Loads a macro (or variable) a template exports.  This can be used to\n-    invoke a macro from within Python code.  If you for example have a\n-    template named `_cider.html` with the following contents:\n-\n-    .. sourcecode:: html+jinja\n-\n-       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}\n-\n-    You can access this from Python code like this::\n-\n-        hello = get_template_attribute('_cider.html', 'hello')\n-        return hello('World')\n-\n-    .. versionadded:: 0.2\n-\n-    :param template_name: the name of the template\n-    :param attribute: the name of the variable of macro to acccess\n-    \"\"\"\n-    return getattr(current_app.jinja_env.get_template(template_name).module,\n-                   attribute)\n-\n-\n-def flash(message, category='message'):\n-    \"\"\"Flashes a message to the next request.  In order to remove the\n-    flashed message from the session and to display it to the user,\n-    the template has to call :func:`get_flashed_messages`.\n-\n-    .. versionchanged: 0.3\n-       `category` parameter added.\n-\n-    :param message: the message to be flashed.\n-    :param category: the category for the message.  The following values\n-                     are recommended: ``'message'`` for any kind of message,\n-                     ``'error'`` for errors, ``'info'`` for information\n-                     messages and ``'warning'`` for warnings.  However any\n-                     kind of string can be used as category.\n-    \"\"\"\n-    session.setdefault('_flashes', []).append((category, message))\n-\n-\n-def get_flashed_messages(with_categories=False):\n-    \"\"\"Pulls all flashed messages from the session and returns them.\n-    Further calls in the same request to the function will return\n-    the same messages.  By default just the messages are returned,\n-    but when `with_categories` is set to `True`, the return value will\n-    be a list of tuples in the form ``(category, message)`` instead.\n-\n-    Example usage:\n-\n-    .. sourcecode:: html+jinja\n-\n-        {% for category, msg in get_flashed_messages(with_categories=true) %}\n-          <p class=flash-{{ category }}>{{ msg }}\n-        {% endfor %}\n-\n-    .. versionchanged:: 0.3\n-       `with_categories` parameter added.\n-\n-    :param with_categories: set to `True` to also receive categories.\n-    \"\"\"\n-    flashes = _request_ctx_stack.top.flashes\n-    if flashes is None:\n-        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])\n-    if not with_categories:\n-        return [x[1] for x in flashes]\n-    return flashes\n-\n-\n-def jsonify(*args, **kwargs):\n-    \"\"\"Creates a :class:`~flask.Response` with the JSON representation of\n-    the given arguments with an `application/json` mimetype.  The arguments\n-    to this function are the same as to the :class:`dict` constructor.\n-\n-    Example usage::\n-\n-        @app.route('/_get_current_user')\n-        def get_current_user():\n-            return jsonify(username=g.user.username,\n-                           email=g.user.email,\n-                           id=g.user.id)\n-\n-    This will send a JSON response like this to the browser::\n-\n-        {\n-            \"username\": \"admin\",\n-            \"email\": \"admin@localhost\",\n-            \"id\": 42\n-        }\n-\n-    This requires Python 2.6 or an installed version of simplejson.  For\n-    security reasons only objects are supported toplevel.  For more\n-    information about this, have a look at :ref:`json-security`.\n-\n-    .. versionadded:: 0.2\n-    \"\"\"\n-    if __debug__:\n-        _assert_have_json()\n-    return current_app.response_class(json.dumps(dict(*args, **kwargs),\n-        indent=None if request.is_xhr else 2), mimetype='application/json')\n-\n-\n-def send_file(filename_or_fp, mimetype=None, as_attachment=False,\n-              attachment_filename=None):\n-    \"\"\"Sends the contents of a file to the client.  This will use the\n-    most efficient method available and configured.  By default it will\n-    try to use the WSGI server's file_wrapper support.  Alternatively\n-    you can set the application's :attr:`~Flask.use_x_sendfile` attribute\n-    to ``True`` to directly emit an `X-Sendfile` header.  This however\n-    requires support of the underlying webserver for `X-Sendfile`.\n-\n-    By default it will try to guess the mimetype for you, but you can\n-    also explicitly provide one.  For extra security you probably want\n-    to sent certain files as attachment (HTML for instance).\n-\n-    Please never pass filenames to this function from user sources without\n-    checking them first.  Something like this is usually sufficient to\n-    avoid security problems::\n-\n-        if '..' in filename or filename.startswith('/'):\n-            abort(404)\n-\n-    .. versionadded:: 0.2\n-\n-    :param filename_or_fp: the filename of the file to send.  This is\n-                           relative to the :attr:`~Flask.root_path` if a\n-                           relative path is specified.\n-                           Alternatively a file object might be provided\n-                           in which case `X-Sendfile` might not work and\n-                           fall back to the traditional method.\n-    :param mimetype: the mimetype of the file if provided, otherwise\n-                     auto detection happens.\n-    :param as_attachment: set to `True` if you want to send this file with\n-                          a ``Content-Disposition: attachment`` header.\n-    :param attachment_filename: the filename for the attachment if it\n-                                differs from the file's filename.\n-    \"\"\"\n-    if isinstance(filename_or_fp, basestring):\n-        filename = filename_or_fp\n-        file = None\n-    else:\n-        file = filename_or_fp\n-        filename = getattr(file, 'name', None)\n-    if filename is not None:\n-        filename = os.path.join(current_app.root_path, filename)\n-    if mimetype is None and (filename or attachment_filename):\n-        mimetype = mimetypes.guess_type(filename or attachment_filename)[0]\n-    if mimetype is None:\n-        mimetype = 'application/octet-stream'\n-\n-    headers = Headers()\n-    if as_attachment:\n-        if attachment_filename is None:\n-            if filename is None:\n-                raise TypeError('filename unavailable, required for '\n-                                'sending as attachment')\n-            attachment_filename = os.path.basename(filename)\n-        headers.add('Content-Disposition', 'attachment',\n-                    filename=attachment_filename)\n-\n-    if current_app.use_x_sendfile and filename:\n-        if file is not None:\n-            file.close()\n-        headers['X-Sendfile'] = filename\n-        data = None\n-    else:\n-        if file is None:\n-            file = open(filename, 'rb')\n-        data = wrap_file(request.environ, file)\n-\n-    return Response(data, mimetype=mimetype, headers=headers,\n-                    direct_passthrough=True)\n-\n-\n-def render_template(template_name, **context):\n-    \"\"\"Renders a template from the template folder with the given\n-    context.\n-\n-    :param template_name: the name of the template to be rendered\n-    :param context: the variables that should be available in the\n-                    context of the template.\n-    \"\"\"\n-    current_app.update_template_context(context)\n-    return current_app.jinja_env.get_template(template_name).render(context)\n-\n-\n-def render_template_string(source, **context):\n-    \"\"\"Renders a template from the given template source string\n-    with the given context.\n-\n-    :param template_name: the sourcecode of the template to be\n-                          rendered\n-    :param context: the variables that should be available in the\n-                    context of the template.\n-    \"\"\"\n-    current_app.update_template_context(context)\n-    return current_app.jinja_env.from_string(source).render(context)\n-\n-\n-def _default_template_ctx_processor():\n-    \"\"\"Default template context processor.  Injects `request`,\n-    `session` and `g`.\n-    \"\"\"\n-    reqctx = _request_ctx_stack.top\n-    return dict(\n-        request=reqctx.request,\n-        session=reqctx.session,\n-        g=reqctx.g\n-    )\n-\n-\n-def _assert_have_json():\n-    \"\"\"Helper function that fails if JSON is unavailable.\"\"\"\n-    if not json_available:\n-        raise RuntimeError('simplejson not installed')\n-\n-\n-def _get_package_path(name):\n-    \"\"\"Returns the path to a package or cwd if that cannot be found.\"\"\"\n-    try:\n-        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))\n-    except (KeyError, AttributeError):\n-        return os.getcwd()\n-\n-\n-# figure out if simplejson escapes slashes.  This behaviour was changed\n-# from one version to another without reason.\n-if not json_available or '\\\\/' not in json.dumps('/'):\n-\n-    def _tojson_filter(*args, **kwargs):\n-        if __debug__:\n-            _assert_have_json()\n-        return json.dumps(*args, **kwargs).replace('/', '\\\\/')\n-else:\n-    _tojson_filter = json.dumps\n-\n-\n-class _PackageBoundObject(object):\n-\n-    def __init__(self, import_name):\n-        #: The name of the package or module.  Do not change this once\n-        #: it was set by the constructor.\n-        self.import_name = import_name\n-\n-        #: Where is the app root located?\n-        self.root_path = _get_package_path(self.import_name)\n-\n-    def open_resource(self, resource):\n-        \"\"\"Opens a resource from the application's resource folder.  To see\n-        how this works, consider the following folder structure::\n-\n-            /myapplication.py\n-            /schemal.sql\n-            /static\n-                /style.css\n-            /templates\n-                /layout.html\n-                /index.html\n-\n-        If you want to open the `schema.sql` file you would do the\n-        following::\n-\n-            with app.open_resource('schema.sql') as f:\n-                contents = f.read()\n-                do_something_with(contents)\n-\n-        :param resource: the name of the resource.  To access resources within\n-                         subfolders use forward slashes as separator.\n-        \"\"\"\n-        if pkg_resources is None:\n-            return open(os.path.join(self.root_path, resource), 'rb')\n-        return pkg_resources.resource_stream(self.import_name, resource)\n-\n-\n-class _ModuleSetupState(object):\n-\n-    def __init__(self, app, url_prefix=None):\n-        self.app = app\n-        self.url_prefix = url_prefix\n-\n-\n-class Module(_PackageBoundObject):\n-    \"\"\"Container object that enables pluggable applications.  A module can\n-    be used to organize larger applications.  They represent blueprints that,\n-    in combination with a :class:`Flask` object are used to create a large\n-    application.\n-\n-    A module is like an application bound to an `import_name`.  Multiple\n-    modules can share the same import names, but in that case a `name` has\n-    to be provided to keep them apart.  If different import names are used,\n-    the rightmost part of the import name is used as name.\n-\n-    Here an example structure for a larger appliation::\n-\n-        /myapplication\n-            /__init__.py\n-            /views\n-                /__init__.py\n-                /admin.py\n-                /frontend.py\n-\n-    The `myapplication/__init__.py` can look like this::\n-\n-        from flask import Flask\n-        from myapplication.views.admin import admin\n-        from myapplication.views.frontend import frontend\n-\n-        app = Flask(__name__)\n-        app.register_module(admin, url_prefix='/admin')\n-        app.register_module(frontend)\n-\n-    And here an example view module (`myapplication/views/admin.py`)::\n-\n-        from flask import Module\n-\n-        admin = Module(__name__)\n-\n-        @admin.route('/')\n-        def index():\n-            pass\n-\n-        @admin.route('/login')\n-        def login():\n-            pass\n-\n-    For a gentle introduction into modules, checkout the\n-    :ref:`working-with-modules` section.\n-    \"\"\"\n-\n-    def __init__(self, import_name, name=None, url_prefix=None):\n-        if name is None:\n-            assert '.' in import_name, 'name required if package name ' \\\n-                'does not point to a submodule'\n-            name = import_name.rsplit('.', 1)[1]\n-        _PackageBoundObject.__init__(self, import_name)\n-        self.name = name\n-        self.url_prefix = url_prefix\n-        self._register_events = []\n-\n-    def route(self, rule, **options):\n-        \"\"\"Like :meth:`Flask.route` but for a module.  The endpoint for the\n-        :func:`url_for` function is prefixed with the name of the module.\n-        \"\"\"\n-        def decorator(f):\n-            self.add_url_rule(rule, f.__name__, f, **options)\n-            return f\n-        return decorator\n-\n-    def add_url_rule(self, rule, endpoint, view_func=None, **options):\n-        \"\"\"Like :meth:`Flask.add_url_rule` but for a module.  The endpoint for\n-        the :func:`url_for` function is prefixed with the name of the module.\n-        \"\"\"\n-        def register_rule(state):\n-            the_rule = rule\n-            if state.url_prefix:\n-                the_rule = state.url_prefix + rule\n-            state.app.add_url_rule(the_rule, '%s.%s' % (self.name, endpoint),\n-                                   view_func, **options)\n-        self._record(register_rule)\n-\n-    def before_request(self, f):\n-        \"\"\"Like :meth:`Flask.before_request` but for a module.  This function\n-        is only executed before each request that is handled by a function of\n-        that module.\n-        \"\"\"\n-        self._record(lambda s: s.app.before_request_funcs\n-            .setdefault(self.name, []).append(f))\n-        return f\n-\n-    def before_app_request(self, f):\n-        \"\"\"Like :meth:`Flask.before_request`.  Such a function is executed\n-        before each request, even if outside of a module.\n-        \"\"\"\n-        self._record(lambda s: s.app.before_request_funcs\n-            .setdefault(None, []).append(f))\n-        return f\n-\n-    def after_request(self, f):\n-        \"\"\"Like :meth:`Flask.after_request` but for a module.  This function\n-        is only executed after each request that is handled by a function of\n-        that module.\n-        \"\"\"\n-        self._record(lambda s: s.app.after_request_funcs\n-            .setdefault(self.name, []).append(f))\n-        return f\n-\n-    def after_app_request(self, f):\n-        \"\"\"Like :meth:`Flask.after_request` but for a module.  Such a function\n-        is executed after each request, even if outside of the module.\n-        \"\"\"\n-        self._record(lambda s: s.app.after_request_funcs\n-            .setdefault(None, []).append(f))\n-        return f\n-\n-    def context_processor(self, f):\n-        \"\"\"Like :meth:`Flask.context_processor` but for a module.  This\n-        function is only executed for requests handled by a module.\n-        \"\"\"\n-        self._record(lambda s: s.app.template_context_processors\n-            .setdefault(self.name, []).append(f))\n-        return f\n-\n-    def app_context_processor(self, f):\n-        \"\"\"Like :meth:`Flask.context_processor` but for a module.  Such a\n-        function is executed each request, even if outside of the module.\n-        \"\"\"\n-        self._record(lambda s: s.app.template_context_processors\n-            .setdefault(None, []).append(f))\n-        return f\n-\n-    def app_errorhandler(self, code):\n-        \"\"\"Like :meth:`Flask.errorhandler` but for a module.  This\n-        handler is used for all requests, even if outside of the module.\n-\n-        .. versionadded:: 0.4\n-        \"\"\"\n-        def decorator(f):\n-            self._record(lambda s: s.app.errorhandler(code)(f))\n-            return f\n-        return decorator\n-\n-    def _record(self, func):\n-        self._register_events.append(func)\n-\n-\n-class ConfigAttribute(object):\n-    \"\"\"Makes an attribute forward to the config\"\"\"\n-\n-    def __init__(self, name):\n-        self.__name__ = name\n-\n-    def __get__(self, obj, type=None):\n-        if obj is None:\n-            return self\n-        return obj.config[self.__name__]\n-\n-    def __set__(self, obj, value):\n-        obj.config[self.__name__] = value\n-\n-\n-class Config(dict):\n-    \"\"\"Works exactly like a dict but provides ways to fill it from files\n-    or special dictionaries.  There are two common patterns to populate the\n-    config.\n-\n-    Either you can fill the config from a config file::\n-\n-        app.config.from_pyfile('yourconfig.cfg')\n-\n-    Or alternatively you can define the configuration options in the\n-    module that calls :meth:`from_object` or provide an import path to\n-    a module that should be loaded.  It is also possible to tell it to\n-    use the same module and with that provide the configuration values\n-    just before the call::\n-\n-        DEBUG = True\n-        SECRET_KEY = 'development key'\n-        app.config.from_object(__name__)\n-\n-    In both cases (loading from any Python file or loading from modules),\n-    only uppercase keys are added to the config.  This makes it possible to use\n-    lowercase values in the config file for temporary values that are not added\n-    to the config or to define the config keys in the same file that implements\n-    the application.\n-\n-    Probably the most interesting way to load configurations is from an\n-    environment variable pointing to a file::\n-\n-        app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n-\n-    In this case before launching the application you have to set this\n-    environment variable to the file you want to use.  On Linux and OS X\n-    use the export statement::\n-\n-        export YOURAPPLICATION_SETTINGS='/path/to/config/file'\n-\n-    On windows use `set` instead.\n-\n-    :param root_path: path to which files are read relative from.  When the\n-                      config object is created by the application, this is\n-                      the application's :attr:`~flask.Flask.root_path`.\n-    :param defaults: an optional dictionary of default values\n-    \"\"\"\n-\n-    def __init__(self, root_path, defaults=None):\n-        dict.__init__(self, defaults or {})\n-        self.root_path = root_path\n-\n-    def from_envvar(self, variable_name, silent=False):\n-        \"\"\"Loads a configuration from an environment variable pointing to\n-        a configuration file.  This basically is just a shortcut with nicer\n-        error messages for this line of code::\n-\n-            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n-\n-        :param variable_name: name of the environment variable\n-        :param silent: set to `True` if you want silent failing for missing\n-                       files.\n-        :return: bool. `True` if able to load config, `False` otherwise.\n-        \"\"\"\n-        rv = os.environ.get(variable_name)\n-        if not rv:\n-            if silent:\n-                return False\n-            raise RuntimeError('The environment variable %r is not set '\n-                               'and as such configuration could not be '\n-                               'loaded.  Set this variable and make it '\n-                               'point to a configuration file' %\n-                               variable_name)\n-        self.from_pyfile(rv)\n-        return True\n-\n-    def from_pyfile(self, filename):\n-        \"\"\"Updates the values in the config from a Python file.  This function\n-        behaves as if the file was imported as module with the\n-        :meth:`from_object` function.\n-\n-        :param filename: the filename of the config.  This can either be an\n-                         absolute filename or a filename relative to the\n-                         root path.\n-        \"\"\"\n-        filename = os.path.join(self.root_path, filename)\n-        d = type(sys)('config')\n-        d.__file__ = filename\n-        execfile(filename, d.__dict__)\n-        self.from_object(d)\n-\n-    def from_object(self, obj):\n-        \"\"\"Updates the values from the given object.  An object can be of one\n-        of the following two types:\n-\n-        -   a string: in this case the object with that name will be imported\n-        -   an actual object reference: that object is used directly\n-\n-        Objects are usually either modules or classes.\n-\n-        Just the uppercase variables in that object are stored in the config\n-        after lowercasing.  Example usage::\n-\n-            app.config.from_object('yourapplication.default_config')\n-            from yourapplication import default_config\n-            app.config.from_object(default_config)\n-\n-        You should not use this function to load the actual configuration but\n-        rather configuration defaults.  The actual config should be loaded\n-        with :meth:`from_pyfile` and ideally from a location not within the\n-        package because the package might be installed system wide.\n-\n-        :param obj: an import name or object\n-        \"\"\"\n-        if isinstance(obj, basestring):\n-            obj = import_string(obj)\n-        for key in dir(obj):\n-            if key.isupper():\n-                self[key] = getattr(obj, key)\n-\n-    def __repr__(self):\n-        return '<%s %s>' % (self.__class__.__name__, dict.__repr__(self))\n-\n-\n-class Flask(_PackageBoundObject):\n-    \"\"\"The flask object implements a WSGI application and acts as the central\n-    object.  It is passed the name of the module or package of the\n-    application.  Once it is created it will act as a central registry for\n-    the view functions, the URL rules, template configuration and much more.\n-\n-    The name of the package is used to resolve resources from inside the\n-    package or the folder the module is contained in depending on if the\n-    package parameter resolves to an actual python package (a folder with\n-    an `__init__.py` file inside) or a standard module (just a `.py` file).\n-\n-    For more information about resource loading, see :func:`open_resource`.\n-\n-    Usually you create a :class:`Flask` instance in your main module or\n-    in the `__init__.py` file of your package like this::\n-\n-        from flask import Flask\n-        app = Flask(__name__)\n-\n-    .. admonition:: About the First Parameter\n-\n-        The idea of the first parameter is to give Flask an idea what\n-        belongs to your application.  This name is used to find resources\n-        on the file system, can be used by extensions to improve debugging\n-        information and a lot more.\n-\n-        So it's important what you provide there.  If you are using a single\n-        module, `__name__` is always the correct value.  If you however are\n-        using a package, it's usually recommended to hardcode the name of\n-        your package there.\n-\n-        For example if your application is defined in `yourapplication/app.py`\n-        you should create it with one of the two versions below::\n-\n-            app = Flask('yourapplication')\n-            app = Flask(__name__.split('.')[0])\n-\n-        Why is that?  The application will work even with `__name__`, thanks\n-        to how resources are looked up.  However it will make debugging more\n-        painful.  Certain extensions can make assumptions based on the\n-        import name of your application.  For example the Flask-SQLAlchemy\n-        extension will look for the code in your application that triggered\n-        an SQL query in debug mode.  If the import name is not properly set\n-        up, that debugging information is lost.  (For example it would only\n-        pick up SQL queries in `yourapplicaiton.app` and not\n-        `yourapplication.views.frontend`)\n-    \"\"\"\n-\n-    #: The class that is used for request objects.  See :class:`~flask.Request`\n-    #: for more information.\n-    request_class = Request\n-\n-    #: The class that is used for response objects.  See\n-    #: :class:`~flask.Response` for more information.\n-    response_class = Response\n-\n-    #: Path for the static files.  If you don't want to use static files\n-    #: you can set this value to `None` in which case no URL rule is added\n-    #: and the development server will no longer serve any static files.\n-    static_path = '/static'\n-\n-    #: The debug flag.  Set this to `True` to enable debugging of the\n-    #: application.  In debug mode the debugger will kick in when an unhandled\n-    #: exception ocurrs and the integrated server will automatically reload\n-    #: the application if changes in the code are detected.\n-    #:\n-    #: This attribute can also be configured from the config with the `DEBUG`\n-    #: configuration key.  Defaults to `False`.\n-    debug = ConfigAttribute('DEBUG')\n-\n-    #: The testing flask.  Set this to `True` to enable the test mode of\n-    #: Flask extensions (and in the future probably also Flask itself).\n-    #: For example this might activate unittest helpers that have an\n-    #: additional runtime cost which should not be enabled by default.\n-    #:\n-    #: This attribute can also be configured from the config with the\n-    #: `TESTING` configuration key.  Defaults to `False`.\n-    testing = ConfigAttribute('TESTING')\n-\n-    #: If a secret key is set, cryptographic components can use this to\n-    #: sign cookies and other things.  Set this to a complex random value\n-    #: when you want to use the secure cookie for instance.\n-    #:\n-    #: This attribute can also be configured from the config with the\n-    #: `SECRET_KEY` configuration key.  Defaults to `None`.\n-    secret_key = ConfigAttribute('SECRET_KEY')\n-\n-    #: The secure cookie uses this for the name of the session cookie.\n-    #:\n-    #: This attribute can also be configured from the config with the\n-    #: `SESSION_COOKIE_NAME` configuration key.  Defaults to ``'session'``\n-    session_cookie_name = ConfigAttribute('SESSION_COOKIE_NAME')\n-\n-    #: A :class:`~datetime.timedelta` which is used to set the expiration\n-    #: date of a permanent session.  The default is 31 days which makes a\n-    #: permanent session survive for roughly one month.\n-    #:\n-    #: This attribute can also be configured from the config with the\n-    #: `PERMANENT_SESSION_LIFETIME` configuration key.  Defaults to\n-    #: ``timedelta(days=31)``\n-    permanent_session_lifetime = ConfigAttribute('PERMANENT_SESSION_LIFETIME')\n-\n-    #: Enable this if you want to use the X-Sendfile feature.  Keep in\n-    #: mind that the server has to support this.  This only affects files\n-    #: sent with the :func:`send_file` method.\n-    #:\n-    #: .. versionadded:: 0.2\n-    #:\n-    #: This attribute can also be configured from the config with the\n-    #: `USE_X_SENDFILE` configuration key.  Defaults to `False`.\n-    use_x_sendfile = ConfigAttribute('USE_X_SENDFILE')\n-\n-    #: The name of the logger to use.  By default the logger name is the\n-    #: package name passed to the constructor.\n-    #:\n-    #: .. versionadded:: 0.4\n-    logger_name = ConfigAttribute('LOGGER_NAME')\n-\n-    #: The logging format used for the debug logger.  This is only used when\n-    #: the application is in debug mode, otherwise the attached logging\n-    #: handler does the formatting.\n-    #:\n-    #: .. versionadded:: 0.3\n-    debug_log_format = (\n-        '-' * 80 + '\\n' +\n-        '%(levelname)s in %(module)s [%(pathname)s:%(lineno)d]:\\n' +\n-        '%(message)s\\n' +\n-        '-' * 80\n-    )\n-\n-    #: Options that are passed directly to the Jinja2 environment.\n-    jinja_options = ImmutableDict(\n-        autoescape=True,\n-        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']\n-    )\n-\n-    #: Default configuration parameters.\n-    default_config = ImmutableDict({\n-        'DEBUG':                                False,\n-        'TESTING':                              False,\n-        'SECRET_KEY':                           None,\n-        'SESSION_COOKIE_NAME':                  'session',\n-        'PERMANENT_SESSION_LIFETIME':           timedelta(days=31),\n-        'USE_X_SENDFILE':                       False,\n-        'LOGGER_NAME':                          None,\n-        'SERVER_NAME':                          None\n-    })\n-\n-    def __init__(self, import_name):\n-        _PackageBoundObject.__init__(self, import_name)\n-\n-        #: The configuration dictionary as :class:`Config`.  This behaves\n-        #: exactly like a regular dictionary but supports additional methods\n-        #: to load a config from files.\n-        self.config = Config(self.root_path, self.default_config)\n-\n-        #: Prepare the deferred setup of the logger.\n-        self._logger = None\n-        self.logger_name = self.import_name\n-\n-        #: A dictionary of all view functions registered.  The keys will\n-        #: be function names which are also used to generate URLs and\n-        #: the values are the function objects themselves.\n-        #: to register a view function, use the :meth:`route` decorator.\n-        self.view_functions = {}\n-\n-        #: A dictionary of all registered error handlers.  The key is\n-        #: be the error code as integer, the value the function that\n-        #: should handle that error.\n-        #: To register a error handler, use the :meth:`errorhandler`\n-        #: decorator.\n-        self.error_handlers = {}\n-\n-        #: A dictionary with lists of functions that should be called at the\n-        #: beginning of the request.  The key of the dictionary is the name of\n-        #: the module this function is active for, `None` for all requests.\n-        #: This can for example be used to open database connections or\n-        #: getting hold of the currently logged in user.  To register a\n-        #: function here, use the :meth:`before_request` decorator.\n-        self.before_request_funcs = {}\n-\n-        #: A dictionary with lists of functions that should be called after\n-        #: each request.  The key of the dictionary is the name of the module\n-        #: this function is active for, `None` for all requests.  This can for\n-        #: example be used to open database connections or getting hold of the\n-        #: currently logged in user.  To register a function here, use the\n-        #: :meth:`before_request` decorator.\n-        self.after_request_funcs = {}\n-\n-        #: A dictionary with list of functions that are called without argument\n-        #: to populate the template context.  They key of the dictionary is the\n-        #: name of the module this function is active for, `None` for all\n-        #: requests.  Each returns a dictionary that the template context is\n-        #: updated with.  To register a function here, use the\n-        #: :meth:`context_processor` decorator.\n-        self.template_context_processors = {\n-            None: [_default_template_ctx_processor]\n-        }\n-\n-        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n-        #: this to change the routing converters after the class was created\n-        #: but before any routes are connected.  Example::\n-        #:\n-        #:    from werkzeug import BaseConverter\n-        #:\n-        #:    class ListConverter(BaseConverter):\n-        #:        def to_python(self, value):\n-        #:            return value.split(',')\n-        #:        def to_url(self, values):\n-        #:            return ','.join(BaseConverter.to_url(value)\n-        #:                            for value in values)\n-        #:\n-        #:    app = Flask(__name__)\n-        #:    app.url_map.converters['list'] = ListConverter\n-        self.url_map = Map()\n-\n-        if self.static_path is not None:\n-            self.add_url_rule(self.static_path + '/<filename>',\n-                              build_only=True, endpoint='static')\n-            if pkg_resources is not None:\n-                target = (self.import_name, 'static')\n-            else:\n-                target = os.path.join(self.root_path, 'static')\n-            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {\n-                self.static_path: target\n-            })\n-\n-        #: The Jinja2 environment.  It is created from the\n-        #: :attr:`jinja_options` and the loader that is returned\n-        #: by the :meth:`create_jinja_loader` function.\n-        self.jinja_env = Environment(loader=self.create_jinja_loader(),\n-                                     **self.jinja_options)\n-        self.jinja_env.globals.update(\n-            url_for=url_for,\n-            get_flashed_messages=get_flashed_messages\n-        )\n-        self.jinja_env.filters['tojson'] = _tojson_filter\n-\n-    @property\n-    def logger(self):\n-        \"\"\"A :class:`logging.Logger` object for this application.  The\n-        default configuration is to log to stderr if the application is\n-        in debug mode.  This logger can be used to (surprise) log messages.\n-        Here some examples::\n-\n-            app.logger.debug('A value for debugging')\n-            app.logger.warning('A warning ocurred (%d apples)', 42)\n-            app.logger.error('An error occoured')\n-\n-        .. versionadded:: 0.3\n-        \"\"\"\n-        if self._logger and self._logger.name == self.logger_name:\n-            return self._logger\n-        with _logger_lock:\n-            if self._logger and self._logger.name == self.logger_name:\n-                return self._logger\n-            from logging import getLogger, StreamHandler, Formatter, \\\n-                                Logger,  DEBUG\n-            class DebugLogger(Logger):\n-                def getEffectiveLevel(x):\n-                    return DEBUG if self.debug else Logger.getEffectiveLevel(x)\n-            class DebugHandler(StreamHandler):\n-                def emit(x, record):\n-                    StreamHandler.emit(x, record) if self.debug else None\n-            handler = DebugHandler()\n-            handler.setLevel(DEBUG)\n-            handler.setFormatter(Formatter(self.debug_log_format))\n-            logger = getLogger(self.logger_name)\n-            logger.__class__ = DebugLogger\n-            logger.addHandler(handler)\n-            self._logger = logger\n-            return logger\n-\n-    def create_jinja_loader(self):\n-        \"\"\"Creates the Jinja loader.  By default just a package loader for\n-        the configured package is returned that looks up templates in the\n-        `templates` folder.  To add other loaders it's possible to\n-        override this method.\n-        \"\"\"\n-        if pkg_resources is None:\n-            return FileSystemLoader(os.path.join(self.root_path, 'templates'))\n-        return PackageLoader(self.import_name)\n-\n-    def update_template_context(self, context):\n-        \"\"\"Update the template context with some commonly used variables.\n-        This injects request, session and g into the template context.\n-\n-        :param context: the context as a dictionary that is updated in place\n-                        to add extra variables.\n-        \"\"\"\n-        funcs = self.template_context_processors[None]\n-        mod = _request_ctx_stack.top.request.module\n-        if mod is not None and mod in self.template_context_processors:\n-            funcs = chain(funcs, self.template_context_processors[mod])\n-        for func in funcs:\n-            context.update(func())\n-\n-    def run(self, host='127.0.0.1', port=5000, **options):\n-        \"\"\"Runs the application on a local development server.  If the\n-        :attr:`debug` flag is set the server will automatically reload\n-        for code changes and show a debugger in case an exception happened.\n-\n-        .. admonition:: Keep in Mind\n-\n-           Flask will supress any server error with a generic error page\n-           unless it is in debug mode.  As such to enable just the\n-           interactive debugger without the code reloading, you ahve to\n-           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n-           Setting ``use_debugger`` to `True` without being in debug mode\n-           won't catch any exceptions because there won't be any to\n-           catch.\n-\n-        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``\n-                     to have the server available externally as well.\n-        :param port: the port of the webserver\n-        :param options: the options to be forwarded to the underlying\n-                        Werkzeug server.  See :func:`werkzeug.run_simple`\n-                        for more information.\n-        \"\"\"\n-        from werkzeug import run_simple\n-        if 'debug' in options:\n-            self.debug = options.pop('debug')\n-        options.setdefault('use_reloader', self.debug)\n-        options.setdefault('use_debugger', self.debug)\n-        return run_simple(host, port, self, **options)\n-\n-    def test_client(self):\n-        \"\"\"Creates a test client for this application.  For information\n-        about unit testing head over to :ref:`testing`.\n-\n-        The test client can be used in a `with` block to defer the closing down\n-        of the context until the end of the `with` block.  This is useful if\n-        you want to access the context locals for testing::\n-\n-            with app.test_client() as c:\n-                rv = c.get('/?vodka=42')\n-                assert request.args['vodka'] == '42'\n-\n-        .. versionchanged:: 0.4\n-           added support for `with` block usage for the client.\n-        \"\"\"\n-        from werkzeug import Client\n-        class FlaskClient(Client):\n-            preserve_context = context_preserved = False\n-            def open(self, *args, **kwargs):\n-                if self.context_preserved:\n-                    _request_ctx_stack.pop()\n-                    self.context_preserved = False\n-                kwargs.setdefault('environ_overrides', {}) \\\n-                    ['flask._preserve_context'] = self.preserve_context\n-                old = _request_ctx_stack.top\n-                try:\n-                    return Client.open(self, *args, **kwargs)\n-                finally:\n-                    self.context_preserved = _request_ctx_stack.top is not old\n-            def __enter__(self):\n-                self.preserve_context = True\n-                return self\n-            def __exit__(self, exc_type, exc_value, tb):\n-                self.preserve_context = False\n-                if self.context_preserved:\n-                    _request_ctx_stack.pop()\n-        return FlaskClient(self, self.response_class, use_cookies=True)\n-\n-    def open_session(self, request):\n-        \"\"\"Creates or opens a new session.  Default implementation stores all\n-        session data in a signed cookie.  This requires that the\n-        :attr:`secret_key` is set.\n-\n-        :param request: an instance of :attr:`request_class`.\n-        \"\"\"\n-        key = self.secret_key\n-        if key is not None:\n-            return Session.load_cookie(request, self.session_cookie_name,\n-                                       secret_key=key)\n-\n-    def save_session(self, session, response):\n-        \"\"\"Saves the session if it needs updates.  For the default\n-        implementation, check :meth:`open_session`.\n-\n-        :param session: the session to be saved (a\n-                        :class:`~werkzeug.contrib.securecookie.SecureCookie`\n-                        object)\n-        :param response: an instance of :attr:`response_class`\n-        \"\"\"\n-        expires = None\n-        if session.permanent:\n-            expires = datetime.utcnow() + self.permanent_session_lifetime\n-        session.save_cookie(response, self.session_cookie_name,\n-                            expires=expires, httponly=True)\n-\n-    def register_module(self, module, **options):\n-        \"\"\"Registers a module with this application.  The keyword argument\n-        of this function are the same as the ones for the constructor of the\n-        :class:`Module` class and will override the values of the module if\n-        provided.\n-        \"\"\"\n-        options.setdefault('url_prefix', module.url_prefix)\n-        state = _ModuleSetupState(self, **options)\n-        for func in module._register_events:\n-            func(state)\n-\n-    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n-        \"\"\"Connects a URL rule.  Works exactly like the :meth:`route`\n-        decorator.  If a view_func is provided it will be registered with the\n-        endpoint.\n-\n-        Basically this example::\n-\n-            @app.route('/')\n-            def index():\n-                pass\n-\n-        Is equivalent to the following::\n-\n-            def index():\n-                pass\n-            app.add_url_rule('/', 'index', index)\n-\n-        If the view_func is not provided you will need to connect the endpoint\n-        to a view function like so::\n-\n-            app.view_functions['index'] = index\n-\n-        .. versionchanged:: 0.2\n-           `view_func` parameter added.\n-\n-        :param rule: the URL rule as string\n-        :param endpoint: the endpoint for the registered URL rule.  Flask\n-                         itself assumes the name of the view function as\n-                         endpoint\n-        :param view_func: the function to call when serving a request to the\n-                          provided endpoint\n-        :param options: the options to be forwarded to the underlying\n-                        :class:`~werkzeug.routing.Rule` object\n-        \"\"\"\n-        if endpoint is None:\n-            assert view_func is not None, 'expected view func if endpoint ' \\\n-                                          'is not provided.'\n-            endpoint = view_func.__name__\n-        options['endpoint'] = endpoint\n-        options.setdefault('methods', ('GET',))\n-        self.url_map.add(Rule(rule, **options))\n-        if view_func is not None:\n-            self.view_functions[endpoint] = view_func\n-\n-    def route(self, rule, **options):\n-        \"\"\"A decorator that is used to register a view function for a\n-        given URL rule.  Example::\n-\n-            @app.route('/')\n-            def index():\n-                return 'Hello World'\n-\n-        Variables parts in the route can be specified with angular\n-        brackets (``/user/<username>``).  By default a variable part\n-        in the URL accepts any string without a slash however a different\n-        converter can be specified as well by using ``<converter:name>``.\n-\n-        Variable parts are passed to the view function as keyword\n-        arguments.\n-\n-        The following converters are possible:\n-\n-        =========== ===========================================\n-        `int`       accepts integers\n-        `float`     like `int` but for floating point values\n-        `path`      like the default but also accepts slashes\n-        =========== ===========================================\n-\n-        Here some examples::\n-\n-            @app.route('/')\n-            def index():\n-                pass\n-\n-            @app.route('/<username>')\n-            def show_user(username):\n-                pass\n-\n-            @app.route('/post/<int:post_id>')\n-            def show_post(post_id):\n-                pass\n-\n-        An important detail to keep in mind is how Flask deals with trailing\n-        slashes.  The idea is to keep each URL unique so the following rules\n-        apply:\n-\n-        1. If a rule ends with a slash and is requested without a slash\n-           by the user, the user is automatically redirected to the same\n-           page with a trailing slash attached.\n-        2. If a rule does not end with a trailing slash and the user request\n-           the page with a trailing slash, a 404 not found is raised.\n-\n-        This is consistent with how web servers deal with static files.  This\n-        also makes it possible to use relative link targets safely.\n-\n-        The :meth:`route` decorator accepts a couple of other arguments\n-        as well:\n-\n-        :param rule: the URL rule as string\n-        :param methods: a list of methods this rule should be limited\n-                        to (``GET``, ``POST`` etc.).  By default a rule\n-                        just listens for ``GET`` (and implicitly ``HEAD``).\n-        :param subdomain: specifies the rule for the subdoain in case\n-                          subdomain matching is in use.\n-        :param strict_slashes: can be used to disable the strict slashes\n-                               setting for this rule.  See above.\n-        :param options: other options to be forwarded to the underlying\n-                        :class:`~werkzeug.routing.Rule` object.\n-        \"\"\"\n-        def decorator(f):\n-            self.add_url_rule(rule, None, f, **options)\n-            return f\n-        return decorator\n-\n-    def errorhandler(self, code):\n-        \"\"\"A decorator that is used to register a function give a given\n-        error code.  Example::\n-\n-            @app.errorhandler(404)\n-            def page_not_found(error):\n-                return 'This page does not exist', 404\n-\n-        You can also register a function as error handler without using\n-        the :meth:`errorhandler` decorator.  The following example is\n-        equivalent to the one above::\n-\n-            def page_not_found(error):\n-                return 'This page does not exist', 404\n-            app.error_handlers[404] = page_not_found\n-\n-        :param code: the code as integer for the handler\n-        \"\"\"\n-        def decorator(f):\n-            self.error_handlers[code] = f\n-            return f\n-        return decorator\n-\n-    def template_filter(self, name=None):\n-        \"\"\"A decorator that is used to register custom template filter.\n-        You can specify a name for the filter, otherwise the function\n-        name will be used. Example::\n-\n-          @app.template_filter()\n-          def reverse(s):\n-              return s[::-1]\n-\n-        :param name: the optional name of the filter, otherwise the\n-                     function name will be used.\n-        \"\"\"\n-        def decorator(f):\n-            self.jinja_env.filters[name or f.__name__] = f\n-            return f\n-        return decorator\n-\n-    def before_request(self, f):\n-        \"\"\"Registers a function to run before each request.\"\"\"\n-        self.before_request_funcs.setdefault(None, []).append(f)\n-        return f\n-\n-    def after_request(self, f):\n-        \"\"\"Register a function to be run after each request.\"\"\"\n-        self.after_request_funcs.setdefault(None, []).append(f)\n-        return f\n-\n-    def context_processor(self, f):\n-        \"\"\"Registers a template context processor function.\"\"\"\n-        self.template_context_processors[None].append(f)\n-        return f\n-\n-    def handle_http_exception(self, e):\n-        \"\"\"Handles an HTTP exception.  By default this will invoke the\n-        registered error handlers and fall back to returning the\n-        exception as response.\n-\n-        .. versionadded: 0.3\n-        \"\"\"\n-        handler = self.error_handlers.get(e.code)\n-        if handler is None:\n-            return e\n-        return handler(e)\n-\n-    def handle_exception(self, e):\n-        \"\"\"Default exception handling that kicks in when an exception\n-        occours that is not catched.  In debug mode the exception will\n-        be re-raised immediately, otherwise it is logged and the handler\n-        for a 500 internal server error is used.  If no such handler\n-        exists, a default 500 internal server error message is displayed.\n-\n-        .. versionadded: 0.3\n-        \"\"\"\n-        handler = self.error_handlers.get(500)\n-        if self.debug:\n-            raise\n-        self.logger.exception('Exception on %s [%s]' % (\n-            request.path,\n-            request.method\n-        ))\n-        if handler is None:\n-            return InternalServerError()\n-        return handler(e)\n-\n-    def dispatch_request(self):\n-        \"\"\"Does the request dispatching.  Matches the URL and returns the\n-        return value of the view or error handler.  This does not have to\n-        be a response object.  In order to convert the return value to a\n-        proper response object, call :func:`make_response`.\n-        \"\"\"\n-        req = _request_ctx_stack.top.request\n-        try:\n-            if req.routing_exception is not None:\n-                raise req.routing_exception\n-            return self.view_functions[req.endpoint](**req.view_args)\n-        except HTTPException, e:\n-            return self.handle_http_exception(e)\n-\n-    def make_response(self, rv):\n-        \"\"\"Converts the return value from a view function to a real\n-        response object that is an instance of :attr:`response_class`.\n-\n-        The following types are allowed for `rv`:\n-\n-        .. tabularcolumns:: |p{3.5cm}|p{9.5cm}|\n-\n-        ======================= ===========================================\n-        :attr:`response_class`  the object is returned unchanged\n-        :class:`str`            a response object is created with the\n-                                string as body\n-        :class:`unicode`        a response object is created with the\n-                                string encoded to utf-8 as body\n-        :class:`tuple`          the response object is created with the\n-                                contents of the tuple as arguments\n-        a WSGI function         the function is called as WSGI application\n-                                and buffered as response object\n-        ======================= ===========================================\n-\n-        :param rv: the return value from the view function\n-        \"\"\"\n-        if rv is None:\n-            raise ValueError('View function did not return a response')\n-        if isinstance(rv, self.response_class):\n-            return rv\n-        if isinstance(rv, basestring):\n-            return self.response_class(rv)\n-        if isinstance(rv, tuple):\n-            return self.response_class(*rv)\n-        return self.response_class.force_type(rv, request.environ)\n-\n-    def preprocess_request(self):\n-        \"\"\"Called before the actual request dispatching and will\n-        call every as :meth:`before_request` decorated function.\n-        If any of these function returns a value it's handled as\n-        if it was the return value from the view and further\n-        request handling is stopped.\n-        \"\"\"\n-        funcs = self.before_request_funcs.get(None, ())\n-        mod = request.module\n-        if mod and mod in self.before_request_funcs:\n-            funcs = chain(funcs, self.before_request_funcs[mod])\n-        for func in funcs:\n-            rv = func()\n-            if rv is not None:\n-                return rv\n-\n-    def process_response(self, response):\n-        \"\"\"Can be overridden in order to modify the response object\n-        before it's sent to the WSGI server.  By default this will\n-        call all the :meth:`after_request` decorated functions.\n-\n-        :param response: a :attr:`response_class` object.\n-        :return: a new response object or the same, has to be an\n-                 instance of :attr:`response_class`.\n-        \"\"\"\n-        ctx = _request_ctx_stack.top\n-        mod = ctx.request.module\n-        if not isinstance(ctx.session, _NullSession):\n-            self.save_session(ctx.session, response)\n-        funcs = ()\n-        if mod and mod in self.after_request_funcs:\n-            funcs = chain(funcs, self.after_request_funcs[mod])\n-        if None in self.after_request_funcs:\n-            funcs = chain(funcs, self.after_request_funcs[None])\n-        for handler in funcs:\n-            response = handler(response)\n-        return response\n-\n-    def wsgi_app(self, environ, start_response):\n-        \"\"\"The actual WSGI application.  This is not implemented in\n-        `__call__` so that middlewares can be applied without losing a\n-        reference to the class.  So instead of doing this::\n-\n-            app = MyMiddleware(app)\n-\n-        It's a better idea to do this instead::\n-\n-            app.wsgi_app = MyMiddleware(app.wsgi_app)\n-\n-        Then you still have the original application object around and\n-        can continue to call methods on it.\n-\n-        .. versionchanged:: 0.4\n-           The :meth:`after_request` functions are now called even if an\n-           error handler took over request processing.  This ensures that\n-           even if an exception happens database have the chance to\n-           properly close the connection.\n-\n-        :param environ: a WSGI environment\n-        :param start_response: a callable accepting a status code,\n-                               a list of headers and an optional\n-                               exception context to start the response\n-        \"\"\"\n-        with self.request_context(environ):\n-            try:\n-                rv = self.preprocess_request()\n-                if rv is None:\n-                    rv = self.dispatch_request()\n-                response = self.make_response(rv)\n-            except Exception, e:\n-                response = self.make_response(self.handle_exception(e))\n-            try:\n-                response = self.process_response(response)\n-            except Exception, e:\n-                response = self.make_response(self.handle_exception(e))\n-            return response(environ, start_response)\n-\n-    def request_context(self, environ):\n-        \"\"\"Creates a request context from the given environment and binds\n-        it to the current context.  This must be used in combination with\n-        the `with` statement because the request is only bound to the\n-        current context for the duration of the `with` block.\n-\n-        Example usage::\n-\n-            with app.request_context(environ):\n-                do_something_with(request)\n-\n-        The object returned can also be used without the `with` statement\n-        which is useful for working in the shell.  The example above is\n-        doing exactly the same as this code::\n-\n-            ctx = app.request_context(environ)\n-            ctx.push()\n-            try:\n-                do_something_with(request)\n-            finally:\n-                ctx.pop()\n-\n-        The big advantage of this approach is that you can use it without\n-        the try/finally statement in a shell for interactive testing:\n-\n-        >>> ctx = app.test_request_context()\n-        >>> ctx.bind()\n-        >>> request.path\n-        u'/'\n-        >>> ctx.unbind()\n-\n-        .. versionchanged:: 0.3\n-           Added support for non-with statement usage and `with` statement\n-           is now passed the ctx object.\n-\n-        :param environ: a WSGI environment\n-        \"\"\"\n-        return _RequestContext(self, environ)\n-\n-    def test_request_context(self, *args, **kwargs):\n-        \"\"\"Creates a WSGI environment from the given values (see\n-        :func:`werkzeug.create_environ` for more information, this\n-        function accepts the same arguments).\n-        \"\"\"\n-        return self.request_context(create_environ(*args, **kwargs))\n-\n-    def __call__(self, environ, start_response):\n-        \"\"\"Shortcut for :attr:`wsgi_app`.\"\"\"\n-        return self.wsgi_app(environ, start_response)\n-\n-\n-# context locals\n-_request_ctx_stack = LocalStack()\n-current_app = LocalProxy(lambda: _request_ctx_stack.top.app)\n-request = LocalProxy(lambda: _request_ctx_stack.top.request)\n-session = LocalProxy(lambda: _request_ctx_stack.top.session)\n-g = LocalProxy(lambda: _request_ctx_stack.top.g)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
