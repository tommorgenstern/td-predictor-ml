{"custom_id": "flask#7b28a9057d6925ae408ef73a9f28e9906d9300b3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 251 | Contributors (this commit): 2 | Commits (past 90d): 7 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -42,4 +42,4 @@ from .signals import template_rendered as template_rendered\n from .templating import render_template as render_template\n from .templating import render_template_string as render_template_string\n \n-__version__ = \"2.1.2.dev0\"\n+__version__ = \"2.1.2\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#8ddbad9ccdc176b9d57a4aff0076c1c58c455318", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 8 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 9 | Churn Cumulative: 620 | Contributors (this commit): 13 | Commits (past 90d): 3 | Contributors (cumulative): 13 | DMM Complexity: None\n\nDIFF:\n@@ -9,6 +9,8 @@ from functools import update_wrapper\n from operator import attrgetter\n from threading import Lock\n from threading import Thread\n+from typing import Any\n+from typing import TYPE_CHECKING\n \n import click\n from werkzeug.utils import import_string\n@@ -36,7 +38,12 @@ else:\n     # We technically have importlib.metadata on 3.8+,\n     # but the API changed in 3.10, so use the backport\n     # for consistency.\n-    import importlib_metadata as metadata  # type: ignore\n+    if TYPE_CHECKING:\n+        metadata: Any\n+    else:\n+        # we do this to avoid a version dependent mypy error\n+        # because importlib_metadata is not installed in python3.10+\n+        import importlib_metadata as metadata\n \n \n class NoAppException(click.UsageError):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#1e5dd430223369d13ea94ffffe22bca53a98e730", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 37 | Lines Deleted: 35 | Files Changed: 3 | Hunks: 12 | Methods Changed: 5 | Complexity Δ (Sum/Max): 0/1 | Churn Δ: 72 | Churn Cumulative: 6776 | Contributors (this commit): 58 | Commits (past 90d): 8 | Contributors (cumulative): 68 | DMM Complexity: 0.0\n\nDIFF:\n@@ -697,22 +697,7 @@ class Scaffold:\n \n         .. versionadded:: 0.7\n         \"\"\"\n-        if isinstance(code_or_exception, HTTPException):  # old broken behavior\n-            raise ValueError(\n-                \"Tried to register a handler for an exception instance\"\n-                f\" {code_or_exception!r}. Handlers can only be\"\n-                \" registered for exception classes or HTTP error codes.\"\n-            )\n-\n-        try:\n         exc_class, code = self._get_exc_class_and_code(code_or_exception)\n-        except KeyError:\n-            raise KeyError(\n-                f\"'{code_or_exception}' is not a recognized HTTP error\"\n-                \" code. Use a subclass of HTTPException with that code\"\n-                \" instead.\"\n-            ) from None\n-\n         self.error_handler_spec[None][code][exc_class] = f\n \n     @staticmethod\n@@ -727,14 +712,32 @@ class Scaffold:\n             code as an integer.\n         \"\"\"\n         exc_class: t.Type[Exception]\n+\n         if isinstance(exc_class_or_code, int):\n+            try:\n                 exc_class = default_exceptions[exc_class_or_code]\n+            except KeyError:\n+                raise ValueError(\n+                    f\"'{exc_class_or_code}' is not a recognized HTTP\"\n+                    \" error code. Use a subclass of HTTPException with\"\n+                    \" that code instead.\"\n+                ) from None\n         else:\n             exc_class = exc_class_or_code\n \n-        assert issubclass(\n-            exc_class, Exception\n-        ), \"Custom exceptions must be subclasses of Exception.\"\n+        if isinstance(exc_class, Exception):\n+            raise TypeError(\n+                f\"{exc_class!r} is an instance, not a class. Handlers\"\n+                \" can only be registered for Exception classes or HTTP\"\n+                \" error codes.\"\n+            )\n+\n+        if not issubclass(exc_class, Exception):\n+            raise ValueError(\n+                f\"'{exc_class.__name__}' is not a subclass of Exception.\"\n+                \" Handlers can only be registered for Exception classes\"\n+                \" or HTTP error codes.\"\n+            )\n \n         if issubclass(exc_class, HTTPException):\n             return exc_class, exc_class.code\n\n@@ -899,13 +899,6 @@ def test_error_handling(app, client):\n     assert b\"forbidden\" == rv.data\n \n \n-def test_error_handler_unknown_code(app):\n-    with pytest.raises(KeyError) as exc_info:\n-        app.register_error_handler(999, lambda e: (\"999\", 999))\n-\n-    assert \"Use a subclass\" in exc_info.value.args[0]\n-\n-\n def test_error_handling_processing(app, client):\n     app.testing = False\n \n\n@@ -11,29 +11,35 @@ def test_error_handler_no_match(app, client):\n     class CustomException(Exception):\n         pass\n \n-    class UnacceptableCustomException(BaseException):\n-        pass\n-\n     @app.errorhandler(CustomException)\n     def custom_exception_handler(e):\n         assert isinstance(e, CustomException)\n         return \"custom\"\n \n-    with pytest.raises(\n-        AssertionError, match=\"Custom exceptions must be subclasses of Exception.\"\n-    ):\n-        app.register_error_handler(UnacceptableCustomException, None)\n+    with pytest.raises(TypeError) as exc_info:\n+        app.register_error_handler(CustomException(), None)\n+\n+    assert \"CustomException() is an instance, not a class.\" in str(exc_info.value)\n+\n+    with pytest.raises(ValueError) as exc_info:\n+        app.register_error_handler(list, None)\n+\n+    assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)\n \n     @app.errorhandler(500)\n     def handle_500(e):\n         assert isinstance(e, InternalServerError)\n-        original = getattr(e, \"original_exception\", None)\n \n-        if original is not None:\n-            return f\"wrapped {type(original).__name__}\"\n+        if e.original_exception is not None:\n+            return f\"wrapped {type(e.original_exception).__name__}\"\n \n         return \"direct\"\n \n+    with pytest.raises(ValueError) as exc_info:\n+        app.register_error_handler(999, None)\n+\n+    assert \"Use a subclass of HTTPException\" in str(exc_info.value)\n+\n     @app.route(\"/custom\")\n     def custom_test():\n         raise CustomException()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#a74e266474f0981e9fc0d54d5dc430386823e4d7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 13 | Lines Deleted: 13 | Files Changed: 13 | Hunks: 13 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 26 | Churn Cumulative: 7591 | Contributors (this commit): 46 | Commits (past 90d): 33 | Contributors (cumulative): 101 | DMM Complexity: None\n\nDIFF:\n@@ -67,7 +67,7 @@ from .typing import TemplateTestCallable\n from .wrappers import Request\n from .wrappers import Response\n \n-if t.TYPE_CHECKING:\n+if t.TYPE_CHECKING:  # pragma: no cover\n     import typing_extensions as te\n     from .blueprints import Blueprint\n     from .testing import FlaskClient\n\n@@ -17,7 +17,7 @@ from .typing import TemplateTestCallable\n from .typing import URLDefaultCallable\n from .typing import URLValuePreprocessorCallable\n \n-if t.TYPE_CHECKING:\n+if t.TYPE_CHECKING:  # pragma: no cover\n     from .app import Flask\n     from .typing import ErrorHandlerCallable\n \n\n@@ -11,7 +11,7 @@ from .signals import appcontext_popped\n from .signals import appcontext_pushed\n from .typing import AfterRequestCallable\n \n-if t.TYPE_CHECKING:\n+if t.TYPE_CHECKING:  # pragma: no cover\n     from .app import Flask\n     from .sessions import SessionMixin\n     from .wrappers import Request\n\n@@ -4,7 +4,7 @@ from functools import partial\n from werkzeug.local import LocalProxy\n from werkzeug.local import LocalStack\n \n-if t.TYPE_CHECKING:\n+if t.TYPE_CHECKING:  # pragma: no cover\n     from .app import Flask\n     from .ctx import _AppCtxGlobals\n     from .sessions import SessionMixin\n\n@@ -20,7 +20,7 @@ from .globals import request\n from .globals import session\n from .signals import message_flashed\n \n-if t.TYPE_CHECKING:\n+if t.TYPE_CHECKING:  # pragma: no cover\n     from .wrappers import Response\n \n \n\n@@ -11,7 +11,7 @@ from werkzeug.http import http_date\n from ..globals import current_app\n from ..globals import request\n \n-if t.TYPE_CHECKING:\n+if t.TYPE_CHECKING:  # pragma: no cover\n     from ..app import Flask\n     from ..wrappers import Response\n \n\n@@ -6,7 +6,7 @@ from werkzeug.local import LocalProxy\n \n from .globals import request\n \n-if t.TYPE_CHECKING:\n+if t.TYPE_CHECKING:  # pragma: no cover\n     from .app import Flask\n \n \n\n@@ -26,7 +26,7 @@ from .typing import TemplateContextProcessorCallable\n from .typing import URLDefaultCallable\n from .typing import URLValuePreprocessorCallable\n \n-if t.TYPE_CHECKING:\n+if t.TYPE_CHECKING:  # pragma: no cover\n     from .wrappers import Response\n     from .typing import ErrorHandlerCallable\n \n\n@@ -11,7 +11,7 @@ from werkzeug.datastructures import CallbackDict\n from .helpers import is_ip\n from .json.tag import TaggedJSONSerializer\n \n-if t.TYPE_CHECKING:\n+if t.TYPE_CHECKING:  # pragma: no cover\n     import typing_extensions as te\n     from .app import Flask\n     from .wrappers import Request, Response\n\n@@ -10,7 +10,7 @@ from .globals import _request_ctx_stack\n from .signals import before_render_template\n from .signals import template_rendered\n \n-if t.TYPE_CHECKING:\n+if t.TYPE_CHECKING:  # pragma: no cover\n     from .app import Flask\n     from .scaffold import Scaffold\n \n\n@@ -14,7 +14,7 @@ from .globals import _request_ctx_stack\n from .json import dumps as json_dumps\n from .sessions import SessionMixin\n \n-if t.TYPE_CHECKING:\n+if t.TYPE_CHECKING:  # pragma: no cover\n     from werkzeug.test import TestResponse\n \n     from .app import Flask\n\n@@ -1,7 +1,7 @@\n import typing as t\n \n \n-if t.TYPE_CHECKING:\n+if t.TYPE_CHECKING:  # pragma: no cover\n     from _typeshed.wsgi import WSGIApplication  # noqa: F401\n     from werkzeug.datastructures import Headers  # noqa: F401\n     from werkzeug.wrappers.response import Response  # noqa: F401\n\n@@ -8,7 +8,7 @@ from . import json\n from .globals import current_app\n from .helpers import _split_blueprint_path\n \n-if t.TYPE_CHECKING:\n+if t.TYPE_CHECKING:  # pragma: no cover\n     from werkzeug.routing import Rule\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#fdab801fbbd9de5adbdb3320ca4a1cb116c892f5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 52 | Lines Deleted: 1 | Files Changed: 4 | Hunks: 8 | Methods Changed: 5 | Complexity Δ (Sum/Max): 6/3 | Churn Δ: 53 | Churn Cumulative: 7396 | Contributors (this commit): 63 | Commits (past 90d): 18 | Contributors (cumulative): 76 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,7 +1,6 @@\n from markupsafe import escape\n from markupsafe import Markup\n from werkzeug.exceptions import abort as abort\n-from werkzeug.utils import redirect as redirect\n \n from . import json as json\n from .app import Flask as Flask\n@@ -23,6 +22,7 @@ from .helpers import flash as flash\n from .helpers import get_flashed_messages as get_flashed_messages\n from .helpers import get_template_attribute as get_template_attribute\n from .helpers import make_response as make_response\n+from .helpers import redirect as redirect\n from .helpers import send_file as send_file\n from .helpers import send_from_directory as send_from_directory\n from .helpers import stream_with_context as stream_with_context\n\n@@ -22,6 +22,7 @@ from werkzeug.routing import MapAdapter\n from werkzeug.routing import RequestRedirect\n from werkzeug.routing import RoutingException\n from werkzeug.routing import Rule\n+from werkzeug.utils import redirect as _wz_redirect\n from werkzeug.wrappers import Response as BaseResponse\n \n from . import cli\n@@ -1630,6 +1631,16 @@ class Flask(Scaffold):\n \n         return asgiref_async_to_sync(func)\n \n+    def redirect(self, location: str, code: int = 302) -> BaseResponse:\n+        \"\"\"Create a redirect response object.\n+\n+        :param location: the url of the redirect\n+        :param code: http return code\n+\n+        .. versionadded:: 2.2\n+        \"\"\"\n+        return _wz_redirect(location, code=code, Response=self.response_class)\n+\n     def make_response(self, rv: ResponseReturnValue) -> Response:\n         \"\"\"Convert the return value from a view function to an instance of\n         :attr:`response_class`.\n\n@@ -12,6 +12,7 @@ from threading import RLock\n import werkzeug.utils\n from werkzeug.routing import BuildError\n from werkzeug.urls import url_quote\n+from werkzeug.utils import redirect as _wz_redirect\n \n from .globals import _app_ctx_stack\n from .globals import _request_ctx_stack\n@@ -21,6 +22,7 @@ from .globals import session\n from .signals import message_flashed\n \n if t.TYPE_CHECKING:  # pragma: no cover\n+    from werkzeug.wrappers import Response as BaseResponse\n     from .wrappers import Response\n \n \n@@ -340,6 +342,28 @@ def url_for(endpoint: str, **values: t.Any) -> str:\n     return rv\n \n \n+def redirect(\n+    location: str, code: int = 302, Response: t.Optional[t.Type[\"BaseResponse\"]] = None\n+) -> \"BaseResponse\":\n+    \"\"\"Create a redirect response object.\n+\n+    If :data:`~flask.current_app` is available, it will use\n+    :meth:`~flask.app.Flask.redirect`, otherwise it will use\n+    :func:`werkzeug.utils.redirect`.\n+\n+    :param location: The URL to redirect to.\n+    :param code: The status code for the redirect.\n+    :param Response: The response class to use. Not used when\n+        ``current_app`` is active, which uses ``app.response_class``.\n+\n+    .. versionadded:: 2.2\n+    \"\"\"\n+    if current_app:\n+        return current_app.redirect(location, code=code)\n+\n+    return _wz_redirect(location, code=code, Response=Response)\n+\n+\n def get_template_attribute(template_name: str, attribute: str) -> t.Any:\n     \"\"\"Loads a macro (or variable) a template exports.  This can be used to\n     invoke a macro from within Python code.  If you for example have a\n\n@@ -158,6 +158,22 @@ class TestUrlFor:\n         assert flask.url_for(\"myview\", _method=\"POST\") == \"/myview/create\"\n \n \n+def test_redirect_no_app():\n+    response = flask.redirect(\"https://localhost\", 307)\n+    assert response.location == \"https://localhost\"\n+    assert response.status_code == 307\n+\n+\n+def test_redirect_with_app(app):\n+    def redirect(location, code=302):\n+        raise ValueError\n+\n+    app.redirect = redirect\n+\n+    with app.app_context(), pytest.raises(ValueError):\n+        flask.redirect(\"other\")\n+\n+\n class TestNoImports:\n     \"\"\"Test Flasks are created without import.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#eb5dd9f5ef255c578cbbe13c1cb4dd11389d5519", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 88 | Lines Deleted: 1 | Files Changed: 4 | Hunks: 11 | Methods Changed: 6 | Complexity Δ (Sum/Max): 6/3 | Churn Δ: 89 | Churn Cumulative: 7485 | Contributors (this commit): 64 | Commits (past 90d): 22 | Contributors (cumulative): 80 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,6 +1,5 @@\n from markupsafe import escape\n from markupsafe import Markup\n-from werkzeug.exceptions import abort as abort\n \n from . import json as json\n from .app import Flask as Flask\n@@ -18,6 +17,7 @@ from .globals import current_app as current_app\n from .globals import g as g\n from .globals import request as request\n from .globals import session as session\n+from .helpers import abort as abort\n from .helpers import flash as flash\n from .helpers import get_flashed_messages as get_flashed_messages\n from .helpers import get_template_attribute as get_template_attribute\n\n@@ -12,6 +12,7 @@ from types import TracebackType\n \n from werkzeug.datastructures import Headers\n from werkzeug.datastructures import ImmutableDict\n+from werkzeug.exceptions import Aborter\n from werkzeug.exceptions import BadRequest\n from werkzeug.exceptions import BadRequestKeyError\n from werkzeug.exceptions import HTTPException\n@@ -201,6 +202,16 @@ class Flask(Scaffold):\n     #: :class:`~flask.Response` for more information.\n     response_class = Response\n \n+    #: The class of the object assigned to :attr:`aborter`, created by\n+    #: :meth:`create_aborter`. That object is called by\n+    #: :func:`flask.abort` to raise HTTP errors, and can be\n+    #: called directly as well.\n+    #:\n+    #: Defaults to :class:`werkzeug.exceptions.Aborter`.\n+    #:\n+    #: .. versionadded:: 2.2\n+    aborter_class = Aborter\n+\n     #: The class that is used for the Jinja environment.\n     #:\n     #: .. versionadded:: 0.11\n@@ -421,6 +432,13 @@ class Flask(Scaffold):\n         #: to load a config from files.\n         self.config = self.make_config(instance_relative_config)\n \n+        #: An instance of :attr:`aborter_class` created by\n+        #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n+        #: to raise HTTP errors, and can be called directly as well.\n+        #:\n+        #: .. versionadded:: 2.2\n+        self.aborter = self.make_aborter()\n+\n         #: A list of functions that are called when :meth:`url_for` raises a\n         #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here\n         #: is called with `error`, `endpoint` and `values`.  If a function\n@@ -628,6 +646,18 @@ class Flask(Scaffold):\n         defaults[\"DEBUG\"] = get_debug_flag()\n         return self.config_class(root_path, defaults)\n \n+    def make_aborter(self) -> Aborter:\n+        \"\"\"Create the object to assign to :attr:`aborter`. That object\n+        is called by :func:`flask.abort` to raise HTTP errors, and can\n+        be called directly as well.\n+\n+        By default, this creates an instance of :attr:`aborter_class`,\n+        which defaults to :class:`werkzeug.exceptions.Aborter`.\n+\n+        .. versionadded:: 2.2\n+        \"\"\"\n+        return self.aborter_class()\n+\n     def auto_find_instance_path(self) -> str:\n         \"\"\"Tries to locate the instance path if it was not provided to the\n         constructor of the application class.  It will basically calculate\n\n@@ -10,6 +10,7 @@ from functools import update_wrapper\n from threading import RLock\n \n import werkzeug.utils\n+from werkzeug.exceptions import abort as _wz_abort\n from werkzeug.routing import BuildError\n from werkzeug.urls import url_quote\n from werkzeug.utils import redirect as _wz_redirect\n@@ -24,6 +25,7 @@ from .signals import message_flashed\n if t.TYPE_CHECKING:  # pragma: no cover\n     from werkzeug.wrappers import Response as BaseResponse\n     from .wrappers import Response\n+    import typing_extensions as te\n \n \n def get_env() -> str:\n@@ -364,6 +366,31 @@ def redirect(\n     return _wz_redirect(location, code=code, Response=Response)\n \n \n+def abort(  # type: ignore[misc]\n+    code: t.Union[int, \"BaseResponse\"], *args: t.Any, **kwargs: t.Any\n+) -> \"te.NoReturn\":\n+    \"\"\"Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given\n+    status code.\n+\n+    If :data:`~flask.current_app` is available, it will call its\n+    :attr:`~flask.Flask.aborter` object, otherwise it will use\n+    :func:`werkzeug.exceptions.abort`.\n+\n+    :param code: The status code for the exception, which must be\n+        registered in ``app.aborter``.\n+    :param args: Passed to the exception.\n+    :param kwargs: Passed to the exception.\n+\n+    .. versionadded:: 2.2\n+        Calls ``current_app.aborter`` if available instead of always\n+        using Werkzeug's default ``abort``.\n+    \"\"\"\n+    if current_app:\n+        current_app.aborter(code, *args, **kwargs)\n+\n+    _wz_abort(code, *args, **kwargs)\n+\n+\n def get_template_attribute(template_name: str, attribute: str) -> t.Any:\n     \"\"\"Loads a macro (or variable) a template exports.  This can be used to\n     invoke a macro from within Python code.  If you for example have a\n\n@@ -2,6 +2,7 @@ import io\n import os\n \n import pytest\n+import werkzeug.exceptions\n \n import flask\n from flask.helpers import get_debug_flag\n@@ -174,6 +175,35 @@ def test_redirect_with_app(app):\n         flask.redirect(\"other\")\n \n \n+def test_abort_no_app():\n+    with pytest.raises(werkzeug.exceptions.Unauthorized):\n+        flask.abort(401)\n+\n+    with pytest.raises(LookupError):\n+        flask.abort(900)\n+\n+\n+def test_app_aborter_class():\n+    class MyAborter(werkzeug.exceptions.Aborter):\n+        pass\n+\n+    class MyFlask(flask.Flask):\n+        aborter_class = MyAborter\n+\n+    app = MyFlask(__name__)\n+    assert isinstance(app.aborter, MyAborter)\n+\n+\n+def test_abort_with_app(app):\n+    class My900Error(werkzeug.exceptions.HTTPException):\n+        code = 900\n+\n+    app.aborter.mapping[900] = My900Error\n+\n+    with app.app_context(), pytest.raises(My900Error):\n+        flask.abort(900)\n+\n+\n class TestNoImports:\n     \"\"\"Test Flasks are created without import.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#fac630379d31baaa1667894c2b5613304285a4bb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 13 | Churn Cumulative: 3375 | Contributors (this commit): 29 | Commits (past 90d): 13 | Contributors (cumulative): 36 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1664,8 +1664,11 @@ class Flask(Scaffold):\n     def redirect(self, location: str, code: int = 302) -> BaseResponse:\n         \"\"\"Create a redirect response object.\n \n-        :param location: the url of the redirect\n-        :param code: http return code\n+        This is called by :func:`flask.redirect`, and can be called\n+        directly as well.\n+\n+        :param location: The URL to redirect to.\n+        :param code: The status code for the redirect.\n \n         .. versionadded:: 2.2\n         \"\"\"\n\n@@ -349,8 +349,8 @@ def redirect(\n ) -> \"BaseResponse\":\n     \"\"\"Create a redirect response object.\n \n-    If :data:`~flask.current_app` is available, it will use\n-    :meth:`~flask.app.Flask.redirect`, otherwise it will use\n+    If :data:`~flask.current_app` is available, it will use its\n+    :meth:`~flask.Flask.redirect` method, otherwise it will use\n     :func:`werkzeug.utils.redirect`.\n \n     :param location: The URL to redirect to.\n@@ -359,6 +359,8 @@ def redirect(\n         ``current_app`` is active, which uses ``app.response_class``.\n \n     .. versionadded:: 2.2\n+        Calls ``current_app.redirect`` if available instead of always\n+        using Werkzeug's default ``redirect``.\n     \"\"\"\n     if current_app:\n         return current_app.redirect(location, code=code)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#92acd05d9bd33419ab885e4472b28a1d5cc15d2e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 46 | Lines Deleted: 37 | Files Changed: 2 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/7 | Churn Δ: 83 | Churn Cumulative: 3458 | Contributors (this commit): 30 | Commits (past 90d): 15 | Contributors (cumulative): 38 | DMM Complexity: 0.0\n\nDIFF:\n@@ -23,6 +23,7 @@ from werkzeug.routing import MapAdapter\n from werkzeug.routing import RequestRedirect\n from werkzeug.routing import RoutingException\n from werkzeug.routing import Rule\n+from werkzeug.urls import url_quote\n from werkzeug.utils import redirect as _wz_redirect\n from werkzeug.wrappers import Response as BaseResponse\n \n@@ -1661,6 +1662,50 @@ class Flask(Scaffold):\n \n         return asgiref_async_to_sync(func)\n \n+    def url_for(\n+        self,\n+        endpoint: str,\n+        external: bool,\n+        url_adapter,\n+        **values: t.Any,\n+    ) -> str:\n+\n+        anchor = values.pop(\"_anchor\", None)\n+        method = values.pop(\"_method\", None)\n+        scheme = values.pop(\"_scheme\", None)\n+        self.inject_url_defaults(endpoint, values)\n+\n+        # This is not the best way to deal with this but currently the\n+        # underlying Werkzeug router does not support overriding the scheme on\n+        # a per build call basis.\n+        old_scheme = None\n+        if scheme is not None:\n+            if not external:\n+                raise ValueError(\"When specifying _scheme, _external must be True\")\n+            old_scheme = url_adapter.url_scheme\n+            url_adapter.url_scheme = scheme\n+\n+        try:\n+            try:\n+                rv = url_adapter.build(\n+                    endpoint, values, method=method, force_external=external\n+                )\n+            finally:\n+                if old_scheme is not None:\n+                    url_adapter.url_scheme = old_scheme\n+        except BuildError as error:\n+            # We need to inject the values again so that the app callback can\n+            # deal with that sort of stuff.\n+            values[\"_external\"] = external\n+            values[\"_anchor\"] = anchor\n+            values[\"_method\"] = method\n+            values[\"_scheme\"] = scheme\n+            return self.handle_url_build_error(error, endpoint, values)\n+\n+        if anchor is not None:\n+            rv += f\"#{url_quote(anchor)}\"\n+        return rv\n+\n     def redirect(self, location: str, code: int = 302) -> BaseResponse:\n         \"\"\"Create a redirect response object.\n \n\n@@ -11,8 +11,6 @@ from threading import RLock\n \n import werkzeug.utils\n from werkzeug.exceptions import abort as _wz_abort\n-from werkzeug.routing import BuildError\n-from werkzeug.urls import url_quote\n from werkzeug.utils import redirect as _wz_redirect\n \n from .globals import _app_ctx_stack\n@@ -307,41 +305,7 @@ def url_for(endpoint: str, **values: t.Any) -> str:\n \n         external = values.pop(\"_external\", True)\n \n-    anchor = values.pop(\"_anchor\", None)\n-    method = values.pop(\"_method\", None)\n-    scheme = values.pop(\"_scheme\", None)\n-    appctx.app.inject_url_defaults(endpoint, values)\n-\n-    # This is not the best way to deal with this but currently the\n-    # underlying Werkzeug router does not support overriding the scheme on\n-    # a per build call basis.\n-    old_scheme = None\n-    if scheme is not None:\n-        if not external:\n-            raise ValueError(\"When specifying _scheme, _external must be True\")\n-        old_scheme = url_adapter.url_scheme\n-        url_adapter.url_scheme = scheme\n-\n-    try:\n-        try:\n-            rv = url_adapter.build(\n-                endpoint, values, method=method, force_external=external\n-            )\n-        finally:\n-            if old_scheme is not None:\n-                url_adapter.url_scheme = old_scheme\n-    except BuildError as error:\n-        # We need to inject the values again so that the app callback can\n-        # deal with that sort of stuff.\n-        values[\"_external\"] = external\n-        values[\"_anchor\"] = anchor\n-        values[\"_method\"] = method\n-        values[\"_scheme\"] = scheme\n-        return appctx.app.handle_url_build_error(error, endpoint, values)\n-\n-    if anchor is not None:\n-        rv += f\"#{url_quote(anchor)}\"\n-    return rv\n+    return current_app.url_for(endpoint, external, url_adapter, **values)\n \n \n def redirect(\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#39f93632964ecabfcb9c1980e2add922098aad80", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 182 | Lines Deleted: 149 | Files Changed: 3 | Hunks: 25 | Methods Changed: 9 | Complexity Δ (Sum/Max): -1/5 | Churn Δ: 331 | Churn Cumulative: 7657 | Contributors (this commit): 65 | Commits (past 90d): 20 | Contributors (cumulative): 78 | DMM Complexity: 1.0\n\nDIFF:\n@@ -34,6 +34,7 @@ from .config import ConfigAttribute\n from .ctx import _AppCtxGlobals\n from .ctx import AppContext\n from .ctx import RequestContext\n+from .globals import _app_ctx_stack\n from .globals import _request_ctx_stack\n from .globals import g\n from .globals import request\n@@ -440,15 +441,16 @@ class Flask(Scaffold):\n         #: .. versionadded:: 2.2\n         self.aborter = self.make_aborter()\n \n-        #: A list of functions that are called when :meth:`url_for` raises a\n-        #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here\n-        #: is called with `error`, `endpoint` and `values`.  If a function\n-        #: returns ``None`` or raises a :exc:`BuildError` the next function is\n-        #: tried.\n+        #: A list of functions that are called by\n+        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n+        #: :exc:`~werkzeug.routing.BuildError`. Each function is called\n+        #: with ``error``, ``endpoint`` and ``values``. If a function\n+        #: returns ``None`` or raises a ``BuildError``, it is skipped.\n+        #: Otherwise, its return value is returned by ``url_for``.\n         #:\n         #: .. versionadded:: 0.9\n         self.url_build_error_handlers: t.List[\n-            t.Callable[[Exception, str, dict], str]\n+            t.Callable[[Exception, str, t.Dict[str, t.Any]], str]\n         ] = []\n \n         #: A list of functions that will be called at the beginning of the\n@@ -1665,45 +1667,125 @@ class Flask(Scaffold):\n     def url_for(\n         self,\n         endpoint: str,\n-        external: bool,\n-        url_adapter,\n+        *,\n+        _anchor: t.Optional[str] = None,\n+        _method: t.Optional[str] = None,\n+        _scheme: t.Optional[str] = None,\n+        _external: t.Optional[bool] = None,\n         **values: t.Any,\n     ) -> str:\n+        \"\"\"Generate a URL to the given endpoint with the given values.\n+\n+        This is called by :func:`flask.url_for`, and can be called\n+        directly as well.\n+\n+        An *endpoint* is the name of a URL rule, usually added with\n+        :meth:`@app.route() <route>`, and usually the same name as the\n+        view function. A route defined in a :class:`~flask.Blueprint`\n+        will prepend the blueprint's name separated by a ``.`` to the\n+        endpoint.\n+\n+        In some cases, such as email messages, you want URLs to include\n+        the scheme and domain, like ``https://example.com/hello``. When\n+        not in an active request, URLs will be external by default, but\n+        this requires setting :data:`SERVER_NAME` so Flask knows what\n+        domain to use. :data:`APPLICATION_ROOT` and\n+        :data:`PREFERRED_URL_SCHEME` should also be configured as\n+        needed. This config is only used when not in an active request.\n+\n+        Functions can be decorated with :meth:`url_defaults` to modify\n+        keyword arguments before the URL is built.\n+\n+        If building fails for some reason, such as an unknown endpoint\n+        or incorrect values, the app's :meth:`handle_url_build_error`\n+        method is called. If that returns a string, that is returned,\n+        otherwise a :exc:`~werkzeug.routing.BuildError` is raised.\n+\n+        :param endpoint: The endpoint name associated with the URL to\n+            generate. If this starts with a ``.``, the current blueprint\n+            name (if any) will be used.\n+        :param _anchor: If given, append this as ``#anchor`` to the URL.\n+        :param _method: If given, generate the URL associated with this\n+            method for the endpoint.\n+        :param _scheme: If given, the URL will have this scheme if it\n+            is external.\n+        :param _external: If given, prefer the URL to be internal\n+            (False) or require it to be external (True). External URLs\n+            include the scheme and domain. When not in an active\n+            request, URLs are external by default.\n+        :param values: Values to use for the variable parts of the URL\n+            rule. Unknown keys are appended as query string arguments,\n+            like ``?a=b&c=d``.\n+\n+        .. versionadded:: 2.2\n+            Moved from ``flask.url_for``, which calls this method.\n+        \"\"\"\n+        req_ctx = _request_ctx_stack.top\n+\n+        if req_ctx is not None:\n+            url_adapter = req_ctx.url_adapter\n+            blueprint_name = req_ctx.request.blueprint\n+\n+            # If the endpoint starts with \".\" and the request matches a\n+            # blueprint, the endpoint is relative to the blueprint.\n+            if endpoint[:1] == \".\":\n+                if blueprint_name is not None:\n+                    endpoint = f\"{blueprint_name}{endpoint}\"\n+                else:\n+                    endpoint = endpoint[1:]\n+\n+            # When in a request, generate a URL without scheme and\n+            # domain by default, unless a scheme is given.\n+            if _external is None:\n+                _external = _scheme is not None\n+        else:\n+            app_ctx = _app_ctx_stack.top\n+\n+            # If called by helpers.url_for, an app context is active,\n+            # use its url_adapter. Otherwise, app.url_for was called\n+            # directly, build an adapter.\n+            if app_ctx is not None:\n+                url_adapter = app_ctx.url_adapter\n+            else:\n+                url_adapter = self.create_url_adapter(None)\n+\n+            if url_adapter is None:\n+                raise RuntimeError(\n+                    \"Unable to build URLs outside an active request\"\n+                    \" without 'SERVER_NAME' configured. Also configure\"\n+                    \" 'APPLICATION_ROOT' and 'PREFERRED_URL_SCHEME' as\"\n+                    \" needed.\"\n+                )\n+\n+            # When outside a request, generate a URL with scheme and\n+            # domain by default.\n+            if _external is None:\n+                _external = True\n+\n+        # It is an error to set _scheme when _external=False, in order\n+        # to avoid accidental insecure URLs.\n+        if _scheme is not None and not _external:\n+            raise ValueError(\"When specifying '_scheme', '_external' must be True.\")\n \n-        anchor = values.pop(\"_anchor\", None)\n-        method = values.pop(\"_method\", None)\n-        scheme = values.pop(\"_scheme\", None)\n         self.inject_url_defaults(endpoint, values)\n \n-        # This is not the best way to deal with this but currently the\n-        # underlying Werkzeug router does not support overriding the scheme on\n-        # a per build call basis.\n-        old_scheme = None\n-        if scheme is not None:\n-            if not external:\n-                raise ValueError(\"When specifying _scheme, _external must be True\")\n-            old_scheme = url_adapter.url_scheme\n-            url_adapter.url_scheme = scheme\n-\n-        try:\n         try:\n             rv = url_adapter.build(\n-                    endpoint, values, method=method, force_external=external\n+                endpoint,\n+                values,\n+                method=_method,\n+                url_scheme=_scheme,\n+                force_external=_external,\n             )\n-            finally:\n-                if old_scheme is not None:\n-                    url_adapter.url_scheme = old_scheme\n         except BuildError as error:\n-            # We need to inject the values again so that the app callback can\n-            # deal with that sort of stuff.\n-            values[\"_external\"] = external\n-            values[\"_anchor\"] = anchor\n-            values[\"_method\"] = method\n-            values[\"_scheme\"] = scheme\n+            values.update(\n+                _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external\n+            )\n             return self.handle_url_build_error(error, endpoint, values)\n \n-        if anchor is not None:\n-            rv += f\"#{url_quote(anchor)}\"\n+        if _anchor is not None:\n+            rv = f\"{rv}#{url_quote(_anchor)}\"\n+\n         return rv\n \n     def redirect(self, location: str, code: int = 302) -> BaseResponse:\n@@ -1905,10 +1987,21 @@ class Flask(Scaffold):\n                     func(endpoint, values)\n \n     def handle_url_build_error(\n-        self, error: Exception, endpoint: str, values: dict\n+        self, error: BuildError, endpoint: str, values: t.Dict[str, t.Any]\n     ) -> str:\n-        \"\"\"Handle :class:`~werkzeug.routing.BuildError` on\n-        :meth:`url_for`.\n+        \"\"\"Called by :meth:`.url_for` if a\n+        :exc:`~werkzeug.routing.BuildError` was raised. If this returns\n+        a value, it will be returned by ``url_for``, otherwise the error\n+        will be re-raised.\n+\n+        Each function in :attr:`url_build_error_handlers` is called with\n+        ``error``, ``endpoint`` and ``values``. If a function returns\n+        ``None`` or raises a ``BuildError``, it is skipped. Otherwise,\n+        its return value is returned by ``url_for``.\n+\n+        :param error: The active ``BuildError`` being handled.\n+        :param endpoint: The endpoint being built.\n+        :param values: The keyword arguments passed to ``url_for``.\n         \"\"\"\n         for handler in self.url_build_error_handlers:\n             try:\n\n@@ -13,7 +13,6 @@ import werkzeug.utils\n from werkzeug.exceptions import abort as _wz_abort\n from werkzeug.utils import redirect as _wz_redirect\n \n-from .globals import _app_ctx_stack\n from .globals import _request_ctx_stack\n from .globals import current_app\n from .globals import request\n@@ -191,122 +190,59 @@ def make_response(*args: t.Any) -> \"Response\":\n     return current_app.make_response(args)  # type: ignore\n \n \n-def url_for(endpoint: str, **values: t.Any) -> str:\n-    \"\"\"Generates a URL to the given endpoint with the method provided.\n+def url_for(\n+    endpoint: str,\n+    *,\n+    _anchor: t.Optional[str] = None,\n+    _method: t.Optional[str] = None,\n+    _scheme: t.Optional[str] = None,\n+    _external: t.Optional[bool] = None,\n+    **values: t.Any,\n+) -> str:\n+    \"\"\"Generate a URL to the given endpoint with the given values.\n \n-    Variable arguments that are unknown to the target endpoint are appended\n-    to the generated URL as query arguments.  If the value of a query argument\n-    is ``None``, the whole pair is skipped.  In case blueprints are active\n-    you can shortcut references to the same blueprint by prefixing the\n-    local endpoint with a dot (``.``).\n+    This requires an active request or application context, and calls\n+    :meth:`current_app.url_for() <flask.Flask.url_for>`. See that method\n+    for full documentation.\n \n-    This will reference the index function local to the current blueprint::\n+    :param endpoint: The endpoint name associated with the URL to\n+        generate. If this starts with a ``.``, the current blueprint\n+        name (if any) will be used.\n+    :param _anchor: If given, append this as ``#anchor`` to the URL.\n+    :param _method: If given, generate the URL associated with this\n+        method for the endpoint.\n+    :param _scheme: If given, the URL will have this scheme if it is\n+        external.\n+    :param _external: If given, prefer the URL to be internal (False) or\n+        require it to be external (True). External URLs include the\n+        scheme and domain. When not in an active request, URLs are\n+        external by default.\n+    :param values: Values to use for the variable parts of the URL rule.\n+        Unknown keys are appended as query string arguments, like\n+        ``?a=b&c=d``.\n \n-        url_for('.index')\n+    .. versionchanged:: 2.2\n+        Calls ``current_app.url_for``, allowing an app to override the\n+        behavior.\n \n-    See :ref:`url-building`.\n+    .. versionchanged:: 0.10\n+       The ``_scheme`` parameter was added.\n \n-    Configuration values ``APPLICATION_ROOT`` and ``SERVER_NAME`` are only used when\n-    generating URLs outside of a request context.\n+    .. versionchanged:: 0.9\n+       The ``_anchor`` and ``_method`` parameters were added.\n \n-    To integrate applications, :class:`Flask` has a hook to intercept URL build\n-    errors through :attr:`Flask.url_build_error_handlers`.  The `url_for`\n-    function results in a :exc:`~werkzeug.routing.BuildError` when the current\n-    app does not have a URL for the given endpoint and values.  When it does, the\n-    :data:`~flask.current_app` calls its :attr:`~Flask.url_build_error_handlers` if\n-    it is not ``None``, which can return a string to use as the result of\n-    `url_for` (instead of `url_for`'s default to raise the\n-    :exc:`~werkzeug.routing.BuildError` exception) or re-raise the exception.\n-    An example::\n-\n-        def external_url_handler(error, endpoint, values):\n-            \"Looks up an external URL when `url_for` cannot build a URL.\"\n-            # This is an example of hooking the build_error_handler.\n-            # Here, lookup_url is some utility function you've built\n-            # which looks up the endpoint in some external URL registry.\n-            url = lookup_url(endpoint, **values)\n-            if url is None:\n-                # External lookup did not have a URL.\n-                # Re-raise the BuildError, in context of original traceback.\n-                exc_type, exc_value, tb = sys.exc_info()\n-                if exc_value is error:\n-                    raise exc_type(exc_value).with_traceback(tb)\n-                else:\n-                    raise error\n-            # url_for will use this result, instead of raising BuildError.\n-            return url\n-\n-        app.url_build_error_handlers.append(external_url_handler)\n-\n-    Here, `error` is the instance of :exc:`~werkzeug.routing.BuildError`, and\n-    `endpoint` and `values` are the arguments passed into `url_for`.  Note\n-    that this is for building URLs outside the current application, and not for\n-    handling 404 NotFound errors.\n-\n-    .. versionadded:: 0.10\n-       The `_scheme` parameter was added.\n-\n-    .. versionadded:: 0.9\n-       The `_anchor` and `_method` parameters were added.\n-\n-    .. versionadded:: 0.9\n-       Calls :meth:`Flask.handle_build_error` on\n-       :exc:`~werkzeug.routing.BuildError`.\n-\n-    :param endpoint: the endpoint of the URL (name of the function)\n-    :param values: the variable arguments of the URL rule\n-    :param _external: if set to ``True``, an absolute URL is generated. Server\n-      address can be changed via ``SERVER_NAME`` configuration variable which\n-      falls back to the `Host` header, then to the IP and port of the request.\n-    :param _scheme: a string specifying the desired URL scheme. The `_external`\n-      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The default\n-      behavior uses the same scheme as the current request, or\n-      :data:`PREFERRED_URL_SCHEME` if no request context is available.\n-      This also can be set to an empty string to build protocol-relative\n-      URLs.\n-    :param _anchor: if provided this is added as anchor to the URL.\n-    :param _method: if provided this explicitly specifies an HTTP method.\n+    .. versionchanged:: 0.9\n+       Calls ``app.handle_url_build_error`` on build errors.\n     \"\"\"\n-    appctx = _app_ctx_stack.top\n-    reqctx = _request_ctx_stack.top\n-\n-    if appctx is None:\n-        raise RuntimeError(\n-            \"Attempted to generate a URL without the application context being\"\n-            \" pushed. This has to be executed when application context is\"\n-            \" available.\"\n+    return current_app.url_for(\n+        endpoint,\n+        _anchor=_anchor,\n+        _method=_method,\n+        _scheme=_scheme,\n+        _external=_external,\n+        **values,\n     )\n \n-    # If request specific information is available we have some extra\n-    # features that support \"relative\" URLs.\n-    if reqctx is not None:\n-        url_adapter = reqctx.url_adapter\n-        blueprint_name = request.blueprint\n-\n-        if endpoint[:1] == \".\":\n-            if blueprint_name is not None:\n-                endpoint = f\"{blueprint_name}{endpoint}\"\n-            else:\n-                endpoint = endpoint[1:]\n-\n-        external = values.pop(\"_external\", False)\n-\n-    # Otherwise go with the url adapter from the appctx and make\n-    # the URLs external by default.\n-    else:\n-        url_adapter = appctx.url_adapter\n-\n-        if url_adapter is None:\n-            raise RuntimeError(\n-                \"Application was not able to create a URL adapter for request\"\n-                \" independent URL generation. You might be able to fix this by\"\n-                \" setting the SERVER_NAME config variable.\"\n-            )\n-\n-        external = values.pop(\"_external\", True)\n-\n-    return current_app.url_for(endpoint, external, url_adapter, **values)\n-\n \n def redirect(\n     location: str, code: int = 302, Response: t.Optional[t.Type[\"BaseResponse\"]] = None\n\n@@ -119,11 +119,15 @@ class TestUrlFor:\n         )\n \n     def test_url_for_with_scheme_not_external(self, app, req_ctx):\n-        @app.route(\"/\")\n-        def index():\n-            return \"42\"\n+        app.add_url_rule(\"/\", endpoint=\"index\")\n \n-        pytest.raises(ValueError, flask.url_for, \"index\", _scheme=\"https\")\n+        # Implicit external with scheme.\n+        url = flask.url_for(\"index\", _scheme=\"https\")\n+        assert url == \"https://localhost/\"\n+\n+        # Error when external=False with scheme\n+        with pytest.raises(ValueError):\n+            flask.url_for(\"index\", _scheme=\"https\", _external=False)\n \n     def test_url_for_with_alternating_schemes(self, app, req_ctx):\n         @app.route(\"/\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#69e2300608497bba103fd05735c878c0d642dd68", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 2010 | Contributors (this commit): 23 | Commits (past 90d): 11 | Contributors (cumulative): 23 | DMM Complexity: 1.0\n\nDIFF:\n@@ -45,7 +45,6 @@ from .helpers import get_env\n from .helpers import get_flashed_messages\n from .helpers import get_load_dotenv\n from .helpers import locked_cached_property\n-from .helpers import url_for\n from .json import jsonify\n from .logging import create_logger\n from .scaffold import _endpoint_from_view_func\n@@ -439,6 +438,7 @@ class Flask(Scaffold):\n         #: to raise HTTP errors, and can be called directly as well.\n         #:\n         #: .. versionadded:: 2.2\n+        #:     Moved from ``flask.abort``, which calls this object.\n         self.aborter = self.make_aborter()\n \n         #: A list of functions that are called by\n@@ -727,7 +727,7 @@ class Flask(Scaffold):\n \n         rv = self.jinja_environment(self, **options)\n         rv.globals.update(\n-            url_for=url_for,\n+            url_for=self.url_for,\n             get_flashed_messages=get_flashed_messages,\n             config=self.config,\n             # request, session and g are normally added with the\n@@ -1798,6 +1798,7 @@ class Flask(Scaffold):\n         :param code: The status code for the redirect.\n \n         .. versionadded:: 2.2\n+            Moved from ``flask.redirect``, which calls this method.\n         \"\"\"\n         return _wz_redirect(location, code=code, Response=self.response_class)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#a406c297aafa28074d11ec6fd27c246c70418cb4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 53 | Lines Deleted: 30 | Files Changed: 3 | Hunks: 29 | Methods Changed: 9 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 83 | Churn Cumulative: 4504 | Contributors (this commit): 29 | Commits (past 90d): 21 | Contributors (cumulative): 48 | DMM Complexity: 1.0\n\nDIFF:\n@@ -541,8 +541,17 @@ class Flask(Scaffold):\n         # the app's commands to another CLI tool.\n         self.cli.name = self.name\n \n-    def _is_setup_finished(self) -> bool:\n-        return self.debug and self._got_first_request\n+    def _check_setup_finished(self, f_name: str) -> None:\n+        if self._got_first_request:\n+            raise AssertionError(\n+                f\"The setup method '{f_name}' can no longer be called\"\n+                \" on the application. It has already handled its first\"\n+                \" request, any changes will not be applied\"\n+                \" consistently.\\n\"\n+                \"Make sure all imports, decorators, functions, etc.\"\n+                \" needed to set up the application are done before\"\n+                \" running it.\"\n+            )\n \n     @locked_cached_property\n     def name(self) -> str:  # type: ignore\n\n@@ -6,6 +6,7 @@ from functools import update_wrapper\n from .scaffold import _endpoint_from_view_func\n from .scaffold import _sentinel\n from .scaffold import Scaffold\n+from .scaffold import setupmethod\n from .typing import AfterRequestCallable\n from .typing import BeforeFirstRequestCallable\n from .typing import BeforeRequestCallable\n@@ -207,28 +208,33 @@ class Blueprint(Scaffold):\n         self.cli_group = cli_group\n         self._blueprints: t.List[t.Tuple[\"Blueprint\", dict]] = []\n \n-    def _is_setup_finished(self) -> bool:\n-        return self._got_registered_once\n+    def _check_setup_finished(self, f_name: str) -> None:\n+        if self._got_registered_once:\n+            import warnings\n \n+            warnings.warn(\n+                f\"The setup method '{f_name}' can no longer be called on\"\n+                f\" the blueprint '{self.name}'. It has already been\"\n+                \" registered at least once, any changes will not be\"\n+                \" applied consistently.\\n\"\n+                \"Make sure all imports, decorators, functions, etc.\"\n+                \" needed to set up the blueprint are done before\"\n+                \" registering it.\\n\"\n+                \"This warning will become an exception in Flask 2.3.\",\n+                UserWarning,\n+                stacklevel=3,\n+            )\n+\n+    @setupmethod\n     def record(self, func: t.Callable) -> None:\n         \"\"\"Registers a function that is called when the blueprint is\n         registered on the application.  This function is called with the\n         state as argument as returned by the :meth:`make_setup_state`\n         method.\n         \"\"\"\n-        if self._got_registered_once:\n-            # TODO: Upgrade this to an error and unify it setupmethod in 2.3\n-            from warnings import warn\n-\n-            warn(\n-                Warning(\n-                    \"The blueprint was already registered once but is\"\n-                    \" getting modified now. These changes will not show\"\n-                    \" up.\\n This warning will be become an exception in 2.3.\"\n-                )\n-            )\n         self.deferred_functions.append(func)\n \n+    @setupmethod\n     def record_once(self, func: t.Callable) -> None:\n         \"\"\"Works like :meth:`record` but wraps the function in another\n         function that will ensure the function is only called once.  If the\n@@ -251,6 +257,7 @@ class Blueprint(Scaffold):\n         \"\"\"\n         return BlueprintSetupState(self, app, options, first_registration)\n \n+    @setupmethod\n     def register_blueprint(self, blueprint: \"Blueprint\", **options: t.Any) -> None:\n         \"\"\"Register a :class:`~flask.Blueprint` on this blueprint. Keyword\n         arguments passed to this method will override the defaults set\n@@ -390,6 +397,7 @@ class Blueprint(Scaffold):\n             bp_options[\"name_prefix\"] = name\n             blueprint.register(app, bp_options)\n \n+    @setupmethod\n     def add_url_rule(\n         self,\n         rule: str,\n@@ -417,6 +425,7 @@ class Blueprint(Scaffold):\n             )\n         )\n \n+    @setupmethod\n     def app_template_filter(\n         self, name: t.Optional[str] = None\n     ) -> t.Callable[[TemplateFilterCallable], TemplateFilterCallable]:\n@@ -433,6 +442,7 @@ class Blueprint(Scaffold):\n \n         return decorator\n \n+    @setupmethod\n     def add_app_template_filter(\n         self, f: TemplateFilterCallable, name: t.Optional[str] = None\n     ) -> None:\n@@ -449,6 +459,7 @@ class Blueprint(Scaffold):\n \n         self.record_once(register_template)\n \n+    @setupmethod\n     def app_template_test(\n         self, name: t.Optional[str] = None\n     ) -> t.Callable[[TemplateTestCallable], TemplateTestCallable]:\n@@ -467,6 +478,7 @@ class Blueprint(Scaffold):\n \n         return decorator\n \n+    @setupmethod\n     def add_app_template_test(\n         self, f: TemplateTestCallable, name: t.Optional[str] = None\n     ) -> None:\n@@ -485,6 +497,7 @@ class Blueprint(Scaffold):\n \n         self.record_once(register_template)\n \n+    @setupmethod\n     def app_template_global(\n         self, name: t.Optional[str] = None\n     ) -> t.Callable[[TemplateGlobalCallable], TemplateGlobalCallable]:\n@@ -503,6 +516,7 @@ class Blueprint(Scaffold):\n \n         return decorator\n \n+    @setupmethod\n     def add_app_template_global(\n         self, f: TemplateGlobalCallable, name: t.Optional[str] = None\n     ) -> None:\n@@ -521,6 +535,7 @@ class Blueprint(Scaffold):\n \n         self.record_once(register_template)\n \n+    @setupmethod\n     def before_app_request(self, f: BeforeRequestCallable) -> BeforeRequestCallable:\n         \"\"\"Like :meth:`Flask.before_request`.  Such a function is executed\n         before each request, even if outside of a blueprint.\n@@ -530,6 +545,7 @@ class Blueprint(Scaffold):\n         )\n         return f\n \n+    @setupmethod\n     def before_app_first_request(\n         self, f: BeforeFirstRequestCallable\n     ) -> BeforeFirstRequestCallable:\n@@ -548,6 +564,7 @@ class Blueprint(Scaffold):\n         )\n         return f\n \n+    @setupmethod\n     def teardown_app_request(self, f: TeardownCallable) -> TeardownCallable:\n         \"\"\"Like :meth:`Flask.teardown_request` but for a blueprint.  Such a\n         function is executed when tearing down each request, even if outside of\n@@ -558,6 +575,7 @@ class Blueprint(Scaffold):\n         )\n         return f\n \n+    @setupmethod\n     def app_context_processor(\n         self, f: TemplateContextProcessorCallable\n     ) -> TemplateContextProcessorCallable:\n@@ -569,6 +587,7 @@ class Blueprint(Scaffold):\n         )\n         return f\n \n+    @setupmethod\n     def app_errorhandler(self, code: t.Union[t.Type[Exception], int]) -> t.Callable:\n         \"\"\"Like :meth:`Flask.errorhandler` but for a blueprint.  This\n         handler is used for all requests, even if outside of the blueprint.\n@@ -580,6 +599,7 @@ class Blueprint(Scaffold):\n \n         return decorator\n \n+    @setupmethod\n     def app_url_value_preprocessor(\n         self, f: URLValuePreprocessorCallable\n     ) -> URLValuePreprocessorCallable:\n@@ -589,6 +609,7 @@ class Blueprint(Scaffold):\n         )\n         return f\n \n+    @setupmethod\n     def app_url_defaults(self, f: URLDefaultCallable) -> URLDefaultCallable:\n         \"\"\"Same as :meth:`url_defaults` but application wide.\"\"\"\n         self.record_once(\n\n@@ -37,22 +37,10 @@ F = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])\n \n \n def setupmethod(f: F) -> F:\n-    \"\"\"Wraps a method so that it performs a check in debug mode if the\n-    first request was already handled.\n-    \"\"\"\n+    f_name = f.__name__\n \n     def wrapper_func(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\n-        if self._is_setup_finished():\n-            raise AssertionError(\n-                \"A setup function was called after the first request \"\n-                \"was handled. This usually indicates a bug in the\"\n-                \" application where a module was not imported and\"\n-                \" decorators or other functionality was called too\"\n-                \" late.\\nTo fix this make sure to import all your view\"\n-                \" modules, database models, and everything related at a\"\n-                \" central place before the application starts serving\"\n-                \" requests.\"\n-            )\n+        self._check_setup_finished(f_name)\n         return f(self, *args, **kwargs)\n \n     return t.cast(F, update_wrapper(wrapper_func, f))\n@@ -239,7 +227,7 @@ class Scaffold:\n     def __repr__(self) -> str:\n         return f\"<{type(self).__name__} {self.name!r}>\"\n \n-    def _is_setup_finished(self) -> bool:\n+    def _check_setup_finished(self, f_name: str) -> None:\n         raise NotImplementedError\n \n     @property\n@@ -376,6 +364,7 @@ class Scaffold:\n \n         return self.route(rule, methods=[method], **options)\n \n+    @setupmethod\n     def get(self, rule: str, **options: t.Any) -> t.Callable[[F], F]:\n         \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n \n@@ -383,6 +372,7 @@ class Scaffold:\n         \"\"\"\n         return self._method_route(\"GET\", rule, options)\n \n+    @setupmethod\n     def post(self, rule: str, **options: t.Any) -> t.Callable[[F], F]:\n         \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n \n@@ -390,6 +380,7 @@ class Scaffold:\n         \"\"\"\n         return self._method_route(\"POST\", rule, options)\n \n+    @setupmethod\n     def put(self, rule: str, **options: t.Any) -> t.Callable[[F], F]:\n         \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n \n@@ -397,6 +388,7 @@ class Scaffold:\n         \"\"\"\n         return self._method_route(\"PUT\", rule, options)\n \n+    @setupmethod\n     def delete(self, rule: str, **options: t.Any) -> t.Callable[[F], F]:\n         \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n \n@@ -404,6 +396,7 @@ class Scaffold:\n         \"\"\"\n         return self._method_route(\"DELETE\", rule, options)\n \n+    @setupmethod\n     def patch(self, rule: str, **options: t.Any) -> t.Callable[[F], F]:\n         \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
