{"custom_id": "flask#3351a8677e5bd1e1b8cfe2860b73b3422cde4f31", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 40 | Lines Deleted: 4 | Files Changed: 4 | Hunks: 6 | Methods Changed: 10 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 44 | Churn Cumulative: 2795 | Contributors (this commit): 20 | Commits (past 90d): 24 | Contributors (cumulative): 35 | DMM Complexity: 1.0\n\nDIFF:\n@@ -561,12 +561,14 @@ class Blueprint(Scaffold):\n         )\n         return f\n \n-    def app_errorhandler(self, code: t.Union[t.Type[Exception], int]) -> t.Callable:\n+    def app_errorhandler(\n+        self, code: t.Union[t.Type[Exception], int]\n+    ) -> t.Callable[[ft.ErrorHandlerDecorator], ft.ErrorHandlerDecorator]:\n         \"\"\"Like :meth:`Flask.errorhandler` but for a blueprint.  This\n         handler is used for all requests, even if outside of the blueprint.\n         \"\"\"\n \n-        def decorator(f: ft.ErrorHandlerCallable) -> ft.ErrorHandlerCallable:\n+        def decorator(f: ft.ErrorHandlerDecorator) -> ft.ErrorHandlerDecorator:\n             self.record_once(lambda s: s.app.errorhandler(code)(f))\n             return f\n \n\n@@ -654,7 +654,7 @@ class Scaffold:\n     @setupmethod\n     def errorhandler(\n         self, code_or_exception: t.Union[t.Type[Exception], int]\n-    ) -> t.Callable[[ft.ErrorHandlerCallable], ft.ErrorHandlerCallable]:\n+    ) -> t.Callable[[ft.ErrorHandlerDecorator], ft.ErrorHandlerDecorator]:\n         \"\"\"Register a function to handle errors by code or exception class.\n \n         A decorator that is used to register a function given an\n@@ -684,7 +684,7 @@ class Scaffold:\n                                   an arbitrary exception\n         \"\"\"\n \n-        def decorator(f: ft.ErrorHandlerCallable) -> ft.ErrorHandlerCallable:\n+        def decorator(f: ft.ErrorHandlerDecorator) -> ft.ErrorHandlerDecorator:\n             self.register_error_handler(code_or_exception, f)\n             return f\n \n\n@@ -52,6 +52,7 @@ URLValuePreprocessorCallable = t.Callable[[t.Optional[str], t.Optional[dict]], N\n # https://github.com/pallets/flask/issues/4295\n # https://github.com/pallets/flask/issues/4297\n ErrorHandlerCallable = t.Callable[[t.Any], ResponseReturnValue]\n+ErrorHandlerDecorator = t.TypeVar(\"ErrorHandlerDecorator\", bound=ErrorHandlerCallable)\n \n ViewCallable = t.Callable[..., ResponseReturnValue]\n RouteDecorator = t.TypeVar(\"RouteDecorator\", bound=ViewCallable)\n\n@@ -0,0 +1,33 @@\n+from __future__ import annotations\n+\n+from http import HTTPStatus\n+\n+from werkzeug.exceptions import BadRequest\n+from werkzeug.exceptions import NotFound\n+\n+from flask import Flask\n+\n+app = Flask(__name__)\n+\n+\n+@app.errorhandler(400)\n+@app.errorhandler(HTTPStatus.BAD_REQUEST)\n+@app.errorhandler(BadRequest)\n+def handle_400(e: BadRequest) -> str:\n+    return \"\"\n+\n+\n+@app.errorhandler(ValueError)\n+def handle_custom(e: ValueError) -> str:\n+    return \"\"\n+\n+\n+@app.errorhandler(ValueError)\n+def handle_accept_base(e: Exception) -> str:\n+    return \"\"\n+\n+\n+@app.errorhandler(BadRequest)\n+@app.errorhandler(404)\n+def handle_multiple(e: BadRequest | NotFound) -> str:\n+    return \"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#88bcf78439b66b5fcba9f4d3a1c56307f98dbf1d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 46 | Lines Deleted: 12 | Files Changed: 2 | Hunks: 9 | Methods Changed: 5 | Complexity Δ (Sum/Max): 6/4 | Churn Δ: 58 | Churn Cumulative: 2075 | Contributors (this commit): 19 | Commits (past 90d): 12 | Contributors (cumulative): 21 | DMM Complexity: 0.5185185185185185\n\nDIFF:\n@@ -780,30 +780,46 @@ def _matching_loader_thinks_module_is_package(loader, mod_name):\n     )\n \n \n-def _find_package_path(root_mod_name):\n+def _find_package_path(import_name):\n     \"\"\"Find the path that contains the package or module.\"\"\"\n-    try:\n-        spec = importlib.util.find_spec(root_mod_name)\n+    root_mod_name, _, _ = import_name.partition(\".\")\n \n-        if spec is None:\n+    try:\n+        root_spec = importlib.util.find_spec(root_mod_name)\n+\n+        if root_spec is None:\n             raise ValueError(\"not found\")\n     # ImportError: the machinery told us it does not exist\n     # ValueError:\n     #    - the module name was invalid\n     #    - the module name is __main__\n-    #    - *we* raised `ValueError` due to `spec` being `None`\n+    #    - *we* raised `ValueError` due to `root_spec` being `None`\n     except (ImportError, ValueError):\n         pass  # handled below\n     else:\n         # namespace package\n-        if spec.origin in {\"namespace\", None}:\n-            return os.path.dirname(next(iter(spec.submodule_search_locations)))\n+        if root_spec.origin in {\"namespace\", None}:\n+            package_spec = importlib.util.find_spec(import_name)\n+            if package_spec is not None and package_spec.submodule_search_locations:\n+                # Pick the path in the namespace that contains the submodule.\n+                package_path = os.path.commonpath(\n+                    package_spec.submodule_search_locations\n+                )\n+                search_locations = (\n+                    location\n+                    for location in root_spec.submodule_search_locations\n+                    if package_path.startswith(location)\n+                )\n+            else:\n+                # Pick the first path.\n+                search_locations = iter(root_spec.submodule_search_locations)\n+            return os.path.dirname(next(search_locations))\n         # a package (with __init__.py)\n-        elif spec.submodule_search_locations:\n-            return os.path.dirname(os.path.dirname(spec.origin))\n+        elif root_spec.submodule_search_locations:\n+            return os.path.dirname(os.path.dirname(root_spec.origin))\n         # just a normal module\n         else:\n-            return os.path.dirname(spec.origin)\n+            return os.path.dirname(root_spec.origin)\n \n     # we were unable to find the `package_path` using PEP 451 loaders\n     loader = pkgutil.get_loader(root_mod_name)\n@@ -845,8 +861,7 @@ def find_package(import_name: str):\n     for import. If the package is not installed, it's assumed that the\n     package was imported from the current working directory.\n     \"\"\"\n-    root_mod_name, _, _ = import_name.partition(\".\")\n-    package_path = _find_package_path(root_mod_name)\n+    package_path = _find_package_path(import_name)\n     py_prefix = os.path.abspath(sys.prefix)\n \n     # installed to the system\n\n@@ -59,6 +59,25 @@ def test_uninstalled_package_paths(modules_tmpdir, purge_module):\n     assert app.instance_path == str(modules_tmpdir.join(\"instance\"))\n \n \n+def test_uninstalled_namespace_paths(tmpdir, monkeypatch, purge_module):\n+    def create_namespace(package):\n+        project = tmpdir.join(f\"project-{package}\")\n+        monkeypatch.syspath_prepend(str(project))\n+        project.join(\"namespace\").join(package).join(\"__init__.py\").write(\n+            \"import flask\\napp = flask.Flask(__name__)\\n\", ensure=True\n+        )\n+        return project\n+\n+    _ = create_namespace(\"package1\")\n+    project2 = create_namespace(\"package2\")\n+    purge_module(\"namespace.package2\")\n+    purge_module(\"namespace\")\n+\n+    from namespace.package2 import app\n+\n+    assert app.instance_path == str(project2.join(\"instance\"))\n+\n+\n def test_installed_module_paths(\n     modules_tmpdir, modules_tmpdir_prefix, purge_module, site_packages, limit_loader\n ):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#3ba37d2afe6511c3f3153248f7342174bea5b131", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 14 | Lines Deleted: 7 | Files Changed: 2 | Hunks: 8 | Methods Changed: 3 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 21 | Churn Cumulative: 2096 | Contributors (this commit): 19 | Commits (past 90d): 13 | Contributors (cumulative): 21 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,5 +1,6 @@\n import importlib.util\n import os\n+import pathlib\n import pkgutil\n import sys\n import typing as t\n@@ -780,6 +781,15 @@ def _matching_loader_thinks_module_is_package(loader, mod_name):\n     )\n \n \n+def _path_is_relative_to(path: pathlib.PurePath, base: str) -> bool:\n+    # Path.is_relative_to doesn't exist until Python 3.9\n+    try:\n+        path.relative_to(base)\n+        return True\n+    except ValueError:\n+        return False\n+\n+\n def _find_package_path(import_name):\n     \"\"\"Find the path that contains the package or module.\"\"\"\n     root_mod_name, _, _ = import_name.partition(\".\")\n@@ -802,13 +812,13 @@ def _find_package_path(import_name):\n             package_spec = importlib.util.find_spec(import_name)\n             if package_spec is not None and package_spec.submodule_search_locations:\n                 # Pick the path in the namespace that contains the submodule.\n-                package_path = os.path.commonpath(\n-                    package_spec.submodule_search_locations\n+                package_path = pathlib.Path(\n+                    os.path.commonpath(package_spec.submodule_search_locations)\n                 )\n                 search_locations = (\n                     location\n                     for location in root_spec.submodule_search_locations\n-                    if package_path.startswith(location)\n+                    if _path_is_relative_to(package_path, location)\n                 )\n             else:\n                 # Pick the first path.\n@@ -865,7 +875,7 @@ def find_package(import_name: str):\n     py_prefix = os.path.abspath(sys.prefix)\n \n     # installed to the system\n-    if package_path.startswith(py_prefix):\n+    if _path_is_relative_to(pathlib.PurePath(package_path), py_prefix):\n         return py_prefix, package_path\n \n     site_parent, site_folder = os.path.split(package_path)\n\n@@ -15,7 +15,6 @@ def test_explicit_instance_paths(modules_tmpdir):\n     assert app.instance_path == str(modules_tmpdir)\n \n \n-@pytest.mark.xfail(reason=\"weird interaction with tox\")\n def test_main_module_paths(modules_tmpdir, purge_module):\n     app = modules_tmpdir.join(\"main_app.py\")\n     app.write('import flask\\n\\napp = flask.Flask(\"__main__\")')\n@@ -27,7 +26,6 @@ def test_main_module_paths(modules_tmpdir, purge_module):\n     assert app.instance_path == os.path.join(here, \"instance\")\n \n \n-@pytest.mark.xfail(reason=\"weird interaction with tox\")\n def test_uninstalled_module_paths(modules_tmpdir, purge_module):\n     app = modules_tmpdir.join(\"config_module_app.py\").write(\n         \"import os\\n\"\n@@ -42,7 +40,6 @@ def test_uninstalled_module_paths(modules_tmpdir, purge_module):\n     assert app.instance_path == str(modules_tmpdir.join(\"instance\"))\n \n \n-@pytest.mark.xfail(reason=\"weird interaction with tox\")\n def test_uninstalled_package_paths(modules_tmpdir, purge_module):\n     app = modules_tmpdir.mkdir(\"config_package_app\")\n     init = app.join(\"__init__.py\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#b06df0a792ceb5506da47e0c8fea09902c1058f9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 12 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 12 | Churn Cumulative: 353 | Contributors (this commit): 6 | Commits (past 90d): 3 | Contributors (cumulative): 6 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,4 +1,3 @@\n-import os\n import sys\n \n import pytest\n@@ -15,17 +14,6 @@ def test_explicit_instance_paths(modules_tmpdir):\n     assert app.instance_path == str(modules_tmpdir)\n \n \n-def test_main_module_paths(modules_tmpdir, purge_module):\n-    app = modules_tmpdir.join(\"main_app.py\")\n-    app.write('import flask\\n\\napp = flask.Flask(\"__main__\")')\n-    purge_module(\"main_app\")\n-\n-    from main_app import app\n-\n-    here = os.path.abspath(os.getcwd())\n-    assert app.instance_path == os.path.join(here, \"instance\")\n-\n-\n def test_uninstalled_module_paths(modules_tmpdir, purge_module):\n     app = modules_tmpdir.join(\"config_module_app.py\").write(\n         \"import os\\n\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#96c97dec095f204b8a557c5ea804afdd329e3c43", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 49 | Lines Deleted: 17 | Files Changed: 5 | Hunks: 11 | Methods Changed: 9 | Complexity Δ (Sum/Max): 11/13 | Churn Δ: 66 | Churn Cumulative: 9830 | Contributors (this commit): 70 | Commits (past 90d): 29 | Contributors (cumulative): 98 | DMM Complexity: 0.0\n\nDIFF:\n@@ -451,6 +451,10 @@ class Flask(Scaffold):\n         #: first request to this instance. To register a function, use the\n         #: :meth:`before_first_request` decorator.\n         #:\n+        #: .. deprecated:: 2.2\n+        #:     Will be removed in Flask 2.3. Run setup code when\n+        #:     creating the application instead.\n+        #:\n         #: .. versionadded:: 0.8\n         self.before_first_request_funcs: t.List[ft.BeforeFirstRequestCallable] = []\n \n@@ -1255,8 +1259,21 @@ class Flask(Scaffold):\n         The function will be called without any arguments and its return\n         value is ignored.\n \n+        .. deprecated:: 2.2\n+            Will be removed in Flask 2.3. Run setup code when creating\n+            the application instead.\n+\n         .. versionadded:: 0.8\n         \"\"\"\n+        import warnings\n+\n+        warnings.warn(\n+            \"'before_first_request' is deprecated and will be removed\"\n+            \" in Flask 2.3. Run setup code while creating the\"\n+            \" application instead.\",\n+            DeprecationWarning,\n+            stacklevel=2,\n+        )\n         self.before_first_request_funcs.append(f)\n         return f\n \n@@ -1552,7 +1569,17 @@ class Flask(Scaffold):\n \n         .. versionadded:: 0.7\n         \"\"\"\n-        self.try_trigger_before_first_request_functions()\n+        # Run before_first_request functions if this is the thread's first request.\n+        # Inlined to avoid a method call on subsequent requests.\n+        # This is deprecated, will be removed in Flask 2.3.\n+        if not self._got_first_request:\n+            with self._before_request_lock:\n+                if not self._got_first_request:\n+                    for func in self.before_first_request_funcs:\n+                        self.ensure_sync(func)()\n+\n+                    self._got_first_request = True\n+\n         try:\n             request_started.send(self)\n             rv = self.preprocess_request()\n@@ -1591,22 +1618,6 @@ class Flask(Scaffold):\n             )\n         return response\n \n-    def try_trigger_before_first_request_functions(self) -> None:\n-        \"\"\"Called before each request and will ensure that it triggers\n-        the :attr:`before_first_request_funcs` and only exactly once per\n-        application instance (which means process usually).\n-\n-        :internal:\n-        \"\"\"\n-        if self._got_first_request:\n-            return\n-        with self._before_request_lock:\n-            if self._got_first_request:\n-                return\n-            for func in self.before_first_request_funcs:\n-                self.ensure_sync(func)()\n-            self._got_first_request = True\n-\n     def make_default_options_response(self) -> Response:\n         \"\"\"This method is called to create the default ``OPTIONS`` response.\n         This can be changed through subclassing to change the default\n\n@@ -543,7 +543,20 @@ class Blueprint(Scaffold):\n     ) -> ft.BeforeFirstRequestCallable:\n         \"\"\"Like :meth:`Flask.before_first_request`.  Such a function is\n         executed before the first request to the application.\n+\n+        .. deprecated:: 2.2\n+            Will be removed in Flask 2.3. Run setup code when creating\n+            the application instead.\n         \"\"\"\n+        import warnings\n+\n+        warnings.warn(\n+            \"'before_app_first_request' is deprecated and will be\"\n+            \" removed in Flask 2.3. Use 'record_once' instead to run\"\n+            \" setup code when registering the blueprint.\",\n+            DeprecationWarning,\n+            stacklevel=2,\n+        )\n         self.record_once(lambda s: s.app.before_first_request_funcs.append(f))\n         return f\n \n\n@@ -107,6 +107,8 @@ def test_async_before_after_request():\n     def index():\n         return \"\"\n \n+    with pytest.deprecated_call():\n+\n         @app.before_first_request\n         async def before_first():\n             nonlocal app_first_called\n\n@@ -1684,6 +1684,8 @@ def test_no_setup_after_first_request(app, client):\n def test_before_first_request_functions(app, client):\n     got = []\n \n+    with pytest.deprecated_call():\n+\n         @app.before_first_request\n         def foo():\n             got.append(42)\n@@ -1698,6 +1700,8 @@ def test_before_first_request_functions(app, client):\n def test_before_first_request_functions_concurrent(app, client):\n     got = []\n \n+    with pytest.deprecated_call():\n+\n         @app.before_first_request\n         def foo():\n             time.sleep(0.2)\n\n@@ -722,6 +722,8 @@ def test_app_request_processing(app, client):\n     bp = flask.Blueprint(\"bp\", __name__)\n     evts = []\n \n+    with pytest.deprecated_call():\n+\n         @bp.before_app_first_request\n         def before_first_request():\n             evts.append(\"first\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#6e23239567efde1c2e272db87c53444d6c22a1bb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 58 | Lines Deleted: 12 | Files Changed: 2 | Hunks: 8 | Methods Changed: 8 | Complexity Δ (Sum/Max): 5/3 | Churn Δ: 70 | Churn Cumulative: 559 | Contributors (this commit): 10 | Commits (past 90d): 3 | Contributors (cumulative): 11 | DMM Complexity: 1.0\n\nDIFF:\n@@ -59,6 +59,18 @@ class View:\n     #: .. versionadded:: 0.8\n     decorators: t.List[t.Callable] = []\n \n+    #: Create a new instance of this view class for every request by\n+    #: default. If a view subclass sets this to ``False``, the same\n+    #: instance is used for every request.\n+    #:\n+    #: A single instance is more efficient, especially if complex setup\n+    #: is done during init. However, storing data on ``self`` is no\n+    #: longer safe across requests, and :data:`~flask.g` should be used\n+    #: instead.\n+    #:\n+    #: .. versionadded:: 2.2\n+    init_every_request: t.ClassVar[bool] = True\n+\n     def dispatch_request(self) -> ft.ResponseReturnValue:\n         \"\"\"Subclasses have to override this method to implement the\n         actual view function code.  This method is called with all\n@@ -69,19 +81,35 @@ class View:\n     @classmethod\n     def as_view(\n         cls, name: str, *class_args: t.Any, **class_kwargs: t.Any\n-    ) -> t.Callable:\n-        \"\"\"Converts the class into an actual view function that can be used\n-        with the routing system.  Internally this generates a function on the\n-        fly which will instantiate the :class:`View` on each request and call\n-        the :meth:`dispatch_request` method on it.\n+    ) -> ft.ViewCallable:\n+        \"\"\"Convert the class into a view function that can be registered\n+        for a route.\n \n-        The arguments passed to :meth:`as_view` are forwarded to the\n-        constructor of the class.\n+        By default, the generated view will create a new instance of the\n+        view class for every request and call its\n+        :meth:`dispatch_request` method. If the view class sets\n+        :attr:`init_every_request` to ``False``, the same instance will\n+        be used for every request.\n+\n+        The arguments passed to this method are forwarded to the view\n+        class ``__init__`` method.\n+\n+        .. versionchanged:: 2.2\n+            Added the ``init_every_request`` class attribute.\n         \"\"\"\n+        if cls.init_every_request:\n \n-        def view(*args: t.Any, **kwargs: t.Any) -> ft.ResponseReturnValue:\n-            self = view.view_class(*class_args, **class_kwargs)  # type: ignore\n-            return current_app.ensure_sync(self.dispatch_request)(*args, **kwargs)\n+            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:\n+                self = view.view_class(  # type: ignore[attr-defined]\n+                    *class_args, **class_kwargs\n+                )\n+                return current_app.ensure_sync(self.dispatch_request)(**kwargs)\n+\n+        else:\n+            self = cls(*class_args, **class_kwargs)\n+\n+            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:\n+                return current_app.ensure_sync(self.dispatch_request)(**kwargs)\n \n         if cls.decorators:\n             view.__name__ = name\n@@ -146,7 +174,7 @@ class MethodView(View, metaclass=MethodViewType):\n         app.add_url_rule('/counter', view_func=CounterAPI.as_view('counter'))\n     \"\"\"\n \n-    def dispatch_request(self, *args: t.Any, **kwargs: t.Any) -> ft.ResponseReturnValue:\n+    def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:\n         meth = getattr(self, request.method.lower(), None)\n \n         # If the request method is HEAD and we don't have a handler for it\n@@ -155,4 +183,4 @@ class MethodView(View, metaclass=MethodViewType):\n             meth = getattr(self, \"get\", None)\n \n         assert meth is not None, f\"Unimplemented method {request.method!r}\"\n-        return current_app.ensure_sync(meth)(*args, **kwargs)\n+        return current_app.ensure_sync(meth)(**kwargs)\n\n@@ -240,3 +240,21 @@ def test_remove_method_from_parent(app, client):\n     assert client.get(\"/\").data == b\"GET\"\n     assert client.post(\"/\").status_code == 405\n     assert sorted(View.methods) == [\"GET\"]\n+\n+\n+def test_init_once(app, client):\n+    n = 0\n+\n+    class CountInit(flask.views.View):\n+        init_every_request = False\n+\n+        def __init__(self):\n+            nonlocal n\n+            n += 1\n+\n+        def dispatch_request(self):\n+            return str(n)\n+\n+    app.add_url_rule(\"/\", view_func=CountInit.as_view(\"index\"))\n+    assert client.get(\"/\").data == b\"1\"\n+    assert client.get(\"/\").data == b\"1\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#bab5a65e6eaee20ac1706fc9439ee538f59e652f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 56 | Lines Deleted: 44 | Files Changed: 1 | Hunks: 16 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 100 | Churn Cumulative: 216 | Contributors (this commit): 3 | Commits (past 90d): 3 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -11,53 +11,54 @@ http_method_funcs = frozenset(\n \n \n class View:\n-    \"\"\"Alternative way to use view functions.  A subclass has to implement\n-    :meth:`dispatch_request` which is called with the view arguments from\n-    the URL routing system.  If :attr:`methods` is provided the methods\n-    do not have to be passed to the :meth:`~flask.Flask.add_url_rule`\n-    method explicitly::\n+    \"\"\"Subclass this class and override :meth:`dispatch_request` to\n+    create a generic class-based view. Call :meth:`as_view` to create a\n+    view function that creates an instance of the class with the given\n+    arguments and calls its ``dispatch_request`` method with any URL\n+    variables.\n \n-        class MyView(View):\n-            methods = ['GET']\n+    See :doc:`views` for a detailed guide.\n+\n+    .. code-block:: python\n+\n+        class Hello(View):\n+            init_every_request = False\n \n             def dispatch_request(self, name):\n-                return f\"Hello {name}!\"\n+                return f\"Hello, {name}!\"\n \n-        app.add_url_rule('/hello/<name>', view_func=MyView.as_view('myview'))\n+        app.add_url_rule(\n+            \"/hello/<name>\", view_func=Hello.as_view(\"hello\")\n+        )\n \n-    When you want to decorate a pluggable view you will have to either do that\n-    when the view function is created (by wrapping the return value of\n-    :meth:`as_view`) or you can use the :attr:`decorators` attribute::\n+    Set :attr:`methods` on the class to change what methods the view\n+    accepts.\n \n-        class SecretView(View):\n-            methods = ['GET']\n-            decorators = [superuser_required]\n+    Set :attr:`decorators` on the class to apply a list of decorators to\n+    the generated view function. Decorators applied to the class itself\n+    will not be applied to the generated view function!\n \n-            def dispatch_request(self):\n-                ...\n-\n-    The decorators stored in the decorators list are applied one after another\n-    when the view function is created.  Note that you can *not* use the class\n-    based decorators since those would decorate the view class and not the\n-    generated view function!\n+    Set :attr:`init_every_request` to ``False`` for efficiency, unless\n+    you need to store request-global data on ``self``.\n     \"\"\"\n \n-    #: A list of methods this view can handle.\n-    methods: t.Optional[t.List[str]] = None\n+    #: The methods this view is registered for. Uses the same default\n+    #: (``[\"GET\", \"HEAD\", \"OPTIONS\"]``) as ``route`` and\n+    #: ``add_url_rule`` by default.\n+    methods: t.ClassVar[t.Optional[t.List[str]]] = None\n \n-    #: Setting this disables or force-enables the automatic options handling.\n-    provide_automatic_options: t.Optional[bool] = None\n+    #: Control whether the ``OPTIONS`` method is handled automatically.\n+    #: Uses the same default (``True``) as ``route`` and\n+    #: ``add_url_rule`` by default.\n+    provide_automatic_options: t.ClassVar[t.Optional[bool]] = None\n \n-    #: The canonical way to decorate class-based views is to decorate the\n-    #: return value of as_view().  However since this moves parts of the\n-    #: logic from the class declaration to the place where it's hooked\n-    #: into the routing system.\n-    #:\n-    #: You can place one or more decorators in this list and whenever the\n-    #: view function is created the result is automatically decorated.\n+    #: A list of decorators to apply, in order, to the generated view\n+    #: function. Remember that ``@decorator`` syntax is applied bottom\n+    #: to top, so the first decorator in the list would be the bottom\n+    #: decorator.\n     #:\n     #: .. versionadded:: 0.8\n-    decorators: t.List[t.Callable] = []\n+    decorators: t.ClassVar[t.List[t.Callable]] = []\n \n     #: Create a new instance of this view class for every request by\n     #: default. If a view subclass sets this to ``False``, the same\n@@ -72,9 +73,9 @@ class View:\n     init_every_request: t.ClassVar[bool] = True\n \n     def dispatch_request(self) -> ft.ResponseReturnValue:\n-        \"\"\"Subclasses have to override this method to implement the\n-        actual view function code.  This method is called with all\n-        the arguments from the URL rule.\n+        \"\"\"The actual view function behavior. Subclasses must override\n+        this and return a valid response. Any variables from the URL\n+        rule are passed as keyword arguments.\n         \"\"\"\n         raise NotImplementedError()\n \n@@ -159,19 +160,30 @@ class MethodViewType(type):\n \n \n class MethodView(View, metaclass=MethodViewType):\n-    \"\"\"A class-based view that dispatches request methods to the corresponding\n-    class methods. For example, if you implement a ``get`` method, it will be\n-    used to handle ``GET`` requests. ::\n+    \"\"\"Dispatches request methods to the corresponding instance methods.\n+    For example, if you implement a ``get`` method, it will be used to\n+    handle ``GET`` requests.\n+\n+    This can be useful for defining a REST API.\n+\n+    :attr:`methods` is automatically set based on the methods defined on\n+    the class.\n+\n+    See :doc:`views` for a detailed guide.\n+\n+    .. code-block:: python\n \n         class CounterAPI(MethodView):\n             def get(self):\n-                return session.get('counter', 0)\n+                return str(session.get(\"counter\", 0))\n \n             def post(self):\n-                session['counter'] = session.get('counter', 0) + 1\n-                return 'OK'\n+                session[\"counter\"] = session.get(\"counter\", 0) + 1\n+                return redirect(url_for(\"counter\"))\n \n-        app.add_url_rule('/counter', view_func=CounterAPI.as_view('counter'))\n+        app.add_url_rule(\n+            \"/counter\", view_func=CounterAPI.as_view(\"counter\")\n+        )\n     \"\"\"\n \n     def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#45174bf9a1e96e51ce589c7aa2c151249d1fdf11", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 19 | Lines Deleted: 29 | Files Changed: 1 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 48 | Churn Cumulative: 264 | Contributors (this commit): 3 | Commits (past 90d): 4 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -45,7 +45,7 @@ class View:\n     #: The methods this view is registered for. Uses the same default\n     #: (``[\"GET\", \"HEAD\", \"OPTIONS\"]``) as ``route`` and\n     #: ``add_url_rule`` by default.\n-    methods: t.ClassVar[t.Optional[t.List[str]]] = None\n+    methods: t.ClassVar[t.Optional[t.Collection[str]]] = None\n \n     #: Control whether the ``OPTIONS`` method is handled automatically.\n     #: Uses the same default (``True``) as ``route`` and\n@@ -132,34 +132,7 @@ class View:\n         return view\n \n \n-class MethodViewType(type):\n-    \"\"\"Metaclass for :class:`MethodView` that determines what methods the view\n-    defines.\n-    \"\"\"\n-\n-    def __init__(cls, name, bases, d):\n-        super().__init__(name, bases, d)\n-\n-        if \"methods\" not in d:\n-            methods = set()\n-\n-            for base in bases:\n-                if getattr(base, \"methods\", None):\n-                    methods.update(base.methods)\n-\n-            for key in http_method_funcs:\n-                if hasattr(cls, key):\n-                    methods.add(key.upper())\n-\n-            # If we have no method at all in there we don't want to add a\n-            # method list. This is for instance the case for the base class\n-            # or another subclass of a base method view that does not introduce\n-            # new methods.\n-            if methods:\n-                cls.methods = methods\n-\n-\n-class MethodView(View, metaclass=MethodViewType):\n+class MethodView(View):\n     \"\"\"Dispatches request methods to the corresponding instance methods.\n     For example, if you implement a ``get`` method, it will be used to\n     handle ``GET`` requests.\n@@ -186,6 +159,23 @@ class MethodView(View, metaclass=MethodViewType):\n         )\n     \"\"\"\n \n+    def __init_subclass__(cls, **kwargs: t.Any) -> None:\n+        super().__init_subclass__(**kwargs)\n+\n+        if \"methods\" not in cls.__dict__:\n+            methods = set()\n+\n+            for base in cls.__bases__:\n+                if getattr(base, \"methods\", None):\n+                    methods.update(base.methods)  # type: ignore[attr-defined]\n+\n+            for key in http_method_funcs:\n+                if hasattr(cls, key):\n+                    methods.add(key.upper())\n+\n+            if methods:\n+                cls.methods = methods\n+\n     def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:\n         meth = getattr(self, request.method.lower(), None)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#6f6e3289da182593fb296da072049ade729adeea", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 8 | Churn Cumulative: 99 | Contributors (this commit): 2 | Commits (past 90d): 2 | Contributors (cumulative): 4 | DMM Complexity: None\n\nDIFF:\n@@ -5,8 +5,8 @@ from flask import request\n from js_example import app\n \n \n-@app.route(\"/\", defaults={\"js\": \"plain\"})\n-@app.route(\"/<any(plain, jquery, fetch):js>\")\n+@app.route(\"/\", defaults={\"js\": \"fetch\"})\n+@app.route(\"/<any(xhr, jquery, fetch):js>\")\n def index(js):\n     return render_template(f\"{js}.html\", js=js)\n \n\n@@ -5,8 +5,8 @@ from flask import template_rendered\n @pytest.mark.parametrize(\n     (\"path\", \"template_name\"),\n     (\n-        (\"/\", \"plain.html\"),\n-        (\"/plain\", \"plain.html\"),\n+        (\"/\", \"xhr.html\"),\n+        (\"/plain\", \"xhr.html\"),\n         (\"/fetch\", \"fetch.html\"),\n         (\"/jquery\", \"jquery.html\"),\n     ),\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#9934528c8f7e3aa6f4a1c800cba439e5425a5093", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 7/7 | Churn Δ: 3 | Churn Cumulative: 1775 | Contributors (this commit): 16 | Commits (past 90d): 8 | Contributors (cumulative): 16 | DMM Complexity: 1.0\n\nDIFF:\n@@ -649,7 +649,8 @@ def send_from_directory(\n     If the final path does not point to an existing regular file,\n     raises a 404 :exc:`~werkzeug.exceptions.NotFound` error.\n \n-    :param directory: The directory that ``path`` must be located under.\n+    :param directory: The directory that ``path`` must be located under,\n+        relative to the current application's root path.\n     :param path: The path to the file to send, relative to\n         ``directory``.\n     :param kwargs: Arguments to pass to :func:`send_file`.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#4f03a769d44f6740490dd4ddf70e094c12a6090c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 17 | Lines Deleted: 29 | Files Changed: 3 | Hunks: 14 | Methods Changed: 5 | Complexity Δ (Sum/Max): -1/1 | Churn Δ: 46 | Churn Cumulative: 3004 | Contributors (this commit): 33 | Commits (past 90d): 20 | Contributors (cumulative): 39 | DMM Complexity: 0.0\n\nDIFF:\n@@ -10,6 +10,7 @@ from itertools import chain\n from threading import Lock\n from types import TracebackType\n \n+import click\n from werkzeug.datastructures import Headers\n from werkzeug.datastructures import ImmutableDict\n from werkzeug.exceptions import Aborter\n@@ -23,6 +24,7 @@ from werkzeug.routing import MapAdapter\n from werkzeug.routing import RequestRedirect\n from werkzeug.routing import RoutingException\n from werkzeug.routing import Rule\n+from werkzeug.serving import is_running_from_reloader\n from werkzeug.urls import url_quote\n from werkzeug.utils import redirect as _wz_redirect\n from werkzeug.wrappers import Response as BaseResponse\n@@ -908,12 +910,18 @@ class Flask(Scaffold):\n             The default port is now picked from the ``SERVER_NAME``\n             variable.\n         \"\"\"\n-        # Change this into a no-op if the server is invoked from the\n-        # command line. Have a look at cli.py for more information.\n+        # Ignore this call so that it doesn't start another server if\n+        # the 'flask run' command is used.\n         if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n-            from .debughelpers import explain_ignored_app_run\n+            if not is_running_from_reloader():\n+                click.secho(\n+                    \" * Ignoring a call to 'app.run()', the server is\"\n+                    \" already being run with the 'flask run' command.\\n\"\n+                    \"   Only call 'app.run()' in an 'if __name__ ==\"\n+                    ' \"__main__\"\\' guard.',\n+                    fg=\"red\",\n+                )\n \n-            explain_ignored_app_run()\n             return\n \n         if get_load_dotenv(load_dotenv):\n\n@@ -11,6 +11,7 @@ from threading import Lock\n from threading import Thread\n \n import click\n+from werkzeug.serving import is_running_from_reloader\n from werkzeug.utils import import_string\n \n from .globals import current_app\n@@ -273,7 +274,7 @@ class DispatchingApp:\n         self._bg_loading_exc = None\n \n         if use_eager_loading is None:\n-            use_eager_loading = os.environ.get(\"WERKZEUG_RUN_MAIN\") != \"true\"\n+            use_eager_loading = not is_running_from_reloader()\n \n         if use_eager_loading:\n             self._load_unlocked()\n@@ -546,12 +547,6 @@ class FlaskGroup(AppGroup):\n         return sorted(rv)\n \n     def main(self, *args, **kwargs):\n-        # Set a global flag that indicates that we were invoked from the\n-        # command line interface. This is detected by Flask.run to make the\n-        # call into a no-op. This is necessary to avoid ugly errors when the\n-        # script that is loaded here also attempts to start a server.\n-        os.environ[\"FLASK_RUN_FROM_CLI\"] = \"true\"\n-\n         if get_load_dotenv(self.load_dotenv):\n             load_dotenv()\n \n@@ -637,7 +632,7 @@ def show_server_banner(env, debug, app_import_path, eager_loading):\n     \"\"\"Show extra startup messages the first time the server is run,\n     ignoring the reloader.\n     \"\"\"\n-    if os.environ.get(\"WERKZEUG_RUN_MAIN\") == \"true\":\n+    if is_running_from_reloader():\n         return\n \n     if app_import_path is not None:\n@@ -653,10 +648,10 @@ def show_server_banner(env, debug, app_import_path, eager_loading):\n     if env == \"production\":\n         click.secho(\n             \"   WARNING: This is a development server. Do not use it in\"\n-            \" a production deployment.\",\n+            \" a production deployment.\\n   Use a production WSGI server\"\n+            \" instead.\",\n             fg=\"red\",\n         )\n-        click.secho(\"   Use a production WSGI server instead.\", dim=True)\n \n     if debug is not None:\n         click.echo(f\" * Debug mode: {'on' if debug else 'off'}\")\n\n@@ -1,6 +1,4 @@\n-import os\n import typing as t\n-from warnings import warn\n \n from .app import Flask\n from .blueprints import Blueprint\n@@ -159,16 +157,3 @@ def explain_template_loading_attempts(app: Flask, template, attempts) -> None:\n         info.append(\"  See https://flask.palletsprojects.com/blueprints/#templates\")\n \n     app.logger.info(\"\\n\".join(info))\n-\n-\n-def explain_ignored_app_run() -> None:\n-    if os.environ.get(\"WERKZEUG_RUN_MAIN\") != \"true\":\n-        warn(\n-            Warning(\n-                \"Silently ignoring app.run() because the application is\"\n-                \" run from the flask command line executable. Consider\"\n-                ' putting app.run() behind an if __name__ == \"__main__\"'\n-                \" guard to silence this warning.\"\n-            ),\n-            stacklevel=3,\n-        )\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#aa801c431ad1f979bce3ea1afbd88e7796ebfd7e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 33 | Lines Deleted: 10 | Files Changed: 2 | Hunks: 8 | Methods Changed: 5 | Complexity Δ (Sum/Max): 4/2 | Churn Δ: 43 | Churn Cumulative: 2503 | Contributors (this commit): 39 | Commits (past 90d): 10 | Contributors (cumulative): 45 | DMM Complexity: 1.0\n\nDIFF:\n@@ -5,6 +5,7 @@ import platform\n import re\n import sys\n import traceback\n+import typing as t\n from functools import update_wrapper\n from operator import attrgetter\n from threading import Lock\n@@ -478,7 +479,13 @@ class FlaskGroup(AppGroup):\n         if add_version_option:\n             params.append(version_option)\n \n-        AppGroup.__init__(self, params=params, **extra)\n+        if \"context_settings\" not in extra:\n+            extra[\"context_settings\"] = {}\n+\n+        extra[\"context_settings\"].setdefault(\"auto_envvar_prefix\", \"FLASK\")\n+\n+        super().__init__(params=params, **extra)\n+\n         self.create_app = create_app\n         self.load_dotenv = load_dotenv\n         self.set_debug_flag = set_debug_flag\n@@ -546,20 +553,22 @@ class FlaskGroup(AppGroup):\n \n         return sorted(rv)\n \n-    def main(self, *args, **kwargs):\n+    def make_context(\n+        self,\n+        info_name: t.Optional[str],\n+        args: t.List[str],\n+        parent: t.Optional[click.Context] = None,\n+        **extra: t.Any,\n+    ) -> click.Context:\n         if get_load_dotenv(self.load_dotenv):\n             load_dotenv()\n \n-        obj = kwargs.get(\"obj\")\n-\n-        if obj is None:\n-            obj = ScriptInfo(\n+        if \"obj\" not in extra and \"obj\" not in self.context_settings:\n+            extra[\"obj\"] = ScriptInfo(\n                 create_app=self.create_app, set_debug_flag=self.set_debug_flag\n             )\n \n-        kwargs[\"obj\"] = obj\n-        kwargs.setdefault(\"auto_envvar_prefix\", \"FLASK\")\n-        return super().main(*args, **kwargs)\n+        return super().make_context(info_name, args, parent=parent, **extra)\n \n \n def _path_is_ancestor(path, other):\n@@ -958,6 +967,7 @@ def routes_command(sort: str, all_methods: bool) -> None:\n \n \n cli = FlaskGroup(\n+    name=\"flask\",\n     help=\"\"\"\\\n A general utility script for Flask applications.\n \n@@ -973,7 +983,7 @@ debug mode.\n \"\"\".format(\n         cmd=\"export\" if os.name == \"posix\" else \"set\",\n         prefix=\"$ \" if os.name == \"posix\" else \"> \",\n-    )\n+    ),\n )\n \n \n\n@@ -388,6 +388,19 @@ def test_flaskgroup_debug(runner, set_debug_flag):\n     assert result.output == f\"{not set_debug_flag}\\n\"\n \n \n+def test_flaskgroup_nested(app, runner):\n+    cli = click.Group(\"cli\")\n+    flask_group = FlaskGroup(name=\"flask\", create_app=lambda: app)\n+    cli.add_command(flask_group)\n+\n+    @flask_group.command()\n+    def show():\n+        click.echo(current_app.name)\n+\n+    result = runner.invoke(cli, [\"flask\", \"show\"])\n+    assert result.output == \"flask_test\\n\"\n+\n+\n def test_no_command_echo_loading_error():\n     from flask.cli import cli\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#99fa3c36abc03cd5b3407df34dce74e879ea377a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 191 | Lines Deleted: 54 | Files Changed: 2 | Hunks: 34 | Methods Changed: 17 | Complexity Δ (Sum/Max): 5/12 | Churn Δ: 245 | Churn Cumulative: 2738 | Contributors (this commit): 25 | Commits (past 90d): 14 | Contributors (cumulative): 29 | DMM Complexity: 0.618421052631579\n\nDIFF:\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import ast\n import inspect\n import os\n@@ -12,6 +14,7 @@ from threading import Lock\n from threading import Thread\n \n import click\n+from click.core import ParameterSource\n from werkzeug.serving import is_running_from_reloader\n from werkzeug.utils import import_string\n \n@@ -20,6 +23,9 @@ from .helpers import get_debug_flag\n from .helpers import get_env\n from .helpers import get_load_dotenv\n \n+if t.TYPE_CHECKING:\n+    from .app import Flask\n+\n \n class NoAppException(click.UsageError):\n     \"\"\"Raised if an application cannot be found or loaded.\"\"\"\n@@ -46,8 +52,8 @@ def find_best_app(module):\n     elif len(matches) > 1:\n         raise NoAppException(\n             \"Detected multiple Flask applications in module\"\n-            f\" {module.__name__!r}. Use 'FLASK_APP={module.__name__}:name'\"\n-            f\" to specify the correct one.\"\n+            f\" '{module.__name__}'. Use '{module.__name__}:name'\"\n+            \" to specify the correct one.\"\n         )\n \n     # Search for app factory functions.\n@@ -65,15 +71,15 @@ def find_best_app(module):\n                     raise\n \n                 raise NoAppException(\n-                    f\"Detected factory {attr_name!r} in module {module.__name__!r},\"\n+                    f\"Detected factory '{attr_name}' in module '{module.__name__}',\"\n                     \" but could not call it without arguments. Use\"\n-                    f\" \\\"FLASK_APP='{module.__name__}:{attr_name}(args)'\\\"\"\n+                    f\" '{module.__name__}:{attr_name}(args)'\"\n                     \" to specify arguments.\"\n                 ) from e\n \n     raise NoAppException(\n         \"Failed to find Flask application or factory in module\"\n-        f\" {module.__name__!r}. Use 'FLASK_APP={module.__name__}:name'\"\n+        f\" '{module.__name__}'. Use '{module.__name__}:name'\"\n         \" to specify one.\"\n     )\n \n@@ -253,7 +259,7 @@ def get_version(ctx, param, value):\n \n version_option = click.Option(\n     [\"--version\"],\n-    help=\"Show the flask version\",\n+    help=\"Show the Flask version.\",\n     expose_value=False,\n     callback=get_version,\n     is_flag=True,\n@@ -338,19 +344,24 @@ class ScriptInfo:\n     onwards as click object.\n     \"\"\"\n \n-    def __init__(self, app_import_path=None, create_app=None, set_debug_flag=True):\n+    def __init__(\n+        self,\n+        app_import_path: str | None = None,\n+        create_app: t.Callable[..., Flask] | None = None,\n+        set_debug_flag: bool = True,\n+    ) -> None:\n         #: Optionally the import path for the Flask application.\n-        self.app_import_path = app_import_path or os.environ.get(\"FLASK_APP\")\n+        self.app_import_path = app_import_path\n         #: Optionally a function that is passed the script info to create\n         #: the instance of the application.\n         self.create_app = create_app\n         #: A dictionary with arbitrary data that can be associated with\n         #: this script info.\n-        self.data = {}\n+        self.data: t.Dict[t.Any, t.Any] = {}\n         self.set_debug_flag = set_debug_flag\n-        self._loaded_app = None\n+        self._loaded_app: Flask | None = None\n \n-    def load_app(self):\n+    def load_app(self) -> Flask:\n         \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n         this multiple times will just result in the already loaded app to\n         be returned.\n@@ -379,9 +390,10 @@ class ScriptInfo:\n \n         if not app:\n             raise NoAppException(\n-                \"Could not locate a Flask application. You did not provide \"\n-                'the \"FLASK_APP\" environment variable, and a \"wsgi.py\" or '\n-                '\"app.py\" module was not found in the current directory.'\n+                \"Could not locate a Flask application. Use the\"\n+                \" 'flask --app' option, 'FLASK_APP' environment\"\n+                \" variable, or a 'wsgi.py' or 'app.py' file in the\"\n+                \" current directory.\"\n             )\n \n         if self.set_debug_flag:\n@@ -442,6 +454,117 @@ class AppGroup(click.Group):\n         return click.Group.group(self, *args, **kwargs)\n \n \n+def _set_app(ctx: click.Context, param: click.Option, value: str | None) -> str | None:\n+    if value is None:\n+        return None\n+\n+    info = ctx.ensure_object(ScriptInfo)\n+    info.app_import_path = value\n+    return value\n+\n+\n+# This option is eager so the app will be available if --help is given.\n+# --help is also eager, so --app must be before it in the param list.\n+# no_args_is_help bypasses eager processing, so this option must be\n+# processed manually in that case to ensure FLASK_APP gets picked up.\n+_app_option = click.Option(\n+    [\"-A\", \"--app\"],\n+    metavar=\"IMPORT\",\n+    help=(\n+        \"The Flask application or factory function to load, in the form 'module:name'.\"\n+        \" Module can be a dotted import or file path. Name is not required if it is\"\n+        \" 'app', 'application', 'create_app', or 'make_app', and can be 'name(args)' to\"\n+        \" pass arguments.\"\n+    ),\n+    is_eager=True,\n+    expose_value=False,\n+    callback=_set_app,\n+)\n+\n+\n+def _set_env(ctx: click.Context, param: click.Option, value: str | None) -> str | None:\n+    if value is None:\n+        return None\n+\n+    # Set with env var instead of ScriptInfo.load so that it can be\n+    # accessed early during a factory function.\n+    os.environ[\"FLASK_ENV\"] = value\n+    return value\n+\n+\n+_env_option = click.Option(\n+    [\"-E\", \"--env\"],\n+    metavar=\"NAME\",\n+    help=(\n+        \"The execution environment name to set in 'app.env'. Defaults to\"\n+        \" 'production'. 'development' will enable 'app.debug' and start the\"\n+        \" debugger and reloader when running the server.\"\n+    ),\n+    expose_value=False,\n+    callback=_set_env,\n+)\n+\n+\n+def _set_debug(ctx: click.Context, param: click.Option, value: bool) -> bool | None:\n+    # If the flag isn't provided, it will default to False. Don't use\n+    # that, let debug be set by env in that case.\n+    source = ctx.get_parameter_source(param.name)  # type: ignore[arg-type]\n+\n+    if source is not None and source in (\n+        ParameterSource.DEFAULT,\n+        ParameterSource.DEFAULT_MAP,\n+    ):\n+        return None\n+\n+    # Set with env var instead of ScriptInfo.load so that it can be\n+    # accessed early during a factory function.\n+    os.environ[\"FLASK_DEBUG\"] = \"1\" if value else \"0\"\n+    return value\n+\n+\n+_debug_option = click.Option(\n+    [\"--debug/--no-debug\"],\n+    help=\"Set 'app.debug' separately from '--env'.\",\n+    expose_value=False,\n+    callback=_set_debug,\n+)\n+\n+\n+def _env_file_callback(\n+    ctx: click.Context, param: click.Option, value: str | None\n+) -> str | None:\n+    if value is None:\n+        return None\n+\n+    import importlib\n+\n+    try:\n+        importlib.import_module(\"dotenv\")\n+    except ImportError:\n+        raise click.BadParameter(\n+            \"python-dotenv must be installed to load an env file.\",\n+            ctx=ctx,\n+            param=param,\n+        ) from None\n+\n+    # Don't check FLASK_SKIP_DOTENV, that only disables automatically\n+    # loading .env and .flaskenv files.\n+    load_dotenv(value)\n+    return value\n+\n+\n+# This option is eager so env vars are loaded as early as possible to be\n+# used by other options.\n+_env_file_option = click.Option(\n+    [\"-e\", \"--env-file\"],\n+    type=click.Path(exists=True, dir_okay=False),\n+    help=\"Load environment variables from this file. python-dotenv must be installed.\",\n+    is_eager=True,\n+    expose_value=False,\n+    callback=_env_file_callback,\n+)\n+\n+\n class FlaskGroup(AppGroup):\n     \"\"\"Special subclass of the :class:`AppGroup` group that supports\n     loading more commands from the configured Flask app.  Normally a\n@@ -460,6 +583,10 @@ class FlaskGroup(AppGroup):\n     :param set_debug_flag: Set the app's debug flag based on the active\n         environment\n \n+    .. versionchanged:: 2.2\n+        Added the ``-A/--app``, ``-E/--env``, ``--debug/--no-debug``,\n+        and ``-e/--env-file`` options.\n+\n     .. versionchanged:: 1.0\n         If installed, python-dotenv will be used to load environment variables\n         from :file:`.env` and :file:`.flaskenv` files.\n@@ -467,14 +594,19 @@ class FlaskGroup(AppGroup):\n \n     def __init__(\n         self,\n-        add_default_commands=True,\n-        create_app=None,\n-        add_version_option=True,\n-        load_dotenv=True,\n-        set_debug_flag=True,\n-        **extra,\n-    ):\n+        add_default_commands: bool = True,\n+        create_app: t.Callable[..., Flask] | None = None,\n+        add_version_option: bool = True,\n+        load_dotenv: bool = True,\n+        set_debug_flag: bool = True,\n+        **extra: t.Any,\n+    ) -> None:\n         params = list(extra.pop(\"params\", None) or ())\n+        # Processing is done with option callbacks instead of a group\n+        # callback. This allows users to make a custom group callback\n+        # without losing the behavior. --env-file must come first so\n+        # that it is eagerly evaluated before --app.\n+        params.extend((_env_file_option, _app_option, _env_option, _debug_option))\n \n         if add_version_option:\n             params.append(version_option)\n@@ -555,11 +687,13 @@ class FlaskGroup(AppGroup):\n \n     def make_context(\n         self,\n-        info_name: t.Optional[str],\n-        args: t.List[str],\n-        parent: t.Optional[click.Context] = None,\n+        info_name: str | None,\n+        args: list[str],\n+        parent: click.Context | None = None,\n         **extra: t.Any,\n     ) -> click.Context:\n+        # Attempt to load .env and .flask env files. The --env-file\n+        # option can cause another file to be loaded.\n         if get_load_dotenv(self.load_dotenv):\n             load_dotenv()\n \n@@ -570,6 +704,16 @@ class FlaskGroup(AppGroup):\n \n         return super().make_context(info_name, args, parent=parent, **extra)\n \n+    def parse_args(self, ctx: click.Context, args: list[str]) -> list[str]:\n+        if not args and self.no_args_is_help:\n+            # Attempt to load --env-file and --app early in case they\n+            # were given as env vars. Otherwise no_args_is_help will not\n+            # see commands from app.cli.\n+            _env_file_option.handle_parse_result(ctx, {}, [])\n+            _app_option.handle_parse_result(ctx, {}, [])\n+\n+        return super().parse_args(ctx, args)\n+\n \n def _path_is_ancestor(path, other):\n     \"\"\"Take ``other`` and remove the length of ``path`` from it. Then join it\n@@ -578,7 +722,7 @@ def _path_is_ancestor(path, other):\n     return os.path.join(path, other[len(path) :].lstrip(os.sep)) == other\n \n \n-def load_dotenv(path=None):\n+def load_dotenv(path: str | os.PathLike | None = None) -> bool:\n     \"\"\"Load \"dotenv\" files in order of precedence to set environment variables.\n \n     If an env var is already set it is not overwritten, so earlier files in the\n@@ -591,13 +735,17 @@ def load_dotenv(path=None):\n     :param path: Load the file at this location instead of searching.\n     :return: ``True`` if a file was loaded.\n \n-    .. versionchanged:: 1.1.0\n-        Returns ``False`` when python-dotenv is not installed, or when\n-        the given path isn't a file.\n+    .. versionchanged:: 2.0\n+        The current directory is not changed to the location of the\n+        loaded file.\n \n     .. versionchanged:: 2.0\n         When loading the env files, set the default encoding to UTF-8.\n \n+    .. versionchanged:: 1.1.0\n+        Returns ``False`` when python-dotenv is not installed, or when\n+        the given path isn't a file.\n+\n     .. versionadded:: 1.0\n     \"\"\"\n     try:\n@@ -613,15 +761,15 @@ def load_dotenv(path=None):\n \n         return False\n \n-    # if the given path specifies the actual file then return True,\n-    # else False\n+    # Always return after attempting to load a given path, don't load\n+    # the default files.\n     if path is not None:\n         if os.path.isfile(path):\n             return dotenv.load_dotenv(path, encoding=\"utf-8\")\n \n         return False\n \n-    new_dir = None\n+    loaded = False\n \n     for name in (\".env\", \".flaskenv\"):\n         path = dotenv.find_dotenv(name, usecwd=True)\n@@ -629,12 +777,10 @@ def load_dotenv(path=None):\n         if not path:\n             continue\n \n-        if new_dir is None:\n-            new_dir = os.path.dirname(path)\n-\n         dotenv.load_dotenv(path, encoding=\"utf-8\")\n+        loaded = True\n \n-    return new_dir is not None  # at least one file was located and loaded\n+    return loaded  # True if at least one file was located and loaded.\n \n \n def show_server_banner(env, debug, app_import_path, eager_loading):\n@@ -837,9 +983,10 @@ def run_command(\n     This server is for development purposes only. It does not provide\n     the stability, security, or performance of production WSGI servers.\n \n-    The reloader and debugger are enabled by default if\n-    FLASK_ENV=development or FLASK_DEBUG=1.\n+    The reloader and debugger are enabled by default with the\n+    '--env development' or '--debug' options.\n     \"\"\"\n+    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n     debug = get_debug_flag()\n \n     if reload is None:\n@@ -849,7 +996,6 @@ def run_command(\n         debugger = debug\n \n     show_server_banner(get_env(), debug, info.app_import_path, eager_loading)\n-    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n \n     from werkzeug.serving import run_simple\n \n@@ -971,19 +1117,10 @@ cli = FlaskGroup(\n     help=\"\"\"\\\n A general utility script for Flask applications.\n \n-Provides commands from Flask, extensions, and the application. Loads the\n-application defined in the FLASK_APP environment variable, or from a wsgi.py\n-file. Setting the FLASK_ENV environment variable to 'development' will enable\n-debug mode.\n-\n-\\b\n-  {prefix}{cmd} FLASK_APP=hello.py\n-  {prefix}{cmd} FLASK_ENV=development\n-  {prefix}flask run\n-\"\"\".format(\n-        cmd=\"export\" if os.name == \"posix\" else \"set\",\n-        prefix=\"$ \" if os.name == \"posix\" else \"> \",\n-    ),\n+An application to load must be given with the '--app' option,\n+'FLASK_APP' environment variable, or with a 'wsgi.py' or 'app.py' file\n+in the current directory.\n+\"\"\",\n )\n \n \n\n@@ -48,9 +48,9 @@ def get_debug_flag() -> bool:\n \n \n def get_load_dotenv(default: bool = True) -> bool:\n-    \"\"\"Get whether the user has disabled loading dotenv files by setting\n-    :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load the\n-    files.\n+    \"\"\"Get whether the user has disabled loading default dotenv files by\n+    setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load\n+    the files.\n \n     :param default: What to return if the env var isn't set.\n     \"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
