{"custom_id": "scrapy#0097b4c0bb4de6e651e8b9d064aae140e11698d5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 5 | Files Changed: 3 | Hunks: 4 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 9 | Churn Cumulative: 3086 | Contributors (this commit): 52 | Commits (past 90d): 6 | Contributors (cumulative): 82 | DMM Complexity: None\n\nDIFF:\n@@ -3,8 +3,7 @@ import cProfile\n import inspect\n import os\n import sys\n-\n-import pkg_resources\n+from importlib.metadata import entry_points\n \n import scrapy\n from scrapy.commands import BaseRunSpiderCommand, ScrapyCommand, ScrapyHelpFormatter\n@@ -49,7 +48,7 @@ def _get_commands_from_module(module, inproject):\n \n def _get_commands_from_entry_points(inproject, group=\"scrapy.commands\"):\n     cmds = {}\n-    for entry_point in pkg_resources.iter_entry_points(group):\n+    for entry_point in entry_points(group):\n         obj = entry_point.load()\n         if inspect.isclass(obj):\n             cmds[entry_point.name] = obj()\n\n@@ -1,6 +1,6 @@\n from pathlib import Path\n \n-from pkg_resources import parse_version\n+from packaging.version import parse as parse_version\n from setuptools import __version__ as setuptools_version\n from setuptools import find_packages, setup\n \n\n@@ -6,7 +6,7 @@ import sys\n import warnings\n from pathlib import Path\n \n-from pkg_resources import parse_version\n+from packaging.version import parse as parse_version\n from pytest import mark, raises\n from twisted import version as twisted_version\n from twisted.internet import defer\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#a93a63c208af1d13d5ea84623d160337c7fec6c5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 796 | Contributors (this commit): 37 | Commits (past 90d): 4 | Contributors (cumulative): 37 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,6 +1,5 @@\n from pathlib import Path\n \n-from packaging.version import parse as parse_version\n from setuptools import __version__ as setuptools_version\n from setuptools import find_packages, setup\n \n@@ -15,6 +14,8 @@ def has_environment_marker_platform_impl_support():\n     it is 18.5, see:\n     https://setuptools.readthedocs.io/en/latest/history.html#id235\n     \"\"\"\n+    from packaging.version import parse as parse_version\n+\n     return parse_version(setuptools_version) >= parse_version(\"18.5\")\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#0b1da44a05cc64970aa11ccc4d7a4a3bec143443", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 27 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 31 | Churn Cumulative: 827 | Contributors (this commit): 37 | Commits (past 90d): 5 | Contributors (cumulative): 37 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,24 +1,10 @@\n from pathlib import Path\n \n-from setuptools import __version__ as setuptools_version\n from setuptools import find_packages, setup\n \n version = (Path(__file__).parent / \"scrapy/VERSION\").read_text(\"ascii\").strip()\n \n \n-def has_environment_marker_platform_impl_support():\n-    \"\"\"Code extracted from 'pytest/setup.py'\n-    https://github.com/pytest-dev/pytest/blob/7538680c/setup.py#L31\n-\n-    The first known release to support environment marker with range operators\n-    it is 18.5, see:\n-    https://setuptools.readthedocs.io/en/latest/history.html#id235\n-    \"\"\"\n-    from packaging.version import parse as parse_version\n-\n-    return parse_version(setuptools_version) >= parse_version(\"18.5\")\n-\n-\n install_requires = [\n     \"Twisted>=18.9.0\",\n     \"cryptography>=36.0.0\",\n@@ -37,19 +23,10 @@ install_requires = [\n     \"tldextract\",\n     \"lxml>=4.4.1\",\n ]\n-extras_require = {}\n-cpython_dependencies = [\n-    \"PyDispatcher>=2.0.5\",\n-]\n-if has_environment_marker_platform_impl_support():\n-    extras_require[\n-        ':platform_python_implementation == \"CPython\"'\n-    ] = cpython_dependencies\n-    extras_require[':platform_python_implementation == \"PyPy\"'] = [\n-        \"PyPyDispatcher>=2.1.0\",\n-    ]\n-else:\n-    install_requires.extend(cpython_dependencies)\n+extras_require = {\n+    ':platform_python_implementation == \"CPython\"': [\"PyDispatcher>=2.0.5\"],\n+    ':platform_python_implementation == \"PyPy\"': [\"PyPyDispatcher>=2.1.0\"],\n+}\n \n \n setup(\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#82cf00bbc931723320c9aca3cf0305372027d0a0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 800 | Contributors (this commit): 24 | Commits (past 90d): 2 | Contributors (cumulative): 24 | DMM Complexity: None\n\nDIFF:\n@@ -48,7 +48,7 @@ def _get_commands_from_module(module, inproject):\n \n def _get_commands_from_entry_points(inproject, group=\"scrapy.commands\"):\n     cmds = {}\n-    for entry_point in entry_points(group):\n+    for entry_point in entry_points().get(group, {}):\n         obj = entry_point.load()\n         if inspect.isclass(obj):\n             cmds[entry_point.name] = obj()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#5360ba34bc345667f77a4d4256f15fd648e42e18", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 14 | Lines Deleted: 17 | Files Changed: 12 | Hunks: 15 | Methods Changed: 10 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 31 | Churn Cumulative: 7571 | Contributors (this commit): 104 | Commits (past 90d): 20 | Contributors (cumulative): 225 | DMM Complexity: None\n\nDIFF:\n@@ -30,7 +30,7 @@ def main():\n     try:\n         with Path(\"build/linkcheck/output.txt\").open(encoding=\"utf-8\") as out:\n             output_lines = out.readlines()\n-    except IOError:\n+    except OSError:\n         print(\"linkcheck output not found; please run linkcheck first.\")\n         sys.exit(1)\n \n\n@@ -63,7 +63,7 @@ class DecompressionMiddleware:\n         archive = BytesIO(response.body)\n         try:\n             body = gzip.GzipFile(fileobj=archive).read()\n-        except IOError:\n+        except OSError:\n             return\n \n         respcls = responsetypes.from_args(body=body)\n@@ -72,7 +72,7 @@ class DecompressionMiddleware:\n     def _is_bzip2(self, response):\n         try:\n             body = bz2.decompress(response.body)\n-        except IOError:\n+        except OSError:\n             return\n \n         respcls = responsetypes.from_args(body=body)\n\n@@ -37,7 +37,7 @@ class HttpCacheMiddleware:\n         ConnectionLost,\n         TCPTimedOutError,\n         ResponseFailed,\n-        IOError,\n+        OSError,\n     )\n \n     def __init__(self, settings: Settings, stats: StatsCollector) -> None:\n\n@@ -268,9 +268,9 @@ RETRY_EXCEPTIONS = [\n     \"twisted.internet.error.ConnectionLost\",\n     \"twisted.internet.error.TCPTimedOutError\",\n     \"twisted.web.client.ResponseFailed\",\n-    # IOError is raised by the HttpCompression middleware when trying to\n+    # OSError is raised by the HttpCompression middleware when trying to\n     # decompress an empty response\n-    IOError,\n+    OSError,\n     \"scrapy.core.downloader.handlers.http11.TunnelError\",\n ]\n \n\n@@ -15,7 +15,7 @@ def gunzip(data):\n         try:\n             chunk = f.read1(8196)\n             output_list.append(chunk)\n-        except (IOError, EOFError, struct.error):\n+        except (OSError, EOFError, struct.error):\n             # complete only if there is some data, otherwise re-raise\n             # see issue 87 about catching struct.error\n             # some pages are quite small so output_list is empty and f.extrabuf\n\n@@ -291,7 +291,7 @@ def without_none_values(iterable):\n     try:\n         return {k: v for k, v in iterable.items() if v is not None}\n     except AttributeError:\n-        return type(iterable)((v for v in iterable if v is not None))\n+        return type(iterable)(v for v in iterable if v is not None)\n \n \n def global_object_name(obj):\n\n@@ -129,7 +129,7 @@ class FileTestCase(unittest.TestCase):\n     def test_non_existent(self):\n         request = Request(f\"file://{self.mktemp()}\")\n         d = self.download_request(request, Spider(\"foo\"))\n-        return self.assertFailure(d, IOError)\n+        return self.assertFailure(d, OSError)\n \n \n class ContentLengthHeaderResource(resource.Resource):\n\n@@ -70,7 +70,7 @@ class DefaultsTest(ManagerTestCase):\n         In particular when some website returns a 30x response with header\n         'Content-Encoding: gzip' giving as result the error below:\n \n-            exceptions.IOError: Not a gzipped file\n+            BadGzipFile: Not a gzipped file (...)\n \n         \"\"\"\n         req = Request(\"http://example.com\")\n@@ -108,7 +108,7 @@ class DefaultsTest(ManagerTestCase):\n                 \"Location\": \"http://example.com/login\",\n             },\n         )\n-        self.assertRaises(IOError, self._download, request=req, response=resp)\n+        self.assertRaises(OSError, self._download, request=req, response=resp)\n \n \n class ResponseFromProcessRequestTest(ManagerTestCase):\n\n@@ -1,5 +1,3 @@\n-# coding=utf-8\n-\n import unittest\n from email.charset import Charset\n from io import BytesIO\n\n@@ -1,4 +1,3 @@\n-# coding=utf-8\n from twisted.trial import unittest\n \n \n\n@@ -28,7 +28,7 @@ class GunzipTest(unittest.TestCase):\n \n     def test_gunzip_no_gzip_file_raises(self):\n         self.assertRaises(\n-            IOError, gunzip, (SAMPLEDIR / \"feed-sample1.xml\").read_bytes()\n+            OSError, gunzip, (SAMPLEDIR / \"feed-sample1.xml\").read_bytes()\n         )\n \n     def test_gunzip_truncated_short(self):\n\n@@ -346,8 +346,8 @@ class UtilsCsvTestCase(unittest.TestCase):\n \n         # explicit type check cuz' we no like stinkin' autocasting! yarrr\n         for result_row in result:\n-            self.assertTrue(all((isinstance(k, str) for k in result_row.keys())))\n-            self.assertTrue(all((isinstance(v, str) for v in result_row.values())))\n+            self.assertTrue(all(isinstance(k, str) for k in result_row.keys()))\n+            self.assertTrue(all(isinstance(v, str) for v in result_row.values()))\n \n     def test_csviter_delimiter(self):\n         body = get_testdata(\"feeds\", \"feed-sample3.csv\").replace(b\",\", b\"\\t\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#04ee3303e4487270a433f5c3a087bda9a87d7008", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 30 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 11/7 | Churn Δ: 32 | Churn Cumulative: 8968 | Contributors (this commit): 50 | Commits (past 90d): 9 | Contributors (cumulative): 84 | DMM Complexity: 0.9583333333333334\n\nDIFF:\n@@ -382,7 +382,9 @@ class FeedExporter:\n                 category=ScrapyDeprecationWarning,\n                 stacklevel=2,\n             )\n-            uri = str(self.settings[\"FEED_URI\"])  # handle pathlib.Path objects\n+            uri = self.settings[\"FEED_URI\"]\n+            # handle pathlib.Path objects\n+            uri = str(uri) if not isinstance(uri, Path) else uri.absolute().as_uri()\n             feed_options = {\"format\": self.settings.get(\"FEED_FORMAT\", \"jsonlines\")}\n             self.feeds[uri] = feed_complete_default_values_from_settings(\n                 feed_options, self.settings\n@@ -392,7 +394,8 @@ class FeedExporter:\n \n         # 'FEEDS' setting takes precedence over 'FEED_URI'\n         for uri, feed_options in self.settings.getdict(\"FEEDS\").items():\n-            uri = str(uri)  # handle pathlib.Path objects\n+            # handle pathlib.Path objects\n+            uri = str(uri) if not isinstance(uri, Path) else uri.absolute().as_uri()\n             self.feeds[uri] = feed_complete_default_values_from_settings(\n                 feed_options, self.settings\n             )\n\n@@ -2758,6 +2758,31 @@ class FeedExportInitTest(unittest.TestCase):\n         with self.assertRaises(NotConfigured):\n             FeedExporter.from_crawler(crawler)\n \n+    def test_absolute_pathlib_as_uri(self):\n+        with tempfile.NamedTemporaryFile(suffix=\"json\") as tmp:\n+            settings = {\n+                \"FEEDS\": {\n+                    Path(tmp.name).resolve(): {\n+                        \"format\": \"json\",\n+                    },\n+                },\n+            }\n+            crawler = get_crawler(settings_dict=settings)\n+            exporter = FeedExporter.from_crawler(crawler)\n+            self.assertIsInstance(exporter, FeedExporter)\n+\n+    def test_relative_pathlib_as_uri(self):\n+        settings = {\n+            \"FEEDS\": {\n+                Path(\"./items.json\"): {\n+                    \"format\": \"json\",\n+                },\n+            },\n+        }\n+        crawler = get_crawler(settings_dict=settings)\n+        exporter = FeedExporter.from_crawler(crawler)\n+        self.assertIsInstance(exporter, FeedExporter)\n+\n \n class StdoutFeedStorageWithoutFeedOptions(StdoutFeedStorage):\n     def __init__(self, uri):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#e71d6d67e56e35642fddc226e34e4d523041ad17", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): -4/0 | Churn Δ: 4 | Churn Cumulative: 1752 | Contributors (this commit): 41 | Commits (past 90d): 6 | Contributors (cumulative): 41 | DMM Complexity: None\n\nDIFF:\n@@ -439,10 +439,10 @@ class FeedExporter:\n             return slot_.file\n \n         if slot.itemcount:\n-            # Nomal case\n+            # Normal case\n             slot.finish_exporting()\n         elif slot.store_empty and slot.batch_id == 1:\n-            # Need Store Empty\n+            # Need to store the empty file\n             slot.start_exporting()\n             slot.finish_exporting()\n         else:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#080b9bd0b8f65dcf09ea8ad94505fec6c77f820c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 27 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 4/3 | Churn Δ: 27 | Churn Cumulative: 2147 | Contributors (this commit): 25 | Commits (past 90d): 2 | Contributors (cumulative): 37 | DMM Complexity: 1.0\n\nDIFF:\n@@ -75,6 +75,8 @@ class BaseSettings(MutableMapping):\n     highest priority will be retrieved.\n     \"\"\"\n \n+    __default = object()\n+\n     def __init__(self, values=None, priority=\"project\"):\n         self.frozen = False\n         self.attributes = {}\n@@ -445,6 +447,18 @@ class BaseSettings(MutableMapping):\n         else:\n             p.text(pformat(self.copy_to_dict()))\n \n+    def pop(self, name, default=__default):\n+        try:\n+            value = self.attributes[name]\n+        except KeyError:\n+            if default is self.__default:\n+                raise\n+\n+            return SettingsAttribute(default, get_settings_priority(\"project\"))\n+        else:\n+            del self.attributes[name]\n+            return value\n+\n \n class Settings(BaseSettings):\n     \"\"\"\n\n@@ -451,6 +451,19 @@ class SettingsTest(unittest.TestCase):\n         self.assertIsInstance(myhandler_instance, FileDownloadHandler)\n         self.assertTrue(hasattr(myhandler_instance, \"download_request\"))\n \n+    def test_pop_item_with_default_value(self):\n+        settings = Settings()\n+\n+        with self.assertRaises(KeyError):\n+            settings.pop(\"DUMMY_CONFIG\")\n+\n+        dummy_config = settings.pop(\"DUMMY_CONFIG\", \"dummy_value\")\n+\n+        self.assertEqual(\n+            repr(dummy_config), \"<SettingsAttribute value='dummy_value' priority=20>\"\n+        )\n+        self.assertEqual(dummy_config.value, \"dummy_value\")\n+\n \n if __name__ == \"__main__\":\n     unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#876feaf339e181c9c5a6b9a5f8ffedc03a9ed3d2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 17 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 18 | Churn Cumulative: 2165 | Contributors (this commit): 25 | Commits (past 90d): 4 | Contributors (cumulative): 37 | DMM Complexity: 1.0\n\nDIFF:\n@@ -456,7 +456,7 @@ class BaseSettings(MutableMapping):\n \n             return SettingsAttribute(default, get_settings_priority(\"project\"))\n         else:\n-            del self.attributes[name]\n+            self.__delitem__(name)\n             return value\n \n \n\n@@ -464,6 +464,22 @@ class SettingsTest(unittest.TestCase):\n         )\n         self.assertEqual(dummy_config.value, \"dummy_value\")\n \n+    def test_pop_item_with_frozen_settings(self):\n+        settings = Settings(\n+            {\"DUMMY_CONFIG\": \"dummy_value\", \"OTHER_DUMMY_CONFIG\": \"other_dummy_value\"}\n+        )\n+\n+        self.assertEqual(settings.pop(\"DUMMY_CONFIG\").value, \"dummy_value\")\n+\n+        settings.freeze()\n+\n+        with self.assertRaises(TypeError) as error:\n+            settings.pop(\"OTHER_DUMMY_CONFIG\")\n+\n+        self.assertEqual(\n+            str(error.exception), \"Trying to modify an immutable Settings object\"\n+        )\n+\n \n if __name__ == \"__main__\":\n     unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#a3f8912d69eacdd2208617e6afb418e4e1847e36", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 1065 | Contributors (this commit): 14 | Commits (past 90d): 3 | Contributors (cumulative): 14 | DMM Complexity: None\n\nDIFF:\n@@ -464,7 +464,7 @@ class SettingsTest(unittest.TestCase):\n         )\n         self.assertEqual(dummy_config.value, \"dummy_value\")\n \n-    def test_pop_item_with_frozen_settings(self):\n+    def test_pop_item_with_immutable_settings(self):\n         settings = Settings(\n             {\"DUMMY_CONFIG\": \"dummy_value\", \"OTHER_DUMMY_CONFIG\": \"other_dummy_value\"}\n         )\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#2ce4856508f7092368349c0ebf296dd1391a229a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 67 | Lines Deleted: 22 | Files Changed: 2 | Hunks: 8 | Methods Changed: 3 | Complexity Δ (Sum/Max): -3/1 | Churn Δ: 89 | Churn Cumulative: 183 | Contributors (this commit): 1 | Commits (past 90d): 5 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -39,29 +39,16 @@ class PeriodicLog:\n         interval = crawler.settings.getfloat(\"LOGSTATS_INTERVAL\")\n         try:\n             ext_stats = crawler.settings.getdict(\"PERIODIC_LOG_STATS\")\n-        except ValueError:\n+        except (TypeError, ValueError):\n             ext_stats = (\n                 {\"enabled\": True}\n                 if crawler.settings.getbool(\"PERIODIC_LOG_STATS\")\n                 else None\n             )\n-        except TypeError:\n-            ext_stats = (\n-                {\"enabled\": True}\n-                if crawler.settings.getbool(\"PERIODIC_LOG_STATS\")\n-                else None\n-            )\n-\n         try:\n             ext_delta = crawler.settings.getdict(\"PERIODIC_LOG_DELTA\")\n-        except ValueError:\n+        except (TypeError, ValueError):\n             ext_delta = (\n-                {\"enabled\": True}\n-                if crawler.settings.getdict(\"PERIODIC_LOG_DELTA\")\n-                else None\n-            )\n-        except TypeError:\n-            ext_stats = (\n                 {\"enabled\": True}\n                 if crawler.settings.getbool(\"PERIODIC_LOG_DELTA\")\n                 else None\n\n@@ -51,20 +51,78 @@ stats_dump_2 = {\n }\n \n \n-class TestPeriodicLog(unittest.TestCase):\n-    def test_extension_enabled(self):\n-        extension = PeriodicLog.from_crawler(\n+def extension(settings=None):\n+    return PeriodicLog.from_crawler(\n         Crawler(\n             MetaSpider,\n-                settings={\"PERIODIC_LOG_STATS\": True, \"LOGSTATS_INTERVAL\": 60},\n+            settings=settings,\n         )\n     )\n-        # Test enabled\n-        assert extension\n+\n+\n+class TestPeriodicLog(unittest.TestCase):\n+    def test_extension_enabled(self):\n+        # Expected that settings for this extension loaded succesfully\n+        # And on certain conditions - extension raising NotConfigured\n+\n+        # \"PERIODIC_LOG_STATS\": True -> set to {\"enabled\": True}\n+        # due to TypeError exception from settings.getdict\n+        assert extension({\"PERIODIC_LOG_STATS\": True, \"LOGSTATS_INTERVAL\": 60})\n+\n+        # \"PERIODIC_LOG_STATS\": \"True\" -> set to {\"enabled\": True}\n+        # due to JSONDecodeError(ValueError) exception from settings.getdict\n+        assert extension({\"PERIODIC_LOG_STATS\": \"True\", \"LOGSTATS_INTERVAL\": 60})\n+\n+        # The ame for PERIODIC_LOG_DELTA:\n+        assert extension({\"PERIODIC_LOG_DELTA\": True, \"LOGSTATS_INTERVAL\": 60})\n+        assert extension({\"PERIODIC_LOG_DELTA\": \"True\", \"LOGSTATS_INTERVAL\": 60})\n \n         # Raise not configured if not set by settings\n         with self.assertRaises(NotConfigured):\n-            PeriodicLog.from_crawler(Crawler(MetaSpider))\n+            extension()\n+\n+        # Regular use cases:\n+        assert extension(\n+            {\n+                \"PERIODIC_LOG_STATS\": {\n+                    \"include\": [\n+                        \"downloader/\",\n+                        \"scheduler/\",\n+                        \"log_count/\",\n+                        \"item_scraped_count/\",\n+                    ],\n+                    \"exclude\": [\"scheduler/\"],\n+                }\n+            }\n+        )\n+\n+        assert extension(\n+            {\n+                \"PERIODIC_LOG_DELTA\": {\"include\": [\"downloader/\"]},\n+                \"PERIODIC_LOG_TIMING_ENABLED\": True,\n+            }\n+        )\n+\n+        assert extension(\n+            {\n+                \"PERIODIC_LOG_TIMING_ENABLED\": True,\n+            }\n+        )\n+\n+        assert extension(\n+            {\n+                \"PERIODIC_LOG_STATS\": {\n+                    \"include\": [\n+                        \"downloader/\",\n+                        \"scheduler/\",\n+                        \"log_count/\",\n+                        \"item_scraped_count/\",\n+                    ],\n+                    \"exclude\": [\"scheduler/\"],\n+                },\n+                \"PERIODIC_LOG_DELTA\": {\"include\": [\"downloader/\"]},\n+            }\n+        )\n \n     def test_periodic_log_stats(self):\n         pass\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#e7124447f7e86ee93ad78ffd0ebfa6acbebc73ce", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 121 | Lines Deleted: 807 | Files Changed: 15 | Hunks: 61 | Methods Changed: 83 | Complexity Δ (Sum/Max): -87/8 | Churn Δ: 928 | Churn Cumulative: 10236 | Contributors (this commit): 73 | Commits (past 90d): 51 | Contributors (cumulative): 203 | DMM Complexity: 0.14832535885167464\n\nDIFF:\n@@ -1,108 +1,27 @@\n-import warnings\n-from collections import OrderedDict, defaultdict\n from collections.abc import Mapping\n-from inspect import isclass\n-from typing import Dict\n+from typing import Any, Dict, Iterator, Optional, OrderedDict\n \n-import zope.interface\n-from packaging.requirements import Requirement\n-from packaging.version import Version\n-from zope.interface.verify import verifyObject\n-\n-from scrapy.interfaces import IAddon\n from scrapy.utils.conf import build_component_list\n-from scrapy.utils.misc import load_module_or_object\n+from scrapy.utils.misc import load_object\n \n \n-@zope.interface.implementer(IAddon)\n class Addon(object):\n-    basic_settings = None\n-    \"\"\"``dict`` of settings that will be exported via :meth:`export_basics`.\"\"\"\n+    name: str\n \n     default_config = None\n     \"\"\"``dict`` with default configuration.\"\"\"\n \n     config_mapping = None\n     \"\"\"``dict`` with mappings from config names to setting names. The given\n-    setting names will be taken as given, i.e. they will be neither prefixed\n-    nor uppercased.\n+    setting names will be taken as given, not uppercased.\n     \"\"\"\n \n-    component_type = None\n-    \"\"\"Component setting into which to export via :meth:`export_component`. Can\n-    be any of the dictionary-like component setting names. If ``None``,\n-    :meth:`export_component` will do nothing.\n-    \"\"\"\n-\n-    component_key = None\n-    \"\"\"Key to be used in the component dictionary setting when exporting via\n-    :meth:`export_component`. This is only useful for the settings that have\n-    no order, e.g. ``DOWNLOAD_HANDLERS`` or ``FEED_EXPORTERS``.\n-    \"\"\"\n-\n-    component_order = 0\n-    \"\"\"Component order to use when not given in the add-on configuration. Has\n-    no effect for component types that use :attr:`component_key`.\n-    \"\"\"\n-\n-    component = None\n-    \"\"\"Component to be inserted via :meth:`export_component`. This can be\n-    anything that can be used in the dictionary-like component settings, i.e.\n-    a class path or a class. If ``None``, it is assumed that the add-on itself\n-    also provides the component interface, and ``self`` will be used.\n-    \"\"\"\n-\n-    settings_prefix = None\n-    \"\"\"Prefix with which the add-on configuration will be exported into the\n-    global settings namespace via :meth:`export_config`. If ``None``,\n-    :attr:`name` will be used. If ``False``, no configuration will be exported.\n-    \"\"\"\n-\n-    def export_component(self, config, settings):\n-        \"\"\"Export the component in :attr:`component` into the dictionary-like\n-        component setting derived from :attr:`component_type`.\n-\n-        Where applicable, the order parameter of the component (i.e. the\n-        dictionary value) will be retrieved from the ``order`` add-on\n-        configuration value.\n-\n-        :param config: Add-on configuration from which to read component order\n-        :type config: ``dict``\n-\n-        :param settings: Settings object into which to export component\n-        :type settings: :class:`~scrapy.settings.Settings`\n-        \"\"\"\n-        if self.component_type:\n-            comp = self.component or self\n-            if self.component_key:\n-                # e.g. for DOWNLOAD_HANDLERS: {'http': 'myclass'}\n-                k = self.component_key\n-                v = comp\n-            else:\n-                # e.g. for DOWNLOADER_MIDDLEWARES: {'myclass': 100}\n-                k = comp\n-                v = config.get(\"order\", self.component_order)\n-            settings[self.component_type].update({k: v}, \"addon\")\n-\n-    def export_basics(self, settings):\n-        \"\"\"Export the :attr:`basic_settings` attribute into the settings object.\n-\n-        All settings will be exported with ``addon`` priority (see\n-        :ref:`topics-api-settings`).\n-\n-        :param settings: Settings object into which to expose the basic settings\n-        :type settings: :class:`~scrapy.settings.Settings`\n-        \"\"\"\n-        for setting, value in (self.basic_settings or {}).items():\n-            settings.set(setting, value, \"addon\")\n-\n     def export_config(self, config, settings):\n-        \"\"\"Export the add-on configuration, all keys in caps and with\n-        :attr:`settings_prefix` or :attr:`name` prepended, into the settings\n+        \"\"\"Export the add-on configuration, all keys in caps, into the settings\n         object.\n \n         For example, the add-on configuration ``{'key': 'value'}`` will export\n-        the setting ``ADDONNAME_KEY`` with a value of ``value``. All settings\n+        the setting ``KEY`` with a value of ``value``. All settings\n         will be exported with ``addon`` priority (see\n         :ref:`topics-api-settings`).\n \n@@ -112,11 +31,8 @@ class Addon(object):\n         :param settings: Settings object into which to export the configuration\n         :type settings: :class:`~scrapy.settings.Settings`\n         \"\"\"\n-        if self.settings_prefix is False:\n-            return\n         conf = self.default_config or {}\n         conf.update(config)\n-        prefix = self.settings_prefix or self.name\n         # Since default exported config is case-insensitive (everything will be\n         # uppercased), make mapped config case-insensitive as well\n         conf_mapping = {k.lower(): v for k, v in (self.config_mapping or {}).items()}\n@@ -124,14 +40,11 @@ class Addon(object):\n             if key.lower() in conf_mapping:\n                 key = conf_mapping[key.lower()]\n             else:\n-                key = (prefix + \"_\" + key).upper()\n+                key = key.upper()\n             settings.set(key, val, \"addon\")\n \n     def update_settings(self, config, settings):\n-        \"\"\"Export both the basic settings and the add-on configuration. I.e.,\n-        call :meth:`export_basics` and :meth:`export_config`.\n-\n-        For more advanced add-ons, you may want to override this callback.\n+        \"\"\"Modifiy `settings` to enable and configure required components.\n \n         :param config: Add-on configuration\n         :type config: ``dict``\n@@ -139,12 +52,21 @@ class Addon(object):\n         :param settings: Crawler settings object\n         :type settings: :class:`~scrapy.settings.Settings`\n         \"\"\"\n-        self.export_component(config, settings)\n-        self.export_basics(settings)\n         self.export_config(config, settings)\n \n+    def check_configuration(self, config, crawler):\n+        \"\"\"Perform post-initialization checks on fully configured `crawler`.\n \n-class AddonManager(Mapping):\n+        :param config: Add-on configuration\n+        :type config: ``dict``\n+\n+        :param crawler: the fully-initialized crawler\n+        :type crawler: :class:`~scrapy.crawler.Crawler`\n+        \"\"\"\n+        pass\n+\n+\n+class AddonManager(Mapping[str, Addon]):\n     \"\"\"This class facilitates loading and storing :ref:`topics-addons`.\n \n     You can treat it like a read-only dictionary in which keys correspond to\n@@ -160,108 +82,42 @@ class AddonManager(Mapping):\n \n     \"\"\"\n \n-    def __init__(self):\n-        self._addons = OrderedDict()\n-        self.configs = {}\n-        self._disable_on_add = []\n+    def __init__(self) -> None:\n+        self._addons: OrderedDict[str, Addon] = OrderedDict[str, Addon]()\n+        self.configs: Dict[str, Dict[str, Any]] = {}\n \n-    def __getitem__(self, name):\n+    def __getitem__(self, name: str) -> Addon:\n         return self._addons[name]\n \n-    def __delitem__(self, name):\n-        del self._addons[name]\n-        del self.configs[name]\n-\n-    def __iter__(self):\n+    def __iter__(self) -> Iterator[str]:\n         return iter(self._addons)\n \n-    def __len__(self):\n+    def __len__(self) -> int:\n         return len(self._addons)\n \n-    def add(self, addon, config=None):\n+    def add(self, addon: Any, config: Optional[Dict[str, Any]] = None):\n         \"\"\"Store an add-on.\n \n-        If ``addon`` is a string, it will be treated as add-on path and passed\n-        to :meth:`get_addon`. Otherwise, ``addon`` must be a Python object\n-        implementing or providing Scrapy's add-on interface. The interface\n-        will be enforced through ``zope.interface``'s ``verifyObject()``.\n-\n-        If ``addon`` is a class, it will be instantiated. You can avoid this\n-        (for example if you have implemented the add-on callbacks as class\n-        methods) by declaring --  via ``zope.interface`` -- that your class\n-        directly *provides* ``scrapy.interfaces.IAddon``.\n-\n         :param addon: The add-on object (or path) to be stored\n-        :type addon: Any Python object providing the add-on interface or ``str``\n+        :type addon: Python object, class or ``str``\n \n         :param config: The add-on configuration dictionary\n         :type config: ``dict``\n         \"\"\"\n-        addon = self.get_addon(addon)\n-        if isclass(addon) and not IAddon.providedBy(addon):\n+        if isinstance(addon, (type, str)):\n+            addon = load_object(addon)\n+        if isinstance(addon, type):\n             addon = addon()\n-        if not IAddon.providedBy(addon):\n-            zope.interface.alsoProvides(addon, IAddon)\n-        # zope.interface's exceptions are already quite helpful. Still, should\n-        # we catch them and log an error message?\n-        verifyObject(IAddon, addon)\n         name = addon.name\n         if name in self:\n             raise ValueError(f\"Addon '{name}' already loaded\")\n         self._addons[name] = addon\n         self.configs[name] = config or {}\n-        if name in self._disable_on_add:\n-            self.configs[name][\"_enabled\"] = False\n-            self._disable_on_add.remove(name)\n-\n-    def remove(self, addon):\n-        \"\"\"Remove an add-on.\n-\n-        If ``addon`` is the name of a stored add-on, that add-on will be\n-        removed. Otherwise, you can use the argument in the same fashion as\n-        in :meth:`add`.\n-\n-        :param addon: The add-on name, object, or path to be removed\n-        :type addon: Any Python object providing the add-on interface or ``str``\n-        \"\"\"\n-        if addon in self:\n-            del self[addon]\n-        elif hasattr(addon, \"name\") and addon.name in self:\n-            del self[addon.name]\n-        else:\n-            try:\n-                del self[self.get_addon(addon).name]\n-            except NameError:\n-                raise KeyError\n-\n-    @staticmethod\n-    def get_addon(path):\n-        \"\"\"Get an add-on object by its Python or file path.\n-\n-        ``path`` is assumed to be an import path of an add-on. If the object or\n-        module pointed to by ``path`` has an attribute named ``_addon`` that\n-        attribute will be assumed to be the add-on. :meth:`get_addon` will keep\n-        following ``_addon`` attributes until it finds an object that does not\n-        have an attribute named ``_addon``.\n-\n-        :param path: Import path of an add-on\n-        :type path: ``str``\n-        \"\"\"\n-        if isinstance(path, str):\n-            try:\n-                obj = load_module_or_object(path)\n-            except NameError:\n-                raise NameError(f\"Could not find add-on '{path}'\")\n-        else:\n-            obj = path\n-        if hasattr(obj, \"_addon\"):\n-            obj = AddonManager.get_addon(obj._addon)\n-        return obj\n \n     def load_settings(self, settings):\n         \"\"\"Load add-ons and configurations from settings object.\n \n-        This will invoke :meth:`get_addon` for every add-on path in the\n+        This will load the addon for every add-on path in the\n         ``ADDONS`` setting. For each of these add-ons, the configuration will be\n         read from the dictionary setting whose name matches the uppercase add-on\n         name.\n@@ -271,141 +127,12 @@ class AddonManager(Mapping):\n         :type settings: :class:`~scrapy.settings.Settings`\n         \"\"\"\n         paths = build_component_list(settings[\"ADDONS\"])\n-        addons = [self.get_addon(path) for path in paths]\n+        addons = [load_object(path) for path in paths]\n         configs = [settings.getdict(addon.name.upper()) for addon in addons]\n         for a, c in zip(addons, configs):\n             self.add(a, c)\n \n-    def check_dependency_clashes(self) -> None:\n-        \"\"\"Check for incompatibilities in add-on dependencies.\n-\n-        Add-ons can provide information about their dependencies in their\n-        ``provides``, ``modifies`` and ``requires`` attributes. This method will\n-        raise an ``ImportError`` if\n-\n-        * a component required by an add-on is not provided by any other add-on,\n-          or\n-        * a component modified by an add-on is not provided by any other add-on,\n-          or\n-        * the same component is provided by more than one add-on,\n-\n-        and warn when a component required by an add-on is modified by any other\n-        add-on.\n-        \"\"\"\n-        # Collect all active add-ons and the components they provide\n-        versions: Dict[str, Version] = {}\n-\n-        def add_version(project_name, version):\n-            if project_name in versions:\n-                raise ImportError(\n-                    f\"Component {project_name} provided by multiple add-ons\"\n-                )\n-            versions[project_name] = Version(version)\n-\n-        for name in self:\n-            ver = self[name].version\n-            add_version(name, ver)\n-            for provides_name in getattr(self[name], \"provides\", []):\n-                add_version(provides_name, ver)\n-\n-        # Collect all required and modified components\n-        def compile_attribute_dict(attribute_name):\n-            attrs = defaultdict(list)\n-            for name in self:\n-                for entry in getattr(self[name], attribute_name, []):\n-                    attrs[entry].append(name)\n-            return attrs\n-\n-        modified = compile_attribute_dict(\"modifies\")\n-        required = compile_attribute_dict(\"requires\")\n-\n-        req_or_mod = set(required.keys()).union(modified.keys())\n-        for reqstr in req_or_mod:\n-            req = Requirement(reqstr)\n-            if req.name not in versions or versions[req.name] not in req.specifier:\n-                raise ImportError(\n-                    f\"Add-ons {required[reqstr] + modified[reqstr]} require\"\n-                    f\" or modify missing component {reqstr}\"\n-                )\n-\n-        mod_and_req = set(required.keys()).intersection(modified.keys())\n-        for conflict in mod_and_req:\n-            warnings.warn(\n-                f\"Component '{conflict}', required by add-ons {required[conflict]},\"\n-                f\" is modified by add-ons {modified[conflict]}\"\n-            )\n-\n-    def disable(self, addon):\n-        \"\"\"Disable an add-on, i.e. prevent its callbacks from being called.\n-\n-        If you disable an add-on before it is loaded, it will be disabled as\n-        soon as it is added to the :class:`AddonManager`.\n-\n-        :param addon: Name of the add-on to be disabled\n-        :type addon: ``str``\n-        \"\"\"\n-        if addon in self:\n-            self.configs[addon][\"_enabled\"] = False\n-        else:\n-            self._disable_on_add.append(addon)\n-\n-    def enable(self, addon):\n-        \"\"\"Re-enable a disabled add-on.\n-\n-        Will raise ``ValueError`` if the add-on is neither already loaded nor\n-        marked for being disabled on adding.\n-\n-        :param addon: Name of the add-on to be enabled\n-        :type addon: ``str``\n-        \"\"\"\n-        if addon in self:\n-            self.configs[addon][\"_enabled\"] = True\n-        elif addon in self._disable_on_add:\n-            self._disable_on_add.remove(addon)\n-        else:\n-            raise ValueError(\"Add-ons need to be added before they can be enabled\")\n-\n-    @property\n-    def disabled(self):\n-        \"\"\"Names of disabled add-ons\"\"\"\n-        return [\n-            a for a in self if not self.configs[a].get(\"_enabled\", True)\n-        ] + self._disable_on_add\n-\n-    @property\n-    def enabled(self):\n-        \"\"\"Names of enabled add-ons\"\"\"\n-        return [a for a in self if self.configs[a].get(\"_enabled\", True)]\n-\n-    def _call_if_exists(self, obj, cbname, *args, **kwargs):\n-        if obj is None:\n-            return\n-        try:\n-            cb = getattr(obj, cbname)\n-        except AttributeError:\n-            return\n-        else:\n-            cb(*args, **kwargs)\n-\n-    def _call_addon(self, addonname, cbname, *args, **kwargs):\n-        if self.configs[addonname].get(\"_enabled\", True):\n-            self._call_if_exists(\n-                self[addonname], cbname, self.configs[addonname], *args, **kwargs\n-            )\n-\n-    def update_addons(self):\n-        \"\"\"Call ``update_addons()`` of all held add-ons.\n-\n-        This will also call ``update_addons()`` of all add-ons that are added\n-        last minute during the ``update_addons()`` routine of other add-ons.\n-        \"\"\"\n-        called_addons = set()\n-        while called_addons != set(self):\n-            for name in set(self).difference(called_addons):\n-                called_addons.add(name)\n-                self._call_addon(name, \"update_addons\", self)\n-\n-    def update_settings(self, settings):\n+    def update_settings(self, settings) -> None:\n         \"\"\"Call ``update_settings()`` of all held add-ons.\n \n         :param settings: The :class:`~scrapy.settings.Settings` object to be \\\n@@ -413,13 +140,13 @@ class AddonManager(Mapping):\n         :type settings: :class:`~scrapy.settings.Settings`\n         \"\"\"\n         for name in self:\n-            self._call_addon(name, \"update_settings\", settings)\n+            self[name].update_settings(self.configs[name], settings)\n \n-    def check_configuration(self, crawler):\n+    def check_configuration(self, crawler) -> None:\n         \"\"\"Call ``check_configuration()`` of all held add-ons.\n \n         :param crawler: the fully-initialized crawler\n         :type crawler: :class:`~scrapy.crawler.Crawler`\n         \"\"\"\n         for name in self:\n-            self._call_addon(name, \"check_configuration\", crawler)\n+            self[name].check_configuration(self.configs[name], crawler)\n\n@@ -6,7 +6,6 @@ import sys\n from importlib.metadata import entry_points\n \n import scrapy\n-from scrapy.addons import AddonManager\n from scrapy.commands import BaseRunSpiderCommand, ScrapyCommand, ScrapyHelpFormatter\n from scrapy.crawler import CrawlerProcess\n from scrapy.exceptions import UsageError\n@@ -131,8 +130,6 @@ def execute(argv=None, settings=None):\n         else:\n             settings[\"EDITOR\"] = editor\n \n-    addons = AddonManager()\n-\n     inproject = inside_project()\n     cmds = _get_commands_dict(settings, inproject)\n     cmdname = _pop_command_name(argv)\n@@ -156,7 +153,7 @@ def execute(argv=None, settings=None):\n     opts, args = parser.parse_known_args(args=argv[1:])\n     _run_print_help(parser, cmd.process_options, args, opts)\n \n-    cmd.crawler_process = CrawlerProcess(settings, addons=addons)\n+    cmd.crawler_process = CrawlerProcess(settings)\n     _run_print_help(parser, _run_command, cmd, args, opts)\n     sys.exit(cmd.exitcode)\n \n\n@@ -58,7 +58,6 @@ class Crawler:\n         spidercls: Type[Spider],\n         settings: Union[None, dict, Settings] = None,\n         init_reactor: bool = False,\n-        addons: Optional[AddonManager] = None,\n     ):\n         if isinstance(spidercls, Spider):\n             raise ValueError(\"The spidercls argument must be a class, not an object\")\n@@ -70,10 +69,8 @@ class Crawler:\n         self.settings: Settings = settings.copy()\n         self.spidercls.update_settings(self.settings)\n \n-        self.addons: AddonManager = addons if addons is not None else AddonManager()\n+        self.addons: AddonManager = AddonManager()\n         self.addons.load_settings(self.settings)\n-        self.addons.update_addons()\n-        self.addons.check_dependency_clashes()\n         self.addons.update_settings(self.settings)\n \n         self.signals: SignalManager = SignalManager(self)\n@@ -200,15 +197,10 @@ class CrawlerRunner:\n             )\n         return loader_cls.from_settings(settings.frozencopy())\n \n-    def __init__(\n-        self,\n-        settings: Union[Dict[str, Any], Settings, None] = None,\n-        addons: Optional[AddonManager] = None,\n-    ):\n+    def __init__(self, settings: Union[Dict[str, Any], Settings, None] = None):\n         if isinstance(settings, dict) or settings is None:\n             settings = Settings(settings)\n         self.settings = settings\n-        self.addons: Optional[AddonManager] = addons\n         self.spider_loader = self._get_spider_loader(settings)\n         self._crawlers: Set[Crawler] = set()\n         self._active: Set[defer.Deferred] = set()\n@@ -292,7 +284,7 @@ class CrawlerRunner:\n     def _create_crawler(self, spidercls: Union[str, Type[Spider]]) -> Crawler:\n         if isinstance(spidercls, str):\n             spidercls = self.spider_loader.load(spidercls)\n-        return Crawler(spidercls, self.settings, addons=self.addons)\n+        return Crawler(spidercls, self.settings)\n \n     def stop(self):\n         \"\"\"\n@@ -338,13 +330,8 @@ class CrawlerProcess(CrawlerRunner):\n     process. See :ref:`run-from-script` for an example.\n     \"\"\"\n \n-    def __init__(\n-        self,\n-        settings=None,\n-        install_root_handler: bool = True,\n-        addons: Optional[AddonManager] = None,\n-    ):\n-        super().__init__(settings, addons)\n+    def __init__(self, settings=None, install_root_handler=True):\n+        super().__init__(settings)\n         configure_logging(self.settings, install_root_handler)\n         log_scrapy_info(self.settings)\n         self._initialized_reactor = False\n\n@@ -1,4 +1,4 @@\n-from zope.interface import Attribute, Interface\n+from zope.interface import Interface\n \n \n class ISpiderLoader(Interface):\n@@ -15,22 +15,3 @@ class ISpiderLoader(Interface):\n \n     def find_by_request(request):\n         \"\"\"Return the list of spiders names that can handle the given request\"\"\"\n-\n-\n-class IAddon(Interface):\n-    \"\"\"Scrapy add-on\"\"\"\n-\n-    name = Attribute(\"\"\"Add-on name\"\"\")\n-    version = Attribute(\"\"\"Add-on version string (PEP440)\"\"\")\n-\n-    # XXX: Can methods be declared optional? I.e., can I enforce the signature\n-    #      but not the existence of a method?\n-\n-    # def update_addons(config, addons):\n-    #    \"\"\"Enables and configures other add-ons\"\"\"\n-\n-    # def update_settings(config, settings):\n-    #    \"\"\"Modifies `settings` to enable and configure required components\"\"\"\n-\n-    # def check_configuration(config, crawler):\n-    #    \"\"\"Performs post-initialization checks on fully configured `crawler`\"\"\"\n\n@@ -99,18 +99,12 @@ def init_env(project=\"default\", set_syspath=True):\n             sys.path.append(projdir)\n \n \n-def config_from_filepath(sources):\n-    \"\"\"Create a ConfigParser and read in the given `sources`, which can be\n-    either a filename or a list of filenames.\"\"\"\n-    cfg = ConfigParser()\n-    cfg.read(sources)\n-    return cfg\n-\n-\n def get_config(use_closest=True):\n     \"\"\"Get Scrapy config file as a ConfigParser\"\"\"\n     sources = get_sources(use_closest)\n-    return config_from_filepath(sources)\n+    cfg = ConfigParser()\n+    cfg.read(sources)\n+    return cfg\n \n \n def get_sources(use_closest=True) -> List[str]:\n\n@@ -67,7 +67,7 @@ def load_object(path: Union[str, Callable]) -> Any:\n         if callable(path):\n             return path\n         raise TypeError(\n-            \"Unexpected argument type, expected string \" f\"or object, got: {type(path)}\"\n+            f\"Unexpected argument type, expected string or object, got: {type(path)}\"\n         )\n \n     try:\n@@ -86,22 +86,6 @@ def load_object(path: Union[str, Callable]) -> Any:\n     return obj\n \n \n-def load_module_or_object(path):\n-    \"\"\"Load python module or (non-module) object from given path.\n-\n-    Path can be both a Python or a file path.\n-    \"\"\"\n-    try:\n-        return import_module(path)\n-    except ImportError:\n-        pass\n-    try:\n-        return load_object(path)\n-    except (ValueError, NameError, ImportError):\n-        pass\n-    raise NameError(f\"Could not load '{path}'\")\n-\n-\n def walk_modules(path: str) -> List[ModuleType]:\n     \"\"\"Loads a module and all its submodules from the given module path and\n     returns them. If *any* module throws an exception while importing, that\n\n@@ -73,7 +73,6 @@ def get_crawler(\n     spidercls: Optional[Type[Spider]] = None,\n     settings_dict: Optional[Dict[str, Any]] = None,\n     prevent_warnings: bool = True,\n-    addons=None,\n ) -> Crawler:\n     \"\"\"Return an unconfigured Crawler object. If settings_dict is given, it\n     will be used to populate the crawler settings with a project level\n@@ -87,7 +86,7 @@ def get_crawler(\n     if prevent_warnings:\n         settings[\"REQUEST_FINGERPRINTER_IMPLEMENTATION\"] = \"2.7\"\n     settings.update(settings_dict or {})\n-    runner = CrawlerRunner(settings, addons)\n+    runner = CrawlerRunner(settings)\n     return runner.create_crawler(spidercls or Spider)\n \n \n\n@@ -0,0 +1,72 @@\n+import unittest\n+\n+from scrapy.addons import Addon, AddonManager\n+from scrapy.settings import BaseSettings\n+\n+\n+class GoodAddon(object):\n+    name = \"GoodAddon\"\n+\n+    def update_settings(self, config, settings):\n+        pass\n+\n+    def check_configuration(self, config, crawler):\n+        pass\n+\n+\n+class AddonTest(unittest.TestCase):\n+    def setUp(self):\n+        class AddonWithAttributes(Addon):\n+            name = \"Test\"\n+\n+        self.testaddon = AddonWithAttributes()\n+\n+    def test_export_config(self):\n+        settings = BaseSettings()\n+        self.testaddon.config_mapping = {\"MAPPED_key\": \"MAPPING_WORKED\"}\n+        self.testaddon.default_config = {\"key\": 55, \"defaultkey\": 100}\n+        self.testaddon.export_config(\n+            {\"key\": 313, \"OTHERKEY\": True, \"mapped_KEY\": 99}, settings\n+        )\n+        self.assertEqual(settings[\"KEY\"], 313)\n+        self.assertEqual(settings[\"DEFAULTKEY\"], 100)\n+        self.assertEqual(settings[\"OTHERKEY\"], True)\n+        self.assertNotIn(\"MAPPED_key\", settings)\n+        self.assertNotIn(\"MAPPED_KEY\", settings)\n+        self.assertEqual(settings[\"MAPPING_WORKED\"], 99)\n+        self.assertEqual(settings.getpriority(\"KEY\"), 15)\n+\n+    def test_update_settings(self):\n+        settings = BaseSettings()\n+        settings.set(\"KEY1\", \"default\", priority=\"default\")\n+        settings.set(\"KEY2\", \"project\", priority=\"project\")\n+        addon_config = {\"key1\": \"addon\", \"key2\": \"addon\", \"key3\": \"addon\"}\n+        self.testaddon.update_settings(addon_config, settings)\n+        self.assertEqual(settings[\"KEY1\"], \"addon\")\n+        self.assertEqual(settings[\"KEY2\"], \"project\")\n+        self.assertEqual(settings[\"KEY3\"], \"addon\")\n+\n+\n+class AddonManagerTest(unittest.TestCase):\n+    def setUp(self):\n+        self.manager = AddonManager()\n+\n+    def test_add(self):\n+        manager = AddonManager()\n+        manager.add(\"tests.test_addons.GoodAddon\")\n+        self.assertCountEqual(manager, [\"GoodAddon\"])\n+        self.assertIsInstance(manager[\"GoodAddon\"], GoodAddon)\n+\n+    def test_load_settings(self):\n+        settings = BaseSettings()\n+        settings.set(\n+            \"ADDONS\",\n+            {\"tests.test_addons.GoodAddon\": 0},\n+        )\n+        settings.set(\"GOODADDON\", {\"key\": \"val2\"})\n+        manager = AddonManager()\n+        manager.load_settings(settings)\n+        self.assertCountEqual(manager, [\"GoodAddon\"])\n+        self.assertIsInstance(manager[\"GoodAddon\"], GoodAddon)\n+        self.assertCountEqual(manager.configs[\"GoodAddon\"], [\"key\"])\n+        self.assertEqual(manager.configs[\"GoodAddon\"][\"key\"], \"val2\")\n\n@@ -1,342 +0,0 @@\n-import itertools\n-import unittest\n-import warnings\n-from unittest import mock\n-\n-from zope.interface import directlyProvides\n-from zope.interface.exceptions import BrokenImplementation, MultipleInvalid\n-from zope.interface.verify import verifyObject\n-\n-from scrapy.addons import Addon, AddonManager\n-from scrapy.crawler import Crawler\n-from scrapy.interfaces import IAddon\n-from scrapy.settings import BaseSettings\n-\n-from . import addonmod, addons\n-\n-\n-class AddonTest(unittest.TestCase):\n-    def setUp(self):\n-        self.rawaddon = Addon()\n-\n-        class AddonWithAttributes(Addon):\n-            name = \"Test\"\n-            version = \"1.0\"\n-\n-        self.testaddon = AddonWithAttributes()\n-\n-    def test_interface(self):\n-        # Raw Addon should fail exactly b/c name and version are not given\n-        self.assertFalse(hasattr(self.rawaddon, \"name\"))\n-        self.assertFalse(hasattr(self.rawaddon, \"version\"))\n-        self.assertRaises(MultipleInvalid, verifyObject, IAddon, self.rawaddon)\n-        verifyObject(IAddon, self.testaddon)\n-\n-    def test_export_component(self):\n-        settings = BaseSettings(\n-            {\"ITEM_PIPELINES\": BaseSettings(), \"DOWNLOAD_HANDLERS\": BaseSettings()},\n-            \"default\",\n-        )\n-        self.testaddon.component_type = None\n-        self.testaddon.export_component({}, settings)\n-        self.assertEqual(len(settings[\"ITEM_PIPELINES\"]), 0)\n-        self.testaddon.component_type = \"ITEM_PIPELINES\"\n-        self.testaddon.component = \"test.component\"\n-        self.testaddon.export_component({}, settings)\n-        self.assertCountEqual(settings[\"ITEM_PIPELINES\"], [\"test.component\"])\n-        self.assertEqual(settings[\"ITEM_PIPELINES\"][\"test.component\"], 0)\n-        self.testaddon.component_order = 313\n-        self.testaddon.export_component({}, settings)\n-        self.assertEqual(settings[\"ITEM_PIPELINES\"][\"test.component\"], 313)\n-        self.testaddon.component_type = \"DOWNLOAD_HANDLERS\"\n-        self.testaddon.component_key = \"http\"\n-        self.testaddon.export_component({}, settings)\n-        self.assertEqual(settings[\"DOWNLOAD_HANDLERS\"][\"http\"], \"test.component\")\n-\n-    def test_export_basics(self):\n-        settings = BaseSettings()\n-        self.testaddon.basic_settings = {\"TESTKEY\": 313, \"OTHERKEY\": True}\n-        self.testaddon.export_basics(settings)\n-        self.assertEqual(settings[\"TESTKEY\"], 313)\n-        self.assertEqual(settings[\"OTHERKEY\"], True)\n-        self.assertEqual(settings.getpriority(\"TESTKEY\"), 15)\n-\n-    def test_export_config(self):\n-        settings = BaseSettings()\n-        self.testaddon.settings_prefix = None\n-        self.testaddon.config_mapping = {\"MAPPED_key\": \"MAPPING_WORKED\"}\n-        self.testaddon.default_config = {\"key\": 55, \"defaultkey\": 100}\n-        self.testaddon.export_config(\n-            {\"key\": 313, \"OTHERKEY\": True, \"mapped_KEY\": 99}, settings\n-        )\n-        self.assertEqual(settings[\"TEST_KEY\"], 313)\n-        self.assertEqual(settings[\"TEST_DEFAULTKEY\"], 100)\n-        self.assertEqual(settings[\"TEST_OTHERKEY\"], True)\n-        self.assertNotIn(\"MAPPED_key\", settings)\n-        self.assertNotIn(\"MAPPED_KEY\", settings)\n-        self.assertEqual(settings[\"MAPPING_WORKED\"], 99)\n-        self.assertEqual(settings.getpriority(\"TEST_KEY\"), 15)\n-\n-        self.testaddon.settings_prefix = \"PREF\"\n-        self.testaddon.export_config({\"newkey\": 99}, settings)\n-        self.assertEqual(settings[\"PREF_NEWKEY\"], 99)\n-\n-        with mock.patch.object(settings, \"set\") as mock_set:\n-            self.testaddon.settings_prefix = False\n-            self.testaddon.export_config({\"thirdnewkey\": 99}, settings)\n-            self.assertEqual(mock_set.call_count, 0)\n-\n-    def test_update_settings(self):\n-        settings = BaseSettings()\n-        settings.set(\"TEST_KEY1\", \"default\", priority=\"default\")\n-        settings.set(\"TEST_KEY2\", \"project\", priority=\"project\")\n-        self.testaddon.settings_prefix = None\n-        self.testaddon.basic_settings = {\"OTHERTEST_KEY\": \"addon\"}\n-        addon_config = {\"key1\": \"addon\", \"key2\": \"addon\", \"key3\": \"addon\"}\n-        self.testaddon.update_settings(addon_config, settings)\n-        self.assertEqual(settings[\"OTHERTEST_KEY\"], \"addon\")\n-        self.assertEqual(settings[\"TEST_KEY1\"], \"addon\")\n-        self.assertEqual(settings[\"TEST_KEY2\"], \"project\")\n-        self.assertEqual(settings[\"TEST_KEY3\"], \"addon\")\n-\n-\n-class AddonManagerTest(unittest.TestCase):\n-    def setUp(self):\n-        self.manager = AddonManager()\n-\n-    def test_add(self):\n-        manager = AddonManager()\n-        manager.add(addonmod, {\"key\": \"val1\"})\n-        manager.add(\"tests.test_addons.addons.GoodAddon\")\n-        self.assertCountEqual(manager, [\"AddonModule\", \"GoodAddon\"])\n-        self.assertIsInstance(manager[\"GoodAddon\"], addons.GoodAddon)\n-        self.assertCountEqual(manager.configs[\"AddonModule\"], [\"key\"])\n-        self.assertEqual(manager.configs[\"AddonModule\"][\"key\"], \"val1\")\n-        self.assertRaises(ValueError, manager.add, addonmod)\n-\n-    def test_add_dont_instantiate_providing_classes(self):\n-        class ProviderGoodAddon(addons.GoodAddon):\n-            pass\n-\n-        directlyProvides(ProviderGoodAddon, IAddon)\n-        manager = AddonManager()\n-        manager.add(ProviderGoodAddon)\n-        self.assertIs(manager[\"GoodAddon\"], ProviderGoodAddon)\n-\n-    def test_add_verifies(self):\n-        brokenaddon = self.manager.get_addon(\"tests.test_addons.addons.BrokenAddon\")\n-        self.assertRaises(\n-            BrokenImplementation,\n-            self.manager.add,\n-            brokenaddon,\n-        )\n-\n-    def test_add_adds_missing_interface_declaration(self):\n-        class GoodAddonWithoutDeclaration(object):\n-            name = \"GoodAddonWithoutDeclaration\"\n-            version = \"1.0\"\n-\n-        self.manager.add(GoodAddonWithoutDeclaration)\n-\n-    def test_remove(self):\n-        manager = AddonManager()\n-\n-        def test_gets_removed(removearg):\n-            manager.add(addonmod)\n-            self.assertIn(\"AddonModule\", manager)\n-            manager.remove(removearg)\n-            self.assertNotIn(\"AddonModule\", manager)\n-\n-        test_gets_removed(\"AddonModule\")\n-        test_gets_removed(addonmod)\n-        test_gets_removed(\"tests.test_addons.addonmod\")\n-        self.assertRaises(KeyError, manager.remove, \"nonexistent\")\n-        self.assertRaises(KeyError, manager.remove, addons.GoodAddon())\n-\n-    def test_get_addon(self):\n-        goodaddon = self.manager.get_addon(\"tests.test_addons.addons.GoodAddon\")\n-        self.assertIs(goodaddon, addons.GoodAddon)\n-\n-        loaded_addonmod = self.manager.get_addon(\"tests.test_addons.addonmod\")\n-        self.assertIs(loaded_addonmod, addonmod)\n-\n-        goodaddon = self.manager.get_addon(\"tests.test_addons.addons\")\n-        self.assertIsInstance(goodaddon, addons.GoodAddon)\n-\n-        self.assertRaises(NameError, self.manager.get_addon, \"xy.n_onexistent\")\n-\n-    def test_get_addon_forward(self):\n-        class SomeCls(object):\n-            _addon = \"tests.test_addons.addons.GoodAddon\"\n-\n-        self.assertIs(self.manager.get_addon(SomeCls()), addons.GoodAddon)\n-\n-    def test_get_addon_nested(self):\n-        x = addons.GoodAddon(\"outer\")\n-        x._addon = addons.GoodAddon(\"middle\")\n-        x._addon._addon = addons.GoodAddon(\"inner\")\n-        self.assertIs(self.manager.get_addon(x), x._addon._addon)\n-\n-    def test_load_settings(self):\n-        settings = BaseSettings()\n-        settings.set(\n-            \"ADDONS\",\n-            {\"tests.test_addons.addonmod\": 0, \"tests.test_addons.addons.GoodAddon\": 0},\n-        )\n-        settings.set(\"ADDONMODULE\", {\"key\": \"val1\"})\n-        settings.set(\"GOODADDON\", {\"key\": \"val2\"})\n-        manager = AddonManager()\n-        manager.load_settings(settings)\n-        self.assertCountEqual(manager, [\"GoodAddon\", \"AddonModule\"])\n-        self.assertIsInstance(manager[\"GoodAddon\"], addons.GoodAddon)\n-        self.assertCountEqual(manager.configs[\"GoodAddon\"], [\"key\"])\n-        self.assertEqual(manager.configs[\"GoodAddon\"][\"key\"], \"val2\")\n-        self.assertEqual(manager[\"AddonModule\"], addonmod)\n-        self.assertIn(\"key\", manager.configs[\"AddonModule\"])\n-        self.assertEqual(manager.configs[\"AddonModule\"][\"key\"], \"val1\")\n-\n-    def test_load_settings_order(self):\n-        # Get three addons named 0, 1, 2\n-        addonlist = [addons.GoodAddon(str(x)) for x in range(3)]\n-        # Test for every possible ordering\n-        for ordered_addons in itertools.permutations(addonlist):\n-            expected_order = [a.name for a in ordered_addons]\n-            settings = BaseSettings(\n-                {\"ADDONS\": {a: i for i, a in enumerate(ordered_addons)}}\n-            )\n-            manager = AddonManager()\n-            manager.load_settings(settings)\n-            self.assertEqual(list(manager.keys()), expected_order)\n-\n-    def test_enabled_disabled(self):\n-        manager = AddonManager()\n-        manager.add(addons.GoodAddon(\"FirstAddon\"))\n-        manager.add(addons.GoodAddon(\"SecondAddon\"))\n-        self.assertEqual(set(manager.enabled), set((\"FirstAddon\", \"SecondAddon\")))\n-        self.assertEqual(manager.disabled, [])\n-        manager.disable(\"FirstAddon\")\n-        self.assertEqual(manager.enabled, [\"SecondAddon\"])\n-        self.assertEqual(manager.disabled, [\"FirstAddon\"])\n-        manager.enable(\"FirstAddon\")\n-        self.assertEqual(set(manager.enabled), set((\"FirstAddon\", \"SecondAddon\")))\n-        self.assertEqual(manager.disabled, [])\n-\n-    def test_enable_before_add(self):\n-        manager = AddonManager()\n-        self.assertRaises(ValueError, manager.enable, \"FirstAddon\")\n-        manager.disable(\"FirstAddon\")\n-        manager.enable(\"FirstAddon\")\n-        manager.add(addons.GoodAddon(\"FirstAddon\"))\n-        self.assertIn(\"FirstAddon\", manager.enabled)\n-\n-    def test_disable_before_add(self):\n-        manager = AddonManager()\n-        manager.disable(\"FirstAddon\")\n-        manager.add(addons.GoodAddon(\"FirstAddon\"))\n-        self.assertEqual(manager.disabled, [\"FirstAddon\"])\n-\n-    def test_callbacks(self):\n-        first_addon = addons.GoodAddon(\"FirstAddon\")\n-        second_addon = addons.GoodAddon(\"SecondAddon\")\n-\n-        manager = AddonManager()\n-        manager.add(first_addon, {\"test\": \"first\"})\n-        manager.add(second_addon, {\"test\": \"second\"})\n-        crawler = mock.create_autospec(Crawler)\n-        settings = BaseSettings()\n-\n-        with mock.patch.object(\n-            first_addon, \"update_addons\"\n-        ) as ua_first, mock.patch.object(\n-            second_addon, \"update_addons\"\n-        ) as ua_second, mock.patch.object(\n-            first_addon, \"update_settings\"\n-        ) as us_first, mock.patch.object(\n-            second_addon, \"update_settings\"\n-        ) as us_second, mock.patch.object(\n-            first_addon, \"check_configuration\"\n-        ) as cc_first, mock.patch.object(\n-            second_addon, \"check_configuration\"\n-        ) as cc_second:\n-            manager.update_addons()\n-            ua_first.assert_called_once_with(manager.configs[\"FirstAddon\"], manager)\n-            ua_second.assert_called_once_with(manager.configs[\"SecondAddon\"], manager)\n-            manager.update_settings(settings)\n-            us_first.assert_called_once_with(manager.configs[\"FirstAddon\"], settings)\n-            us_second.assert_called_once_with(manager.configs[\"SecondAddon\"], settings)\n-            manager.check_configuration(crawler)\n-            cc_first.assert_called_once_with(manager.configs[\"FirstAddon\"], crawler)\n-            cc_second.assert_called_once_with(manager.configs[\"SecondAddon\"], crawler)\n-            self.assertEqual(ua_first.call_count, 1)\n-            self.assertEqual(ua_second.call_count, 1)\n-            self.assertEqual(us_first.call_count, 1)\n-            self.assertEqual(us_second.call_count, 1)\n-\n-            us_first.reset_mock()\n-            us_second.reset_mock()\n-            manager.disable(\"FirstAddon\")\n-            manager.update_settings(settings)\n-            self.assertEqual(us_first.call_count, 0)\n-            manager.enable(\"FirstAddon\")\n-            manager.update_settings(settings)\n-            self.assertEqual(us_first.call_count, 1)\n-            self.assertEqual(us_second.call_count, 2)\n-\n-        # This will become relevant when we let spiders implement the add-on\n-        # interface and should be replaced with a test where\n-        # AddonManager.spidercls = None then.\n-        manager._call_if_exists(None, \"irrelevant\")\n-\n-    def test_update_addons_last_minute_add(self):\n-        class AddedAddon(addons.GoodAddon):\n-            name = \"AddedAddon\"\n-\n-        class FirstAddon(addons.GoodAddon):\n-            name = \"FirstAddon\"\n-\n-            def update_addons(self, config, addons):\n-                addons.add(AddedAddon())\n-\n-        manager = AddonManager()\n-        first_addon = FirstAddon()\n-        with mock.patch.object(\n-            first_addon, \"update_addons\", wraps=first_addon.update_addons\n-        ) as ua_first, mock.patch.object(AddedAddon, \"update_addons\") as ua_added:\n-            manager.add(first_addon, {\"non-empty\": \"dict\"})\n-            manager.update_addons()\n-            self.assertCountEqual(manager, [\"FirstAddon\", \"AddedAddon\"])\n-            ua_first.assert_called_once_with(manager.configs[\"FirstAddon\"], manager)\n-            ua_added.assert_called_once_with(manager.configs[\"AddedAddon\"], manager)\n-\n-    def test_check_dependency_clashes_attributes(self):\n-        provides = addons.GoodAddon(\"ProvidesAddon\")\n-        provides.provides = (\"test\",)\n-        provides2 = addons.GoodAddon(\"ProvidesAddon2\")\n-        provides2.provides = (\"test\",)\n-        requires = addons.GoodAddon(\"RequiresAddon\")\n-        requires.requires = (\"test\",)\n-        requires_name = addons.GoodAddon(\"RequiresNameAddon\")\n-        requires_name.requires = (\"ProvidesAddon\",)\n-        requires_newer = addons.GoodAddon(\"RequiresNewerAddon\")\n-        requires_newer.requires = (\"test>=2.0\",)\n-        modifies = addons.GoodAddon(\"ModifiesAddon\")\n-        modifies.modifies = (\"test\",)\n-\n-        def check_with(*addons):\n-            manager = AddonManager()\n-            for a in addons:\n-                manager.add(a)\n-            return manager.check_dependency_clashes()\n-\n-        self.assertRaises(ImportError, check_with, requires)\n-        self.assertRaises(ImportError, check_with, modifies)\n-        self.assertRaises(ImportError, check_with, provides, provides2)\n-        self.assertRaises(ImportError, check_with, provides, requires_newer)\n-        with warnings.catch_warnings(record=True) as w:\n-            check_with(provides, modifies)\n-            check_with(provides)\n-            check_with(provides, requires)\n-            check_with(provides, requires_name)\n-            self.assertEqual(len(w), 0)\n-            check_with(requires, provides, modifies)\n-            self.assertEqual(len(w), 1)\n\n@@ -1,16 +0,0 @@\n-from zope.interface import moduleProvides\n-\n-from scrapy.interfaces import IAddon\n-\n-moduleProvides(IAddon)\n-\n-name = \"AddonModule\"\n-version = \"1.0\"\n-\n-\n-def update_settings(config, settings):\n-    pass\n-\n-\n-def check_configuration(config, crawler):\n-    pass\n\n@@ -1,33 +0,0 @@\n-from zope.interface import implementer\n-\n-from scrapy.interfaces import IAddon\n-\n-\n-@implementer(IAddon)\n-class GoodAddon(object):\n-    name = \"GoodAddon\"\n-    version = \"1.0\"\n-\n-    def __init__(self, name=None, version=None):\n-        if name is not None:\n-            self.name = name\n-        if version is not None:\n-            self.version = version\n-\n-    def update_addons(self, config, addons):\n-        pass\n-\n-    def update_settings(self, config, settings):\n-        pass\n-\n-    def check_configuration(self, config, crawler):\n-        pass\n-\n-\n-@implementer(IAddon)\n-class BrokenAddon(object):\n-    name = \"BrokenAddon\"\n-    # No version\n-\n-\n-_addon = GoodAddon()\n\n@@ -412,7 +412,6 @@ with multiples lines\n     def test_abort_on_addon_failed_check(self):\n         class FailedCheckAddon(Addon):\n             name = \"FailedCheckAddon\"\n-            version = \"1.0\"\n \n             def check_configuration(self, config, crawler):\n                 raise ValueError\n\n@@ -15,7 +15,6 @@ from twisted.trial import unittest\n from w3lib import __version__ as w3lib_version\n \n import scrapy\n-from scrapy.addons import Addon, AddonManager\n from scrapy.crawler import Crawler, CrawlerProcess, CrawlerRunner\n from scrapy.exceptions import ScrapyDeprecationWarning\n from scrapy.extensions import telnet\n@@ -56,32 +55,6 @@ class CrawlerTestCase(BaseCrawlerTest):\n         self.assertFalse(settings.frozen)\n         self.assertTrue(crawler.settings.frozen)\n \n-    def test_populate_addons_settings(self):\n-        class TestAddon(Addon):\n-            name = \"TestAddon\"\n-            version = \"1.0\"\n-\n-        addonconfig = {\"TEST1\": \"addon\", \"TEST2\": \"addon\", \"TEST3\": \"addon\"}\n-\n-        class TestAddon2(Addon):\n-            name = \"testAddon2\"\n-            version = \"1.0\"\n-\n-        addonconfig2 = {\"TEST\": \"addon2\"}\n-\n-        settings = Settings()\n-        settings.set(\"TESTADDON_TEST1\", \"project\", priority=\"project\")\n-        settings.set(\"TESTADDON_TEST2\", \"default\", priority=\"default\")\n-        addonmgr = AddonManager()\n-        addonmgr.add(TestAddon(), addonconfig)\n-        addonmgr.add(TestAddon2(), addonconfig2)\n-        crawler = Crawler(DefaultSpider, settings, addons=addonmgr)\n-\n-        self.assertEqual(crawler.settings[\"TESTADDON_TEST1\"], \"project\")\n-        self.assertEqual(crawler.settings[\"TESTADDON_TEST2\"], \"addon\")\n-        self.assertEqual(crawler.settings[\"TESTADDON_TEST3\"], \"addon\")\n-        self.assertEqual(crawler.settings[\"TESTADDON2_TEST\"], \"addon2\")\n-\n     def test_crawler_accepts_dict(self):\n         crawler = get_crawler(DefaultSpider, {\"foo\": \"bar\"})\n         self.assertEqual(crawler.settings[\"foo\"], \"bar\")\n\n@@ -8,7 +8,6 @@ from scrapy.item import Field, Item\n from scrapy.utils.misc import (\n     arg_to_iter,\n     create_instance,\n-    load_module_or_object,\n     load_object,\n     rel_has_nofollow,\n     set_environ,\n@@ -36,12 +35,6 @@ class UtilsMiscTestCase(unittest.TestCase):\n         self.assertRaises(NameError, load_object, \"scrapy.utils.misc.load_object999\")\n         self.assertRaises(TypeError, load_object, {})\n \n-    def test_load_module_or_object(self):\n-        testmod = load_module_or_object(__name__ + \".testmod\")\n-        self.assertTrue(hasattr(testmod, \"TESTVAR\"))\n-        obj = load_object(\"scrapy.utils.misc.load_object\")\n-        self.assertIs(obj, load_object)\n-\n     def test_walk_modules(self):\n         mods = walk_modules(\"tests.test_utils_misc.test_walk_modules\")\n         expected = [\n\n@@ -1 +0,0 @@\n-TESTVAR = True\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
