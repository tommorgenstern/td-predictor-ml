{"custom_id": "requests#bbadf47a8fca97c4bf77e795369bc511e9483a40", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 34 | Lines Deleted: 58 | Files Changed: 2 | Hunks: 30 | Methods Changed: 4 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 92 | Churn Cumulative: 3453 | Contributors (this commit): 28 | Commits (past 90d): 4 | Contributors (cumulative): 32 | DMM Complexity: 0.0\n\nDIFF:\n@@ -32,7 +32,7 @@ from .compat import StringIO, u\n \n # Requests to this URL should always fail with a connection timeout (nothing\n # listening on that port)\n-TARPIT = \"http://10.255.255.1\"\n+TARPIT = 'http://10.255.255.1'\n \n \n class TestRequests:\n@@ -48,15 +48,14 @@ class TestRequests:\n         requests.patch\n         requests.post\n \n-    @pytest.mark.parametrize('exception, url',\n-        (\n+    @pytest.mark.parametrize(\n+        'exception, url', (\n             (MissingSchema, 'hiwpefhipowhefopw'),\n             (InvalidSchema, 'localhost:3128'),\n             (InvalidSchema, 'localhost.localdomain:3128/'),\n             (InvalidSchema, '10.122.1.1:3128/'),\n             (InvalidURL, 'http://'),\n-        )\n-    )\n+        ))\n     def test_invalid_url(self, exception, url):\n         with pytest.raises(exception):\n             requests.get(url)\n@@ -88,12 +87,11 @@ class TestRequests:\n \n         assert request.path_url == '/get/test%20case'\n \n-    @pytest.mark.parametrize('url, expected',\n-        (\n+    @pytest.mark.parametrize(\n+        'url, expected', (\n             ('http://example.com/path#fragment', 'http://example.com/path?a=b#fragment'),\n             ('http://example.com/path?key=value#fragment', 'http://example.com/path?key=value&a=b#fragment')\n-        )\n-    )\n+        ))\n     def test_params_are_added_before_fragment(self, url, expected):\n         request = requests.Request('GET', url, params={\"a\": \"b\"}).prepare()\n         assert request.url == expected\n@@ -276,9 +274,7 @@ class TestRequests:\n     @pytest.mark.parametrize('key', ('User-agent', 'user-agent'))\n     def test_user_agent_transfers(self, httpbin, key):\n \n-        heads = {\n-            key: 'Mozilla/5.0 (github.com/kennethreitz/requests)'\n-        }\n+        heads = {key: 'Mozilla/5.0 (github.com/kennethreitz/requests)'}\n \n         r = requests.get(httpbin('user-agent'), headers=heads)\n         assert heads[key] in r.text\n@@ -314,8 +310,7 @@ class TestRequests:\n             ('http://localhost:1', ConnectionError),\n             # Inputing a URL that cannot be parsed should raise an InvalidURL error\n             ('http://fe80::5054:ff:fe5a:fc0', InvalidURL)\n-        )\n-    )\n+        ))\n     def test_errors(self, url, exception):\n         with pytest.raises(exception):\n             requests.get(url, timeout=1)\n@@ -480,15 +475,13 @@ class TestRequests:\n         r.content.decode('ascii')\n \n     @pytest.mark.parametrize(\n-        'url, params',\n-        (\n+        'url, params', (\n             ('/get', {'foo': 'føø'}),\n             ('/get', {'føø': 'føø'}),\n             ('/get', {'føø': 'føø'}),\n             ('/get', {'foo': 'foo'}),\n             ('ø', {'foo': 'foo'}),\n-        )\n-    )\n+        ))\n     def test_unicode_get(self, httpbin, url, params):\n         requests.get(httpbin(url), params=params)\n \n@@ -520,8 +513,7 @@ class TestRequests:\n             {'stuff': u('ëlïxr').encode('utf-8')},\n             {'stuff': 'elixr'},\n             {'stuff': 'elixr'.encode('utf-8')},\n-        )\n-    )\n+        ))\n     def test_unicode_multipart_post(self, httpbin, data):\n         r = requests.post(httpbin('post'),\n             data=data,\n@@ -530,11 +522,10 @@ class TestRequests:\n \n     def test_unicode_multipart_post_fieldnames(self, httpbin):\n         filename = os.path.splitext(__file__)[0] + '.py'\n-        r = requests.Request(method='POST',\n-                             url=httpbin('post'),\n+        r = requests.Request(\n+            method='POST', url=httpbin('post'),\n             data={'stuff'.encode('utf-8'): 'elixr'},\n-                             files={'file': ('test_requests.py',\n-                                             open(filename, 'rb'))})\n+            files={'file': ('test_requests.py', open(filename, 'rb'))})\n         prep = r.prepare()\n         assert b'name=\"stuff\"' in prep.body\n         assert b'name=\"b\\'stuff\\'\"' not in prep.body\n@@ -548,10 +539,10 @@ class TestRequests:\n     def test_unicode_method_name_with_request_object(self, httpbin):\n         files = {'file': open(__file__, 'rb')}\n         s = requests.Session()\n-        req = requests.Request(u(\"POST\"), httpbin('post'), files=files)\n+        req = requests.Request(u('POST'), httpbin('post'), files=files)\n         prep = s.prepare_request(req)\n         assert isinstance(prep.method, builtin_str)\n-        assert prep.method == \"POST\"\n+        assert prep.method == 'POST'\n \n         resp = s.send(prep)\n         assert resp.status_code == 200\n@@ -560,7 +551,8 @@ class TestRequests:\n         r = requests.post(\n             httpbin('post'),\n             data={'stuff': json.dumps({'a': 123})},\n-            files={'file1': ('test_requests.py', open(__file__, 'rb')),\n+            files={\n+                'file1': ('test_requests.py', open(__file__, 'rb')),\n                 'file2': ('test_requests', open(__file__, 'rb'),\n                     'text/py-content-type')})\n         assert r.status_code == 200\n@@ -1081,8 +1073,7 @@ class TestCaseInsensitiveDict:\n             CaseInsensitiveDict({'Foo': 'foo', 'BAr': 'bar'}),\n             CaseInsensitiveDict([('Foo', 'foo'), ('BAr', 'bar')]),\n             CaseInsensitiveDict(FOO='foo', BAr='bar'),\n-        )\n-    )\n+        ))\n     def test_init(self, cid):\n         assert len(cid) == 2\n         assert 'foo' in cid\n@@ -1232,8 +1223,7 @@ class TestMorselToCookieExpires:\n         'value, exception', (\n             (100, TypeError),\n             ('woops', ValueError),\n-        )\n-    )\n+        ))\n     def test_expires_invalid_int(self, value, exception):\n         \"\"\"Test case where an invalid type is passed for expires.\"\"\"\n         morsel = Morsel()\n@@ -1283,8 +1273,7 @@ class TestTimeout:\n         'timeout, error_text', (\n             ((3, 4, 5), '(connect, read)'),\n             ('foo', 'must be an int or float'),\n-        )\n-    )\n+        ))\n     def test_invalid_timeout(self, httpbin, timeout, error_text):\n         with pytest.raises(ValueError) as e:\n             requests.get(httpbin('get'), timeout=timeout)\n@@ -1391,8 +1380,7 @@ def test_requests_are_updated_each_time(httpbin):\n         (('a', 'b'), ('c', 'd')),\n         (('c', 'd'), ('a', 'b')),\n         (('a', 'b'), ('c', 'd'), ('e', 'f')),\n-    )\n-)\n+    ))\n def test_data_argument_accepts_tuples(data):\n     \"\"\"Ensure that the data argument will accept tuples of strings\n     and properly encode them.\n@@ -1427,8 +1415,7 @@ def test_data_argument_accepts_tuples(data):\n             'method': 'GET',\n             'url': u('http://www.example.com/üniçø∂é')\n         },\n-    )\n-)\n+    ))\n def test_prepared_copy(kwargs):\n     p = PreparedRequest()\n     if kwargs:\n\n@@ -20,9 +20,7 @@ class TestSuperLen:\n         'stream, value', (\n             (StringIO.StringIO, 'Test'),\n             (BytesIO, b'Test'),\n-            pytest.mark.skipif('cStringIO is None')(\n-                (cStringIO, 'Test')\n-            ),\n+            pytest.mark.skipif('cStringIO is None')((cStringIO, 'Test')),\n         ))\n     def test_io_streams(self, stream, value):\n         \"\"\"Ensures that we properly deal with different kinds of IO streams.\"\"\"\n@@ -53,8 +51,7 @@ class TestGetEnvironProxies:\n             'http://172.16.1.1/',\n             'http://172.16.1.1:5000/',\n             'http://localhost.localdomain:5000/v1.0/',\n-        )\n-    )\n+        ))\n     def test_bypass(self, url):\n         assert get_environ_proxies(url) == {}\n \n@@ -63,8 +60,7 @@ class TestGetEnvironProxies:\n             'http://192.168.1.1:5000/',\n             'http://192.168.1.1/',\n             'http://www.requests.com/',\n-        )\n-    )\n+        ))\n     def test_not_bypass(self, url):\n         assert get_environ_proxies(url) != {}\n \n@@ -91,8 +87,7 @@ class TestIsValidCIDR:\n             '192.168.1.0/128',\n             '192.168.1.0/-1',\n             '192.168.1.999/24',\n-        )\n-    )\n+        ))\n     def test_invalid(self, value):\n         assert not is_valid_cidr(value)\n \n@@ -118,8 +113,7 @@ class TestGuessFilename:\n         'value, expected_type', (\n             (b'value', compat.bytes),\n             (b'value'.decode('utf-8'), compat.str)\n-        )\n-    )\n+        ))\n     def test_guess_filename_valid(self, value, expected_type):\n         obj = type('Fake', (object,), {'name': value})()\n         result = guess_filename(obj)\n@@ -143,8 +137,7 @@ class TestContentEncodingDetection:\n             '<meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\" />',\n             # XHTML 1.x served as XML\n             '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n-        )\n-    )\n+        ))\n     def test_pragmas(self, content):\n         encodings = get_encodings_from_content(content)\n         assert len(encodings) == 1\n@@ -191,8 +184,7 @@ ENCODED_PASSWORD = compat.quote(PASSWORD, '')\n             'http://user:pass%23pass@complex.url.com/path?query=yes',\n             ('user', 'pass#pass')\n         ),\n-    )\n-)\n+    ))\n def test_get_auth_from_url(url, auth):\n     assert get_auth_from_url(url) == auth\n \n@@ -209,8 +201,7 @@ def test_get_auth_from_url(url, auth):\n             'http://example.com/fiz?buz=%ppicture',\n             'http://example.com/fiz?buz=%25ppicture',\n         ),\n-    )\n-)\n+    ))\n def test_requote_uri_with_unquoted_percents(uri, expected):\n     \"\"\"See: https://github.com/kennethreitz/requests/issues/2356\n     \"\"\"\n@@ -222,8 +213,7 @@ def test_requote_uri_with_unquoted_percents(uri, expected):\n         (8, '255.0.0.0'),\n         (24, '255.255.255.0'),\n         (25, '255.255.255.128'),\n-    )\n-)\n+    ))\n def test_dotted_netmask(mask, expected):\n     assert dotted_netmask(mask) == expected\n \n@@ -233,8 +223,7 @@ def test_dotted_netmask(mask, expected):\n         ('hTTp://u:p@Some.Host/path', 'http://some.host.proxy'),\n         ('hTTp://u:p@Other.Host/path', 'http://http.proxy'),\n         ('hTTps://Other.Host', None),\n-    )\n-)\n+    ))\n def test_select_proxies(url, expected):\n     \"\"\"Make sure we can select per-host proxies correctly.\"\"\"\n     proxies = {'http': 'http://http.proxy',\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#fc512d89245c4ee1f4b6d6f0445bc962a0621288", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 5 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 12 | Churn Cumulative: 3102 | Contributors (this commit): 71 | Commits (past 90d): 7 | Contributors (cumulative): 71 | DMM Complexity: 0.0\n\nDIFF:\n@@ -553,6 +553,13 @@ class Session(SessionRedirectMixin):\n         if not isinstance(request, PreparedRequest):\n             raise ValueError('You can only send PreparedRequests.')\n \n+        # Set up variables needed for resolve_redirects and dispatching of hooks\n+        allow_redirects = kwargs.pop('allow_redirects', True)\n+        stream = kwargs.get('stream')\n+        hooks = request.hooks\n+\n+        # Resolve URL in redirect cache, if available.\n+        if allow_redirects:\n             checked_urls = set()\n             while request.url in self.redirect_cache:\n                 checked_urls.add(request.url)\n@@ -561,11 +568,6 @@ class Session(SessionRedirectMixin):\n                     break\n                 request.url = new_url\n \n-        # Set up variables needed for resolve_redirects and dispatching of hooks\n-        allow_redirects = kwargs.pop('allow_redirects', True)\n-        stream = kwargs.get('stream')\n-        hooks = request.hooks\n-\n         # Get the appropriate adapter to use\n         adapter = self.get_adapter(url=request.url)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b0704b86de4f207c11b72c1ea4046be95af5f9e5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 631 | Contributors (this commit): 13 | Commits (past 90d): 4 | Contributors (cumulative): 13 | DMM Complexity: None\n\nDIFF:\n@@ -46,7 +46,7 @@ __version__ = '2.9.1'\n __build__ = 0x020901\n __author__ = 'Kenneth Reitz'\n __license__ = 'Apache 2.0'\n-__copyright__ = 'Copyright 2015 Kenneth Reitz'\n+__copyright__ = 'Copyright 2016 Kenneth Reitz'\n \n # Attempt to enable urllib3's SNI support, if possible\n try:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f123f89d32d3258429cdecf33fbd20e68a746042", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 205 | Lines Deleted: 24 | Files Changed: 2 | Hunks: 22 | Methods Changed: 20 | Complexity Δ (Sum/Max): 16/16 | Churn Δ: 229 | Churn Cumulative: 3113 | Contributors (this commit): 59 | Commits (past 90d): 6 | Contributors (cumulative): 63 | DMM Complexity: 1.0\n\nDIFF:\n@@ -14,9 +14,7 @@ import codecs\n import collections\n import io\n import os\n-import platform\n import re\n-import sys\n import socket\n import struct\n import warnings\n@@ -557,6 +555,7 @@ def should_bypass_proxies(url):\n \n     return False\n \n+\n def get_environ_proxies(url):\n     \"\"\"Return a dict of environment proxies.\"\"\"\n     if should_bypass_proxies(url):\n@@ -564,6 +563,7 @@ def get_environ_proxies(url):\n     else:\n         return getproxies()\n \n+\n def select_proxy(url, proxies):\n     \"\"\"Select a proxy for the url, if applicable.\n \n@@ -577,6 +577,7 @@ def select_proxy(url, proxies):\n         proxy = proxies.get(urlparts.scheme)\n     return proxy\n \n+\n def default_user_agent(name=\"python-requests\"):\n     \"\"\"Return a string representing the default user agent.\"\"\"\n     return '%s/%s' % (name, __version__)\n@@ -600,21 +601,19 @@ def parse_header_links(value):\n \n     links = []\n \n-    replace_chars = \" '\\\"\"\n+    replace_chars = ' \\'\"'\n \n-    for val in re.split(\", *<\", value):\n+    for val in re.split(', *<', value):\n         try:\n-            url, params = val.split(\";\", 1)\n+            url, params = val.split(';', 1)\n         except ValueError:\n             url, params = val, ''\n \n-        link = {}\n+        link = {'url': url.strip('<> \\'\"')}\n \n-        link[\"url\"] = url.strip(\"<> '\\\"\")\n-\n-        for param in params.split(\";\"):\n+        for param in params.split(';'):\n             try:\n-                key, value = param.split(\"=\")\n+                key, value = param.split('=')\n             except ValueError:\n                 break\n \n@@ -661,8 +660,8 @@ def guess_json_utf(data):\n \n \n def prepend_scheme_if_needed(url, new_scheme):\n-    '''Given a URL that may or may not have a scheme, prepend the given scheme.\n-    Does not replace a present scheme with the one provided as an argument.'''\n+    \"\"\"Given a URL that may or may not have a scheme, prepend the given scheme.\n+    Does not replace a present scheme with the one provided as an argument.\"\"\"\n     scheme, netloc, path, params, query, fragment = urlparse(url, new_scheme)\n \n     # urlparse is a finicky beast, and sometimes decides that there isn't a\n@@ -693,8 +692,6 @@ def to_native_string(string, encoding='ascii'):\n     string in the native string type, encoding and decoding where necessary.\n     This assumes ASCII unless told otherwise.\n     \"\"\"\n-    out = None\n-\n     if isinstance(string, builtin_str):\n         out = string\n     else:\n\n@@ -1,15 +1,20 @@\n # coding: utf-8\n-import os\n from io import BytesIO\n \n import pytest\n from requests import compat\n+from requests.structures import CaseInsensitiveDict\n from requests.utils import (\n     address_in_network, dotted_netmask,\n-    get_auth_from_url, get_encodings_from_content,\n-    get_environ_proxies, guess_filename,\n-    is_ipv4_address, is_valid_cidr, requote_uri,\n-    select_proxy, super_len)\n+    get_auth_from_url, get_encoding_from_headers,\n+    get_encodings_from_content, get_environ_proxies,\n+    guess_filename, guess_json_utf, is_ipv4_address,\n+    is_valid_cidr, iter_slices, parse_dict_header,\n+    parse_header_links, prepend_scheme_if_needed,\n+    requote_uri, select_proxy, super_len,\n+    to_key_val_list, to_native_string,\n+    unquote_header_value, unquote_unreserved,\n+    urldefragauth)\n \n from .compat import StringIO, cStringIO\n \n@@ -33,16 +38,63 @@ class TestSuperLen:\n         s.write('foobarbogus')\n         assert super_len(s) == 0\n \n+    def test_string(self):\n+        assert super_len('Test') == 4\n+\n+    @pytest.mark.parametrize(\n+        'mode, warnings_num', (\n+            ('r', 1),\n+            ('rb', 0),\n+        ))\n+    def test_file(self, tmpdir, mode, warnings_num, recwarn):\n+        file_obj = tmpdir.join('test.txt')\n+        file_obj.write('Test')\n+        with file_obj.open(mode) as fd:\n+            assert super_len(fd) == 4\n+        assert len(recwarn) == warnings_num\n+\n+\n+class TestToKeyValList:\n+\n+    @pytest.mark.parametrize(\n+        'value, expected', (\n+            ([('key', 'val')], [('key', 'val')]),\n+            ((('key', 'val'), ), [('key', 'val')]),\n+            ({'key': 'val'}, [('key', 'val')]),\n+            (None, None)\n+        ))\n+    def test_valid(self, value, expected):\n+        assert to_key_val_list(value) == expected\n+\n+    def test_invalid(self):\n+        with pytest.raises(ValueError):\n+            to_key_val_list('string')\n+\n+\n+class TestUnquoteHeaderValue:\n+\n+    @pytest.mark.parametrize(\n+        'value, expected', (\n+            (None, None),\n+            ('Test', 'Test'),\n+            ('\"Test\"', 'Test'),\n+            ('\"Test\\\\\\\\\"', 'Test\\\\'),\n+            ('\"\\\\\\\\Comp\\\\Res\"', '\\\\Comp\\\\Res'),\n+        ))\n+    def test_valid(self, value, expected):\n+        assert unquote_header_value(value) == expected\n+\n+    def test_is_filename(self):\n+        assert unquote_header_value('\"\\\\\\\\Comp\\\\Res\"', True) == '\\\\\\\\Comp\\\\Res'\n+\n \n class TestGetEnvironProxies:\n     \"\"\"Ensures that IP addresses are correctly matches with ranges\n     in no_proxy variable.\"\"\"\n \n-    @pytest.yield_fixture(scope='class', autouse=True, params=['no_proxy', 'NO_PROXY'])\n-    def no_proxy(self, request):\n-        os.environ[request.param] = '192.168.0.0/24,127.0.0.1,localhost.localdomain,172.16.1.1'\n-        yield\n-        del os.environ[request.param]\n+    @pytest.fixture(autouse=True, params=['no_proxy', 'NO_PROXY'])\n+    def no_proxy(self, request, monkeypatch):\n+        monkeypatch.setenv(request.param, '192.168.0.0/24,127.0.0.1,localhost.localdomain,172.16.1.1')\n \n     @pytest.mark.parametrize(\n         'url', (\n@@ -152,6 +204,21 @@ class TestContentEncodingDetection:\n         assert get_encodings_from_content(content) == ['HTML5', 'HTML4', 'XML']\n \n \n+class TestGuessJSONUTF:\n+\n+    @pytest.mark.parametrize(\n+        'encoding', (\n+            'utf-32', 'utf-8-sig', 'utf-16', 'utf-8', 'utf-16-be', 'utf-16-le',\n+            'utf-32-be', 'utf-32-le'\n+        ))\n+    def test_encoded(self, encoding):\n+        data = '{}'.encode(encoding)\n+        assert guess_json_utf(data) == encoding\n+\n+    def test_bad_utf_like_encoding(self):\n+        assert guess_json_utf(b'\\x00\\x00\\x00\\x00') is None\n+\n+\n USER = PASSWORD = \"%!*'();:@&=+$,/?#[] \"\n ENCODED_USER = compat.quote(USER, '')\n ENCODED_PASSWORD = compat.quote(PASSWORD, '')\n@@ -184,6 +251,10 @@ ENCODED_PASSWORD = compat.quote(PASSWORD, '')\n             'http://user:pass%23pass@complex.url.com/path?query=yes',\n             ('user', 'pass#pass')\n         ),\n+        (\n+            'http://complex.url.com/path?query=yes',\n+            ('', '')\n+        ),\n     ))\n def test_get_auth_from_url(url, auth):\n     assert get_auth_from_url(url) == auth\n@@ -208,6 +279,23 @@ def test_requote_uri_with_unquoted_percents(uri, expected):\n     assert requote_uri(uri) == expected\n \n \n+@pytest.mark.parametrize(\n+    'uri, expected', (\n+        (\n+            # Illegal bytes\n+            'http://example.com/?a=%--',\n+            'http://example.com/?a=%--',\n+        ),\n+        (\n+            # Reserved characters\n+            'http://example.com/?a=%300',\n+            'http://example.com/?a=00',\n+        )\n+    ))\n+def test_unquote_unreserved(uri, expected):\n+    assert unquote_unreserved(uri) == expected\n+\n+\n @pytest.mark.parametrize(\n     'mask, expected', (\n         (8, '255.0.0.0'),\n@@ -229,3 +317,99 @@ def test_select_proxies(url, expected):\n     proxies = {'http': 'http://http.proxy',\n                'http://some.host': 'http://some.host.proxy'}\n     assert select_proxy(url, proxies) == expected\n+\n+\n+@pytest.mark.parametrize(\n+    'value, expected', (\n+        ('foo=\"is a fish\", bar=\"as well\"', {'foo': 'is a fish', 'bar': 'as well'}),\n+        ('key_without_value', {'key_without_value': None})\n+    ))\n+def test_parse_dict_header(value, expected):\n+    assert parse_dict_header(value) == expected\n+\n+\n+@pytest.mark.parametrize(\n+    'value, expected', (\n+        (\n+            CaseInsensitiveDict(),\n+            None\n+        ),\n+        (\n+            CaseInsensitiveDict({'content-type': 'application/json; charset=utf-8'}),\n+            'utf-8'\n+        ),\n+        (\n+            CaseInsensitiveDict({'content-type': 'text/plain'}),\n+            'ISO-8859-1'\n+        ),\n+    ))\n+def test_get_encoding_from_headers(value, expected):\n+    assert get_encoding_from_headers(value) == expected\n+\n+\n+@pytest.mark.parametrize(\n+    'value, length', (\n+        ('', 0),\n+        ('T', 1),\n+        ('Test', 4),\n+    ))\n+def test_iter_slices(value, length):\n+    assert len(list(iter_slices(value, 1))) == length\n+\n+\n+@pytest.mark.parametrize(\n+    'value, expected', (\n+        (\n+            '<http:/.../front.jpeg>; rel=front; type=\"image/jpeg\"',\n+            [{'url': 'http:/.../front.jpeg', 'rel': 'front', 'type': 'image/jpeg'}]\n+        ),\n+        (\n+            '<http:/.../front.jpeg>',\n+            [{'url': 'http:/.../front.jpeg'}]\n+        ),\n+        (\n+            '<http:/.../front.jpeg>;',\n+            [{'url': 'http:/.../front.jpeg'}]\n+        ),\n+        (\n+            '<http:/.../front.jpeg>; type=\"image/jpeg\",<http://.../back.jpeg>;',\n+            [\n+                {'url': 'http:/.../front.jpeg', 'type': 'image/jpeg'},\n+                {'url': 'http://.../back.jpeg'}\n+            ]\n+        ),\n+    ))\n+def test_parse_header_links(value, expected):\n+    assert parse_header_links(value) == expected\n+\n+\n+@pytest.mark.parametrize(\n+    'value, expected', (\n+        ('example.com/path', 'http://example.com/path'),\n+        ('//example.com/path', 'http://example.com/path'),\n+    ))\n+def test_prepend_scheme_if_needed(value, expected):\n+    assert prepend_scheme_if_needed(value, 'http') == expected\n+\n+\n+@pytest.mark.parametrize(\n+    'value, expected', (\n+        ('T', 'T'),\n+        (b'T', 'T'),\n+        (u'T', 'T'),\n+    ))\n+def test_to_native_string(value, expected):\n+    assert to_native_string(value) == expected\n+\n+\n+@pytest.mark.parametrize(\n+    'url, expected', (\n+        ('http://u:p@example.com/path?a=1#test', 'http://example.com/path?a=1'),\n+        ('http://example.com/path', 'http://example.com/path'),\n+        ('//u:p@example.com/path', '//example.com/path'),\n+        ('//example.com/path', '//example.com/path'),\n+        ('example.com/path', '//example.com/path'),\n+        ('scheme:u:p@example.com/path', 'scheme://example.com/path'),\n+    ))\n+def test_urldefragauth(url, expected):\n+    assert urldefragauth(url) == expected\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#fa91b0ab7ce45389357a4fc9f33785514b265b40", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 13 | Files Changed: 2 | Hunks: 8 | Methods Changed: 5 | Complexity Δ (Sum/Max): 19/19 | Churn Δ: 17 | Churn Cumulative: 6089 | Contributors (this commit): 104 | Commits (past 90d): 17 | Contributors (cumulative): 105 | DMM Complexity: None\n\nDIFF:\n@@ -1186,20 +1186,13 @@ class TestContentEncodingDetection(unittest.TestCase):\n         block_server = threading.Event()\n         server = Server.basic_response_server(wait_to_close_event=block_server)\n         data = (i for i in [b'a', b'b', b'c']) \n-\n         with server as (host, port):\n             url = 'http://{}:{}/'.format(host, port)\n             r = requests.post(url, data=data, stream=True)\n             block_server.set() # release server block\n-\n         assert r.status_code == 200\n         assert r.request.headers['Transfer-Encoding'] == 'chunked'\n \n-            \n-        \n-\n-\n-\n class TestCaseInsensitiveDict(unittest.TestCase):\n \n     def test_mapping_init(self):\n\n@@ -5,17 +5,17 @@ import socket\n import select\n \n \n-def consume_socket_content(sock, chunks=65536, timeout=0.5):\n+def consume_socket_content(sock, timeout=0.5):\n+    chunks = 65536\n     content = \"\"\n     more_to_read = select.select([sock], [], [], timeout)[0]\n \n     while more_to_read:\n         new_content = sock.recv(chunks).decode(\"utf-8\")\n \n-        if len(new_content) == 0:\n-            more_to_read = False # empty recv means the socket disconnected\n+        if not new_content:\n+            break\n \n-        else:\n         content += new_content \n         # stop reading if no new data is received for a while \n         more_to_read = select.select([sock], [], [], timeout)[0] \n@@ -49,7 +49,6 @@ class Server(threading.Thread):\n \n \n         server = Server(text_response_handler, **kwargs)\n-\n         return server\n \n     @classmethod\n@@ -58,7 +57,6 @@ class Server(threading.Thread):\n             \"HTTP/1.1 200 OK\\r\\n\" +\n             \"Content-Length: 0\\r\\n\\r\\n\", **kwargs\n         )\n-\n         return server\n \n     def run(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#241656355bbc03f24d04578e3e523bee9ca70269", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 5946 | Contributors (this commit): 104 | Commits (past 90d): 15 | Contributors (cumulative): 104 | DMM Complexity: None\n\nDIFF:\n@@ -1186,10 +1186,12 @@ class TestContentEncodingDetection(unittest.TestCase):\n         block_server = threading.Event()\n         server = Server.basic_response_server(wait_to_close_event=block_server)\n         data = (i for i in [b'a', b'b', b'c']) \n+\n         with server as (host, port):\n             url = 'http://{}:{}/'.format(host, port)\n             r = requests.post(url, data=data, stream=True)\n             block_server.set() # release server block\n+\n         assert r.status_code == 200\n         assert r.request.headers['Transfer-Encoding'] == 'chunked'\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#9ac5a6e4aea4ba76c515291be3682aac262e34d4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 14 | Lines Deleted: 11 | Files Changed: 1 | Hunks: 10 | Methods Changed: 8 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 25 | Churn Cumulative: 170 | Contributors (this commit): 1 | Commits (past 90d): 4 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -11,7 +11,7 @@ def consume_socket_content(sock, timeout=0.5):\n     more_to_read = select.select([sock], [], [], timeout)[0]\n \n     while more_to_read:\n-        new_content = sock.recv(chunks).decode(\"utf-8\")\n+        new_content = sock.recv(chunks)\n \n         if not new_content:\n             break\n@@ -22,8 +22,11 @@ def consume_socket_content(sock, timeout=0.5):\n \n     return content\n \n+\n+\n class Server(threading.Thread):\n     \"\"\" Dummy server using for unit testing \"\"\"\n+    WAIT_EVENT_TIMEOUT = 5\n \n     def __init__(self, handler, host='localhost', port=0, requests_to_handle=1, wait_to_close_event=None):\n         threading.Thread.__init__(self)\n@@ -43,7 +46,7 @@ class Server(threading.Thread):\n     def text_response_server(cls, text, request_timeout=0.5, **kwargs):\n         def text_response_handler(sock):\n             request_content = consume_socket_content(sock, timeout=request_timeout)\n-            sock.send(text.encode())\n+            sock.send(text.encode('utf-8'))\n \n             return request_content\n \n@@ -65,7 +68,10 @@ class Server(threading.Thread):\n             # in case self.port = 0\n             self.port = sock.getsockname()[1]\n             self.ready_event.set()\n-            self._handle_requests_and_close_server(sock)\n+            self._handle_requests(sock)\n+\n+            if self.wait_to_close_event:\n+                self.wait_to_close_event.wait(self.WAIT_EVENT_TIMEOUT)\n         finally:\n             self.ready_event.set() # just in case of exception\n             sock.close()\n@@ -77,28 +83,25 @@ class Server(threading.Thread):\n         sock.listen(0)\n         return sock\n \n-    def _handle_requests_and_close_server(self, server_sock):\n+    def _handle_requests(self, server_sock):\n         for _ in range(self.requests_to_handle):\n             sock = server_sock.accept()[0]\n             handler_result = self.handler(sock)\n \n             self.handler_results.append(handler_result)\n         \n-        if self.wait_to_close_event:\n-            self.wait_to_close_event.wait()\n-        \n     def __enter__(self):\n        self.start()\n-       self.ready_event.wait()\n+       self.ready_event.wait(self.WAIT_EVENT_TIMEOUT)\n        return self.host, self.port\n       \n     def __exit__(self, exc_type, exc_value, traceback):\n         if exc_type is None:\n-            self.stop_event.wait()\n+            self.stop_event.wait(self.WAIT_EVENT_TIMEOUT)\n         else:\n             if self.wait_to_close_event:\n-                # avoid server from blocking if an exception is found\n-                # in the main thread\n+                # avoid server from waiting for event timeouts \n+                # if an exception is found in the main thread \n                 self.wait_to_close_event.set() \n         return False # allow exceptions to propagate \n     \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#ca35c847a203b264edb57a2d6d3a2700ac69dcde", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 107 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 1 | Methods Changed: 10 | Complexity Δ (Sum/Max): 17/17 | Churn Δ: 107 | Churn Cumulative: 107 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n\n@@ -0,0 +1,107 @@\n+#!/usr/bin/python\n+\n+import threading \n+import socket\n+import select\n+\n+\n+def consume_socket_content(sock, timeout=0.5):\n+    chunks = 65536\n+    content = \"\"\n+    more_to_read = select.select([sock], [], [], timeout)[0]\n+\n+    while more_to_read:\n+        new_content = sock.recv(chunks)\n+\n+        if not new_content:\n+            break\n+\n+        content += new_content \n+        # stop reading if no new data is received for a while \n+        more_to_read = select.select([sock], [], [], timeout)[0] \n+\n+    return content\n+\n+\n+\n+class Server(threading.Thread):\n+    \"\"\" Dummy server using for unit testing \"\"\"\n+    WAIT_EVENT_TIMEOUT = 5\n+\n+    def __init__(self, handler, host='localhost', port=0, requests_to_handle=1, wait_to_close_event=None):\n+        threading.Thread.__init__(self)\n+\n+        self.handler = handler\n+        self.handler_results = []\n+\n+        self.host = host\n+        self.port = port\n+        self.requests_to_handle = requests_to_handle\n+ \n+        self.wait_to_close_event = wait_to_close_event\n+        self.ready_event = threading.Event()\n+        self.stop_event = threading.Event()\n+\n+    @classmethod\n+    def text_response_server(cls, text, request_timeout=0.5, **kwargs):\n+        def text_response_handler(sock):\n+            request_content = consume_socket_content(sock, timeout=request_timeout)\n+            sock.send(text.encode('utf-8'))\n+\n+            return request_content\n+\n+\n+        server = Server(text_response_handler, **kwargs)\n+        return server\n+\n+    @classmethod\n+    def basic_response_server(cls, **kwargs):\n+        server = cls.text_response_server(\n+            \"HTTP/1.1 200 OK\\r\\n\" +\n+            \"Content-Length: 0\\r\\n\\r\\n\", **kwargs\n+        )\n+        return server\n+\n+    def run(self):\n+        try:\n+            sock = self._create_socket_and_bind()\n+            # in case self.port = 0\n+            self.port = sock.getsockname()[1]\n+            self.ready_event.set()\n+            self._handle_requests(sock)\n+\n+            if self.wait_to_close_event:\n+                self.wait_to_close_event.wait(self.WAIT_EVENT_TIMEOUT)\n+        finally:\n+            self.ready_event.set() # just in case of exception\n+            sock.close()\n+            self.stop_event.set()\n+\n+    def _create_socket_and_bind(self):\n+        sock = socket.socket()\n+        sock.bind((self.host, self.port))\n+        sock.listen(0)\n+        return sock\n+\n+    def _handle_requests(self, server_sock):\n+        for _ in range(self.requests_to_handle):\n+            sock = server_sock.accept()[0]\n+            handler_result = self.handler(sock)\n+\n+            self.handler_results.append(handler_result)\n+        \n+    def __enter__(self):\n+       self.start()\n+       self.ready_event.wait(self.WAIT_EVENT_TIMEOUT)\n+       return self.host, self.port\n+      \n+    def __exit__(self, exc_type, exc_value, traceback):\n+        if exc_type is None:\n+            self.stop_event.wait(self.WAIT_EVENT_TIMEOUT)\n+        else:\n+            if self.wait_to_close_event:\n+                # avoid server from waiting for event timeouts \n+                # if an exception is found in the main thread \n+                self.wait_to_close_event.set() \n+        return False # allow exceptions to propagate \n+    \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#75a9a981b58dc4866acaa2b95b08a8c2ffa914d9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 107 | Files Changed: 2 | Hunks: 1 | Methods Changed: 10 | Complexity Δ (Sum/Max): -17/0 | Churn Δ: 107 | Churn Cumulative: 277 | Contributors (this commit): 1 | Commits (past 90d): 6 | Contributors (cumulative): 2 | DMM Complexity: 0.0\n\nDIFF:\n\n@@ -1,107 +0,0 @@\n-#!/usr/bin/python\n-\n-import threading \n-import socket\n-import select\n-\n-\n-def consume_socket_content(sock, timeout=0.5):\n-    chunks = 65536\n-    content = \"\"\n-    more_to_read = select.select([sock], [], [], timeout)[0]\n-\n-    while more_to_read:\n-        new_content = sock.recv(chunks)\n-\n-        if not new_content:\n-            break\n-\n-        content += new_content \n-        # stop reading if no new data is received for a while \n-        more_to_read = select.select([sock], [], [], timeout)[0] \n-\n-    return content\n-\n-\n-\n-class Server(threading.Thread):\n-    \"\"\" Dummy server using for unit testing \"\"\"\n-    WAIT_EVENT_TIMEOUT = 5\n-\n-    def __init__(self, handler, host='localhost', port=0, requests_to_handle=1, wait_to_close_event=None):\n-        threading.Thread.__init__(self)\n-\n-        self.handler = handler\n-        self.handler_results = []\n-\n-        self.host = host\n-        self.port = port\n-        self.requests_to_handle = requests_to_handle\n- \n-        self.wait_to_close_event = wait_to_close_event\n-        self.ready_event = threading.Event()\n-        self.stop_event = threading.Event()\n-\n-    @classmethod\n-    def text_response_server(cls, text, request_timeout=0.5, **kwargs):\n-        def text_response_handler(sock):\n-            request_content = consume_socket_content(sock, timeout=request_timeout)\n-            sock.send(text.encode('utf-8'))\n-\n-            return request_content\n-\n-\n-        server = Server(text_response_handler, **kwargs)\n-        return server\n-\n-    @classmethod\n-    def basic_response_server(cls, **kwargs):\n-        server = cls.text_response_server(\n-            \"HTTP/1.1 200 OK\\r\\n\" +\n-            \"Content-Length: 0\\r\\n\\r\\n\", **kwargs\n-        )\n-        return server\n-\n-    def run(self):\n-        try:\n-            sock = self._create_socket_and_bind()\n-            # in case self.port = 0\n-            self.port = sock.getsockname()[1]\n-            self.ready_event.set()\n-            self._handle_requests(sock)\n-\n-            if self.wait_to_close_event:\n-                self.wait_to_close_event.wait(self.WAIT_EVENT_TIMEOUT)\n-        finally:\n-            self.ready_event.set() # just in case of exception\n-            sock.close()\n-            self.stop_event.set()\n-\n-    def _create_socket_and_bind(self):\n-        sock = socket.socket()\n-        sock.bind((self.host, self.port))\n-        sock.listen(0)\n-        return sock\n-\n-    def _handle_requests(self, server_sock):\n-        for _ in range(self.requests_to_handle):\n-            sock = server_sock.accept()[0]\n-            handler_result = self.handler(sock)\n-\n-            self.handler_results.append(handler_result)\n-        \n-    def __enter__(self):\n-       self.start()\n-       self.ready_event.wait(self.WAIT_EVENT_TIMEOUT)\n-       return self.host, self.port\n-      \n-    def __exit__(self, exc_type, exc_value, traceback):\n-        if exc_type is None:\n-            self.stop_event.wait(self.WAIT_EVENT_TIMEOUT)\n-        else:\n-            if self.wait_to_close_event:\n-                # avoid server from waiting for event timeouts \n-                # if an exception is found in the main thread \n-                self.wait_to_close_event.set() \n-        return False # allow exceptions to propagate \n-    \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#567b31080e62fd52bb9b8fb778736eb05359daa8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 4 | Methods Changed: 4 | Complexity Δ (Sum/Max): -3/0 | Churn Δ: 8 | Churn Cumulative: 749 | Contributors (this commit): 6 | Commits (past 90d): 4 | Contributors (cumulative): 6 | DMM Complexity: None\n\nDIFF:\n@@ -164,7 +164,7 @@ class TestContentEncodingDetection:\n         data = (i for i in [b'a', b'b', b'c']) \n \n         with server as (host, port):\n-            url = 'http://{}:{}/'.format(host, port)\n+            url = 'http://{0}:{1}/'.format(host, port)\n             r = requests.post(url, data=data, stream=True)\n             block_server.set() # release server block\n \n@@ -288,7 +288,7 @@ class TestTestServer:\n         )\n \n         with server as (host, port):\n-            r = requests.get('http://{}:{}'.format(host, port))\n+            r = requests.get('http://{0}:{1}'.format(host, port))\n \n             assert r.status_code == 200\n             assert r.text == 'roflol'\n@@ -296,7 +296,7 @@ class TestTestServer:\n             \n     def test_basic_response(self):\n         with Server.basic_response_server() as (host, port):\n-            r = requests.get('http://{}:{}'.format(host, port))\n+            r = requests.get('http://{0}:{1}'.format(host, port))\n             assert r.status_code == 200\n             assert r.text == ''\n             assert r.headers['Content-Length'] == '0'\n@@ -318,7 +318,7 @@ class TestTestServer:\n         server = Server.basic_response_server(requests_to_handle=requests_to_handle)\n \n         with server as (host, port):\n-            server_url = 'http://{}:{}'.format(host, port)\n+            server_url = 'http://{0}:{1}'.format(host, port)\n             for _ in range(requests_to_handle):\n                 r = requests.get(server_url)\n                 assert r.status_code == 200\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f17ef753d2c1f4db0d7f5aec51261da1db20d611", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 17 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 17 | Churn Cumulative: 766 | Contributors (this commit): 6 | Commits (past 90d): 5 | Contributors (cumulative): 6 | DMM Complexity: 0.0\n\nDIFF:\n@@ -157,23 +157,6 @@ class TestContentEncodingDetection:\n         '''.strip()\n         assert get_encodings_from_content(content) == ['HTML5', 'HTML4', 'XML']\n \n-    def test_chunked_upload(self):\n-        \"\"\"can safely send generators\"\"\"\n-        block_server = threading.Event()\n-        server = Server.basic_response_server(wait_to_close_event=block_server)\n-        data = (i for i in [b'a', b'b', b'c']) \n-\n-        with server as (host, port):\n-            url = 'http://{0}:{1}/'.format(host, port)\n-            r = requests.post(url, data=data, stream=True)\n-            block_server.set() # release server block\n-\n-        assert r.status_code == 200\n-        assert r.request.headers['Transfer-Encoding'] == 'chunked'\n-\n-\n-\n-\n USER = PASSWORD = \"%!*'();:@&=+$,/?#[] \"\n ENCODED_USER = compat.quote(USER, '')\n ENCODED_PASSWORD = compat.quote(PASSWORD, '')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e3ad31f3be58790b719c4798f4f3dbdc19518819", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 19 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 19 | Churn Cumulative: 2935 | Contributors (this commit): 28 | Commits (past 90d): 3 | Contributors (cumulative): 28 | DMM Complexity: 1.0\n\nDIFF:\n@@ -9,6 +9,7 @@ import os\n import pickle\n import collections\n import contextlib\n+import threading\n \n import io\n import requests\n@@ -27,6 +28,7 @@ from requests.structures import CaseInsensitiveDict\n from requests.sessions import SessionRedirectMixin\n from requests.models import urlencode\n from requests.hooks import default_hooks\n+from testserver.server import Server\n from .compat import StringIO, u\n \n # Requests to this URL should always fail with a connection timeout (nothing\n@@ -1452,6 +1454,23 @@ def test_vendor_aliases():\n     with pytest.raises(ImportError):\n         from requests.packages import webbrowser\n \n+def test_chunked_upload():\n+    \"\"\"can safely send generators\"\"\"\n+    block_server = threading.Event()\n+    server = Server.basic_response_server(wait_to_close_event=block_server)\n+    data = (i for i in [b'a', b'b', b'c']) \n+\n+    with server as (host, port):\n+        url = 'http://{0}:{1}/'.format(host, port)\n+        r = requests.post(url, data=data, stream=True)\n+        block_server.set() # release server block\n+\n+    assert r.status_code == 200\n+    assert r.request.headers['Transfer-Encoding'] == 'chunked'\n+\n+\n+\n+\n \n \n if __name__ == '__main__':\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#bf026e3c3109ee3d5948f674df120e97e3c3fb84", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 8 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 8 | Churn Cumulative: 2943 | Contributors (this commit): 28 | Commits (past 90d): 4 | Contributors (cumulative): 28 | DMM Complexity: None\n\nDIFF:\n@@ -1467,11 +1467,3 @@ def test_chunked_upload():\n \n     assert r.status_code == 200\n     assert r.request.headers['Transfer-Encoding'] == 'chunked'\n-\n-\n-\n-\n-\n-\n-if __name__ == '__main__':\n-    unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#0d1a779030c1b26f9decda889b3e140d89bdeef9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 11 | Files Changed: 1 | Hunks: 8 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 16 | Churn Cumulative: 123 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 1 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,10 +1,7 @@\n-#!/usr/bin/python\n-\n import threading \n import socket\n import select\n \n-\n def consume_socket_content(sock, timeout=0.5):\n     chunks = 65536\n     content = \"\"\n@@ -22,14 +19,12 @@ def consume_socket_content(sock, timeout=0.5):\n \n     return content\n \n-\n-\n class Server(threading.Thread):\n     \"\"\"Dummy server using for unit testing\"\"\"\n     WAIT_EVENT_TIMEOUT = 5\n \n     def __init__(self, handler, host='localhost', port=0, requests_to_handle=1, wait_to_close_event=None):\n-        threading.Thread.__init__(self)\n+        super(Server, self).__init__()\n \n         self.handler = handler\n         self.handler_results = []\n@@ -51,16 +46,15 @@ class Server(threading.Thread):\n             return request_content\n \n \n-        server = Server(text_response_handler, **kwargs)\n-        return server\n+        return Server(text_response_handler, **kwargs)\n \n     @classmethod\n     def basic_response_server(cls, **kwargs):\n-        server = cls.text_response_server(\n+        return cls.text_response_server(\n             \"HTTP/1.1 200 OK\\r\\n\" +\n-            \"Content-Length: 0\\r\\n\\r\\n\", **kwargs\n+            \"Content-Length: 0\\r\\n\\r\\n\", \n+            **kwargs\n         )\n-        return server\n \n     def run(self):\n         try:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#44161ac373199716c4231aa5cb5011a08d2d6ed4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 128 | Lines Deleted: 125 | Files Changed: 2 | Hunks: 4 | Methods Changed: 20 | Complexity Δ (Sum/Max): 0/11 | Churn Δ: 253 | Churn Cumulative: 1019 | Contributors (this commit): 6 | Commits (past 90d): 7 | Contributors (cumulative): 7 | DMM Complexity: None\n\nDIFF:\n@@ -0,0 +1,128 @@\n+import threading\n+import socket\n+import time\n+\n+import pytest\n+import requests\n+from testserver.server import Server\n+\n+class TestTestServer:\n+    def test_basic(self):\n+        question = b\"sucess?\"\n+        answer = b\"yeah, success\"\n+        def handler(sock):\n+            text = sock.recv(1000)\n+            assert text == question \n+            sock.send(answer)\n+        \n+        with Server(handler) as (host, port):\n+            sock = socket.socket()\n+            sock.connect((host, port))\n+            sock.send(question)\n+            text = sock.recv(1000)\n+            assert text == answer\n+            sock.close()\n+\n+    def test_server_closes(self):\n+        with Server.basic_response_server() as (host, port):\n+            sock = socket.socket()\n+            sock.connect((host, port))\n+\n+            sock.close()\n+\n+        with pytest.raises(socket.error):\n+            new_sock = socket.socket()\n+            new_sock.connect((host, port))\n+\n+    def test_text_response(self):\n+        server = Server.text_response_server(\n+            \"HTTP/1.1 200 OK\\r\\n\" + \n+            \"Content-Length: 6\\r\\n\" +\n+            \"\\r\\nroflol\"\n+        )\n+\n+        with server as (host, port):\n+            r = requests.get('http://{0}:{1}'.format(host, port))\n+\n+            assert r.status_code == 200\n+            assert r.text == 'roflol'\n+            assert r.headers['Content-Length'] == '6' \n+            \n+    def test_basic_response(self):\n+        with Server.basic_response_server() as (host, port):\n+            r = requests.get('http://{0}:{1}'.format(host, port))\n+            assert r.status_code == 200\n+            assert r.text == ''\n+            assert r.headers['Content-Length'] == '0'\n+\n+    def test_basic_waiting_server(self):\n+        block_server = threading.Event()\n+\n+        with Server.basic_response_server(wait_to_close_event=block_server) as (host, port):\n+            sock = socket.socket()\n+            sock.connect((host, port))\n+            sock.send(b'send something')\n+            time.sleep(2.5)\n+            sock.send(b'still alive')\n+            block_server.set() # release server block\n+\n+    def test_multiple_requests(self):\n+        requests_to_handle = 5\n+        \n+        server = Server.basic_response_server(requests_to_handle=requests_to_handle)\n+\n+        with server as (host, port):\n+            server_url = 'http://{0}:{1}'.format(host, port)\n+            for _ in range(requests_to_handle):\n+                r = requests.get(server_url)\n+                assert r.status_code == 200\n+\n+            # the (n+1)th request fails\n+            with pytest.raises(requests.exceptions.ConnectionError):\n+                r = requests.get(server_url)\n+\n+    def test_request_recovery(self):\n+        server = Server.basic_response_server(requests_to_handle=2)\n+        first_request = \"put your hands up in the air\"\n+        second_request = \"put your hand down in the floor\"\n+\n+        with server as address:\n+            sock1 = socket.socket()\n+            sock2 = socket.socket()\n+            \n+            sock1.connect(address)\n+            sock1.send(first_request.encode())\n+            sock1.close()\n+\n+            sock2.connect(address)\n+            sock2.send(second_request.encode())\n+            sock2.close()\n+\n+        assert server.handler_results[0] == first_request\n+        assert server.handler_results[1] == second_request\n+\n+    def test_requests_after_timeout_are_not_received(self):\n+        server = Server.basic_response_server(request_timeout=1)\n+\n+        with server as address:\n+            sock = socket.socket()\n+            sock.connect(address)\n+            time.sleep(1.5)\n+            sock.send(b\"hehehe, not received\")\n+            sock.close()\n+\n+        assert server.handler_results[0] == \"\"\n+\n+\n+    def test_request_recovery_with_bigger_timeout(self):\n+        server = Server.basic_response_server(request_timeout=3)\n+        data = \"bananadine\"\n+\n+        with server as address:\n+            sock = socket.socket() \n+            sock.connect(address)\n+            time.sleep(1.5)\n+            sock.send(data.encode())\n+            sock.close()\n+            \n+        assert server.handler_results[0] == data\n\n@@ -1,12 +1,8 @@\n # coding: utf-8\n import os\n-import threading\n-import socket\n-import time\n from io import BytesIO\n \n import pytest\n-import requests\n from requests import compat\n from requests.utils import (\n     address_in_network, dotted_netmask,\n@@ -234,124 +230,3 @@ def test_select_proxies(url, expected):\n     proxies = {'http': 'http://http.proxy',\n                'http://some.host': 'http://some.host.proxy'}\n     assert select_proxy(url, proxies) == expected\n-\n-class TestTestServer:\n-    def test_basic(self):\n-        question = b\"sucess?\"\n-        answer = b\"yeah, success\"\n-        def handler(sock):\n-            text = sock.recv(1000)\n-            assert text == question \n-            sock.send(answer)\n-        \n-        with Server(handler) as (host, port):\n-            sock = socket.socket()\n-            sock.connect((host, port))\n-            sock.send(question)\n-            text = sock.recv(1000)\n-            assert text == answer\n-            sock.close()\n-\n-    def test_server_closes(self):\n-        with Server.basic_response_server() as (host, port):\n-            sock = socket.socket()\n-            sock.connect((host, port))\n-\n-            sock.close()\n-\n-        with pytest.raises(socket.error):\n-            new_sock = socket.socket()\n-            new_sock.connect((host, port))\n-\n-    def test_text_response(self):\n-        server = Server.text_response_server(\n-            \"HTTP/1.1 200 OK\\r\\n\" + \n-            \"Content-Length: 6\\r\\n\" +\n-            \"\\r\\nroflol\"\n-        )\n-\n-        with server as (host, port):\n-            r = requests.get('http://{0}:{1}'.format(host, port))\n-\n-            assert r.status_code == 200\n-            assert r.text == 'roflol'\n-            assert r.headers['Content-Length'] == '6' \n-            \n-    def test_basic_response(self):\n-        with Server.basic_response_server() as (host, port):\n-            r = requests.get('http://{0}:{1}'.format(host, port))\n-            assert r.status_code == 200\n-            assert r.text == ''\n-            assert r.headers['Content-Length'] == '0'\n-\n-    def test_basic_waiting_server(self):\n-        block_server = threading.Event()\n-\n-        with Server.basic_response_server(wait_to_close_event=block_server) as (host, port):\n-            sock = socket.socket()\n-            sock.connect((host, port))\n-            sock.send(b'send something')\n-            time.sleep(2.5)\n-            sock.send(b'still alive')\n-            block_server.set() # release server block\n-\n-    def test_multiple_requests(self):\n-        requests_to_handle = 5\n-        \n-        server = Server.basic_response_server(requests_to_handle=requests_to_handle)\n-\n-        with server as (host, port):\n-            server_url = 'http://{0}:{1}'.format(host, port)\n-            for _ in range(requests_to_handle):\n-                r = requests.get(server_url)\n-                assert r.status_code == 200\n-\n-            # the (n+1)th request fails\n-            with pytest.raises(requests.exceptions.ConnectionError):\n-                r = requests.get(server_url)\n-\n-    def test_request_recovery(self):\n-        server = Server.basic_response_server(requests_to_handle=2)\n-        first_request = \"put your hands up in the air\"\n-        second_request = \"put your hand down in the floor\"\n-\n-        with server as address:\n-            sock1 = socket.socket()\n-            sock2 = socket.socket()\n-            \n-            sock1.connect(address)\n-            sock1.send(first_request.encode())\n-            sock1.close()\n-\n-            sock2.connect(address)\n-            sock2.send(second_request.encode())\n-            sock2.close()\n-\n-        assert server.handler_results[0] == first_request\n-        assert server.handler_results[1] == second_request\n-\n-    def test_requests_after_timeout_are_not_received(self):\n-        server = Server.basic_response_server(request_timeout=1)\n-\n-        with server as address:\n-            sock = socket.socket()\n-            sock.connect(address)\n-            time.sleep(1.5)\n-            sock.send(b\"hehehe, not received\")\n-            sock.close()\n-\n-        assert server.handler_results[0] == \"\"\n-\n-\n-    def test_request_recovery_with_bigger_timeout(self):\n-        server = Server.basic_response_server(request_timeout=3)\n-        data = \"bananadine\"\n-\n-        with server as address:\n-            sock = socket.socket() \n-            sock.connect(address)\n-            time.sleep(1.5)\n-            sock.send(data.encode())\n-            sock.close()\n-            \n-        assert server.handler_results[0] == data\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
