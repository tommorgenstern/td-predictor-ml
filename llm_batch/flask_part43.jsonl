{"custom_id": "flask#d4fec1454488687b574c545761c2869d3bb97ca6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 44 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 2 | Methods Changed: 6 | Complexity Δ (Sum/Max): 6/5 | Churn Δ: 44 | Churn Cumulative: 1681 | Contributors (this commit): 12 | Commits (past 90d): 6 | Contributors (cumulative): 17 | DMM Complexity: 1.0\n\nDIFF:\n@@ -399,3 +399,14 @@ class Blueprint(_PackageBoundObject):\n                 self.name, code_or_exception, f))\n             return f\n         return decorator\n+\n+    def register_error_handler(self, code_or_exception, f):\n+        \"\"\"Non-decorator version of the :meth:`errorhandler` error attach\n+        function, akin to the :meth:`~flask.Flask.register_error_handler`\n+        application-wide function of the :class:`~flask.Flask` object but\n+        for error handlers limited to this blueprint.\n+\n+        .. versionadded:: 0.11\n+        \"\"\"\n+        self.record_once(lambda s: s.app._register_error_handler(\n+            self.name, code_or_exception, f))\n\n@@ -296,6 +296,39 @@ class BlueprintTestCase(FlaskTestCase):\n         self.assert_equal(c.get('/backend-no').data, b'backend says no')\n         self.assert_equal(c.get('/what-is-a-sideend').data, b'application itself says no')\n \n+    def test_blueprint_specific_user_error_handling(self):\n+        class MyDecoratorException(Exception):\n+            pass\n+        class MyFunctionException(Exception):\n+            pass\n+\n+        blue = flask.Blueprint('blue', __name__)\n+\n+        @blue.errorhandler(MyDecoratorException)\n+        def my_decorator_exception_handler(e):\n+            self.assert_true(isinstance(e, MyDecoratorException))\n+            return 'boom'\n+\n+        def my_function_exception_handler(e):\n+            self.assert_true(isinstance(e, MyFunctionException))\n+            return 'bam'\n+        blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n+\n+        @blue.route('/decorator')\n+        def blue_deco_test():\n+            raise MyDecoratorException()\n+        @blue.route('/function')\n+        def blue_func_test():\n+            raise MyFunctionException()\n+\n+        app = flask.Flask(__name__)\n+        app.register_blueprint(blue)\n+\n+        c = app.test_client()\n+\n+        self.assert_equal(c.get('/decorator').data, b'boom')\n+        self.assert_equal(c.get('/function').data, b'bam')\n+\n     def test_blueprint_url_definitions(self):\n         bp = flask.Blueprint('test', __name__)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#54688b26a9562c9a9c31541dbf32e0d8ee7a5926", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 168 | Contributors (this commit): 3 | Commits (past 90d): 1 | Contributors (cumulative): 3 | DMM Complexity: 1.0\n\nDIFF:\n@@ -26,7 +26,6 @@ def parse_changelog():\n             match = re.search('^Version\\s+(.*)', line.strip())\n             if match is None:\n                 continue\n-            length = len(match.group(1))\n             version = match.group(1).strip()\n             if lineiter.next().count('-') != len(match.group(0)):\n                 continue\n@@ -60,6 +59,7 @@ def parse_date(string):\n \n def set_filename_version(filename, version_number, pattern):\n     changed = []\n+\n     def inject_version(match):\n         before, old, after = match.groups()\n         changed.append(True)\n@@ -133,7 +133,8 @@ def main():\n     if version in tags:\n         fail('Version \"%s\" is already tagged', version)\n     if release_date.date() != date.today():\n-        fail('Release date is not today (%s != %s)')\n+        fail('Release date is not today (%s != %s)',\n+             release_date.date(), date.today())\n \n     if not git_is_clean():\n         fail('You have uncommitted changes in git')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#9554844e2ac3e50872aab6f7b54c277ff582cd13", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 29 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 36 | Churn Cumulative: 1687 | Contributors (this commit): 28 | Commits (past 90d): 3 | Contributors (cumulative): 28 | DMM Complexity: 1.0\n\nDIFF:\n@@ -656,6 +656,29 @@ def get_root_path(import_name):\n     return os.path.dirname(os.path.abspath(filepath))\n \n \n+def _matching_loader_thinks_module_is_package(loader, mod_name):\n+    \"\"\"Given the loader that loaded a module and the module this function\n+    attempts to figure out if the given module is actually a package.\n+    \"\"\"\n+    # If the loader can tell us if something is a package, we can\n+    # directly ask the loader.\n+    if hasattr(loader, 'is_package'):\n+        return loader.is_package(mod_name)\n+    # importlib's namespace loaders do not have this functionality but\n+    # all the modules it loads are packages, so we can take advantage of\n+    # this information.\n+    elif (loader.__module__ == '_frozen_importlib' and\n+          loader.__name__ == 'NamespaceLoader'):\n+        return True\n+    # Otherwise we need to fail with an error that explains what went\n+    # wrong.\n+    raise AttributeError(\n+        ('%s.is_package() method is missing but is required by Flask of '\n+         'PEP 302 import hooks.  If you do not use import hooks and '\n+         'you encounter this error please file a bug against Flask.') %\n+        loader.__class__.__name__)\n+\n+\n def find_package(import_name):\n     \"\"\"Finds a package and returns the prefix (or None if the package is\n     not installed) as well as the folder that contains the package or\n@@ -685,14 +708,13 @@ def find_package(import_name):\n             __import__(import_name)\n             filename = sys.modules[import_name].__file__\n         package_path = os.path.abspath(os.path.dirname(filename))\n-        # package_path ends with __init__.py for a package\n-        if hasattr(loader, 'is_package'):\n-            if loader.is_package(root_mod_name):\n+\n+        # In case the root module is a pcakage we need to chop of the\n+        # rightmost part.  This needs to go through a helper function\n+        # because of python 3.3 namespace packages.\n+        if _matching_loader_thinks_module_is_package(\n+                loader, root_mod_name):\n             package_path = os.path.dirname(package_path)\n-        else:\n-            raise AttributeError(\n-                ('%s.is_package() method is missing but is '\n-                 'required by Flask of PEP 302 import hooks') % loader.__class__.__name__)\n \n     site_parent, site_folder = os.path.split(package_path)\n     py_prefix = os.path.abspath(sys.prefix)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#a293b99b219c13ea94b33a2470a545e07c73b804", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 1691 | Contributors (this commit): 28 | Commits (past 90d): 4 | Contributors (cumulative): 28 | DMM Complexity: None\n\nDIFF:\n@@ -667,8 +667,8 @@ def _matching_loader_thinks_module_is_package(loader, mod_name):\n     # importlib's namespace loaders do not have this functionality but\n     # all the modules it loads are packages, so we can take advantage of\n     # this information.\n-    elif (loader.__module__ == '_frozen_importlib' and\n-          loader.__name__ == 'NamespaceLoader'):\n+    elif (loader.__class__.__module__ == '_frozen_importlib' and\n+          loader.__class__.__name__ == 'NamespaceLoader'):\n         return True\n     # Otherwise we need to fail with an error that explains what went\n     # wrong.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#d4b3d16c142e2189c6faf8f784a195e7f827c596", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 35 | Lines Deleted: 7 | Files Changed: 3 | Hunks: 9 | Methods Changed: 7 | Complexity Δ (Sum/Max): 4/2 | Churn Δ: 42 | Churn Cumulative: 5720 | Contributors (this commit): 64 | Commits (past 90d): 13 | Contributors (cumulative): 77 | DMM Complexity: 0.26666666666666666\n\nDIFF:\n@@ -118,6 +118,9 @@ class Flask(_PackageBoundObject):\n        The `instance_path` and `instance_relative_config` parameters were\n        added.\n \n+    .. versionadded:: 1.0\n+       The `root_path` parameter was added.\n+\n     :param import_name: the name of the application package\n     :param static_url_path: can be used to specify a different path for the\n                             static files on the web.  Defaults to the name\n@@ -137,6 +140,11 @@ class Flask(_PackageBoundObject):\n                                      for loading the config are assumed to\n                                      be relative to the instance path instead\n                                      of the application root.\n+    :param root_path: Flask by default will automatically calculate the path\n+                      to the root of the application.  In certain situations\n+                      this cannot be achieved (for instance if the package\n+                      is a Python 3 namespace package) and needs to be\n+                      manually defined.\n     \"\"\"\n \n     #: The class that is used for request objects.  See :class:`~flask.Request`\n@@ -327,9 +335,11 @@ class Flask(_PackageBoundObject):\n \n     def __init__(self, import_name, static_path=None, static_url_path=None,\n                  static_folder='static', template_folder='templates',\n-                 instance_path=None, instance_relative_config=False):\n+                 instance_path=None, instance_relative_config=False,\n+                 root_path=None):\n         _PackageBoundObject.__init__(self, import_name,\n-                                     template_folder=template_folder)\n+                                     template_folder=template_folder,\n+                                     root_path=root_path)\n         if static_path is not None:\n             from warnings import warn\n             warn(DeprecationWarning('static_path is now called '\n\n@@ -91,8 +91,10 @@ class Blueprint(_PackageBoundObject):\n \n     def __init__(self, name, import_name, static_folder=None,\n                  static_url_path=None, template_folder=None,\n-                 url_prefix=None, subdomain=None, url_defaults=None):\n-        _PackageBoundObject.__init__(self, import_name, template_folder)\n+                 url_prefix=None, subdomain=None, url_defaults=None,\n+                 root_path=None):\n+        _PackageBoundObject.__init__(self, import_name, template_folder,\n+                                     root_path=root_path)\n         self.name = name\n         self.url_prefix = url_prefix\n         self.subdomain = subdomain\n\n@@ -650,7 +650,20 @@ def get_root_path(import_name):\n     else:\n         # Fall back to imports.\n         __import__(import_name)\n-        filepath = sys.modules[import_name].__file__\n+        mod = sys.modules[import_name]\n+        filepath = getattr(mod, '__file__', None)\n+\n+        # If we don't have a filepath it might be because we are a\n+        # namespace package.  In this case we pick the root path from the\n+        # first module that is contained in our package.\n+        if filepath is None:\n+            raise RuntimeError('No root path can be found for the provided '\n+                               'module \"%s\".  This can happen because the '\n+                               'module came from an import hook that does '\n+                               'not provide file name information or because '\n+                               'it\\'s a namespace package.  In this case '\n+                               'the root path needs to be explictly '\n+                               'provided.' % import_name)\n \n     # filepath is import_name.py for a module, or __init__.py for a package.\n     return os.path.dirname(os.path.abspath(filepath))\n@@ -762,7 +775,7 @@ class locked_cached_property(object):\n \n class _PackageBoundObject(object):\n \n-    def __init__(self, import_name, template_folder=None):\n+    def __init__(self, import_name, template_folder=None, root_path=None):\n         #: The name of the package or module.  Do not change this once\n         #: it was set by the constructor.\n         self.import_name = import_name\n@@ -771,8 +784,11 @@ class _PackageBoundObject(object):\n         #: exposed.\n         self.template_folder = template_folder\n \n+        if root_path is None:\n+            root_path = get_root_path(self.import_name)\n+\n         #: Where is the app root located?\n-        self.root_path = get_root_path(self.import_name)\n+        self.root_path = root_path\n \n         self._static_folder = None\n         self._static_url_path = None\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#fbda3f94baa6d7dba8f773309121284c6e6c5a6d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 760 | Contributors (this commit): 13 | Commits (past 90d): 5 | Contributors (cumulative): 18 | DMM Complexity: None\n\nDIFF:\n@@ -119,7 +119,7 @@ def dumps(obj, **kwargs):\n     This function can return ``unicode`` strings or ascii-only bytestrings by\n     default which coerce into unicode strings automatically.  That behavior by\n     default is controlled by the ``JSON_AS_ASCII`` configuration variable\n-    and can be overriden by the simplejson ``ensure_ascii`` parameter.\n+    and can be overridden by the simplejson ``ensure_ascii`` parameter.\n     \"\"\"\n     _dump_arg_defaults(kwargs)\n     encoding = kwargs.pop('encoding', None)\n\n@@ -127,7 +127,7 @@ class Request(RequestBase):\n         parsing fails the :meth:`on_json_loading_failed` method on the\n         request object will be invoked.  By default this function will\n         only load the json data if the mimetype is ``application/json``\n-        but this can be overriden by the `force` parameter.\n+        but this can be overridden by the `force` parameter.\n \n         :param force: if set to `True` the mimetype is ignored.\n         :param silent: if set to `True` this method will fail silently\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#15d8af52dbb091f198664bedc5dfc3d5d9ffdea0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 3415 | Contributors (this commit): 40 | Commits (past 90d): 6 | Contributors (cumulative): 40 | DMM Complexity: None\n\nDIFF:\n@@ -874,7 +874,7 @@ class Flask(_PackageBoundObject):\n         return self.session_interface.make_null_session(self)\n \n     def register_module(self, module, **options):\n-        \"\"\"Registers a module with this application.  The keyword argument\n+        \"\"\"Registers a module with this application.  The keyword arguments\n         of this function are the same as the ones for the constructor of the\n         :class:`Module` class and will override the values of the module if\n         provided.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#671c67aac96ae2cdf9c554ba4e52c167862be6fe", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 22 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 5 | Methods Changed: 5 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 22 | Churn Cumulative: 599 | Contributors (this commit): 6 | Commits (past 90d): 2 | Contributors (cumulative): 6 | DMM Complexity: 1.0\n\nDIFF:\n@@ -51,6 +51,13 @@ class SessionMixin(object):\n     #: The default mixin implementation just hardcodes `True` in.\n     modified = True\n \n+    #: the accessed variable indicates whether or not the session object has\n+    #: been accessed in that request. This allows flask to append a `Vary:\n+    #: Cookie` header to the response if the session is being accessed. This\n+    #: allows caching proxy servers, like Varnish, to use both the URL and the\n+    #: session cookie as keys when caching pages, preventing multiple users\n+    #: from being served the same cache.\n+    accessed = True\n \n class TaggedJSONSerializer(object):\n     \"\"\"A customized JSON serializer that supports a few extra types that\n@@ -112,9 +119,18 @@ class SecureCookieSession(CallbackDict, SessionMixin):\n     def __init__(self, initial=None):\n         def on_update(self):\n             self.modified = True\n+            self.accessed = True\n         CallbackDict.__init__(self, initial, on_update)\n         self.modified = False\n+        self.accessed = False\n \n+    def __getitem__(self, key):\n+        self.accessed = True\n+        return super(SecureCookieSession, self).__getitem__(key)\n+\n+    def get(self, key, default=None):\n+        self.accessed = True\n+        return super(SecureCookieSession, self).get(key, default)\n \n class NullSession(SecureCookieSession):\n     \"\"\"Class used to generate nicer error messages if sessions are not\n@@ -334,6 +350,12 @@ class SecureCookieSessionInterface(SessionInterface):\n         domain = self.get_cookie_domain(app)\n         path = self.get_cookie_path(app)\n \n+        if session.accessed:\n+\n+            response.headers.add('Vary', 'Cookie')\n+\n+        else:\n+\n             # Delete case.  If there is no session we bail early.\n             # If the session was modified to be empty we remove the\n             # whole cookie.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#5935ee495c3e51d26fa2b33de09d532b310cd263", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 50 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 5 | Complexity Δ (Sum/Max): 14/14 | Churn Δ: 50 | Churn Cumulative: 2456 | Contributors (this commit): 12 | Commits (past 90d): 3 | Contributors (cumulative): 12 | DMM Complexity: 1.0\n\nDIFF:\n@@ -396,6 +396,56 @@ class BasicFunctionalityTestCase(FlaskTestCase):\n         app.config['SESSION_REFRESH_EACH_REQUEST'] = False\n         run_test(expect_header=False)\n \n+    def test_session_vary_cookie(self):\n+\n+        app = flask.Flask(__name__)\n+        app.secret_key = 'testkey'\n+\n+        @app.route('/set-session')\n+        def set_session():\n+\n+            flask.session['test'] = 'test'\n+            return ''\n+\n+        @app.route('/get-session')\n+        def get_session():\n+\n+            s = flask.session.get('test')\n+            return ''\n+\n+        @app.route('/get-session-with-dictionary')\n+        def get_session_with_dictionary():\n+\n+            s = flask.session['test']\n+            return ''\n+\n+        @app.route('/no-vary-header')\n+        def no_vary_header():\n+\n+            return ''\n+\n+        c = app.test_client()\n+\n+        rv = c.get('/set-session')\n+\n+        self.assert_in('Vary', rv.headers)\n+        self.assert_equal('Cookie', rv.headers['Vary'])\n+\n+        rv = c.get('/get-session')\n+\n+        self.assert_in('Vary', rv.headers)\n+        self.assert_equal('Cookie', rv.headers['Vary'])\n+\n+        rv = c.get('/get-session-with-dictionary')\n+\n+        self.assert_in('Vary', rv.headers)\n+        self.assert_equal('Cookie', rv.headers['Vary'])\n+\n+        rv = c.get('/no-vary-header')\n+\n+        self.assert_not_in('Vary', rv.headers)\n+\n+\n     def test_flashes(self):\n         app = flask.Flask(__name__)\n         app.secret_key = 'testkey'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#7503bde2235c28853d4c4e53087090d8c42041aa", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 224 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 2 | Methods Changed: 8 | Complexity Δ (Sum/Max): 39/39 | Churn Δ: 224 | Churn Cumulative: 490 | Contributors (this commit): 12 | Commits (past 90d): 2 | Contributors (cumulative): 13 | DMM Complexity: 0.7463768115942029\n\nDIFF:\n@@ -0,0 +1,220 @@\n+import os\n+import sys\n+from threading import Lock\n+from optparse import OptionParser\n+\n+from werkzeug.serving import run_simple\n+\n+from ._compat import iteritems\n+\n+\n+def find_best_app(module):\n+    \"\"\"Given a module instance this tries to find the best possible application\n+    in the module or raises a RuntimeError.\n+    \"\"\"\n+    from flask import Flask\n+\n+    # The app name wins, even if it's not a flask object.\n+    app = getattr(module, 'app', None)\n+    if app is not None and callable(app):\n+        return app\n+\n+    # Otherwise find the first object named Flask\n+    matches = []\n+    for key, value in iteritems(module.__dict__):\n+        if isinstance(value, Flask):\n+            matches.append(value)\n+\n+    if matches:\n+        if len(matches) > 1:\n+            raise RuntimeError('More than one possible Flask application '\n+                               'found in module \"%s\", none of which are called '\n+                               '\"app\".  Be explicit!' % module)\n+        return matches[0]\n+\n+    raise RuntimeError('Failed to find application in module \"%s\".  Are '\n+                       'you sure it contains a Flask application?  Maybe '\n+                       'you wrapped it in a WSGI middleware or you are '\n+                       'using a factory function.' % module)\n+\n+\n+def prepare_exec_for_file(filename):\n+    module = []\n+\n+    # Chop off file extensions or package markers\n+    if filename.endswith('.py'):\n+        filename = filename[:-3]\n+    elif os.path.split(filename)[1] == '__init__.py':\n+        filename = os.path.dirname(filename)\n+    filename = os.path.realpath(filename)\n+\n+    dirpath = filename\n+    while 1:\n+        dirpath, extra = os.path.split(dirpath)\n+        module.append(extra)\n+        if not os.path.isfile(os.path.join(dirpath, '__init__.py')):\n+            break\n+\n+    sys.path.insert(0, dirpath)\n+    return '.'.join(module[::-1])\n+\n+\n+def locate_app(app_id, debug=None):\n+    \"\"\"Attempts to locate the application.\"\"\"\n+    if ':' in app_id:\n+        module, app_obj = app_id.split(':', 1)\n+    else:\n+        module = app_id\n+        app_obj = None\n+\n+    __import__(module)\n+    mod = sys.modules[module]\n+    if app_obj is None:\n+        app = find_best_app(mod)\n+    else:\n+        app = getattr(mod, app_obj, None)\n+        if app is None:\n+            raise RuntimeError('Failed to find application in module \"%s\"'\n+                               % module)\n+    if debug is not None:\n+        app.debug = debug\n+    return app\n+\n+\n+class DispatchingApp(object):\n+    \"\"\"Special applicationt that dispatches to a flask application which\n+    is imported by name on first request.  This is safer than importing\n+    the application upfront because it means that we can forward all\n+    errors for import problems into the browser as error.\n+    \"\"\"\n+\n+    def __init__(self, app_id, debug=None, use_eager_loading=False):\n+        self.app_id = app_id\n+        self.app = None\n+        self.debug = debug\n+        self._lock = Lock()\n+        if use_eager_loading:\n+            self._load_unlocked()\n+\n+    def _load_unlocked(self):\n+        self.app = rv = locate_app(self.app_id, self.debug)\n+        return rv\n+\n+    def __call__(self, environ, start_response):\n+        if self.app is not None:\n+            return self.app(environ, start_response)\n+        with self._lock:\n+            if self.app is not None:\n+                rv = self.app\n+            else:\n+                rv = self._load_unlocked()\n+            return rv(environ, start_response)\n+\n+\n+def run_application(app_id, host='127.0.0.1', port=5000, debug=None,\n+                    use_reloader=False, use_debugger=False,\n+                    use_eager_loading=None, magic_app_id=True):\n+    \"\"\"Useful function to start a Werkzeug server for an application that\n+    is known by it's import name.  By default the app ID can also be a\n+    full file name in which case Flask attempts to reconstruct the import\n+    name from it and do the right thing.\n+\n+    :param app_id: the import name of the application module.  If a colon\n+                   is provided, everything afterwards is the application\n+                   object name.  In case the magic app id is enabled this\n+                   can also be a filename.\n+    :param host: the host to bind to.\n+    :param port: the port to bind to.\n+    :param debug: if set to something other than None then the application's\n+                  debug flag will be set to this.\n+    :param use_reloader: enables or disables the reloader.\n+    :param use_debugger: enables or disables the builtin debugger.\n+    :param use_eager_loading: enables or disables eager loading.  This is\n+                              normally conditional to the reloader.\n+    :param magic_app_id: if this is enabled then the app id can also be a\n+                         filename instead of an import module and Flask\n+                         will attempt to reconstruct the import name.\n+    \"\"\"\n+    if magic_app_id:\n+        if os.path.isfile(app_id) or os.sep in app_id or \\\n+           os.altsep is not None and os.altsep in app_id:\n+            app_id = prepare_exec_for_file(app_id)\n+\n+    if use_eager_loading is None:\n+        use_eager_loading = not use_reloader\n+\n+    # Extra startup messages.  This depends a but on Werkzeug internals to\n+    # not double execute when the reloader kicks in.\n+    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n+        print ' * Serving Flask app \"%s\"' % app_id\n+        if debug is not None:\n+            print ' * Forcing debug %s' % (debug and 'on' or 'off')\n+\n+    app = DispatchingApp(app_id, debug, use_eager_loading)\n+    run_simple(host, port, app, use_reloader=use_reloader,\n+               use_debugger=use_debugger)\n+\n+\n+def main(as_module=False):\n+    this_module = __package__ + '.run'\n+\n+    if as_module:\n+        name = 'python -m ' + this_module\n+    else:\n+        name = 'flask-run'\n+\n+    parser = OptionParser(usage='%prog [options] module', prog=name)\n+    parser.add_option('--debug', action='store_true',\n+                      dest='debug', help='Flip debug flag on.  If enabled '\n+                      'this also affects debugger and reloader defaults.')\n+    parser.add_option('--no-debug', action='store_false',\n+                      dest='debug', help='Flip debug flag off.')\n+    parser.add_option('--host', default='127.0.0.1',\n+                      help='The host to bind on. (defaults to 127.0.0.1)')\n+    parser.add_option('--port', default=5000,\n+                      help='The port to bind on. (defaults to 5000)')\n+    parser.add_option('--with-reloader', action='store_true',\n+                      dest='with_reloader',\n+                      help='Enable the reloader.')\n+    parser.add_option('--without-reloader', action='store_false',\n+                      dest='with_reloader',\n+                      help='Disable the reloader.')\n+    parser.add_option('--with-debugger', action='store_true',\n+                      dest='with_debugger',\n+                      help='Enable the debugger.')\n+    parser.add_option('--without-debugger', action='store_false',\n+                      dest='with_debugger',\n+                      help='Disable the debugger.')\n+    parser.add_option('--with-eager-loading', action='store_true',\n+                      dest='with_eager_loading',\n+                      help='Force enable the eager-loading.  This makes the '\n+                      'application load immediately but makes development '\n+                      'flows harder.  It\\'s not recommended to enable eager '\n+                      'loading when the reloader is enabled as it can lead '\n+                      'to unexpected crashes.')\n+    parser.add_option('--without-eager-loading', action='store_false',\n+                      dest='with_eager_loading',\n+                      help='Disable the eager-loading.')\n+    opts, args = parser.parse_args()\n+    if len(args) != 1:\n+        parser.error('Expected exactly one argument which is the import '\n+                     'name of the application.')\n+\n+    if opts.with_debugger is None:\n+        opts.with_debugger = opts.debug\n+    if opts.with_reloader is None:\n+        opts.with_reloader = opts.debug\n+\n+    # This module is always executed as \"python -m flask.run\" and as such\n+    # we need to ensure that we restore the actual command line so that\n+    # the reloader can properly operate.\n+    sys.argv = ['-m', this_module] + sys.argv[1:]\n+\n+    run_application(args[0], opts.host, opts.port, debug=opts.debug,\n+                    use_reloader=opts.with_reloader,\n+                    use_debugger=opts.with_debugger,\n+                    use_eager_loading=opts.with_eager_loading)\n+\n+\n+if __name__ == '__main__':\n+    main(as_module=True)\n\n@@ -106,6 +106,10 @@ setup(\n         'Topic :: Internet :: WWW/HTTP :: Dynamic Content',\n         'Topic :: Software Development :: Libraries :: Python Modules'\n     ],\n+    entry_points='''\n+        [console_scripts]\n+        flask-run=flask.run:main\n+    ''',\n     cmdclass={'audit': run_audit},\n     test_suite='flask.testsuite.suite'\n )\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#e46bca4051e51f3812d4a0b25f60f7b7959668c2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 5 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 19 | Churn Cumulative: 239 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 1 | DMM Complexity: 0.8888888888888888\n\nDIFF:\n@@ -113,7 +113,8 @@ class DispatchingApp(object):\n \n def run_application(app_id, host='127.0.0.1', port=5000, debug=None,\n                     use_reloader=False, use_debugger=False,\n-                    use_eager_loading=None, magic_app_id=True):\n+                    use_eager_loading=None, magic_app_id=True,\n+                    **options):\n     \"\"\"Useful function to start a Werkzeug server for an application that\n     is known by it's import name.  By default the app ID can also be a\n     full file name in which case Flask attempts to reconstruct the import\n@@ -134,6 +135,10 @@ def run_application(app_id, host='127.0.0.1', port=5000, debug=None,\n     :param magic_app_id: if this is enabled then the app id can also be a\n                          filename instead of an import module and Flask\n                          will attempt to reconstruct the import name.\n+    :param options: the options to be forwarded to the underlying\n+                    Werkzeug server.  See\n+                    :func:`werkzeug.serving.run_simple` for more\n+                    information.\n     \"\"\"\n     if magic_app_id:\n         if os.path.isfile(app_id) or os.sep in app_id or \\\n@@ -152,7 +157,7 @@ def run_application(app_id, host='127.0.0.1', port=5000, debug=None,\n \n     app = DispatchingApp(app_id, debug, use_eager_loading)\n     run_simple(host, port, app, use_reloader=use_reloader,\n-               use_debugger=use_debugger)\n+               use_debugger=use_debugger, **options)\n \n \n def main(as_module=False):\n@@ -195,6 +200,13 @@ def main(as_module=False):\n     parser.add_option('--without-eager-loading', action='store_false',\n                       dest='with_eager_loading',\n                       help='Disable the eager-loading.')\n+    parser.add_option('--with-threads', action='store_true',\n+                      dest='with_threads',\n+                      help='Enable multi-threading to handle multiple '\n+                      'requests concurrently.')\n+    parser.add_option('--without-threads', action='store_false',\n+                      dest='with_threads',\n+                      help='Disables multi-threading. (default)')\n     opts, args = parser.parse_args()\n     if len(args) != 1:\n         parser.error('Expected exactly one argument which is the import '\n@@ -213,7 +225,8 @@ def main(as_module=False):\n     run_application(args[0], opts.host, opts.port, debug=opts.debug,\n                     use_reloader=opts.with_reloader,\n                     use_debugger=opts.with_debugger,\n-                    use_eager_loading=opts.with_eager_loading)\n+                    use_eager_loading=opts.with_eager_loading,\n+                    threaded=opts.with_threads)\n \n \n if __name__ == '__main__':\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#1b06c8a41119f8c93078e85f6474cb85d7e30b43", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 29 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 29 | Churn Cumulative: 268 | Contributors (this commit): 1 | Commits (past 90d): 4 | Contributors (cumulative): 2 | DMM Complexity: 0.0\n\nDIFF:\n@@ -0,0 +1,15 @@\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+    flask.__main__\n+    ~~~~~~~~~~~~~~\n+\n+    Alias for flask.run for the command line.\n+\n+    :copyright: (c) 2014 by Armin Ronacher.\n+    :license: BSD, see LICENSE for more details.\n+\"\"\"\n+\n+\n+if __name__ == '__main__':\n+    from run import main\n+    main(as_module=True)\n\n@@ -1,3 +1,14 @@\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+    flask.run\n+    ~~~~~~~~~\n+\n+    A simple command line application to run flask apps.\n+\n+    :copyright: (c) 2014 by Armin Ronacher.\n+    :license: BSD, see LICENSE for more details.\n+\"\"\"\n+\n import os\n import sys\n from threading import Lock\n@@ -164,6 +175,9 @@ def main(as_module=False):\n     this_module = __package__ + '.run'\n \n     if as_module:\n+        if sys.version_info >= (2, 7):\n+            name = 'python -m ' + this_module.rsplit('.', 1)[0]\n+        else:\n             name = 'python -m ' + this_module\n     else:\n         name = 'flask-run'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#e21afed0bba82668c6e4f5f433d0ccfcf54b3577", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 6 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 12 | Churn Cumulative: 265 | Contributors (this commit): 2 | Commits (past 90d): 4 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -30,7 +30,7 @@ def find_best_app(module):\n     if app is not None and callable(app):\n         return app\n \n-    # Otherwise find the first object named Flask\n+    # Otherwise find exactly one Flask instance, or fail.\n     matches = []\n     for key, value in iteritems(module.__dict__):\n         if isinstance(value, Flask):\n@@ -52,7 +52,7 @@ def find_best_app(module):\n def prepare_exec_for_file(filename):\n     module = []\n \n-    # Chop off file extensions or package markers\n+    # Chop off file extensions or package markers.\n     if filename.endswith('.py'):\n         filename = filename[:-3]\n     elif os.path.split(filename)[1] == '__init__.py':\n@@ -93,10 +93,10 @@ def locate_app(app_id, debug=None):\n \n \n class DispatchingApp(object):\n-    \"\"\"Special applicationt that dispatches to a flask application which\n+    \"\"\"Special application that dispatches to a flask application which\n     is imported by name on first request.  This is safer than importing\n     the application up front because it means that we can forward all\n-    errors for import problems into the browser as error.\n+    errors for import problems into the browser as errors.\n     \"\"\"\n \n     def __init__(self, app_id, debug=None, use_eager_loading=False):\n@@ -127,7 +127,7 @@ def run_application(app_id, host='127.0.0.1', port=5000, debug=None,\n                     use_eager_loading=None, magic_app_id=True,\n                     **options):\n     \"\"\"Useful function to start a Werkzeug server for an application that\n-    is known by it's import name.  By default the app ID can also be a\n+    is known by its import name.  By default the app ID can also be a\n     full file name in which case Flask attempts to reconstruct the import\n     name from it and do the right thing.\n \n@@ -159,7 +159,7 @@ def run_application(app_id, host='127.0.0.1', port=5000, debug=None,\n     if use_eager_loading is None:\n         use_eager_loading = not use_reloader\n \n-    # Extra startup messages.  This depends a but on Werkzeug internals to\n+    # Extra startup messages.  This depends a bit on Werkzeug internals to\n     # not double execute when the reloader kicks in.\n     if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n         print ' * Serving Flask app \"%s\"' % app_id\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#52fa195d459a70f8ef73e954b20a9512b2f5001b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 1916 | Contributors (this commit): 29 | Commits (past 90d): 8 | Contributors (cumulative): 33 | DMM Complexity: None\n\nDIFF:\n@@ -77,7 +77,7 @@ def with_metaclass(meta, *bases):\n # breaks the __exit__ function in a very peculiar way.  This is currently\n # true for pypy 2.2.1 for instance.  The second level of exception blocks\n # is necessary because pypy seems to forget to check if an exception\n-# happend until the next bytecode instruction?\n+# happened until the next bytecode instruction?\n BROKEN_PYPY_CTXMGR_EXIT = False\n if hasattr(sys, 'pypy_version_info'):\n     class _Mgr(object):\n\n@@ -662,7 +662,7 @@ def get_root_path(import_name):\n                                'module came from an import hook that does '\n                                'not provide file name information or because '\n                                'it\\'s a namespace package.  In this case '\n-                               'the root path needs to be explictly '\n+                               'the root path needs to be explicitly '\n                                'provided.' % import_name)\n \n     # filepath is import_name.py for a module, or __init__.py for a package.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#b5e78425be985eeec4c91ea8277368a9fae9411a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 373 | Contributors (this commit): 6 | Commits (past 90d): 2 | Contributors (cumulative): 6 | DMM Complexity: None\n\nDIFF:\n@@ -244,7 +244,7 @@ latex_additional_files = ['flaskstyle.sty', 'logo.pdf']\n #epub_tocdepth = 3\n \n intersphinx_mapping = {\n-    'http://docs.python.org/dev': None,\n+    'https://docs.python.org/dev': None,\n     'http://werkzeug.pocoo.org/docs/': None,\n     'http://www.sqlalchemy.org/docs/': None,\n     'http://wtforms.simplecodes.com/docs/0.5/': None,\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#0ac492a0acda40208e6c613644fe9e779dc3d937", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 4 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 9 | Churn Cumulative: 279 | Contributors (this commit): 12 | Commits (past 90d): 2 | Contributors (cumulative): 12 | DMM Complexity: 0.0\n\nDIFF:\n@@ -41,6 +41,7 @@ Links\n from __future__ import print_function\n from setuptools import Command, setup\n \n+\n class run_audit(Command):\n     \"\"\"Audits source code using PyFlakes for following issues:\n         - Names which are used but not defined or used before they are defined.\n@@ -56,7 +57,8 @@ class run_audit(Command):\n         pass\n \n     def run(self):\n-        import os, sys\n+        import os\n+        import sys\n         try:\n             import pyflakes.scripts.pyflakes as flakes\n         except ImportError:\n@@ -93,7 +95,8 @@ setup(\n     install_requires=[\n         'Werkzeug>=0.7',\n         'Jinja2>=2.4',\n-        'itsdangerous>=0.21'\n+        'itsdangerous>=0.21',\n+        'click',\n     ],\n     classifiers=[\n         'Development Status :: 4 - Beta',\n@@ -108,7 +111,7 @@ setup(\n     ],\n     entry_points='''\n         [console_scripts]\n-        flask-run=flask.run:main\n+        flask=flask.cli:main\n     ''',\n     cmdclass={'audit': run_audit},\n     test_suite='flask.testsuite.suite'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#3bdb90f06b9d3167320180d4a5055dcd949bf72f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 391 | Lines Deleted: 250 | Files Changed: 4 | Hunks: 11 | Methods Changed: 34 | Complexity Δ (Sum/Max): 25/62 | Churn Δ: 641 | Churn Cumulative: 4336 | Contributors (this commit): 41 | Commits (past 90d): 15 | Contributors (cumulative): 44 | DMM Complexity: 1.0\n\nDIFF:\n@@ -11,5 +11,5 @@\n \n \n if __name__ == '__main__':\n-    from run import main\n+    from cli import main\n     main(as_module=True)\n\n@@ -34,6 +34,7 @@ from .templating import DispatchingJinjaLoader, Environment, \\\n      _default_template_ctx_processor\n from .signals import request_started, request_finished, got_request_exception, \\\n      request_tearing_down, appcontext_tearing_down\n+from .cli import make_default_cli\n from ._compat import reraise, string_types, text_type, integer_types\n \n # a lock used for logger initialization\n@@ -476,6 +477,12 @@ class Flask(_PackageBoundObject):\n             None: [_default_template_ctx_processor]\n         }\n \n+        #: A list of shell context processor functions that should be run\n+        #: when a shell context is created.\n+        #:\n+        #: .. versionadded:: 1.0\n+        self.shell_context_processors = []\n+\n         #: all the attached blueprints in a dictionary by name.  Blueprints\n         #: can be attached multiple times so this dictionary does not tell\n         #: you how often they got attached.\n@@ -531,6 +538,14 @@ class Flask(_PackageBoundObject):\n                               endpoint='static',\n                               view_func=self.send_static_file)\n \n+        #: The click command line context for this application.  Commands\n+        #: registered here show up in the ``flask`` command once the\n+        #: application has been discovered.  The default commands are\n+        #: provided by Flask itself and can be overridden.\n+        #:\n+        #: This is an instance of a :class:`click.Group` object.\n+        self.cli = make_default_cli(self)\n+\n     def _get_error_handlers(self):\n         from warnings import warn\n         warn(DeprecationWarning('error_handlers is deprecated, use the '\n@@ -748,6 +763,18 @@ class Flask(_PackageBoundObject):\n         # existing views.\n         context.update(orig_ctx)\n \n+    def make_shell_context(self):\n+        \"\"\"Returns the shell context for an interactive shell for this\n+        application.  This runs all the registered shell context\n+        processors.\n+\n+        .. versionadded:: 1.0\n+        \"\"\"\n+        rv = {'app': self, 'g': g}\n+        for processor in self.shell_context_processors:\n+            rv.update(processor())\n+        return rv\n+\n     def run(self, host=None, port=None, debug=None, **options):\n         \"\"\"Runs the application on a local development server.  If the\n         :attr:`debug` flag is set the server will automatically reload\n@@ -758,6 +785,11 @@ class Flask(_PackageBoundObject):\n         ``use_evalex=False`` as parameter.  This will keep the debugger's\n         traceback screen active, but disable code execution.\n \n+        It is not recommended to use this function for development with\n+        automatic reloading as this is badly supported.  Instead you should\n+        be using the ``flask`` command line script's ``runserver``\n+        support.\n+\n         .. admonition:: Keep in Mind\n \n            Flask will suppress any server error with a generic error page\n@@ -1325,6 +1357,15 @@ class Flask(_PackageBoundObject):\n         self.template_context_processors[None].append(f)\n         return f\n \n+    @setupmethod\n+    def shell_context_processor(self, f):\n+        \"\"\"Registers a shell context processor function.\n+\n+        .. versionadded:: 1.0\n+        \"\"\"\n+        self.shell_context_processors.append(f)\n+        return f\n+\n     @setupmethod\n     def url_value_preprocessor(self, f):\n         \"\"\"Registers a function as URL value preprocessor for all view\n@@ -1609,7 +1650,8 @@ class Flask(_PackageBoundObject):\n             # some extra logic involved when creating these objects with\n             # specific values (like default content type selection).\n             if isinstance(rv, (text_type, bytes, bytearray)):\n-                rv = self.response_class(rv, headers=headers, status=status_or_headers)\n+                rv = self.response_class(rv, headers=headers,\n+                                         status=status_or_headers)\n                 headers = status_or_headers = None\n             else:\n                 rv = self.response_class.force_type(rv, request.environ)\n@@ -1624,7 +1666,6 @@ class Flask(_PackageBoundObject):\n \n         return rv\n \n-\n     def create_url_adapter(self, request):\n         \"\"\"Creates a URL adapter for the given request.  The URL adapter\n         is created at a point where the request context is not yet set up\n\n@@ -0,0 +1,347 @@\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+    flask.run\n+    ~~~~~~~~~\n+\n+    A simple command line application to run flask apps.\n+\n+    :copyright: (c) 2014 by Armin Ronacher.\n+    :license: BSD, see LICENSE for more details.\n+\"\"\"\n+\n+import os\n+import sys\n+from threading import Lock\n+from contextlib import contextmanager\n+\n+import click\n+\n+from ._compat import iteritems\n+\n+\n+class NoAppException(click.UsageError):\n+    \"\"\"Raised if an application cannot be found or loaded.\"\"\"\n+\n+\n+def find_best_app(module):\n+    \"\"\"Given a module instance this tries to find the best possible\n+    application in the module or raises an exception.\n+    \"\"\"\n+    from . import Flask\n+\n+    # Search for the most common names first.\n+    for attr_name in 'app', 'application':\n+        app = getattr(module, attr_name, None)\n+        if app is not None and isinstance(app, Flask):\n+            return app\n+\n+    # Otherwise find the only object that is a Flask instance.\n+    matches = [v for k, v in iteritems(module.__dict__)\n+               if isinstance(v, Flask)]\n+\n+    if matches:\n+        if len(matches) > 1:\n+            raise NoAppException('More than one possible Flask application '\n+                                 'found in module \"%s\", none of which are called '\n+                                 '\"app\".  Be explicit!' % module.__name__)\n+        return matches[0]\n+\n+    raise NoAppException('Failed to find application in module \"%s\".  Are '\n+                         'you sure it contains a Flask application?  Maybe '\n+                         'you wrapped it in a WSGI middleware or you are '\n+                         'using a factory function.' % module.__name__)\n+\n+\n+def prepare_exec_for_file(filename):\n+    module = []\n+\n+    # Chop off file extensions or package markers\n+    if filename.endswith('.py'):\n+        filename = filename[:-3]\n+    elif os.path.split(filename)[1] == '__init__.py':\n+        filename = os.path.dirname(filename)\n+    filename = os.path.realpath(filename)\n+\n+    dirpath = filename\n+    while 1:\n+        dirpath, extra = os.path.split(dirpath)\n+        module.append(extra)\n+        if not os.path.isfile(os.path.join(dirpath, '__init__.py')):\n+            break\n+\n+    sys.path.insert(0, dirpath)\n+    return '.'.join(module[::-1])\n+\n+\n+def locate_app(app_id, debug=None):\n+    \"\"\"Attempts to locate the application.\"\"\"\n+    if ':' in app_id:\n+        module, app_obj = app_id.split(':', 1)\n+    else:\n+        module = app_id\n+        app_obj = None\n+\n+    __import__(module)\n+    mod = sys.modules[module]\n+    if app_obj is None:\n+        app = find_best_app(mod)\n+    else:\n+        app = getattr(mod, app_obj, None)\n+        if app is None:\n+            raise RuntimeError('Failed to find application in module \"%s\"'\n+                               % module)\n+    if debug is not None:\n+        app.debug = debug\n+    return app\n+\n+\n+class DispatchingApp(object):\n+    \"\"\"Special applicationt that dispatches to a flask application which\n+    is imported by name on first request.  This is safer than importing\n+    the application upfront because it means that we can forward all\n+    errors for import problems into the browser as error.\n+    \"\"\"\n+\n+    def __init__(self, app_id, debug=None, use_eager_loading=False):\n+        self.app_id = app_id\n+        self.app = None\n+        self.debug = debug\n+        self._lock = Lock()\n+        if use_eager_loading:\n+            self._load_unlocked()\n+\n+    def _load_unlocked(self):\n+        self.app = rv = locate_app(self.app_id, self.debug)\n+        return rv\n+\n+    def __call__(self, environ, start_response):\n+        if self.app is not None:\n+            return self.app(environ, start_response)\n+        with self._lock:\n+            if self.app is not None:\n+                rv = self.app\n+            else:\n+                rv = self._load_unlocked()\n+            return rv(environ, start_response)\n+\n+\n+class ScriptInfo(object):\n+    \"\"\"Help object to deal with Flask applications.  This is usually not\n+    necessary to interface with as it's used internally in the dispatching\n+    to click.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.app_import_path = None\n+        self.debug = None\n+        self._loaded_app = None\n+\n+    def get_app_import_path(self):\n+        \"\"\"Return the actual application import path or fails if it is\n+        not yet set.\n+        \"\"\"\n+        if self.app_import_path is not None:\n+            return self.app_import_path\n+        raise NoAppException('Could not locate application. '\n+                             'You did not provide FLASK_APP or the '\n+                             '--app parameter.')\n+\n+    def load_app(self):\n+        \"\"\"Loads the app (if not yet loaded) and returns it.\"\"\"\n+        if self._loaded_app is not None:\n+            return self._loaded_app\n+        rv = locate_app(self.get_app_import_path(), self.debug)\n+        self._loaded_app = rv\n+        return rv\n+\n+    @contextmanager\n+    def conditional_context(self, with_context=True):\n+        \"\"\"Creates an application context or not, depending on the\n+        given parameter but always works as context manager.\n+        \"\"\"\n+        if with_context:\n+            with self.load_app().app_context() as ctx:\n+                yield ctx\n+        else:\n+            yield None\n+\n+\n+pass_script_info = click.make_pass_decorator(ScriptInfo)\n+\n+\n+def without_appcontext(f):\n+    \"\"\"Marks a click callback so that it does not get a app context\n+    created.  This only works for commands directly registered to\n+    the toplevel system.  This really is only useful for very\n+    special commands like the runserver one.\n+    \"\"\"\n+    f.__flask_without_appcontext__ = True\n+    return f\n+\n+\n+class FlaskClickGroup(click.Group):\n+    \"\"\"Special subclass of the a regular click group that supports\n+    loading more commands from the configured Flask app.\n+    \"\"\"\n+\n+    def __init__(self, help=None):\n+        def set_app_id(ctx, value):\n+            if value is not None:\n+                if os.path.isfile(value) or os.sep in value or \\\n+                   os.altsep is not None and os.altsep in value:\n+                    value = prepare_exec_for_file(value)\n+            ctx.obj.app_import_path = value\n+        def set_debug(ctx, value):\n+            ctx.obj.debug = value\n+\n+        click.Group.__init__(self, help=help, params=[\n+            click.Option(['-a', '--app'],\n+                         help='The application to run',\n+                         callback=set_app_id, is_eager=True),\n+            click.Option(['--debug/--no-debug'],\n+                         help='Enable or disable debug mode.',\n+                         default=None, callback=set_debug)\n+        ])\n+\n+    def get_command(self, ctx, name):\n+        info = ctx.find_object(ScriptInfo)\n+        # Find the command in the application first, if we can find it.\n+        # If the app is not available, we just ignore this silently.\n+        try:\n+            rv = info.load_app().cli.get_command(ctx, name)\n+            if rv is not None:\n+                return rv\n+        except NoAppException:\n+            pass\n+        return click.Group.get_command(self, ctx, name)\n+\n+    def list_commands(self, ctx):\n+        # The commands available is the list of both the application (if\n+        # available) plus the builtin commands.\n+        rv = set(click.Group.list_commands(self, ctx))\n+        info = ctx.find_object(ScriptInfo)\n+        try:\n+            rv.update(info.load_app().cli.list_commands(ctx))\n+        except NoAppException:\n+            pass\n+        return sorted(rv)\n+\n+    def invoke_subcommand(self, ctx, cmd, cmd_name, args):\n+        with_context = cmd.callback is None or \\\n+           not getattr(cmd.callback, '__flask_without_appcontext__', False)\n+\n+        with ctx.find_object(ScriptInfo).conditional_context(with_context):\n+            return click.Group.invoke_subcommand(\n+                self, ctx, cmd, cmd_name, args)\n+\n+\n+cli = FlaskClickGroup(help='''\\\n+This shell command acts as general utility script for Flask applications.\n+\n+It loads the application configured (either through the FLASK_APP environment\n+variable or the --app parameter) and then provides commands either provided\n+by the application or Flask itself.\n+\n+The most useful commands are the \"run\" and \"shell\" command.\n+\n+Example usage:\n+\n+  flask --app=hello --debug run\n+''')\n+\n+\n+@cli.command('run', short_help='Runs a development server.')\n+@click.option('--host', '-h', default='127.0.0.1',\n+              help='The interface to bind to.')\n+@click.option('--port', '-p', default=5000,\n+              help='The port to bind to.')\n+@click.option('--reload/--no-reload', default=None,\n+              help='Enable or disable the reloader.  By default the reloader '\n+              'is active is debug is enabled.')\n+@click.option('--debugger/--no-debugger', default=None,\n+              help='Enable or disable the debugger.  By default the debugger '\n+              'is active if debug is enabled.')\n+@click.option('--eager-loading/--lazy-loader', default=None,\n+              help='Enable or disable eager loading.  By default eager '\n+              'loading is enabled if the reloader is disabled.')\n+@click.option('--with-threads/--without-threads', default=False,\n+              help='Enable or disable multithreading.')\n+@without_appcontext\n+@pass_script_info\n+def run_command(info, host, port, reload, debugger, eager_loading,\n+                with_threads):\n+    \"\"\"Runs a local development server for the Flask application.\"\"\"\n+    from werkzeug.serving import run_simple\n+    app_id = info.get_app_import_path()\n+    if reload is None:\n+        reload = info.debug\n+    if debugger is None:\n+        debugger = info.debug\n+    if eager_loading is None:\n+        eager_loading = not reload\n+\n+    # Extra startup messages.  This depends a but on Werkzeug internals to\n+    # not double execute when the reloader kicks in.\n+    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n+        print(' * Serving Flask app \"%s\"' % app_id)\n+        if info.debug is not None:\n+            print(' * Forcing debug %s' % (info.debug and 'on' or 'off'))\n+\n+    app = DispatchingApp(app_id, info.debug, eager_loading)\n+    run_simple(host, port, app, use_reloader=reload,\n+               use_debugger=debugger, threaded=with_threads)\n+\n+\n+@cli.command('shell', short_help='Runs a shell in the app context.')\n+def shell_command():\n+    \"\"\"Runs an interactive Python shell in the context of a given\n+    Flask application.  The application will populate the default\n+    namespace of this shell according to it's configuration.\n+\n+    This is useful for executing small snippets of management code\n+    without having to manually configuring the application.\n+    \"\"\"\n+    import code\n+    from flask.globals import _app_ctx_stack\n+    app = _app_ctx_stack.top.app\n+    banner = 'Python %s on %s\\nApp: %s%s\\nInstance: %s' % (\n+        sys.version,\n+        sys.platform,\n+        app.import_name,\n+        app.debug and ' [debug]' or '',\n+        app.instance_path,\n+    )\n+    code.interact(banner=banner, local=app.make_shell_context())\n+\n+\n+def make_default_cli(app):\n+    \"\"\"Creates the default click object for the app itself.  Currently\n+    there are no default commands registered because all builtin commands\n+    are registered on the actual cmd object here.\n+    \"\"\"\n+    return click.Group()\n+\n+\n+def main(as_module=False):\n+    this_module = __package__ + '.cli'\n+    args = sys.argv[1:]\n+\n+    if as_module:\n+        if sys.version_info >= (2, 7):\n+            name = 'python -m ' + this_module.rsplit('.', 1)[0]\n+        else:\n+            name = 'python -m ' + this_module\n+\n+        # This module is always executed as \"python -m flask.run\" and as such\n+        # we need to ensure that we restore the actual command line so that\n+        # the reloader can properly operate.\n+        sys.argv = ['-m', this_module] + sys.argv[1:]\n+    else:\n+        name = 'flask'\n+\n+    cli.main(args=args, prog_name=name, obj=ScriptInfo(),\n+             auto_envvar_prefix='FLASK')\n+\n+\n+if __name__ == '__main__':\n+    main(as_module=True)\n\n@@ -1,247 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\"\"\"\n-    flask.run\n-    ~~~~~~~~~\n-\n-    A simple command line application to run flask apps.\n-\n-    :copyright: (c) 2014 by Armin Ronacher.\n-    :license: BSD, see LICENSE for more details.\n-\"\"\"\n-\n-import os\n-import sys\n-from threading import Lock\n-from optparse import OptionParser\n-\n-from werkzeug.serving import run_simple\n-\n-from ._compat import iteritems\n-\n-\n-def find_best_app(module):\n-    \"\"\"Given a module instance this tries to find the best possible application\n-    in the module or raises a RuntimeError.\n-    \"\"\"\n-    from flask import Flask\n-\n-    # The app name wins, even if it's not a flask object.\n-    app = getattr(module, 'app', None)\n-    if app is not None and callable(app):\n-        return app\n-\n-    # Otherwise find the first object named Flask\n-    matches = []\n-    for key, value in iteritems(module.__dict__):\n-        if isinstance(value, Flask):\n-            matches.append(value)\n-\n-    if matches:\n-        if len(matches) > 1:\n-            raise RuntimeError('More than one possible Flask application '\n-                               'found in module \"%s\", none of which are called '\n-                               '\"app\".  Be explicit!' % module)\n-        return matches[0]\n-\n-    raise RuntimeError('Failed to find application in module \"%s\".  Are '\n-                       'you sure it contains a Flask application?  Maybe '\n-                       'you wrapped it in a WSGI middleware or you are '\n-                       'using a factory function.' % module)\n-\n-\n-def prepare_exec_for_file(filename):\n-    module = []\n-\n-    # Chop off file extensions or package markers\n-    if filename.endswith('.py'):\n-        filename = filename[:-3]\n-    elif os.path.split(filename)[1] == '__init__.py':\n-        filename = os.path.dirname(filename)\n-    filename = os.path.realpath(filename)\n-\n-    dirpath = filename\n-    while 1:\n-        dirpath, extra = os.path.split(dirpath)\n-        module.append(extra)\n-        if not os.path.isfile(os.path.join(dirpath, '__init__.py')):\n-            break\n-\n-    sys.path.insert(0, dirpath)\n-    return '.'.join(module[::-1])\n-\n-\n-def locate_app(app_id, debug=None):\n-    \"\"\"Attempts to locate the application.\"\"\"\n-    if ':' in app_id:\n-        module, app_obj = app_id.split(':', 1)\n-    else:\n-        module = app_id\n-        app_obj = None\n-\n-    __import__(module)\n-    mod = sys.modules[module]\n-    if app_obj is None:\n-        app = find_best_app(mod)\n-    else:\n-        app = getattr(mod, app_obj, None)\n-        if app is None:\n-            raise RuntimeError('Failed to find application in module \"%s\"'\n-                               % module)\n-    if debug is not None:\n-        app.debug = debug\n-    return app\n-\n-\n-class DispatchingApp(object):\n-    \"\"\"Special applicationt that dispatches to a flask application which\n-    is imported by name on first request.  This is safer than importing\n-    the application upfront because it means that we can forward all\n-    errors for import problems into the browser as error.\n-    \"\"\"\n-\n-    def __init__(self, app_id, debug=None, use_eager_loading=False):\n-        self.app_id = app_id\n-        self.app = None\n-        self.debug = debug\n-        self._lock = Lock()\n-        if use_eager_loading:\n-            self._load_unlocked()\n-\n-    def _load_unlocked(self):\n-        self.app = rv = locate_app(self.app_id, self.debug)\n-        return rv\n-\n-    def __call__(self, environ, start_response):\n-        if self.app is not None:\n-            return self.app(environ, start_response)\n-        with self._lock:\n-            if self.app is not None:\n-                rv = self.app\n-            else:\n-                rv = self._load_unlocked()\n-            return rv(environ, start_response)\n-\n-\n-def run_application(app_id, host='127.0.0.1', port=5000, debug=None,\n-                    use_reloader=False, use_debugger=False,\n-                    use_eager_loading=None, magic_app_id=True,\n-                    **options):\n-    \"\"\"Useful function to start a Werkzeug server for an application that\n-    is known by it's import name.  By default the app ID can also be a\n-    full file name in which case Flask attempts to reconstruct the import\n-    name from it and do the right thing.\n-\n-    :param app_id: the import name of the application module.  If a colon\n-                   is provided, everything afterwards is the application\n-                   object name.  In case the magic app id is enabled this\n-                   can also be a filename.\n-    :param host: the host to bind to.\n-    :param port: the port to bind to.\n-    :param debug: if set to something other than None then the application's\n-                  debug flag will be set to this.\n-    :param use_reloader: enables or disables the reloader.\n-    :param use_debugger: enables or disables the builtin debugger.\n-    :param use_eager_loading: enables or disables eager loading.  This is\n-                              normally conditional to the reloader.\n-    :param magic_app_id: if this is enabled then the app id can also be a\n-                         filename instead of an import module and Flask\n-                         will attempt to reconstruct the import name.\n-    :param options: the options to be forwarded to the underlying\n-                    Werkzeug server.  See\n-                    :func:`werkzeug.serving.run_simple` for more\n-                    information.\n-    \"\"\"\n-    if magic_app_id:\n-        if os.path.isfile(app_id) or os.sep in app_id or \\\n-           os.altsep is not None and os.altsep in app_id:\n-            app_id = prepare_exec_for_file(app_id)\n-\n-    if use_eager_loading is None:\n-        use_eager_loading = not use_reloader\n-\n-    # Extra startup messages.  This depends a but on Werkzeug internals to\n-    # not double execute when the reloader kicks in.\n-    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n-        print ' * Serving Flask app \"%s\"' % app_id\n-        if debug is not None:\n-            print ' * Forcing debug %s' % (debug and 'on' or 'off')\n-\n-    app = DispatchingApp(app_id, debug, use_eager_loading)\n-    run_simple(host, port, app, use_reloader=use_reloader,\n-               use_debugger=use_debugger, **options)\n-\n-\n-def main(as_module=False):\n-    this_module = __package__ + '.run'\n-\n-    if as_module:\n-        if sys.version_info >= (2, 7):\n-            name = 'python -m ' + this_module.rsplit('.', 1)[0]\n-        else:\n-            name = 'python -m ' + this_module\n-    else:\n-        name = 'flask-run'\n-\n-    parser = OptionParser(usage='%prog [options] module', prog=name)\n-    parser.add_option('--debug', action='store_true',\n-                      dest='debug', help='Flip debug flag on.  If enabled '\n-                      'this also affects debugger and reloader defaults.')\n-    parser.add_option('--no-debug', action='store_false',\n-                      dest='debug', help='Flip debug flag off.')\n-    parser.add_option('--host', default='127.0.0.1',\n-                      help='The host to bind on. (defaults to 127.0.0.1)')\n-    parser.add_option('--port', default=5000,\n-                      help='The port to bind on. (defaults to 5000)')\n-    parser.add_option('--with-reloader', action='store_true',\n-                      dest='with_reloader',\n-                      help='Enable the reloader.')\n-    parser.add_option('--without-reloader', action='store_false',\n-                      dest='with_reloader',\n-                      help='Disable the reloader.')\n-    parser.add_option('--with-debugger', action='store_true',\n-                      dest='with_debugger',\n-                      help='Enable the debugger.')\n-    parser.add_option('--without-debugger', action='store_false',\n-                      dest='with_debugger',\n-                      help='Disable the debugger.')\n-    parser.add_option('--with-eager-loading', action='store_true',\n-                      dest='with_eager_loading',\n-                      help='Force enable the eager-loading.  This makes the '\n-                      'application load immediately but makes development '\n-                      'flows harder.  It\\'s not recommended to enable eager '\n-                      'loading when the reloader is enabled as it can lead '\n-                      'to unexpected crashes.')\n-    parser.add_option('--without-eager-loading', action='store_false',\n-                      dest='with_eager_loading',\n-                      help='Disable the eager-loading.')\n-    parser.add_option('--with-threads', action='store_true',\n-                      dest='with_threads',\n-                      help='Enable multi-threading to handle multiple '\n-                      'requests concurrently.')\n-    parser.add_option('--without-threads', action='store_false',\n-                      dest='with_threads',\n-                      help='Disables multi-threading. (default)')\n-    opts, args = parser.parse_args()\n-    if len(args) != 1:\n-        parser.error('Expected exactly one argument which is the import '\n-                     'name of the application.')\n-\n-    if opts.with_debugger is None:\n-        opts.with_debugger = opts.debug\n-    if opts.with_reloader is None:\n-        opts.with_reloader = opts.debug\n-\n-    # This module is always executed as \"python -m flask.run\" and as such\n-    # we need to ensure that we restore the actual command line so that\n-    # the reloader can properly operate.\n-    sys.argv = ['-m', this_module] + sys.argv[1:]\n-\n-    run_application(args[0], opts.host, opts.port, debug=opts.debug,\n-                    use_reloader=opts.with_reloader,\n-                    use_debugger=opts.with_debugger,\n-                    use_eager_loading=opts.with_eager_loading,\n-                    threaded=opts.with_threads)\n-\n-\n-if __name__ == '__main__':\n-    main(as_module=True)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
