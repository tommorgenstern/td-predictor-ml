{"custom_id": "requests#e9be7c1a58ff31b04633526c425714b272b457e8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 437 | Contributors (this commit): 6 | Commits (past 90d): 3 | Contributors (cumulative): 6 | DMM Complexity: None\n\nDIFF:\n@@ -25,6 +25,9 @@ Available hooks:\n import traceback\n \n \n+HOOKS = ('args', 'pre_request', 'post_request', 'response')\n+\n+\n def dispatch_hook(key, hooks, hook_data):\n     \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#a3b26c7e5bde922a874a413a0d752ed2555c3d66", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 6/6 | Churn Δ: 17 | Churn Cumulative: 4284 | Contributors (this commit): 37 | Commits (past 90d): 86 | Contributors (cumulative): 37 | DMM Complexity: 0.2857142857142857\n\nDIFF:\n@@ -13,7 +13,7 @@ import urllib\n from urlparse import urlparse, urlunparse, urljoin, urlsplit\n from datetime import datetime\n \n-from .hooks import dispatch_hook\n+from .hooks import dispatch_hook, HOOKS\n from .structures import CaseInsensitiveDict\n from .status_codes import codes\n from .packages import oreos\n@@ -114,7 +114,15 @@ class Request(object):\n         self.sent = False\n \n         #: Event-handling hooks.\n-        self.hooks = hooks\n+        self.hooks = {}\n+\n+        for event in HOOKS:\n+            self.hooks[event] = []\n+\n+        hooks = hooks or {}\n+\n+        for (k, v) in hooks.items():\n+            self.register_hook(event=k, hook=v)\n \n         #: Session.\n         self.session = session\n@@ -343,6 +351,11 @@ class Request(object):\n         return ''.join(url)\n \n \n+    def register_hook(self, event, hook):\n+        \"\"\"Properly register a hook.\"\"\"\n+\n+        return self.hooks[event].append(hook)\n+\n \n     def send(self, anyway=False, prefetch=False):\n         \"\"\"Sends the request. Returns True of successful, false if not.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#5f44d7972956471c5b14f0dab898dff70ebc3179", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 272 | Contributors (this commit): 4 | Commits (past 90d): 14 | Contributors (cumulative): 4 | DMM Complexity: None\n\nDIFF:\n@@ -134,5 +134,5 @@ class HTTPDigestAuth(AuthBase):\n         return r\n \n     def __call__(self, r):\n-        r.hooks['response'] = self.handle_401\n+        r.register_hook('response', self.handle_401)\n         return r\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#70e98e47cfd9c14dc967fdbfe690444166ff172e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 2 | Churn Cumulative: 4286 | Contributors (this commit): 37 | Commits (past 90d): 76 | Contributors (cumulative): 37 | DMM Complexity: None\n\nDIFF:\n@@ -720,7 +720,7 @@ class Response(object):\n         \"\"\"Content of the response, in unicode.\"\"\"\n \n         # Try charset from content-type\n-        content = u''\n+        content = None\n \n         if self.encoding:\n             try:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#16a7a26452b61ccd08b0a52e940d13e305c73e37", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 278 | Contributors (this commit): 3 | Commits (past 90d): 23 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -15,7 +15,7 @@ requests\n \"\"\"\n \n __title__ = 'requests'\n-__version__ = '0.9.3'\n+__version__ = '0.10.0'\n __build__ = 0x000903\n __author__ = 'Kenneth Reitz'\n __license__ = 'ISC'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#ada98899f87a9118b026a547ee5d5ecda47bcfe8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 280 | Contributors (this commit): 3 | Commits (past 90d): 24 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -16,7 +16,7 @@ requests\n \n __title__ = 'requests'\n __version__ = '0.10.0'\n-__build__ = 0x000903\n+__build__ = 0x001000\n __author__ = 'Kenneth Reitz'\n __license__ = 'ISC'\n __copyright__ = 'Copyright 2012 Kenneth Reitz'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#47e96b80407b52ec45136391c77b089d71ccbe18", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 129 | Contributors (this commit): 2 | Commits (past 90d): 9 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -21,7 +21,8 @@ if sys.argv[-1] == 'test':\n     sys.exit()\n \n required = [\n-    'certifi>=0.0.4'\n+    'certifi>=0.0.4',\n+    'chardet>=1.0.0'\n ]\n \n if sys.version_info[:2] < (2,6):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b725bfd3fb3e6bec9e15009985b8d30bdee66f51", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 30 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 7 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 36 | Churn Cumulative: 4322 | Contributors (this commit): 37 | Commits (past 90d): 77 | Contributors (cumulative): 37 | DMM Complexity: 0.0\n\nDIFF:\n@@ -31,6 +31,11 @@ from .utils import (\n     get_encoding_from_headers, stream_decode_response_unicode,\n     stream_decompress, guess_filename, requote_path)\n \n+# Import chardet if it is available.\n+try:\n+    import chardet\n+except ImportError:\n+    pass\n \n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n \n@@ -717,23 +722,42 @@ class Response(object):\n \n     @property\n     def text(self):\n-        \"\"\"Content of the response, in unicode.\"\"\"\n+        \"\"\"Content of the response, in unicode.\n+\n+        if Response.encoding is None and chardet module is available, encoding\n+        will be guessed.\n+        \"\"\"\n \n         # Try charset from content-type\n         content = None\n+        encoding = self.encoding\n+\n+        # Fallback to auto-detected encoding if chardet is available.\n+        if self.encoding is None:\n \n-        if self.encoding:\n             try:\n-                content = unicode(self.content, self.encoding)\n-            except UnicodeError:\n+                detected = chardet.detect(self.content) or {}\n+                encoding = detected.get('encoding')\n+\n+            # Trust that chardet isn't available or something went terribly wrong.\n+            except Exception:\n+                pass\n+\n+\n+        # Decode unicode from given encoding.\n+        try:\n+            content = unicode(self.content, encoding)\n+        except UnicodeError, TypeError:\n             pass\n \n         # Try to fall back:\n         try:\n-                content = unicode(content, self.encoding, errors='replace')\n-            except TypeError:\n+            content = unicode(content, encoding, errors='replace')\n+        except UnicodeError, TypeError:\n             pass\n \n+\n+\n         return content\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#2c7e920298d8bbd0f3b28972a5febf148fd33188", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 1 | Churn Cumulative: 4323 | Contributors (this commit): 37 | Commits (past 90d): 78 | Contributors (cumulative): 37 | DMM Complexity: 0.0\n\nDIFF:\n@@ -752,6 +752,7 @@ class Response(object):\n \n         # Try to fall back:\n         try:\n+            if not content:\n                 content = unicode(content, encoding, errors='replace')\n         except UnicodeError, TypeError:\n             pass\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b14a244ab4cb598d5f5b65209734b1bbca10d708", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 4325 | Contributors (this commit): 37 | Commits (past 90d): 79 | Contributors (cumulative): 37 | DMM Complexity: None\n\nDIFF:\n@@ -751,8 +751,8 @@ class Response(object):\n             pass\n \n         # Try to fall back:\n-        try:\n         if not content:\n+            try:\n                 content = unicode(content, encoding, errors='replace')\n             except UnicodeError, TypeError:\n                 pass\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#464279f48d2aa3aea75edd037b7020eb23682002", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 4327 | Contributors (this commit): 37 | Commits (past 90d): 80 | Contributors (cumulative): 37 | DMM Complexity: None\n\nDIFF:\n@@ -734,7 +734,6 @@ class Response(object):\n \n         # Fallback to auto-detected encoding if chardet is available.\n         if self.encoding is None:\n-\n             try:\n                 detected = chardet.detect(self.content) or {}\n                 encoding = detected.get('encoding')\n@@ -743,7 +742,6 @@ class Response(object):\n             except Exception:\n                 pass\n \n-\n         # Decode unicode from given encoding.\n         try:\n             content = unicode(self.content, encoding)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#0dbda6665d65b186107e01b03ae901684a7f5ecb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 6 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 7 | Churn Cumulative: 4334 | Contributors (this commit): 37 | Commits (past 90d): 81 | Contributors (cumulative): 37 | DMM Complexity: None\n\nDIFF:\n@@ -677,16 +677,21 @@ class Response(object):\n         avoids reading the content at once into memory for large\n         responses.\n         \"\"\"\n-        #XXX: why rstrip by default\n+        #TODO: why rstrip by default\n         pending = None\n+\n         for chunk in self.iter_content(chunk_size, decode_unicode=decode_unicode):\n+\n             if pending is not None:\n                 chunk = pending + chunk\n             lines = chunk.splitlines(True)\n+\n             for line in lines[:-1]:\n                 yield line.rstrip()\n+\n             # Save the last part of the chunk for next iteration, to keep full line together\n             # lines may be empty for the last chunk of a chunked response\n+\n             if lines:\n                 pending = lines[-1]\n                 #if pending is a complete line, give it baack\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#128b49a1fbefb076fa0e5e9770ca725a1a2f70bb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 4335 | Contributors (this commit): 37 | Commits (past 90d): 82 | Contributors (cumulative): 37 | DMM Complexity: None\n\nDIFF:\n@@ -677,6 +677,7 @@ class Response(object):\n         avoids reading the content at once into memory for large\n         responses.\n         \"\"\"\n+\n         #TODO: why rstrip by default\n         pending = None\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#2109afc144f98f98320e6747d37961282efe1404", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 146 | Lines Deleted: 63 | Files Changed: 7 | Hunks: 37 | Methods Changed: 16 | Complexity Δ (Sum/Max): 16/7 | Churn Δ: 209 | Churn Cumulative: 2989 | Contributors (this commit): 1 | Commits (past 90d): 30 | Contributors (cumulative): 7 | DMM Complexity: 0.5476190476190477\n\nDIFF:\n@@ -7,22 +7,23 @@\n import logging\n import socket\n \n+from select import poll, POLLIN\n+from socket import error as SocketError, timeout as SocketTimeout\n+\n+\n try:   # Python 3\n     from http.client import HTTPConnection, HTTPSConnection, HTTPException\n+    from http.client import HTTP_PORT, HTTPS_PORT\n except ImportError:\n     from httplib import HTTPConnection, HTTPSConnection, HTTPException\n+    from httplib import HTTP_PORT, HTTPS_PORT\n \n try:   # Python 3\n     from queue import Queue, Empty, Full\n except ImportError:\n     from Queue import Queue, Empty, Full\n \n-from select import select\n-from socket import error as SocketError, timeout as SocketTimeout\n-\n-from .packages.ssl_match_hostname import match_hostname, CertificateError\n-\n-try:\n+try:   # Compiled with SSL?\n     import ssl\n     BaseSSLError = ssl.SSLError\n except ImportError:\n@@ -32,22 +33,26 @@ except ImportError:\n \n from .request import RequestMethods\n from .response import HTTPResponse\n-from .exceptions import (\n-    SSLError,\n+from .exceptions import (SSLError,\n     MaxRetryError,\n     TimeoutError,\n     HostChangedError,\n     EmptyPoolError,\n )\n \n-from . import six\n-xrange = six.moves.xrange\n+from urllib3.packages.ssl_match_hostname import match_hostname, CertificateError\n+from urllib3.packages import six\n \n+xrange = six.moves.xrange\n \n log = logging.getLogger(__name__)\n \n _Default = object()\n \n+port_by_scheme = {\n+    'http': HTTP_PORT,\n+    'https': HTTPS_PORT,\n+}\n \n ## Connection objects (extension of httplib)\n \n@@ -91,7 +96,16 @@ class ConnectionPool(object):\n     Base class for all connection pools, such as\n     :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n     \"\"\"\n-    pass\n+\n+    scheme = None\n+\n+    def __init__(self, host, port=None):\n+        self.host = host\n+        self.port = port\n+\n+    def __str__(self):\n+        return '%s(host=%r, port=%r)' % (type(self).__name__,\n+                                         self.host, self.port)\n \n \n class HTTPConnectionPool(ConnectionPool, RequestMethods):\n@@ -179,14 +193,14 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n             conn = self.pool.get(block=self.block, timeout=timeout)\n \n             # If this is a persistent connection, check if it got disconnected\n-            if conn and conn.sock and select([conn.sock], [], [], 0.0)[0]:\n-                # Either data is buffered (bad), or the connection is dropped.\n+            if conn and conn.sock and is_connection_dropped(conn):\n                 log.info(\"Resetting dropped connection: %s\" % self.host)\n                 conn.close()\n \n         except Empty:\n             if self.block:\n-                raise EmptyPoolError(\"Pool reached maximum size and no more \"\n+                raise EmptyPoolError(self,\n+                                     \"Pool reached maximum size and no more \"\n                                      \"connections are allowed.\")\n             pass  # Oh well, we'll create a new connection then\n \n@@ -239,11 +253,17 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n     def is_same_host(self, url):\n         \"\"\"\n         Check if the given ``url`` is a member of the same host as this\n-        conncetion pool.\n+        connection pool.\n         \"\"\"\n         # TODO: Add optional support for socket.gethostbyname checking.\n+        scheme, host, port = get_host(url)\n+\n+        if self.port and not port:\n+            # Use explicit default port for comparison when none is given.\n+            port = port_by_scheme.get(scheme)\n+\n         return (url.startswith('/') or\n-                get_host(url) == (self.scheme, self.host, self.port))\n+                (scheme, host, port) == (self.scheme, self.host, self.port))\n \n     def urlopen(self, method, url, body=None, headers=None, retries=3,\n                 redirect=True, assert_same_host=True, timeout=_Default,\n@@ -316,7 +336,7 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n             headers = self.headers\n \n         if retries < 0:\n-            raise MaxRetryError(url)\n+            raise MaxRetryError(self, url)\n \n         if timeout is _Default:\n             timeout = self.timeout\n@@ -330,7 +350,7 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n             if self.port:\n                 host = \"%s:%d\" % (host, self.port)\n \n-            raise HostChangedError(host, url, retries - 1)\n+            raise HostChangedError(self, url, retries - 1)\n \n         conn = None\n \n@@ -363,12 +383,12 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n \n         except Empty as e:\n             # Timed out by queue\n-            raise TimeoutError(\"Request timed out. (pool_timeout=%s)\" %\n+            raise TimeoutError(self, \"Request timed out. (pool_timeout=%s)\" %\n                                pool_timeout)\n \n         except SocketTimeout as e:\n             # Timed out by socket\n-            raise TimeoutError(\"Request timed out. (timeout=%s)\" %\n+            raise TimeoutError(self, \"Request timed out. (timeout=%s)\" %\n                                timeout)\n \n         except BaseSSLError as e:\n@@ -558,3 +578,19 @@ def connection_from_url(url, **kw):\n         return HTTPSConnectionPool(host, port=port, **kw)\n     else:\n         return HTTPConnectionPool(host, port=port, **kw)\n+\n+\n+def is_connection_dropped(conn):\n+    \"\"\"\n+    Returns True if the connection is dropped and should be closed.\n+\n+    :param conn:\n+        ``HTTPConnection`` object.\n+    \"\"\"\n+    # poll-based replacement to select([conn.sock], [], [], 0.0)[0]:\n+    p = poll()\n+    p.register(conn.sock, POLLIN)\n+    for (fno, ev) in p.poll(0.0):\n+        if fno == conn.sock.fileno():\n+            # Either data is buffered (bad), or the connection is dropped.\n+            return True\n\n@@ -4,42 +4,51 @@\n # This module is part of urllib3 and is released under\n # the MIT License: http://www.opensource.org/licenses/mit-license.php\n \n-## Exceptions\n+## Base Exceptions\n \n class HTTPError(Exception):\n     \"Base exception used by this module.\"\n     pass\n \n \n-class SSLError(Exception):\n+class PoolError(HTTPError):\n+    \"Base exception for errors caused within a pool.\"\n+    def __init__(self, pool, message):\n+        self.pool = pool\n+        HTTPError.__init__(self, \"%s: %s\" % (pool, message))\n+\n+\n+class SSLError(HTTPError):\n     \"Raised when SSL certificate fails in an HTTPS connection.\"\n     pass\n \n \n-class MaxRetryError(HTTPError):\n+## Leaf Exceptions\n+\n+class MaxRetryError(PoolError):\n     \"Raised when the maximum number of retries is exceeded.\"\n-    def __init__(self, url):\n-        HTTPError.__init__(self, \"Max retries exceeded for url: %s\" % url)\n+    def __init__(self, pool, url):\n+        PoolError.__init__(self, pool,\n+                           \"Max retries exceeded with url: %s\" % url)\n+\n         self.url = url\n \n \n-class TimeoutError(HTTPError):\n+class HostChangedError(PoolError):\n+    \"Raised when an existing pool gets a request for a foreign host.\"\n+    def __init__(self, pool, url, retries=3):\n+        PoolError.__init__(self, pool,\n+                           \"Tried to open a foreign host with url: %s\" % url)\n+\n+        self.url = url\n+        self.retries = retries\n+\n+\n+class TimeoutError(PoolError):\n     \"Raised when a socket timeout occurs.\"\n     pass\n \n \n-class HostChangedError(HTTPError):\n-    \"Raised when an existing pool gets a request for a foreign host.\"\n-    def __init__(self, original_host, new_url, retries=3):\n-        HTTPError.__init__(self,\n-            \"Connection pool with host '%s' tried to open a foreign host: %s\" %\n-            (original_host, new_url))\n-\n-        self.original_host = original_host\n-        self.new_url = new_url\n-        self.retries = retries\n-\n-\n-class EmptyPoolError(HTTPError):\n+class EmptyPoolError(PoolError):\n     \"Raised when a pool runs out of connections and no more are allowed.\"\n     pass\n\n@@ -10,13 +10,12 @@ import mimetypes\n try:\n     from mimetools import choose_boundary\n except ImportError:\n-    # I don't like using an undocumented function, but I don't yet know what it does\n-    from email.generator import _make_boundary as choose_boundary\n+    from .packages.mimetools_choose_boundary import choose_boundary\n \n from io import BytesIO\n \n-from . import six\n-from .six import b\n+from .packages import six\n+from .packages.six import b\n \n writer = codecs.lookup('utf-8')[3]\n \n\n@@ -0,0 +1,47 @@\n+\"\"\"The function mimetools.choose_boundary() from Python 2.7, which seems to\n+have disappeared in Python 3 (although email.generator._make_boundary() might\n+work as a replacement?).\n+\n+Tweaked to use lock from threading rather than thread.\n+\"\"\"\n+import os\n+from threading import Lock\n+_counter_lock = Lock()\n+\n+_counter = 0\n+def _get_next_counter():\n+    global _counter\n+    with _counter_lock:\n+        _counter += 1\n+        return _counter\n+\n+_prefix = None\n+\n+def choose_boundary():\n+    \"\"\"Return a string usable as a multipart boundary.\n+\n+    The string chosen is unique within a single program run, and\n+    incorporates the user id (if available), process id (if available),\n+    and current time.  So it's very unlikely the returned string appears\n+    in message text, but there's no guarantee.\n+\n+    The boundary contains dots so you have to quote it in the header.\"\"\"\n+\n+    global _prefix\n+    import time\n+    if _prefix is None:\n+        import socket\n+        try:\n+            hostid = socket.gethostbyname(socket.gethostname())\n+        except socket.gaierror:\n+            hostid = '127.0.0.1'\n+        try:\n+            uid = repr(os.getuid())\n+        except AttributeError:\n+            uid = '1'\n+        try:\n+            pid = repr(os.getpid())\n+        except AttributeError:\n+            pid = '1'\n+        _prefix = hostid + '.' + uid + '.' + pid\n+    return \"%s.%.3f.%d\" % (_prefix, time.time(), _get_next_counter())\n\n\n@@ -8,7 +8,7 @@ import logging\n \n from ._collections import RecentlyUsedContainer\n from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool\n-from .connectionpool import get_host, connection_from_url\n+from .connectionpool import get_host, connection_from_url, port_by_scheme\n from .exceptions import HostChangedError\n from .request import RequestMethods\n \n@@ -21,11 +21,6 @@ pool_classes_by_scheme = {\n     'https': HTTPSConnectionPool,\n }\n \n-port_by_scheme = {\n-    'http': 80,\n-    'https': 443,\n-}\n-\n log = logging.getLogger(__name__)\n \n \n@@ -110,7 +105,7 @@ class PoolManager(RequestMethods):\n \n         except HostChangedError as e:\n             kw['retries'] = e.retries # Persist retries countdown\n-            return self.urlopen(method, e.new_url, **kw)\n+            return self.urlopen(method, e.url, **kw)\n \n \n class ProxyManager(RequestMethods):\n\n@@ -67,7 +67,7 @@ class HTTPResponse(object):\n         self.strict = strict\n \n         self._decode_content = decode_content\n-        self._body = None\n+        self._body = body if body and isinstance(body, basestring) else None\n         self._fp = None\n         self._original_response = original_response\n \n@@ -77,7 +77,7 @@ class HTTPResponse(object):\n         if hasattr(body, 'read'):\n             self._fp = body\n \n-        if preload_content:\n+        if preload_content and not self._body:\n             self._body = self.read(decode_content=decode_content)\n \n     def get_redirect_location(self):\n@@ -135,20 +135,18 @@ class HTTPResponse(object):\n         if decode_content is None:\n             decode_content = self._decode_content\n \n-        data = self._fp and self._fp.read(amt)\n+        if self._fp is None:\n+            return\n \n         try:\n-\n-            if amt:\n-                return data\n-\n-            if not decode_content or not decoder:\n-                if cache_content:\n-                    self._body = data\n-\n-                return data\n+            if amt is None:\n+                # cStringIO doesn't like amt=None\n+                data = self._fp.read()\n+            else:\n+                return self._fp.read(amt)\n \n             try:\n+                if decode_content and decoder:\n                     data = decoder(data)\n             except IOError:\n                 raise HTTPError(\"Received response with content-encoding: %s, but \"\n@@ -160,7 +158,6 @@ class HTTPResponse(object):\n             return data\n \n         finally:\n-\n             if self._original_response and self._original_response.isclosed():\n                 self.release_conn()\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e84a7c7e6f9a46f111132e1bd188e99848927773", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 21 | Files Changed: 1 | Hunks: 7 | Methods Changed: 3 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 30 | Churn Cumulative: 1658 | Contributors (this commit): 19 | Commits (past 90d): 32 | Contributors (cumulative): 19 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,11 +1,14 @@\n #!/usr/bin/env python\n # -*- coding: utf-8 -*-\n \n+\n+\n from __future__ import with_statement\n \n import StringIO\n import time\n import os\n+import sys\n import unittest\n \n import requests\n@@ -18,12 +21,12 @@ try:\n except ImportError:\n     import json\n \n+if (sys.platform == 'win32') and ('HTTPBIN_URL' not in os.environ):\n+    os.environ['HTTPBIN_URL'] = 'http://httpbin.org/'\n \n # TODO: Detect an open port.\n PORT = os.environ.get('HTTPBIN_PORT', '7077')\n-\n-HTTPBIN_URL = 'http://0.0.0.0:%s/' % (PORT)\n-# HTTPBIN_URL = 'http://127.0.0.1:8000/'\n+HTTPBIN_URL = os.environ.get('HTTPBIN_URL', 'http://0.0.0.0:%s/' % (PORT))\n \n \n def httpbin(*suffix):\n@@ -46,20 +49,10 @@ class RequestsTestSuite(unittest.TestCase):\n \n         global _httpbin\n \n-        if not _httpbin:\n-\n-            c = envoy.connect('gunicorn httpbin:app --bind=0.0.0.0:%s' % (PORT))\n-\n-            self.httpbin = c\n-            _httpbin = True\n+        if (not 'HTTPBIN_URL' in os.environ) and not _httpbin:\n+            c = envoy.connect('httpbin %s' % (PORT))\n             time.sleep(1)\n-\n-\n-\n-    def tearDown(self):\n-        \"\"\"Teardown.\"\"\"\n-        # self.httpbin.kill()\n-        pass\n+            _httpbin = True\n \n \n     def test_entry_points(self):\n@@ -142,11 +135,6 @@ class RequestsTestSuite(unittest.TestCase):\n         self.assertEqual(r.status_code, 200)\n \n \n-    def test_HTTP_200_OK_PATCH(self):\n-        r = requests.patch(httpbin('patch'))\n-        self.assertEqual(r.status_code, 200)\n-\n-\n     def test_BASICAUTH_TUPLE_HTTP_200_OK_GET(self):\n \n         for service in SERVICES:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b0e2e4f284f619536b7f405122bb1a93900cd743", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 241 | Lines Deleted: 188 | Files Changed: 14 | Hunks: 129 | Methods Changed: 58 | Complexity Δ (Sum/Max): 60/59 | Churn Δ: 429 | Churn Cumulative: 12873 | Contributors (this commit): 48 | Commits (past 90d): 182 | Contributors (cumulative): 93 | DMM Complexity: 1.0\n\nDIFF:\n@@ -7,11 +7,14 @@ requests.auth\n This module contains the authentication handlers for Requests.\n \"\"\"\n \n+from __future__ import unicode_literals\n+\n import time\n import hashlib\n \n from base64 import b64encode\n-from urlparse import urlparse\n+# from urlparse import urlparse\n+from urllib.parse import urlparse\n \n from .utils import randombytes, parse_dict_header\n \n@@ -19,7 +22,8 @@ from .utils import randombytes, parse_dict_header\n \n def _basic_auth_str(username, password):\n     \"\"\"Returns a Basic Auth string.\"\"\"\n-    return 'Basic %s' % b64encode('%s:%s' % (username, password))\n+\n+    return 'Basic ' + b64encode((\"%s:%s\" % (username, password)).encode('utf-8')).strip().decode('utf-8')\n \n \n class AuthBase(object):\n@@ -32,8 +36,8 @@ class AuthBase(object):\n class HTTPBasicAuth(AuthBase):\n     \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n     def __init__(self, username, password):\n-        self.username = str(username)\n-        self.password = str(password)\n+        self.username = username\n+        self.password = password\n \n     def __call__(self, r):\n         r.headers['Authorization'] = _basic_auth_str(self.username, self.password)\n@@ -101,10 +105,12 @@ class HTTPDigestAuth(AuthBase):\n                     last_nonce = nonce\n \n                 ncvalue = '%08x' % nonce_count\n-                cnonce = (hashlib.sha1(\"%s:%s:%s:%s\" % (\n-                    nonce_count, nonce, time.ctime(), randombytes(8)))\n-                    .hexdigest()[:16]\n-                )\n+                s = str(nonce_count).encode('utf-8')\n+                s += nonce.encode('utf-8')\n+                s += time.ctime().encode('utf-8')\n+                s += randombytes(8)\n+\n+                cnonce = (hashlib.sha1(s).hexdigest()[:16])\n                 noncebit = \"%s:%s:%s:%s:%s\" % (nonce, ncvalue, cnonce, qop, H(A2))\n                 respdig = KD(H(A1), noncebit)\n             elif qop is None:\n\n@@ -8,15 +8,16 @@ This module contains the primary objects that power Requests.\n \"\"\"\n \n import os\n-import urllib\n+import urllib.request, urllib.parse, urllib.error\n \n-from urlparse import urlparse, urlunparse, urljoin, urlsplit\n+# from urlparse import urlparse, urlunparse, urljoin, urlsplit\n+from urllib.parse import urlparse, urlunparse, urljoin, urlsplit, urlencode\n from datetime import datetime\n \n from .hooks import dispatch_hook, HOOKS\n from .structures import CaseInsensitiveDict\n from .status_codes import codes\n-from .packages import oreos\n+# from .packages import oreos\n from .auth import HTTPBasicAuth, HTTPProxyAuth\n from .packages.urllib3.response import HTTPResponse\n from .packages.urllib3.exceptions import MaxRetryError\n@@ -29,7 +30,7 @@ from .exceptions import (\n     URLRequired, SSLError)\n from .utils import (\n     get_encoding_from_headers, stream_decode_response_unicode,\n-    stream_decompress, guess_filename, requote_path)\n+    stream_decompress, guess_filename, requote_path, dict_from_string)\n \n # Import chardet if it is available.\n try:\n@@ -70,6 +71,11 @@ class Request(object):\n         self.timeout = timeout\n \n         #: Request URL.\n+\n+        # if isinstance(url, str):\n+            # url = url.encode('utf-8')\n+            # print(dir(url))\n+\n         self.url = url\n \n         #: Dictionary of HTTP Headers to attach to the :class:`Request <Request>`.\n@@ -126,7 +132,7 @@ class Request(object):\n \n         hooks = hooks or {}\n \n-        for (k, v) in hooks.items():\n+        for (k, v) in list(hooks.items()):\n             self.register_hook(event=k, hook=v)\n \n         #: Session.\n@@ -141,7 +147,7 @@ class Request(object):\n             headers = CaseInsensitiveDict()\n \n         # Add configured base headers.\n-        for (k, v) in self.config.get('base_headers', {}).items():\n+        for (k, v) in list(self.config.get('base_headers', {}).items()):\n             if k not in headers:\n                 headers[k] = v\n \n@@ -186,7 +192,7 @@ class Request(object):\n                 # Add new cookies from the server.\n                 if 'set-cookie' in response.headers:\n                     cookie_header = response.headers['set-cookie']\n-                    cookies = oreos.dict_from_string(cookie_header)\n+                    cookies = dict_from_string(cookie_header)\n \n                 # Save cookies in Response.\n                 response.cookies = cookies\n@@ -196,7 +202,7 @@ class Request(object):\n \n             # Save original response for later.\n             response.raw = resp\n-            response.url = self.full_url.decode('utf-8')\n+            response.url = self.full_url\n \n             return response\n \n@@ -284,16 +290,17 @@ class Request(object):\n         returns it twice.\n         \"\"\"\n \n-        if hasattr(data, '__iter__'):\n+        if hasattr(data, '__iter__') and not isinstance(data, str):\n             data = dict(data)\n \n+\n         if hasattr(data, 'items'):\n             result = []\n-            for k, vs in data.items():\n+            for k, vs in list(data.items()):\n                 for v in isinstance(vs, list) and vs or [vs]:\n-                    result.append((k.encode('utf-8') if isinstance(k, unicode) else k,\n-                                   v.encode('utf-8') if isinstance(v, unicode) else v))\n-            return result, urllib.urlencode(result, doseq=True)\n+                    result.append((k.encode('utf-8') if isinstance(k, str) else k,\n+                                   v.encode('utf-8') if isinstance(v, str) else v))\n+            return result, urlencode(result, doseq=True)\n         else:\n             return data, data\n \n@@ -304,20 +311,26 @@ class Request(object):\n         if not self.url:\n             raise URLRequired()\n \n+        url = self.url\n+\n         # Support for unicode domain names and paths.\n-        scheme, netloc, path, params, query, fragment = urlparse(self.url)\n+        scheme, netloc, path, params, query, fragment = urlparse(url)\n+\n \n         if not scheme:\n-            raise ValueError(\"Invalid URL %r: No schema supplied\" %self.url)\n+            raise ValueError(\"Invalid URL %r: No schema supplied\" % url)\n \n-        netloc = netloc.encode('idna')\n+        netloc = netloc.encode('idna').decode('utf-8')\n \n-        if isinstance(path, unicode):\n-            path = path.encode('utf-8')\n+        # if isinstance(path, str):\n+        #     path = path.encode('utf-8')\n \n-        path = requote_path(path)\n+        # path = requote_path(path)\n \n-        url = str(urlunparse([ scheme, netloc, path, params, query, fragment ]))\n+        # print([ scheme, netloc, path, params, query, fragment ])\n+        # print('---------------------')\n+\n+        url = (urlunparse([ scheme, netloc, path, params, query, fragment ]))\n \n         if self._enc_params:\n             if urlparse(url).query:\n@@ -342,6 +355,10 @@ class Request(object):\n         path = p.path\n         if not path:\n             path = '/'\n+\n+        from urllib.parse import quote, unquote\n+\n+        path = quote(path.encode('utf-8'))\n         url.append(path)\n \n         query = p.query\n@@ -349,6 +366,8 @@ class Request(object):\n             url.append('?')\n             url.append(query)\n \n+        # print(url)\n+\n         return ''.join(url)\n \n \n@@ -384,14 +403,14 @@ class Request(object):\n \n         # Multi-part file uploads.\n         if self.files:\n-            if not isinstance(self.data, basestring):\n+            if not isinstance(self.data, str):\n \n                 try:\n                     fields = self.data.copy()\n                 except AttributeError:\n                     fields = dict(self.data)\n \n-                for (k, v) in self.files.items():\n+                for (k, v) in list(self.files.items()):\n                     # support for explicit filename\n                     if isinstance(v, (tuple, list)):\n                         fn, fp = v\n@@ -408,7 +427,7 @@ class Request(object):\n             if self.data:\n \n                 body = self._enc_data\n-                if isinstance(self.data, basestring):\n+                if isinstance(self.data, str):\n                     content_type = None\n                 else:\n                     content_type = 'application/x-www-form-urlencoded'\n@@ -481,8 +500,10 @@ class Request(object):\n                 if 'cookie' not in self.headers:\n \n                     # Simple cookie with our dict.\n-                    c = oreos.monkeys.SimpleCookie()\n-                    for (k, v) in self.cookies.items():\n+                    # c = oreos.monkeys.SimpleCookie()\n+                    from http.cookies import SimpleCookie\n+                    c = SimpleCookie()\n+                    for (k, v) in list(self.cookies.items()):\n                         c[k] = v\n \n                     # Turn it into a header.\n@@ -511,16 +532,16 @@ class Request(object):\n                     )\n                     self.sent = True\n \n-                except MaxRetryError, e:\n+                except MaxRetryError as e:\n                     raise ConnectionError(e)\n \n-                except (_SSLError, _HTTPError), e:\n+                except (_SSLError, _HTTPError) as e:\n                     if self.verify and isinstance(e, _SSLError):\n                         raise SSLError(e)\n \n                     raise Timeout('Request timed out.')\n \n-            except RequestException, e:\n+            except RequestException as e:\n                 if self.config.get('safe_mode', False):\n                     # In safe mode, catch the exception and attach it to\n                     # a blank urllib3.HTTPResponse object.\n@@ -599,7 +620,7 @@ class Response(object):\n     def __repr__(self):\n         return '<Response [%s]>' % (self.status_code)\n \n-    def __nonzero__(self):\n+    def __bool__(self):\n         \"\"\"Returns true if :attr:`status_code` is 'OK'.\"\"\"\n         return self.ok\n \n@@ -750,15 +771,15 @@ class Response(object):\n \n         # Decode unicode from given encoding.\n         try:\n-            content = unicode(self.content, encoding)\n-        except UnicodeError, TypeError:\n+            content = str(self.content, encoding)\n+        except (UnicodeError, TypeError):\n             pass\n \n         # Try to fall back:\n         if not content:\n             try:\n-                content = unicode(content, encoding, errors='replace')\n-            except UnicodeError, TypeError:\n+                content = str(content, encoding, errors='replace')\n+            except (UnicodeError, TypeError):\n                 pass\n \n \n\n@@ -318,7 +318,7 @@ _Translator       = {\n     '\\375' : '\\\\375',  '\\376' : '\\\\376',  '\\377' : '\\\\377'\n     }\n \n-_idmap = ''.join(chr(x) for x in xrange(256))\n+_idmap = ''.join(chr(x) for x in range(256))\n \n def _quote(str, LegalChars=_LegalChars,\n            idmap=_idmap, translate=string.translate):\n\n@@ -15,13 +15,13 @@ try:   # Python 3\n     from http.client import HTTPConnection, HTTPSConnection, HTTPException\n     from http.client import HTTP_PORT, HTTPS_PORT\n except ImportError:\n-    from httplib import HTTPConnection, HTTPSConnection, HTTPException\n-    from httplib import HTTP_PORT, HTTPS_PORT\n+    from http.client import HTTPConnection, HTTPSConnection, HTTPException\n+    from http.client import HTTP_PORT, HTTPS_PORT\n \n try:   # Python 3\n     from queue import Queue, Empty, Full\n except ImportError:\n-    from Queue import Queue, Empty, Full\n+    from queue import Queue, Empty, Full\n \n try:   # Compiled with SSL?\n     import ssl\n@@ -40,8 +40,8 @@ from .exceptions import (SSLError,\n     EmptyPoolError,\n )\n \n-from urllib3.packages.ssl_match_hostname import match_hostname, CertificateError\n-from urllib3.packages import six\n+from .packages.ssl_match_hostname import match_hostname, CertificateError\n+from .packages import six\n \n xrange = six.moves.xrange\n \n@@ -160,7 +160,7 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n         self.headers = headers or {}\n \n         # Fill the queue up so that doing get() on it will block properly\n-        for _ in xrange(maxsize):\n+        for _ in range(maxsize):\n             self.pool.put(None)\n \n         # These are mostly for testing and debugging purposes.\n\n@@ -13,7 +13,7 @@ Issue #10, see: http://code.google.com/p/urllib3/issues/detail?id=10\n try:\n     from http.client import HTTPSConnection\n except ImportError:\n-    from httplib import HTTPSConnection\n+    from http.client import HTTPSConnection\n from logging import getLogger\n from ntlm import ntlm\n \n\n@@ -1,4 +1,4 @@\n-from __future__ import absolute_import\n+\n \n from . import ssl_match_hostname\n \n\n@@ -39,10 +39,10 @@ if PY3:\n \n     MAXSIZE = sys.maxsize\n else:\n-    string_types = basestring,\n-    integer_types = (int, long)\n-    class_types = (type, types.ClassType)\n-    text_type = unicode\n+    string_types = str,\n+    integer_types = (int, int)\n+    class_types = (type, type)\n+    text_type = str\n     binary_type = str\n \n     # It's possible to have sizeof(long) != sizeof(Py_ssize_t).\n@@ -230,11 +230,11 @@ if PY3:\n         return any(\"__call__\" in klass.__dict__ for klass in type(obj).__mro__)\n else:\n     def get_unbound_function(unbound):\n-        return unbound.im_func\n+        return unbound.__func__\n \n \n     def advance_iterator(it):\n-        return it.next()\n+        return next(it)\n \n     callable = callable\n _add_doc(get_unbound_function,\n@@ -278,10 +278,10 @@ else:\n     def b(s):\n         return s\n     def u(s):\n-        return unicode(s, \"unicode_escape\")\n+        return str(s, \"unicode_escape\")\n     int2byte = chr\n-    import StringIO\n-    StringIO = BytesIO = StringIO.StringIO\n+    import io\n+    StringIO = BytesIO = io.StringIO\n _add_doc(b, \"\"\"Byte literal\"\"\")\n _add_doc(u, \"\"\"Text literal\"\"\")\n \n@@ -325,19 +325,19 @@ else:\n         if fp is None:\n             return\n         def write(data):\n-            if not isinstance(data, basestring):\n+            if not isinstance(data, str):\n                 data = str(data)\n             fp.write(data)\n         want_unicode = False\n         sep = kwargs.pop(\"sep\", None)\n         if sep is not None:\n-            if isinstance(sep, unicode):\n+            if isinstance(sep, str):\n                 want_unicode = True\n             elif not isinstance(sep, str):\n                 raise TypeError(\"sep must be None or a string\")\n         end = kwargs.pop(\"end\", None)\n         if end is not None:\n-            if isinstance(end, unicode):\n+            if isinstance(end, str):\n                 want_unicode = True\n             elif not isinstance(end, str):\n                 raise TypeError(\"end must be None or a string\")\n@@ -345,12 +345,12 @@ else:\n             raise TypeError(\"invalid keyword arguments to print()\")\n         if not want_unicode:\n             for arg in args:\n-                if isinstance(arg, unicode):\n+                if isinstance(arg, str):\n                     want_unicode = True\n                     break\n         if want_unicode:\n-            newline = unicode(\"\\n\")\n-            space = unicode(\" \")\n+            newline = str(\"\\n\")\n+            space = str(\" \")\n         else:\n             newline = \"\\n\"\n             space = \" \"\n\n@@ -7,7 +7,7 @@\n try:\n     from urllib.parse import urlencode\n except ImportError:\n-    from urllib import urlencode\n+    from urllib.parse import urlencode\n \n from .filepost import encode_multipart_formdata\n \n\n@@ -67,7 +67,7 @@ class HTTPResponse(object):\n         self.strict = strict\n \n         self._decode_content = decode_content\n-        self._body = body if body and isinstance(body, basestring) else None\n+        self._body = body if body and isinstance(body, str) else None\n         self._fp = None\n         self._original_response = original_response\n \n\n@@ -25,7 +25,7 @@ def merge_kwargs(local_kwarg, default_kwarg):\n     if default_kwarg is None:\n         return local_kwarg\n \n-    if isinstance(local_kwarg, basestring):\n+    if isinstance(local_kwarg, str):\n         return local_kwarg\n \n     if local_kwarg is None:\n@@ -40,7 +40,7 @@ def merge_kwargs(local_kwarg, default_kwarg):\n     kwargs.update(local_kwarg)\n \n     # Remove keys that are set to None.\n-    for (k,v) in local_kwarg.items():\n+    for (k,v) in list(local_kwarg.items()):\n         if v is None:\n             del kwargs[k]\n \n@@ -76,7 +76,7 @@ class Session(object):\n         self.config = config or {}\n         self.verify = verify\n \n-        for (k, v) in defaults.items():\n+        for (k, v) in list(defaults.items()):\n             self.config.setdefault(k, v)\n \n         self.poolmanager = PoolManager(\n@@ -150,12 +150,12 @@ class Session(object):\n             verify = self.verify\n \n         # use session's hooks as defaults\n-        for key, cb in self.hooks.iteritems():\n+        for key, cb in list(self.hooks.items()):\n             hooks.setdefault(key, cb)\n \n         # Expand header values.\n         if headers:\n-            for k, v in headers.items() or {}:\n+            for k, v in list(headers.items()) or {}:\n                 headers[k] = header_expand(v)\n \n         args = dict(\n\n@@ -79,7 +79,7 @@ _codes = {\n \n codes = LookupDict(name='status_codes')\n \n-for (code, titles) in _codes.items():\n+for (code, titles) in list(_codes.items()):\n     for title in titles:\n         setattr(codes, title, code)\n         if not title.startswith('\\\\'):\n\n@@ -18,7 +18,7 @@ class CaseInsensitiveDict(dict):\n     @property\n     def lower_keys(self):\n         if not hasattr(self, '_lower_keys') or not self._lower_keys:\n-            self._lower_keys = dict((k.lower(), k) for k in self.iterkeys())\n+            self._lower_keys = dict((k.lower(), k) for k in list(self.keys()))\n         return self._lower_keys\n \n     def _clear_lower_keys(self):\n\n@@ -11,15 +11,34 @@ that are also useful for external consumption.\n \n import cgi\n import codecs\n-import cookielib\n+# import cookielib\n+from http import cookiejar as cookielib\n import os\n import random\n import re\n import zlib\n-import urllib\n+import urllib.request, urllib.parse, urllib.error\n \n-from urllib2 import parse_http_list as _parse_list_header\n \n+from urllib.parse import quote, unquote\n+\n+# from urllib2 import parse_http_list as _parse_list_header\n+from urllib.request import parse_http_list as _parse_list_header\n+\n+from http.cookies import SimpleCookie\n+\n+def dict_from_string(s):\n+    \"\"\"Returns a MultiDict with Cookies.\"\"\"\n+\n+    cookies = dict()\n+\n+    c = SimpleCookie()\n+    c.load(s)\n+\n+    for k,v in list(c.items()):\n+        cookies.update({k: v.value})\n+\n+    return cookies\n \n def guess_filename(obj):\n     \"\"\"Tries to guess the filename of the given object.\"\"\"\n@@ -132,16 +151,16 @@ def header_expand(headers):\n     collector = []\n \n     if isinstance(headers, dict):\n-        headers = headers.items()\n+        headers = list(headers.items())\n \n-    elif isinstance(headers, basestring):\n+    elif isinstance(headers, str):\n         return headers\n \n     for i, (value, params) in enumerate(headers):\n \n         _params = []\n \n-        for (p_k, p_v) in params.items():\n+        for (p_k, p_v) in list(params.items()):\n \n             _params.append('%s=%s' % (p_k, p_v))\n \n@@ -166,17 +185,8 @@ def header_expand(headers):\n \n def randombytes(n):\n     \"\"\"Return n random bytes.\"\"\"\n-    # Use /dev/urandom if it is available.  Fall back to random module\n-    # if not.  It might be worthwhile to extend this function to use\n-    # other platform-specific mechanisms for getting random bytes.\n-    if os.path.exists(\"/dev/urandom\"):\n-        f = open(\"/dev/urandom\")\n-        s = f.read(n)\n-        f.close()\n-        return s\n-    else:\n-        L = [chr(random.randrange(0, 256)) for i in range(n)]\n-        return \"\".join(L)\n+    L = [chr(random.randrange(0, 256)).encode('utf-8') for i in range(n)]\n+    return b\"\".join(L)\n \n \n def dict_from_cookiejar(cj):\n@@ -187,9 +197,9 @@ def dict_from_cookiejar(cj):\n \n     cookie_dict = {}\n \n-    for _, cookies in cj._cookies.items():\n-        for _, cookies in cookies.items():\n-            for cookie in cookies.values():\n+    for _, cookies in list(cj._cookies.items()):\n+        for _, cookies in list(cookies.items()):\n+            for cookie in list(cookies.values()):\n                 # print cookie\n                 cookie_dict[cookie.name] = cookie.value\n \n@@ -221,7 +231,7 @@ def add_dict_to_cookiejar(cj, cookie_dict):\n     :param cookie_dict: Dict of key/values to insert into CookieJar.\n     \"\"\"\n \n-    for k, v in cookie_dict.items():\n+    for k, v in list(cookie_dict.items()):\n \n         cookie = cookielib.Cookie(\n             version=0,\n@@ -290,7 +300,7 @@ def unicode_from_html(content):\n     for encoding in encodings:\n \n         try:\n-            return unicode(content, encoding)\n+            return str(content, encoding)\n         except (UnicodeError, TypeError):\n             pass\n \n@@ -337,13 +347,13 @@ def get_unicode_from_response(r):\n \n     if encoding:\n         try:\n-            return unicode(r.content, encoding)\n+            return str(r.content, encoding)\n         except UnicodeError:\n             tried_encodings.append(encoding)\n \n     # Fall back:\n     try:\n-        return unicode(r.content, encoding, errors='replace')\n+        return str(r.content, encoding, errors='replace')\n     except TypeError:\n         return r.content\n \n@@ -396,6 +406,6 @@ def requote_path(path):\n     This function passes the given path through an unquote/quote cycle to\n     ensure that it is fully and consistently quoted.\n     \"\"\"\n-    parts = path.split(\"/\")\n-    parts = (urllib.quote(urllib.unquote(part), safe=\"\") for part in parts)\n-    return \"/\".join(parts)\n+    parts = path.split(b\"/\")\n+    parts = (quote(unquote(part), safe=b\"\") for part in parts)\n+    return b\"/\".join(parts)\n\n@@ -3,16 +3,16 @@\n \n \n \n-from __future__ import with_statement\n \n-import StringIO\n+\n+import io\n import time\n import os\n import sys\n import unittest\n \n import requests\n-import envoy\n+# import envoy\n from requests import HTTPError\n from requests.auth import HTTPBasicAuth, HTTPDigestAuth\n \n@@ -50,8 +50,8 @@ class RequestsTestSuite(unittest.TestCase):\n         global _httpbin\n \n         if (not 'HTTPBIN_URL' in os.environ) and not _httpbin:\n-            c = envoy.connect('httpbin %s' % (PORT))\n-            time.sleep(1)\n+            # c = envoy.connect('httpbin %s' % (PORT))\n+            # time.sleep(1)\n             _httpbin = True\n \n \n@@ -94,7 +94,7 @@ class RequestsTestSuite(unittest.TestCase):\n \n         r = requests.get(httpbin('user-agent'), headers=heads)\n \n-        assert heads['User-agent'] in r.content\n+        assert heads['User-agent'] in r.text\n         self.assertEqual(r.status_code, 200)\n \n \n@@ -114,7 +114,7 @@ class RequestsTestSuite(unittest.TestCase):\n         }\n \n         r = requests.get(httpbin('user-agent'), headers=heads);\n-        self.assertTrue(heads['User-agent'] in r.content)\n+        self.assertTrue(heads['User-agent'] in r.text)\n \n         heads = {\n             'user-agent':\n@@ -122,7 +122,7 @@ class RequestsTestSuite(unittest.TestCase):\n         }\n \n         r = requests.get(httpbin('user-agent'), headers=heads);\n-        self.assertTrue(heads['user-agent'] in r.content)\n+        self.assertTrue(heads['user-agent'] in r.text)\n \n \n     def test_HTTP_200_OK_HEAD(self):\n@@ -290,7 +290,7 @@ class RequestsTestSuite(unittest.TestCase):\n \n             response = requests.get(url)\n \n-            self.assertIsInstance(response.url, unicode)\n+            self.assertIsInstance(response.url, str)\n \n \n     def test_unicode_get(self):\n@@ -299,11 +299,21 @@ class RequestsTestSuite(unittest.TestCase):\n \n             url = service('/get')\n \n-            requests.get(url, params={'foo': u'føø'})\n-            requests.get(url, params={u'føø': u'føø'})\n+            requests.get(url, params={'foo': 'føø'})\n             requests.get(url, params={'føø': 'føø'})\n-            requests.get(url, params={'foo': u'foo'})\n-            requests.get(service('ø'), params={'foo': u'foo'})\n+            requests.get(url, params={'føø': 'føø'})\n+            requests.get(url, params={'foo': 'foo'})\n+            # print('\\n')\n+            # print('\\n')\n+            # print('\\n')\n+            # print('\\n')\n+            # print(service('ø'))\n+            # print('\\n')\n+            # print('\\n')\n+            # print('\\n')\n+            # print('\\n')\n+            # print('\\n')\n+            requests.get(service('ø'), params={'foo': 'foo'})\n \n \n     def test_httpauth_recursion(self):\n@@ -312,7 +322,7 @@ class RequestsTestSuite(unittest.TestCase):\n \n         for service in SERVICES:\n             r = requests.get(service('basic-auth', 'user', 'pass'), auth=http_auth)\n-            self.assertEquals(r.status_code, 401)\n+            self.assertEqual(r.status_code, 401)\n \n \n     def test_urlencoded_post_data(self):\n@@ -321,14 +331,14 @@ class RequestsTestSuite(unittest.TestCase):\n \n             r = requests.post(service('post'), data=dict(test='fooaowpeuf'))\n \n-            self.assertEquals(r.status_code, 200)\n-            self.assertEquals(r.headers['content-type'], 'application/json')\n-            self.assertEquals(r.url, service('post'))\n+            self.assertEqual(r.status_code, 200)\n+            self.assertEqual(r.headers['content-type'], 'application/json')\n+            self.assertEqual(r.url, service('post'))\n \n-            rbody = json.loads(r.content)\n+            rbody = json.loads(r.text)\n \n-            self.assertEquals(rbody.get('form'), dict(test='fooaowpeuf'))\n-            self.assertEquals(rbody.get('data'), '')\n+            self.assertEqual(rbody.get('form'), dict(test='fooaowpeuf'))\n+            self.assertEqual(rbody.get('data'), '')\n \n \n     def test_nonurlencoded_post_data(self):\n@@ -337,15 +347,15 @@ class RequestsTestSuite(unittest.TestCase):\n \n             r = requests.post(service('post'), data='fooaowpeuf')\n \n-            self.assertEquals(r.status_code, 200)\n-            self.assertEquals(r.headers['content-type'], 'application/json')\n-            self.assertEquals(r.url, service('post'))\n+            self.assertEqual(r.status_code, 200)\n+            self.assertEqual(r.headers['content-type'], 'application/json')\n+            self.assertEqual(r.url, service('post'))\n \n-            rbody = json.loads(r.content)\n+            rbody = json.loads(r.text)\n             # Body wasn't valid url encoded data, so the server returns None as\n             # \"form\" and the raw body as \"data\".\n-            self.assertEquals(rbody.get('form'), {})\n-            self.assertEquals(rbody.get('data'), 'fooaowpeuf')\n+            self.assertEqual(rbody.get('form'), {})\n+            self.assertEqual(rbody.get('data'), 'fooaowpeuf')\n \n \n     def test_urlencoded_post_querystring(self):\n@@ -354,13 +364,13 @@ class RequestsTestSuite(unittest.TestCase):\n \n             r = requests.post(service('post'), params=dict(test='fooaowpeuf'))\n \n-            self.assertEquals(r.status_code, 200)\n-            self.assertEquals(r.headers['content-type'], 'application/json')\n-            self.assertEquals(r.url, service('post?test=fooaowpeuf'))\n+            self.assertEqual(r.status_code, 200)\n+            self.assertEqual(r.headers['content-type'], 'application/json')\n+            self.assertEqual(r.url, service('post?test=fooaowpeuf'))\n \n-            rbody = json.loads(r.content)\n-            self.assertEquals(rbody.get('form'), {}) # No form supplied\n-            self.assertEquals(rbody.get('data'), '')\n+            rbody = json.loads(r.text)\n+            self.assertEqual(rbody.get('form'), {}) # No form supplied\n+            self.assertEqual(rbody.get('data'), '')\n \n \n     def test_urlencoded_post_query_and_data(self):\n@@ -372,13 +382,13 @@ class RequestsTestSuite(unittest.TestCase):\n                 params=dict(test='fooaowpeuf'),\n                 data=dict(test2=\"foobar\"))\n \n-            self.assertEquals(r.status_code, 200)\n-            self.assertEquals(r.headers['content-type'], 'application/json')\n-            self.assertEquals(r.url, service('post?test=fooaowpeuf'))\n+            self.assertEqual(r.status_code, 200)\n+            self.assertEqual(r.headers['content-type'], 'application/json')\n+            self.assertEqual(r.url, service('post?test=fooaowpeuf'))\n \n-            rbody = json.loads(r.content)\n-            self.assertEquals(rbody.get('form'), dict(test2='foobar'))\n-            self.assertEquals(rbody.get('data'), '')\n+            rbody = json.loads(r.text)\n+            self.assertEqual(rbody.get('form'), dict(test2='foobar'))\n+            self.assertEqual(rbody.get('data'), '')\n \n \n     def test_nonurlencoded_postdata(self):\n@@ -387,13 +397,13 @@ class RequestsTestSuite(unittest.TestCase):\n \n             r = requests.post(service('post'), data=\"foobar\")\n \n-            self.assertEquals(r.status_code, 200)\n-            self.assertEquals(r.headers['content-type'], 'application/json')\n+            self.assertEqual(r.status_code, 200)\n+            self.assertEqual(r.headers['content-type'], 'application/json')\n \n-            rbody = json.loads(r.content)\n+            rbody = json.loads(r.text)\n \n-            self.assertEquals(rbody.get('form'), {})\n-            self.assertEquals(rbody.get('data'), 'foobar')\n+            self.assertEqual(rbody.get('form'), {})\n+            self.assertEqual(rbody.get('data'), 'foobar')\n \n \n     # def test_idna(self):\n@@ -406,8 +416,8 @@ class RequestsTestSuite(unittest.TestCase):\n         for service in SERVICES:\n \n             r = requests.get(service('get'), params=dict(test=['foo','baz']))\n-            self.assertEquals(r.status_code, 200)\n-            self.assertEquals(r.url, service('get?test=foo&test=baz'))\n+            self.assertEqual(r.status_code, 200)\n+            self.assertEqual(r.url, service('get?test=foo&test=baz'))\n \n \n     def test_urlencoded_post_querystring_multivalued(self):\n@@ -415,13 +425,13 @@ class RequestsTestSuite(unittest.TestCase):\n         for service in SERVICES:\n \n             r = requests.post(service('post'), params=dict(test=['foo','baz']))\n-            self.assertEquals(r.status_code, 200)\n-            self.assertEquals(r.headers['content-type'], 'application/json')\n-            self.assertEquals(r.url, service('post?test=foo&test=baz'))\n+            self.assertEqual(r.status_code, 200)\n+            self.assertEqual(r.headers['content-type'], 'application/json')\n+            self.assertEqual(r.url, service('post?test=foo&test=baz'))\n \n-            rbody = json.loads(r.content)\n-            self.assertEquals(rbody.get('form'), {}) # No form supplied\n-            self.assertEquals(rbody.get('data'), '')\n+            rbody = json.loads(r.text)\n+            self.assertEqual(rbody.get('form'), {}) # No form supplied\n+            self.assertEqual(rbody.get('data'), '')\n \n \n     def test_urlencoded_post_query_multivalued_and_data(self):\n@@ -433,12 +443,16 @@ class RequestsTestSuite(unittest.TestCase):\n                 params=dict(test=['foo','baz']),\n                 data=dict(test2=\"foobar\",test3=['foo','baz']))\n \n-            self.assertEquals(r.status_code, 200)\n-            self.assertEquals(r.headers['content-type'], 'application/json')\n-            self.assertEquals(r.url, service('post?test=foo&test=baz'))\n-            rbody = json.loads(r.content)\n-            self.assertEquals(rbody.get('form'), dict(test2='foobar',test3=['foo','baz']))\n-            self.assertEquals(rbody.get('data'), '')\n+            self.assertEqual(r.status_code, 200)\n+            self.assertEqual(r.headers['content-type'], 'application/json')\n+            self.assertEqual(r.url, service('post?test=foo&test=baz'))\n+\n+            # print(r.text)\n+            # print('-----------------------')\n+\n+            rbody = json.loads(r.text)\n+            self.assertEqual(rbody.get('form'), dict(test2='foobar',test3=['foo','baz']))\n+            self.assertEqual(rbody.get('data'), '')\n \n \n     def test_GET_no_redirect(self):\n@@ -446,8 +460,8 @@ class RequestsTestSuite(unittest.TestCase):\n         for service in SERVICES:\n \n             r = requests.get(service('redirect', '3'), allow_redirects=False)\n-            self.assertEquals(r.status_code, 302)\n-            self.assertEquals(len(r.history), 0)\n+            self.assertEqual(r.status_code, 302)\n+            self.assertEqual(len(r.history), 0)\n \n \n     def test_HEAD_no_redirect(self):\n@@ -455,8 +469,8 @@ class RequestsTestSuite(unittest.TestCase):\n         for service in SERVICES:\n \n             r = requests.head(service('redirect', '3'), allow_redirects=False)\n-            self.assertEquals(r.status_code, 302)\n-            self.assertEquals(len(r.history), 0)\n+            self.assertEqual(r.status_code, 302)\n+            self.assertEqual(len(r.history), 0)\n \n \n     def test_redirect_history(self):\n@@ -464,8 +478,8 @@ class RequestsTestSuite(unittest.TestCase):\n         for service in SERVICES:\n \n             r = requests.get(service('redirect', '3'))\n-            self.assertEquals(r.status_code, 200)\n-            self.assertEquals(len(r.history), 3)\n+            self.assertEqual(r.status_code, 200)\n+            self.assertEqual(len(r.history), 3)\n \n \n     def test_relative_redirect_history(self):\n@@ -473,8 +487,8 @@ class RequestsTestSuite(unittest.TestCase):\n         for service in SERVICES:\n \n             r = requests.get(service('relative-redirect', '3'))\n-            self.assertEquals(r.status_code, 200)\n-            self.assertEquals(len(r.history), 3)\n+            self.assertEqual(r.status_code, 200)\n+            self.assertEqual(len(r.history), 3)\n \n \n     def test_session_HTTP_200_OK_GET(self):\n@@ -493,14 +507,14 @@ class RequestsTestSuite(unittest.TestCase):\n \n         # Make 2 requests from Session object, should send header both times\n         r1 = s.get(httpbin('user-agent'))\n-        assert heads['User-agent'] in r1.content\n+        assert heads['User-agent'] in r1.text\n \n         r2 = s.get(httpbin('user-agent'))\n-        assert heads['User-agent'] in r2.content\n+        assert heads['User-agent'] in r2.text\n \n         new_heads = {'User-agent': 'blah'}\n         r3 = s.get(httpbin('user-agent'), headers=new_heads)\n-        assert new_heads['User-agent'] in r3.content\n+        assert new_heads['User-agent'] in r3.text\n \n         self.assertEqual(r2.status_code, 200)\n \n@@ -526,7 +540,7 @@ class RequestsTestSuite(unittest.TestCase):\n                 }\n             )\n \n-            assert 'foo' in response.content\n+            assert 'foo' in response.text\n \n     def test_multiple_hooks(self):\n \n@@ -560,8 +574,8 @@ class RequestsTestSuite(unittest.TestCase):\n                 }\n             )\n \n-            assert 'foo' in response.content\n-            assert 'bar' in response.content\n+            assert 'foo' in response.text\n+            assert 'bar' in response.text\n \n     def test_session_persistent_cookies(self):\n \n@@ -573,35 +587,35 @@ class RequestsTestSuite(unittest.TestCase):\n         r = s.get(httpbin('cookies'))\n \n         # Those cookies persist transparently.\n-        c = json.loads(r.content).get('cookies')\n+        c = json.loads(r.text).get('cookies')\n         assert c == _c\n \n         # Double check.\n         r = s.get(httpbin('cookies'), cookies={})\n-        c = json.loads(r.content).get('cookies')\n+        c = json.loads(r.text).get('cookies')\n         assert c == _c\n \n         # Remove a cookie by setting it's value to None.\n         r = s.get(httpbin('cookies'), cookies={'bessie': None})\n-        c = json.loads(r.content).get('cookies')\n+        c = json.loads(r.text).get('cookies')\n         del _c['bessie']\n         assert c == _c\n \n         # Test session-level cookies.\n         s = requests.session(cookies=_c)\n         r = s.get(httpbin('cookies'))\n-        c = json.loads(r.content).get('cookies')\n+        c = json.loads(r.text).get('cookies')\n         assert c == _c\n \n         # Have the server set a cookie.\n         r = s.get(httpbin('cookies', 'set', 'k', 'v'), allow_redirects=True)\n-        c = json.loads(r.content).get('cookies')\n+        c = json.loads(r.text).get('cookies')\n \n         assert 'k' in c\n \n         # And server-set cookie persistience.\n         r = s.get(httpbin('cookies'))\n-        c = json.loads(r.content).get('cookies')\n+        c = json.loads(r.text).get('cookies')\n \n         assert 'k' in c\n \n@@ -616,23 +630,23 @@ class RequestsTestSuite(unittest.TestCase):\n \n         # Make 2 requests from Session object, should send header both times\n         r1 = s.get(httpbin('get'))\n-        assert params['a'] in r1.content\n+        assert params['a'] in r1.text\n \n \n         params2 = {'b': 'b_test'}\n \n         r2 = s.get(httpbin('get'), params=params2)\n-        assert params['a'] in r2.content\n-        assert params2['b'] in r2.content\n+        assert params['a'] in r2.text\n+        assert params2['b'] in r2.text\n \n \n         params3 = {'b': 'b_test', 'a': None, 'c': 'c_test'}\n \n         r3 = s.get(httpbin('get'), params=params3)\n \n-        assert not params['a'] in r3.content\n-        assert params3['b'] in r3.content\n-        assert params3['c'] in r3.content\n+        assert not params['a'] in r3.text\n+        assert params3['b'] in r3.text\n+        assert params3['c'] in r3.text\n \n     def test_invalid_content(self):\n         # WARNING: if you're using a terrible DNS provider (comcast),\n@@ -653,12 +667,14 @@ class RequestsTestSuite(unittest.TestCase):\n     def test_cached_response(self):\n \n         r1 = requests.get(httpbin('get'), prefetch=False)\n+        assert not r1._content\n         assert r1.content\n-        assert r1.content\n+        assert r1.text\n \n         r2 = requests.get(httpbin('get'), prefetch=True)\n         assert r2._content\n         assert r2.content\n+        assert r2.text\n \n     def test_iter_lines(self):\n \n@@ -680,7 +696,7 @@ class RequestsTestSuite(unittest.TestCase):\n \n         # Make a request and monkey-patch its contents\n         r = requests.get(httpbin('get'))\n-        r.raw = StringIO.StringIO(quote)\n+        r.raw = io.StringIO(quote)\n \n         # Make sure iter_lines doesn't chop the trailing bit\n         lines = '\\n'.join(r.iter_lines())\n@@ -693,11 +709,11 @@ class RequestsTestSuite(unittest.TestCase):\n         # Safe mode creates empty responses for failed requests.\n         # Iterating on these responses should produce empty sequences\n         r = safe.get('http://_/')\n-        self.assertEquals(list(r.iter_lines()), [])\n+        self.assertEqual(list(r.iter_lines()), [])\n         self.assertIsInstance(r.error, requests.exceptions.ConnectionError)\n \n         r = safe.get('http://_/')\n-        self.assertEquals(list(r.iter_content()), [])\n+        self.assertEqual(list(r.iter_content()), [])\n         self.assertIsInstance(r.error, requests.exceptions.ConnectionError)\n \n         # When not in safe mode, should raise Timeout exception\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
