{"custom_id": "requests#ed642cfb6d471f2462953ac5f4f33a443750bd02", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 2 | Files Changed: 3 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 6 | Churn Cumulative: 2374 | Contributors (this commit): 35 | Commits (past 90d): 11 | Contributors (cumulative): 52 | DMM Complexity: 1.0\n\nDIFF:\n@@ -44,7 +44,7 @@ def request(method, url, **kwargs):\n     adhoc_session = False\n     session = kwargs.pop('session', None)\n     if session is None:\n-        session = sessions.session()\n+        session = sessions.session(config=kwargs.get('config', None))\n         adhoc_session = True\n \n     try:\n\n@@ -48,3 +48,4 @@ defaults['keep_alive'] = True\n defaults['encode_uri'] = True\n defaults['trust_env'] = True\n defaults['store_cookies'] = True\n+defaults['support_http0.9'] = True\n\n@@ -98,7 +98,8 @@ class Session(object):\n     def init_poolmanager(self):\n         self.poolmanager = PoolManager(\n             num_pools=self.config.get('pool_connections'),\n-            maxsize=self.config.get('pool_maxsize')\n+            maxsize=self.config.get('pool_maxsize'),\n+            strict=not self.config.get('support_http0.9')\n         )\n \n     def __repr__(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#93b2be48f0db93d96495212da96257051ae24ee9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 5842 | Contributors (this commit): 88 | Commits (past 90d): 24 | Contributors (cumulative): 88 | DMM Complexity: None\n\nDIFF:\n@@ -700,6 +700,8 @@ class Response(object):\n         self.headers = CaseInsensitiveDict()\n \n         #: File-like object representation of response (for advanced usage).\n+        #: Requires that ``prefetch=False` on the request.\n+        # This requirement does not apply for use internally to Requests.\n         self.raw = None\n \n         #: Final URL location of Response.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#710f09f806404fedc4b54e3a31125a2aa1bd7543", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 4 | Files Changed: 3 | Hunks: 4 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 8 | Churn Cumulative: 1844 | Contributors (this commit): 32 | Commits (past 90d): 17 | Contributors (cumulative): 39 | DMM Complexity: None\n\nDIFF:\n@@ -37,7 +37,7 @@ The other HTTP methods are supported - see `requests.api`. Full documentation\n is at <http://python-requests.org>.\n \n :copyright: (c) 2012 by Kenneth Reitz.\n-:license: ISC, see LICENSE for more details.\n+:license: Apache 2.0, see LICENSE for more details.\n \n \"\"\"\n \n@@ -45,7 +45,7 @@ __title__ = 'requests'\n __version__ = '0.14.2'\n __build__ = 0x001402\n __author__ = 'Kenneth Reitz'\n-__license__ = 'ISC'\n+__license__ = 'Apache 2.0'\n __copyright__ = 'Copyright 2012 Kenneth Reitz'\n \n \n\n@@ -7,7 +7,7 @@ requests.api\n This module implements the Requests API.\n \n :copyright: (c) 2012 by Kenneth Reitz.\n-:license: ISC, see LICENSE for more details.\n+:license: Apache2, see LICENSE for more details.\n \n \"\"\"\n \n\n@@ -45,7 +45,7 @@ setup(\n         'Development Status :: 5 - Production/Stable',\n         'Intended Audience :: Developers',\n         'Natural Language :: English',\n-        'License :: OSI Approved :: ISC License (ISCL)',\n+        'License :: OSI Approved :: Apache Software License',\n         'Programming Language :: Python',\n         'Programming Language :: Python :: 2.6',\n         'Programming Language :: Python :: 2.7',\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#500dc7886712b1e2cb112b837769230544d88b1e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 2 | Churn Cumulative: 5844 | Contributors (this commit): 89 | Commits (past 90d): 22 | Contributors (cumulative): 89 | DMM Complexity: None\n\nDIFF:\n@@ -233,7 +233,7 @@ class Request(object):\n \n         if r.status_code in REDIRECT_STATI and not self.redirect:\n \n-            while (('location' in r.headers) and\n+            while (('location' in r.headers and r.status_code in REDIRECT_STATI) and\n                    ((r.status_code is codes.see_other) or (self.allow_redirects))):\n \n                 r.content  # Consume socket so it can be released\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f69934fb24a9e59f76a2c17993082259bf3a4d90", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 807 | Contributors (this commit): 16 | Commits (past 90d): 4 | Contributors (cumulative): 16 | DMM Complexity: None\n\nDIFF:\n@@ -19,7 +19,8 @@ from .compat import urlparse, str\n from .utils import parse_dict_header\n \n try:\n-    from ._oauth import (Client, SIGNATURE_HMAC, SIGNATURE_TYPE_AUTH_HEADER, extract_params)\n+    from oauthlib.common import extract_params\n+    from oauthlib.oauth1.rfc5849 import (Client, SIGNATURE_HMAC, SIGNATURE_TYPE_AUTH_HEADER)\n \n except (ImportError, SyntaxError):\n     SIGNATURE_HMAC = None\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#17aee319406fe13cb47196e186164f5c21b9f514", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 10 | Files Changed: 3 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 10 | Churn Cumulative: 20 | Contributors (this commit): 2 | Commits (past 90d): 6 | Contributors (cumulative): 6 | DMM Complexity: None\n\nDIFF:\n\n@@ -1,4 +0,0 @@\n-from requests.packages import chardet\n-\n-with open('test', 'rb') as f:\n-    print(chardet.detect(f.read()))\n\\ No newline at end of file\n\n@@ -1,6 +0,0 @@\n-import requests\n-\n-r = requests.get('http://readability.com')\n-r.encoding = None\n-\n-print(r.text)\n\\ No newline at end of file\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#a98ec717f2312f6882a90deded17ef75cbbb1991", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 67 | Contributors (this commit): 2 | Commits (past 90d): 2 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -46,7 +46,7 @@ class KeepAliveTests(unittest.TestCase):\n         self.make_requests(self.proxies)\r\n \r\n     def make_requests(self, proxies=None):\r\n-        for _ in xrange(self.request_count):\r\n+        for _ in range(self.request_count):\n             self.session.get(self.url, proxies=proxies).text\r\n \r\n     def check_each_request_are_in_same_connection(self):\r\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#67c7e496f5f7340387da196d31f59512c366328d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 70 | Files Changed: 1 | Hunks: 4 | Methods Changed: 4 | Complexity Δ (Sum/Max): -3/0 | Churn Δ: 70 | Churn Cumulative: 1301 | Contributors (this commit): 25 | Commits (past 90d): 11 | Contributors (cumulative): 25 | DMM Complexity: 0.0\n\nDIFF:\n@@ -931,19 +931,6 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n         self.assertTrue(ds1.prefetch)\n         self.assertFalse(ds2.prefetch)\n \n-    def test_session_connection_error_with_safe_mode(self):\n-        config = {\"safe_mode\":True}\n-\n-        s = requests.session()\n-        r = s.get(\"http://localhost:1/nope\", timeout=0.1, config=config)\n-        self.assertFalse(r.ok)\n-        self.assertTrue(r.content is None)\n-\n-        s2 = requests.session(config=config)\n-        r2 = s2.get(\"http://localhost:1/nope\", timeout=0.1)\n-        self.assertFalse(r2.ok)\n-        self.assertTrue(r2.content is None)\n-\n     def test_connection_error(self):\n         try:\n             get('http://localhost:1/nope')\n@@ -952,26 +939,6 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n         else:\n             self.fail()\n \n-    def test_connection_error_with_safe_mode(self):\n-        config = {'safe_mode': True}\n-        r = get('http://localhost:1/nope', allow_redirects=False, config=config)\n-        self.assertTrue(r.content is None)\n-\n-    # def test_invalid_content(self):\n-    #     # WARNING: if you're using a terrible DNS provider (comcast),\n-    #     # this will fail.\n-    #     try:\n-    #         hah = 'http://somedomainthatclearlydoesntexistg.com'\n-    #         r = get(hah, allow_redirects=False)\n-    #     except requests.ConnectionError:\n-    #         pass   # \\o/\n-    #     else:\n-    #         assert False\n-\n-    #     config = {'safe_mode': True}\n-    #     r = get(hah, allow_redirects=False, config=config)\n-    #     assert r.content == None\n-\n     def test_cached_response(self):\n \n         r1 = get(httpbin('get'), prefetch=False)\n@@ -1032,32 +999,6 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n             self.assertEqual(bytes().join(r.iter_content(chunk_size=chunk_size)), r.content)\n \n \n-    # def test_safe_mode(self):\n-\n-    #     safe = requests.session(config=dict(safe_mode=True))\n-\n-    #     # Safe mode creates empty responses for failed requests.\n-    #     # Iterating on these responses should produce empty sequences\n-    #     r = get('http://0.0.0.0:700/', session=safe)\n-    #     self.assertEqual(list(r.iter_lines()), [])\n-    #     assert isinstance(r.error, requests.exceptions.ConnectionError)\n-\n-    #     r = get('http://0.0.0.0:789/', session=safe)\n-    #     self.assertEqual(list(r.iter_content()), [])\n-    #     assert isinstance(r.error, requests.exceptions.ConnectionError)\n-\n-    #     # When not in safe mode, should raise Timeout exception\n-    #     self.assertRaises(\n-    #         requests.exceptions.Timeout,\n-    #         get,\n-    #         httpbin('stream', '1000'), timeout=0.0001)\n-\n-    #     # In safe mode, should return a blank response\n-    #     r = get(httpbin('stream', '1000'), timeout=0.0001,\n-    #             config=dict(safe_mode=True))\n-    #     assert r.content is None\n-    #     assert isinstance(r.error, requests.exceptions.Timeout)\n-\n     def test_upload_binary_data(self):\n \n         requests.get(httpbin('post'), auth=('a', 'b'), data='\\xff')\n@@ -1094,17 +1035,6 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n         r = requests.get(httpbin('status', '404'))\n         r.text\n \n-    def test_max_redirects(self):\n-        \"\"\"Test the max_redirects config variable, normally and under safe_mode.\"\"\"\n-        def unsafe_callable():\n-            requests.get(httpbin('redirect', '3'), config=dict(max_redirects=2))\n-        self.assertRaises(requests.exceptions.TooManyRedirects, unsafe_callable)\n-\n-        # add safe mode\n-        response = requests.get(httpbin('redirect', '3'), config=dict(safe_mode=True, max_redirects=2))\n-        self.assertTrue(response.content is None)\n-        self.assertTrue(isinstance(response.error, requests.exceptions.TooManyRedirects))\n-\n     def test_connection_keepalive_and_close(self):\n         \"\"\"Test that we send 'Connection: close' when keep_alive is disabled.\"\"\"\n         # keep-alive should be on by default\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#79992579c9289144ce0bb690c15b7f658f530768", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 13 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 13 | Churn Cumulative: 1314 | Contributors (this commit): 25 | Commits (past 90d): 12 | Contributors (cumulative): 25 | DMM Complexity: 0.0\n\nDIFF:\n@@ -462,15 +462,6 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n         self.assertFalse(r.error)\n         r.raise_for_status()\n \n-    def test_default_status_raising(self):\n-        config = {'danger_mode': True}\n-        args = [httpbin('status', '404')]\n-        kwargs = dict(config=config)\n-        self.assertRaises(HTTPError, get, *args, **kwargs)\n-\n-        r = get(httpbin('status', '200'))\n-        self.assertEqual(r.status_code, 200)\n-\n     def test_decompress_gzip(self):\n \n         r = get(httpbin('gzip'))\n@@ -1026,10 +1017,6 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n         except TypeError:\n             self.fail('Not able to have none in header values')\n \n-    def test_danger_mode_redirects(self):\n-        s = requests.session()\n-        s.config['danger_mode'] = True\n-        s.get(httpbin('redirect', '4'))\n \n     def test_empty_response(self):\n         r = requests.get(httpbin('status', '404'))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#2acce4221e38a76ba603e406b0b30db051b0c3e2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 6 | Files Changed: 2 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 7 | Churn Cumulative: 6093 | Contributors (this commit): 92 | Commits (past 90d): 28 | Contributors (cumulative): 96 | DMM Complexity: 0.0\n\nDIFF:\n@@ -9,17 +9,13 @@ This module provides the Requests configuration defaults.\n Configurations:\n \n :base_headers: Default HTTP headers.\n-:verbose: Stream to write request logging to.\n :max_redirects: Maximum number of redirects allowed within a request.s\n :keep_alive: Reuse HTTP Connections?\n :max_retries: The number of times a request should be retried in the event of a connection failure.\n-:strict_mode: If true, Requests will do its best to follow RFCs (e.g. POST redirects).\n :pool_maxsize: The maximium size of an HTTP connection pool.\n :pool_connections: The number of active HTTP connection pools to use.\n :encode_uri: If true, URIs will automatically be percent-encoded.\n :trust_env: If true, the surrouding environment will be trusted (environ, netrc).\n-:store_cookies: If false, the received cookies as part of the HTTP response would be ignored.\n-\n \"\"\"\n \n SCHEMAS = ['http', 'https']\n\n@@ -204,8 +204,7 @@ class Request(object):\n                 # Set encoding.\n                 response.encoding = get_encoding_from_headers(response.headers)\n \n-                # Add new cookies from the server. Don't if configured not to\n-                if self.config.get('store_cookies'):\n+                # Add new cookies from the server.\n                 extract_cookies_to_jar(self.cookies, self, resp)\n \n                 # Save cookies in Response.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4a9f3572a38796d71c5b40f1c506da03161b1c70", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 27 | Files Changed: 4 | Hunks: 6 | Methods Changed: 3 | Complexity Δ (Sum/Max): -1/1 | Churn Δ: 42 | Churn Cumulative: 6863 | Contributors (this commit): 95 | Commits (past 90d): 36 | Contributors (cumulative): 106 | DMM Complexity: 0.23076923076923078\n\nDIFF:\n@@ -58,3 +58,14 @@ from .exceptions import (\n     RequestException, Timeout, URLRequired,\n     TooManyRedirects, HTTPError, ConnectionError\n )\n+\n+# Set default logging handler to avoid \"No handler found\" warnings.\n+import logging\n+try:  # Python 2.7+\n+    from logging import NullHandler\n+except ImportError:\n+    class NullHandler(logging.Handler):\n+        def emit(self, record):\n+            pass\n+\n+logging.getLogger(__name__).addHandler(NullHandler())\n\n@@ -38,5 +38,4 @@ defaults['max_retries'] = 0\n defaults['keep_alive'] = True\n defaults['encode_uri'] = True\n defaults['trust_env'] = True\n-defaults['store_cookies'] = True\n defaults['support_http0.9'] = True\n\n@@ -10,6 +10,8 @@ This module contains the primary objects that power Requests.\n import os\n import socket\n import collections\n+import logging\n+\n from datetime import datetime\n from io import BytesIO\n \n@@ -41,6 +43,7 @@ from .compat import (\n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n CONTENT_CHUNK_SIZE = 10 * 1024\n \n+log = logging.getLogger(__name__)\n \n class Request(object):\n     \"\"\"The :class:`Request <Request>` object. It carries out all functionality\n@@ -503,10 +506,7 @@ class Request(object):\n         self.__dict__.update(r.__dict__)\n \n         # Logging\n-        if self.config.get('verbose'):\n-            self.config.get('verbose').write('%s   %s   %s\\n' % (\n-                datetime.now().isoformat(), self.method, url\n-            ))\n+        log.info('Sending %s: %s' % (self, url))\n \n         # Use .netrc auth if none was provided.\n         if not self.auth and self.config.get('trust_env'):\n\n@@ -104,28 +104,6 @@ class CookieTests(TestBaseMixin, unittest.TestCase):\n         insecure_cookies_sent = json.loads(insecure_resp.text)['cookies']\n         self.assertEqual(insecure_cookies_sent, {})\n \n-    def test_disabled_cookie_persistence(self):\n-        \"\"\"Test that cookies are not persisted when configured accordingly.\"\"\"\n-\n-        config = {'store_cookies': False}\n-\n-        # Check the case when no cookie is passed as part of the request and the one in response is ignored\n-        cookies = requests.get(httpbin('cookies', 'set', 'key', 'value'), config=config).cookies\n-        self.assertTrue(cookies.get(\"key\") is None)\n-\n-        # Test that the cookies passed while making the request still gets used and is available in response object.\n-        # only the ones received from server is not saved\n-        cookies_2 = requests.get(httpbin('cookies', 'set', 'key', 'value'), config=config,\\\n-                                                cookies={\"key_2\": \"value_2\"}).cookies\n-        self.assertEqual(len(cookies_2), 1)\n-        self.assertEqual(cookies_2.get(\"key_2\"), \"value_2\")\n-\n-        # Use the session and make sure that the received cookie is not used in subsequent calls\n-        s = requests.session()\n-        s.get(httpbin('cookies', 'set', 'key', 'value'), config=config)\n-        r = s.get(httpbin('cookies'))\n-        self.assertEqual(json.loads(r.text)['cookies'], {})\n-\n     def test_jar_utility_functions(self):\n         \"\"\"Test utility functions such as list_domains, list_paths, multiple_domains.\"\"\"\n         r = requests.get(\"http://github.com\")\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#ec5844a3bca014f71673da091c8717f114c921f0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 25 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 2 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 25 | Churn Cumulative: 25 | Contributors (this commit): 1 | Commits (past 90d): 1 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -0,0 +1,25 @@\n+import requests\n+import unittest\n+\n+\n+class IterationTestCase(unittest.TestCase):\n+\n+    def test_assertion(self):\n+        assert 1\n+\n+    # def test_dzubia(self):\n+    #     s = requests.Session()\n+    #     r = requests.Request(method='GET', url='http://github.com/')\n+\n+    #     # r = s.send(r)\n+\n+    def test_prepared_request(self):\n+        s = requests.Session()\n+        r = requests.Request(method='GET', url='http://github.com/')\n+        r = r.prepare()\n+\n+        s.send(r)\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#edfd0990b57199394446fed73b6f0ce0838ad43d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 5 | Churn Cumulative: 5860 | Contributors (this commit): 89 | Commits (past 90d): 25 | Contributors (cumulative): 89 | DMM Complexity: 1.0\n\nDIFF:\n@@ -11,6 +11,7 @@ import os\n import socket\n import collections\n import logging\n+from copy import deepcopy\n \n from datetime import datetime\n from io import BytesIO\n@@ -677,6 +678,10 @@ class Request(object):\n         except LocationParseError as e:\n             raise InvalidURL(e)\n \n+    def prepare(self):\n+        return deepcopy(self)\n+\n+\n \n class Response(object):\n     \"\"\"The core :class:`Response <Response>` object. All\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#19e1f2037c3db6269635b1e9de749efa29b1c8e1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 4 | Churn Cumulative: 1097 | Contributors (this commit): 22 | Commits (past 90d): 5 | Contributors (cumulative): 22 | DMM Complexity: 1.0\n\nDIFF:\n@@ -344,6 +344,10 @@ class Session(object):\n \n         return self.request('delete', url, **kwargs)\n \n+    def send(self, request):\n+        \"\"\"Send a given PreparedRequest.\"\"\"\n+        return request.send()\n+\n     def __getstate__(self):\n         return dict((attr, getattr(self, attr, None)) for attr in self.__attrs__)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#2161d8f78d71f619c07132add0b1966f62e40c6f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 41 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 11/11 | Churn Δ: 42 | Churn Cumulative: 6318 | Contributors (this commit): 89 | Commits (past 90d): 28 | Contributors (cumulative): 89 | DMM Complexity: 0.0\n\nDIFF:\n@@ -104,6 +104,46 @@ class RequestMixin(object):\n         else:\n             return data\n \n+    @staticmethod\n+    def _encode_files(files, data):\n+        \"\"\"Build the body for a multipart/form-data request.\n+\n+        Will successfully encode files when passed as a dict or a list of\n+        2-tuples. Order is retained if data is a list of 2-tuples but abritrary\n+        if parameters are supplied as a dict.\n+\n+        \"\"\"\n+        if (not files) or isinstance(data, str):\n+            return None\n+\n+        new_fields = []\n+        fields = to_key_val_list(data)\n+        files = to_key_val_list(files)\n+\n+        for field, val in fields:\n+            if isinstance(val, list):\n+                for v in val:\n+                    new_fields.append((field, builtin_str(v)))\n+            else:\n+                new_fields.append((field, builtin_str(val)))\n+\n+        for (k, v) in files:\n+            # support for explicit filename\n+            if isinstance(v, (tuple, list)):\n+                fn, fp = v\n+            else:\n+                fn = guess_filename(v) or k\n+                fp = v\n+            if isinstance(fp, str):\n+                fp = StringIO(fp)\n+            if isinstance(fp, bytes):\n+                fp = BytesIO(fp)\n+            new_fields.append((k, (fn, fp.read())))\n+\n+        body, content_type = encode_multipart_formdata(new_fields)\n+\n+        return body, content_type\n+\n \n class Request(object):\n     \"\"\"A user-created Request object.\"\"\"\n@@ -268,7 +308,7 @@ class PreparedRequest(RequestMixin):\n \n         # Multi-part file uploads.\n         if files:\n-            (body, content_type) = self._encode_files(files)\n+            (body, content_type) = self._encode_files(files, data)\n         else:\n             if data:\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#ab27027aa8916e6e199bbb35083beb5d6339f6aa", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 56 | Lines Deleted: 176 | Files Changed: 3 | Hunks: 28 | Methods Changed: 12 | Complexity Δ (Sum/Max): -43/0 | Churn Δ: 232 | Churn Cumulative: 7327 | Contributors (this commit): 96 | Commits (past 90d): 45 | Contributors (cumulative): 106 | DMM Complexity: 1.0\n\nDIFF:\n@@ -32,7 +32,7 @@ class MockRequest(object):\n     def __init__(self, request):\n         self._r = request\n         self._new_headers = {}\n-        self.type = urlparse(self._r.full_url).scheme\n+        self.type = urlparse(self._r.url).scheme\n \n     def get_type(self):\n         return self.type\n\n@@ -30,12 +30,7 @@ defaults['base_headers'] = {\n     'Accept': '*/*'\n }\n \n-defaults['verbose'] = None\n+# Consumed at the session level, not connection.\n defaults['max_redirects'] = 30\n-defaults['pool_connections'] = 10\n-defaults['pool_maxsize'] = 10\n-defaults['max_retries'] = 0\n-defaults['keep_alive'] = True\n-defaults['encode_uri'] = True\n defaults['trust_env'] = True\n-defaults['support_http0.9'] = True\n+# defaults['support_http0.9'] = True\n\n@@ -190,6 +190,7 @@ class Request(object):\n         p.prepare_method(self.method)\n         p.prepare_url(self.url, self.params)\n         p.prepare_headers(self.headers)\n+        p.prepare_cookies(self.cookies)\n         p.prepare_auth(self.auth)\n         p.prepare_body(self.data, self.files)\n \n@@ -347,11 +348,16 @@ class PreparedRequest(RequestMixin):\n             self.__dict__.update(r.__dict__)\n \n     def prepare_cookies(self, cookies):\n-        #: CookieJar to attach to :class:`Request <Request>`.\n+\n         if isinstance(cookies, cookielib.CookieJar):\n-            self.cookies = cookies\n+            cookies = cookies\n         else:\n-            self.cookies = cookiejar_from_dict(cookies)\n+            cookies = cookiejar_from_dict(cookies)\n+\n+        if 'cookie' not in self.headers:\n+            cookie_header = get_cookie_header(cookies, self)\n+            if cookie_header is not None:\n+                self.headers['Cookie'] = cookie_header\n \n     def send(self):\n         pass\n@@ -616,7 +622,7 @@ class OldRequest(object):\n                     verify=self.verify,\n                     session=self.session,\n                     cert=self.cert,\n-                    prefetch=self.prefetch,\n+                    prefetch=self.prefetch\n                 )\n \n                 request.send()\n@@ -628,127 +634,6 @@ class OldRequest(object):\n         self.response.request = self\n \n \n-\n-    def _encode_files(self, files):\n-        \"\"\"Build the body for a multipart/form-data request.\n-\n-        Will successfully encode files when passed as a dict or a list of\n-        2-tuples. Order is retained if data is a list of 2-tuples but abritrary\n-        if parameters are supplied as a dict.\n-\n-        \"\"\"\n-        if (not files) or isinstance(self.data, str):\n-            return None\n-\n-        new_fields = []\n-        fields = to_key_val_list(self.data)\n-        files = to_key_val_list(files)\n-\n-        for field, val in fields:\n-            if isinstance(val, list):\n-                for v in val:\n-                    new_fields.append((field, builtin_str(v)))\n-            else:\n-                new_fields.append((field, builtin_str(val)))\n-\n-        for (k, v) in files:\n-            # support for explicit filename\n-            if isinstance(v, (tuple, list)):\n-                fn, fp = v\n-            else:\n-                fn = guess_filename(v) or k\n-                fp = v\n-            if isinstance(fp, str):\n-                fp = StringIO(fp)\n-            if isinstance(fp, bytes):\n-                fp = BytesIO(fp)\n-            new_fields.append((k, (fn, fp.read())))\n-\n-        body, content_type = encode_multipart_formdata(new_fields)\n-\n-        return body, content_type\n-\n-    @property\n-    def full_url(self):\n-        \"\"\"Build the actual URL to use.\"\"\"\n-\n-        if not self.url:\n-            raise URLRequired()\n-\n-        url = self.url\n-\n-        # Support for unicode domain names and paths.\n-        scheme, netloc, path, params, query, fragment = urlparse(url)\n-\n-        if not scheme:\n-            raise MissingSchema(\"Invalid URL %r: No schema supplied\" % url)\n-\n-        if not scheme in SCHEMAS:\n-            raise InvalidSchema(\"Invalid scheme %r\" % scheme)\n-\n-        try:\n-            netloc = netloc.encode('idna').decode('utf-8')\n-        except UnicodeError:\n-            raise InvalidURL('URL has an invalid label.')\n-\n-        if not path:\n-            path = '/'\n-\n-        if is_py2:\n-            if isinstance(scheme, str):\n-                scheme = scheme.encode('utf-8')\n-            if isinstance(netloc, str):\n-                netloc = netloc.encode('utf-8')\n-            if isinstance(path, str):\n-                path = path.encode('utf-8')\n-            if isinstance(params, str):\n-                params = params.encode('utf-8')\n-            if isinstance(query, str):\n-                query = query.encode('utf-8')\n-            if isinstance(fragment, str):\n-                fragment = fragment.encode('utf-8')\n-\n-        enc_params = self._encode_params(self.params)\n-        if enc_params:\n-            if query:\n-                query = '%s&%s' % (query, enc_params)\n-            else:\n-                query = enc_params\n-\n-        url = (urlunparse([scheme, netloc, path, params, query, fragment]))\n-\n-        if self.config.get('encode_uri', True):\n-            url = requote_uri(url)\n-\n-        return url\n-\n-    @property\n-    def path_url(self):\n-        \"\"\"Build the path URL to use.\"\"\"\n-\n-        url = []\n-\n-        p = urlsplit(self.full_url)\n-\n-        # Proxies use full URLs.\n-        if p.scheme in self.proxies:\n-            url_base, frag = urldefrag(self.full_url)\n-            return url_base\n-\n-\n-        path = p.path\n-        if not path:\n-            path = '/'\n-\n-        url.append(path)\n-\n-        query = p.query\n-        if query:\n-            url.append('?')\n-            url.append(query)\n-\n-        return ''.join(url)\n-\n     def register_hook(self, event, hook):\n         \"\"\"Properly register a hook.\"\"\"\n         if isinstance(hook, collections.Callable):\n@@ -852,40 +737,40 @@ class OldRequest(object):\n         if not self.config.get('keep_alive'):\n             self.headers['Connection'] = 'close'\n \n-        if url.startswith('https') and self.verify:\n+        # if url.startswith('https') and self.verify:\n \n-            cert_loc = None\n+        #     cert_loc = None\n \n-            # Allow self-specified cert location.\n-            if self.verify is not True:\n-                cert_loc = self.verify\n+        #     # Allow self-specified cert location.\n+        #     if self.verify is not True:\n+        #         cert_loc = self.verify\n \n-            # Look for configuration.\n-            if not cert_loc and self.config.get('trust_env'):\n-                cert_loc = os.environ.get('REQUESTS_CA_BUNDLE')\n+        #     # Look for configuration.\n+        #     if not cert_loc and self.config.get('trust_env'):\n+        #         cert_loc = os.environ.get('REQUESTS_CA_BUNDLE')\n \n-            # Curl compatibility.\n-            if not cert_loc and self.config.get('trust_env'):\n-                cert_loc = os.environ.get('CURL_CA_BUNDLE')\n+        #     # Curl compatibility.\n+        #     if not cert_loc and self.config.get('trust_env'):\n+        #         cert_loc = os.environ.get('CURL_CA_BUNDLE')\n \n-            if not cert_loc:\n-                cert_loc = DEFAULT_CA_BUNDLE_PATH\n+        #     if not cert_loc:\n+        #         cert_loc = DEFAULT_CA_BUNDLE_PATH\n \n-            if not cert_loc:\n-                raise Exception(\"Could not find a suitable SSL CA certificate bundle.\")\n+        #     if not cert_loc:\n+        #         raise Exception(\"Could not find a suitable SSL CA certificate bundle.\")\n \n-            conn.cert_reqs = 'CERT_REQUIRED'\n-            conn.ca_certs = cert_loc\n-        else:\n-            conn.cert_reqs = 'CERT_NONE'\n-            conn.ca_certs = None\n+        #     conn.cert_reqs = 'CERT_REQUIRED'\n+        #     conn.ca_certs = cert_loc\n+        # else:\n+        #     conn.cert_reqs = 'CERT_NONE'\n+        #     conn.ca_certs = None\n \n-        if self.cert:\n-            if len(self.cert) == 2:\n-                conn.cert_file = self.cert[0]\n-                conn.key_file = self.cert[1]\n-            else:\n-                conn.cert_file = self.cert\n+        # if self.cert:\n+        #     if len(self.cert) == 2:\n+        #         conn.cert_file = self.cert[0]\n+        #         conn.key_file = self.cert[1]\n+        #     else:\n+        #         conn.cert_file = self.cert\n \n         if not self.sent or anyway:\n \n@@ -964,8 +849,18 @@ class OldRequest(object):\n         return deepcopy(self)\n \n \n+class BaseResponse(object):\n+    \"\"\"The basic Respone\"\"\"\n+    def __init__(self):\n+        self.url = None\n+        self.status_code = None\n+        self.reason = None\n+        self.headers = None\n+        self.data = None\n+        self.body = None\n \n-class Response(object):\n+\n+class Response(BaseResponse):\n     \"\"\"The core :class:`Response <Response>` object. All\n     :class:`Request <Request>` objects contain a\n     :class:`response <Response>` attribute, which is an instance\n@@ -973,6 +868,7 @@ class Response(object):\n     \"\"\"\n \n     def __init__(self):\n+        super(Response, self).__init__()\n \n         self._content = False\n         self._content_consumed = False\n@@ -993,9 +889,6 @@ class Response(object):\n         #: Final URL location of Response.\n         self.url = None\n \n-        #: Resulting :class:`HTTPError` of request, if one occurred.\n-        self.error = None\n-\n         #: Encoding to decode with when accessing r.text.\n         self.encoding = None\n \n@@ -1005,7 +898,9 @@ class Response(object):\n         self.history = []\n \n         #: The :class:`Request <Request>` that created the Response.\n-        self.request = None\n+        # self.request = None\n+\n+        self.reason = None\n \n         #: A CookieJar of Cookies the server sent back.\n         self.cookies = None\n@@ -1180,22 +1075,12 @@ class Response(object):\n \n         return l\n \n-    @property\n-    def reason(self):\n-        \"\"\"The HTTP Reason for the response.\"\"\"\n-        return self.raw.reason\n-\n-    def raise_for_status(self, allow_redirects=True):\n+    def raise_for_status(self):\n         \"\"\"Raises stored :class:`HTTPError` or :class:`URLError`, if one occurred.\"\"\"\n \n-        if self.error:\n-            raise self.error\n-\n         http_error_msg = ''\n-        if 300 <= self.status_code < 400 and not allow_redirects:\n-            http_error_msg = '%s Redirection: %s' % (self.status_code, self.reason)\n \n-        elif 400 <= self.status_code < 500:\n+        if 400 <= self.status_code < 500:\n             http_error_msg = '%s Client Error: %s' % (self.status_code, self.reason)\n \n         elif 500 <= self.status_code < 600:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#88d41430186b98166e20f7b6d8f100c72fcd07b3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 99 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 7 | Complexity Δ (Sum/Max): 19/19 | Churn Δ: 99 | Churn Cumulative: 99 | Contributors (this commit): 1 | Commits (past 90d): 1 | Contributors (cumulative): 1 | DMM Complexity: 0.45454545454545453\n\nDIFF:\n@@ -0,0 +1,99 @@\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+requests.adapters\n+~~~~~~~~~~~~~~~~~\n+\n+This module contains the transport adapters that Requests uses to define\n+and maintain connections.\n+\"\"\"\n+import os\n+from .packages.urllib3.poolmanager import PoolManager\n+from .utils import DEFAULT_CA_BUNDLE_PATH\n+\n+\n+DEFAULT_POOLSIZE = 10\n+DEFAULT_RETRIES = 0\n+\n+\n+class BaseAdapter(object):\n+    \"\"\"The Base Transport Adapter\"\"\"\n+\n+    def __init__(self):\n+        super(BaseAdapter, self).__init__()\n+\n+    def send(self):\n+        raise NotImplementedError\n+\n+    def close(self):\n+        raise NotImplementedError\n+\n+\n+class HTTPAdapter(BaseAdapter):\n+    \"\"\"Built-In HTTP Adapter for Urllib3.\"\"\"\n+    def __init__(self,\n+        pool_connections=DEFAULT_POOLSIZE,\n+        pool_maxsize=DEFAULT_POOLSIZE):\n+        self.max_retries = DEFAULT_RETRIES\n+        self.config = {}\n+\n+        super(HTTPAdapter, self).__init__()\n+\n+        self.init_poolmanager(pool_connections, pool_maxsize)\n+\n+    def init_poolmanager(self, connections, maxsize):\n+        self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize)\n+\n+    def cert_verify(self, conn, verify, cert):\n+        if url.startswith('https') and self.verify:\n+\n+            cert_loc = None\n+\n+            # Allow self-specified cert location.\n+            if self.verify is not True:\n+                cert_loc = self.verify\n+\n+            # Look for configuration.\n+            if not cert_loc and self.config.get('trust_env'):\n+                cert_loc = os.environ.get('REQUESTS_CA_BUNDLE')\n+\n+            # Curl compatibility.\n+            if not cert_loc and self.config.get('trust_env'):\n+                cert_loc = os.environ.get('CURL_CA_BUNDLE')\n+\n+            if not cert_loc:\n+                cert_loc = DEFAULT_CA_BUNDLE_PATH\n+\n+            if not cert_loc:\n+                raise Exception(\"Could not find a suitable SSL CA certificate bundle.\")\n+\n+            conn.cert_reqs = 'CERT_REQUIRED'\n+            conn.ca_certs = cert_loc\n+        else:\n+            conn.cert_reqs = 'CERT_NONE'\n+            conn.ca_certs = None\n+\n+        if self.cert:\n+            if len(self.cert) == 2:\n+                conn.cert_file = self.cert[0]\n+                conn.key_file = self.cert[1]\n+            else:\n+                conn.cert_file = self.cert\n+\n+    def close(self):\n+        \"\"\"Dispose of any internal state.\n+\n+        Currently, this just closes the PoolManager, which closes pooled\n+        connections.\n+        \"\"\"\n+        self.poolmanager.clear()\n+\n+    def send(self, request, timeout, verify, cert):\n+        \"\"\"Sends PreparedRequest object. Returns Response object.\"\"\"\n+\n+        conn = self._poolmanager.connection_from_url(request.url)\n+        self.cert_verify(conn, verify, cert)\n+\n+\n+\n+\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#3aefb8edc1d27c3cbb221225f68eadef3a865ab2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 482 | Lines Deleted: 490 | Files Changed: 2 | Hunks: 3 | Methods Changed: 19 | Complexity Δ (Sum/Max): -1/56 | Churn Δ: 972 | Churn Cumulative: 7579 | Contributors (this commit): 89 | Commits (past 90d): 32 | Contributors (cumulative): 90 | DMM Complexity: 0.0\n\nDIFF:\n@@ -0,0 +1,481 @@\n+\n+class OldRequest(object):\n+    \"\"\"The :class:`Request <Request>` object. It carries out all functionality\n+    of Requests. Recommended interface is with the Requests functions.\n+    \"\"\"\n+\n+    def __init__(self,\n+        url=None,\n+        headers=dict(),\n+        files=None,\n+        method=None,\n+        data=dict(),\n+        params=dict(),\n+        auth=None,\n+        cookies=None,\n+        timeout=None,\n+        redirect=False,\n+        allow_redirects=False,\n+        proxies=None,\n+        hooks=None,\n+        config=None,\n+        prefetch=True,\n+        _poolmanager=None,\n+        verify=None,\n+        session=None,\n+        cert=None):\n+\n+        #: Dictionary of configurations for this request.\n+        self.config = dict(config or [])\n+\n+        #: Float describes the timeout of the request.\n+        #  (Use socket.setdefaulttimeout() as fallback)\n+        self.timeout = timeout\n+\n+        # URL\n+\n+        #: Dictionary of HTTP Headers to attach to the :class:`Request <Request>`.\n+        self.headers = dict(headers or [])\n+\n+        #: Dictionary of files to multipart upload (``{filename: content}``).\n+        self.files = None\n+\n+        #: HTTP Method to use.\n+        self.method = method\n+\n+        #: Dictionary, bytes or file stream of request body data to attach to the\n+        #: :class:`Request <Request>`.\n+        self.data = None\n+\n+        #: Dictionary of querystring data to attach to the\n+        #: :class:`Request <Request>`. The dictionary values can be lists for representing\n+        #: multivalued query parameters.\n+        self.params = None\n+\n+        #: True if :class:`Request <Request>` is part of a redirect chain (disables history\n+        #: and HTTPError storage).\n+        self.redirect = redirect\n+\n+        #: Set to True if full redirects are allowed (e.g. re-POST-ing of data at new ``Location``)\n+        self.allow_redirects = allow_redirects\n+\n+        # Dictionary mapping protocol to the URL of the proxy (e.g. {'http': 'foo.bar:3128'})\n+        self.proxies = dict(proxies or [])\n+\n+        for proxy_type, uri_ref in list(self.proxies.items()):\n+            if not uri_ref:\n+                del self.proxies[proxy_type]\n+\n+        # If no proxies are given, allow configuration by environment variables\n+        # HTTP_PROXY and HTTPS_PROXY.\n+        if not self.proxies and self.config.get('trust_env'):\n+            self.proxies = get_environ_proxies(self.url)\n+\n+        self.data = data\n+        self.params = params\n+        self.files = files\n+\n+        #: :class:`Response <Response>` instance, containing\n+        #: content and metadata of HTTP Response, once :attr:`sent <send>`.\n+        self.response = Response()\n+\n+        #: Authentication tuple or object to attach to :class:`Request <Request>`.\n+        self.auth = auth\n+\n+        # #: CookieJar to attach to :class:`Request <Request>`.\n+        # if isinstance(cookies, cookielib.CookieJar):\n+        #     self.cookies = cookies\n+        # else:\n+        #     self.cookies = cookiejar_from_dict(cookies)\n+\n+        #: True if Request has been sent.\n+        self.sent = False\n+\n+        #: Event-handling hooks.\n+        self.hooks = {}\n+\n+        for event in HOOKS:\n+            self.hooks[event] = []\n+\n+        hooks = hooks or {}\n+\n+        for (k, v) in list(hooks.items()):\n+            self.register_hook(event=k, hook=v)\n+\n+        #: Session.\n+        self.session = session\n+\n+        #: SSL Verification.\n+        self.verify = verify\n+\n+        #: SSL Certificate\n+        self.cert = cert\n+\n+        #: Prefetch response content\n+        self.prefetch = prefetch\n+\n+        # if headers:\n+        #     headers = CaseInsensitiveDict(self.headers)\n+        # else:\n+        #     headers = CaseInsensitiveDict()\n+\n+        # Add configured base headers.\n+        for (k, v) in list(self.config.get('base_headers', {}).items()):\n+            if k not in headers:\n+                headers[k] = v\n+\n+        self.headers = headers\n+        self._poolmanager = _poolmanager\n+\n+    def __repr__(self):\n+        return '<Request [%s]>' % (self.method)\n+\n+    def _build_response(self, resp):\n+        \"\"\"Build internal :class:`Response <Response>` object\n+        from given response.\n+        \"\"\"\n+\n+        def build(resp):\n+\n+            response = Response()\n+\n+            # Pass settings over.\n+            response.config = self.config\n+\n+            if resp:\n+\n+                # Fallback to None if there's no status_code, for whatever reason.\n+                # response.status_code = getattr(resp, 'status', None)\n+\n+                # Make headers case-insensitive.\n+                # response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))\n+\n+                # Set encoding.\n+                # response.encoding = get_encoding_from_headers(response.headers)\n+\n+                # Add new cookies from the server.\n+                extract_cookies_to_jar(self.cookies, self, resp)\n+\n+                # Save cookies in Response.\n+                response.cookies = self.cookies\n+\n+                # Save cookies in Session.\n+                for cookie in self.cookies:\n+                    self.session.cookies.set_cookie(cookie)\n+\n+                # No exceptions were harmed in the making of this request.\n+                response.error = getattr(resp, 'error', None)\n+\n+            # Save original response for later.\n+            response.raw = resp\n+            if isinstance(self.full_url, bytes):\n+                response.url = self.full_url.decode('utf-8')\n+            else:\n+                response.url = self.full_url\n+\n+            return response\n+\n+        history = []\n+\n+        r = build(resp)\n+        # TODO: session level shit\n+        if r.status_code in REDIRECT_STATI and not self.redirect:\n+\n+            while (('location' in r.headers and r.status_code in REDIRECT_STATI) and\n+                   ((r.status_code is codes.see_other) or (self.allow_redirects))):\n+\n+                r.content  # Consume socket so it can be released\n+\n+                if not len(history) < self.config.get('max_redirects'):\n+                    raise TooManyRedirects()\n+\n+                # Release the connection back into the pool.\n+                r.raw.release_conn()\n+\n+                history.append(r)\n+\n+                url = r.headers['location']\n+                data = self.data\n+                files = self.files\n+\n+                # Handle redirection without scheme (see: RFC 1808 Section 4)\n+                if url.startswith('//'):\n+                    parsed_rurl = urlparse(r.url)\n+                    url = '%s:%s' % (parsed_rurl.scheme, url)\n+\n+                # Facilitate non-RFC2616-compliant 'location' headers\n+                # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n+                if not urlparse(url).netloc:\n+                    url = urljoin(r.url,\n+                                  # Compliant with RFC3986, we percent\n+                                  # encode the url.\n+                                  requote_uri(url))\n+\n+                # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n+                if r.status_code is codes.see_other:\n+                    method = 'GET'\n+                    data = None\n+                    files = None\n+                else:\n+                    method = self.method\n+\n+                # Do what the browsers do, despite standards...\n+                if r.status_code in (codes.moved, codes.found) and self.method == 'POST':\n+                    method = 'GET'\n+                    data = None\n+                    files = None\n+\n+                if (r.status_code == 303) and self.method != 'HEAD':\n+                    method = 'GET'\n+                    data = None\n+                    files = None\n+\n+                # Remove the cookie headers that were sent.\n+                headers = self.headers\n+                try:\n+                    del headers['Cookie']\n+                except KeyError:\n+                    pass\n+\n+                request = Request(\n+                    url=url,\n+                    headers=headers,\n+                    files=files,\n+                    method=method,\n+                    params=self.session.params,\n+                    auth=self.auth,\n+                    cookies=self.cookies,\n+                    redirect=True,\n+                    data=data,\n+                    config=self.config,\n+                    timeout=self.timeout,\n+                    _poolmanager=self._poolmanager,\n+                    proxies=self.proxies,\n+                    verify=self.verify,\n+                    session=self.session,\n+                    cert=self.cert,\n+                    prefetch=self.prefetch\n+                )\n+\n+                request.send()\n+                r = request.response\n+\n+            r.history = history\n+\n+        self.response = r\n+        self.response.request = self\n+\n+\n+    def register_hook(self, event, hook):\n+        \"\"\"Properly register a hook.\"\"\"\n+        if isinstance(hook, collections.Callable):\n+            self.hooks[event].append(hook)\n+        elif hasattr(hook, '__iter__'):\n+            self.hooks[event].extend(h for h in hook if isinstance(h, collections.Callable))\n+\n+    def deregister_hook(self, event, hook):\n+        \"\"\"Deregister a previously registered hook.\n+        Returns True if the hook existed, False if not.\n+        \"\"\"\n+\n+        try:\n+            self.hooks[event].remove(hook)\n+            return True\n+        except ValueError:\n+            return False\n+\n+    def send(self, anyway=False, prefetch=None):\n+        \"\"\"Sends the request. Returns True if successful, False if not.\n+        If there was an HTTPError during transmission,\n+        self.response.status_code will contain the HTTPError code.\n+\n+        Once a request is successfully sent, `sent` will equal True.\n+\n+        :param anyway: If True, request will be sent, even if it has\n+        already been sent.\n+\n+        :param prefetch: If not None, will override the request's own setting\n+        for prefetch.\n+        \"\"\"\n+\n+        # Build the URL\n+        url = self.full_url\n+\n+        # Pre-request hook.\n+        r = dispatch_hook('pre_request', self.hooks, self)\n+        self.__dict__.update(r.__dict__)\n+\n+        # Logging\n+        log.info('Sending %s: %s' % (self, url))\n+\n+        # Use .netrc auth if none was provided.\n+        if not self.auth and self.config.get('trust_env'):\n+            self.auth = get_netrc_auth(url)\n+\n+        # if self.auth:\n+        #     if isinstance(self.auth, tuple) and len(self.auth) == 2:\n+        #         # special-case basic HTTP auth\n+        #         self.auth = HTTPBasicAuth(*self.auth)\n+\n+        #     # Allow auth to make its changes.\n+        #     r = self.auth(self)\n+\n+        #     # Update self to reflect the auth changes.\n+        #     self.__dict__.update(r.__dict__)\n+\n+        # # Nottin' on you.\n+        # body = None\n+        # content_type = None\n+\n+        # # Multi-part file uploads.\n+        # if self.files:\n+        #     (body, content_type) = self._encode_files(self.files)\n+        # else:\n+        #     if self.data:\n+\n+        #         body = self._encode_params(self.data)\n+        #         if isinstance(self.data, str) or isinstance(self.data, builtin_str) or hasattr(self.data, 'read'):\n+        #             content_type = None\n+        #         else:\n+        #             content_type = 'application/x-www-form-urlencoded'\n+\n+        # self.headers['Content-Length'] = '0'\n+        # if hasattr(body, 'seek') and hasattr(body, 'tell'):\n+        #     body.seek(0, 2)\n+        #     self.headers['Content-Length'] = str(body.tell())\n+        #     body.seek(0, 0)\n+        # elif body is not None:\n+        #     self.headers['Content-Length'] = str(len(body))\n+\n+        # # Add content-type if it wasn't explicitly provided.\n+        # if (content_type) and (not 'content-type' in self.headers):\n+        #     self.headers['Content-Type'] = content_type\n+\n+        _p = urlparse(url)\n+        no_proxy = filter(lambda x: x.strip(), self.proxies.get('no', '').split(','))\n+        proxy = self.proxies.get(_p.scheme)\n+\n+        if proxy and not any(map(_p.hostname.endswith, no_proxy)):\n+            conn = poolmanager.ProxyManager(self.get_connection_for_url(proxy))\n+            _proxy = urlparse(proxy)\n+            if '@' in _proxy.netloc:\n+                auth, url = _proxy.netloc.split('@', 1)\n+                self.proxy_auth = HTTPProxyAuth(*auth.split(':', 1))\n+                r = self.proxy_auth(self)\n+                self.__dict__.update(r.__dict__)\n+        else:\n+            conn = self.get_connection_for_url(url)\n+\n+        if not self.config.get('keep_alive'):\n+            self.headers['Connection'] = 'close'\n+\n+        # if url.startswith('https') and self.verify:\n+\n+        #     cert_loc = None\n+\n+        #     # Allow self-specified cert location.\n+        #     if self.verify is not True:\n+        #         cert_loc = self.verify\n+\n+        #     # Look for configuration.\n+        #     if not cert_loc and self.config.get('trust_env'):\n+        #         cert_loc = os.environ.get('REQUESTS_CA_BUNDLE')\n+\n+        #     # Curl compatibility.\n+        #     if not cert_loc and self.config.get('trust_env'):\n+        #         cert_loc = os.environ.get('CURL_CA_BUNDLE')\n+\n+        #     if not cert_loc:\n+        #         cert_loc = DEFAULT_CA_BUNDLE_PATH\n+\n+        #     if not cert_loc:\n+        #         raise Exception(\"Could not find a suitable SSL CA certificate bundle.\")\n+\n+        #     conn.cert_reqs = 'CERT_REQUIRED'\n+        #     conn.ca_certs = cert_loc\n+        # else:\n+        #     conn.cert_reqs = 'CERT_NONE'\n+        #     conn.ca_certs = None\n+\n+        # if self.cert:\n+        #     if len(self.cert) == 2:\n+        #         conn.cert_file = self.cert[0]\n+        #         conn.key_file = self.cert[1]\n+        #     else:\n+        #         conn.cert_file = self.cert\n+\n+        if not self.sent or anyway:\n+\n+            # Skip if 'cookie' header is explicitly set.\n+            # if 'cookie' not in self.headers:\n+            #     cookie_header = get_cookie_header(self.cookies, self)\n+            #     if cookie_header is not None:\n+            #         self.headers['Cookie'] = cookie_header\n+\n+            # Pre-send hook.\n+            r = dispatch_hook('pre_send', self.hooks, self)\n+            self.__dict__.update(r.__dict__)\n+\n+            # catch urllib3 exceptions and throw Requests exceptions\n+            # try:\n+            #     # Send the request.\n+            #     r = conn.urlopen(\n+            #         method=self.method,\n+            #         url=self.path_url,\n+            #         body=body,\n+            #         headers=self.headers,\n+            #         redirect=False,\n+            #         assert_same_host=False,\n+            #         preload_content=False,\n+            #         decode_content=False,\n+            #         retries=self.config.get('max_retries', 0),\n+            #         timeout=self.timeout,\n+            #     )\n+            #     self.sent = True\n+\n+            # except socket.error as sockerr:\n+            #     raise ConnectionError(sockerr)\n+\n+            # except MaxRetryError as e:\n+            #     raise ConnectionError(e)\n+\n+            # except (_SSLError, _HTTPError) as e:\n+            #     if isinstance(e, _SSLError):\n+            #         raise SSLError(e)\n+            #     elif isinstance(e, TimeoutError):\n+            #         raise Timeout(e)\n+            #     else:\n+            #         raise Timeout('Request timed out.')\n+\n+            # build_response can throw TooManyRedirects\n+            self._build_response(r)\n+\n+            # Response manipulation hook.\n+            self.response = dispatch_hook('response', self.hooks, self.response)\n+\n+            # Post-request hook.\n+            r = dispatch_hook('post_request', self.hooks, self)\n+            self.__dict__.update(r.__dict__)\n+\n+            # If prefetch is True, mark content as consumed.\n+            if prefetch is None:\n+                prefetch = self.prefetch\n+            if prefetch:\n+                # Save the response.\n+                self.response.content\n+\n+            return self.sent\n+\n+    def get_connection_for_url(self, url):\n+        # Check to see if keep_alive is allowed.\n+        try:\n+            if self.config.get('keep_alive'):\n+                conn = self._poolmanager.connection_from_url(url)\n+            else:\n+                conn = connectionpool.connection_from_url(url)\n+            return conn\n+        except LocationParseError as e:\n+            raise InvalidURL(e)\n+\n+    def prepare(self):\n+        return deepcopy(self)\n\\ No newline at end of file\n\n@@ -17,7 +17,7 @@ from datetime import datetime\n from io import BytesIO\n \n from .hooks import dispatch_hook, HOOKS\n-from .structures import CaseInsensitiveDict\n+zz\n from .status_codes import codes\n \n from .auth import HTTPBasicAuth, HTTPProxyAuth\n@@ -359,495 +359,6 @@ class PreparedRequest(RequestMixin):\n             if cookie_header is not None:\n                 self.headers['Cookie'] = cookie_header\n \n-    def send(self):\n-        pass\n-        # return\n-\n-    # def prepare_allow_\n-\n-\n-\n-class OldRequest(object):\n-    \"\"\"The :class:`Request <Request>` object. It carries out all functionality\n-    of Requests. Recommended interface is with the Requests functions.\n-    \"\"\"\n-\n-    def __init__(self,\n-        url=None,\n-        headers=dict(),\n-        files=None,\n-        method=None,\n-        data=dict(),\n-        params=dict(),\n-        auth=None,\n-        cookies=None,\n-        timeout=None,\n-        redirect=False,\n-        allow_redirects=False,\n-        proxies=None,\n-        hooks=None,\n-        config=None,\n-        prefetch=True,\n-        _poolmanager=None,\n-        verify=None,\n-        session=None,\n-        cert=None):\n-\n-        #: Dictionary of configurations for this request.\n-        self.config = dict(config or [])\n-\n-        #: Float describes the timeout of the request.\n-        #  (Use socket.setdefaulttimeout() as fallback)\n-        self.timeout = timeout\n-\n-        # URL\n-\n-        #: Dictionary of HTTP Headers to attach to the :class:`Request <Request>`.\n-        self.headers = dict(headers or [])\n-\n-        #: Dictionary of files to multipart upload (``{filename: content}``).\n-        self.files = None\n-\n-        #: HTTP Method to use.\n-        self.method = method\n-\n-        #: Dictionary, bytes or file stream of request body data to attach to the\n-        #: :class:`Request <Request>`.\n-        self.data = None\n-\n-        #: Dictionary of querystring data to attach to the\n-        #: :class:`Request <Request>`. The dictionary values can be lists for representing\n-        #: multivalued query parameters.\n-        self.params = None\n-\n-        #: True if :class:`Request <Request>` is part of a redirect chain (disables history\n-        #: and HTTPError storage).\n-        self.redirect = redirect\n-\n-        #: Set to True if full redirects are allowed (e.g. re-POST-ing of data at new ``Location``)\n-        self.allow_redirects = allow_redirects\n-\n-        # Dictionary mapping protocol to the URL of the proxy (e.g. {'http': 'foo.bar:3128'})\n-        self.proxies = dict(proxies or [])\n-\n-        for proxy_type, uri_ref in list(self.proxies.items()):\n-            if not uri_ref:\n-                del self.proxies[proxy_type]\n-\n-        # If no proxies are given, allow configuration by environment variables\n-        # HTTP_PROXY and HTTPS_PROXY.\n-        if not self.proxies and self.config.get('trust_env'):\n-            self.proxies = get_environ_proxies(self.url)\n-\n-        self.data = data\n-        self.params = params\n-        self.files = files\n-\n-        #: :class:`Response <Response>` instance, containing\n-        #: content and metadata of HTTP Response, once :attr:`sent <send>`.\n-        self.response = Response()\n-\n-        #: Authentication tuple or object to attach to :class:`Request <Request>`.\n-        self.auth = auth\n-\n-        # #: CookieJar to attach to :class:`Request <Request>`.\n-        # if isinstance(cookies, cookielib.CookieJar):\n-        #     self.cookies = cookies\n-        # else:\n-        #     self.cookies = cookiejar_from_dict(cookies)\n-\n-        #: True if Request has been sent.\n-        self.sent = False\n-\n-        #: Event-handling hooks.\n-        self.hooks = {}\n-\n-        for event in HOOKS:\n-            self.hooks[event] = []\n-\n-        hooks = hooks or {}\n-\n-        for (k, v) in list(hooks.items()):\n-            self.register_hook(event=k, hook=v)\n-\n-        #: Session.\n-        self.session = session\n-\n-        #: SSL Verification.\n-        self.verify = verify\n-\n-        #: SSL Certificate\n-        self.cert = cert\n-\n-        #: Prefetch response content\n-        self.prefetch = prefetch\n-\n-        # if headers:\n-        #     headers = CaseInsensitiveDict(self.headers)\n-        # else:\n-        #     headers = CaseInsensitiveDict()\n-\n-        # Add configured base headers.\n-        for (k, v) in list(self.config.get('base_headers', {}).items()):\n-            if k not in headers:\n-                headers[k] = v\n-\n-        self.headers = headers\n-        self._poolmanager = _poolmanager\n-\n-    def __repr__(self):\n-        return '<Request [%s]>' % (self.method)\n-\n-    def _build_response(self, resp):\n-        \"\"\"Build internal :class:`Response <Response>` object\n-        from given response.\n-        \"\"\"\n-\n-        def build(resp):\n-\n-            response = Response()\n-\n-            # Pass settings over.\n-            response.config = self.config\n-\n-            if resp:\n-\n-                # Fallback to None if there's no status_code, for whatever reason.\n-                # response.status_code = getattr(resp, 'status', None)\n-\n-                # Make headers case-insensitive.\n-                # response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))\n-\n-                # Set encoding.\n-                # response.encoding = get_encoding_from_headers(response.headers)\n-\n-                # Add new cookies from the server.\n-                extract_cookies_to_jar(self.cookies, self, resp)\n-\n-                # Save cookies in Response.\n-                response.cookies = self.cookies\n-\n-                # Save cookies in Session.\n-                for cookie in self.cookies:\n-                    self.session.cookies.set_cookie(cookie)\n-\n-                # No exceptions were harmed in the making of this request.\n-                response.error = getattr(resp, 'error', None)\n-\n-            # Save original response for later.\n-            response.raw = resp\n-            if isinstance(self.full_url, bytes):\n-                response.url = self.full_url.decode('utf-8')\n-            else:\n-                response.url = self.full_url\n-\n-            return response\n-\n-        history = []\n-\n-        r = build(resp)\n-        # TODO: session level shit\n-        if r.status_code in REDIRECT_STATI and not self.redirect:\n-\n-            while (('location' in r.headers and r.status_code in REDIRECT_STATI) and\n-                   ((r.status_code is codes.see_other) or (self.allow_redirects))):\n-\n-                r.content  # Consume socket so it can be released\n-\n-                if not len(history) < self.config.get('max_redirects'):\n-                    raise TooManyRedirects()\n-\n-                # Release the connection back into the pool.\n-                r.raw.release_conn()\n-\n-                history.append(r)\n-\n-                url = r.headers['location']\n-                data = self.data\n-                files = self.files\n-\n-                # Handle redirection without scheme (see: RFC 1808 Section 4)\n-                if url.startswith('//'):\n-                    parsed_rurl = urlparse(r.url)\n-                    url = '%s:%s' % (parsed_rurl.scheme, url)\n-\n-                # Facilitate non-RFC2616-compliant 'location' headers\n-                # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n-                if not urlparse(url).netloc:\n-                    url = urljoin(r.url,\n-                                  # Compliant with RFC3986, we percent\n-                                  # encode the url.\n-                                  requote_uri(url))\n-\n-                # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n-                if r.status_code is codes.see_other:\n-                    method = 'GET'\n-                    data = None\n-                    files = None\n-                else:\n-                    method = self.method\n-\n-                # Do what the browsers do, despite standards...\n-                if r.status_code in (codes.moved, codes.found) and self.method == 'POST':\n-                    method = 'GET'\n-                    data = None\n-                    files = None\n-\n-                if (r.status_code == 303) and self.method != 'HEAD':\n-                    method = 'GET'\n-                    data = None\n-                    files = None\n-\n-                # Remove the cookie headers that were sent.\n-                headers = self.headers\n-                try:\n-                    del headers['Cookie']\n-                except KeyError:\n-                    pass\n-\n-                request = Request(\n-                    url=url,\n-                    headers=headers,\n-                    files=files,\n-                    method=method,\n-                    params=self.session.params,\n-                    auth=self.auth,\n-                    cookies=self.cookies,\n-                    redirect=True,\n-                    data=data,\n-                    config=self.config,\n-                    timeout=self.timeout,\n-                    _poolmanager=self._poolmanager,\n-                    proxies=self.proxies,\n-                    verify=self.verify,\n-                    session=self.session,\n-                    cert=self.cert,\n-                    prefetch=self.prefetch\n-                )\n-\n-                request.send()\n-                r = request.response\n-\n-            r.history = history\n-\n-        self.response = r\n-        self.response.request = self\n-\n-\n-    def register_hook(self, event, hook):\n-        \"\"\"Properly register a hook.\"\"\"\n-        if isinstance(hook, collections.Callable):\n-            self.hooks[event].append(hook)\n-        elif hasattr(hook, '__iter__'):\n-            self.hooks[event].extend(h for h in hook if isinstance(h, collections.Callable))\n-\n-    def deregister_hook(self, event, hook):\n-        \"\"\"Deregister a previously registered hook.\n-        Returns True if the hook existed, False if not.\n-        \"\"\"\n-\n-        try:\n-            self.hooks[event].remove(hook)\n-            return True\n-        except ValueError:\n-            return False\n-\n-    def send(self, anyway=False, prefetch=None):\n-        \"\"\"Sends the request. Returns True if successful, False if not.\n-        If there was an HTTPError during transmission,\n-        self.response.status_code will contain the HTTPError code.\n-\n-        Once a request is successfully sent, `sent` will equal True.\n-\n-        :param anyway: If True, request will be sent, even if it has\n-        already been sent.\n-\n-        :param prefetch: If not None, will override the request's own setting\n-        for prefetch.\n-        \"\"\"\n-\n-        # Build the URL\n-        url = self.full_url\n-\n-        # Pre-request hook.\n-        r = dispatch_hook('pre_request', self.hooks, self)\n-        self.__dict__.update(r.__dict__)\n-\n-        # Logging\n-        log.info('Sending %s: %s' % (self, url))\n-\n-        # Use .netrc auth if none was provided.\n-        if not self.auth and self.config.get('trust_env'):\n-            self.auth = get_netrc_auth(url)\n-\n-        # if self.auth:\n-        #     if isinstance(self.auth, tuple) and len(self.auth) == 2:\n-        #         # special-case basic HTTP auth\n-        #         self.auth = HTTPBasicAuth(*self.auth)\n-\n-        #     # Allow auth to make its changes.\n-        #     r = self.auth(self)\n-\n-        #     # Update self to reflect the auth changes.\n-        #     self.__dict__.update(r.__dict__)\n-\n-        # # Nottin' on you.\n-        # body = None\n-        # content_type = None\n-\n-        # # Multi-part file uploads.\n-        # if self.files:\n-        #     (body, content_type) = self._encode_files(self.files)\n-        # else:\n-        #     if self.data:\n-\n-        #         body = self._encode_params(self.data)\n-        #         if isinstance(self.data, str) or isinstance(self.data, builtin_str) or hasattr(self.data, 'read'):\n-        #             content_type = None\n-        #         else:\n-        #             content_type = 'application/x-www-form-urlencoded'\n-\n-        # self.headers['Content-Length'] = '0'\n-        # if hasattr(body, 'seek') and hasattr(body, 'tell'):\n-        #     body.seek(0, 2)\n-        #     self.headers['Content-Length'] = str(body.tell())\n-        #     body.seek(0, 0)\n-        # elif body is not None:\n-        #     self.headers['Content-Length'] = str(len(body))\n-\n-        # # Add content-type if it wasn't explicitly provided.\n-        # if (content_type) and (not 'content-type' in self.headers):\n-        #     self.headers['Content-Type'] = content_type\n-\n-        _p = urlparse(url)\n-        no_proxy = filter(lambda x: x.strip(), self.proxies.get('no', '').split(','))\n-        proxy = self.proxies.get(_p.scheme)\n-\n-        if proxy and not any(map(_p.hostname.endswith, no_proxy)):\n-            conn = poolmanager.ProxyManager(self.get_connection_for_url(proxy))\n-            _proxy = urlparse(proxy)\n-            if '@' in _proxy.netloc:\n-                auth, url = _proxy.netloc.split('@', 1)\n-                self.proxy_auth = HTTPProxyAuth(*auth.split(':', 1))\n-                r = self.proxy_auth(self)\n-                self.__dict__.update(r.__dict__)\n-        else:\n-            conn = self.get_connection_for_url(url)\n-\n-        if not self.config.get('keep_alive'):\n-            self.headers['Connection'] = 'close'\n-\n-        # if url.startswith('https') and self.verify:\n-\n-        #     cert_loc = None\n-\n-        #     # Allow self-specified cert location.\n-        #     if self.verify is not True:\n-        #         cert_loc = self.verify\n-\n-        #     # Look for configuration.\n-        #     if not cert_loc and self.config.get('trust_env'):\n-        #         cert_loc = os.environ.get('REQUESTS_CA_BUNDLE')\n-\n-        #     # Curl compatibility.\n-        #     if not cert_loc and self.config.get('trust_env'):\n-        #         cert_loc = os.environ.get('CURL_CA_BUNDLE')\n-\n-        #     if not cert_loc:\n-        #         cert_loc = DEFAULT_CA_BUNDLE_PATH\n-\n-        #     if not cert_loc:\n-        #         raise Exception(\"Could not find a suitable SSL CA certificate bundle.\")\n-\n-        #     conn.cert_reqs = 'CERT_REQUIRED'\n-        #     conn.ca_certs = cert_loc\n-        # else:\n-        #     conn.cert_reqs = 'CERT_NONE'\n-        #     conn.ca_certs = None\n-\n-        # if self.cert:\n-        #     if len(self.cert) == 2:\n-        #         conn.cert_file = self.cert[0]\n-        #         conn.key_file = self.cert[1]\n-        #     else:\n-        #         conn.cert_file = self.cert\n-\n-        if not self.sent or anyway:\n-\n-            # Skip if 'cookie' header is explicitly set.\n-            # if 'cookie' not in self.headers:\n-            #     cookie_header = get_cookie_header(self.cookies, self)\n-            #     if cookie_header is not None:\n-            #         self.headers['Cookie'] = cookie_header\n-\n-            # Pre-send hook.\n-            r = dispatch_hook('pre_send', self.hooks, self)\n-            self.__dict__.update(r.__dict__)\n-\n-            # catch urllib3 exceptions and throw Requests exceptions\n-            # try:\n-            #     # Send the request.\n-            #     r = conn.urlopen(\n-            #         method=self.method,\n-            #         url=self.path_url,\n-            #         body=body,\n-            #         headers=self.headers,\n-            #         redirect=False,\n-            #         assert_same_host=False,\n-            #         preload_content=False,\n-            #         decode_content=False,\n-            #         retries=self.config.get('max_retries', 0),\n-            #         timeout=self.timeout,\n-            #     )\n-            #     self.sent = True\n-\n-            # except socket.error as sockerr:\n-            #     raise ConnectionError(sockerr)\n-\n-            # except MaxRetryError as e:\n-            #     raise ConnectionError(e)\n-\n-            # except (_SSLError, _HTTPError) as e:\n-            #     if isinstance(e, _SSLError):\n-            #         raise SSLError(e)\n-            #     elif isinstance(e, TimeoutError):\n-            #         raise Timeout(e)\n-            #     else:\n-            #         raise Timeout('Request timed out.')\n-\n-            # build_response can throw TooManyRedirects\n-            self._build_response(r)\n-\n-            # Response manipulation hook.\n-            self.response = dispatch_hook('response', self.hooks, self.response)\n-\n-            # Post-request hook.\n-            r = dispatch_hook('post_request', self.hooks, self)\n-            self.__dict__.update(r.__dict__)\n-\n-            # If prefetch is True, mark content as consumed.\n-            if prefetch is None:\n-                prefetch = self.prefetch\n-            if prefetch:\n-                # Save the response.\n-                self.response.content\n-\n-            return self.sent\n-\n-    def get_connection_for_url(self, url):\n-        # Check to see if keep_alive is allowed.\n-        try:\n-            if self.config.get('keep_alive'):\n-                conn = self._poolmanager.connection_from_url(url)\n-            else:\n-                conn = connectionpool.connection_from_url(url)\n-            return conn\n-        except LocationParseError as e:\n-            raise InvalidURL(e)\n-\n-    def prepare(self):\n-        return deepcopy(self)\n-\n \n class BaseResponse(object):\n     \"\"\"The basic Respone\"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
