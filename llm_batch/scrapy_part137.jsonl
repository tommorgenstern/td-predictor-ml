{"custom_id": "scrapy#9fddc73ed818a6695d18c4160eaf7100c5bfc4e8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 31 | Files Changed: 3 | Hunks: 7 | Methods Changed: 3 | Complexity Δ (Sum/Max): -6/0 | Churn Δ: 32 | Churn Cumulative: 817 | Contributors (this commit): 3 | Commits (past 90d): 4 | Contributors (cumulative): 5 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,5 +1,4 @@\n import sys\n-import os\n import optparse\n import cProfile\n import inspect\n@@ -9,7 +8,7 @@ from scrapy.crawler import CrawlerProcess\n from scrapy.xlib import lsprofcalltree\n from scrapy.conf import settings\n from scrapy.command import ScrapyCommand\n-from scrapy.exceptions import UsageError, ScrapyDeprecationWarning\n+from scrapy.exceptions import UsageError\n from scrapy.utils.misc import walk_modules\n from scrapy.utils.project import inside_project\n \n@@ -72,24 +71,6 @@ def _print_unknown_command(cmdname, inproject):\n         print\n         print \"More commands are available in project mode\"\n \n-def _check_deprecated_scrapy_ctl(argv, inproject):\n-    \"\"\"Check if Scrapy was called using the deprecated scrapy-ctl command and\n-    warn in that case, also creating a scrapy.cfg if it doesn't exist.\n-    \"\"\"\n-    if not any('scrapy-ctl' in x for x in argv):\n-        return\n-    import warnings\n-    warnings.warn(\"`scrapy-ctl.py` command-line tool is deprecated and will be removed in Scrapy 0.11, use `scrapy` instead\",\n-        ScrapyDeprecationWarning, stacklevel=3)\n-    if inproject:\n-        projpath = os.path.abspath(os.path.dirname(os.path.dirname(settings.settings_module.__file__)))\n-        cfg_path = os.path.join(projpath, 'scrapy.cfg')\n-        if not os.path.exists(cfg_path):\n-            with open(cfg_path, 'w') as f:\n-                f.write(\"# generated automatically - feel free to edit\" + os.linesep)\n-                f.write(\"[settings]\" + os.linesep)\n-                f.write(\"default = %s\" % settings.settings_module.__name__ + os.linesep)\n-\n def _run_print_help(parser, func, *a, **kw):\n     try:\n         func(*a, **kw)\n@@ -106,7 +87,6 @@ def execute(argv=None):\n     crawler = CrawlerProcess(settings)\n     crawler.install()\n     inproject = inside_project()\n-    _check_deprecated_scrapy_ctl(argv, inproject) # TODO: remove for Scrapy 0.11\n     cmds = _get_commands_dict(inproject)\n     cmdname = _pop_command_name(argv)\n     parser = optparse.OptionParser(formatter=optparse.TitledHelpFormatter(), \\\n\n@@ -1,6 +0,0 @@\n-from scrapy.contrib.exporter import JsonLinesItemExporter\n-from scrapy.exceptions import ScrapyDeprecationWarning\n-\n-import warnings\n-warnings.warn(\"Module `scrapy.contrib.exporter.jsonlines` is deprecated - use `scrapy.contrib.exporter` instead\",\n-    ScrapyDeprecationWarning, stacklevel=2)\n\n@@ -13,7 +13,6 @@ import scrapy\n from scrapy.conf import settings\n from scrapy.utils.python import unicode_to_str\n from scrapy.utils.misc import load_object\n-from scrapy.exceptions import ScrapyDeprecationWarning\n  \n # Logging levels\n DEBUG = logging.DEBUG\n@@ -113,9 +112,6 @@ def start(logfile=None, loglevel=None, logstdout=None):\n             settings['BOT_NAME']))\n \n def msg(message, level=INFO, **kw):\n-    if 'component' in kw:\n-        warnings.warn(\"Argument `component` of scrapy.log.msg() is deprecated\", \\\n-            ScrapyDeprecationWarning, stacklevel=2)\n     kw.setdefault('system', 'scrapy')\n     kw['logLevel'] = level\n     log.msg(message, **kw)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#b6ae2665461bcff6c47eadc899b8484eda399aea", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 51 | Files Changed: 3 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): -4/0 | Churn Δ: 53 | Churn Cumulative: 392 | Contributors (this commit): 4 | Commits (past 90d): 8 | Contributors (cumulative): 7 | DMM Complexity: 0.0\n\nDIFF:\n@@ -15,7 +15,7 @@ if sys.version_info < (2,6):\n warnings.filterwarnings('ignore', category=DeprecationWarning, module='twisted')\n \n # monkey patches to fix external library issues\n-from scrapy.xlib import twisted_250_monkeypatches, urlparse_monkeypatches\n+from scrapy.xlib import urlparse_monkeypatches\n \n # optional_features is a set containing Scrapy optional features\n optional_features = set()\n\n@@ -1,49 +0,0 @@\n-\"\"\"\n-Monkey patches for supporting Twisted 2.5.0\n-\n-NOTE: This module must not fail if twisted module is not available.\n-\"\"\"\n-\n-# This function comes bundled with Twisted 8.x and above\n-def add_missing_blockingCallFromThread():\n-    import Queue\n-    from twisted.internet import defer\n-    from twisted.python import failure\n-\n-    def blockingCallFromThread(reactor, f, *a, **kw):\n-        \"\"\"\n-        Run a function in the reactor from a thread, and wait for the result\n-        synchronously, i.e. until the callback chain returned by the function\n-        get a result.\n-\n-        @param reactor: The L{IReactorThreads} provider which will be used to\n-            schedule the function call.\n-        @param f: the callable to run in the reactor thread\n-        @type f: any callable.\n-        @param a: the arguments to pass to C{f}.\n-        @param kw: the keyword arguments to pass to C{f}.\n-\n-        @return: the result of the callback chain.\n-        @raise: any error raised during the callback chain.\n-        \"\"\"\n-        queue = Queue.Queue()\n-        def _callFromThread():\n-            result = defer.maybeDeferred(f, *a, **kw)\n-            result.addBoth(queue.put)\n-        reactor.callFromThread(_callFromThread)\n-        result = queue.get()\n-        if isinstance(result, failure.Failure):\n-            result.raiseException()\n-        return result\n-\n-    from twisted.internet import threads\n-    threads.blockingCallFromThread = blockingCallFromThread\n-\n-try:\n-    import twisted\n-    from twisted.python.versions import Version\n-    if twisted.version < Version(\"twisted\", 8, 0, 0):\n-        add_missing_blockingCallFromThread()\n-except ImportError:\n-    pass\n-\n\n@@ -120,7 +120,7 @@ try:\n except ImportError:\n     from distutils.core import setup\n else:\n-    setup_args['install_requires'] = ['Twisted>=2.5', 'w3lib>=1.1', 'pyOpenSSL']\n+    setup_args['install_requires'] = ['Twisted>=8.0', 'w3lib>=1.1', 'pyOpenSSL']\n     if sys.version_info < (2, 6):\n         setup_args['install_requires'] += ['simplejson']\n     try:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#838e1dcce9947f946418de4db4be4ca390be78bd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 14 | Lines Deleted: 15 | Files Changed: 1 | Hunks: 15 | Methods Changed: 13 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 29 | Churn Cumulative: 409 | Contributors (this commit): 5 | Commits (past 90d): 2 | Contributors (cumulative): 5 | DMM Complexity: None\n\nDIFF:\n@@ -1,11 +1,10 @@\n import cgi\n import unittest\n import xmlrpclib\n-from inspect import getargspec\n from cStringIO import StringIO\n from urlparse import urlparse\n \n-from scrapy.http import Request, FormRequest, XmlRpcRequest, Headers, Response\n+from scrapy.http import Request, FormRequest, XmlRpcRequest, Headers, HtmlResponse\n \n \n class RequestTest(unittest.TestCase):\n@@ -214,7 +213,7 @@ class FormRequestTest(RequestTest):\n <input type=\"hidden\" name=\"test2\" value=\"xxx\">\n </form>\n         \"\"\"\n-        response = Response(\"http://www.example.com/this/list.html\", body=respbody)\n+        response = HtmlResponse(\"http://www.example.com/this/list.html\", body=respbody)\n         r1 = self.request_class.from_response(response, formdata={'one': ['two', 'three'], 'six': 'seven'}, callback=lambda x: x)\n         self.assertEqual(r1.method, 'POST')\n         self.assertEqual(r1.headers['Content-type'], 'application/x-www-form-urlencoded')\n@@ -234,7 +233,7 @@ class FormRequestTest(RequestTest):\n </form>\n         \"\"\"\n         headers = {\"Accept-Encoding\": \"gzip,deflate\"}\n-        response = Response(\"http://www.example.com/this/list.html\", body=respbody)\n+        response = HtmlResponse(\"http://www.example.com/this/list.html\", body=respbody)\n         r1 = self.request_class.from_response(response, formdata={'one': ['two', 'three'], 'six': 'seven'}, headers=headers, callback=lambda x: x)\n         self.assertEqual(r1.method, 'POST')\n         self.assertEqual(r1.headers['Content-type'], 'application/x-www-form-urlencoded')\n@@ -248,7 +247,7 @@ class FormRequestTest(RequestTest):\n <input type=\"hidden\" name=\"test2\" value=\"xxx\">\n </form>\n         \"\"\"\n-        response = Response(\"http://www.example.com/this/list.html\", body=respbody)\n+        response = HtmlResponse(\"http://www.example.com/this/list.html\", body=respbody)\n         r1 = self.request_class.from_response(response, formdata={'one': ['two', 'three'], 'six': 'seven'})\n         self.assertEqual(r1.method, 'GET')\n         self.assertEqual(urlparse(r1.url).hostname, \"www.example.com\")\n@@ -266,7 +265,7 @@ class FormRequestTest(RequestTest):\n <input type=\"hidden\" name=\"two\" value=\"3\">\n </form>\n         \"\"\"\n-        response = Response(\"http://www.example.com/this/list.html\", body=respbody)\n+        response = HtmlResponse(\"http://www.example.com/this/list.html\", body=respbody)\n         r1 = self.request_class.from_response(response, formdata={'two': '2'})\n         fs = cgi.FieldStorage(StringIO(r1.body), r1.headers, environ={\"REQUEST_METHOD\": \"POST\"})\n         self.assertEqual(fs['one'].value, '1')\n@@ -281,7 +280,7 @@ class FormRequestTest(RequestTest):\n <input type=\"submit\" name=\"clickeable2\" value=\"clicked2\">\n </form>\n         \"\"\"\n-        response = Response(\"http://www.example.com/this/list.html\", body=respbody)\n+        response = HtmlResponse(\"http://www.example.com/this/list.html\", body=respbody)\n         r1 = self.request_class.from_response(response, formdata={'two': '2'})\n         urlargs = cgi.parse_qs(urlparse(r1.url).query)\n         self.assertEqual(urlargs['clickeable1'], ['clicked1'])\n@@ -298,7 +297,7 @@ class FormRequestTest(RequestTest):\n <input type=\"submit\" name=\"clickeable2\" value=\"clicked2\">\n </form>\n         \"\"\"\n-        response = Response(\"http://www.example.com/this/list.html\", body=respbody)\n+        response = HtmlResponse(\"http://www.example.com/this/list.html\", body=respbody)\n         r1 = self.request_class.from_response(response, formdata={'two': '2'}, clickdata={'name': 'clickeable2'})\n         urlargs = cgi.parse_qs(urlparse(r1.url).query)\n         self.assertEqual(urlargs['clickeable2'], ['clicked2'])\n@@ -315,7 +314,7 @@ class FormRequestTest(RequestTest):\n <input type=\"submit\" name=\"clickeable2\" value=\"clicked2\">\n </form>\n         \"\"\"\n-        response = Response(\"http://www.example.com/this/list.html\", body=respbody)\n+        response = HtmlResponse(\"http://www.example.com/this/list.html\", body=respbody)\n         r1 = self.request_class.from_response(response, dont_click=True)\n         urlargs = cgi.parse_qs(urlparse(r1.url).query)\n         self.assertFalse('clickeable1' in urlargs, urlargs)\n@@ -323,7 +322,7 @@ class FormRequestTest(RequestTest):\n \n     def test_from_response_errors_noform(self):\n         respbody = \"\"\"<html></html>\"\"\"\n-        response = Response(\"http://www.example.com/lala.html\", body=respbody)\n+        response = HtmlResponse(\"http://www.example.com/lala.html\", body=respbody)\n         self.assertRaises(ValueError, self.request_class.from_response, response)\n \n     def test_from_response_errors_formnumber(self):\n@@ -334,7 +333,7 @@ class FormRequestTest(RequestTest):\n <input type=\"hidden\" name=\"test2\" value=\"xxx\">\n </form>\n         \"\"\"\n-        response = Response(\"http://www.example.com/lala.html\", body=respbody)\n+        response = HtmlResponse(\"http://www.example.com/lala.html\", body=respbody)\n         self.assertRaises(IndexError, self.request_class.from_response, response, formnumber=1)\n \n     def test_from_response_noformname(self):\n@@ -344,7 +343,7 @@ class FormRequestTest(RequestTest):\n <input type=\"hidden\" name=\"two\" value=\"2\">\n </form>\n         \"\"\"\n-        response = Response(\"http://www.example.com/formname.html\", body=respbody)\n+        response = HtmlResponse(\"http://www.example.com/formname.html\", body=respbody)\n         r1 = self.request_class.from_response(response, formdata={'two':'3'}, callback=lambda x: x)\n         self.assertEqual(r1.method, 'POST')\n         self.assertEqual(r1.headers['Content-type'], 'application/x-www-form-urlencoded')\n@@ -364,7 +363,7 @@ class FormRequestTest(RequestTest):\n <input type=\"hidden\" name=\"four\" value=\"4\">\n </form>\n         \"\"\"\n-        response = Response(\"http://www.example.com/formname.html\", body=respbody)\n+        response = HtmlResponse(\"http://www.example.com/formname.html\", body=respbody)\n         r1 = self.request_class.from_response(response, formname=\"form2\", callback=lambda x: x)\n         self.assertEqual(r1.method, 'POST')\n         fs = cgi.FieldStorage(StringIO(r1.body), r1.headers, environ={\"REQUEST_METHOD\": \"POST\"})\n@@ -380,7 +379,7 @@ class FormRequestTest(RequestTest):\n <input type=\"hidden\" name=\"two\" value=\"2\">\n </form>\n         \"\"\"\n-        response = Response(\"http://www.example.com/formname.html\", body=respbody)\n+        response = HtmlResponse(\"http://www.example.com/formname.html\", body=respbody)\n         r1 = self.request_class.from_response(response, formname=\"form3\", callback=lambda x: x)\n         self.assertEqual(r1.method, 'POST')\n         fs = cgi.FieldStorage(StringIO(r1.body), r1.headers, environ={\"REQUEST_METHOD\": \"POST\"})\n@@ -395,7 +394,7 @@ class FormRequestTest(RequestTest):\n <input type=\"hidden\" name=\"two\" value=\"2\">\n </form>\n         \"\"\"\n-        response = Response(\"http://www.example.com/formname.html\", body=respbody)\n+        response = HtmlResponse(\"http://www.example.com/formname.html\", body=respbody)\n         self.assertRaises(IndexError, self.request_class.from_response, response, formname=\"form3\", formnumber=2)\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#35fb01156e4fce94236de5beef131198b3290bd8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 5 | Files Changed: 3 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 267 | Contributors (this commit): 5 | Commits (past 90d): 9 | Contributors (cumulative): 7 | DMM Complexity: 0.0\n\nDIFF:\n@@ -214,8 +214,6 @@ SPIDER_MIDDLEWARES_BASE = {\n \n SPIDER_MODULES = []\n \n-SQLITE_DB = 'scrapy.db'\n-\n STATS_CLASS = 'scrapy.statscol.MemoryStatsCollector'\n STATS_ENABLED = True\n STATS_DUMP = True\n\n@@ -28,8 +28,6 @@ class Environment(object):\n         env['SCRAPY_JOB'] = message['_job']\n         if project in self.settings:\n             env['SCRAPY_SETTINGS_MODULE'] = self.settings[project]\n-        dbpath = os.path.join(self.dbs_dir, '%s.db' % project)\n-        env['SCRAPY_SQLITE_DB'] = dbpath\n         env['SCRAPY_LOG_FILE'] = self._get_file(message, self.logs_dir, 'log')\n         env['SCRAPY_FEED_URI'] = self._get_file(message, self.items_dir, 'jl')\n         return env\n\n@@ -29,7 +29,6 @@ class EnvironmentTest(unittest.TestCase):\n         self.assertEqual(env['SCRAPY_SLOT'], '3')\n         self.assertEqual(env['SCRAPY_SPIDER'], 'myspider')\n         self.assertEqual(env['SCRAPY_JOB'], 'ID')\n-        self.assert_(env['SCRAPY_SQLITE_DB'].endswith('mybot.db'))\n         self.assert_(env['SCRAPY_LOG_FILE'].endswith(os.path.join('mybot', 'myspider', 'ID.log')))\n         self.assert_(env['SCRAPY_FEED_URI'].endswith(os.path.join('mybot', 'myspider', 'ID.jl')))\n         self.failIf('SCRAPY_SETTINGS_MODULE' in env)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#8933e2f2beabb2c5c09e4edf2be5512e8f7bbe72", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 7/7 | Churn Δ: 10 | Churn Cumulative: 139 | Contributors (this commit): 4 | Commits (past 90d): 7 | Contributors (cumulative): 6 | DMM Complexity: 1.0\n\nDIFF:\n@@ -4,8 +4,16 @@ originated it.\n \"\"\"\n \n from scrapy.http import Request\n+from scrapy.exceptions import NotConfigured\n \n class RefererMiddleware(object):\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        if not crawler.settings.getbool('REFERER_ENABLED'):\n+            raise NotConfigured\n+        return cls()\n+\n     def process_spider_output(self, response, result, spider):\n         def _set_referer(r):\n             if isinstance(r, Request):\n\n@@ -185,6 +185,8 @@ REDIRECT_MAX_METAREFRESH_DELAY = 100\n REDIRECT_MAX_TIMES = 20 # uses Firefox default setting\n REDIRECT_PRIORITY_ADJUST = +2\n \n+REFERER_ENABLED = True\n+\n RETRY_ENABLED = True\n RETRY_TIMES = 2 # initial response + 2 retries = 3 requests\n RETRY_HTTP_CODES = [500, 503, 504, 400, 408]\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#27018fced7ada188bfeb3057f193de678524ed90", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 134 | Contributors (this commit): 4 | Commits (past 90d): 7 | Contributors (cumulative): 4 | DMM Complexity: None\n\nDIFF:\n@@ -17,7 +17,6 @@ import sys, os\n from os.path import join, abspath, dirname\n \n BOT_NAME = 'scrapybot'\n-BOT_VERSION = '1.0'\n \n CLOSESPIDER_TIMEOUT = 0\n CLOSESPIDER_PAGECOUNT = 0\n@@ -226,7 +225,7 @@ TEMPLATES_DIR = abspath(join(dirname(__file__), '..', 'templates'))\n \n URLLENGTH_LIMIT = 2083\n \n-USER_AGENT = '%s/%s' % (BOT_NAME, BOT_VERSION)\n+USER_AGENT = 'Scrapy/0.15 (+http://scrapy.org)'\n \n TELNETCONSOLE_ENABLED = 1\n TELNETCONSOLE_PORT = [6023, 6073]\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#e9184def35734031eed8d48b2fae952c36ba8be1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 8 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 9 | Churn Cumulative: 471 | Contributors (this commit): 4 | Commits (past 90d): 2 | Contributors (cumulative): 5 | DMM Complexity: 1.0\n\nDIFF:\n@@ -174,6 +174,13 @@ class XPathSelectorTestCase(unittest.TestCase):\n         self.assertEqual(x.select(\"//ul/li\").re(\"Age: (\\d+)\"),\n                          [\"10\", \"20\"])\n \n+    @libxml2debug\n+    def test_selector_re_intl(self):\n+        body = \"\"\"<div>Evento: cumplea\\xc3\\xb1os</div>\"\"\"\n+        response = HtmlResponse(url=\"http://example.com\", body=body, encoding='utf-8')\n+        x = self.hxs_cls(response)\n+        self.assertEqual(x.select(\"//div\").re(\"Evento: (\\w+)\"), [u'cumplea\\xf1os'])\n+\n     @libxml2debug\n     def test_selector_over_text(self):\n         hxs = self.hxs_cls(text='<root>lala</root>')\n\n@@ -75,7 +75,7 @@ def extract_regex(regex, text, encoding='utf-8'):\n     \"\"\"\n \n     if isinstance(regex, basestring):\n-        regex = re.compile(regex)\n+        regex = re.compile(regex, re.UNICODE)\n \n     try:\n         strings = [regex.search(text).group('extract')]   # named group\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#b39cb22d8315bde49616eae9606bfc67334e7fc0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 3 | Methods Changed: 4 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 7 | Churn Cumulative: 579 | Contributors (this commit): 3 | Commits (past 90d): 1 | Contributors (cumulative): 3 | DMM Complexity: 0.0\n\nDIFF:\n@@ -75,7 +75,7 @@ class Downloader(object):\n         self.domain_concurrency = self.settings.getint('CONCURRENT_REQUESTS_PER_DOMAIN')\n         self.ip_concurrency = self.settings.getint('CONCURRENT_REQUESTS_PER_IP')\n         self.middleware = DownloaderMiddlewareManager.from_crawler(crawler)\n-\n+        self.inactive_slots = {}\n \n     def fetch(self, request, spider):\n         key, slot = self._get_slot(request, spider)\n@@ -86,7 +86,7 @@ class Downloader(object):\n             self.active.remove(request)\n             slot.active.remove(request)\n             if not slot.active: # remove empty slots\n-                del self.slots[key]\n+                self.inactive_slots[key] = self.slots.pop(key)\n             return response\n \n         dlfunc = partial(self._enqueue_request, slot=slot)\n@@ -101,6 +101,9 @@ class Downloader(object):\n         if self.ip_concurrency:\n             key = dnscache.get(key, key)\n         if key not in self.slots:\n+            if key in self.inactive_slots:\n+                self.slots[key] = self.inactive_slots.pop(key)\n+            else:\n                 if self.ip_concurrency:\n                     concurrency = self.ip_concurrency\n                 else:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#e6d7afa13b31eeef141b283c84e703a46525064b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 2 | Churn Cumulative: 267 | Contributors (this commit): 3 | Commits (past 90d): 4 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -106,7 +106,7 @@ class AutoThrottle(object):\n         key = urlparse_cached(request).hostname or ''\n         if downloader.ip_concurrency:\n             key = dnscache.get(key, key)\n-        return key, downloader.slots.get(key)\n+        return key, downloader.slots.get(key) or downloader.inactive_slots.get(key)\n \n     def _check_concurrency(self, slot, latency):\n         latencies = self.last_latencies\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#97e4003a560aadd8e6015524cc330f9d2320e707", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 7 | Churn Cumulative: 467 | Contributors (this commit): 3 | Commits (past 90d): 4 | Contributors (cumulative): 5 | DMM Complexity: 1.0\n\nDIFF:\n@@ -37,6 +37,7 @@ class XPathSelector(object_ref):\n     def select(self, xpath):\n         if hasattr(self.xmlNode, 'xpathEval'):\n             self.doc.xpathContext.setContextNode(self.xmlNode)\n+            xpath = unicode_to_str(xpath, 'utf-8')\n             try:\n                 xpath_result = self.doc.xpathContext.xpathEval(xpath)\n             except libxml2.xpathError:\n\n@@ -43,6 +43,12 @@ class XPathSelectorTestCase(unittest.TestCase):\n         self.assertEqual([x.extract() for x in xpath.select(\"concat(//input[@name='a']/@value, //input[@name='b']/@value)\")],\n                          [u'12'])\n \n+    def test_selector_unicode_query(self):\n+        body = u\"<p><input name='\\xa9' value='1'/></p>\"\n+        response = TextResponse(url=\"http://example.com\", body=body, encoding='utf8')\n+        xpath = self.hxs_cls(response)\n+        self.assertEqual(xpath.select(u'//input[@name=\"\\xa9\"]/@value').extract(), [u'1'])\n+\n     @libxml2debug\n     def test_selector_same_type(self):\n         \"\"\"Test XPathSelector returning the same type in x() method\"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#eb47849c058270e1ad93c4d76b7ede7aac673aa5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 168 | Lines Deleted: 36 | Files Changed: 1 | Hunks: 12 | Methods Changed: 6 | Complexity Δ (Sum/Max): 33/33 | Churn Δ: 204 | Churn Cumulative: 255 | Contributors (this commit): 6 | Commits (past 90d): 1 | Contributors (cumulative): 6 | DMM Complexity: 0.07291666666666667\n\nDIFF:\n@@ -6,18 +6,14 @@ See documentation in docs/topics/request-response.rst\n \"\"\"\n \n import urllib\n-from cStringIO import StringIO\n \n-from scrapy.xlib.ClientForm import ParseFile\n+from lxml import html\n \n from scrapy.http.request import Request\n-from scrapy.utils.python import unicode_to_str\n \n-def _unicode_to_str(string, encoding):\n-    if hasattr(string, '__iter__'):\n-        return [unicode_to_str(k, encoding) for k in string]\n-    else:\n-        return unicode_to_str(string, encoding)\n+\n+class MultipleElementsFound(Exception):\n+    pass\n \n \n class FormRequest(Request):\n@@ -37,39 +33,175 @@ class FormRequest(Request):\n     @classmethod\n     def from_response(cls, response, formname=None, formnumber=0, formdata=None,\n                       clickdata=None, dont_click=False, **kwargs):\n-        encoding = getattr(response, 'encoding', 'utf-8')\n-        forms = ParseFile(StringIO(response.body), response.url,\n-                          encoding=encoding, backwards_compat=False)\n-        if not forms:\n+        if not hasattr(formdata, \"items\"):\n+            try:\n+                if formdata:\n+                    formdata = dict(formdata)\n+                else: formdata = {}\n+            except (ValueError, TypeError):\n+                raise ValueError('formdata should be a dict or iterable of tuples')\n+\n+        encoding = kwargs.get('encoding', response.encoding or 'UTF-8')\n+        hxs = html.fromstring(response.body_as_unicode(),\n+                              base_url=response.url)\n+        form = _get_form(hxs, formname, formnumber, response)\n+        inputs = _get_inputs(form, formdata, dont_click, clickdata, response)\n+        values = [(_unicode_to_str(key, encoding), _unicode_to_str(value, encoding))\n+                  for key,value in inputs]\n+        if form.action:\n+            url = form.action\n+        else:\n+            url = form.base_url\n+        if form.method == \"POST\":\n+            kwargs.setdefault('headers', {}).update(\n+                        {'Content-Type':'application/x-www-form-urlencoded'})\n+            body = urllib.urlencode(values, doseq=1)\n+        else:\n+            if '?' in url:\n+                url += '&'\n+            else:\n+                url += '?'\n+            url += urllib.urlencode(values, doseq=1)\n+            body=None\n+\n+        return cls(url, method=form.method, body=body, encoding=encoding, **kwargs)\n+\n+\n+def unicode_to_str(text, encoding='utf-8', errors='strict'):\n+    if isinstance(text, unicode):\n+        return text.encode(encoding, errors)\n+    elif isinstance(text, str):\n+        return unicode(text, 'utf-8', errors).encode(encoding, errors)\n+    else:\n+        raise TypeError('unicode_to_str must receive a unicode or str object, got %s' % type(text).__name__)\n+\n+def _unicode_to_str(string, encoding):\n+    if hasattr(string, '__iter__'):\n+        return [unicode_to_str(k, encoding) for k in string]\n+    else:\n+        return unicode_to_str(string, encoding)\n+\n+def _get_form(hxs, formname, formnumber, response):\n+    \"\"\"\n+    Uses all the passed arguments to get the required form\n+    element\n+    \"\"\"\n+    if not hxs.forms:\n         raise ValueError(\"No <form> element found in %s\" % response)\n \n-        form = None\n+    if formname is not None:\n+        f = hxs.xpath('//form[@name=\"%s\"]' % formname)\n+        if f:\n+            return f[0]\n \n-        if formname:\n-            for f in forms:\n-                if f.name == formname:\n-                    form = f\n-                    break\n-\n-        if not form:\n+    # If we get here, it means that either formname was None\n+    # or invalid\n+    if formnumber is not None:\n         try:\n-                form = forms[formnumber]\n+            form = hxs.forms[formnumber]\n         except IndexError:\n-                raise IndexError(\"Form number %d not found in %s\" % (formnumber, response))\n-        if formdata:\n-            # remove all existing fields with the same name before, so that\n-            # formdata fields properly can properly override existing ones,\n-            # which is the desired behaviour\n-            form.controls = [c for c in form.controls if c.name not in formdata]\n-            for k, v in formdata.iteritems():\n-                for v2 in v if hasattr(v, '__iter__') else [v]:\n-                    form.new_control('text', k, {'value': v2})\n-\n-        if dont_click:\n-            url, body, headers = form._switch_click('request_data')\n+            raise IndexError(\"Form number %d not found in %s\" %\n+                                (formnumber, response))\n         else:\n-            url, body, headers = form.click_request_data(**(clickdata or {}))\n+            return form\n \n-        kwargs.setdefault('headers', {}).update(headers)\n+def _get_inputs(form, formdata, dont_click, clickdata, response):\n+    \"\"\"\n+    Returns all the inputs that will be sent with the request,\n+    both those already present in the form and those given by\n+    the user\n+    \"\"\"\n+    clickables = []\n+    inputs = []\n+    for el in form.inputs:\n+        name = el.name\n+        if not name or name in formdata:\n+            continue\n+        tag = html._nons(el.tag)\n+        if tag == 'textarea':\n+            inputs.append((name, el.value))\n+        elif tag == 'select':\n+            if u' xmlns' in response.body_as_unicode()[:200]:\n+                #use builtin select parser with namespaces\n+                value = el.value\n+            else:\n+                value = el.xpath(\".//option[@selected]\") or None\n \n-        return cls(url, method=form.method, body=body, **kwargs)\n+            if el.multiple:\n+                for v in value:\n+                    if v is not None:\n+                        inputs.append((name, v))\n+            elif value is not None:\n+                inputs.append((name, value[0] if isinstance(value, list)\n+                                               else value))\n+            else:\n+                option = el.xpath(\".//option[1]/@value\")\n+                if option:\n+                    inputs.append((name, option[0]))\n+        else:\n+            assert tag == 'input', (\"Unexpected tag: %r\" % el)\n+            if el.checkable and not el.checked:\n+                continue\n+            if el.type in ('image', 'reset'):\n+                continue\n+            elif el.type == 'submit':\n+                clickables.append(el)\n+            else:\n+                value = el.value\n+                if value is not None:\n+                    inputs.append((name, el.value))\n+\n+    # If we are allowed to click on buttons and we have clickable\n+    # elements, we move on to see if we have any clickdata\n+    if not dont_click and clickables:\n+        clickable = _get_clickable(clickdata, clickables, form)\n+        inputs.append(clickable)\n+\n+    inputs.extend([(key, value) for key, value in formdata.iteritems()])\n+    return inputs\n+\n+def _get_clickable(clickdata, clickables, form):\n+    \"\"\"\n+    Returns the clickable element specified in clickdata,\n+    if the latter is given. If not, it returns the first\n+    clickable element found\n+    \"\"\"\n+    # If clickdata is given, we compare it to the clickable elements\n+    # to find a match\n+    if clickdata is not None:\n+        # We first look to see if the number is specified in\n+        # clickdata, because that uniquely identifies the element\n+        nr = clickdata.get('nr', None)\n+        if nr is not None:\n+            try:\n+                el = list(form.inputs)[nr]\n+            except IndexError:\n+                pass\n+            else:\n+                return (el.name, el.value)\n+\n+        # We didn't find it, so now we build an XPath expression\n+        # out of the other arguments, because they can be used\n+        # as such\n+        else:\n+            xpath_pred = []\n+            for k, v in clickdata.items():\n+                if k == 'coord':\n+                    v = ','.join(str(c) for c in v)\n+                xpath_pred.append('[@%s=\"%s\"]' % (k, v))\n+\n+            xpath_expr = '//*%s' % ''.join(xpath_pred)\n+            el = form.xpath(xpath_expr)\n+            if len(el) > 1:\n+                raise MultipleElementsFound(\n+                        \"Multiple elements found (%r) matching the criteria\"\n+                        \" in clickdata: %r\" % (el, clickdata)\n+                )\n+            else:\n+                return (el[0].name, el[0].value)\n+\n+    # If we don't have clickdata, we just use the first\n+    # clickable element\n+    else:\n+        el = clickables.pop(0)\n+        return (el.name, el.value)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#df2e7952783761e85ce31d867e49531d2831caf2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 16 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 16 | Churn Cumulative: 425 | Contributors (this commit): 6 | Commits (past 90d): 3 | Contributors (cumulative): 6 | DMM Complexity: 1.0\n\nDIFF:\n@@ -5,6 +5,7 @@ from cStringIO import StringIO\n from urlparse import urlparse\n \n from scrapy.http import Request, FormRequest, XmlRpcRequest, Headers, HtmlResponse\n+from scrapy.http.request.form import MultipleElementsFound\n \n \n class RequestTest(unittest.TestCase):\n@@ -320,6 +321,21 @@ class FormRequestTest(RequestTest):\n         self.assertFalse('clickeable1' in urlargs, urlargs)\n         self.assertFalse('clickeable2' in urlargs, urlargs)\n \n+    def test_from_response_ambiguous_clickdata(self):\n+        respbody = \"\"\"\n+<form action=\"get.php\" method=\"GET\">\n+<input type=\"submit\" name=\"clickeable1\" value=\"clicked1\">\n+<input type=\"hidden\" name=\"one\" value=\"1\">\n+<input type=\"hidden\" name=\"two\" value=\"3\">\n+<input type=\"submit\" name=\"clickeable2\" value=\"clicked2\">\n+</form>\n+        \"\"\"\n+        response = HtmlResponse(\"http://www.example.com/this/list.html\", body=respbody)\n+        self.assertRaises(MultipleElementsFound,\n+                          self.request_class.from_response,\n+                          response,\n+                          clickdata={'type': 'submit'})\n+\n     def test_from_response_errors_noform(self):\n         respbody = \"\"\"<html></html>\"\"\"\n         response = HtmlResponse(\"http://www.example.com/lala.html\", body=respbody)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#4be6c22c4d97497c91de9ec85c2575f5eb499b23", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 5430 | Files Changed: 3 | Hunks: 3 | Methods Changed: 250 | Complexity Δ (Sum/Max): -1085/0 | Churn Δ: 5430 | Churn Cumulative: 5764 | Contributors (this commit): 3 | Commits (past 90d): 3 | Contributors (cumulative): 8 | DMM Complexity: 0.43733681462140994\n\nDIFF:\n@@ -1,8 +0,0 @@\n-import unittest\n-\n-from scrapy.xlib import ClientForm\n-\n-class ClientFormPatchTests(unittest.TestCase):\n-\n-    def test_patched_unescape_charref(self):\n-        self.assertEqual(ClientForm.unescape_charref('c', 'utf-8'), 'c')\n\n@@ -1,2016 +0,0 @@\n-\"\"\"\n-FIXME: this module is only needed beacuse scrapy.xlib.ClientForm uses it. We\n-should remove it after we remove the scrapy.xlib.ClientForm module.\n-\n-Beautiful Soup\n-Elixir and Tonic\n-\"The Screen-Scraper's Friend\"\n-http://www.crummy.com/software/BeautifulSoup/\n-\n-Beautiful Soup parses a (possibly invalid) XML or HTML document into a\n-tree representation. It provides methods and Pythonic idioms that make\n-it easy to navigate, search, and modify the tree.\n-\n-A well-formed XML/HTML document yields a well-formed data\n-structure. An ill-formed XML/HTML document yields a correspondingly\n-ill-formed data structure. If your document is only locally\n-well-formed, you can use this library to find and process the\n-well-formed part of it.\n-\n-Beautiful Soup works with Python 2.2 and up. It has no external\n-dependencies, but you'll have more success at converting data to UTF-8\n-if you also install these three packages:\n-\n-* chardet, for auto-detecting character encodings\n-  http://chardet.feedparser.org/\n-* cjkcodecs and iconv_codec, which add more encodings to the ones supported\n-  by stock Python.\n-  http://cjkpython.i18n.org/\n-\n-Beautiful Soup defines classes for two main parsing strategies:\n-\n- * BeautifulStoneSoup, for parsing XML, SGML, or your domain-specific\n-   language that kind of looks like XML.\n-\n- * BeautifulSoup, for parsing run-of-the-mill HTML code, be it valid\n-   or invalid. This class has web browser-like heuristics for\n-   obtaining a sensible parse tree in the face of common HTML errors.\n-\n-Beautiful Soup also defines a class (UnicodeDammit) for autodetecting\n-the encoding of an HTML or XML document, and converting it to\n-Unicode. Much of this code is taken from Mark Pilgrim's Universal Feed Parser.\n-\n-For more than you ever wanted to know about Beautiful Soup, see the\n-documentation:\n-http://www.crummy.com/software/BeautifulSoup/documentation.html\n-\n-Here, have some legalese:\n-\n-Copyright (c) 2004-2010, Leonard Richardson\n-\n-All rights reserved.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-  * Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n-\n-  * Redistributions in binary form must reproduce the above\n-    copyright notice, this list of conditions and the following\n-    disclaimer in the documentation and/or other materials provided\n-    with the distribution.\n-\n-  * Neither the name of the the Beautiful Soup Consortium and All\n-    Night Kosher Bakery nor the names of its contributors may be\n-    used to endorse or promote products derived from this software\n-    without specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n-CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE, DAMMIT.\n-\n-\"\"\"\n-from __future__ import generators\n-\n-__author__ = \"Leonard Richardson (leonardr@segfault.org)\"\n-__version__ = \"3.0.8.1\"\n-__copyright__ = \"Copyright (c) 2004-2010 Leonard Richardson\"\n-__license__ = \"New-style BSD\"\n-\n-from sgmllib import SGMLParser, SGMLParseError\n-import codecs\n-import markupbase\n-import types\n-import re\n-import sgmllib\n-try:\n-  from htmlentitydefs import name2codepoint\n-except ImportError:\n-  name2codepoint = {}\n-try:\n-    set\n-except NameError:\n-    from sets import Set as set\n-\n-#These hacks make Beautiful Soup able to parse XML with namespaces\n-sgmllib.tagfind = re.compile('[a-zA-Z][-_.:a-zA-Z0-9]*')\n-markupbase._declname_match = re.compile(r'[a-zA-Z][-_.:a-zA-Z0-9]*\\s*').match\n-\n-DEFAULT_OUTPUT_ENCODING = \"utf-8\"\n-\n-def _match_css_class(str):\n-    \"\"\"Build a RE to match the given CSS class.\"\"\"\n-    return re.compile(r\"(^|.*\\s)%s($|\\s)\" % str)\n-\n-# First, the classes that represent markup elements.\n-\n-class PageElement(object):\n-    \"\"\"Contains the navigational information for some part of the page\n-    (either a tag or a piece of text)\"\"\"\n-\n-    def setup(self, parent=None, previous=None):\n-        \"\"\"Sets up the initial relations between this element and\n-        other elements.\"\"\"\n-        self.parent = parent\n-        self.previous = previous\n-        self.next = None\n-        self.previousSibling = None\n-        self.nextSibling = None\n-        if self.parent and self.parent.contents:\n-            self.previousSibling = self.parent.contents[-1]\n-            self.previousSibling.nextSibling = self\n-\n-    def replaceWith(self, replaceWith):\n-        oldParent = self.parent\n-        myIndex = self.parent.index(self)\n-        if hasattr(replaceWith, \"parent\")\\\n-                  and replaceWith.parent is self.parent:\n-            # We're replacing this element with one of its siblings.\n-            index = replaceWith.parent.index(replaceWith)\n-            if index and index < myIndex:\n-                # Furthermore, it comes before this element. That\n-                # means that when we extract it, the index of this\n-                # element will change.\n-                myIndex = myIndex - 1\n-        self.extract()\n-        oldParent.insert(myIndex, replaceWith)\n-\n-    def replaceWithChildren(self):\n-        myParent = self.parent\n-        myIndex = self.parent.index(self)\n-        self.extract()\n-        reversedChildren = list(self.contents)\n-        reversedChildren.reverse()\n-        for child in reversedChildren:\n-            myParent.insert(myIndex, child)\n-\n-    def extract(self):\n-        \"\"\"Destructively rips this element out of the tree.\"\"\"\n-        if self.parent:\n-            try:\n-                del self.parent.contents[self.parent.index(self)]\n-            except ValueError:\n-                pass\n-\n-        #Find the two elements that would be next to each other if\n-        #this element (and any children) hadn't been parsed. Connect\n-        #the two.\n-        lastChild = self._lastRecursiveChild()\n-        nextElement = lastChild.next\n-\n-        if self.previous:\n-            self.previous.next = nextElement\n-        if nextElement:\n-            nextElement.previous = self.previous\n-        self.previous = None\n-        lastChild.next = None\n-\n-        self.parent = None\n-        if self.previousSibling:\n-            self.previousSibling.nextSibling = self.nextSibling\n-        if self.nextSibling:\n-            self.nextSibling.previousSibling = self.previousSibling\n-        self.previousSibling = self.nextSibling = None\n-        return self\n-\n-    def _lastRecursiveChild(self):\n-        \"Finds the last element beneath this object to be parsed.\"\n-        lastChild = self\n-        while hasattr(lastChild, 'contents') and lastChild.contents:\n-            lastChild = lastChild.contents[-1]\n-        return lastChild\n-\n-    def insert(self, position, newChild):\n-        if isinstance(newChild, basestring) \\\n-            and not isinstance(newChild, NavigableString):\n-            newChild = NavigableString(newChild)\n-\n-        position =  min(position, len(self.contents))\n-        if hasattr(newChild, 'parent') and newChild.parent is not None:\n-            # We're 'inserting' an element that's already one\n-            # of this object's children.\n-            if newChild.parent is self:\n-                index = self.index(newChild)\n-                if index > position:\n-                    # Furthermore we're moving it further down the\n-                    # list of this object's children. That means that\n-                    # when we extract this element, our target index\n-                    # will jump down one.\n-                    position = position - 1\n-            newChild.extract()\n-\n-        newChild.parent = self\n-        previousChild = None\n-        if position == 0:\n-            newChild.previousSibling = None\n-            newChild.previous = self\n-        else:\n-            previousChild = self.contents[position-1]\n-            newChild.previousSibling = previousChild\n-            newChild.previousSibling.nextSibling = newChild\n-            newChild.previous = previousChild._lastRecursiveChild()\n-        if newChild.previous:\n-            newChild.previous.next = newChild\n-\n-        newChildsLastElement = newChild._lastRecursiveChild()\n-\n-        if position >= len(self.contents):\n-            newChild.nextSibling = None\n-\n-            parent = self\n-            parentsNextSibling = None\n-            while not parentsNextSibling:\n-                parentsNextSibling = parent.nextSibling\n-                parent = parent.parent\n-                if not parent: # This is the last element in the document.\n-                    break\n-            if parentsNextSibling:\n-                newChildsLastElement.next = parentsNextSibling\n-            else:\n-                newChildsLastElement.next = None\n-        else:\n-            nextChild = self.contents[position]\n-            newChild.nextSibling = nextChild\n-            if newChild.nextSibling:\n-                newChild.nextSibling.previousSibling = newChild\n-            newChildsLastElement.next = nextChild\n-\n-        if newChildsLastElement.next:\n-            newChildsLastElement.next.previous = newChildsLastElement\n-        self.contents.insert(position, newChild)\n-\n-    def append(self, tag):\n-        \"\"\"Appends the given tag to the contents of this tag.\"\"\"\n-        self.insert(len(self.contents), tag)\n-\n-    def findNext(self, name=None, attrs={}, text=None, **kwargs):\n-        \"\"\"Returns the first item that matches the given criteria and\n-        appears after this Tag in the document.\"\"\"\n-        return self._findOne(self.findAllNext, name, attrs, text, **kwargs)\n-\n-    def findAllNext(self, name=None, attrs={}, text=None, limit=None,\n-                    **kwargs):\n-        \"\"\"Returns all items that match the given criteria and appear\n-        after this Tag in the document.\"\"\"\n-        return self._findAll(name, attrs, text, limit, self.nextGenerator,\n-                             **kwargs)\n-\n-    def findNextSibling(self, name=None, attrs={}, text=None, **kwargs):\n-        \"\"\"Returns the closest sibling to this Tag that matches the\n-        given criteria and appears after this Tag in the document.\"\"\"\n-        return self._findOne(self.findNextSiblings, name, attrs, text,\n-                             **kwargs)\n-\n-    def findNextSiblings(self, name=None, attrs={}, text=None, limit=None,\n-                         **kwargs):\n-        \"\"\"Returns the siblings of this Tag that match the given\n-        criteria and appear after this Tag in the document.\"\"\"\n-        return self._findAll(name, attrs, text, limit,\n-                             self.nextSiblingGenerator, **kwargs)\n-    fetchNextSiblings = findNextSiblings # Compatibility with pre-3.x\n-\n-    def findPrevious(self, name=None, attrs={}, text=None, **kwargs):\n-        \"\"\"Returns the first item that matches the given criteria and\n-        appears before this Tag in the document.\"\"\"\n-        return self._findOne(self.findAllPrevious, name, attrs, text, **kwargs)\n-\n-    def findAllPrevious(self, name=None, attrs={}, text=None, limit=None,\n-                        **kwargs):\n-        \"\"\"Returns all items that match the given criteria and appear\n-        before this Tag in the document.\"\"\"\n-        return self._findAll(name, attrs, text, limit, self.previousGenerator,\n-                           **kwargs)\n-    fetchPrevious = findAllPrevious # Compatibility with pre-3.x\n-\n-    def findPreviousSibling(self, name=None, attrs={}, text=None, **kwargs):\n-        \"\"\"Returns the closest sibling to this Tag that matches the\n-        given criteria and appears before this Tag in the document.\"\"\"\n-        return self._findOne(self.findPreviousSiblings, name, attrs, text,\n-                             **kwargs)\n-\n-    def findPreviousSiblings(self, name=None, attrs={}, text=None,\n-                             limit=None, **kwargs):\n-        \"\"\"Returns the siblings of this Tag that match the given\n-        criteria and appear before this Tag in the document.\"\"\"\n-        return self._findAll(name, attrs, text, limit,\n-                             self.previousSiblingGenerator, **kwargs)\n-    fetchPreviousSiblings = findPreviousSiblings # Compatibility with pre-3.x\n-\n-    def findParent(self, name=None, attrs={}, **kwargs):\n-        \"\"\"Returns the closest parent of this Tag that matches the given\n-        criteria.\"\"\"\n-        # NOTE: We can't use _findOne because findParents takes a different\n-        # set of arguments.\n-        r = None\n-        l = self.findParents(name, attrs, 1)\n-        if l:\n-            r = l[0]\n-        return r\n-\n-    def findParents(self, name=None, attrs={}, limit=None, **kwargs):\n-        \"\"\"Returns the parents of this Tag that match the given\n-        criteria.\"\"\"\n-\n-        return self._findAll(name, attrs, None, limit, self.parentGenerator,\n-                             **kwargs)\n-    fetchParents = findParents # Compatibility with pre-3.x\n-\n-    #These methods do the real heavy lifting.\n-\n-    def _findOne(self, method, name, attrs, text, **kwargs):\n-        r = None\n-        l = method(name, attrs, text, 1, **kwargs)\n-        if l:\n-            r = l[0]\n-        return r\n-\n-    def _findAll(self, name, attrs, text, limit, generator, **kwargs):\n-        \"Iterates over a generator looking for things that match.\"\n-\n-        if isinstance(name, SoupStrainer):\n-            strainer = name\n-        # (Possibly) special case some findAll*(...) searches\n-        elif text is None and not limit and not attrs and not kwargs:\n-            # findAll*(True)\n-            if name is True:\n-                return [element for element in generator()\n-                        if isinstance(element, Tag)]\n-            # findAll*('tag-name')\n-            elif isinstance(name, basestring):\n-                return [element for element in generator()\n-                        if isinstance(element, Tag) and\n-                        element.name == name]\n-            else:\n-                strainer = SoupStrainer(name, attrs, text, **kwargs)\n-        # Build a SoupStrainer\n-        else:\n-            strainer = SoupStrainer(name, attrs, text, **kwargs)\n-        results = ResultSet(strainer)\n-        g = generator()\n-        while True:\n-            try:\n-                i = g.next()\n-            except StopIteration:\n-                break\n-            if i:\n-                found = strainer.search(i)\n-                if found:\n-                    results.append(found)\n-                    if limit and len(results) >= limit:\n-                        break\n-        return results\n-\n-    #These Generators can be used to navigate starting from both\n-    #NavigableStrings and Tags.\n-    def nextGenerator(self):\n-        i = self\n-        while i is not None:\n-            i = i.next\n-            yield i\n-\n-    def nextSiblingGenerator(self):\n-        i = self\n-        while i is not None:\n-            i = i.nextSibling\n-            yield i\n-\n-    def previousGenerator(self):\n-        i = self\n-        while i is not None:\n-            i = i.previous\n-            yield i\n-\n-    def previousSiblingGenerator(self):\n-        i = self\n-        while i is not None:\n-            i = i.previousSibling\n-            yield i\n-\n-    def parentGenerator(self):\n-        i = self\n-        while i is not None:\n-            i = i.parent\n-            yield i\n-\n-    # Utility methods\n-    def substituteEncoding(self, str, encoding=None):\n-        encoding = encoding or \"utf-8\"\n-        return str.replace(\"%SOUP-ENCODING%\", encoding)\n-\n-    def toEncoding(self, s, encoding=None):\n-        \"\"\"Encodes an object to a string in some encoding, or to Unicode.\n-        .\"\"\"\n-        if isinstance(s, unicode):\n-            if encoding:\n-                s = s.encode(encoding)\n-        elif isinstance(s, str):\n-            if encoding:\n-                s = s.encode(encoding)\n-            else:\n-                s = unicode(s)\n-        else:\n-            if encoding:\n-                s  = self.toEncoding(str(s), encoding)\n-            else:\n-                s = unicode(s)\n-        return s\n-\n-class NavigableString(unicode, PageElement):\n-\n-    def __new__(cls, value):\n-        \"\"\"Create a new NavigableString.\n-\n-        When unpickling a NavigableString, this method is called with\n-        the string in DEFAULT_OUTPUT_ENCODING. That encoding needs to be\n-        passed in to the superclass's __new__ or the superclass won't know\n-        how to handle non-ASCII characters.\n-        \"\"\"\n-        if isinstance(value, unicode):\n-            return unicode.__new__(cls, value)\n-        return unicode.__new__(cls, value, DEFAULT_OUTPUT_ENCODING)\n-\n-    def __getnewargs__(self):\n-        return (NavigableString.__str__(self),)\n-\n-    def __getattr__(self, attr):\n-        \"\"\"text.string gives you text. This is for backwards\n-        compatibility for Navigable*String, but for CData* it lets you\n-        get the string without the CData wrapper.\"\"\"\n-        if attr == 'string':\n-            return self\n-        else:\n-            raise AttributeError, \"'%s' object has no attribute '%s'\" % (self.__class__.__name__, attr)\n-\n-    def __unicode__(self):\n-        return str(self).decode(DEFAULT_OUTPUT_ENCODING)\n-\n-    def __str__(self, encoding=DEFAULT_OUTPUT_ENCODING):\n-        if encoding:\n-            return self.encode(encoding)\n-        else:\n-            return self\n-\n-class CData(NavigableString):\n-\n-    def __str__(self, encoding=DEFAULT_OUTPUT_ENCODING):\n-        return \"<![CDATA[%s]]>\" % NavigableString.__str__(self, encoding)\n-\n-class ProcessingInstruction(NavigableString):\n-    def __str__(self, encoding=DEFAULT_OUTPUT_ENCODING):\n-        output = self\n-        if \"%SOUP-ENCODING%\" in output:\n-            output = self.substituteEncoding(output, encoding)\n-        return \"<?%s?>\" % self.toEncoding(output, encoding)\n-\n-class Comment(NavigableString):\n-    def __str__(self, encoding=DEFAULT_OUTPUT_ENCODING):\n-        return \"<!--%s-->\" % NavigableString.__str__(self, encoding)\n-\n-class Declaration(NavigableString):\n-    def __str__(self, encoding=DEFAULT_OUTPUT_ENCODING):\n-        return \"<!%s>\" % NavigableString.__str__(self, encoding)\n-\n-class Tag(PageElement):\n-\n-    \"\"\"Represents a found HTML tag with its attributes and contents.\"\"\"\n-\n-    def _invert(h):\n-        \"Cheap function to invert a hash.\"\n-        i = {}\n-        for k,v in h.items():\n-            i[v] = k\n-        return i\n-\n-    XML_ENTITIES_TO_SPECIAL_CHARS = { \"apos\" : \"'\",\n-                                      \"quot\" : '\"',\n-                                      \"amp\" : \"&\",\n-                                      \"lt\" : \"<\",\n-                                      \"gt\" : \">\" }\n-\n-    XML_SPECIAL_CHARS_TO_ENTITIES = _invert(XML_ENTITIES_TO_SPECIAL_CHARS)\n-\n-    def _convertEntities(self, match):\n-        \"\"\"Used in a call to re.sub to replace HTML, XML, and numeric\n-        entities with the appropriate Unicode characters. If HTML\n-        entities are being converted, any unrecognized entities are\n-        escaped.\"\"\"\n-        x = match.group(1)\n-        if self.convertHTMLEntities and x in name2codepoint:\n-            return unichr(name2codepoint[x])\n-        elif x in self.XML_ENTITIES_TO_SPECIAL_CHARS:\n-            if self.convertXMLEntities:\n-                return self.XML_ENTITIES_TO_SPECIAL_CHARS[x]\n-            else:\n-                return u'&%s;' % x\n-        elif len(x) > 0 and x[0] == '#':\n-            # Handle numeric entities\n-            if len(x) > 1 and x[1] == 'x':\n-                return unichr(int(x[2:], 16))\n-            else:\n-                return unichr(int(x[1:]))\n-\n-        elif self.escapeUnrecognizedEntities:\n-            return u'&amp;%s;' % x\n-        else:\n-            return u'&%s;' % x\n-\n-    def __init__(self, parser, name, attrs=None, parent=None,\n-                 previous=None):\n-        \"Basic constructor.\"\n-\n-        # We don't actually store the parser object: that lets extracted\n-        # chunks be garbage-collected\n-        self.parserClass = parser.__class__\n-        self.isSelfClosing = parser.isSelfClosingTag(name)\n-        self.name = name\n-        if attrs is None:\n-            attrs = []\n-        self.attrs = attrs\n-        self.contents = []\n-        self.setup(parent, previous)\n-        self.hidden = False\n-        self.containsSubstitutions = False\n-        self.convertHTMLEntities = parser.convertHTMLEntities\n-        self.convertXMLEntities = parser.convertXMLEntities\n-        self.escapeUnrecognizedEntities = parser.escapeUnrecognizedEntities\n-\n-        # Convert any HTML, XML, or numeric entities in the attribute values.\n-        convert = lambda(k, val): (k,\n-                                   re.sub(\"&(#\\d+|#x[0-9a-fA-F]+|\\w+);\",\n-                                          self._convertEntities,\n-                                          val))\n-        self.attrs = map(convert, self.attrs)\n-\n-    def getString(self):\n-        if (len(self.contents) == 1\n-            and isinstance(self.contents[0], NavigableString)):\n-            return self.contents[0]\n-\n-    def setString(self, string):\n-        \"\"\"Replace the contents of the tag with a string\"\"\"\n-        self.clear()\n-        self.append(string)\n-\n-    string = property(getString, setString)\n-\n-    def getText(self, separator=u\"\"):\n-        if not len(self.contents):\n-            return u\"\"\n-        stopNode = self._lastRecursiveChild().next\n-        strings = []\n-        current = self.contents[0]\n-        while current is not stopNode:\n-            if isinstance(current, NavigableString):\n-                strings.append(current.strip())\n-            current = current.next\n-        return separator.join(strings)\n-\n-    text = property(getText)\n-\n-    def get(self, key, default=None):\n-        \"\"\"Returns the value of the 'key' attribute for the tag, or\n-        the value given for 'default' if it doesn't have that\n-        attribute.\"\"\"\n-        return self._getAttrMap().get(key, default)\n-\n-    def clear(self):\n-        \"\"\"Extract all children.\"\"\"\n-        for child in self.contents[:]:\n-            child.extract()\n-\n-    def index(self, element):\n-        for i, child in enumerate(self.contents):\n-            if child is element:\n-                return i\n-        raise ValueError(\"Tag.index: element not in tag\")\n-\n-    def has_key(self, key):\n-        return self._getAttrMap().has_key(key)\n-\n-    def __getitem__(self, key):\n-        \"\"\"tag[key] returns the value of the 'key' attribute for the tag,\n-        and throws an exception if it's not there.\"\"\"\n-        return self._getAttrMap()[key]\n-\n-    def __iter__(self):\n-        \"Iterating over a tag iterates over its contents.\"\n-        return iter(self.contents)\n-\n-    def __len__(self):\n-        \"The length of a tag is the length of its list of contents.\"\n-        return len(self.contents)\n-\n-    def __contains__(self, x):\n-        return x in self.contents\n-\n-    def __nonzero__(self):\n-        \"A tag is non-None even if it has no contents.\"\n-        return True\n-\n-    def __setitem__(self, key, value):\n-        \"\"\"Setting tag[key] sets the value of the 'key' attribute for the\n-        tag.\"\"\"\n-        self._getAttrMap()\n-        self.attrMap[key] = value\n-        found = False\n-        for i in range(0, len(self.attrs)):\n-            if self.attrs[i][0] == key:\n-                self.attrs[i] = (key, value)\n-                found = True\n-        if not found:\n-            self.attrs.append((key, value))\n-        self._getAttrMap()[key] = value\n-\n-    def __delitem__(self, key):\n-        \"Deleting tag[key] deletes all 'key' attributes for the tag.\"\n-        for item in self.attrs:\n-            if item[0] == key:\n-                self.attrs.remove(item)\n-                #We don't break because bad HTML can define the same\n-                #attribute multiple times.\n-            self._getAttrMap()\n-            if self.attrMap.has_key(key):\n-                del self.attrMap[key]\n-\n-    def __call__(self, *args, **kwargs):\n-        \"\"\"Calling a tag like a function is the same as calling its\n-        findAll() method. Eg. tag('a') returns a list of all the A tags\n-        found within this tag.\"\"\"\n-        return apply(self.findAll, args, kwargs)\n-\n-    def __getattr__(self, tag):\n-        #print \"Getattr %s.%s\" % (self.__class__, tag)\n-        if len(tag) > 3 and tag.rfind('Tag') == len(tag)-3:\n-            return self.find(tag[:-3])\n-        elif tag.find('__') != 0:\n-            return self.find(tag)\n-        raise AttributeError, \"'%s' object has no attribute '%s'\" % (self.__class__, tag)\n-\n-    def __eq__(self, other):\n-        \"\"\"Returns true iff this tag has the same name, the same attributes,\n-        and the same contents (recursively) as the given tag.\n-\n-        NOTE: right now this will return false if two tags have the\n-        same attributes in a different order. Should this be fixed?\"\"\"\n-        if other is self:\n-            return True\n-        if not hasattr(other, 'name') or not hasattr(other, 'attrs') or not hasattr(other, 'contents') or self.name != other.name or self.attrs != other.attrs or len(self) != len(other):\n-            return False\n-        for i in range(0, len(self.contents)):\n-            if self.contents[i] != other.contents[i]:\n-                return False\n-        return True\n-\n-    def __ne__(self, other):\n-        \"\"\"Returns true iff this tag is not identical to the other tag,\n-        as defined in __eq__.\"\"\"\n-        return not self == other\n-\n-    def __repr__(self, encoding=DEFAULT_OUTPUT_ENCODING):\n-        \"\"\"Renders this tag as a string.\"\"\"\n-        return self.__str__(encoding)\n-\n-    def __unicode__(self):\n-        return self.__str__(None)\n-\n-    BARE_AMPERSAND_OR_BRACKET = re.compile(\"([<>]|\"\n-                                           + \"&(?!#\\d+;|#x[0-9a-fA-F]+;|\\w+;)\"\n-                                           + \")\")\n-\n-    def _sub_entity(self, x):\n-        \"\"\"Used with a regular expression to substitute the\n-        appropriate XML entity for an XML special character.\"\"\"\n-        return \"&\" + self.XML_SPECIAL_CHARS_TO_ENTITIES[x.group(0)[0]] + \";\"\n-\n-    def __str__(self, encoding=DEFAULT_OUTPUT_ENCODING,\n-                prettyPrint=False, indentLevel=0):\n-        \"\"\"Returns a string or Unicode representation of this tag and\n-        its contents. To get Unicode, pass None for encoding.\n-\n-        NOTE: since Python's HTML parser consumes whitespace, this\n-        method is not certain to reproduce the whitespace present in\n-        the original string.\"\"\"\n-\n-        encodedName = self.toEncoding(self.name, encoding)\n-\n-        attrs = []\n-        if self.attrs:\n-            for key, val in self.attrs:\n-                fmt = '%s=\"%s\"'\n-                if isinstance(val, basestring):\n-                    if self.containsSubstitutions and '%SOUP-ENCODING%' in val:\n-                        val = self.substituteEncoding(val, encoding)\n-\n-                    # The attribute value either:\n-                    #\n-                    # * Contains no embedded double quotes or single quotes.\n-                    #   No problem: we enclose it in double quotes.\n-                    # * Contains embedded single quotes. No problem:\n-                    #   double quotes work here too.\n-                    # * Contains embedded double quotes. No problem:\n-                    #   we enclose it in single quotes.\n-                    # * Embeds both single _and_ double quotes. This\n-                    #   can't happen naturally, but it can happen if\n-                    #   you modify an attribute value after parsing\n-                    #   the document. Now we have a bit of a\n-                    #   problem. We solve it by enclosing the\n-                    #   attribute in single quotes, and escaping any\n-                    #   embedded single quotes to XML entities.\n-                    if '\"' in val:\n-                        fmt = \"%s='%s'\"\n-                        if \"'\" in val:\n-                            # TODO: replace with apos when\n-                            # appropriate.\n-                            val = val.replace(\"'\", \"&squot;\")\n-\n-                    # Now we're okay w/r/t quotes. But the attribute\n-                    # value might also contain angle brackets, or\n-                    # ampersands that aren't part of entities. We need\n-                    # to escape those to XML entities too.\n-                    val = self.BARE_AMPERSAND_OR_BRACKET.sub(self._sub_entity, val)\n-\n-                attrs.append(fmt % (self.toEncoding(key, encoding),\n-                                    self.toEncoding(val, encoding)))\n-        close = ''\n-        closeTag = ''\n-        if self.isSelfClosing:\n-            close = ' /'\n-        else:\n-            closeTag = '</%s>' % encodedName\n-\n-        indentTag, indentContents = 0, 0\n-        if prettyPrint:\n-            indentTag = indentLevel\n-            space = (' ' * (indentTag-1))\n-            indentContents = indentTag + 1\n-        contents = self.renderContents(encoding, prettyPrint, indentContents)\n-        if self.hidden:\n-            s = contents\n-        else:\n-            s = []\n-            attributeString = ''\n-            if attrs:\n-                attributeString = ' ' + ' '.join(attrs)\n-            if prettyPrint:\n-                s.append(space)\n-            s.append('<%s%s%s>' % (encodedName, attributeString, close))\n-            if prettyPrint:\n-                s.append(\"\\n\")\n-            s.append(contents)\n-            if prettyPrint and contents and contents[-1] != \"\\n\":\n-                s.append(\"\\n\")\n-            if prettyPrint and closeTag:\n-                s.append(space)\n-            s.append(closeTag)\n-            if prettyPrint and closeTag and self.nextSibling:\n-                s.append(\"\\n\")\n-            s = ''.join(s)\n-        return s\n-\n-    def decompose(self):\n-        \"\"\"Recursively destroys the contents of this tree.\"\"\"\n-        self.extract()\n-        if len(self.contents) == 0:\n-            return\n-        current = self.contents[0]\n-        while current is not None:\n-            next = current.next\n-            if isinstance(current, Tag):\n-                del current.contents[:]\n-            current.parent = None\n-            current.previous = None\n-            current.previousSibling = None\n-            current.next = None\n-            current.nextSibling = None\n-            current = next\n-\n-    def prettify(self, encoding=DEFAULT_OUTPUT_ENCODING):\n-        return self.__str__(encoding, True)\n-\n-    def renderContents(self, encoding=DEFAULT_OUTPUT_ENCODING,\n-                       prettyPrint=False, indentLevel=0):\n-        \"\"\"Renders the contents of this tag as a string in the given\n-        encoding. If encoding is None, returns a Unicode string..\"\"\"\n-        s=[]\n-        for c in self:\n-            text = None\n-            if isinstance(c, NavigableString):\n-                text = c.__str__(encoding)\n-            elif isinstance(c, Tag):\n-                s.append(c.__str__(encoding, prettyPrint, indentLevel))\n-            if text and prettyPrint:\n-                text = text.strip()\n-            if text:\n-                if prettyPrint:\n-                    s.append(\" \" * (indentLevel-1))\n-                s.append(text)\n-                if prettyPrint:\n-                    s.append(\"\\n\")\n-        return ''.join(s)\n-\n-    #Soup methods\n-\n-    def find(self, name=None, attrs={}, recursive=True, text=None,\n-             **kwargs):\n-        \"\"\"Return only the first child of this Tag matching the given\n-        criteria.\"\"\"\n-        r = None\n-        l = self.findAll(name, attrs, recursive, text, 1, **kwargs)\n-        if l:\n-            r = l[0]\n-        return r\n-    findChild = find\n-\n-    def findAll(self, name=None, attrs={}, recursive=True, text=None,\n-                limit=None, **kwargs):\n-        \"\"\"Extracts a list of Tag objects that match the given\n-        criteria.  You can specify the name of the Tag and any\n-        attributes you want the Tag to have.\n-\n-        The value of a key-value pair in the 'attrs' map can be a\n-        string, a list of strings, a regular expression object, or a\n-        callable that takes a string and returns whether or not the\n-        string matches for some custom definition of 'matches'. The\n-        same is true of the tag name.\"\"\"\n-        generator = self.recursiveChildGenerator\n-        if not recursive:\n-            generator = self.childGenerator\n-        return self._findAll(name, attrs, text, limit, generator, **kwargs)\n-    findChildren = findAll\n-\n-    # Pre-3.x compatibility methods\n-    first = find\n-    fetch = findAll\n-\n-    def fetchText(self, text=None, recursive=True, limit=None):\n-        return self.findAll(text=text, recursive=recursive, limit=limit)\n-\n-    def firstText(self, text=None, recursive=True):\n-        return self.find(text=text, recursive=recursive)\n-\n-    #Private methods\n-\n-    def _getAttrMap(self):\n-        \"\"\"Initializes a map representation of this tag's attributes,\n-        if not already initialized.\"\"\"\n-        if not getattr(self, 'attrMap'):\n-            self.attrMap = {}\n-            for (key, value) in self.attrs:\n-                self.attrMap[key] = value\n-        return self.attrMap\n-\n-    #Generator methods\n-    def childGenerator(self):\n-        # Just use the iterator from the contents\n-        return iter(self.contents)\n-\n-    def recursiveChildGenerator(self):\n-        if not len(self.contents):\n-            raise StopIteration\n-        stopNode = self._lastRecursiveChild().next\n-        current = self.contents[0]\n-        while current is not stopNode:\n-            yield current\n-            current = current.next\n-\n-\n-# Next, a couple classes to represent queries and their results.\n-class SoupStrainer:\n-    \"\"\"Encapsulates a number of ways of matching a markup element (tag or\n-    text).\"\"\"\n-\n-    def __init__(self, name=None, attrs={}, text=None, **kwargs):\n-        self.name = name\n-        if isinstance(attrs, basestring):\n-            kwargs['class'] = _match_css_class(attrs)\n-            attrs = None\n-        if kwargs:\n-            if attrs:\n-                attrs = attrs.copy()\n-                attrs.update(kwargs)\n-            else:\n-                attrs = kwargs\n-        self.attrs = attrs\n-        self.text = text\n-\n-    def __str__(self):\n-        if self.text:\n-            return self.text\n-        else:\n-            return \"%s|%s\" % (self.name, self.attrs)\n-\n-    def searchTag(self, markupName=None, markupAttrs={}):\n-        found = None\n-        markup = None\n-        if isinstance(markupName, Tag):\n-            markup = markupName\n-            markupAttrs = markup\n-        callFunctionWithTagData = callable(self.name) \\\n-                                and not isinstance(markupName, Tag)\n-\n-        if (not self.name) \\\n-               or callFunctionWithTagData \\\n-               or (markup and self._matches(markup, self.name)) \\\n-               or (not markup and self._matches(markupName, self.name)):\n-            if callFunctionWithTagData:\n-                match = self.name(markupName, markupAttrs)\n-            else:\n-                match = True\n-                markupAttrMap = None\n-                for attr, matchAgainst in self.attrs.items():\n-                    if not markupAttrMap:\n-                         if hasattr(markupAttrs, 'get'):\n-                            markupAttrMap = markupAttrs\n-                         else:\n-                            markupAttrMap = {}\n-                            for k,v in markupAttrs:\n-                                markupAttrMap[k] = v\n-                    attrValue = markupAttrMap.get(attr)\n-                    if not self._matches(attrValue, matchAgainst):\n-                        match = False\n-                        break\n-            if match:\n-                if markup:\n-                    found = markup\n-                else:\n-                    found = markupName\n-        return found\n-\n-    def search(self, markup):\n-        #print 'looking for %s in %s' % (self, markup)\n-        found = None\n-        # If given a list of items, scan it for a text element that\n-        # matches.\n-        if hasattr(markup, \"__iter__\") \\\n-                and not isinstance(markup, Tag):\n-            for element in markup:\n-                if isinstance(element, NavigableString) \\\n-                       and self.search(element):\n-                    found = element\n-                    break\n-        # If it's a Tag, make sure its name or attributes match.\n-        # Don't bother with Tags if we're searching for text.\n-        elif isinstance(markup, Tag):\n-            if not self.text:\n-                found = self.searchTag(markup)\n-        # If it's text, make sure the text matches.\n-        elif isinstance(markup, NavigableString) or \\\n-                 isinstance(markup, basestring):\n-            if self._matches(markup, self.text):\n-                found = markup\n-        else:\n-            raise Exception, \"I don't know how to match against a %s\" \\\n-                  % markup.__class__\n-        return found\n-\n-    def _matches(self, markup, matchAgainst):\n-        #print \"Matching %s against %s\" % (markup, matchAgainst)\n-        result = False\n-        if matchAgainst is True:\n-            result = markup is not None\n-        elif callable(matchAgainst):\n-            result = matchAgainst(markup)\n-        else:\n-            #Custom match methods take the tag as an argument, but all\n-            #other ways of matching match the tag name as a string.\n-            if isinstance(markup, Tag):\n-                markup = markup.name\n-            if markup and not isinstance(markup, basestring):\n-                markup = unicode(markup)\n-            #Now we know that chunk is either a string, or None.\n-            if hasattr(matchAgainst, 'match'):\n-                # It's a regexp object.\n-                result = markup and matchAgainst.search(markup)\n-            elif hasattr(matchAgainst, '__iter__'): # list-like\n-                result = markup in matchAgainst\n-            elif hasattr(matchAgainst, 'items'):\n-                result = markup.has_key(matchAgainst)\n-            elif matchAgainst and isinstance(markup, basestring):\n-                if isinstance(markup, unicode):\n-                    matchAgainst = unicode(matchAgainst)\n-                else:\n-                    matchAgainst = str(matchAgainst)\n-\n-            if not result:\n-                result = matchAgainst == markup\n-        return result\n-\n-class ResultSet(list):\n-    \"\"\"A ResultSet is just a list that keeps track of the SoupStrainer\n-    that created it.\"\"\"\n-    def __init__(self, source):\n-        list.__init__([])\n-        self.source = source\n-\n-# Now, some helper functions.\n-\n-def buildTagMap(default, *args):\n-    \"\"\"Turns a list of maps, lists, or scalars into a single map.\n-    Used to build the SELF_CLOSING_TAGS, NESTABLE_TAGS, and\n-    NESTING_RESET_TAGS maps out of lists and partial maps.\"\"\"\n-    built = {}\n-    for portion in args:\n-        if hasattr(portion, 'items'):\n-            #It's a map. Merge it.\n-            for k,v in portion.items():\n-                built[k] = v\n-        elif hasattr(portion, '__iter__'): # is a list\n-            #It's a list. Map each item to the default.\n-            for k in portion:\n-                built[k] = default\n-        else:\n-            #It's a scalar. Map it to the default.\n-            built[portion] = default\n-    return built\n-\n-# Now, the parser classes.\n-\n-class BeautifulStoneSoup(Tag, SGMLParser):\n-\n-    \"\"\"This class contains the basic parser and search code. It defines\n-    a parser that knows nothing about tag behavior except for the\n-    following:\n-\n-      You can't close a tag without closing all the tags it encloses.\n-      That is, \"<foo><bar></foo>\" actually means\n-      \"<foo><bar></bar></foo>\".\n-\n-    [Another possible explanation is \"<foo><bar /></foo>\", but since\n-    this class defines no SELF_CLOSING_TAGS, it will never use that\n-    explanation.]\n-\n-    This class is useful for parsing XML or made-up markup languages,\n-    or when BeautifulSoup makes an assumption counter to what you were\n-    expecting.\"\"\"\n-\n-    SELF_CLOSING_TAGS = {}\n-    NESTABLE_TAGS = {}\n-    RESET_NESTING_TAGS = {}\n-    QUOTE_TAGS = {}\n-    PRESERVE_WHITESPACE_TAGS = []\n-\n-    MARKUP_MASSAGE = [(re.compile('(<[^<>]*)/>'),\n-                       lambda x: x.group(1) + ' />'),\n-                      (re.compile('<!\\s+([^<>]*)>'),\n-                       lambda x: '<!' + x.group(1) + '>')\n-                      ]\n-\n-    ROOT_TAG_NAME = u'[document]'\n-\n-    HTML_ENTITIES = \"html\"\n-    XML_ENTITIES = \"xml\"\n-    XHTML_ENTITIES = \"xhtml\"\n-    # TODO: This only exists for backwards-compatibility\n-    ALL_ENTITIES = XHTML_ENTITIES\n-\n-    # Used when determining whether a text node is all whitespace and\n-    # can be replaced with a single space. A text node that contains\n-    # fancy Unicode spaces (usually non-breaking) should be left\n-    # alone.\n-    STRIP_ASCII_SPACES = { 9: None, 10: None, 12: None, 13: None, 32: None, }\n-\n-    def __init__(self, markup=\"\", parseOnlyThese=None, fromEncoding=None,\n-                 markupMassage=True, smartQuotesTo=XML_ENTITIES,\n-                 convertEntities=None, selfClosingTags=None, isHTML=False):\n-        \"\"\"The Soup object is initialized as the 'root tag', and the\n-        provided markup (which can be a string or a file-like object)\n-        is fed into the underlying parser.\n-\n-        sgmllib will process most bad HTML, and the BeautifulSoup\n-        class has some tricks for dealing with some HTML that kills\n-        sgmllib, but Beautiful Soup can nonetheless choke or lose data\n-        if your data uses self-closing tags or declarations\n-        incorrectly.\n-\n-        By default, Beautiful Soup uses regexes to sanitize input,\n-        avoiding the vast majority of these problems. If the problems\n-        don't apply to you, pass in False for markupMassage, and\n-        you'll get better performance.\n-\n-        The default parser massage techniques fix the two most common\n-        instances of invalid HTML that choke sgmllib:\n-\n-         <br/> (No space between name of closing tag and tag close)\n-         <! --Comment--> (Extraneous whitespace in declaration)\n-\n-        You can pass in a custom list of (RE object, replace method)\n-        tuples to get Beautiful Soup to scrub your input the way you\n-        want.\"\"\"\n-\n-        self.parseOnlyThese = parseOnlyThese\n-        self.fromEncoding = fromEncoding\n-        self.smartQuotesTo = smartQuotesTo\n-        self.convertEntities = convertEntities\n-        # Set the rules for how we'll deal with the entities we\n-        # encounter\n-        if self.convertEntities:\n-            # It doesn't make sense to convert encoded characters to\n-            # entities even while you're converting entities to Unicode.\n-            # Just convert it all to Unicode.\n-            self.smartQuotesTo = None\n-            if convertEntities == self.HTML_ENTITIES:\n-                self.convertXMLEntities = False\n-                self.convertHTMLEntities = True\n-                self.escapeUnrecognizedEntities = True\n-            elif convertEntities == self.XHTML_ENTITIES:\n-                self.convertXMLEntities = True\n-                self.convertHTMLEntities = True\n-                self.escapeUnrecognizedEntities = False\n-            elif convertEntities == self.XML_ENTITIES:\n-                self.convertXMLEntities = True\n-                self.convertHTMLEntities = False\n-                self.escapeUnrecognizedEntities = False\n-        else:\n-            self.convertXMLEntities = False\n-            self.convertHTMLEntities = False\n-            self.escapeUnrecognizedEntities = False\n-\n-        self.instanceSelfClosingTags = buildTagMap(None, selfClosingTags)\n-        SGMLParser.__init__(self)\n-\n-        if hasattr(markup, 'read'):        # It's a file-type object.\n-            markup = markup.read()\n-        self.markup = markup\n-        self.markupMassage = markupMassage\n-        try:\n-            self._feed(isHTML=isHTML)\n-        except StopParsing:\n-            pass\n-        self.markup = None                 # The markup can now be GCed\n-\n-    def convert_charref(self, name):\n-        \"\"\"This method fixes a bug in Python's SGMLParser.\"\"\"\n-        try:\n-            n = int(name)\n-        except ValueError:\n-            return\n-        if not 0 <= n <= 127 : # ASCII ends at 127, not 255\n-            return\n-        return self.convert_codepoint(n)\n-\n-    def _feed(self, inDocumentEncoding=None, isHTML=False):\n-        # Convert the document to Unicode.\n-        markup = self.markup\n-        if isinstance(markup, unicode):\n-            if not hasattr(self, 'originalEncoding'):\n-                self.originalEncoding = None\n-        else:\n-            dammit = UnicodeDammit\\\n-                     (markup, [self.fromEncoding, inDocumentEncoding],\n-                      smartQuotesTo=self.smartQuotesTo, isHTML=isHTML)\n-            markup = dammit.unicode\n-            self.originalEncoding = dammit.originalEncoding\n-            self.declaredHTMLEncoding = dammit.declaredHTMLEncoding\n-        if markup:\n-            if self.markupMassage:\n-                if not hasattr(self.markupMassage, \"__iter__\"):\n-                    self.markupMassage = self.MARKUP_MASSAGE\n-                for fix, m in self.markupMassage:\n-                    markup = fix.sub(m, markup)\n-                # TODO: We get rid of markupMassage so that the\n-                # soup object can be deepcopied later on. Some\n-                # Python installations can't copy regexes. If anyone\n-                # was relying on the existence of markupMassage, this\n-                # might cause problems.\n-                del(self.markupMassage)\n-        self.reset()\n-\n-        SGMLParser.feed(self, markup)\n-        # Close out any unfinished strings and close all the open tags.\n-        self.endData()\n-        while self.currentTag.name != self.ROOT_TAG_NAME:\n-            self.popTag()\n-\n-    def __getattr__(self, methodName):\n-        \"\"\"This method routes method call requests to either the SGMLParser\n-        superclass or the Tag superclass, depending on the method name.\"\"\"\n-        #print \"__getattr__ called on %s.%s\" % (self.__class__, methodName)\n-\n-        if methodName.startswith('start_') or methodName.startswith('end_') \\\n-               or methodName.startswith('do_'):\n-            return SGMLParser.__getattr__(self, methodName)\n-        elif not methodName.startswith('__'):\n-            return Tag.__getattr__(self, methodName)\n-        else:\n-            raise AttributeError\n-\n-    def isSelfClosingTag(self, name):\n-        \"\"\"Returns true iff the given string is the name of a\n-        self-closing tag according to this parser.\"\"\"\n-        return self.SELF_CLOSING_TAGS.has_key(name) \\\n-               or self.instanceSelfClosingTags.has_key(name)\n-\n-    def reset(self):\n-        Tag.__init__(self, self, self.ROOT_TAG_NAME)\n-        self.hidden = 1\n-        SGMLParser.reset(self)\n-        self.currentData = []\n-        self.currentTag = None\n-        self.tagStack = []\n-        self.quoteStack = []\n-        self.pushTag(self)\n-\n-    def popTag(self):\n-        tag = self.tagStack.pop()\n-\n-        #print \"Pop\", tag.name\n-        if self.tagStack:\n-            self.currentTag = self.tagStack[-1]\n-        return self.currentTag\n-\n-    def pushTag(self, tag):\n-        #print \"Push\", tag.name\n-        if self.currentTag:\n-            self.currentTag.contents.append(tag)\n-        self.tagStack.append(tag)\n-        self.currentTag = self.tagStack[-1]\n-\n-    def endData(self, containerClass=NavigableString):\n-        if self.currentData:\n-            currentData = u''.join(self.currentData)\n-            if (currentData.translate(self.STRIP_ASCII_SPACES) == '' and\n-                not set([tag.name for tag in self.tagStack]).intersection(\n-                    self.PRESERVE_WHITESPACE_TAGS)):\n-                if '\\n' in currentData:\n-                    currentData = '\\n'\n-                else:\n-                    currentData = ' '\n-            self.currentData = []\n-            if self.parseOnlyThese and len(self.tagStack) <= 1 and \\\n-                   (not self.parseOnlyThese.text or \\\n-                    not self.parseOnlyThese.search(currentData)):\n-                return\n-            o = containerClass(currentData)\n-            o.setup(self.currentTag, self.previous)\n-            if self.previous:\n-                self.previous.next = o\n-            self.previous = o\n-            self.currentTag.contents.append(o)\n-\n-\n-    def _popToTag(self, name, inclusivePop=True):\n-        \"\"\"Pops the tag stack up to and including the most recent\n-        instance of the given tag. If inclusivePop is false, pops the tag\n-        stack up to but *not* including the most recent instqance of\n-        the given tag.\"\"\"\n-        #print \"Popping to %s\" % name\n-        if name == self.ROOT_TAG_NAME:\n-            return\n-\n-        numPops = 0\n-        mostRecentTag = None\n-        for i in range(len(self.tagStack)-1, 0, -1):\n-            if name == self.tagStack[i].name:\n-                numPops = len(self.tagStack)-i\n-                break\n-        if not inclusivePop:\n-            numPops = numPops - 1\n-\n-        for i in range(0, numPops):\n-            mostRecentTag = self.popTag()\n-        return mostRecentTag\n-\n-    def _smartPop(self, name):\n-\n-        \"\"\"We need to pop up to the previous tag of this type, unless\n-        one of this tag's nesting reset triggers comes between this\n-        tag and the previous tag of this type, OR unless this tag is a\n-        generic nesting trigger and another generic nesting trigger\n-        comes between this tag and the previous tag of this type.\n-\n-        Examples:\n-         <p>Foo<b>Bar *<p>* should pop to 'p', not 'b'.\n-         <p>Foo<table>Bar *<p>* should pop to 'table', not 'p'.\n-         <p>Foo<table><tr>Bar *<p>* should pop to 'tr', not 'p'.\n-\n-         <li><ul><li> *<li>* should pop to 'ul', not the first 'li'.\n-         <tr><table><tr> *<tr>* should pop to 'table', not the first 'tr'\n-         <td><tr><td> *<td>* should pop to 'tr', not the first 'td'\n-        \"\"\"\n-\n-        nestingResetTriggers = self.NESTABLE_TAGS.get(name)\n-        isNestable = nestingResetTriggers != None\n-        isResetNesting = self.RESET_NESTING_TAGS.has_key(name)\n-        popTo = None\n-        inclusive = True\n-        for i in range(len(self.tagStack)-1, 0, -1):\n-            p = self.tagStack[i]\n-            if (not p or p.name == name) and not isNestable:\n-                #Non-nestable tags get popped to the top or to their\n-                #last occurance.\n-                popTo = name\n-                break\n-            if (nestingResetTriggers is not None\n-                and p.name in nestingResetTriggers) \\\n-                or (nestingResetTriggers is None and isResetNesting\n-                    and self.RESET_NESTING_TAGS.has_key(p.name)):\n-\n-                #If we encounter one of the nesting reset triggers\n-                #peculiar to this tag, or we encounter another tag\n-                #that causes nesting to reset, pop up to but not\n-                #including that tag.\n-                popTo = p.name\n-                inclusive = False\n-                break\n-            p = p.parent\n-        if popTo:\n-            self._popToTag(popTo, inclusive)\n-\n-    def unknown_starttag(self, name, attrs, selfClosing=0):\n-        #print \"Start tag %s: %s\" % (name, attrs)\n-        if self.quoteStack:\n-            #This is not a real tag.\n-            #print \"<%s> is not real!\" % name\n-            attrs = ''.join([' %s=\"%s\"' % (x, y) for x, y in attrs])\n-            self.handle_data('<%s%s>' % (name, attrs))\n-            return\n-        self.endData()\n-\n-        if not self.isSelfClosingTag(name) and not selfClosing:\n-            self._smartPop(name)\n-\n-        if self.parseOnlyThese and len(self.tagStack) <= 1 \\\n-               and (self.parseOnlyThese.text or not self.parseOnlyThese.searchTag(name, attrs)):\n-            return\n-\n-        tag = Tag(self, name, attrs, self.currentTag, self.previous)\n-        if self.previous:\n-            self.previous.next = tag\n-        self.previous = tag\n-        self.pushTag(tag)\n-        if selfClosing or self.isSelfClosingTag(name):\n-            self.popTag()\n-        if name in self.QUOTE_TAGS:\n-            #print \"Beginning quote (%s)\" % name\n-            self.quoteStack.append(name)\n-            self.literal = 1\n-        return tag\n-\n-    def unknown_endtag(self, name):\n-        #print \"End tag %s\" % name\n-        if self.quoteStack and self.quoteStack[-1] != name:\n-            #This is not a real end tag.\n-            #print \"</%s> is not real!\" % name\n-            self.handle_data('</%s>' % name)\n-            return\n-        self.endData()\n-        self._popToTag(name)\n-        if self.quoteStack and self.quoteStack[-1] == name:\n-            self.quoteStack.pop()\n-            self.literal = (len(self.quoteStack) > 0)\n-\n-    def handle_data(self, data):\n-        self.currentData.append(data)\n-\n-    def _toStringSubclass(self, text, subclass):\n-        \"\"\"Adds a certain piece of text to the tree as a NavigableString\n-        subclass.\"\"\"\n-        self.endData()\n-        self.handle_data(text)\n-        self.endData(subclass)\n-\n-    def handle_pi(self, text):\n-        \"\"\"Handle a processing instruction as a ProcessingInstruction\n-        object, possibly one with a %SOUP-ENCODING% slot into which an\n-        encoding will be plugged later.\"\"\"\n-        if text[:3] == \"xml\":\n-            text = u\"xml version='1.0' encoding='%SOUP-ENCODING%'\"\n-        self._toStringSubclass(text, ProcessingInstruction)\n-\n-    def handle_comment(self, text):\n-        \"Handle comments as Comment objects.\"\n-        self._toStringSubclass(text, Comment)\n-\n-    def handle_charref(self, ref):\n-        \"Handle character references as data.\"\n-        if self.convertEntities:\n-            data = unichr(int(ref))\n-        else:\n-            data = '&#%s;' % ref\n-        self.handle_data(data)\n-\n-    def handle_entityref(self, ref):\n-        \"\"\"Handle entity references as data, possibly converting known\n-        HTML and/or XML entity references to the corresponding Unicode\n-        characters.\"\"\"\n-        data = None\n-        if self.convertHTMLEntities:\n-            try:\n-                data = unichr(name2codepoint[ref])\n-            except KeyError:\n-                pass\n-\n-        if not data and self.convertXMLEntities:\n-                data = self.XML_ENTITIES_TO_SPECIAL_CHARS.get(ref)\n-\n-        if not data and self.convertHTMLEntities and \\\n-            not self.XML_ENTITIES_TO_SPECIAL_CHARS.get(ref):\n-                # TODO: We've got a problem here. We're told this is\n-                # an entity reference, but it's not an XML entity\n-                # reference or an HTML entity reference. Nonetheless,\n-                # the logical thing to do is to pass it through as an\n-                # unrecognized entity reference.\n-                #\n-                # Except: when the input is \"&carol;\" this function\n-                # will be called with input \"carol\". When the input is\n-                # \"AT&T\", this function will be called with input\n-                # \"T\". We have no way of knowing whether a semicolon\n-                # was present originally, so we don't know whether\n-                # this is an unknown entity or just a misplaced\n-                # ampersand.\n-                #\n-                # The more common case is a misplaced ampersand, so I\n-                # escape the ampersand and omit the trailing semicolon.\n-                data = \"&amp;%s\" % ref\n-        if not data:\n-            # This case is different from the one above, because we\n-            # haven't already gone through a supposedly comprehensive\n-            # mapping of entities to Unicode characters. We might not\n-            # have gone through any mapping at all. So the chances are\n-            # very high that this is a real entity, and not a\n-            # misplaced ampersand.\n-            data = \"&%s;\" % ref\n-        self.handle_data(data)\n-\n-    def handle_decl(self, data):\n-        \"Handle DOCTYPEs and the like as Declaration objects.\"\n-        self._toStringSubclass(data, Declaration)\n-\n-    def parse_declaration(self, i):\n-        \"\"\"Treat a bogus SGML declaration as raw data. Treat a CDATA\n-        declaration as a CData object.\"\"\"\n-        j = None\n-        if self.rawdata[i:i+9] == '<![CDATA[':\n-             k = self.rawdata.find(']]>', i)\n-             if k == -1:\n-                 k = len(self.rawdata)\n-             data = self.rawdata[i+9:k]\n-             j = k+3\n-             self._toStringSubclass(data, CData)\n-        else:\n-            try:\n-                j = SGMLParser.parse_declaration(self, i)\n-            except SGMLParseError:\n-                toHandle = self.rawdata[i:]\n-                self.handle_data(toHandle)\n-                j = i + len(toHandle)\n-        return j\n-\n-class BeautifulSoup(BeautifulStoneSoup):\n-\n-    \"\"\"This parser knows the following facts about HTML:\n-\n-    * Some tags have no closing tag and should be interpreted as being\n-      closed as soon as they are encountered.\n-\n-    * The text inside some tags (ie. 'script') may contain tags which\n-      are not really part of the document and which should be parsed\n-      as text, not tags. If you want to parse the text as tags, you can\n-      always fetch it and parse it explicitly.\n-\n-    * Tag nesting rules:\n-\n-      Most tags can't be nested at all. For instance, the occurance of\n-      a <p> tag should implicitly close the previous <p> tag.\n-\n-       <p>Para1<p>Para2\n-        should be transformed into:\n-       <p>Para1</p><p>Para2\n-\n-      Some tags can be nested arbitrarily. For instance, the occurance\n-      of a <blockquote> tag should _not_ implicitly close the previous\n-      <blockquote> tag.\n-\n-       Alice said: <blockquote>Bob said: <blockquote>Blah\n-        should NOT be transformed into:\n-       Alice said: <blockquote>Bob said: </blockquote><blockquote>Blah\n-\n-      Some tags can be nested, but the nesting is reset by the\n-      interposition of other tags. For instance, a <tr> tag should\n-      implicitly close the previous <tr> tag within the same <table>,\n-      but not close a <tr> tag in another table.\n-\n-       <table><tr>Blah<tr>Blah\n-        should be transformed into:\n-       <table><tr>Blah</tr><tr>Blah\n-        but,\n-       <tr>Blah<table><tr>Blah\n-        should NOT be transformed into\n-       <tr>Blah<table></tr><tr>Blah\n-\n-    Differing assumptions about tag nesting rules are a major source\n-    of problems with the BeautifulSoup class. If BeautifulSoup is not\n-    treating as nestable a tag your page author treats as nestable,\n-    try ICantBelieveItsBeautifulSoup, MinimalSoup, or\n-    BeautifulStoneSoup before writing your own subclass.\"\"\"\n-\n-    def __init__(self, *args, **kwargs):\n-        if not kwargs.has_key('smartQuotesTo'):\n-            kwargs['smartQuotesTo'] = self.HTML_ENTITIES\n-        kwargs['isHTML'] = True\n-        BeautifulStoneSoup.__init__(self, *args, **kwargs)\n-\n-    SELF_CLOSING_TAGS = buildTagMap(None,\n-                                    ('br' , 'hr', 'input', 'img', 'meta',\n-                                    'spacer', 'link', 'frame', 'base', 'col'))\n-\n-    PRESERVE_WHITESPACE_TAGS = set(['pre', 'textarea'])\n-\n-    QUOTE_TAGS = {'script' : None, 'textarea' : None}\n-\n-    #According to the HTML standard, each of these inline tags can\n-    #contain another tag of the same type. Furthermore, it's common\n-    #to actually use these tags this way.\n-    NESTABLE_INLINE_TAGS = ('span', 'font', 'q', 'object', 'bdo', 'sub', 'sup',\n-                            'center')\n-\n-    #According to the HTML standard, these block tags can contain\n-    #another tag of the same type. Furthermore, it's common\n-    #to actually use these tags this way.\n-    NESTABLE_BLOCK_TAGS = ('blockquote', 'div', 'fieldset', 'ins', 'del')\n-\n-    #Lists can contain other lists, but there are restrictions.\n-    NESTABLE_LIST_TAGS = { 'ol' : [],\n-                           'ul' : [],\n-                           'li' : ['ul', 'ol'],\n-                           'dl' : [],\n-                           'dd' : ['dl'],\n-                           'dt' : ['dl'] }\n-\n-    #Tables can contain other tables, but there are restrictions.\n-    NESTABLE_TABLE_TAGS = {'table' : [],\n-                           'tr' : ['table', 'tbody', 'tfoot', 'thead'],\n-                           'td' : ['tr'],\n-                           'th' : ['tr'],\n-                           'thead' : ['table'],\n-                           'tbody' : ['table'],\n-                           'tfoot' : ['table'],\n-                           }\n-\n-    NON_NESTABLE_BLOCK_TAGS = ('address', 'form', 'p', 'pre')\n-\n-    #If one of these tags is encountered, all tags up to the next tag of\n-    #this type are popped.\n-    RESET_NESTING_TAGS = buildTagMap(None, NESTABLE_BLOCK_TAGS, 'noscript',\n-                                     NON_NESTABLE_BLOCK_TAGS,\n-                                     NESTABLE_LIST_TAGS,\n-                                     NESTABLE_TABLE_TAGS)\n-\n-    NESTABLE_TAGS = buildTagMap([], NESTABLE_INLINE_TAGS, NESTABLE_BLOCK_TAGS,\n-                                NESTABLE_LIST_TAGS, NESTABLE_TABLE_TAGS)\n-\n-    # Used to detect the charset in a META tag; see start_meta\n-    CHARSET_RE = re.compile(\"((^|;)\\s*charset=)([^;]*)\", re.M)\n-\n-    def start_meta(self, attrs):\n-        \"\"\"Beautiful Soup can detect a charset included in a META tag,\n-        try to convert the document to that charset, and re-parse the\n-        document from the beginning.\"\"\"\n-        httpEquiv = None\n-        contentType = None\n-        contentTypeIndex = None\n-        tagNeedsEncodingSubstitution = False\n-\n-        for i in range(0, len(attrs)):\n-            key, value = attrs[i]\n-            key = key.lower()\n-            if key == 'http-equiv':\n-                httpEquiv = value\n-            elif key == 'content':\n-                contentType = value\n-                contentTypeIndex = i\n-\n-        if httpEquiv and contentType: # It's an interesting meta tag.\n-            match = self.CHARSET_RE.search(contentType)\n-            if match:\n-                if (self.declaredHTMLEncoding is not None or\n-                    self.originalEncoding == self.fromEncoding):\n-                    # An HTML encoding was sniffed while converting\n-                    # the document to Unicode, or an HTML encoding was\n-                    # sniffed during a previous pass through the\n-                    # document, or an encoding was specified\n-                    # explicitly and it worked. Rewrite the meta tag.\n-                    def rewrite(match):\n-                        return match.group(1) + \"%SOUP-ENCODING%\"\n-                    newAttr = self.CHARSET_RE.sub(rewrite, contentType)\n-                    attrs[contentTypeIndex] = (attrs[contentTypeIndex][0],\n-                                               newAttr)\n-                    tagNeedsEncodingSubstitution = True\n-                else:\n-                    # This is our first pass through the document.\n-                    # Go through it again with the encoding information.\n-                    newCharset = match.group(3)\n-                    if newCharset and newCharset != self.originalEncoding:\n-                        self.declaredHTMLEncoding = newCharset\n-                        self._feed(self.declaredHTMLEncoding)\n-                        raise StopParsing\n-                    pass\n-        tag = self.unknown_starttag(\"meta\", attrs)\n-        if tag and tagNeedsEncodingSubstitution:\n-            tag.containsSubstitutions = True\n-\n-class StopParsing(Exception):\n-    pass\n-\n-class ICantBelieveItsBeautifulSoup(BeautifulSoup):\n-\n-    \"\"\"The BeautifulSoup class is oriented towards skipping over\n-    common HTML errors like unclosed tags. However, sometimes it makes\n-    errors of its own. For instance, consider this fragment:\n-\n-     <b>Foo<b>Bar</b></b>\n-\n-    This is perfectly valid (if bizarre) HTML. However, the\n-    BeautifulSoup class will implicitly close the first b tag when it\n-    encounters the second 'b'. It will think the author wrote\n-    \"<b>Foo<b>Bar\", and didn't close the first 'b' tag, because\n-    there's no real-world reason to bold something that's already\n-    bold. When it encounters '</b></b>' it will close two more 'b'\n-    tags, for a grand total of three tags closed instead of two. This\n-    can throw off the rest of your document structure. The same is\n-    true of a number of other tags, listed below.\n-\n-    It's much more common for someone to forget to close a 'b' tag\n-    than to actually use nested 'b' tags, and the BeautifulSoup class\n-    handles the common case. This class handles the not-co-common\n-    case: where you can't believe someone wrote what they did, but\n-    it's valid HTML and BeautifulSoup screwed up by assuming it\n-    wouldn't be.\"\"\"\n-\n-    I_CANT_BELIEVE_THEYRE_NESTABLE_INLINE_TAGS = \\\n-     ('em', 'big', 'i', 'small', 'tt', 'abbr', 'acronym', 'strong',\n-      'cite', 'code', 'dfn', 'kbd', 'samp', 'strong', 'var', 'b',\n-      'big')\n-\n-    I_CANT_BELIEVE_THEYRE_NESTABLE_BLOCK_TAGS = ('noscript',)\n-\n-    NESTABLE_TAGS = buildTagMap([], BeautifulSoup.NESTABLE_TAGS,\n-                                I_CANT_BELIEVE_THEYRE_NESTABLE_BLOCK_TAGS,\n-                                I_CANT_BELIEVE_THEYRE_NESTABLE_INLINE_TAGS)\n-\n-class MinimalSoup(BeautifulSoup):\n-    \"\"\"The MinimalSoup class is for parsing HTML that contains\n-    pathologically bad markup. It makes no assumptions about tag\n-    nesting, but it does know which tags are self-closing, that\n-    <script> tags contain Javascript and should not be parsed, that\n-    META tags may contain encoding information, and so on.\n-\n-    This also makes it better for subclassing than BeautifulStoneSoup\n-    or BeautifulSoup.\"\"\"\n-\n-    RESET_NESTING_TAGS = buildTagMap('noscript')\n-    NESTABLE_TAGS = {}\n-\n-class BeautifulSOAP(BeautifulStoneSoup):\n-    \"\"\"This class will push a tag with only a single string child into\n-    the tag's parent as an attribute. The attribute's name is the tag\n-    name, and the value is the string child. An example should give\n-    the flavor of the change:\n-\n-    <foo><bar>baz</bar></foo>\n-     =>\n-    <foo bar=\"baz\"><bar>baz</bar></foo>\n-\n-    You can then access fooTag['bar'] instead of fooTag.barTag.string.\n-\n-    This is, of course, useful for scraping structures that tend to\n-    use subelements instead of attributes, such as SOAP messages. Note\n-    that it modifies its input, so don't print the modified version\n-    out.\n-\n-    I'm not sure how many people really want to use this class; let me\n-    know if you do. Mainly I like the name.\"\"\"\n-\n-    def popTag(self):\n-        if len(self.tagStack) > 1:\n-            tag = self.tagStack[-1]\n-            parent = self.tagStack[-2]\n-            parent._getAttrMap()\n-            if (isinstance(tag, Tag) and len(tag.contents) == 1 and\n-                isinstance(tag.contents[0], NavigableString) and\n-                not parent.attrMap.has_key(tag.name)):\n-                parent[tag.name] = tag.contents[0]\n-        BeautifulStoneSoup.popTag(self)\n-\n-#Enterprise class names! It has come to our attention that some people\n-#think the names of the Beautiful Soup parser classes are too silly\n-#and \"unprofessional\" for use in enterprise screen-scraping. We feel\n-#your pain! For such-minded folk, the Beautiful Soup Consortium And\n-#All-Night Kosher Bakery recommends renaming this file to\n-#\"RobustParser.py\" (or, in cases of extreme enterprisiness,\n-#\"RobustParserBeanInterface.class\") and using the following\n-#enterprise-friendly class aliases:\n-class RobustXMLParser(BeautifulStoneSoup):\n-    pass\n-class RobustHTMLParser(BeautifulSoup):\n-    pass\n-class RobustWackAssHTMLParser(ICantBelieveItsBeautifulSoup):\n-    pass\n-class RobustInsanelyWackAssHTMLParser(MinimalSoup):\n-    pass\n-class SimplifyingSOAPParser(BeautifulSOAP):\n-    pass\n-\n-######################################################\n-#\n-# Bonus library: Unicode, Dammit\n-#\n-# This class forces XML data into a standard format (usually to UTF-8\n-# or Unicode).  It is heavily based on code from Mark Pilgrim's\n-# Universal Feed Parser. It does not rewrite the XML or HTML to\n-# reflect a new encoding: that happens in BeautifulStoneSoup.handle_pi\n-# (XML) and BeautifulSoup.start_meta (HTML).\n-\n-# Autodetects character encodings.\n-# Download from http://chardet.feedparser.org/\n-try:\n-    import chardet\n-#    import chardet.constants\n-#    chardet.constants._debug = 1\n-except ImportError:\n-    chardet = None\n-\n-# cjkcodecs and iconv_codec make Python know about more character encodings.\n-# Both are available from http://cjkpython.i18n.org/\n-# They're built in if you use Python 2.4.\n-try:\n-    import cjkcodecs.aliases\n-except ImportError:\n-    pass\n-try:\n-    import iconv_codec\n-except ImportError:\n-    pass\n-\n-class UnicodeDammit:\n-    \"\"\"A class for detecting the encoding of a *ML document and\n-    converting it to a Unicode string. If the source encoding is\n-    windows-1252, can replace MS smart quotes with their HTML or XML\n-    equivalents.\"\"\"\n-\n-    # This dictionary maps commonly seen values for \"charset\" in HTML\n-    # meta tags to the corresponding Python codec names. It only covers\n-    # values that aren't in Python's aliases and can't be determined\n-    # by the heuristics in find_codec.\n-    CHARSET_ALIASES = { \"macintosh\" : \"mac-roman\",\n-                        \"x-sjis\" : \"shift-jis\" }\n-\n-    def __init__(self, markup, overrideEncodings=[],\n-                 smartQuotesTo='xml', isHTML=False):\n-        self.declaredHTMLEncoding = None\n-        self.markup, documentEncoding, sniffedEncoding = \\\n-                     self._detectEncoding(markup, isHTML)\n-        self.smartQuotesTo = smartQuotesTo\n-        self.triedEncodings = []\n-        if markup == '' or isinstance(markup, unicode):\n-            self.originalEncoding = None\n-            self.unicode = unicode(markup)\n-            return\n-\n-        u = None\n-        for proposedEncoding in overrideEncodings:\n-            u = self._convertFrom(proposedEncoding)\n-            if u: break\n-        if not u:\n-            for proposedEncoding in (documentEncoding, sniffedEncoding):\n-                u = self._convertFrom(proposedEncoding)\n-                if u: break\n-\n-        # If no luck and we have auto-detection library, try that:\n-        if not u and chardet and not isinstance(self.markup, unicode):\n-            u = self._convertFrom(chardet.detect(self.markup)['encoding'])\n-\n-        # As a last resort, try utf-8 and windows-1252:\n-        if not u:\n-            for proposed_encoding in (\"utf-8\", \"windows-1252\"):\n-                u = self._convertFrom(proposed_encoding)\n-                if u: break\n-\n-        self.unicode = u\n-        if not u: self.originalEncoding = None\n-\n-    def _subMSChar(self, orig):\n-        \"\"\"Changes a MS smart quote character to an XML or HTML\n-        entity.\"\"\"\n-        sub = self.MS_CHARS.get(orig)\n-        if isinstance(sub, tuple):\n-            if self.smartQuotesTo == 'xml':\n-                sub = '&#x%s;' % sub[1]\n-            else:\n-                sub = '&%s;' % sub[0]\n-        return sub\n-\n-    def _convertFrom(self, proposed):\n-        proposed = self.find_codec(proposed)\n-        if not proposed or proposed in self.triedEncodings:\n-            return None\n-        self.triedEncodings.append(proposed)\n-        markup = self.markup\n-\n-        # Convert smart quotes to HTML if coming from an encoding\n-        # that might have them.\n-        if self.smartQuotesTo and proposed.lower() in(\"windows-1252\",\n-                                                      \"iso-8859-1\",\n-                                                      \"iso-8859-2\"):\n-            markup = re.compile(\"([\\x80-\\x9f])\").sub \\\n-                     (lambda(x): self._subMSChar(x.group(1)),\n-                      markup)\n-\n-        try:\n-            # print \"Trying to convert document to %s\" % proposed\n-            u = self._toUnicode(markup, proposed)\n-            self.markup = u\n-            self.originalEncoding = proposed\n-        except Exception, e:\n-            # print \"That didn't work!\"\n-            # print e\n-            return None\n-        #print \"Correct encoding: %s\" % proposed\n-        return self.markup\n-\n-    def _toUnicode(self, data, encoding):\n-        '''Given a string and its encoding, decodes the string into Unicode.\n-        %encoding is a string recognized by encodings.aliases'''\n-\n-        # strip Byte Order Mark (if present)\n-        if (len(data) >= 4) and (data[:2] == '\\xfe\\xff') \\\n-               and (data[2:4] != '\\x00\\x00'):\n-            encoding = 'utf-16be'\n-            data = data[2:]\n-        elif (len(data) >= 4) and (data[:2] == '\\xff\\xfe') \\\n-                 and (data[2:4] != '\\x00\\x00'):\n-            encoding = 'utf-16le'\n-            data = data[2:]\n-        elif data[:3] == '\\xef\\xbb\\xbf':\n-            encoding = 'utf-8'\n-            data = data[3:]\n-        elif data[:4] == '\\x00\\x00\\xfe\\xff':\n-            encoding = 'utf-32be'\n-            data = data[4:]\n-        elif data[:4] == '\\xff\\xfe\\x00\\x00':\n-            encoding = 'utf-32le'\n-            data = data[4:]\n-        newdata = unicode(data, encoding)\n-        return newdata\n-\n-    def _detectEncoding(self, xml_data, isHTML=False):\n-        \"\"\"Given a document, tries to detect its XML encoding.\"\"\"\n-        xml_encoding = sniffed_xml_encoding = None\n-        try:\n-            if xml_data[:4] == '\\x4c\\x6f\\xa7\\x94':\n-                # EBCDIC\n-                xml_data = self._ebcdic_to_ascii(xml_data)\n-            elif xml_data[:4] == '\\x00\\x3c\\x00\\x3f':\n-                # UTF-16BE\n-                sniffed_xml_encoding = 'utf-16be'\n-                xml_data = unicode(xml_data, 'utf-16be').encode('utf-8')\n-            elif (len(xml_data) >= 4) and (xml_data[:2] == '\\xfe\\xff') \\\n-                     and (xml_data[2:4] != '\\x00\\x00'):\n-                # UTF-16BE with BOM\n-                sniffed_xml_encoding = 'utf-16be'\n-                xml_data = unicode(xml_data[2:], 'utf-16be').encode('utf-8')\n-            elif xml_data[:4] == '\\x3c\\x00\\x3f\\x00':\n-                # UTF-16LE\n-                sniffed_xml_encoding = 'utf-16le'\n-                xml_data = unicode(xml_data, 'utf-16le').encode('utf-8')\n-            elif (len(xml_data) >= 4) and (xml_data[:2] == '\\xff\\xfe') and \\\n-                     (xml_data[2:4] != '\\x00\\x00'):\n-                # UTF-16LE with BOM\n-                sniffed_xml_encoding = 'utf-16le'\n-                xml_data = unicode(xml_data[2:], 'utf-16le').encode('utf-8')\n-            elif xml_data[:4] == '\\x00\\x00\\x00\\x3c':\n-                # UTF-32BE\n-                sniffed_xml_encoding = 'utf-32be'\n-                xml_data = unicode(xml_data, 'utf-32be').encode('utf-8')\n-            elif xml_data[:4] == '\\x3c\\x00\\x00\\x00':\n-                # UTF-32LE\n-                sniffed_xml_encoding = 'utf-32le'\n-                xml_data = unicode(xml_data, 'utf-32le').encode('utf-8')\n-            elif xml_data[:4] == '\\x00\\x00\\xfe\\xff':\n-                # UTF-32BE with BOM\n-                sniffed_xml_encoding = 'utf-32be'\n-                xml_data = unicode(xml_data[4:], 'utf-32be').encode('utf-8')\n-            elif xml_data[:4] == '\\xff\\xfe\\x00\\x00':\n-                # UTF-32LE with BOM\n-                sniffed_xml_encoding = 'utf-32le'\n-                xml_data = unicode(xml_data[4:], 'utf-32le').encode('utf-8')\n-            elif xml_data[:3] == '\\xef\\xbb\\xbf':\n-                # UTF-8 with BOM\n-                sniffed_xml_encoding = 'utf-8'\n-                xml_data = unicode(xml_data[3:], 'utf-8').encode('utf-8')\n-            else:\n-                sniffed_xml_encoding = 'ascii'\n-                pass\n-        except:\n-            xml_encoding_match = None\n-        xml_encoding_match = re.compile(\n-            '^<\\?.*encoding=[\\'\"](.*?)[\\'\"].*\\?>').match(xml_data)\n-        if not xml_encoding_match and isHTML:\n-            regexp = re.compile('<\\s*meta[^>]+charset=([^>]*?)[;\\'\">]', re.I)\n-            xml_encoding_match = regexp.search(xml_data)\n-        if xml_encoding_match is not None:\n-            xml_encoding = xml_encoding_match.groups()[0].lower()\n-            if isHTML:\n-                self.declaredHTMLEncoding = xml_encoding\n-            if sniffed_xml_encoding and \\\n-               (xml_encoding in ('iso-10646-ucs-2', 'ucs-2', 'csunicode',\n-                                 'iso-10646-ucs-4', 'ucs-4', 'csucs4',\n-                                 'utf-16', 'utf-32', 'utf_16', 'utf_32',\n-                                 'utf16', 'u16')):\n-                xml_encoding = sniffed_xml_encoding\n-        return xml_data, xml_encoding, sniffed_xml_encoding\n-\n-\n-    def find_codec(self, charset):\n-        return self._codec(self.CHARSET_ALIASES.get(charset, charset)) \\\n-               or (charset and self._codec(charset.replace(\"-\", \"\"))) \\\n-               or (charset and self._codec(charset.replace(\"-\", \"_\"))) \\\n-               or charset\n-\n-    def _codec(self, charset):\n-        if not charset: return charset\n-        codec = None\n-        try:\n-            codecs.lookup(charset)\n-            codec = charset\n-        except (LookupError, ValueError):\n-            pass\n-        return codec\n-\n-    EBCDIC_TO_ASCII_MAP = None\n-    def _ebcdic_to_ascii(self, s):\n-        c = self.__class__\n-        if not c.EBCDIC_TO_ASCII_MAP:\n-            emap = (0,1,2,3,156,9,134,127,151,141,142,11,12,13,14,15,\n-                    16,17,18,19,157,133,8,135,24,25,146,143,28,29,30,31,\n-                    128,129,130,131,132,10,23,27,136,137,138,139,140,5,6,7,\n-                    144,145,22,147,148,149,150,4,152,153,154,155,20,21,158,26,\n-                    32,160,161,162,163,164,165,166,167,168,91,46,60,40,43,33,\n-                    38,169,170,171,172,173,174,175,176,177,93,36,42,41,59,94,\n-                    45,47,178,179,180,181,182,183,184,185,124,44,37,95,62,63,\n-                    186,187,188,189,190,191,192,193,194,96,58,35,64,39,61,34,\n-                    195,97,98,99,100,101,102,103,104,105,196,197,198,199,200,\n-                    201,202,106,107,108,109,110,111,112,113,114,203,204,205,\n-                    206,207,208,209,126,115,116,117,118,119,120,121,122,210,\n-                    211,212,213,214,215,216,217,218,219,220,221,222,223,224,\n-                    225,226,227,228,229,230,231,123,65,66,67,68,69,70,71,72,\n-                    73,232,233,234,235,236,237,125,74,75,76,77,78,79,80,81,\n-                    82,238,239,240,241,242,243,92,159,83,84,85,86,87,88,89,\n-                    90,244,245,246,247,248,249,48,49,50,51,52,53,54,55,56,57,\n-                    250,251,252,253,254,255)\n-            import string\n-            c.EBCDIC_TO_ASCII_MAP = string.maketrans( \\\n-            ''.join(map(chr, range(256))), ''.join(map(chr, emap)))\n-        return s.translate(c.EBCDIC_TO_ASCII_MAP)\n-\n-    MS_CHARS = { '\\x80' : ('euro', '20AC'),\n-                 '\\x81' : ' ',\n-                 '\\x82' : ('sbquo', '201A'),\n-                 '\\x83' : ('fnof', '192'),\n-                 '\\x84' : ('bdquo', '201E'),\n-                 '\\x85' : ('hellip', '2026'),\n-                 '\\x86' : ('dagger', '2020'),\n-                 '\\x87' : ('Dagger', '2021'),\n-                 '\\x88' : ('circ', '2C6'),\n-                 '\\x89' : ('permil', '2030'),\n-                 '\\x8A' : ('Scaron', '160'),\n-                 '\\x8B' : ('lsaquo', '2039'),\n-                 '\\x8C' : ('OElig', '152'),\n-                 '\\x8D' : '?',\n-                 '\\x8E' : ('#x17D', '17D'),\n-                 '\\x8F' : '?',\n-                 '\\x90' : '?',\n-                 '\\x91' : ('lsquo', '2018'),\n-                 '\\x92' : ('rsquo', '2019'),\n-                 '\\x93' : ('ldquo', '201C'),\n-                 '\\x94' : ('rdquo', '201D'),\n-                 '\\x95' : ('bull', '2022'),\n-                 '\\x96' : ('ndash', '2013'),\n-                 '\\x97' : ('mdash', '2014'),\n-                 '\\x98' : ('tilde', '2DC'),\n-                 '\\x99' : ('trade', '2122'),\n-                 '\\x9a' : ('scaron', '161'),\n-                 '\\x9b' : ('rsaquo', '203A'),\n-                 '\\x9c' : ('oelig', '153'),\n-                 '\\x9d' : '?',\n-                 '\\x9e' : ('#x17E', '17E'),\n-                 '\\x9f' : ('Yuml', ''),}\n-\n-#######################################################################\n-\n-\n-#By default, act as an HTML pretty-printer.\n-if __name__ == '__main__':\n-    import sys\n-    soup = BeautifulSoup(sys.stdin)\n-    print soup.prettify()\n\n@@ -1,3406 +0,0 @@\n-\"\"\"HTML form handling for web clients.\n-\n-ClientForm is a Python module for handling HTML forms on the client\n-side, useful for parsing HTML forms, filling them in and returning the\n-completed forms to the server.  It has developed from a port of Gisle\n-Aas' Perl module HTML::Form, from the libwww-perl library, but the\n-interface is not the same.\n-\n-The most useful docstring is the one for HTMLForm.\n-\n-RFC 1866: HTML 2.0\n-RFC 1867: Form-based File Upload in HTML\n-RFC 2388: Returning Values from Forms: multipart/form-data\n-HTML 3.2 Specification, W3C Recommendation 14 January 1997 (for ISINDEX)\n-HTML 4.01 Specification, W3C Recommendation 24 December 1999\n-\n-\n-Copyright 2002-2007 John J. Lee <jjl@pobox.com>\n-Copyright 2005 Gary Poster\n-Copyright 2005 Zope Corporation\n-Copyright 1998-2000 Gisle Aas.\n-\n-This code is free software; you can redistribute it and/or modify it\n-under the terms of the BSD or ZPL 2.1 licenses (see the file\n-COPYING.txt included with the distribution).\n-\n-\"\"\"\n-\n-# XXX\n-# Remove parser testing hack\n-# safeUrl()-ize action\n-# Switch to unicode throughout (would be 0.3.x)\n-#  See Wichert Akkerman's 2004-01-22 message to c.l.py.\n-# Add charset parameter to Content-type headers?  How to find value??\n-# Add some more functional tests\n-#  Especially single and multiple file upload on the internet.\n-#  Does file upload work when name is missing?  Sourceforge tracker form\n-#   doesn't like it.  Check standards, and test with Apache.  Test\n-#   binary upload with Apache.\n-# mailto submission & enctype text/plain\n-# I'm not going to fix this unless somebody tells me what real servers\n-#  that want this encoding actually expect: If enctype is\n-#  application/x-www-form-urlencoded and there's a FILE control present.\n-#  Strictly, it should be 'name=data' (see HTML 4.01 spec., section\n-#  17.13.2), but I send \"name=\" ATM.  What about multiple file upload??\n-\n-# Would be nice, but I'm not going to do it myself:\n-# -------------------------------------------------\n-# Maybe a 0.4.x?\n-#   Replace by_label etc. with moniker / selector concept. Allows, eg.,\n-#    a choice between selection by value / id / label / element\n-#    contents.  Or choice between matching labels exactly or by\n-#    substring.  Etc.\n-#   Remove deprecated methods.\n-#   ...what else?\n-# Work on DOMForm.\n-# XForms?  Don't know if there's a need here.\n-\n-__all__ = ['AmbiguityError', 'CheckboxControl', 'Control',\n-           'ControlNotFoundError', 'FileControl', 'FormParser', 'HTMLForm',\n-           'HiddenControl', 'IgnoreControl', 'ImageControl', 'IsindexControl',\n-           'Item', 'ItemCountError', 'ItemNotFoundError', 'Label',\n-           'ListControl', 'LocateError', 'Missing', 'ParseError', 'ParseFile',\n-           'ParseFileEx', 'ParseResponse', 'ParseResponseEx','PasswordControl',\n-           'RadioControl', 'ScalarControl', 'SelectControl',\n-           'SubmitButtonControl', 'SubmitControl', 'TextControl',\n-           'TextareaControl', 'XHTMLCompatibleFormParser']\n-\n-try: True\n-except NameError:\n-    True = 1\n-    False = 0\n-\n-try: bool\n-except NameError:\n-    def bool(expr):\n-        if expr: return True\n-        else: return False\n-\n-try:\n-    import logging\n-    import inspect\n-except ImportError:\n-    def debug(msg, *args, **kwds):\n-        pass\n-else:\n-    _logger = logging.getLogger(\"ClientForm\")\n-    OPTIMIZATION_HACK = True\n-\n-    def debug(msg, *args, **kwds):\n-        if OPTIMIZATION_HACK:\n-            return\n-\n-        caller_name = inspect.stack()[1][3]\n-        extended_msg = '%%s %s' % msg\n-        extended_args = (caller_name,)+args\n-        debug = _logger.debug(extended_msg, *extended_args, **kwds)\n-\n-    def _show_debug_messages():\n-        global OPTIMIZATION_HACK\n-        OPTIMIZATION_HACK = False\n-        _logger.setLevel(logging.DEBUG)\n-        handler = logging.StreamHandler(sys.stdout)\n-        handler.setLevel(logging.DEBUG)\n-        _logger.addHandler(handler)\n-\n-import sys, urllib, urllib2, types, mimetools, copy, urlparse, \\\n-       htmlentitydefs, re, random\n-from cStringIO import StringIO\n-\n-import sgmllib\n-# monkeypatch to fix http://www.python.org/sf/803422 :-(\n-sgmllib.charref = re.compile(\"&#(x?[0-9a-fA-F]+)[^0-9a-fA-F]\")\n-\n-# HTMLParser.HTMLParser is recent, so live without it if it's not available\n-# (also, sgmllib.SGMLParser is much more tolerant of bad HTML)\n-try:\n-    import HTMLParser\n-except ImportError:\n-    HAVE_MODULE_HTMLPARSER = False\n-else:\n-    HAVE_MODULE_HTMLPARSER = True\n-\n-try:\n-    import warnings\n-except ImportError:\n-    def deprecation(message, stack_offset=0):\n-        pass\n-else:\n-    def deprecation(message, stack_offset=0):\n-        warnings.warn(message, DeprecationWarning, stacklevel=3+stack_offset)\n-\n-VERSION = \"0.2.10\"\n-\n-CHUNK = 1024  # size of chunks fed to parser, in bytes\n-\n-DEFAULT_ENCODING = \"latin-1\"\n-\n-class Missing: pass\n-\n-_compress_re = re.compile(r\"\\s+\")\n-def compress_text(text): return _compress_re.sub(\" \", text.strip())\n-\n-def normalize_line_endings(text):\n-    return re.sub(r\"(?:(?<!\\r)\\n)|(?:\\r(?!\\n))\", \"\\r\\n\", text)\n-\n-\n-# This version of urlencode is from my Python 1.5.2 back-port of the\n-# Python 2.1 CVS maintenance branch of urllib.  It will accept a sequence\n-# of pairs instead of a mapping -- the 2.0 version only accepts a mapping.\n-def urlencode(query,doseq=False,):\n-    \"\"\"Encode a sequence of two-element tuples or dictionary into a URL query \\\n-string.\n-\n-    If any values in the query arg are sequences and doseq is true, each\n-    sequence element is converted to a separate parameter.\n-\n-    If the query arg is a sequence of two-element tuples, the order of the\n-    parameters in the output will match the order of parameters in the\n-    input.\n-    \"\"\"\n-\n-    if hasattr(query,\"items\"):\n-        # mapping objects\n-        query = query.items()\n-    else:\n-        # it's a bother at times that strings and string-like objects are\n-        # sequences...\n-        try:\n-            # non-sequence items should not work with len()\n-            x = len(query)\n-            # non-empty strings will fail this\n-            if len(query) and type(query[0]) != types.TupleType:\n-                raise TypeError()\n-            # zero-length sequences of all types will get here and succeed,\n-            # but that's a minor nit - since the original implementation\n-            # allowed empty dicts that type of behavior probably should be\n-            # preserved for consistency\n-        except TypeError:\n-            ty,va,tb = sys.exc_info()\n-            raise TypeError(\"not a valid non-string sequence or mapping \"\n-                            \"object\", tb)\n-\n-    l = []\n-    if not doseq:\n-        # preserve old behavior\n-        for k, v in query:\n-            k = urllib.quote_plus(str(k))\n-            v = urllib.quote_plus(str(v))\n-            l.append(k + '=' + v)\n-    else:\n-        for k, v in query:\n-            k = urllib.quote_plus(str(k))\n-            if type(v) == types.StringType:\n-                v = urllib.quote_plus(v)\n-                l.append(k + '=' + v)\n-            elif type(v) == types.UnicodeType:\n-                # is there a reasonable way to convert to ASCII?\n-                # encode generates a string, but \"replace\" or \"ignore\"\n-                # lose information and \"strict\" can raise UnicodeError\n-                v = urllib.quote_plus(v.encode(\"ASCII\",\"replace\"))\n-                l.append(k + '=' + v)\n-            else:\n-                try:\n-                    # is this a sufficient test for sequence-ness?\n-                    x = len(v)\n-                except TypeError:\n-                    # not a sequence\n-                    v = urllib.quote_plus(str(v))\n-                    l.append(k + '=' + v)\n-                else:\n-                    # loop over the sequence\n-                    for elt in v:\n-                        l.append(k + '=' + urllib.quote_plus(str(elt)))\n-    return '&'.join(l)\n-\n-def unescape(data, entities, encoding=DEFAULT_ENCODING):\n-    if data is None or \"&\" not in data:\n-        return data\n-\n-    def replace_entities(match, entities=entities, encoding=encoding):\n-        ent = match.group()\n-        if ent[1] == \"#\":\n-            return unescape_charref(ent[2:-1], encoding)\n-\n-        repl = entities.get(ent)\n-        if repl is not None:\n-            if type(repl) != type(\"\"):\n-                try:\n-                    repl = repl.encode(encoding)\n-                except UnicodeError:\n-                    repl = ent\n-        else:\n-            repl = ent\n-\n-        return repl\n-\n-    return re.sub(r\"&#?[A-Za-z0-9]+?;\", replace_entities, data)\n-\n-def unescape_charref(data, encoding):\n-    name, base = data, 10\n-    if name.startswith(\"x\"):\n-        name, base= name[1:], 16\n-    try:\n-        uc = unichr(int(name, base))\n-    except ValueError:\n-        # invalid literal for int()\n-        # or integer not in unichr()'s range\n-        uc = name\n-    if encoding is None:\n-        return uc\n-    else:\n-        try:\n-            repl = uc.encode(encoding)\n-        except UnicodeError:\n-            repl = \"&#%s;\" % data\n-        return repl\n-\n-def get_entitydefs():\n-    import htmlentitydefs\n-    from codecs import latin_1_decode\n-    entitydefs = {}\n-    try:\n-        htmlentitydefs.name2codepoint\n-    except AttributeError:\n-        entitydefs = {}\n-        for name, char in htmlentitydefs.entitydefs.items():\n-            uc = latin_1_decode(char)[0]\n-            if uc.startswith(\"&#\") and uc.endswith(\";\"):\n-                uc = unescape_charref(uc[2:-1], None)\n-            entitydefs[\"&%s;\" % name] = uc\n-    else:\n-        for name, codepoint in htmlentitydefs.name2codepoint.items():\n-            entitydefs[\"&%s;\" % name] = unichr(codepoint)\n-    return entitydefs\n-\n-\n-def issequence(x):\n-    try:\n-        x[0]\n-    except (TypeError, KeyError):\n-        return False\n-    except IndexError:\n-        pass\n-    return True\n-\n-def isstringlike(x):\n-    try: x+\"\"\n-    except: return False\n-    else: return True\n-\n-\n-def choose_boundary():\n-    \"\"\"Return a string usable as a multipart boundary.\"\"\"\n-    # follow IE and firefox\n-    nonce = \"\".join([str(random.randint(0, sys.maxint-1)) for i in 0,1,2])\n-    return \"-\"*27 + nonce\n-\n-# This cut-n-pasted MimeWriter from standard library is here so can add\n-# to HTTP headers rather than message body when appropriate.  It also uses\n-# \\r\\n in place of \\n.  This is a bit nasty.\n-class MimeWriter:\n-\n-    \"\"\"Generic MIME writer.\n-\n-    Methods:\n-\n-    __init__()\n-    addheader()\n-    flushheaders()\n-    startbody()\n-    startmultipartbody()\n-    nextpart()\n-    lastpart()\n-\n-    A MIME writer is much more primitive than a MIME parser.  It\n-    doesn't seek around on the output file, and it doesn't use large\n-    amounts of buffer space, so you have to write the parts in the\n-    order they should occur on the output file.  It does buffer the\n-    headers you add, allowing you to rearrange their order.\n-\n-    General usage is:\n-\n-    f = <open the output file>\n-    w = MimeWriter(f)\n-    ...call w.addheader(key, value) 0 or more times...\n-\n-    followed by either:\n-\n-    f = w.startbody(content_type)\n-    ...call f.write(data) for body data...\n-\n-    or:\n-\n-    w.startmultipartbody(subtype)\n-    for each part:\n-        subwriter = w.nextpart()\n-        ...use the subwriter's methods to create the subpart...\n-    w.lastpart()\n-\n-    The subwriter is another MimeWriter instance, and should be\n-    treated in the same way as the toplevel MimeWriter.  This way,\n-    writing recursive body parts is easy.\n-\n-    Warning: don't forget to call lastpart()!\n-\n-    XXX There should be more state so calls made in the wrong order\n-    are detected.\n-\n-    Some special cases:\n-\n-    - startbody() just returns the file passed to the constructor;\n-      but don't use this knowledge, as it may be changed.\n-\n-    - startmultipartbody() actually returns a file as well;\n-      this can be used to write the initial 'if you can read this your\n-      mailer is not MIME-aware' message.\n-\n-    - If you call flushheaders(), the headers accumulated so far are\n-      written out (and forgotten); this is useful if you don't need a\n-      body part at all, e.g. for a subpart of type message/rfc822\n-      that's (mis)used to store some header-like information.\n-\n-    - Passing a keyword argument 'prefix=<flag>' to addheader(),\n-      start*body() affects where the header is inserted; 0 means\n-      append at the end, 1 means insert at the start; default is\n-      append for addheader(), but insert for start*body(), which use\n-      it to determine where the Content-type header goes.\n-\n-    \"\"\"\n-\n-    def __init__(self, fp, http_hdrs=None):\n-        self._http_hdrs = http_hdrs\n-        self._fp = fp\n-        self._headers = []\n-        self._boundary = []\n-        self._first_part = True\n-\n-    def addheader(self, key, value, prefix=0,\n-                  add_to_http_hdrs=0):\n-        \"\"\"\n-        prefix is ignored if add_to_http_hdrs is true.\n-        \"\"\"\n-        lines = value.split(\"\\r\\n\")\n-        while lines and not lines[-1]: del lines[-1]\n-        while lines and not lines[0]: del lines[0]\n-        if add_to_http_hdrs:\n-            value = \"\".join(lines)\n-            # 2.2 urllib2 doesn't normalize header case\n-            self._http_hdrs.append((key.capitalize(), value))\n-        else:\n-            for i in range(1, len(lines)):\n-                lines[i] = \"    \" + lines[i].strip()\n-            value = \"\\r\\n\".join(lines) + \"\\r\\n\"\n-            line = key.title() + \": \" + value\n-            if prefix:\n-                self._headers.insert(0, line)\n-            else:\n-                self._headers.append(line)\n-\n-    def flushheaders(self):\n-        self._fp.writelines(self._headers)\n-        self._headers = []\n-\n-    def startbody(self, ctype=None, plist=[], prefix=1,\n-                  add_to_http_hdrs=0, content_type=1):\n-        \"\"\"\n-        prefix is ignored if add_to_http_hdrs is true.\n-        \"\"\"\n-        if content_type and ctype:\n-            for name, value in plist:\n-                ctype = ctype + ';\\r\\n %s=%s' % (name, value)\n-            self.addheader(\"Content-Type\", ctype, prefix=prefix,\n-                           add_to_http_hdrs=add_to_http_hdrs)\n-        self.flushheaders()\n-        if not add_to_http_hdrs: self._fp.write(\"\\r\\n\")\n-        self._first_part = True\n-        return self._fp\n-\n-    def startmultipartbody(self, subtype, boundary=None, plist=[], prefix=1,\n-                           add_to_http_hdrs=0, content_type=1):\n-        boundary = boundary or choose_boundary()\n-        self._boundary.append(boundary)\n-        return self.startbody(\"multipart/\" + subtype,\n-                              [(\"boundary\", boundary)] + plist,\n-                              prefix=prefix,\n-                              add_to_http_hdrs=add_to_http_hdrs,\n-                              content_type=content_type)\n-\n-    def nextpart(self):\n-        boundary = self._boundary[-1]\n-        if self._first_part:\n-            self._first_part = False\n-        else:\n-            self._fp.write(\"\\r\\n\")\n-        self._fp.write(\"--\" + boundary + \"\\r\\n\")\n-        return self.__class__(self._fp)\n-\n-    def lastpart(self):\n-        if self._first_part:\n-            self.nextpart()\n-        boundary = self._boundary.pop()\n-        self._fp.write(\"\\r\\n--\" + boundary + \"--\\r\\n\")\n-\n-\n-class LocateError(ValueError): pass\n-class AmbiguityError(LocateError): pass\n-class ControlNotFoundError(LocateError): pass\n-class ItemNotFoundError(LocateError): pass\n-\n-class ItemCountError(ValueError): pass\n-\n-# for backwards compatibility, ParseError derives from exceptions that were\n-# raised by versions of ClientForm <= 0.2.5\n-if HAVE_MODULE_HTMLPARSER:\n-    SGMLLIB_PARSEERROR = sgmllib.SGMLParseError\n-    class ParseError(sgmllib.SGMLParseError,\n-                     HTMLParser.HTMLParseError,\n-                     ):\n-        pass\n-else:\n-    if hasattr(sgmllib, \"SGMLParseError\"):\n-        SGMLLIB_PARSEERROR = sgmllib.SGMLParseError\n-        class ParseError(sgmllib.SGMLParseError):\n-            pass\n-    else:\n-        SGMLLIB_PARSEERROR = RuntimeError\n-        class ParseError(RuntimeError):\n-            pass\n-\n-\n-class _AbstractFormParser:\n-    \"\"\"forms attribute contains HTMLForm instances on completion.\"\"\"\n-    # thanks to Moshe Zadka for an example of sgmllib/htmllib usage\n-    def __init__(self, entitydefs=None, encoding=DEFAULT_ENCODING):\n-        if entitydefs is None:\n-            entitydefs = get_entitydefs()\n-        self._entitydefs = entitydefs\n-        self._encoding = encoding\n-\n-        self.base = None\n-        self.forms = []\n-        self.labels = []\n-        self._current_label = None\n-        self._current_form = None\n-        self._select = None\n-        self._optgroup = None\n-        self._option = None\n-        self._textarea = None\n-\n-        # forms[0] will contain all controls that are outside of any form\n-        # self._global_form is an alias for self.forms[0]\n-        self._global_form = None\n-        self.start_form([])\n-        self.end_form()\n-        self._current_form = self._global_form = self.forms[0]\n-\n-    def do_base(self, attrs):\n-        debug(\"%s\", attrs)\n-        for key, value in attrs:\n-            if key == \"href\":\n-                self.base = self.unescape_attr_if_required(value)\n-\n-    def end_body(self):\n-        debug(\"\")\n-        if self._current_label is not None:\n-            self.end_label()\n-        if self._current_form is not self._global_form:\n-            self.end_form()\n-\n-    def start_form(self, attrs):\n-        debug(\"%s\", attrs)\n-        if self._current_form is not self._global_form:\n-            raise ParseError(\"nested FORMs\")\n-        name = None\n-        action = None\n-        enctype = \"application/x-www-form-urlencoded\"\n-        method = \"GET\"\n-        d = {}\n-        for key, value in attrs:\n-            if key == \"name\":\n-                name = self.unescape_attr_if_required(value)\n-            elif key == \"action\":\n-                action = self.unescape_attr_if_required(value)\n-            elif key == \"method\":\n-                method = self.unescape_attr_if_required(value.upper())\n-            elif key == \"enctype\":\n-                enctype = self.unescape_attr_if_required(value.lower())\n-            d[key] = self.unescape_attr_if_required(value)\n-        controls = []\n-        self._current_form = (name, action, method, enctype), d, controls\n-\n-    def end_form(self):\n-        debug(\"\")\n-        if self._current_label is not None:\n-            self.end_label()\n-        if self._current_form is self._global_form:\n-            raise ParseError(\"end of FORM before start\")\n-        self.forms.append(self._current_form)\n-        self._current_form = self._global_form\n-\n-    def start_select(self, attrs):\n-        debug(\"%s\", attrs)\n-        if self._select is not None:\n-            raise ParseError(\"nested SELECTs\")\n-        if self._textarea is not None:\n-            raise ParseError(\"SELECT inside TEXTAREA\")\n-        d = {}\n-        for key, val in attrs:\n-            d[key] = self.unescape_attr_if_required(val)\n-\n-        self._select = d\n-        self._add_label(d)\n-\n-        self._append_select_control({\"__select\": d})\n-\n-    def end_select(self):\n-        debug(\"\")\n-        if self._select is None:\n-            raise ParseError(\"end of SELECT before start\")\n-\n-        if self._option is not None:\n-            self._end_option()\n-\n-        self._select = None\n-\n-    def start_optgroup(self, attrs):\n-        debug(\"%s\", attrs)\n-        if self._select is None:\n-            raise ParseError(\"OPTGROUP outside of SELECT\")\n-        d = {}\n-        for key, val in attrs:\n-            d[key] = self.unescape_attr_if_required(val)\n-\n-        self._optgroup = d\n-\n-    def end_optgroup(self):\n-        debug(\"\")\n-        if self._optgroup is None:\n-            raise ParseError(\"end of OPTGROUP before start\")\n-        self._optgroup = None\n-\n-    def _start_option(self, attrs):\n-        debug(\"%s\", attrs)\n-        if self._select is None:\n-            raise ParseError(\"OPTION outside of SELECT\")\n-        if self._option is not None:\n-            self._end_option()\n-\n-        d = {}\n-        for key, val in attrs:\n-            d[key] = self.unescape_attr_if_required(val)\n-\n-        self._option = {}\n-        self._option.update(d)\n-        if (self._optgroup and self._optgroup.has_key(\"disabled\") and\n-            not self._option.has_key(\"disabled\")):\n-            self._option[\"disabled\"] = None\n-\n-    def _end_option(self):\n-        debug(\"\")\n-        if self._option is None:\n-            raise ParseError(\"end of OPTION before start\")\n-\n-        contents = self._option.get(\"contents\", \"\").strip()\n-        self._option[\"contents\"] = contents\n-        if not self._option.has_key(\"value\"):\n-            self._option[\"value\"] = contents\n-        if not self._option.has_key(\"label\"):\n-            self._option[\"label\"] = contents\n-        # stuff dict of SELECT HTML attrs into a special private key\n-        #  (gets deleted again later)\n-        self._option[\"__select\"] = self._select\n-        self._append_select_control(self._option)\n-        self._option = None\n-\n-    def _append_select_control(self, attrs):\n-        debug(\"%s\", attrs)\n-        controls = self._current_form[2]\n-        name = self._select.get(\"name\")\n-        controls.append((\"select\", name, attrs))\n-\n-    def start_textarea(self, attrs):\n-        debug(\"%s\", attrs)\n-        if self._textarea is not None:\n-            raise ParseError(\"nested TEXTAREAs\")\n-        if self._select is not None:\n-            raise ParseError(\"TEXTAREA inside SELECT\")\n-        d = {}\n-        for key, val in attrs:\n-            d[key] = self.unescape_attr_if_required(val)\n-        self._add_label(d)\n-\n-        self._textarea = d\n-\n-    def end_textarea(self):\n-        debug(\"\")\n-        if self._textarea is None:\n-            raise ParseError(\"end of TEXTAREA before start\")\n-        controls = self._current_form[2]\n-        name = self._textarea.get(\"name\")\n-        controls.append((\"textarea\", name, self._textarea))\n-        self._textarea = None\n-\n-    def start_label(self, attrs):\n-        debug(\"%s\", attrs)\n-        if self._current_label:\n-            self.end_label()\n-        d = {}\n-        for key, val in attrs:\n-            d[key] = self.unescape_attr_if_required(val)\n-        taken = bool(d.get(\"for\"))  # empty id is invalid\n-        d[\"__text\"] = \"\"\n-        d[\"__taken\"] = taken\n-        if taken:\n-            self.labels.append(d)\n-        self._current_label = d\n-\n-    def end_label(self):\n-        debug(\"\")\n-        label = self._current_label\n-        if label is None:\n-            # something is ugly in the HTML, but we're ignoring it\n-            return\n-        self._current_label = None\n-        # if it is staying around, it is True in all cases\n-        del label[\"__taken\"]\n-\n-    def _add_label(self, d):\n-        #debug(\"%s\", d)\n-        if self._current_label is not None:\n-            if not self._current_label[\"__taken\"]:\n-                self._current_label[\"__taken\"] = True\n-                d[\"__label\"] = self._current_label\n-\n-    def handle_data(self, data):\n-        debug(\"%s\", data)\n-\n-        if self._option is not None:\n-            # self._option is a dictionary of the OPTION element's HTML\n-            # attributes, but it has two special keys, one of which is the\n-            # special \"contents\" key contains text between OPTION tags (the\n-            # other is the \"__select\" key: see the end_option method)\n-            map = self._option\n-            key = \"contents\"\n-        elif self._textarea is not None:\n-            map = self._textarea\n-            key = \"value\"\n-            data = normalize_line_endings(data)\n-        # not if within option or textarea\n-        elif self._current_label is not None:\n-            map = self._current_label\n-            key = \"__text\"\n-        else:\n-            return\n-\n-        if data and not map.has_key(key):\n-            # according to\n-            # http://www.w3.org/TR/html4/appendix/notes.html#h-B.3.1 line break\n-            # immediately after start tags or immediately before end tags must\n-            # be ignored, but real browsers only ignore a line break after a\n-            # start tag, so we'll do that.\n-            if data[0:2] == \"\\r\\n\":\n-                data = data[2:]\n-            elif data[0:1] in [\"\\n\", \"\\r\"]:\n-                data = data[1:]\n-            map[key] = data\n-        else:\n-            map[key] = map[key] + data\n-\n-    def do_button(self, attrs):\n-        debug(\"%s\", attrs)\n-        d = {}\n-        d[\"type\"] = \"submit\"  # default\n-        for key, val in attrs:\n-            d[key] = self.unescape_attr_if_required(val)\n-        controls = self._current_form[2]\n-\n-        type = d[\"type\"]\n-        name = d.get(\"name\")\n-        # we don't want to lose information, so use a type string that\n-        # doesn't clash with INPUT TYPE={SUBMIT,RESET,BUTTON}\n-        # e.g. type for BUTTON/RESET is \"resetbutton\"\n-        #     (type for INPUT/RESET is \"reset\")\n-        type = type+\"button\"\n-        self._add_label(d)\n-        controls.append((type, name, d))\n-\n-    def do_input(self, attrs):\n-        debug(\"%s\", attrs)\n-        d = {}\n-        d[\"type\"] = \"text\"  # default\n-        for key, val in attrs:\n-            d[key] = self.unescape_attr_if_required(val)\n-        controls = self._current_form[2]\n-\n-        type = d[\"type\"]\n-        name = d.get(\"name\")\n-        self._add_label(d)\n-        controls.append((type, name, d))\n-\n-    def do_isindex(self, attrs):\n-        debug(\"%s\", attrs)\n-        d = {}\n-        for key, val in attrs:\n-            d[key] = self.unescape_attr_if_required(val)\n-        controls = self._current_form[2]\n-\n-        self._add_label(d)\n-        # isindex doesn't have type or name HTML attributes\n-        controls.append((\"isindex\", None, d))\n-\n-    def handle_entityref(self, name):\n-        #debug(\"%s\", name)\n-        self.handle_data(unescape(\n-            '&%s;' % name, self._entitydefs, self._encoding))\n-\n-    def handle_charref(self, name):\n-        #debug(\"%s\", name)\n-        self.handle_data(unescape_charref(name, self._encoding))\n-\n-    def unescape_attr(self, name):\n-        #debug(\"%s\", name)\n-        return unescape(name, self._entitydefs, self._encoding)\n-\n-    def unescape_attrs(self, attrs):\n-        #debug(\"%s\", attrs)\n-        escaped_attrs = {}\n-        for key, val in attrs.items():\n-            try:\n-                val.items\n-            except AttributeError:\n-                escaped_attrs[key] = self.unescape_attr(val)\n-            else:\n-                # e.g. \"__select\" -- yuck!\n-                escaped_attrs[key] = self.unescape_attrs(val)\n-        return escaped_attrs\n-\n-    def unknown_entityref(self, ref): self.handle_data(\"&%s;\" % ref)\n-    def unknown_charref(self, ref): self.handle_data(\"&#%s;\" % ref)\n-\n-\n-if not HAVE_MODULE_HTMLPARSER:\n-    class XHTMLCompatibleFormParser:\n-        def __init__(self, entitydefs=None, encoding=DEFAULT_ENCODING):\n-            raise ValueError(\"HTMLParser could not be imported\")\n-else:\n-    class XHTMLCompatibleFormParser(_AbstractFormParser, HTMLParser.HTMLParser):\n-        \"\"\"Good for XHTML, bad for tolerance of incorrect HTML.\"\"\"\n-        # thanks to Michael Howitz for this!\n-        def __init__(self, entitydefs=None, encoding=DEFAULT_ENCODING):\n-            HTMLParser.HTMLParser.__init__(self)\n-            _AbstractFormParser.__init__(self, entitydefs, encoding)\n-\n-        def feed(self, data):\n-            try:\n-                HTMLParser.HTMLParser.feed(self, data)\n-            except HTMLParser.HTMLParseError, exc:\n-                raise ParseError(exc)\n-\n-        def start_option(self, attrs):\n-            _AbstractFormParser._start_option(self, attrs)\n-\n-        def end_option(self):\n-            _AbstractFormParser._end_option(self)\n-\n-        def handle_starttag(self, tag, attrs):\n-            try:\n-                method = getattr(self, \"start_\" + tag)\n-            except AttributeError:\n-                try:\n-                    method = getattr(self, \"do_\" + tag)\n-                except AttributeError:\n-                    pass  # unknown tag\n-                else:\n-                    method(attrs)\n-            else:\n-                method(attrs)\n-\n-        def handle_endtag(self, tag):\n-            try:\n-                method = getattr(self, \"end_\" + tag)\n-            except AttributeError:\n-                pass  # unknown tag\n-            else:\n-                method()\n-\n-        def unescape(self, name):\n-            # Use the entitydefs passed into constructor, not\n-            # HTMLParser.HTMLParser's entitydefs.\n-            return self.unescape_attr(name)\n-\n-        def unescape_attr_if_required(self, name):\n-            return name  # HTMLParser.HTMLParser already did it\n-        def unescape_attrs_if_required(self, attrs):\n-            return attrs  # ditto\n-\n-        def close(self):\n-            HTMLParser.HTMLParser.close(self)\n-            self.end_body()\n-\n-\n-class _AbstractSgmllibParser(_AbstractFormParser):\n-\n-    def do_option(self, attrs):\n-        _AbstractFormParser._start_option(self, attrs)\n-\n-    if sys.version_info[:2] >= (2,5):\n-        # we override this attr to decode hex charrefs\n-        entity_or_charref = re.compile(\n-            '&(?:([a-zA-Z][-.a-zA-Z0-9]*)|#(x?[0-9a-fA-F]+))(;?)')\n-        def convert_entityref(self, name):\n-            return unescape(\"&%s;\" % name, self._entitydefs, self._encoding)\n-        def convert_charref(self, name):\n-            return unescape_charref(\"%s\" % name, self._encoding)\n-        def unescape_attr_if_required(self, name):\n-            return name  # sgmllib already did it\n-        def unescape_attrs_if_required(self, attrs):\n-            return attrs  # ditto\n-    else:\n-        def unescape_attr_if_required(self, name):\n-            return self.unescape_attr(name)\n-        def unescape_attrs_if_required(self, attrs):\n-            return self.unescape_attrs(attrs)\n-\n-\n-class FormParser(_AbstractSgmllibParser, sgmllib.SGMLParser):\n-    \"\"\"Good for tolerance of incorrect HTML, bad for XHTML.\"\"\"\n-    def __init__(self, entitydefs=None, encoding=DEFAULT_ENCODING):\n-        sgmllib.SGMLParser.__init__(self)\n-        _AbstractFormParser.__init__(self, entitydefs, encoding)\n-\n-    def feed(self, data):\n-        try:\n-            sgmllib.SGMLParser.feed(self, data)\n-        except SGMLLIB_PARSEERROR, exc:\n-            raise ParseError(exc)\n-\n-    def close(self):\n-        sgmllib.SGMLParser.close(self)\n-        self.end_body()\n-\n-\n-# sigh, must support mechanize by allowing dynamic creation of classes based on\n-# its bundled copy of BeautifulSoup (which was necessary because of dependency\n-# problems)\n-\n-def _create_bs_classes(bs,\n-                       icbinbs,\n-                       ):\n-    class _AbstractBSFormParser(_AbstractSgmllibParser):\n-        bs_base_class = None\n-        def __init__(self, entitydefs=None, encoding=DEFAULT_ENCODING):\n-            _AbstractFormParser.__init__(self, entitydefs, encoding)\n-            self.bs_base_class.__init__(self)\n-        def handle_data(self, data):\n-            _AbstractFormParser.handle_data(self, data)\n-            self.bs_base_class.handle_data(self, data)\n-        def feed(self, data):\n-            try:\n-                self.bs_base_class.feed(self, data)\n-            except SGMLLIB_PARSEERROR, exc:\n-                raise ParseError(exc)\n-        def close(self):\n-            self.bs_base_class.close(self)\n-            self.end_body()\n-\n-    class RobustFormParser(_AbstractBSFormParser, bs):\n-        \"\"\"Tries to be highly tolerant of incorrect HTML.\"\"\"\n-        pass\n-    RobustFormParser.bs_base_class = bs\n-    class NestingRobustFormParser(_AbstractBSFormParser, icbinbs):\n-        \"\"\"Tries to be highly tolerant of incorrect HTML.\n-\n-        Different from RobustFormParser in that it more often guesses nesting\n-        above missing end tags (see BeautifulSoup docs).\n-\n-        \"\"\"\n-        pass\n-    NestingRobustFormParser.bs_base_class = icbinbs\n-\n-    return RobustFormParser, NestingRobustFormParser\n-\n-try:\n-    if sys.version_info[:2] < (2, 2):\n-        raise ImportError  # BeautifulSoup uses generators\n-    from scrapy.xlib import BeautifulSoup\n-except ImportError:\n-    pass\n-else:\n-    RobustFormParser, NestingRobustFormParser = _create_bs_classes(\n-        BeautifulSoup.BeautifulSoup, BeautifulSoup.ICantBelieveItsBeautifulSoup\n-        )\n-    __all__ += ['RobustFormParser', 'NestingRobustFormParser']\n-\n-\n-#FormParser = XHTMLCompatibleFormParser  # testing hack\n-#FormParser = RobustFormParser  # testing hack\n-\n-\n-def ParseResponseEx(response,\n-                    select_default=False,\n-                    form_parser_class=FormParser,\n-                    request_class=urllib2.Request,\n-                    entitydefs=None,\n-                    encoding=DEFAULT_ENCODING,\n-\n-                    # private\n-                    _urljoin=urlparse.urljoin,\n-                    _urlparse=urlparse.urlparse,\n-                    _urlunparse=urlparse.urlunparse,\n-                    ):\n-    \"\"\"Identical to ParseResponse, except that:\n-\n-    1. The returned list contains an extra item.  The first form in the list\n-    contains all controls not contained in any FORM element.\n-\n-    2. The arguments ignore_errors and backwards_compat have been removed.\n-\n-    3. Backwards-compatibility mode (backwards_compat=True) is not available.\n-    \"\"\"\n-    return _ParseFileEx(response, response.geturl(),\n-                        select_default,\n-                        False,\n-                        form_parser_class,\n-                        request_class,\n-                        entitydefs,\n-                        False,\n-                        encoding,\n-                        _urljoin=_urljoin,\n-                        _urlparse=_urlparse,\n-                        _urlunparse=_urlunparse,\n-                        )\n-\n-def ParseFileEx(file, base_uri,\n-                select_default=False,\n-                form_parser_class=FormParser,\n-                request_class=urllib2.Request,\n-                entitydefs=None,\n-                encoding=DEFAULT_ENCODING,\n-\n-                # private\n-                _urljoin=urlparse.urljoin,\n-                _urlparse=urlparse.urlparse,\n-                _urlunparse=urlparse.urlunparse,\n-                ):\n-    \"\"\"Identical to ParseFile, except that:\n-\n-    1. The returned list contains an extra item.  The first form in the list\n-    contains all controls not contained in any FORM element.\n-\n-    2. The arguments ignore_errors and backwards_compat have been removed.\n-\n-    3. Backwards-compatibility mode (backwards_compat=True) is not available.\n-    \"\"\"\n-    return _ParseFileEx(file, base_uri,\n-                        select_default,\n-                        False,\n-                        form_parser_class,\n-                        request_class,\n-                        entitydefs,\n-                        False,\n-                        encoding,\n-                        _urljoin=_urljoin,\n-                        _urlparse=_urlparse,\n-                        _urlunparse=_urlunparse,\n-                        )\n-\n-def ParseResponse(response, *args, **kwds):\n-    \"\"\"Parse HTTP response and return a list of HTMLForm instances.\n-\n-    The return value of urllib2.urlopen can be conveniently passed to this\n-    function as the response parameter.\n-\n-    ClientForm.ParseError is raised on parse errors.\n-\n-    response: file-like object (supporting read() method) with a method\n-     geturl(), returning the URI of the HTTP response\n-    select_default: for multiple-selection SELECT controls and RADIO controls,\n-     pick the first item as the default if none are selected in the HTML\n-    form_parser_class: class to instantiate and use to pass\n-    request_class: class to return from .click() method (default is\n-     urllib2.Request)\n-    entitydefs: mapping like {\"&amp;\": \"&\", ...} containing HTML entity\n-     definitions (a sensible default is used)\n-    encoding: character encoding used for encoding numeric character references\n-     when matching link text.  ClientForm does not attempt to find the encoding\n-     in a META HTTP-EQUIV attribute in the document itself (mechanize, for\n-     example, does do that and will pass the correct value to ClientForm using\n-     this parameter).\n-\n-    backwards_compat: boolean that determines whether the returned HTMLForm\n-     objects are backwards-compatible with old code.  If backwards_compat is\n-     true:\n-\n-     - ClientForm 0.1 code will continue to work as before.\n-\n-     - Label searches that do not specify a nr (number or count) will always\n-       get the first match, even if other controls match.  If\n-       backwards_compat is False, label searches that have ambiguous results\n-       will raise an AmbiguityError.\n-\n-     - Item label matching is done by strict string comparison rather than\n-       substring matching.\n-\n-     - De-selecting individual list items is allowed even if the Item is\n-       disabled.\n-\n-    The backwards_compat argument will be deprecated in a future release.\n-\n-    Pass a true value for select_default if you want the behaviour specified by\n-    RFC 1866 (the HTML 2.0 standard), which is to select the first item in a\n-    RADIO or multiple-selection SELECT control if none were selected in the\n-    HTML.  Most browsers (including Microsoft Internet Explorer (IE) and\n-    Netscape Navigator) instead leave all items unselected in these cases.  The\n-    W3C HTML 4.0 standard leaves this behaviour undefined in the case of\n-    multiple-selection SELECT controls, but insists that at least one RADIO\n-    button should be checked at all times, in contradiction to browser\n-    behaviour.\n-\n-    There is a choice of parsers.  ClientForm.XHTMLCompatibleFormParser (uses\n-    HTMLParser.HTMLParser) works best for XHTML, ClientForm.FormParser (uses\n-    sgmllib.SGMLParser) (the default) works better for ordinary grubby HTML.\n-    Note that HTMLParser is only available in Python 2.2 and later.  You can\n-    pass your own class in here as a hack to work around bad HTML, but at your\n-    own risk: there is no well-defined interface.\n-\n-    \"\"\"\n-    return _ParseFileEx(response, response.geturl(), *args, **kwds)[1:]\n-\n-def ParseFile(file, base_uri, *args, **kwds):\n-    \"\"\"Parse HTML and return a list of HTMLForm instances.\n-\n-    ClientForm.ParseError is raised on parse errors.\n-\n-    file: file-like object (supporting read() method) containing HTML with zero\n-     or more forms to be parsed\n-    base_uri: the URI of the document (note that the base URI used to submit\n-     the form will be that given in the BASE element if present, not that of\n-     the document)\n-\n-    For the other arguments and further details, see ParseResponse.__doc__.\n-\n-    \"\"\"\n-    return _ParseFileEx(file, base_uri, *args, **kwds)[1:]\n-\n-def _ParseFileEx(file, base_uri,\n-                 select_default=False,\n-                 ignore_errors=False,\n-                 form_parser_class=FormParser,\n-                 request_class=urllib2.Request,\n-                 entitydefs=None,\n-                 backwards_compat=True,\n-                 encoding=DEFAULT_ENCODING,\n-                 _urljoin=urlparse.urljoin,\n-                 _urlparse=urlparse.urlparse,\n-                 _urlunparse=urlparse.urlunparse,\n-                 ):\n-    if backwards_compat:\n-        deprecation(\"operating in backwards-compatibility mode\", 1)\n-    fp = form_parser_class(entitydefs, encoding)\n-    while 1:\n-        data = file.read(CHUNK)\n-        try:\n-            fp.feed(data)\n-        except ParseError, e:\n-            e.base_uri = base_uri\n-            raise\n-        if len(data) != CHUNK: break\n-    fp.close()\n-    if fp.base is not None:\n-        # HTML BASE element takes precedence over document URI\n-        base_uri = fp.base\n-    labels = []  # Label(label) for label in fp.labels]\n-    id_to_labels = {}\n-    for l in fp.labels:\n-        label = Label(l)\n-        labels.append(label)\n-        for_id = l[\"for\"]\n-        coll = id_to_labels.get(for_id)\n-        if coll is None:\n-            id_to_labels[for_id] = [label]\n-        else:\n-            coll.append(label)\n-    forms = []\n-    for (name, action, method, enctype), attrs, controls in fp.forms:\n-        if action is None:\n-            action = base_uri\n-        else:\n-            action = _urljoin(base_uri, action)\n-        # would be nice to make HTMLForm class (form builder) pluggable\n-        form = HTMLForm(\n-            action, method, enctype, name, attrs, request_class,\n-            forms, labels, id_to_labels, backwards_compat)\n-        form._urlparse = _urlparse\n-        form._urlunparse = _urlunparse\n-        for ii in range(len(controls)):\n-            type, name, attrs = controls[ii]\n-            # index=ii*10 allows ImageControl to return multiple ordered pairs\n-            form.new_control(\n-                type, name, attrs, select_default=select_default, index=ii*10)\n-        forms.append(form)\n-    for form in forms:\n-        form.fixup()\n-    return forms\n-\n-\n-class Label:\n-    def __init__(self, attrs):\n-        self.id = attrs.get(\"for\")\n-        self._text = attrs.get(\"__text\").strip()\n-        self._ctext = compress_text(self._text)\n-        self.attrs = attrs\n-        self._backwards_compat = False  # maintained by HTMLForm\n-\n-    def __getattr__(self, name):\n-        if name == \"text\":\n-            if self._backwards_compat:\n-                return self._text\n-            else:\n-                return self._ctext\n-        return getattr(Label, name)\n-\n-    def __setattr__(self, name, value):\n-        if name == \"text\":\n-            # don't see any need for this, so make it read-only\n-            raise AttributeError(\"text attribute is read-only\")\n-        self.__dict__[name] = value\n-\n-    def __str__(self):\n-        return \"<Label(id=%r, text=%r)>\" % (self.id, self.text)\n-\n-\n-def _get_label(attrs):\n-    text = attrs.get(\"__label\")\n-    if text is not None:\n-        return Label(text)\n-    else:\n-        return None\n-\n-class Control:\n-    \"\"\"An HTML form control.\n-\n-    An HTMLForm contains a sequence of Controls.  The Controls in an HTMLForm\n-    are accessed using the HTMLForm.find_control method or the\n-    HTMLForm.controls attribute.\n-\n-    Control instances are usually constructed using the ParseFile /\n-    ParseResponse functions.  If you use those functions, you can ignore the\n-    rest of this paragraph.  A Control is only properly initialised after the\n-    fixup method has been called.  In fact, this is only strictly necessary for\n-    ListControl instances.  This is necessary because ListControls are built up\n-    from ListControls each containing only a single item, and their initial\n-    value(s) can only be known after the sequence is complete.\n-\n-    The types and values that are acceptable for assignment to the value\n-    attribute are defined by subclasses.\n-\n-    If the disabled attribute is true, this represents the state typically\n-    represented by browsers by 'greying out' a control.  If the disabled\n-    attribute is true, the Control will raise AttributeError if an attempt is\n-    made to change its value.  In addition, the control will not be considered\n-    'successful' as defined by the W3C HTML 4 standard -- ie. it will\n-    contribute no data to the return value of the HTMLForm.click* methods.  To\n-    enable a control, set the disabled attribute to a false value.\n-\n-    If the readonly attribute is true, the Control will raise AttributeError if\n-    an attempt is made to change its value.  To make a control writable, set\n-    the readonly attribute to a false value.\n-\n-    All controls have the disabled and readonly attributes, not only those that\n-    may have the HTML attributes of the same names.\n-\n-    On assignment to the value attribute, the following exceptions are raised:\n-    TypeError, AttributeError (if the value attribute should not be assigned\n-    to, because the control is disabled, for example) and ValueError.\n-\n-    If the name or value attributes are None, or the value is an empty list, or\n-    if the control is disabled, the control is not successful.\n-\n-    Public attributes:\n-\n-    type: string describing type of control (see the keys of the\n-     HTMLForm.type2class dictionary for the allowable values) (readonly)\n-    name: name of control (readonly)\n-    value: current value of control (subclasses may allow a single value, a\n-     sequence of values, or either)\n-    disabled: disabled state\n-    readonly: readonly state\n-    id: value of id HTML attribute\n-\n-    \"\"\"\n-    def __init__(self, type, name, attrs, index=None):\n-        \"\"\"\n-        type: string describing type of control (see the keys of the\n-         HTMLForm.type2class dictionary for the allowable values)\n-        name: control name\n-        attrs: HTML attributes of control's HTML element\n-\n-        \"\"\"\n-        raise NotImplementedError()\n-\n-    def add_to_form(self, form):\n-        self._form = form\n-        form.controls.append(self)\n-\n-    def fixup(self):\n-        pass\n-\n-    def is_of_kind(self, kind):\n-        raise NotImplementedError()\n-\n-    def clear(self):\n-        raise NotImplementedError()\n-\n-    def __getattr__(self, name): raise NotImplementedError()\n-    def __setattr__(self, name, value): raise NotImplementedError()\n-\n-    def pairs(self):\n-        \"\"\"Return list of (key, value) pairs suitable for passing to urlencode.\n-        \"\"\"\n-        return [(k, v) for (i, k, v) in self._totally_ordered_pairs()]\n-\n-    def _totally_ordered_pairs(self):\n-        \"\"\"Return list of (key, value, index) tuples.\n-\n-        Like pairs, but allows preserving correct ordering even where several\n-        controls are involved.\n-\n-        \"\"\"\n-        raise NotImplementedError()\n-\n-    def _write_mime_data(self, mw, name, value):\n-        \"\"\"Write data for a subitem of this control to a MimeWriter.\"\"\"\n-        # called by HTMLForm\n-        mw2 = mw.nextpart()\n-        mw2.addheader(\"Content-Disposition\",\n-                      'form-data; name=\"%s\"' % name, 1)\n-        f = mw2.startbody(prefix=0)\n-        f.write(value)\n-\n-    def __str__(self):\n-        raise NotImplementedError()\n-\n-    def get_labels(self):\n-        \"\"\"Return all labels (Label instances) for this control.\n-        \n-        If the control was surrounded by a <label> tag, that will be the first\n-        label; all other labels, connected by 'for' and 'id', are in the order\n-        that appear in the HTML.\n-\n-        \"\"\"\n-        res = []\n-        if self._label:\n-            res.append(self._label)\n-        if self.id:\n-            res.extend(self._form._id_to_labels.get(self.id, ()))\n-        return res\n-\n-\n-#---------------------------------------------------\n-class ScalarControl(Control):\n-    \"\"\"Control whose value is not restricted to one of a prescribed set.\n-\n-    Some ScalarControls don't accept any value attribute.  Otherwise, takes a\n-    single value, which must be string-like.\n-\n-    Additional read-only public attribute:\n-\n-    attrs: dictionary mapping the names of original HTML attributes of the\n-     control to their values\n-\n-    \"\"\"\n-    def __init__(self, type, name, attrs, index=None):\n-        self._index = index\n-        self._label = _get_label(attrs)\n-        self.__dict__[\"type\"] = type.lower()\n-        self.__dict__[\"name\"] = name\n-        self._value = attrs.get(\"value\")\n-        self.disabled = attrs.has_key(\"disabled\")\n-        self.readonly = attrs.has_key(\"readonly\")\n-        self.id = attrs.get(\"id\")\n-\n-        self.attrs = attrs.copy()\n-\n-        self._clicked = False\n-\n-        self._urlparse = urlparse.urlparse\n-        self._urlunparse = urlparse.urlunparse\n-\n-    def __getattr__(self, name):\n-        if name == \"value\":\n-            return self.__dict__[\"_value\"]\n-        else:\n-            raise AttributeError(\"%s instance has no attribute '%s'\" %\n-                                 (self.__class__.__name__, name))\n-\n-    def __setattr__(self, name, value):\n-        if name == \"value\":\n-            if not isstringlike(value):\n-                raise TypeError(\"must assign a string\")\n-            elif self.readonly:\n-                raise AttributeError(\"control '%s' is readonly\" % self.name)\n-            elif self.disabled:\n-                raise AttributeError(\"control '%s' is disabled\" % self.name)\n-            self.__dict__[\"_value\"] = value\n-        elif name in (\"name\", \"type\"):\n-            raise AttributeError(\"%s attribute is readonly\" % name)\n-        else:\n-            self.__dict__[name] = value\n-\n-    def _totally_ordered_pairs(self):\n-        name = self.name\n-        value = self.value\n-        if name is None or value is None or self.disabled:\n-            return []\n-        return [(self._index, name, value)]\n-\n-    def clear(self):\n-        if self.readonly:\n-            raise AttributeError(\"control '%s' is readonly\" % self.name)\n-        self.__dict__[\"_value\"] = None\n-\n-    def __str__(self):\n-        name = self.name\n-        value = self.value\n-        if name is None: name = \"<None>\"\n-        if value is None: value = \"<None>\"\n-\n-        infos = []\n-        if self.disabled: infos.append(\"disabled\")\n-        if self.readonly: infos.append(\"readonly\")\n-        info = \", \".join(infos)\n-        if info: info = \" (%s)\" % info\n-\n-        return \"<%s(%s=%s)%s>\" % (self.__class__.__name__, name, value, info)\n-\n-\n-#---------------------------------------------------\n-class TextControl(ScalarControl):\n-    \"\"\"Textual input control.\n-\n-    Covers:\n-\n-    INPUT/TEXT\n-    INPUT/PASSWORD\n-    INPUT/HIDDEN\n-    TEXTAREA\n-\n-    \"\"\"\n-    def __init__(self, type, name, attrs, index=None):\n-        ScalarControl.__init__(self, type, name, attrs, index)\n-        if self.type == \"hidden\": self.readonly = True\n-        if self._value is None:\n-            self._value = \"\"\n-\n-    def is_of_kind(self, kind): return kind == \"text\"\n-\n-#---------------------------------------------------\n-class FileControl(ScalarControl):\n-    \"\"\"File upload with INPUT TYPE=FILE.\n-\n-    The value attribute of a FileControl is always None.  Use add_file instead.\n-\n-    Additional public method: add_file\n-\n-    \"\"\"\n-\n-    def __init__(self, type, name, attrs, index=None):\n-        ScalarControl.__init__(self, type, name, attrs, index)\n-        self._value = None\n-        self._upload_data = []\n-\n-    def is_of_kind(self, kind): return kind == \"file\"\n-\n-    def clear(self):\n-        if self.readonly:\n-            raise AttributeError(\"control '%s' is readonly\" % self.name)\n-        self._upload_data = []\n-\n-    def __setattr__(self, name, value):\n-        if name in (\"value\", \"name\", \"type\"):\n-            raise AttributeError(\"%s attribute is readonly\" % name)\n-        else:\n-            self.__dict__[name] = value\n-\n-    def add_file(self, file_object, content_type=None, filename=None):\n-        if not hasattr(file_object, \"read\"):\n-            raise TypeError(\"file-like object must have read method\")\n-        if content_type is not None and not isstringlike(content_type):\n-            raise TypeError(\"content type must be None or string-like\")\n-        if filename is not None and not isstringlike(filename):\n-            raise TypeError(\"filename must be None or string-like\")\n-        if content_type is None:\n-            content_type = \"application/octet-stream\"\n-        self._upload_data.append((file_object, content_type, filename))\n-\n-    def _totally_ordered_pairs(self):\n-        # XXX should it be successful even if unnamed?\n-        if self.name is None or self.disabled:\n-            return []\n-        return [(self._index, self.name, \"\")]\n-\n-    def _write_mime_data(self, mw, _name, _value):\n-        # called by HTMLForm\n-        # assert _name == self.name and _value == ''\n-        if len(self._upload_data) < 2:\n-            if len(self._upload_data) == 0:\n-                file_object = StringIO()\n-                content_type = \"application/octet-stream\"\n-                filename = \"\"\n-            else:\n-                file_object, content_type, filename = self._upload_data[0]\n-                if filename is None:\n-                    filename = \"\"\n-            mw2 = mw.nextpart()\n-            fn_part = '; filename=\"%s\"' % filename\n-            disp = 'form-data; name=\"%s\"%s' % (self.name, fn_part)\n-            mw2.addheader(\"Content-Disposition\", disp, prefix=1)\n-            fh = mw2.startbody(content_type, prefix=0)\n-            fh.write(file_object.read())\n-        else:\n-            # multiple files\n-            mw2 = mw.nextpart()\n-            disp = 'form-data; name=\"%s\"' % self.name\n-            mw2.addheader(\"Content-Disposition\", disp, prefix=1)\n-            fh = mw2.startmultipartbody(\"mixed\", prefix=0)\n-            for file_object, content_type, filename in self._upload_data:\n-                mw3 = mw2.nextpart()\n-                if filename is None:\n-                    filename = \"\"\n-                fn_part = '; filename=\"%s\"' % filename\n-                disp = \"file%s\" % fn_part\n-                mw3.addheader(\"Content-Disposition\", disp, prefix=1)\n-                fh2 = mw3.startbody(content_type, prefix=0)\n-                fh2.write(file_object.read())\n-            mw2.lastpart()\n-\n-    def __str__(self):\n-        name = self.name\n-        if name is None: name = \"<None>\"\n-\n-        if not self._upload_data:\n-            value = \"<No files added>\"\n-        else:\n-            value = []\n-            for file, ctype, filename in self._upload_data:\n-                if filename is None:\n-                    value.append(\"<Unnamed file>\")\n-                else:\n-                    value.append(filename)\n-            value = \", \".join(value)\n-\n-        info = []\n-        if self.disabled: info.append(\"disabled\")\n-        if self.readonly: info.append(\"readonly\")\n-        info = \", \".join(info)\n-        if info: info = \" (%s)\" % info\n-\n-        return \"<%s(%s=%s)%s>\" % (self.__class__.__name__, name, value, info)\n-\n-\n-#---------------------------------------------------\n-class IsindexControl(ScalarControl):\n-    \"\"\"ISINDEX control.\n-\n-    ISINDEX is the odd-one-out of HTML form controls.  In fact, it isn't really\n-    part of regular HTML forms at all, and predates it.  You're only allowed\n-    one ISINDEX per HTML document.  ISINDEX and regular form submission are\n-    mutually exclusive -- either submit a form, or the ISINDEX.\n-\n-    Having said this, since ISINDEX controls may appear in forms (which is\n-    probably bad HTML), ParseFile / ParseResponse will include them in the\n-    HTMLForm instances it returns.  You can set the ISINDEX's value, as with\n-    any other control (but note that ISINDEX controls have no name, so you'll\n-    need to use the type argument of set_value!).  When you submit the form,\n-    the ISINDEX will not be successful (ie., no data will get returned to the\n-    server as a result of its presence), unless you click on the ISINDEX\n-    control, in which case the ISINDEX gets submitted instead of the form:\n-\n-    form.set_value(\"my isindex value\", type=\"isindex\")\n-    urllib2.urlopen(form.click(type=\"isindex\"))\n-\n-    ISINDEX elements outside of FORMs are ignored.  If you want to submit one\n-    by hand, do it like so:\n-\n-    url = urlparse.urljoin(page_uri, \"?\"+urllib.quote_plus(\"my isindex value\"))\n-    result = urllib2.urlopen(url)\n-\n-    \"\"\"\n-    def __init__(self, type, name, attrs, index=None):\n-        ScalarControl.__init__(self, type, name, attrs, index)\n-        if self._value is None:\n-            self._value = \"\"\n-\n-    def is_of_kind(self, kind): return kind in [\"text\", \"clickable\"]\n-\n-    def _totally_ordered_pairs(self):\n-        return []\n-\n-    def _click(self, form, coord, return_type, request_class=urllib2.Request):\n-        # Relative URL for ISINDEX submission: instead of \"foo=bar+baz\",\n-        # want \"bar+baz\".\n-        # This doesn't seem to be specified in HTML 4.01 spec. (ISINDEX is\n-        # deprecated in 4.01, but it should still say how to submit it).\n-        # Submission of ISINDEX is explained in the HTML 3.2 spec, though.\n-        parts = self._urlparse(form.action)\n-        rest, (query, frag) = parts[:-2], parts[-2:]\n-        parts = rest + (urllib.quote_plus(self.value), None)\n-        url = self._urlunparse(parts)\n-        req_data = url, None, []\n-\n-        if return_type == \"pairs\":\n-            return []\n-        elif return_type == \"request_data\":\n-            return req_data\n-        else:\n-            return request_class(url)\n-\n-    def __str__(self):\n-        value = self.value\n-        if value is None: value = \"<None>\"\n-\n-        infos = []\n-        if self.disabled: infos.append(\"disabled\")\n-        if self.readonly: infos.append(\"readonly\")\n-        info = \", \".join(infos)\n-        if info: info = \" (%s)\" % info\n-\n-        return \"<%s(%s)%s>\" % (self.__class__.__name__, value, info)\n-\n-\n-#---------------------------------------------------\n-class IgnoreControl(ScalarControl):\n-    \"\"\"Control that we're not interested in.\n-\n-    Covers:\n-\n-    INPUT/RESET\n-    BUTTON/RESET\n-    INPUT/BUTTON\n-    BUTTON/BUTTON\n-\n-    These controls are always unsuccessful, in the terminology of HTML 4 (ie.\n-    they never require any information to be returned to the server).\n-\n-    BUTTON/BUTTON is used to generate events for script embedded in HTML.\n-\n-    The value attribute of IgnoreControl is always None.\n-\n-    \"\"\"\n-    def __init__(self, type, name, attrs, index=None):\n-        ScalarControl.__init__(self, type, name, attrs, index)\n-        self._value = None\n-\n-    def is_of_kind(self, kind): return False\n-\n-    def __setattr__(self, name, value):\n-        if name == \"value\":\n-            raise AttributeError(\n-                \"control '%s' is ignored, hence read-only\" % self.name)\n-        elif name in (\"name\", \"type\"):\n-            raise AttributeError(\"%s attribute is readonly\" % name)\n-        else:\n-            self.__dict__[name] = value\n-\n-\n-#---------------------------------------------------\n-# ListControls\n-\n-# helpers and subsidiary classes\n-\n-class Item:\n-    def __init__(self, control, attrs, index=None):\n-        label = _get_label(attrs)\n-        self.__dict__.update({\n-            \"name\": attrs[\"value\"],\n-            \"_labels\": label and [label] or [],\n-            \"attrs\": attrs,\n-            \"_control\": control,\n-            \"disabled\": attrs.has_key(\"disabled\"),\n-            \"_selected\": False,\n-            \"id\": attrs.get(\"id\"),\n-            \"_index\": index,\n-            })\n-        control.items.append(self)\n-\n-    def get_labels(self):\n-        \"\"\"Return all labels (Label instances) for this item.\n-        \n-        For items that represent radio buttons or checkboxes, if the item was\n-        surrounded by a <label> tag, that will be the first label; all other\n-        labels, connected by 'for' and 'id', are in the order that appear in\n-        the HTML.\n-        \n-        For items that represent select options, if the option had a label\n-        attribute, that will be the first label.  If the option has contents\n-        (text within the option tags) and it is not the same as the label\n-        attribute (if any), that will be a label.  There is nothing in the\n-        spec to my knowledge that makes an option with an id unable to be the\n-        target of a label's for attribute, so those are included, if any, for\n-        the sake of consistency and completeness.\n-\n-        \"\"\"\n-        res = []\n-        res.extend(self._labels)\n-        if self.id:\n-            res.extend(self._control._form._id_to_labels.get(self.id, ()))\n-        return res\n-\n-    def __getattr__(self, name):\n-        if name==\"selected\":\n-            return self._selected\n-        raise AttributeError(name)\n-\n-    def __setattr__(self, name, value):\n-        if name == \"selected\":\n-            self._control._set_selected_state(self, value)\n-        elif name == \"disabled\":\n-            self.__dict__[\"disabled\"] = bool(value)\n-        else:\n-            raise AttributeError(name)\n-\n-    def __str__(self):\n-        res = self.name\n-        if self.selected:\n-            res = \"*\" + res\n-        if self.disabled:\n-            res = \"(%s)\" % res\n-        return res\n-\n-    def __repr__(self):\n-        # XXX appending the attrs without distinguishing them from name and id\n-        # is silly\n-        attrs = [(\"name\", self.name), (\"id\", self.id)]+self.attrs.items()\n-        return \"<%s %s>\" % (\n-            self.__class__.__name__,\n-            \" \".join([\"%s=%r\" % (k, v) for k, v in attrs])\n-            )\n-\n-def disambiguate(items, nr, **kwds):\n-    msgs = []\n-    for key, value in kwds.items():\n-        msgs.append(\"%s=%r\" % (key, value))\n-    msg = \" \".join(msgs)\n-    if not items:\n-        raise ItemNotFoundError(msg)\n-    if nr is None:\n-        if len(items) > 1:\n-            raise AmbiguityError(msg)\n-        nr = 0\n-    if len(items) <= nr:\n-        raise ItemNotFoundError(msg)\n-    return items[nr]\n-\n-class ListControl(Control):\n-    \"\"\"Control representing a sequence of items.\n-\n-    The value attribute of a ListControl represents the successful list items\n-    in the control.  The successful list items are those that are selected and\n-    not disabled.\n-\n-    ListControl implements both list controls that take a length-1 value\n-    (single-selection) and those that take length >1 values\n-    (multiple-selection).\n-\n-    ListControls accept sequence values only.  Some controls only accept\n-    sequences of length 0 or 1 (RADIO, and single-selection SELECT).\n-    In those cases, ItemCountError is raised if len(sequence) > 1.  CHECKBOXes\n-    and multiple-selection SELECTs (those having the \"multiple\" HTML attribute)\n-    accept sequences of any length.\n-\n-    Note the following mistake:\n-\n-    control.value = some_value\n-    assert control.value == some_value    # not necessarily true\n-\n-    The reason for this is that the value attribute always gives the list items\n-    in the order they were listed in the HTML.\n-\n-    ListControl items can also be referred to by their labels instead of names.\n-    Use the label argument to .get(), and the .set_value_by_label(),\n-    .get_value_by_label() methods.\n-\n-    Note that, rather confusingly, though SELECT controls are represented in\n-    HTML by SELECT elements (which contain OPTION elements, representing\n-    individual list items), CHECKBOXes and RADIOs are not represented by *any*\n-    element.  Instead, those controls are represented by a collection of INPUT\n-    elements.  For example, this is a SELECT control, named \"control1\":\n-\n-    <select name=\"control1\">\n-     <option>foo</option>\n-     <option value=\"1\">bar</option>\n-    </select>\n-\n-    and this is a CHECKBOX control, named \"control2\":\n-\n-    <input type=\"checkbox\" name=\"control2\" value=\"foo\" id=\"cbe1\">\n-    <input type=\"checkbox\" name=\"control2\" value=\"bar\" id=\"cbe2\">\n-\n-    The id attribute of a CHECKBOX or RADIO ListControl is always that of its\n-    first element (for example, \"cbe1\" above).\n-\n-\n-    Additional read-only public attribute: multiple.\n-\n-    \"\"\"\n-\n-    # ListControls are built up by the parser from their component items by\n-    # creating one ListControl per item, consolidating them into a single\n-    # master ListControl held by the HTMLForm:\n-\n-    # -User calls form.new_control(...)\n-    # -Form creates Control, and calls control.add_to_form(self).\n-    # -Control looks for a Control with the same name and type in the form,\n-    #  and if it finds one, merges itself with that control by calling\n-    #  control.merge_control(self).  The first Control added to the form, of\n-    #  a particular name and type, is the only one that survives in the\n-    #  form.\n-    # -Form calls control.fixup for all its controls.  ListControls in the\n-    #  form know they can now safely pick their default values.\n-\n-    # To create a ListControl without an HTMLForm, use:\n-\n-    # control.merge_control(new_control)\n-\n-    # (actually, it's much easier just to use ParseFile)\n-\n-    _label = None\n-\n-    def __init__(self, type, name, attrs={}, select_default=False,\n-                 called_as_base_class=False, index=None):\n-        \"\"\"\n-        select_default: for RADIO and multiple-selection SELECT controls, pick\n-         the first item as the default if no 'selected' HTML attribute is\n-         present\n-\n-        \"\"\"\n-        if not called_as_base_class:\n-            raise NotImplementedError()\n-\n-        self.__dict__[\"type\"] = type.lower()\n-        self.__dict__[\"name\"] = name\n-        self._value = attrs.get(\"value\")\n-        self.disabled = False\n-        self.readonly = False\n-        self.id = attrs.get(\"id\")\n-        self._closed = False\n-\n-        # As Controls are merged in with .merge_control(), self.attrs will\n-        # refer to each Control in turn -- always the most recently merged\n-        # control.  Each merged-in Control instance corresponds to a single\n-        # list item: see ListControl.__doc__.\n-        self.items = []\n-        self._form = None\n-\n-        self._select_default = select_default\n-        self._clicked = False\n-\n-    def clear(self):\n-        self.value = []\n-\n-    def is_of_kind(self, kind):\n-        if kind  == \"list\":\n-            return True\n-        elif kind == \"multilist\":\n-            return bool(self.multiple)\n-        elif kind == \"singlelist\":\n-            return not self.multiple\n-        else:\n-            return False\n-\n-    def get_items(self, name=None, label=None, id=None,\n-                  exclude_disabled=False):\n-        \"\"\"Return matching items by name or label.\n-\n-        For argument docs, see the docstring for .get()\n-\n-        \"\"\"\n-        if name is not None and not isstringlike(name):\n-            raise TypeError(\"item name must be string-like\")\n-        if label is not None and not isstringlike(label):\n-            raise TypeError(\"item label must be string-like\")\n-        if id is not None and not isstringlike(id):\n-            raise TypeError(\"item id must be string-like\")\n-        items = []  # order is important\n-        compat = self._form.backwards_compat\n-        for o in self.items:\n-            if exclude_disabled and o.disabled:\n-                continue\n-            if name is not None and o.name != name:\n-                continue\n-            if label is not None:\n-                for l in o.get_labels():\n-                    if ((compat and l.text == label) or\n-                        (not compat and l.text.find(label) > -1)):\n-                        break\n-                else:\n-                    continue\n-            if id is not None and o.id != id:\n-                continue\n-            items.append(o)\n-        return items\n-\n-    def get(self, name=None, label=None, id=None, nr=None,\n-            exclude_disabled=False):\n-        \"\"\"Return item by name or label, disambiguating if necessary with nr.\n-\n-        All arguments must be passed by name, with the exception of 'name',\n-        which may be used as a positional argument.\n-\n-        If name is specified, then the item must have the indicated name.\n-\n-        If label is specified, then the item must have a label whose\n-        whitespace-compressed, stripped, text substring-matches the indicated\n-        label string (eg. label=\"please choose\" will match\n-        \"  Do  please  choose an item \").\n-\n-        If id is specified, then the item must have the indicated id.\n-\n-        nr is an optional 0-based index of the items matching the query.\n-\n-        If nr is the default None value and more than item is found, raises\n-        AmbiguityError (unless the HTMLForm instance's backwards_compat\n-        attribute is true).\n-\n-        If no item is found, or if items are found but nr is specified and not\n-        found, raises ItemNotFoundError.\n-\n-        Optionally excludes disabled items.\n-\n-        \"\"\"\n-        if nr is None and self._form.backwards_compat:\n-            nr = 0  # :-/\n-        items = self.get_items(name, label, id, exclude_disabled)\n-        return disambiguate(items, nr, name=name, label=label, id=id)\n-\n-    def _get(self, name, by_label=False, nr=None, exclude_disabled=False):\n-        # strictly for use by deprecated methods\n-        if by_label:\n-            name, label = None, name\n-        else:\n-            name, label = name, None\n-        return self.get(name, label, nr, exclude_disabled)\n-\n-    def toggle(self, name, by_label=False, nr=None):\n-        \"\"\"Deprecated: given a name or label and optional disambiguating index\n-        nr, toggle the matching item's selection.\n-\n-        Selecting items follows the behavior described in the docstring of the\n-        'get' method.\n-\n-        if the item is disabled, or this control is disabled or readonly,\n-        raise AttributeError.\n-\n-        \"\"\"\n-        deprecation(\n-            \"item = control.get(...); item.selected = not item.selected\")\n-        o = self._get(name, by_label, nr)\n-        self._set_selected_state(o, not o.selected)\n-\n-    def set(self, selected, name, by_label=False, nr=None):\n-        \"\"\"Deprecated: given a name or label and optional disambiguating index\n-        nr, set the matching item's selection to the bool value of selected.\n-\n-        Selecting items follows the behavior described in the docstring of the\n-        'get' method.\n-\n-        if the item is disabled, or this control is disabled or readonly,\n-        raise AttributeError.\n-\n-        \"\"\"\n-        deprecation(\n-            \"control.get(...).selected = <boolean>\")\n-        self._set_selected_state(self._get(name, by_label, nr), selected)\n-\n-    def _set_selected_state(self, item, action):\n-        # action:\n-        # bool False: off\n-        # bool True: on\n-        if self.disabled:\n-            raise AttributeError(\"control '%s' is disabled\" % self.name)\n-        if self.readonly:\n-            raise AttributeError(\"control '%s' is readonly\" % self.name)\n-        action == bool(action)\n-        compat = self._form.backwards_compat\n-        if not compat and item.disabled:\n-            raise AttributeError(\"item is disabled\")\n-        else:\n-            if compat and item.disabled and action:\n-                raise AttributeError(\"item is disabled\")\n-            if self.multiple:\n-                item.__dict__[\"_selected\"] = action\n-            else:\n-                if not action:\n-                    item.__dict__[\"_selected\"] = False\n-                else:\n-                    for o in self.items:\n-                        o.__dict__[\"_selected\"] = False\n-                    item.__dict__[\"_selected\"] = True\n-\n-    def toggle_single(self, by_label=None):\n-        \"\"\"Deprecated: toggle the selection of the single item in this control.\n-        \n-        Raises ItemCountError if the control does not contain only one item.\n-        \n-        by_label argument is ignored, and included only for backwards\n-        compatibility.\n-\n-        \"\"\"\n-        deprecation(\n-            \"control.items[0].selected = not control.items[0].selected\")\n-        if len(self.items) != 1:\n-            raise ItemCountError(\n-                \"'%s' is not a single-item control\" % self.name)\n-        item = self.items[0]\n-        self._set_selected_state(item, not item.selected)\n-\n-    def set_single(self, selected, by_label=None):\n-        \"\"\"Deprecated: set the selection of the single item in this control.\n-        \n-        Raises ItemCountError if the control does not contain only one item.\n-        \n-        by_label argument is ignored, and included only for backwards\n-        compatibility.\n-\n-        \"\"\"\n-        deprecation(\n-            \"control.items[0].selected = <boolean>\")\n-        if len(self.items) != 1:\n-            raise ItemCountError(\n-                \"'%s' is not a single-item control\" % self.name)\n-        self._set_selected_state(self.items[0], selected)\n-\n-    def get_item_disabled(self, name, by_label=False, nr=None):\n-        \"\"\"Get disabled state of named list item in a ListControl.\"\"\"\n-        deprecation(\n-            \"control.get(...).disabled\")\n-        return self._get(name, by_label, nr).disabled\n-\n-    def set_item_disabled(self, disabled, name, by_label=False, nr=None):\n-        \"\"\"Set disabled state of named list item in a ListControl.\n-\n-        disabled: boolean disabled state\n-\n-        \"\"\"\n-        deprecation(\n-            \"control.get(...).disabled = <boolean>\")\n-        self._get(name, by_label, nr).disabled = disabled\n-\n-    def set_all_items_disabled(self, disabled):\n-        \"\"\"Set disabled state of all list items in a ListControl.\n-\n-        disabled: boolean disabled state\n-\n-        \"\"\"\n-        for o in self.items:\n-            o.disabled = disabled\n-\n-    def get_item_attrs(self, name, by_label=False, nr=None):\n-        \"\"\"Return dictionary of HTML attributes for a single ListControl item.\n-\n-        The HTML element types that describe list items are: OPTION for SELECT\n-        controls, INPUT for the rest.  These elements have HTML attributes that\n-        you may occasionally want to know about -- for example, the \"alt\" HTML\n-        attribute gives a text string describing the item (graphical browsers\n-        usually display this as a tooltip).\n-\n-        The returned dictionary maps HTML attribute names to values.  The names\n-        and values are taken from the original HTML.\n-\n-        \"\"\"\n-        deprecation(\n-            \"control.get(...).attrs\")\n-        return self._get(name, by_label, nr).attrs\n-\n-    def close_control(self):\n-        self._closed = True\n-\n-    def add_to_form(self, form):\n-        assert self._form is None or form == self._form, (\n-            \"can't add control to more than one form\")\n-        self._form = form\n-        if self.name is None:\n-            # always count nameless elements as separate controls\n-            Control.add_to_form(self, form)\n-        else:\n-            for ii in range(len(form.controls)-1, -1, -1):\n-                control = form.controls[ii]\n-                if control.name == self.name and control.type == self.type:\n-                    if control._closed:\n-                        Control.add_to_form(self, form)\n-                    else:\n-                        control.merge_control(self)\n-                    break\n-            else:\n-                Control.add_to_form(self, form)\n-\n-    def merge_control(self, control):\n-        assert bool(control.multiple) == bool(self.multiple)\n-        # usually, isinstance(control, self.__class__)\n-        self.items.extend(control.items)\n-\n-    def fixup(self):\n-        \"\"\"\n-        ListControls are built up from component list items (which are also\n-        ListControls) during parsing.  This method should be called after all\n-        items have been added.  See ListControl.__doc__ for the reason this is\n-        required.\n-\n-        \"\"\"\n-        # Need to set default selection where no item was indicated as being\n-        # selected by the HTML:\n-\n-        # CHECKBOX:\n-        #  Nothing should be selected.\n-        # SELECT/single, SELECT/multiple and RADIO:\n-        #  RFC 1866 (HTML 2.0): says first item should be selected.\n-        #  W3C HTML 4.01 Specification: says that client behaviour is\n-        #   undefined in this case.  For RADIO, exactly one must be selected,\n-        #   though which one is undefined.\n-        #  Both Netscape and Microsoft Internet Explorer (IE) choose first\n-        #   item for SELECT/single.  However, both IE5 and Mozilla (both 1.0\n-        #   and Firebird 0.6) leave all items unselected for RADIO and\n-        #   SELECT/multiple.\n-\n-        # Since both Netscape and IE all choose the first item for\n-        # SELECT/single, we do the same.  OTOH, both Netscape and IE\n-        # leave SELECT/multiple with nothing selected, in violation of RFC 1866\n-        # (but not in violation of the W3C HTML 4 standard); the same is true\n-        # of RADIO (which *is* in violation of the HTML 4 standard).  We follow\n-        # RFC 1866 if the _select_default attribute is set, and Netscape and IE\n-        # otherwise.  RFC 1866 and HTML 4 are always violated insofar as you\n-        # can deselect all items in a RadioControl.\n-        \n-        for o in self.items: \n-            # set items' controls to self, now that we've merged\n-            o.__dict__[\"_control\"] = self\n-\n-    def __getattr__(self, name):\n-        if name == \"value\":\n-            compat = self._form.backwards_compat\n-            if self.name is None:\n-                return []\n-            return [o.name for o in self.items if o.selected and\n-                    (not o.disabled or compat)]\n-        else:\n-            raise AttributeError(\"%s instance has no attribute '%s'\" %\n-                                 (self.__class__.__name__, name))\n-\n-    def __setattr__(self, name, value):\n-        if name == \"value\":\n-            if self.disabled:\n-                raise AttributeError(\"control '%s' is disabled\" % self.name)\n-            if self.readonly:\n-                raise AttributeError(\"control '%s' is readonly\" % self.name)\n-            self._set_value(value)\n-        elif name in (\"name\", \"type\", \"multiple\"):\n-            raise AttributeError(\"%s attribute is readonly\" % name)\n-        else:\n-            self.__dict__[name] = value\n-\n-    def _set_value(self, value):\n-        if value is None or isstringlike(value):\n-            raise TypeError(\"ListControl, must set a sequence\")\n-        if not value:\n-            compat = self._form.backwards_compat\n-            for o in self.items:\n-                if not o.disabled or compat:\n-                    o.selected = False\n-        elif self.multiple:\n-            self._multiple_set_value(value)\n-        elif len(value) > 1:\n-            raise ItemCountError(\n-                \"single selection list, must set sequence of \"\n-                \"length 0 or 1\")\n-        else:\n-            self._single_set_value(value)\n-\n-    def _get_items(self, name, target=1):\n-        all_items = self.get_items(name)\n-        items = [o for o in all_items if not o.disabled]\n-        if len(items) < target:\n-            if len(all_items) < target:\n-                raise ItemNotFoundError(\n-                    \"insufficient items with name %r\" % name)\n-            else:\n-                raise AttributeError(\n-                    \"insufficient non-disabled items with name %s\" % name)\n-        on = []\n-        off = []\n-        for o in items:\n-            if o.selected:\n-                on.append(o)\n-            else:\n-                off.append(o)\n-        return on, off\n-\n-    def _single_set_value(self, value):\n-        assert len(value) == 1\n-        on, off = self._get_items(value[0])\n-        assert len(on) <= 1\n-        if not on:\n-            off[0].selected = True\n-\n-    def _multiple_set_value(self, value):\n-        compat = self._form.backwards_compat\n-        turn_on = []  # transactional-ish\n-        turn_off = [item for item in self.items if\n-                    item.selected and (not item.disabled or compat)]\n-        names = {}\n-        for nn in value:\n-            if nn in names.keys():\n-                names[nn] += 1\n-            else:\n-                names[nn] = 1\n-        for name, count in names.items():\n-            on, off = self._get_items(name, count)\n-            for i in range(count):\n-                if on:\n-                    item = on[0]\n-                    del on[0]\n-                    del turn_off[turn_off.index(item)]\n-                else:\n-                    item = off[0]\n-                    del off[0]\n-                    turn_on.append(item)\n-        for item in turn_off:\n-            item.selected = False\n-        for item in turn_on:\n-            item.selected = True\n-\n-    def set_value_by_label(self, value):\n-        \"\"\"Set the value of control by item labels.\n-\n-        value is expected to be an iterable of strings that are substrings of\n-        the item labels that should be selected.  Before substring matching is\n-        performed, the original label text is whitespace-compressed\n-        (consecutive whitespace characters are converted to a single space\n-        character) and leading and trailing whitespace is stripped.  Ambiguous\n-        labels are accepted without complaint if the form's backwards_compat is\n-        True; otherwise, it will not complain as long as all ambiguous labels\n-        share the same item name (e.g. OPTION value).\n-\n-        \"\"\"\n-        if isstringlike(value):\n-            raise TypeError(value)\n-        if not self.multiple and len(value) > 1:\n-            raise ItemCountError(\n-                \"single selection list, must set sequence of \"\n-                \"length 0 or 1\")\n-        items = []\n-        for nn in value:\n-            found = self.get_items(label=nn)\n-            if len(found) > 1:\n-                if not self._form.backwards_compat:\n-                    # ambiguous labels are fine as long as item names (e.g.\n-                    # OPTION values) are same\n-                    opt_name = found[0].name\n-                    if [o for o in found[1:] if o.name != opt_name]:\n-                        raise AmbiguityError(nn)\n-                else:\n-                    # OK, we'll guess :-(  Assume first available item.\n-                    found = found[:1]\n-            for o in found:\n-                # For the multiple-item case, we could try to be smarter,\n-                # saving them up and trying to resolve, but that's too much.\n-                if self._form.backwards_compat or o not in items:\n-                    items.append(o)\n-                    break\n-            else:  # all of them are used\n-                raise ItemNotFoundError(nn)\n-        # now we have all the items that should be on\n-        # let's just turn everything off and then back on.\n-        self.value = []\n-        for o in items:\n-            o.selected = True\n-\n-    def get_value_by_label(self):\n-        \"\"\"Return the value of the control as given by normalized labels.\"\"\"\n-        res = []\n-        compat = self._form.backwards_compat\n-        for o in self.items:\n-            if (not o.disabled or compat) and o.selected:\n-                for l in o.get_labels():\n-                    if l.text:\n-                        res.append(l.text)\n-                        break\n-                else:\n-                    res.append(None)\n-        return res\n-\n-    def possible_items(self, by_label=False):\n-        \"\"\"Deprecated: return the names or labels of all possible items.\n-\n-        Includes disabled items, which may be misleading for some use cases.\n-\n-        \"\"\"\n-        deprecation(\n-            \"[item.name for item in self.items]\")\n-        if by_label:\n-            res = []\n-            for o in self.items:\n-                for l in o.get_labels():\n-                    if l.text:\n-                        res.append(l.text)\n-                        break\n-                else:\n-                    res.append(None)\n-            return res\n-        return [o.name for o in self.items]\n-\n-    def _totally_ordered_pairs(self):\n-        if self.disabled or self.name is None:\n-            return []\n-        else:\n-            return [(o._index, self.name, o.name) for o in self.items\n-                    if o.selected and not o.disabled]\n-\n-    def __str__(self):\n-        name = self.name\n-        if name is None: name = \"<None>\"\n-\n-        display = [str(o) for o in self.items]\n-\n-        infos = []\n-        if self.disabled: infos.append(\"disabled\")\n-        if self.readonly: infos.append(\"readonly\")\n-        info = \", \".join(infos)\n-        if info: info = \" (%s)\" % info\n-\n-        return \"<%s(%s=[%s])%s>\" % (self.__class__.__name__,\n-                                    name, \", \".join(display), info)\n-\n-\n-class RadioControl(ListControl):\n-    \"\"\"\n-    Covers:\n-\n-    INPUT/RADIO\n-\n-    \"\"\"\n-    def __init__(self, type, name, attrs, select_default=False, index=None):\n-        attrs.setdefault(\"value\", \"on\")\n-        ListControl.__init__(self, type, name, attrs, select_default,\n-                             called_as_base_class=True, index=index)\n-        self.__dict__[\"multiple\"] = False\n-        o = Item(self, attrs, index)\n-        o.__dict__[\"_selected\"] = attrs.has_key(\"checked\")\n-\n-    def fixup(self):\n-        ListControl.fixup(self)\n-        found = [o for o in self.items if o.selected and not o.disabled]\n-        if not found:\n-            if self._select_default:\n-                for o in self.items:\n-                    if not o.disabled:\n-                        o.selected = True\n-                        break\n-        else:\n-            # Ensure only one item selected.  Choose the last one,\n-            # following IE and Firefox.\n-            for o in found[:-1]:\n-                o.selected = False\n-\n-    def get_labels(self):\n-        return []\n-\n-class CheckboxControl(ListControl):\n-    \"\"\"\n-    Covers:\n-\n-    INPUT/CHECKBOX\n-\n-    \"\"\"\n-    def __init__(self, type, name, attrs, select_default=False, index=None):\n-        attrs.setdefault(\"value\", \"on\")\n-        ListControl.__init__(self, type, name, attrs, select_default,\n-                             called_as_base_class=True, index=index)\n-        self.__dict__[\"multiple\"] = True\n-        o = Item(self, attrs, index)\n-        o.__dict__[\"_selected\"] = attrs.has_key(\"checked\")\n-\n-    def get_labels(self):\n-        return []\n-\n-\n-class SelectControl(ListControl):\n-    \"\"\"\n-    Covers:\n-\n-    SELECT (and OPTION)\n-\n-\n-    OPTION 'values', in HTML parlance, are Item 'names' in ClientForm parlance.\n-\n-    SELECT control values and labels are subject to some messy defaulting\n-    rules.  For example, if the HTML representation of the control is:\n-\n-    <SELECT name=year>\n-      <OPTION value=0 label=\"2002\">current year</OPTION>\n-      <OPTION value=1>2001</OPTION>\n-      <OPTION>2000</OPTION>\n-    </SELECT>\n-\n-    The items, in order, have labels \"2002\", \"2001\" and \"2000\", whereas their\n-    names (the OPTION values) are \"0\", \"1\" and \"2000\" respectively.  Note that\n-    the value of the last OPTION in this example defaults to its contents, as\n-    specified by RFC 1866, as do the labels of the second and third OPTIONs.\n-\n-    The OPTION labels are sometimes more meaningful than the OPTION values,\n-    which can make for more maintainable code.\n-\n-    Additional read-only public attribute: attrs\n-\n-    The attrs attribute is a dictionary of the original HTML attributes of the\n-    SELECT element.  Other ListControls do not have this attribute, because in\n-    other cases the control as a whole does not correspond to any single HTML\n-    element.  control.get(...).attrs may be used as usual to get at the HTML\n-    attributes of the HTML elements corresponding to individual list items (for\n-    SELECT controls, these are OPTION elements).\n-\n-    Another special case is that the Item.attrs dictionaries have a special key\n-    \"contents\" which does not correspond to any real HTML attribute, but rather\n-    contains the contents of the OPTION element:\n-\n-    <OPTION>this bit</OPTION>\n-\n-    \"\"\"\n-    # HTML attributes here are treated slightly differently from other list\n-    # controls:\n-    # -The SELECT HTML attributes dictionary is stuffed into the OPTION\n-    #  HTML attributes dictionary under the \"__select\" key.\n-    # -The content of each OPTION element is stored under the special\n-    #  \"contents\" key of the dictionary.\n-    # After all this, the dictionary is passed to the SelectControl constructor\n-    # as the attrs argument, as usual.  However:\n-    # -The first SelectControl constructed when building up a SELECT control\n-    #  has a constructor attrs argument containing only the __select key -- so\n-    #  this SelectControl represents an empty SELECT control.\n-    # -Subsequent SelectControls have both OPTION HTML-attribute in attrs and\n-    #  the __select dictionary containing the SELECT HTML-attributes.\n-\n-    def __init__(self, type, name, attrs, select_default=False, index=None):\n-        # fish out the SELECT HTML attributes from the OPTION HTML attributes\n-        # dictionary\n-        self.attrs = attrs[\"__select\"].copy()\n-        self.__dict__[\"_label\"] = _get_label(self.attrs)\n-        self.__dict__[\"id\"] = self.attrs.get(\"id\")\n-        self.__dict__[\"multiple\"] = self.attrs.has_key(\"multiple\")\n-        # the majority of the contents, label, and value dance already happened\n-        contents = attrs.get(\"contents\")\n-        attrs = attrs.copy()\n-        del attrs[\"__select\"]\n-\n-        ListControl.__init__(self, type, name, self.attrs, select_default,\n-                             called_as_base_class=True, index=index)\n-        self.disabled = self.attrs.has_key(\"disabled\")\n-        self.readonly = self.attrs.has_key(\"readonly\")\n-        if attrs.has_key(\"value\"):\n-            # otherwise it is a marker 'select started' token\n-            o = Item(self, attrs, index)\n-            o.__dict__[\"_selected\"] = attrs.has_key(\"selected\")\n-            # add 'label' label and contents label, if different.  If both are\n-            # provided, the 'label' label is used for display in HTML \n-            # 4.0-compliant browsers (and any lower spec? not sure) while the\n-            # contents are used for display in older or less-compliant\n-            # browsers.  We make label objects for both, if the values are\n-            # different.\n-            label = attrs.get(\"label\")\n-            if label:\n-                o._labels.append(Label({\"__text\": label}))\n-                if contents and contents != label:\n-                    o._labels.append(Label({\"__text\": contents}))\n-            elif contents:\n-                o._labels.append(Label({\"__text\": contents}))\n-\n-    def fixup(self):\n-        ListControl.fixup(self)\n-        # Firefox doesn't exclude disabled items from those considered here\n-        # (i.e. from 'found', for both branches of the if below).  Note that\n-        # IE6 doesn't support the disabled attribute on OPTIONs at all.\n-        found = [o for o in self.items if o.selected]\n-        if not found:\n-            if not self.multiple or self._select_default:\n-                for o in self.items:\n-                    if not o.disabled:\n-                        was_disabled = self.disabled\n-                        self.disabled = False\n-                        try:\n-                            o.selected = True\n-                        finally:\n-                            o.disabled = was_disabled\n-                        break\n-        elif not self.multiple:\n-            # Ensure only one item selected.  Choose the last one,\n-            # following IE and Firefox.\n-            for o in found[:-1]:\n-                o.selected = False\n-\n-\n-#---------------------------------------------------\n-class SubmitControl(ScalarControl):\n-    \"\"\"\n-    Covers:\n-\n-    INPUT/SUBMIT\n-    BUTTON/SUBMIT\n-\n-    \"\"\"\n-    def __init__(self, type, name, attrs, index=None):\n-        ScalarControl.__init__(self, type, name, attrs, index)\n-        # IE5 defaults SUBMIT value to \"Submit Query\"; Firebird 0.6 leaves it\n-        # blank, Konqueror 3.1 defaults to \"Submit\".  HTML spec. doesn't seem\n-        # to define this.\n-        if self.value is None: self.value = \"\"\n-        self.readonly = True\n-\n-    def get_labels(self):\n-        res = []\n-        if self.value:\n-            res.append(Label({\"__text\": self.value}))\n-        res.extend(ScalarControl.get_labels(self))\n-        return res\n-\n-    def is_of_kind(self, kind): return kind == \"clickable\"\n-\n-    def _click(self, form, coord, return_type, request_class=urllib2.Request):\n-        self._clicked = coord\n-        r = form._switch_click(return_type, request_class)\n-        self._clicked = False\n-        return r\n-\n-    def _totally_ordered_pairs(self):\n-        if not self._clicked:\n-            return []\n-        return ScalarControl._totally_ordered_pairs(self)\n-\n-\n-#---------------------------------------------------\n-class ImageControl(SubmitControl):\n-    \"\"\"\n-    Covers:\n-\n-    INPUT/IMAGE\n-\n-    Coordinates are specified using one of the HTMLForm.click* methods.\n-\n-    \"\"\"\n-    def __init__(self, type, name, attrs, index=None):\n-        SubmitControl.__init__(self, type, name, attrs, index)\n-        self.readonly = False\n-\n-    def _totally_ordered_pairs(self):\n-        clicked = self._clicked\n-        if self.disabled or not clicked:\n-            return []\n-        name = self.name\n-        if name is None: return []\n-        pairs = [\n-            (self._index, \"%s.x\" % name, str(clicked[0])),\n-            (self._index+1, \"%s.y\" % name, str(clicked[1])),\n-            ]\n-        value = self._value\n-        if value:\n-            pairs.append((self._index+2, name, value))\n-        return pairs\n-\n-    get_labels = ScalarControl.get_labels\n-\n-# aliases, just to make str(control) and str(form) clearer\n-class PasswordControl(TextControl): pass\n-class HiddenControl(TextControl): pass\n-class TextareaControl(TextControl): pass\n-class SubmitButtonControl(SubmitControl): pass\n-\n-\n-def is_listcontrol(control): return control.is_of_kind(\"list\")\n-\n-\n-class HTMLForm:\n-    \"\"\"Represents a single HTML <form> ... </form> element.\n-\n-    A form consists of a sequence of controls that usually have names, and\n-    which can take on various values.  The values of the various types of\n-    controls represent variously: text, zero-or-one-of-many or many-of-many\n-    choices, and files to be uploaded.  Some controls can be clicked on to\n-    submit the form, and clickable controls' values sometimes include the\n-    coordinates of the click.\n-\n-    Forms can be filled in with data to be returned to the server, and then\n-    submitted, using the click method to generate a request object suitable for\n-    passing to urllib2.urlopen (or the click_request_data or click_pairs\n-    methods if you're not using urllib2).\n-\n-    import ClientForm\n-    forms = ClientForm.ParseFile(html, base_uri)\n-    form = forms[0]\n-\n-    form[\"query\"] = \"Python\"\n-    form.find_control(\"nr_results\").get(\"lots\").selected = True\n-\n-    response = urllib2.urlopen(form.click())\n-\n-    Usually, HTMLForm instances are not created directly.  Instead, the\n-    ParseFile or ParseResponse factory functions are used.  If you do construct\n-    HTMLForm objects yourself, however, note that an HTMLForm instance is only\n-    properly initialised after the fixup method has been called (ParseFile and\n-    ParseResponse do this for you).  See ListControl.__doc__ for the reason\n-    this is required.\n-\n-    Indexing a form (form[\"control_name\"]) returns the named Control's value\n-    attribute.  Assignment to a form index (form[\"control_name\"] = something)\n-    is equivalent to assignment to the named Control's value attribute.  If you\n-    need to be more specific than just supplying the control's name, use the\n-    set_value and get_value methods.\n-\n-    ListControl values are lists of item names (specifically, the names of the\n-    items that are selected and not disabled, and hence are \"successful\" -- ie.\n-    cause data to be returned to the server).  The list item's name is the\n-    value of the corresponding HTML element's\"value\" attribute.\n-\n-    Example:\n-\n-      <INPUT type=\"CHECKBOX\" name=\"cheeses\" value=\"leicester\"></INPUT>\n-      <INPUT type=\"CHECKBOX\" name=\"cheeses\" value=\"cheddar\"></INPUT>\n-\n-    defines a CHECKBOX control with name \"cheeses\" which has two items, named\n-    \"leicester\" and \"cheddar\".\n-\n-    Another example:\n-\n-      <SELECT name=\"more_cheeses\">\n-        <OPTION>1</OPTION>\n-        <OPTION value=\"2\" label=\"CHEDDAR\">cheddar</OPTION>\n-      </SELECT>\n-\n-    defines a SELECT control with name \"more_cheeses\" which has two items,\n-    named \"1\" and \"2\" (because the OPTION element's value HTML attribute\n-    defaults to the element contents -- see SelectControl.__doc__ for more on\n-    these defaulting rules).\n-\n-    To select, deselect or otherwise manipulate individual list items, use the\n-    HTMLForm.find_control() and ListControl.get() methods.  To set the whole\n-    value, do as for any other control: use indexing or the set_/get_value\n-    methods.\n-\n-    Example:\n-\n-    # select *only* the item named \"cheddar\"\n-    form[\"cheeses\"] = [\"cheddar\"]\n-    # select \"cheddar\", leave other items unaffected\n-    form.find_control(\"cheeses\").get(\"cheddar\").selected = True\n-\n-    Some controls (RADIO and SELECT without the multiple attribute) can only\n-    have zero or one items selected at a time.  Some controls (CHECKBOX and\n-    SELECT with the multiple attribute) can have multiple items selected at a\n-    time.  To set the whole value of a ListControl, assign a sequence to a form\n-    index:\n-\n-    form[\"cheeses\"] = [\"cheddar\", \"leicester\"]\n-\n-    If the ListControl is not multiple-selection, the assigned list must be of\n-    length one.\n-\n-    To check if a control has an item, if an item is selected, or if an item is\n-    successful (selected and not disabled), respectively:\n-\n-    \"cheddar\" in [item.name for item in form.find_control(\"cheeses\").items]\n-    \"cheddar\" in [item.name for item in form.find_control(\"cheeses\").items and\n-                  item.selected]\n-    \"cheddar\" in form[\"cheeses\"]  # (or \"cheddar\" in form.get_value(\"cheeses\"))\n-\n-    Note that some list items may be disabled (see below).\n-\n-    Note the following mistake:\n-\n-    form[control_name] = control_value\n-    assert form[control_name] == control_value  # not necessarily true\n-\n-    The reason for this is that form[control_name] always gives the list items\n-    in the order they were listed in the HTML.\n-\n-    List items (hence list values, too) can be referred to in terms of list\n-    item labels rather than list item names using the appropriate label\n-    arguments.  Note that each item may have several labels.\n-\n-    The question of default values of OPTION contents, labels and values is\n-    somewhat complicated: see SelectControl.__doc__ and\n-    ListControl.get_item_attrs.__doc__ if you think you need to know.\n-\n-    Controls can be disabled or readonly.  In either case, the control's value\n-    cannot be changed until you clear those flags (see example below).\n-    Disabled is the state typically represented by browsers by 'greying out' a\n-    control.  Disabled controls are not 'successful' -- they don't cause data\n-    to get returned to the server.  Readonly controls usually appear in\n-    browsers as read-only text boxes.  Readonly controls are successful.  List\n-    items can also be disabled.  Attempts to select or deselect disabled items\n-    fail with AttributeError.\n-\n-    If a lot of controls are readonly, it can be useful to do this:\n-\n-    form.set_all_readonly(False)\n-\n-    To clear a control's value attribute, so that it is not successful (until a\n-    value is subsequently set):\n-\n-    form.clear(\"cheeses\")\n-\n-    More examples:\n-\n-    control = form.find_control(\"cheeses\")\n-    control.disabled = False\n-    control.readonly = False\n-    control.get(\"gruyere\").disabled = True\n-    control.items[0].selected = True\n-\n-    See the various Control classes for further documentation.  Many methods\n-    take name, type, kind, id, label and nr arguments to specify the control to\n-    be operated on: see HTMLForm.find_control.__doc__.\n-\n-    ControlNotFoundError (subclass of ValueError) is raised if the specified\n-    control can't be found.  This includes occasions where a non-ListControl\n-    is found, but the method (set, for example) requires a ListControl.\n-    ItemNotFoundError (subclass of ValueError) is raised if a list item can't\n-    be found.  ItemCountError (subclass of ValueError) is raised if an attempt\n-    is made to select more than one item and the control doesn't allow that, or\n-    set/get_single are called and the control contains more than one item.\n-    AttributeError is raised if a control or item is readonly or disabled and\n-    an attempt is made to alter its value.\n-\n-    Security note: Remember that any passwords you store in HTMLForm instances\n-    will be saved to disk in the clear if you pickle them (directly or\n-    indirectly).  The simplest solution to this is to avoid pickling HTMLForm\n-    objects.  You could also pickle before filling in any password, or just set\n-    the password to \"\" before pickling.\n-\n-\n-    Public attributes:\n-\n-    action: full (absolute URI) form action\n-    method: \"GET\" or \"POST\"\n-    enctype: form transfer encoding MIME type\n-    name: name of form (None if no name was specified)\n-    attrs: dictionary mapping original HTML form attributes to their values\n-\n-    controls: list of Control instances; do not alter this list\n-     (instead, call form.new_control to make a Control and add it to the\n-     form, or control.add_to_form if you already have a Control instance)\n-\n-\n-\n-    Methods for form filling:\n-    -------------------------\n-\n-    Most of the these methods have very similar arguments.  See\n-    HTMLForm.find_control.__doc__ for details of the name, type, kind, label\n-    and nr arguments.\n-\n-    def find_control(self,\n-                     name=None, type=None, kind=None, id=None, predicate=None,\n-                     nr=None, label=None)\n-\n-    get_value(name=None, type=None, kind=None, id=None, nr=None,\n-              by_label=False,  # by_label is deprecated\n-              label=None)\n-    set_value(value,\n-              name=None, type=None, kind=None, id=None, nr=None,\n-              by_label=False,  # by_label is deprecated\n-              label=None)\n-\n-    clear_all()\n-    clear(name=None, type=None, kind=None, id=None, nr=None, label=None)\n-\n-    set_all_readonly(readonly)\n-\n-\n-    Method applying only to FileControls:\n-\n-    add_file(file_object,\n-             content_type=\"application/octet-stream\", filename=None,\n-             name=None, id=None, nr=None, label=None)\n-\n-\n-    Methods applying only to clickable controls:\n-\n-    click(name=None, type=None, id=None, nr=0, coord=(1,1), label=None)\n-    click_request_data(name=None, type=None, id=None, nr=0, coord=(1,1),\n-                       label=None)\n-    click_pairs(name=None, type=None, id=None, nr=0, coord=(1,1), label=None)\n-\n-    \"\"\"\n-\n-    type2class = {\n-        \"text\": TextControl,\n-        \"password\": PasswordControl,\n-        \"hidden\": HiddenControl,\n-        \"textarea\": TextareaControl,\n-\n-        \"isindex\": IsindexControl,\n-\n-        \"file\": FileControl,\n-\n-        \"button\": IgnoreControl,\n-        \"buttonbutton\": IgnoreControl,\n-        \"reset\": IgnoreControl,\n-        \"resetbutton\": IgnoreControl,\n-\n-        \"submit\": SubmitControl,\n-        \"submitbutton\": SubmitButtonControl,\n-        \"image\": ImageControl,\n-\n-        \"radio\": RadioControl,\n-        \"checkbox\": CheckboxControl,\n-        \"select\": SelectControl,\n-        }\n-\n-#---------------------------------------------------\n-# Initialisation.  Use ParseResponse / ParseFile instead.\n-\n-    def __init__(self, action, method=\"GET\",\n-                 enctype=\"application/x-www-form-urlencoded\",\n-                 name=None, attrs=None,\n-                 request_class=urllib2.Request,\n-                 forms=None, labels=None, id_to_labels=None,\n-                 backwards_compat=True):\n-        \"\"\"\n-        In the usual case, use ParseResponse (or ParseFile) to create new\n-        HTMLForm objects.\n-\n-        action: full (absolute URI) form action\n-        method: \"GET\" or \"POST\"\n-        enctype: form transfer encoding MIME type\n-        name: name of form\n-        attrs: dictionary mapping original HTML form attributes to their values\n-\n-        \"\"\"\n-        self.action = action\n-        self.method = method\n-        self.enctype = enctype\n-        self.name = name\n-        if attrs is not None:\n-            self.attrs = attrs.copy()\n-        else:\n-            self.attrs = {}\n-        self.controls = []\n-        self._request_class = request_class\n-\n-        # these attributes are used by zope.testbrowser\n-        self._forms = forms  # this is a semi-public API!\n-        self._labels = labels  # this is a semi-public API!\n-        self._id_to_labels = id_to_labels  # this is a semi-public API!\n-\n-        self.backwards_compat = backwards_compat  # note __setattr__\n-\n-        self._urlunparse = urlparse.urlunparse\n-        self._urlparse = urlparse.urlparse\n-\n-    def __getattr__(self, name):\n-        if name == \"backwards_compat\":\n-            return self._backwards_compat\n-        return getattr(HTMLForm, name)\n-\n-    def __setattr__(self, name, value):\n-        # yuck\n-        if name == \"backwards_compat\":\n-            name = \"_backwards_compat\"\n-            value = bool(value)\n-            for cc in self.controls:\n-                try:\n-                    items = cc.items \n-                except AttributeError:\n-                    continue\n-                else:\n-                    for ii in items:\n-                        for ll in ii.get_labels():\n-                            ll._backwards_compat = value\n-        self.__dict__[name] = value\n-\n-    def new_control(self, type, name, attrs,\n-                    ignore_unknown=False, select_default=False, index=None):\n-        \"\"\"Adds a new control to the form.\n-\n-        This is usually called by ParseFile and ParseResponse.  Don't call it\n-        youself unless you're building your own Control instances.\n-\n-        Note that controls representing lists of items are built up from\n-        controls holding only a single list item.  See ListControl.__doc__ for\n-        further information.\n-\n-        type: type of control (see Control.__doc__ for a list)\n-        attrs: HTML attributes of control\n-        ignore_unknown: if true, use a dummy Control instance for controls of\n-         unknown type; otherwise, use a TextControl\n-        select_default: for RADIO and multiple-selection SELECT controls, pick\n-         the first item as the default if no 'selected' HTML attribute is\n-         present (this defaulting happens when the HTMLForm.fixup method is\n-         called)\n-        index: index of corresponding element in HTML (see\n-         MoreFormTests.test_interspersed_controls for motivation)\n-\n-        \"\"\"\n-        type = type.lower()\n-        klass = self.type2class.get(type)\n-        if klass is None:\n-            if ignore_unknown:\n-                klass = IgnoreControl\n-            else:\n-                klass = TextControl\n-\n-        a = attrs.copy()\n-        if issubclass(klass, ListControl):\n-            control = klass(type, name, a, select_default, index)\n-        else:\n-            control = klass(type, name, a, index)\n-\n-        if type == \"select\" and len(attrs) == 1:\n-            for ii in range(len(self.controls)-1, -1, -1):\n-                ctl = self.controls[ii]\n-                if ctl.type == \"select\":\n-                    ctl.close_control()\n-                    break\n-\n-        control.add_to_form(self)\n-        control._urlparse = self._urlparse\n-        control._urlunparse = self._urlunparse\n-\n-    def fixup(self):\n-        \"\"\"Normalise form after all controls have been added.\n-\n-        This is usually called by ParseFile and ParseResponse.  Don't call it\n-        youself unless you're building your own Control instances.\n-\n-        This method should only be called once, after all controls have been\n-        added to the form.\n-\n-        \"\"\"\n-        for control in self.controls:\n-            control.fixup()\n-        self.backwards_compat = self._backwards_compat\n-\n-#---------------------------------------------------\n-    def __str__(self):\n-        header = \"%s%s %s %s\" % (\n-            (self.name and self.name+\" \" or \"\"),\n-            self.method, self.action, self.enctype)\n-        rep = [header]\n-        for control in self.controls:\n-            rep.append(\"  %s\" % str(control))\n-        return \"<%s>\" % \"\\n\".join(rep)\n-\n-#---------------------------------------------------\n-# Form-filling methods.\n-\n-    def __getitem__(self, name):\n-        return self.find_control(name).value\n-    def __contains__(self, name):\n-        return bool(self.find_control(name))\n-    def __setitem__(self, name, value):\n-        control = self.find_control(name)\n-        try:\n-            control.value = value\n-        except AttributeError, e:\n-            raise ValueError(str(e))\n-\n-    def get_value(self,\n-                  name=None, type=None, kind=None, id=None, nr=None,\n-                  by_label=False,  # by_label is deprecated\n-                  label=None):\n-        \"\"\"Return value of control.\n-\n-        If only name and value arguments are supplied, equivalent to\n-\n-        form[name]\n-\n-        \"\"\"\n-        if by_label:\n-            deprecation(\"form.get_value_by_label(...)\")\n-        c = self.find_control(name, type, kind, id, label=label, nr=nr)\n-        if by_label:\n-            try:\n-                meth = c.get_value_by_label\n-            except AttributeError:\n-                raise NotImplementedError(\n-                    \"control '%s' does not yet support by_label\" % c.name)\n-            else:\n-                return meth()\n-        else:\n-            return c.value\n-    def set_value(self, value,\n-                  name=None, type=None, kind=None, id=None, nr=None,\n-                  by_label=False,  # by_label is deprecated\n-                  label=None):\n-        \"\"\"Set value of control.\n-\n-        If only name and value arguments are supplied, equivalent to\n-\n-        form[name] = value\n-\n-        \"\"\"\n-        if by_label:\n-            deprecation(\"form.get_value_by_label(...)\")\n-        c = self.find_control(name, type, kind, id, label=label, nr=nr)\n-        if by_label:\n-            try:\n-                meth = c.set_value_by_label\n-            except AttributeError:\n-                raise NotImplementedError(\n-                    \"control '%s' does not yet support by_label\" % c.name)\n-            else:\n-                meth(value)\n-        else:\n-            c.value = value\n-    def get_value_by_label(\n-        self, name=None, type=None, kind=None, id=None, label=None, nr=None):\n-        \"\"\"\n-\n-        All arguments should be passed by name.\n-\n-        \"\"\"\n-        c = self.find_control(name, type, kind, id, label=label, nr=nr)\n-        return c.get_value_by_label()\n-\n-    def set_value_by_label(\n-        self, value,\n-        name=None, type=None, kind=None, id=None, label=None, nr=None):\n-        \"\"\"\n-\n-        All arguments should be passed by name.\n-\n-        \"\"\"\n-        c = self.find_control(name, type, kind, id, label=label, nr=nr)\n-        c.set_value_by_label(value)\n-\n-    def set_all_readonly(self, readonly):\n-        for control in self.controls:\n-            control.readonly = bool(readonly)\n-\n-    def clear_all(self):\n-        \"\"\"Clear the value attributes of all controls in the form.\n-\n-        See HTMLForm.clear.__doc__.\n-\n-        \"\"\"\n-        for control in self.controls:\n-            control.clear()\n-\n-    def clear(self,\n-              name=None, type=None, kind=None, id=None, nr=None, label=None):\n-        \"\"\"Clear the value attribute of a control.\n-\n-        As a result, the affected control will not be successful until a value\n-        is subsequently set.  AttributeError is raised on readonly controls.\n-\n-        \"\"\"\n-        c = self.find_control(name, type, kind, id, label=label, nr=nr)\n-        c.clear()\n-\n-\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
