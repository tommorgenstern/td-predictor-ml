{"custom_id": "requests#2981366f56d1e5b8d6cd26ca5b33d52fc55515c9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 3143 | Contributors (this commit): 73 | Commits (past 90d): 5 | Contributors (cumulative): 73 | DMM Complexity: None\n\nDIFF:\n@@ -443,6 +443,7 @@ class Session(SessionRedirectMixin):\n             A CA_BUNDLE path can also be provided. Defaults to ``True``.\n         :param cert: (optional) if String, path to ssl client cert file (.pem).\n             If Tuple, ('cert', 'key') pair.\n+        :rtype: requests.Response\n \t\"\"\"\n         # Create the Request.\n         req = Request(\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#634b2beb39644a1aa1ef3f1f7c4f26fe0a6a9bf8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 128 | Contributors (this commit): 1 | Commits (past 90d): 5 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -100,4 +100,3 @@ class Server(threading.Thread):\n                 # if an exception is found in the main thread\n                 self.wait_to_close_event.set()\n         return False # allow exceptions to propagate\n-    \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4c04469cfb22c31871b33c0344c73f636109fda9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 1756 | Contributors (this commit): 13 | Commits (past 90d): 1 | Contributors (cumulative): 13 | DMM Complexity: None\n\nDIFF:\n@@ -40,7 +40,7 @@ class CaseInsensitiveDict(collections.MutableMapping):\n \n     \"\"\"\n     def __init__(self, data=None, **kwargs):\n-        self._store = dict()\n+        self._store = collections.OrderedDict()\n         if data is None:\n             data = {}\n         self.update(data, **kwargs)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4f5741e1ffd8bef185582bcba6145493d4abab15", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 20 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 20 | Churn Cumulative: 3127 | Contributors (this commit): 33 | Commits (past 90d): 16 | Contributors (cumulative): 33 | DMM Complexity: 1.0\n\nDIFF:\n@@ -315,6 +315,26 @@ class TestRequests:\n         prep = ses.prepare_request(req)\n         assert 'Accept-Encoding' not in prep.headers\n \n+    def test_headers_preserve_order(self, httpbin):\n+        \"\"\"Preserve order when headers provided as OrderedDict.\"\"\"\n+        ses = requests.Session()\n+        ses.headers = collections.OrderedDict()\n+        ses.headers['Accept-Encoding'] = 'identity'\n+        ses.headers['First'] = '1'\n+        ses.headers['Second'] = '2'\n+        headers = collections.OrderedDict([('Third', '3'), ('Fourth', '4')])\n+        headers['Fifth'] = '5'\n+        headers['Second'] = '222'\n+        req = requests.Request('GET', httpbin('get'), headers = headers)\n+        prep = ses.prepare_request(req)\n+        items = prep.headers.items()\n+        assert items[0] == ('Accept-Encoding', 'identity')\n+        assert items[1] == ('First', '1')\n+        assert items[2] == ('Second', '222')\n+        assert items[3] == ('Third', '3')\n+        assert items[4] == ('Fourth', '4')\n+        assert items[5] == ('Fifth', '5')\n+\n     @pytest.mark.parametrize('key', ('User-agent', 'user-agent'))\n     def test_user_agent_transfers(self, httpbin, key):\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c8a0fc6aa2131c9bfa7ac3903c01d522fca3d346", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 8 | Churn Cumulative: 4891 | Contributors (this commit): 42 | Commits (past 90d): 19 | Contributors (cumulative): 46 | DMM Complexity: None\n\nDIFF:\n@@ -10,6 +10,8 @@ Data structures that power Requests.\n \n import collections\n \n+from .compat import OrderedDict\n+\n \n class CaseInsensitiveDict(collections.MutableMapping):\n     \"\"\"\n@@ -40,7 +42,7 @@ class CaseInsensitiveDict(collections.MutableMapping):\n \n     \"\"\"\n     def __init__(self, data=None, **kwargs):\n-        self._store = collections.OrderedDict()\n+        self._store = OrderedDict()\n         if data is None:\n             data = {}\n         self.update(data, **kwargs)\n\n@@ -318,11 +318,11 @@ class TestRequests:\n     def test_headers_preserve_order(self, httpbin):\n         \"\"\"Preserve order when headers provided as OrderedDict.\"\"\"\n         ses = requests.Session()\n-        ses.headers = collections.OrderedDict()\n+        ses.headers = OrderedDict()\n         ses.headers['Accept-Encoding'] = 'identity'\n         ses.headers['First'] = '1'\n         ses.headers['Second'] = '2'\n-        headers = collections.OrderedDict([('Third', '3'), ('Fourth', '4')])\n+        headers = OrderedDict([('Third', '3'), ('Fourth', '4')])\n         headers['Fifth'] = '5'\n         headers['Second'] = '222'\n         req = requests.Request('GET', httpbin('get'), headers = headers)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#2029a8a93113dbcd0fab98f987933794d6ac3094", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 17 | Churn Cumulative: 4199 | Contributors (this commit): 64 | Commits (past 90d): 21 | Contributors (cumulative): 69 | DMM Complexity: 1.0\n\nDIFF:\n@@ -264,10 +264,12 @@ class HTTPAdapter(BaseAdapter):\n     def close(self):\n         \"\"\"Disposes of any internal state.\n \n-        Currently, this just closes the PoolManager, which closes pooled\n-        connections.\n+        Currently, this closes the PoolManager and any active ProxyManager,\n+        which closes any pooled connections.\n         \"\"\"\n         self.poolmanager.clear()\n+        for proxy in self.proxy_manager.values():\n+            proxy.clear()\n \n     def request_url(self, request, proxies):\n         \"\"\"Obtain the url to use when making the final request.\n\n@@ -1188,6 +1188,17 @@ class TestRequests:\n         next(r.iter_lines())\n         assert len(list(r.iter_lines())) == 3\n \n+    def test_session_close_proxy_clear(self, mocker):\n+        proxies = {\n+          'one': mocker.Mock(),\n+          'two': mocker.Mock(),\n+        }\n+        session = requests.Session()\n+        mocker.patch.dict(session.adapters['http://'].proxy_manager, proxies)\n+        session.close()\n+        proxies['one'].clear.assert_called_once_with()\n+        proxies['two'].clear.assert_called_once_with()\n+\n \n class TestCaseInsensitiveDict:\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b1a7dcd79915ec7a58043031da432b5841d4d8ec", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 3144 | Contributors (this commit): 34 | Commits (past 90d): 19 | Contributors (cumulative): 34 | DMM Complexity: None\n\nDIFF:\n@@ -327,7 +327,7 @@ class TestRequests:\n         headers['Second'] = '222'\n         req = requests.Request('GET', httpbin('get'), headers=headers)\n         prep = ses.prepare_request(req)\n-        items = prep.headers.items()\n+        items = list(prep.headers.items())\n         assert items[0] == ('Accept-Encoding', 'identity')\n         assert items[1] == ('First', '1')\n         assert items[2] == ('Second', '222')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#ae1ac2d4e075fddf67b81e9aa19fbaf6e2c40941", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 10 | Churn Cumulative: 6297 | Contributors (this commit): 95 | Commits (past 90d): 24 | Contributors (cumulative): 108 | DMM Complexity: 1.0\n\nDIFF:\n@@ -557,7 +557,7 @@ class Session(SessionRedirectMixin):\n \n         # It's possible that users might accidentally send a Request object.\n         # Guard against that specific failure case.\n-        if not isinstance(request, PreparedRequest):\n+        if isinstance(request, Request):\n             raise ValueError('You can only send PreparedRequests.')\n \n         # Set up variables needed for resolve_redirects and dispatching of hooks\n\n@@ -638,6 +638,14 @@ class TestRequests:\n         resp = s.send(prep)\n         assert resp.status_code == 200\n \n+    def test_non_prepared_request_error(self):\n+        s = requests.Session()\n+        req = requests.Request(u('POST'), '/')\n+\n+        with pytest.raises(ValueError) as e:\n+            s.send(req)\n+        assert str(e.value) == 'You can only send PreparedRequests.'\n+\n     def test_custom_content_type(self, httpbin):\n         r = requests.post(\n             httpbin('post'),\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4e7beef860aae511a79df97203c1be50dda35049", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 17/16 | Churn Δ: 4 | Churn Cumulative: 3300 | Contributors (this commit): 61 | Commits (past 90d): 15 | Contributors (cumulative): 66 | DMM Complexity: 1.0\n\nDIFF:\n@@ -579,6 +579,9 @@ def select_proxy(url, proxies):\n     \"\"\"\n     proxies = proxies or {}\n     urlparts = urlparse(url)\n+    if urlparts.hostname is None:\n+        proxy = None\n+    else:\n         proxy = proxies.get(urlparts.scheme+'://'+urlparts.hostname)\n     if proxy is None:\n         proxy = proxies.get(urlparts.scheme)\n\n@@ -325,6 +325,7 @@ def test_dotted_netmask(mask, expected):\n         ('hTTp://u:p@Some.Host/path', 'http://some.host.proxy'),\n         ('hTTp://u:p@Other.Host/path', 'http://http.proxy'),\n         ('hTTps://Other.Host', None),\n+        ('file:///etc/motd', None),\n     ))\n def test_select_proxies(url, expected):\n     \"\"\"Make sure we can select per-host proxies correctly.\"\"\"\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#70a344d8ebc549592d8b8644b2029fb3d1ffa4c2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 5 | Files Changed: 4 | Hunks: 5 | Methods Changed: 4 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 10 | Churn Cumulative: 4587 | Contributors (this commit): 23 | Commits (past 90d): 5 | Contributors (cumulative): 36 | DMM Complexity: None\n\nDIFF:\n@@ -376,4 +376,4 @@ epub_exclude_files = ['search.html']\n # If false, no index is generated.\n #epub_use_index = True\n \n-intersphinx_mapping = {'urllib3': ('http://urllib3.readthedocs.org/en/latest', None)}\n+intersphinx_mapping = {'urllib3': ('http://urllib3.readthedocs.io/en/latest', None)}\n\n@@ -787,7 +787,7 @@ class HTTPSConnectionPool(HTTPConnectionPool):\n             warnings.warn((\n                 'Unverified HTTPS request is being made. '\n                 'Adding certificate verification is strongly advised. See: '\n-                'https://urllib3.readthedocs.org/en/latest/security.html'),\n+                'https://urllib3.readthedocs.io/en/latest/security.html'),\n                 InsecureRequestWarning)\n \n \n\n@@ -70,7 +70,7 @@ class AppEngineManager(RequestMethods):\n         warnings.warn(\n             \"urllib3 is using URLFetch on Google App Engine sandbox instead \"\n             \"of sockets. To use sockets directly instead of URLFetch see \"\n-            \"https://urllib3.readthedocs.org/en/latest/contrib.html.\",\n+            \"https://urllib3.readthedocs.io/en/latest/contrib.html.\",\n             AppEnginePlatformWarning)\n \n         RequestMethods.__init__(self, headers)\n\n@@ -115,7 +115,7 @@ except ImportError:\n                 'A true SSLContext object is not available. This prevents '\n                 'urllib3 from configuring SSL appropriately and may cause '\n                 'certain SSL connections to fail. For more information, see '\n-                'https://urllib3.readthedocs.org/en/latest/security.html'\n+                'https://urllib3.readthedocs.io/en/latest/security.html'\n                 '#insecureplatformwarning.',\n                 InsecurePlatformWarning\n             )\n@@ -310,7 +310,7 @@ def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,\n         'This may cause the server to present an incorrect TLS '\n         'certificate, which can cause validation failures. For more '\n         'information, see '\n-        'https://urllib3.readthedocs.org/en/latest/security.html'\n+        'https://urllib3.readthedocs.io/en/latest/security.html'\n         '#snimissingwarning.',\n         SNIMissingWarning\n     )\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#abe02ed89fa7f575877a882cb5ba337290eb27d1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 1476 | Contributors (this commit): 40 | Commits (past 90d): 2 | Contributors (cumulative): 40 | DMM Complexity: 0.0\n\nDIFF:\n@@ -93,6 +93,7 @@ class HTTPDigestAuth(AuthBase):\n         qop = self._thread_local.chal.get('qop')\n         algorithm = self._thread_local.chal.get('algorithm')\n         opaque = self._thread_local.chal.get('opaque')\n+        hash_utf8 = None\n \n         if algorithm is None:\n             _algorithm = 'MD5'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c9ef5653cc7df3d2eb7d6065ee68294551bdde40", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 637 | Contributors (this commit): 14 | Commits (past 90d): 3 | Contributors (cumulative): 14 | DMM Complexity: None\n\nDIFF:\n@@ -42,8 +42,8 @@ is at <http://python-requests.org>.\n \"\"\"\n \n __title__ = 'requests'\n-__version__ = '2.9.1'\n-__build__ = 0x020901\n+__version__ = '2.9.2'\n+__build__ = 0x020902\n __author__ = 'Kenneth Reitz'\n __license__ = 'Apache 2.0'\n __copyright__ = 'Copyright 2016 Kenneth Reitz'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#a5da4f399f3dfdcd8b24fdd18dd361707ac79a55", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 6 | Churn Cumulative: 643 | Contributors (this commit): 14 | Commits (past 90d): 4 | Contributors (cumulative): 14 | DMM Complexity: None\n\nDIFF:\n@@ -36,14 +36,14 @@ usage:\n The other HTTP methods are supported - see `requests.api`. Full documentation\n is at <http://python-requests.org>.\n \n-:copyright: (c) 2015 by Kenneth Reitz.\n+:copyright: (c) 2016 by Kenneth Reitz.\n :license: Apache 2.0, see LICENSE for more details.\n \n \"\"\"\n \n __title__ = 'requests'\n-__version__ = '2.9.2'\n-__build__ = 0x020902\n+__version__ = '2.10.0'\n+__build__ = 0x021000\n __author__ = 'Kenneth Reitz'\n __license__ = 'Apache 2.0'\n __copyright__ = 'Copyright 2016 Kenneth Reitz'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f69d8c16ed47fa87b2cd0e7b8ad4ecf4871cb5c1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 259 | Lines Deleted: 56 | Files Changed: 13 | Hunks: 62 | Methods Changed: 31 | Complexity Δ (Sum/Max): 42/14 | Churn Δ: 315 | Churn Cumulative: 8799 | Contributors (this commit): 23 | Commits (past 90d): 16 | Contributors (cumulative): 96 | DMM Complexity: 0.09917355371900827\n\nDIFF:\n@@ -1,6 +1,7 @@\n \"\"\"\n urllib3 - Thread-safe connection pooling and re-using.\n \"\"\"\n+\n from __future__ import absolute_import\n import warnings\n \n@@ -31,7 +32,7 @@ except ImportError:\n \n __author__ = 'Andrey Petrov (andrey.petrov@shazow.net)'\n __license__ = 'MIT'\n-__version__ = 'dev'\n+__version__ = '1.15.1'\n \n __all__ = (\n     'HTTPConnectionPool',\n@@ -74,15 +75,18 @@ def add_stderr_logger(level=logging.DEBUG):\n del NullHandler\n \n \n+# All warning filters *must* be appended unless you're really certain that they\n+# shouldn't be: otherwise, it's very hard for users to use most Python\n+# mechanisms to silence them.\n # SecurityWarning's always go off by default.\n warnings.simplefilter('always', exceptions.SecurityWarning, append=True)\n # SubjectAltNameWarning's should go off once per host\n-warnings.simplefilter('default', exceptions.SubjectAltNameWarning)\n+warnings.simplefilter('default', exceptions.SubjectAltNameWarning, append=True)\n # InsecurePlatformWarning's don't vary between requests, so we keep it default.\n warnings.simplefilter('default', exceptions.InsecurePlatformWarning,\n                       append=True)\n # SNIMissingWarnings should go off only once.\n-warnings.simplefilter('default', exceptions.SNIMissingWarning)\n+warnings.simplefilter('default', exceptions.SNIMissingWarning, append=True)\n \n \n def disable_warnings(category=exceptions.HTTPWarning):\n\n@@ -134,7 +134,7 @@ class HTTPHeaderDict(MutableMapping):\n \n     def __init__(self, headers=None, **kwargs):\n         super(HTTPHeaderDict, self).__init__()\n-        self._container = {}\n+        self._container = OrderedDict()\n         if headers is not None:\n             if isinstance(headers, HTTPHeaderDict):\n                 self._copy_from(headers)\n\n@@ -1,5 +1,6 @@\n from __future__ import absolute_import\n import datetime\n+import logging\n import os\n import sys\n import socket\n@@ -38,7 +39,7 @@ from .exceptions import (\n     SubjectAltNameWarning,\n     SystemTimeWarning,\n )\n-from .packages.ssl_match_hostname import match_hostname\n+from .packages.ssl_match_hostname import match_hostname, CertificateError\n \n from .util.ssl_ import (\n     resolve_cert_reqs,\n@@ -50,6 +51,10 @@ from .util.ssl_ import (\n \n from .util import connection\n \n+from ._collections import HTTPHeaderDict\n+\n+log = logging.getLogger(__name__)\n+\n port_by_scheme = {\n     'http': 80,\n     'https': 443,\n@@ -162,6 +167,38 @@ class HTTPConnection(_HTTPConnection, object):\n         conn = self._new_conn()\n         self._prepare_conn(conn)\n \n+    def request_chunked(self, method, url, body=None, headers=None):\n+        \"\"\"\n+        Alternative to the common request method, which sends the\n+        body with chunked encoding and not as one block\n+        \"\"\"\n+        headers = HTTPHeaderDict(headers if headers is not None else {})\n+        skip_accept_encoding = 'accept-encoding' in headers\n+        self.putrequest(method, url, skip_accept_encoding=skip_accept_encoding)\n+        for header, value in headers.items():\n+            self.putheader(header, value)\n+        if 'transfer-encoding' not in headers:\n+            self.putheader('Transfer-Encoding', 'chunked')\n+        self.endheaders()\n+\n+        if body is not None:\n+            stringish_types = six.string_types + (six.binary_type,)\n+            if isinstance(body, stringish_types):\n+                body = (body,)\n+            for chunk in body:\n+                if not chunk:\n+                    continue\n+                if not isinstance(chunk, six.binary_type):\n+                    chunk = chunk.encode('utf8')\n+                len_str = hex(len(chunk))[2:]\n+                self.send(len_str.encode('utf-8'))\n+                self.send(b'\\r\\n')\n+                self.send(chunk)\n+                self.send(b'\\r\\n')\n+\n+        # After the if clause, to always have a closed body\n+        self.send(b'0\\r\\n\\r\\n')\n+\n \n class HTTPSConnection(HTTPConnection):\n     default_port = port_by_scheme['https']\n@@ -265,21 +302,26 @@ class VerifiedHTTPSConnection(HTTPSConnection):\n                     'for details.)'.format(hostname)),\n                     SubjectAltNameWarning\n                 )\n-\n-            # In case the hostname is an IPv6 address, strip the square\n-            # brackets from it before using it to validate. This is because\n-            # a certificate with an IPv6 address in it won't have square\n-            # brackets around that address. Sadly, match_hostname won't do this\n-            # for us: it expects the plain host part without any extra work\n-            # that might have been done to make it palatable to httplib.\n-            asserted_hostname = self.assert_hostname or hostname\n-            asserted_hostname = asserted_hostname.strip('[]')\n-            match_hostname(cert, asserted_hostname)\n+            _match_hostname(cert, self.assert_hostname or hostname)\n \n         self.is_verified = (resolved_cert_reqs == ssl.CERT_REQUIRED or\n                             self.assert_fingerprint is not None)\n \n \n+def _match_hostname(cert, asserted_hostname):\n+    try:\n+        match_hostname(cert, asserted_hostname)\n+    except CertificateError as e:\n+        log.error(\n+            'Certificate did not match expected hostname: %s. '\n+            'Certificate: %s', asserted_hostname, cert\n+        )\n+        # Add cert to exception and reraise so client code can inspect\n+        # the cert when catching the exception, if they want to\n+        e._peer_cert = cert\n+        raise\n+\n+\n if ssl:\n     # Make a copy for testing.\n     UnverifiedHTTPSConnection = HTTPSConnection\n\n@@ -69,7 +69,13 @@ class ConnectionPool(object):\n         if not host:\n             raise LocationValueError(\"No host specified.\")\n \n-        self.host = host\n+        # httplib doesn't like it when we include brackets in ipv6 addresses\n+        # Specifically, if we include brackets but also pass the port then\n+        # httplib crazily doubles up the square brackets on the Host header.\n+        # Instead, we need to make sure we never pass ``None`` as the port.\n+        # However, for backward compatibility reasons we can't actually\n+        # *assert* that.\n+        self.host = host.strip('[]')\n         self.port = port\n \n     def __str__(self):\n@@ -318,7 +324,7 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n         if 'timed out' in str(err) or 'did not complete (read)' in str(err):  # Python 2.6\n             raise ReadTimeoutError(self, url, \"Read timed out. (read timeout=%s)\" % timeout_value)\n \n-    def _make_request(self, conn, method, url, timeout=_Default,\n+    def _make_request(self, conn, method, url, timeout=_Default, chunked=False,\n                       **httplib_request_kw):\n         \"\"\"\n         Perform a request on a given urllib connection object taken from our\n@@ -350,6 +356,9 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n \n         # conn.request() calls httplib.*.request, not the method in\n         # urllib3.request. It also calls makefile (recv) on the socket.\n+        if chunked:\n+            conn.request_chunked(method, url, **httplib_request_kw)\n+        else:\n             conn.request(method, url, **httplib_request_kw)\n \n         # Reset the timeout for the recv() on the socket\n@@ -434,7 +443,8 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n \n     def urlopen(self, method, url, body=None, headers=None, retries=None,\n                 redirect=True, assert_same_host=True, timeout=_Default,\n-                pool_timeout=None, release_conn=None, **response_kw):\n+                pool_timeout=None, release_conn=None, chunked=False,\n+                **response_kw):\n         \"\"\"\n         Get a connection from the pool and perform an HTTP request. This is the\n         lowest level call for making a request, so you'll need to specify all\n@@ -511,6 +521,11 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n             back into the pool. If None, it takes the value of\n             ``response_kw.get('preload_content', True)``.\n \n+        :param chunked:\n+            If True, urllib3 will send the body using chunked transfer\n+            encoding. Otherwise, urllib3 will send the body using the standard\n+            content-length form. Defaults to False.\n+\n         :param \\**response_kw:\n             Additional parameters are passed to\n             :meth:`urllib3.response.HTTPResponse.from_httplib`\n@@ -541,6 +556,10 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n         # complains about UnboundLocalError.\n         err = None\n \n+        # Keep track of whether we cleanly exited the except block. This\n+        # ensures we do proper cleanup in finally.\n+        clean_exit = False\n+\n         try:\n             # Request a connection from the queue.\n             timeout_obj = self._get_timeout(timeout)\n@@ -555,13 +574,14 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n             # Make the request on the httplib connection object.\n             httplib_response = self._make_request(conn, method, url,\n                                                   timeout=timeout_obj,\n-                                                  body=body, headers=headers)\n+                                                  body=body, headers=headers,\n+                                                  chunked=chunked)\n \n             # If we're going to release the connection in ``finally:``, then\n-            # the request doesn't need to know about the connection. Otherwise\n+            # the response doesn't need to know about the connection. Otherwise\n             # it will also try to release it and we'll have a double-release\n             # mess.\n-            response_conn = not release_conn and conn\n+            response_conn = conn if not release_conn else None\n \n             # Import httplib's response into our own wrapper object\n             response = HTTPResponse.from_httplib(httplib_response,\n@@ -569,10 +589,8 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n                                                  connection=response_conn,\n                                                  **response_kw)\n \n-            # else:\n-            #     The connection will be put back into the pool when\n-            #     ``response.release_conn()`` is called (implicitly by\n-            #     ``response.read()``)\n+            # Everything went great!\n+            clean_exit = True\n \n         except Empty:\n             # Timed out by queue.\n@@ -582,22 +600,19 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n             # Close the connection. If a connection is reused on which there\n             # was a Certificate error, the next request will certainly raise\n             # another Certificate error.\n-            conn = conn and conn.close()\n-            release_conn = True\n+            clean_exit = False\n             raise SSLError(e)\n \n         except SSLError:\n             # Treat SSLError separately from BaseSSLError to preserve\n             # traceback.\n-            conn = conn and conn.close()\n-            release_conn = True\n+            clean_exit = False\n             raise\n \n         except (TimeoutError, HTTPException, SocketError, ProtocolError) as e:\n             # Discard the connection for these exceptions. It will be\n             # be replaced during the next _get_conn() call.\n-            conn = conn and conn.close()\n-            release_conn = True\n+            clean_exit = False\n \n             if isinstance(e, (SocketError, NewConnectionError)) and self.proxy:\n                 e = ProxyError('Cannot connect to proxy.', e)\n@@ -612,6 +627,14 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n             err = e\n \n         finally:\n+            if not clean_exit:\n+                # We hit some kind of exception, handled or otherwise. We need\n+                # to throw the connection away unless explicitly told not to.\n+                # Close the connection, set the variable to None, and make sure\n+                # we put the None back in the pool to avoid leaking it.\n+                conn = conn and conn.close()\n+                release_conn = True\n+\n             if release_conn:\n                 # Put the connection back to be reused. If the connection is\n                 # expired then it will be None, which will get replaced with a\n@@ -653,7 +676,15 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n \n         # Check if we should retry the HTTP response.\n         if retries.is_forced_retry(method, status_code=response.status):\n+            try:\n                 retries = retries.increment(method, url, response=response, _pool=self)\n+            except MaxRetryError:\n+                if retries.raise_on_status:\n+                    # Release the connection for this response, since we're not\n+                    # returning it to be released manually.\n+                    response.release_conn()\n+                    raise\n+                return response\n             retries.sleep()\n             log.info(\"Forced retry: %s\", url)\n             return self.urlopen(\n@@ -786,7 +817,7 @@ class HTTPSConnectionPool(HTTPConnectionPool):\n             warnings.warn((\n                 'Unverified HTTPS request is being made. '\n                 'Adding certificate verification is strongly advised. See: '\n-                'https://urllib3.readthedocs.io/en/latest/security.html'),\n+                'https://urllib3.readthedocs.org/en/latest/security.html'),\n                 InsecureRequestWarning)\n \n \n@@ -811,6 +842,7 @@ def connection_from_url(url, **kw):\n         >>> r = conn.request('GET', '/')\n     \"\"\"\n     scheme, host, port = get_host(url)\n+    port = port or port_by_scheme.get(scheme, 80)\n     if scheme == 'https':\n         return HTTPSConnectionPool(host, port=port, **kw)\n     else:\n\n@@ -70,7 +70,7 @@ class AppEngineManager(RequestMethods):\n         warnings.warn(\n             \"urllib3 is using URLFetch on Google App Engine sandbox instead \"\n             \"of sockets. To use sockets directly instead of URLFetch see \"\n-            \"https://urllib3.readthedocs.io/en/latest/contrib.html.\",\n+            \"https://urllib3.readthedocs.org/en/latest/contrib.html.\",\n             AppEnginePlatformWarning)\n \n         RequestMethods.__init__(self, headers)\n\n@@ -54,9 +54,17 @@ except SyntaxError as e:\n import OpenSSL.SSL\n from pyasn1.codec.der import decoder as der_decoder\n from pyasn1.type import univ, constraint\n-from socket import _fileobject, timeout, error as SocketError\n+from socket import timeout, error as SocketError\n+\n+try:  # Platform-specific: Python 2\n+    from socket import _fileobject\n+except ImportError:  # Platform-specific: Python 3\n+    _fileobject = None\n+    from urllib3.packages.backports.makefile import backport_makefile\n+\n import ssl\n import select\n+import six\n \n from .. import connection\n from .. import util\n@@ -90,7 +98,7 @@ _openssl_verify = {\n         OpenSSL.SSL.VERIFY_PEER + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,\n }\n \n-DEFAULT_SSL_CIPHER_LIST = util.ssl_.DEFAULT_CIPHERS\n+DEFAULT_SSL_CIPHER_LIST = util.ssl_.DEFAULT_CIPHERS.encode('ascii')\n \n # OpenSSL will only write 16K at a time\n SSL_WRITE_BLOCKSIZE = 16384\n@@ -104,6 +112,7 @@ def inject_into_urllib3():\n \n     connection.ssl_wrap_socket = ssl_wrap_socket\n     util.HAS_SNI = HAS_SNI\n+    util.IS_PYOPENSSL = True\n \n \n def extract_from_urllib3():\n@@ -111,6 +120,7 @@ def extract_from_urllib3():\n \n     connection.ssl_wrap_socket = orig_connection_ssl_wrap_socket\n     util.HAS_SNI = orig_util_HAS_SNI\n+    util.IS_PYOPENSSL = False\n \n \n # Note: This is a slightly bug-fixed version of same from ndg-httpsclient.\n@@ -135,7 +145,7 @@ def get_subj_alt_name(peer_cert):\n     for i in range(peer_cert.get_extension_count()):\n         ext = peer_cert.get_extension(i)\n         ext_name = ext.get_short_name()\n-        if ext_name != 'subjectAltName':\n+        if ext_name != b'subjectAltName':\n             continue\n \n         # PyOpenSSL returns extension data in ASN.1 encoded form\n@@ -167,13 +177,17 @@ class WrappedSocket(object):\n         self.socket = socket\n         self.suppress_ragged_eofs = suppress_ragged_eofs\n         self._makefile_refs = 0\n+        self._closed = False\n \n     def fileno(self):\n         return self.socket.fileno()\n \n-    def makefile(self, mode, bufsize=-1):\n-        self._makefile_refs += 1\n-        return _fileobject(self, mode, bufsize, close=True)\n+    # Copy-pasted from Python 3.5 source code\n+    def _decref_socketios(self):\n+        if self._makefile_refs > 0:\n+            self._makefile_refs -= 1\n+        if self._closed:\n+            self.close()\n \n     def recv(self, *args, **kwargs):\n         try:\n@@ -182,7 +196,7 @@ class WrappedSocket(object):\n             if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'):\n                 return b''\n             else:\n-                raise SocketError(e)\n+                raise SocketError(str(e))\n         except OpenSSL.SSL.ZeroReturnError as e:\n             if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:\n                 return b''\n@@ -198,6 +212,27 @@ class WrappedSocket(object):\n         else:\n             return data\n \n+    def recv_into(self, *args, **kwargs):\n+        try:\n+            return self.connection.recv_into(*args, **kwargs)\n+        except OpenSSL.SSL.SysCallError as e:\n+            if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'):\n+                return 0\n+            else:\n+                raise SocketError(str(e))\n+        except OpenSSL.SSL.ZeroReturnError as e:\n+            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:\n+                return 0\n+            else:\n+                raise\n+        except OpenSSL.SSL.WantReadError:\n+            rd, wd, ed = select.select(\n+                [self.socket], [], [], self.socket.gettimeout())\n+            if not rd:\n+                raise timeout('The read operation timed out')\n+            else:\n+                return self.recv_into(*args, **kwargs)\n+\n     def settimeout(self, timeout):\n         return self.socket.settimeout(timeout)\n \n@@ -225,6 +260,7 @@ class WrappedSocket(object):\n     def close(self):\n         if self._makefile_refs < 1:\n             try:\n+                self._closed = True\n                 return self.connection.close()\n             except OpenSSL.SSL.Error:\n                 return\n@@ -262,6 +298,16 @@ class WrappedSocket(object):\n             self._makefile_refs -= 1\n \n \n+if _fileobject:  # Platform-specific: Python 2\n+    def makefile(self, mode, bufsize=-1):\n+        self._makefile_refs += 1\n+        return _fileobject(self, mode, bufsize, close=True)\n+else:  # Platform-specific: Python 3\n+    makefile = backport_makefile\n+\n+WrappedSocket.makefile = makefile\n+\n+\n def _verify_callback(cnx, x509, err_no, err_depth, return_code):\n     return err_no == 0\n \n@@ -285,7 +331,7 @@ def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,\n     else:\n         ctx.set_default_verify_paths()\n \n-    # Disable TLS compression to migitate CRIME attack (issue #309)\n+    # Disable TLS compression to mitigate CRIME attack (issue #309)\n     OP_NO_COMPRESSION = 0x20000\n     ctx.set_options(OP_NO_COMPRESSION)\n \n@@ -293,6 +339,8 @@ def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,\n     ctx.set_cipher_list(DEFAULT_SSL_CIPHER_LIST)\n \n     cnx = OpenSSL.SSL.Connection(ctx, sock)\n+    if isinstance(server_hostname, six.text_type):  # Platform-specific: Python 3\n+        server_hostname = server_hostname.encode('utf-8')\n     cnx.set_tlsext_host_name(server_hostname)\n     cnx.set_connect_state()\n     while True:\n\n@@ -36,11 +36,11 @@ def format_header_param(name, value):\n         result = '%s=\"%s\"' % (name, value)\n         try:\n             result.encode('ascii')\n-        except UnicodeEncodeError:\n+        except (UnicodeEncodeError, UnicodeDecodeError):\n             pass\n         else:\n             return result\n-    if not six.PY3:  # Python 2:\n+    if not six.PY3 and isinstance(value, six.text_type):  # Python 2:\n         value = value.encode('utf-8')\n     value = email.utils.encode_rfc2231(value, 'utf-8')\n     value = '%s*=%s' % (name, value)\n\n\n@@ -0,0 +1,53 @@\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+backports.makefile\n+~~~~~~~~~~~~~~~~~~\n+\n+Backports the Python 3 ``socket.makefile`` method for use with anything that\n+wants to create a \"fake\" socket object.\n+\"\"\"\n+import io\n+\n+from socket import SocketIO\n+\n+\n+def backport_makefile(self, mode=\"r\", buffering=None, encoding=None,\n+                      errors=None, newline=None):\n+    \"\"\"\n+    Backport of ``socket.makefile`` from Python 3.5.\n+    \"\"\"\n+    if not set(mode) <= set([\"r\", \"w\", \"b\"]):\n+        raise ValueError(\n+            \"invalid mode %r (only r, w, b allowed)\" % (mode,)\n+        )\n+    writing = \"w\" in mode\n+    reading = \"r\" in mode or not writing\n+    assert reading or writing\n+    binary = \"b\" in mode\n+    rawmode = \"\"\n+    if reading:\n+        rawmode += \"r\"\n+    if writing:\n+        rawmode += \"w\"\n+    raw = SocketIO(self, rawmode)\n+    self._makefile_refs += 1\n+    if buffering is None:\n+        buffering = -1\n+    if buffering < 0:\n+        buffering = io.DEFAULT_BUFFER_SIZE\n+    if buffering == 0:\n+        if not binary:\n+            raise ValueError(\"unbuffered streams must be binary\")\n+        return raw\n+    if reading and writing:\n+        buffer = io.BufferedRWPair(raw, raw, buffering)\n+    elif reading:\n+        buffer = io.BufferedReader(raw, buffering)\n+    else:\n+        assert writing\n+        buffer = io.BufferedWriter(raw, buffering)\n+    if binary:\n+        return buffer\n+    text = io.TextIOWrapper(buffer, encoding, errors, newline)\n+    text.mode = mode\n+    return text\n\n@@ -221,6 +221,8 @@ class HTTPResponse(io.IOBase):\n \n         On exit, release the connection back to the pool.\n         \"\"\"\n+        clean_exit = False\n+\n         try:\n             try:\n                 yield\n@@ -243,20 +245,27 @@ class HTTPResponse(io.IOBase):\n                 # This includes IncompleteRead.\n                 raise ProtocolError('Connection broken: %r' % e, e)\n \n-        except Exception:\n-            # The response may not be closed but we're not going to use it anymore\n-            # so close it now to ensure that the connection is released back to the pool.\n-            if self._original_response and not self._original_response.isclosed():\n+            # If no exception is thrown, we should avoid cleaning up\n+            # unnecessarily.\n+            clean_exit = True\n+        finally:\n+            # If we didn't terminate cleanly, we need to throw away our\n+            # connection.\n+            if not clean_exit:\n+                # The response may not be closed but we're not going to use it\n+                # anymore so close it now to ensure that the connection is\n+                # released back to the pool.\n+                if self._original_response:\n                     self._original_response.close()\n \n                 # Closing the response may not actually be sufficient to close\n                 # everything, so if we have a hold of the connection close that\n                 # too.\n-            if self._connection is not None:\n+                if self._connection:\n                     self._connection.close()\n \n-            raise\n-        finally:\n+            # If we hold the original response but it's closed now, we should\n+            # return the connection back to the pool.\n             if self._original_response and self._original_response.isclosed():\n                 self.release_conn()\n \n@@ -387,6 +396,9 @@ class HTTPResponse(io.IOBase):\n         if not self.closed:\n             self._fp.close()\n \n+        if self._connection:\n+            self._connection.close()\n+\n     @property\n     def closed(self):\n         if self._fp is None:\n\n@@ -6,6 +6,7 @@ from .response import is_fp_closed\n from .ssl_ import (\n     SSLContext,\n     HAS_SNI,\n+    IS_PYOPENSSL,\n     assert_fingerprint,\n     resolve_cert_reqs,\n     resolve_ssl_version,\n@@ -26,6 +27,7 @@ from .url import (\n \n __all__ = (\n     'HAS_SNI',\n+    'IS_PYOPENSSL',\n     'SSLContext',\n     'Retry',\n     'Timeout',\n\n@@ -102,6 +102,11 @@ class Retry(object):\n     :param bool raise_on_redirect: Whether, if the number of redirects is\n         exhausted, to raise a MaxRetryError, or to return a response with a\n         response code in the 3xx range.\n+\n+    :param bool raise_on_status: Similar meaning to ``raise_on_redirect``:\n+        whether we should raise an exception, or return a response,\n+        if status falls in ``status_forcelist`` range and retries have\n+        been exhausted.\n     \"\"\"\n \n     DEFAULT_METHOD_WHITELIST = frozenset([\n@@ -112,7 +117,8 @@ class Retry(object):\n \n     def __init__(self, total=10, connect=None, read=None, redirect=None,\n                  method_whitelist=DEFAULT_METHOD_WHITELIST, status_forcelist=None,\n-                 backoff_factor=0, raise_on_redirect=True, _observed_errors=0):\n+                 backoff_factor=0, raise_on_redirect=True, raise_on_status=True,\n+                 _observed_errors=0):\n \n         self.total = total\n         self.connect = connect\n@@ -127,6 +133,7 @@ class Retry(object):\n         self.method_whitelist = method_whitelist\n         self.backoff_factor = backoff_factor\n         self.raise_on_redirect = raise_on_redirect\n+        self.raise_on_status = raise_on_status\n         self._observed_errors = _observed_errors  # TODO: use .history instead?\n \n     def new(self, **kw):\n@@ -137,6 +144,7 @@ class Retry(object):\n             status_forcelist=self.status_forcelist,\n             backoff_factor=self.backoff_factor,\n             raise_on_redirect=self.raise_on_redirect,\n+            raise_on_status=self.raise_on_status,\n             _observed_errors=self._observed_errors,\n         )\n         params.update(kw)\n\n@@ -12,6 +12,7 @@ from ..exceptions import SSLError, InsecurePlatformWarning, SNIMissingWarning\n SSLContext = None\n HAS_SNI = False\n create_default_context = None\n+IS_PYOPENSSL = False\n \n # Maps the length of a digest to a possible hash function producing this digest\n HASHFUNC_MAP = {\n@@ -114,8 +115,9 @@ except ImportError:\n             warnings.warn(\n                 'A true SSLContext object is not available. This prevents '\n                 'urllib3 from configuring SSL appropriately and may cause '\n-                'certain SSL connections to fail. For more information, see '\n-                'https://urllib3.readthedocs.io/en/latest/security.html'\n+                'certain SSL connections to fail. You can upgrade to a newer '\n+                'version of Python to solve this. For more information, see '\n+                'https://urllib3.readthedocs.org/en/latest/security.html'\n                 '#insecureplatformwarning.',\n                 InsecurePlatformWarning\n             )\n@@ -309,9 +311,9 @@ def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,\n         'An HTTPS request has been made, but the SNI (Subject Name '\n         'Indication) extension to TLS is not available on this platform. '\n         'This may cause the server to present an incorrect TLS '\n-        'certificate, which can cause validation failures. For more '\n-        'information, see '\n-        'https://urllib3.readthedocs.io/en/latest/security.html'\n+        'certificate, which can cause validation failures. You can upgrade to '\n+        'a newer version of Python to solve this. For more information, see '\n+        'https://urllib3.readthedocs.org/en/latest/security.html'\n         '#snimissingwarning.',\n         SNIMissingWarning\n     )\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#386382b18caab6a3a8a111fa8e24875dca27b0aa", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 17 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 19 | Churn Cumulative: 12605 | Contributors (this commit): 169 | Commits (past 90d): 24 | Contributors (cumulative): 193 | DMM Complexity: 1.0\n\nDIFF:\n@@ -420,8 +420,11 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         length = None\n \n         if not data and json is not None:\n-            content_type = 'application/json'\n-            body = complexjson.dumps(json)\n+            # When urllib3 uses pyOpenSSL, it can only resume large uploads\n+            # properly if receiving a bytes-like object. In Python 2, json.dumps()\n+            # returns just that, but Python 3 returns a Unicode string.\n+            content_type = 'application/json; charset=utf-8'\n+            body = complexjson.dumps(json).encode('utf-8')\n \n         is_stream = all([\n             hasattr(data, '__iter__'),\n\n@@ -1516,6 +1516,18 @@ class RedirectSession(SessionRedirectMixin):\n         return string\n \n \n+def test_json_encodes_as_bytes():\n+    # urllib3 expects bodies as bytes-like objects\n+    body = {\"key\": \"value\"}\n+    p = PreparedRequest()\n+    p.prepare(\n+        method='GET',\n+        url='https://www.example.com/',\n+        json='body'\n+    )\n+    assert isinstance(p.body, bytes)\n+\n+\n def test_requests_are_updated_each_time(httpbin):\n     session = RedirectSession([303, 307])\n     prep = requests.Request('POST', httpbin('post')).prepare()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#9ff2e43cd6de340c152145adc0e922f94e0aaf1c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 6 | Churn Cumulative: 9447 | Contributors (this commit): 157 | Commits (past 90d): 4 | Contributors (cumulative): 157 | DMM Complexity: 0.0\n\nDIFF:\n@@ -423,8 +423,10 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n             # When urllib3 uses pyOpenSSL, it can only resume large uploads\n             # properly if receiving a bytes-like object. In Python 2, json.dumps()\n             # returns just that, but Python 3 returns a Unicode string.\n-            content_type = 'application/json; charset=utf-8'\n-            body = complexjson.dumps(json).encode('utf-8')\n+            content_type = 'application/json'\n+            body = complexjson.dumps(json)\n+            if not isinstance(body, bytes):\n+                body = body.encode('utf-8')\n \n         is_stream = all([\n             hasattr(data, '__iter__'),\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
