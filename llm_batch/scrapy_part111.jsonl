{"custom_id": "scrapy#1ef2cd400c90ea02975f25c3ee47a054851962c2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 50 | Lines Deleted: 1 | Files Changed: 4 | Hunks: 7 | Methods Changed: 7 | Complexity Δ (Sum/Max): 15/8 | Churn Δ: 51 | Churn Cumulative: 456 | Contributors (this commit): 3 | Commits (past 90d): 16 | Contributors (cumulative): 8 | DMM Complexity: 1.0\n\nDIFF:\n@@ -3,6 +3,7 @@ from twisted.internet import defer\n from scrapy.http import Request\n from scrapy.utils.misc import arg_to_iter\n from scrapy.utils.spider import create_spider_for_request\n+from scrapy.utils.python import stringify_dict\n from scrapy import log\n \n \n@@ -23,6 +24,7 @@ class ExecutionQueue(object):\n         msg = self._queue.pop()\n         if msg:\n             name = msg.pop('name')\n+            msg = stringify_dict(msg) # see #250\n             self.append_spider_name(name, **msg)\n \n     def get_next(self):\n\n@@ -100,6 +100,17 @@ class ExecutionQueueTest(unittest.TestCase):\n         self.assert_(spider.name == 'test123')\n         self.assert_(spider.arg == '123')\n \n+    def test_append_next(self):\n+        # the reason for this test: http://dev.scrapy.org/ticket/250\n+        class MockQueue(object):\n+            def pop(self):\n+                return {u'name': u'test123', u'test': u'hello'}\n+        self.queue._queue = MockQueue()\n+        self.queue._append_next()\n+        spider = self.queue.spider_requests[0][0]\n+        self.assert_(spider.name == 'test123')\n+        self.assert_(spider.test == 'hello')\n+\n     def _assert_request_urls(self, requests, urls):\n         assert all(isinstance(x, Request) for x in requests)\n         self.assertEqual([x.url for x in requests], urls)\n\n@@ -4,7 +4,7 @@ from itertools import count\n \n from scrapy.utils.python import str_to_unicode, unicode_to_str, \\\n     memoizemethod_noargs, isbinarytext, equal_attributes, \\\n-    WeakKeyCache\n+    WeakKeyCache, stringify_dict\n \n class UtilsPythonTestCase(unittest.TestCase):\n     def test_str_to_unicode(self):\n@@ -122,7 +122,29 @@ class UtilsPythonTestCase(unittest.TestCase):\n         del k\n         self.assertFalse(len(wk._weakdict))\n \n+    def test_stringify_dict(self):\n+        d = {'a': 123, u'b': 'c', u'd': u'e', object(): u'e'}\n+        d2 = stringify_dict(d, keys_only=False)\n+        self.failUnlessEqual(d, d2)\n+        self.failIf(d is d2) # shouldn't modify in place\n+        self.failIf(any(isinstance(x, unicode) for x in d2.keys()))\n+        self.failIf(any(isinstance(x, unicode) for x in d2.values()))\n \n+    def test_stringify_dict_tuples(self):\n+        tuples = [('a', 123), (u'b', 'c'), (u'd', u'e'), (object(), u'e')]\n+        d = dict(tuples)\n+        d2 = stringify_dict(tuples, keys_only=False)\n+        self.failUnlessEqual(d, d2)\n+        self.failIf(d is d2) # shouldn't modify in place\n+        self.failIf(any(isinstance(x, unicode) for x in d2.keys()), d2.keys())\n+        self.failIf(any(isinstance(x, unicode) for x in d2.values()))\n+\n+    def test_stringify_dict_keys_only(self):\n+        d = {'a': 123, u'b': 'c', u'd': u'e', object(): u'e'}\n+        d2 = stringify_dict(d)\n+        self.failUnlessEqual(d, d2)\n+        self.failIf(d is d2) # shouldn't modify in place\n+        self.failIf(any(isinstance(x, unicode) for x in d2.keys()))\n \n if __name__ == \"__main__\":\n     unittest.main()\n\n@@ -191,3 +191,17 @@ class WeakKeyCache(object):\n         if key not in self._weakdict:\n             self._weakdict[key] = self.default_factory(key)\n         return self._weakdict[key]\n+\n+\n+def stringify_dict(dct_or_tuples, encoding='utf-8', keys_only=True):\n+    \"\"\"Return a (new) dict with the unicode keys (and values if, keys_only is\n+    False) of the given dict converted to strings. `dct_or_tuples` can be a\n+    dict or a list of tuples, like any dict constructor supports.\n+    \"\"\"\n+    d = {}\n+    for k, v in dict(dct_or_tuples).iteritems():\n+        k = k.encode(encoding) if isinstance(k, unicode) else k\n+        if not keys_only:\n+            v = v.encode(encoding) if isinstance(v, unicode) else v\n+        d[k] = v\n+    return d\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#5d4e0655d089cf0738846d219a573ae4ab1cf405", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 5 | Methods Changed: 4 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 10 | Churn Cumulative: 332 | Contributors (this commit): 4 | Commits (past 90d): 9 | Contributors (cumulative): 7 | DMM Complexity: 1.0\n\nDIFF:\n@@ -277,7 +277,7 @@ class UrlUtilsTest(unittest.TestCase):\n     def test_path_to_file_uri(self):\n         if os.name == 'nt':\n             self.assertEqual(path_to_file_uri(\"C:\\\\windows\\clock.avi\"),\n-                             \"file:///C|/windows/clock.avi\")\n+                             \"file:///C:/windows/clock.avi\")\n         else:\n             self.assertEqual(path_to_file_uri(\"/some/path.txt\"),\n                              \"file:///some/path.txt\")\n@@ -289,9 +289,9 @@ class UrlUtilsTest(unittest.TestCase):\n \n     def test_file_uri_to_path(self):\n         if os.name == 'nt':\n-            self.assertEqual(file_uri_to_path(\"file:///C|/windows/clock.avi\"),\n+            self.assertEqual(file_uri_to_path(\"file:///C:/windows/clock.avi\"),\n                              \"C:\\\\windows\\clock.avi\")\n-            uri = \"file:///C|/windows/clock.avi\"\n+            uri = \"file:///C:/windows/clock.avi\"\n             uri2 = path_to_file_uri(file_uri_to_path(uri))\n             self.assertEqual(uri, uri2)\n         else:\n@@ -309,7 +309,7 @@ class UrlUtilsTest(unittest.TestCase):\n     def test_any_to_uri(self):\n         if os.name == 'nt':\n             self.assertEqual(any_to_uri(\"C:\\\\windows\\clock.avi\"),\n-                             \"file:///C|/windows/clock.avi\")\n+                             \"file:///C:/windows/clock.avi\")\n         else:\n             self.assertEqual(any_to_uri(\"/some/path.txt\"),\n                              \"file:///some/path.txt\")\n\n@@ -161,6 +161,8 @@ def path_to_file_uri(path):\n     http://en.wikipedia.org/wiki/File_URI_scheme\n     \"\"\"\n     x = urllib.pathname2url(os.path.abspath(path))\n+    if os.name == 'nt':\n+        x = x.replace('|', ':') # http://bugs.python.org/issue5861\n     return 'file:///%s' % x.lstrip('/')\n \n def file_uri_to_path(uri):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#3db8d367c42b92e5635aa2be154704260fb47e7a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 161 | Contributors (this commit): 3 | Commits (past 90d): 5 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -285,7 +285,7 @@ class UrlUtilsTest(unittest.TestCase):\n         fn = \"test.txt\"\n         x = path_to_file_uri(fn)\n         self.assert_(x.startswith('file:///'))\n-        self.assertEqual(file_uri_to_path(x), os.path.abspath(fn))\n+        self.assertEqual(file_uri_to_path(x).lower(), os.path.abspath(fn).lower())\n \n     def test_file_uri_to_path(self):\n         if os.name == 'nt':\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "scrapy#52d198afc9088b7d89598c8ccdc92e8642b5e5f4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 42 | Lines Deleted: 1141 | Files Changed: 2 | Hunks: 19 | Methods Changed: 55 | Complexity Δ (Sum/Max): -58/0 | Churn Δ: 1183 | Churn Cumulative: 1192 | Contributors (this commit): 2 | Commits (past 90d): 2 | Contributors (cumulative): 4 | DMM Complexity: 0.05573248407643312\n\nDIFF:\n@@ -84,7 +84,7 @@ class WrappedRequest(object):\n         return self.request.meta.get('is_unverifiable', False)\n \n     def get_origin_req_host(self):\n-        return self.request.hostname\n+        return urlparse_cached(self.request).hostname\n \n     def has_header(self, name):\n         return name in self.request.headers\n\n@@ -1,1159 +1,60 @@\n-\"\"\"Tests for cookielib.py.\"\"\"\n-\n-import re, os, time\n+from urlparse import urlparse\n from unittest import TestCase\n \n-from scrapy.http import Request, Response, Headers\n-from scrapy.http.cookies import WrappedRequest, WrappedResponse, CookieJar, DefaultCookiePolicy\n+from scrapy.http import Request, Response\n+from scrapy.http.cookies import WrappedRequest, WrappedResponse\n \n \n-def interact_2965(cookiejar, url, *set_cookie_hdrs):\n-    return _interact(cookiejar, url, set_cookie_hdrs, \"Set-Cookie2\")\n+class WrappedRequestTest(TestCase):\n \n-def interact_netscape(cookiejar, url, *set_cookie_hdrs):\n-    return _interact(cookiejar, url, set_cookie_hdrs, \"Set-Cookie\")\n+    def setUp(self):\n+        self.request = Request(\"http://www.example.com/page.html\", \\\n+            headers={\"Content-Type\": \"text/html\"})\n+        self.wrapped = WrappedRequest(self.request)\n \n-def _interact(cookiejar, url, set_cookie_hdrs, hdr_name):\n-    \"\"\"Perform a single request / response cycle, returning Cookie: header.\"\"\"\n-    req = Request(url)\n-    cookiejar.add_cookie_header(req)\n-    cookie_hdr = req.headers.get('Cookie', '')\n-    headers = {}\n-    if set_cookie_hdrs:\n-        headers[hdr_name] = set_cookie_hdrs\n-    res = Response(url, headers=headers)\n-    cookiejar.extract_cookies(res, req)\n-    return cookie_hdr\n+    def test_get_full_url(self):\n+        self.assertEqual(self.wrapped.get_full_url(), self.request.url)\n \n+    def test_get_host(self):\n+        self.assertEqual(self.wrapped.get_host(), urlparse(self.request.url).netloc)\n \n-class CookieTests(TestCase):\n-    # XXX\n-    # Get rid of string comparisons where not actually testing str / repr.\n-    # .clear() etc.\n-    # IP addresses like 50 (single number, no dot) and domain-matching\n-    #  functions (and is_HDN)?  See draft RFC 2965 errata.\n-    # Strictness switches\n-    # is_third_party()\n-    # unverifiability / third-party blocking\n-    # Netscape cookies work the same as RFC 2965 with regard to port.\n-    # Set-Cookie with negative max age.\n-    # If turn RFC 2965 handling off, Set-Cookie2 cookies should not clobber\n-    #  Set-Cookie cookies.\n-    # Cookie2 should be sent if *any* cookies are not V1 (ie. V0 OR V2 etc.).\n-    # Cookies (V1 and V0) with no expiry date should be set to be discarded.\n-    # RFC 2965 Quoting:\n-    #  Should accept unquoted cookie-attribute values?  check errata draft.\n-    #   Which are required on the way in and out?\n-    #  Should always return quoted cookie-attribute values?\n-    # Proper testing of when RFC 2965 clobbers Netscape (waiting for errata).\n-    # Path-match on return (same for V0 and V1).\n-    # RFC 2965 acceptance and returning rules\n-    #  Set-Cookie2 without version attribute is rejected.\n+    def test_get_type(self):\n+        self.assertEqual(self.wrapped.get_type(), urlparse(self.request.url).scheme)\n \n-    # Netscape peculiarities list from Ronald Tschalar.\n-    # The first two still need tests, the rest are covered.\n-## - Quoting: only quotes around the expires value are recognized as such\n-##   (and yes, some folks quote the expires value); quotes around any other\n-##   value are treated as part of the value.\n-## - White space: white space around names and values is ignored\n-## - Default path: if no path parameter is given, the path defaults to the\n-##   path in the request-uri up to, but not including, the last '/'. Note\n-##   that this is entirely different from what the spec says.\n-## - Commas and other delimiters: Netscape just parses until the next ';'.\n-##   This means it will allow commas etc inside values (and yes, both\n-##   commas and equals are commonly appear in the cookie value). This also\n-##   means that if you fold multiple Set-Cookie header fields into one,\n-##   comma-separated list, it'll be a headache to parse (at least my head\n-##   starts hurting everytime I think of that code).\n-## - Expires: You'll get all sorts of date formats in the expires,\n-##   including emtpy expires attributes (\"expires=\"). Be as flexible as you\n-##   can, and certainly don't expect the weekday to be there; if you can't\n-##   parse it, just ignore it and pretend it's a session cookie.\n-## - Domain-matching: Netscape uses the 2-dot rule for _all_ domains, not\n-##   just the 7 special TLD's listed in their spec. And folks rely on\n-##   that...\n+    def test_is_unverifiable(self):\n+        self.assertFalse(self.wrapped.is_unverifiable())\n \n-    def test_domain_return_ok(self):\n-        # test optimization: .domain_return_ok() should filter out most\n-        # domains in the CookieJar before we try to access them (because that\n-        # may require disk access -- in particular, with MSIECookieJar)\n-        # This is only a rough check for performance reasons, so it's not too\n-        # critical as long as it's sufficiently liberal.\n-        pol = DefaultCookiePolicy()\n-        for url, domain, ok in [\n-            (\"http://foo.bar.com/\", \"blah.com\", False),\n-            (\"http://foo.bar.com/\", \"rhubarb.blah.com\", False),\n-            (\"http://foo.bar.com/\", \"rhubarb.foo.bar.com\", False),\n-            (\"http://foo.bar.com/\", \".foo.bar.com\", True),\n-            (\"http://foo.bar.com/\", \"foo.bar.com\", True),\n-            (\"http://foo.bar.com/\", \".bar.com\", True),\n-            (\"http://foo.bar.com/\", \"com\", True),\n-            (\"http://foo.com/\", \"rhubarb.foo.com\", False),\n-            (\"http://foo.com/\", \".foo.com\", True),\n-            (\"http://foo.com/\", \"foo.com\", True),\n-            (\"http://foo.com/\", \"com\", True),\n-            (\"http://foo/\", \"rhubarb.foo\", False),\n-            (\"http://foo/\", \".foo\", True),\n-            (\"http://foo/\", \"foo\", True),\n-            (\"http://foo/\", \"foo.local\", True),\n-            (\"http://foo/\", \".local\", True),\n-            ]:\n-            request = WrappedRequest(Request(url))\n-            r = pol.domain_return_ok(domain, request)\n-            if ok: self.assert_(r)\n-            else: self.assert_(not r)\n+    def test_is_unverifiable2(self):\n+        self.request.meta['is_unverifiable'] = True\n+        self.assertTrue(self.wrapped.is_unverifiable())\n \n-    def test_rfc2109_handling(self):\n-        # RFC 2109 cookies are handled as RFC 2965 or Netscape cookies,\n-        # dependent on policy settings\n+    def test_get_origin_req_host(self):\n+        self.assertEqual(self.wrapped.get_origin_req_host(), 'www.example.com')\n \n-        for rfc2109_as_netscape, rfc2965, version in [\n-            # default according to rfc2965 if not explicitly specified\n-            (None, False, 0),\n-            (None, True, 1),\n-            # explicit rfc2109_as_netscape\n-            (False, False, None),  # version None here means no cookie stored\n-            (False, True, 1),\n-            (True, False, 0),\n-            (True, True, 0),\n-            ]:\n-            policy = DefaultCookiePolicy(\n-                rfc2109_as_netscape=rfc2109_as_netscape,\n-                rfc2965=rfc2965)\n-            c = CookieJar(policy)\n-            interact_netscape(c, \"http://www.example.com/\", \"ni=ni; Version=1\")\n-            try:\n-                cookie = c._cookies[\"www.example.com\"][\"/\"][\"ni\"]\n-            except KeyError:\n-                self.assert_(version is None)  # didn't expect a stored cookie\n-            else:\n-                self.assertEqual(cookie.version, version)\n-                # 2965 cookies are unaffected\n-                interact_2965(c, \"http://www.example.com/\",\n-                              \"foo=bar; Version=1\")\n-                if rfc2965:\n-                    cookie2965 = c._cookies[\"www.example.com\"][\"/\"][\"foo\"]\n-                    self.assertEqual(cookie2965.version, 1)\n+    def test_has_header(self):\n+        self.assertTrue(self.wrapped.has_header('content-type'))\n+        self.assertFalse(self.wrapped.has_header('xxxxx'))\n \n-    def test_ns_parser(self):\n-        from cookielib import DEFAULT_HTTP_PORT\n+    def test_get_header(self):\n+        self.assertEqual(self.wrapped.get_header('content-type'), 'text/html')\n+        self.assertEqual(self.wrapped.get_header('xxxxx', 'def'), 'def')\n \n-        c = CookieJar()\n-        interact_netscape(c, \"http://www.acme.com/\",\n-                          'spam=eggs; DoMain=.acme.com; port; blArgh=\"feep\"')\n-        interact_netscape(c, \"http://www.acme.com/\", 'ni=ni; port=80,8080')\n-        interact_netscape(c, \"http://www.acme.com:80/\", 'nini=ni')\n-        interact_netscape(c, \"http://www.acme.com:80/\", 'foo=bar; expires=')\n-        interact_netscape(c, \"http://www.acme.com:80/\", 'spam=eggs; '\n-                          'expires=\"Foo Bar 25 33:22:11 3022\"')\n+    def test_header_items(self):\n+        self.assertEqual(self.wrapped.header_items(), [('Content-Type', ['text/html'])])\n \n-        cookie = c._cookies[\".acme.com\"][\"/\"][\"spam\"]\n-        self.assertEquals(cookie.domain, \".acme.com\")\n-        self.assert_(cookie.domain_specified)\n-        self.assertEquals(cookie.port, DEFAULT_HTTP_PORT)\n-        self.assert_(not cookie.port_specified)\n-        # case is preserved\n-        self.assert_(cookie.has_nonstandard_attr(\"blArgh\") and\n-                     not cookie.has_nonstandard_attr(\"blargh\"))\n+    def test_add_unredirected_header(self):\n+        self.wrapped.add_unredirected_header('hello', 'world')\n+        self.assertEqual(self.request.headers['hello'], 'world')\n \n-        cookie = c._cookies[\"www.acme.com\"][\"/\"][\"ni\"]\n-        self.assertEquals(cookie.domain, \"www.acme.com\")\n-        self.assert_(not cookie.domain_specified)\n-        self.assertEquals(cookie.port, \"80,8080\")\n-        self.assert_(cookie.port_specified)\n+class WrappedResponseTest(TestCase):\n \n-        cookie = c._cookies[\"www.acme.com\"][\"/\"][\"nini\"]\n-        self.assert_(cookie.port is None)\n-        self.assert_(not cookie.port_specified)\n-\n-        # invalid expires should not cause cookie to be dropped\n-        foo = c._cookies[\"www.acme.com\"][\"/\"][\"foo\"]\n-        spam = c._cookies[\"www.acme.com\"][\"/\"][\"foo\"]\n-        self.assert_(foo.expires is None)\n-        self.assert_(spam.expires is None)\n-\n-    def test_ns_parser_special_names(self):\n-        # names such as 'expires' are not special in first name=value pair\n-        # of Set-Cookie: header\n-        c = CookieJar()\n-        interact_netscape(c, \"http://www.acme.com/\", 'expires=eggs')\n-        interact_netscape(c, \"http://www.acme.com/\", 'version=eggs; spam=eggs')\n-\n-        cookies = c._cookies[\"www.acme.com\"][\"/\"]\n-        self.assert_('expires' in cookies)\n-        self.assert_('version' in cookies)\n-\n-    def test_expires(self):\n-        from cookielib import time2netscape\n-\n-        # if expires is in future, keep cookie...\n-        c = CookieJar()\n-        future = time2netscape(time.time()+3600)\n-        interact_netscape(c, \"http://www.acme.com/\", 'spam=\"bar\"; expires=%s' %\n-                          future)\n-        self.assertEquals(len(c), 1)\n-        now = time2netscape(time.time()-1)\n-        # ... and if in past or present, discard it\n-        interact_netscape(c, \"http://www.acme.com/\", 'foo=\"eggs\"; expires=%s' %\n-                          now)\n-        h = interact_netscape(c, \"http://www.acme.com/\")\n-        self.assertEquals(len(c), 1)\n-        self.assert_('spam=\"bar\"' in h and \"foo\" not in h)\n-\n-        # max-age takes precedence over expires, and zero max-age is request to\n-        # delete both new cookie and any old matching cookie\n-        interact_netscape(c, \"http://www.acme.com/\", 'eggs=\"bar\"; expires=%s' %\n-                          future)\n-        interact_netscape(c, \"http://www.acme.com/\", 'bar=\"bar\"; expires=%s' %\n-                          future)\n-        self.assertEquals(len(c), 3)\n-        interact_netscape(c, \"http://www.acme.com/\", 'eggs=\"bar\"; '\n-                          'expires=%s; max-age=0' % future)\n-        interact_netscape(c, \"http://www.acme.com/\", 'bar=\"bar\"; '\n-                          'max-age=0; expires=%s' % future)\n-        h = interact_netscape(c, \"http://www.acme.com/\")\n-        self.assertEquals(len(c), 1)\n-\n-        # test expiry at end of session for cookies with no expires attribute\n-        interact_netscape(c, \"http://www.rhubarb.net/\", 'whum=\"fizz\"')\n-        self.assertEquals(len(c), 2)\n-        c.clear_session_cookies()\n-        self.assertEquals(len(c), 1)\n-        self.assert_('spam=\"bar\"' in h)\n-\n-        # XXX RFC 2965 expiry rules (some apply to V0 too)\n-\n-    def test_default_path(self):\n-        # RFC 2965\n-        pol = DefaultCookiePolicy(rfc2965=True)\n-\n-        c = CookieJar(pol)\n-        interact_2965(c, \"http://www.acme.com/\", 'spam=\"bar\"; Version=\"1\"')\n-        self.assert_(\"/\" in c._cookies[\"www.acme.com\"])\n-\n-        c = CookieJar(pol)\n-        interact_2965(c, \"http://www.acme.com/blah\", 'eggs=\"bar\"; Version=\"1\"')\n-        self.assert_(\"/\" in c._cookies[\"www.acme.com\"])\n-\n-        c = CookieJar(pol)\n-        interact_2965(c, \"http://www.acme.com/blah/rhubarb\",\n-                      'eggs=\"bar\"; Version=\"1\"')\n-        self.assert_(\"/blah/\" in c._cookies[\"www.acme.com\"])\n-\n-        c = CookieJar(pol)\n-        interact_2965(c, \"http://www.acme.com/blah/rhubarb/\",\n-                      'eggs=\"bar\"; Version=\"1\"')\n-        self.assert_(\"/blah/rhubarb/\" in c._cookies[\"www.acme.com\"])\n-\n-        # Netscape\n-\n-        c = CookieJar()\n-        interact_netscape(c, \"http://www.acme.com/\", 'spam=\"bar\"')\n-        self.assert_(\"/\" in c._cookies[\"www.acme.com\"])\n-\n-        c = CookieJar()\n-        interact_netscape(c, \"http://www.acme.com/blah\", 'eggs=\"bar\"')\n-        self.assert_(\"/\" in c._cookies[\"www.acme.com\"])\n-\n-        c = CookieJar()\n-        interact_netscape(c, \"http://www.acme.com/blah/rhubarb\", 'eggs=\"bar\"')\n-        self.assert_(\"/blah\" in c._cookies[\"www.acme.com\"])\n-\n-        c = CookieJar()\n-        interact_netscape(c, \"http://www.acme.com/blah/rhubarb/\", 'eggs=\"bar\"')\n-        self.assert_(\"/blah/rhubarb\" in c._cookies[\"www.acme.com\"])\n-\n-    def test_wrong_domain(self):\n-        # Cookies whose effective request-host name does not domain-match the\n-        # domain are rejected.\n-\n-        # XXX far from complete\n-        c = CookieJar()\n-        interact_2965(c, \"http://www.nasty.com/\", 'foo=bar; domain=friendly.org; Version=\"1\"')\n-        self.assertEquals(len(c), 0)\n-\n-    def test_strict_domain(self):\n-        # Cookies whose domain is a country-code tld like .co.uk should\n-        # not be set if CookiePolicy.strict_domain is true.\n-        cp = DefaultCookiePolicy(strict_domain=True)\n-        cj = CookieJar(policy=cp)\n-        interact_netscape(cj, \"http://example.co.uk/\", 'no=problemo')\n-        interact_netscape(cj, \"http://example.co.uk/\",\n-                          'okey=dokey; Domain=.example.co.uk')\n-        self.assertEquals(len(cj), 2)\n-        for pseudo_tld in [\".co.uk\", \".org.za\", \".tx.us\", \".name.us\"]:\n-            interact_netscape(cj, \"http://example.%s/\" % pseudo_tld,\n-                              'spam=eggs; Domain=.co.uk')\n-            self.assertEquals(len(cj), 2)\n-\n-    def test_two_component_domain_ns(self):\n-        # Netscape: .www.bar.com, www.bar.com, .bar.com, bar.com, no domain\n-        # should all get accepted, as should .acme.com, acme.com and no domain\n-        # for 2-component domains like acme.com.\n-        c = CookieJar()\n-\n-        # two-component V0 domain is OK\n-        interact_netscape(c, \"http://foo.net/\", 'ns=bar')\n-        self.assertEquals(len(c), 1)\n-        self.assertEquals(c._cookies[\"foo.net\"][\"/\"][\"ns\"].value, \"bar\")\n-        self.assertEquals(interact_netscape(c, \"http://foo.net/\"), \"ns=bar\")\n-        # *will* be returned to any other domain (unlike RFC 2965)...\n-        self.assertEquals(interact_netscape(c, \"http://www.foo.net/\"),\n-                          \"ns=bar\")\n-        # ...unless requested otherwise\n-        pol = DefaultCookiePolicy(\n-            strict_ns_domain=DefaultCookiePolicy.DomainStrictNonDomain)\n-        c.set_policy(pol)\n-        self.assertEquals(interact_netscape(c, \"http://www.foo.net/\"), \"\")\n-\n-        # unlike RFC 2965, even explicit two-component domain is OK,\n-        # because .foo.net matches foo.net\n-        interact_netscape(c, \"http://foo.net/foo/\",\n-                          'spam1=eggs; domain=foo.net')\n-        # even if starts with a dot -- in NS rules, .foo.net matches foo.net!\n-        interact_netscape(c, \"http://foo.net/foo/bar/\",\n-                          'spam2=eggs; domain=.foo.net')\n-        self.assertEquals(len(c), 3)\n-        self.assertEquals(c._cookies[\".foo.net\"][\"/foo\"][\"spam1\"].value,\n-                          \"eggs\")\n-        self.assertEquals(c._cookies[\".foo.net\"][\"/foo/bar\"][\"spam2\"].value,\n-                          \"eggs\")\n-        self.assertEquals(interact_netscape(c, \"http://foo.net/foo/bar/\"),\n-                          \"spam2=eggs; spam1=eggs; ns=bar\")\n-\n-        # top-level domain is too general\n-        interact_netscape(c, \"http://foo.net/\", 'nini=\"ni\"; domain=.net')\n-        self.assertEquals(len(c), 3)\n-\n-##         # Netscape protocol doesn't allow non-special top level domains (such\n-##         # as co.uk) in the domain attribute unless there are at least three\n-##         # dots in it.\n-        # Oh yes it does!  Real implementations don't check this, and real\n-        # cookies (of course) rely on that behaviour.\n-        interact_netscape(c, \"http://foo.co.uk\", 'nasty=trick; domain=.co.uk')\n-##         self.assertEquals(len(c), 2)\n-        self.assertEquals(len(c), 4)\n-\n-    def test_two_component_domain_rfc2965(self):\n-        pol = DefaultCookiePolicy(rfc2965=True)\n-        c = CookieJar(pol)\n-\n-        # two-component V1 domain is OK\n-        interact_2965(c, \"http://foo.net/\", 'foo=bar; Version=\"1\"')\n-        self.assertEquals(len(c), 1)\n-        self.assertEquals(c._cookies[\"foo.net\"][\"/\"][\"foo\"].value, \"bar\")\n-        self.assertEquals(interact_2965(c, \"http://foo.net/\"),\n-                          \"$Version=1; foo=bar\")\n-        # won't be returned to any other domain (because domain was implied)\n-        self.assertEquals(interact_2965(c, \"http://www.foo.net/\"), \"\")\n-\n-        # unless domain is given explicitly, because then it must be\n-        # rewritten to start with a dot: foo.net --> .foo.net, which does\n-        # not domain-match foo.net\n-        interact_2965(c, \"http://foo.net/foo\",\n-                      'spam=eggs; domain=foo.net; path=/foo; Version=\"1\"')\n-        self.assertEquals(len(c), 1)\n-        self.assertEquals(interact_2965(c, \"http://foo.net/foo\"),\n-                          \"$Version=1; foo=bar\")\n-\n-        # explicit foo.net from three-component domain www.foo.net *does* get\n-        # set, because .foo.net domain-matches .foo.net\n-        interact_2965(c, \"http://www.foo.net/foo/\",\n-                      'spam=eggs; domain=foo.net; Version=\"1\"')\n-        self.assertEquals(c._cookies[\".foo.net\"][\"/foo/\"][\"spam\"].value,\n-                          \"eggs\")\n-        self.assertEquals(len(c), 2)\n-        self.assertEquals(interact_2965(c, \"http://foo.net/foo/\"),\n-                          \"$Version=1; foo=bar\")\n-        self.assertEquals(interact_2965(c, \"http://www.foo.net/foo/\"),\n-                          '$Version=1; spam=eggs; $Domain=\"foo.net\"')\n-\n-        # top-level domain is too general\n-        interact_2965(c, \"http://foo.net/\",\n-                      'ni=\"ni\"; domain=\".net\"; Version=\"1\"')\n-        self.assertEquals(len(c), 2)\n-\n-        # RFC 2965 doesn't require blocking this\n-        interact_2965(c, \"http://foo.co.uk/\",\n-                      'nasty=trick; domain=.co.uk; Version=\"1\"')\n-        self.assertEquals(len(c), 3)\n-\n-    def test_domain_allow(self):\n-        c = CookieJar(policy=DefaultCookiePolicy(\n-            blocked_domains=[\"acme.com\"],\n-            allowed_domains=[\"www.acme.com\"]))\n-\n-        req = Request(\"http://acme.com/\")\n-        headers = {\"Set-Cookie\": \"CUSTOMER=WILE_E_COYOTE; path=/\"}\n-        res = Response(\"http://acme.com/\", headers=headers)\n-        c.extract_cookies(res, req)\n-        self.assertEquals(len(c), 0)\n-\n-        req = Request(\"http://www.acme.com/\")\n-        res = Response(\"http://www.acme.com/\", headers=headers)\n-        c.extract_cookies(res, req)\n-        self.assertEquals(len(c), 1)\n-\n-        req = Request(\"http://www.coyote.com/\")\n-        res = Response(\"http://www.coyote.com/\", headers=headers)\n-        c.extract_cookies(res, req)\n-        self.assertEquals(len(c), 1)\n-\n-        # set a cookie with non-allowed domain...\n-        req = Request(\"http://www.coyote.com/\")\n-        res = Response(\"http://www.coyote.com/\", headers=headers)\n-        cookies = c.make_cookies(res, req)\n-        c.set_cookie(cookies[0])\n-        self.assertEquals(len(c), 2)\n-        # ... and check is doesn't get returned\n-        c.add_cookie_header(req)\n-        assert 'Cookie' not in req.headers\n-\n-    def test_domain_block(self):\n-        pol = DefaultCookiePolicy(\n-            rfc2965=True, blocked_domains=[\".acme.com\"])\n-\n-        c = CookieJar(policy=pol)\n-        headers = {'Set-Cookie': 'CUSTOMER=WILE_E_COYOTE; path=/'}\n-\n-        req = Request(\"http://www.acme.com/\")\n-        res = Response('http://www.acme.com/', headers=headers)\n-        c.extract_cookies(res, req)\n-        self.assertEquals(len(c), 0)\n-\n-        p = pol.set_blocked_domains([\"acme.com\"])\n-        c.extract_cookies(res, req)\n-        self.assertEquals(len(c), 1)\n-\n-        c.clear()\n-        req = Request(\"http://www.roadrunner.net/\")\n-        res = Response(\"http://www.roadrunner.net/\", headers=headers)\n-        c.extract_cookies(res, req)\n-        self.assertEquals(len(c), 1)\n-        req = Request(\"http://www.roadrunner.net/\")\n-        c.add_cookie_header(req)\n-        assert 'Cookie' in req.headers and 'Cookie2' in req.headers\n-\n-        c.clear()\n-        pol.set_blocked_domains([\".acme.com\"])\n-        c.extract_cookies(res, req)\n-        self.assertEquals(len(c), 1)\n-\n-        # set a cookie with blocked domain...\n-        req = Request(\"http://www.acme.com/\")\n-        res = Response(\"http://www.acme.com/\", headers=headers)\n-        cookies = c.make_cookies(res, req)\n-        c.set_cookie(cookies[0])\n-        self.assertEquals(len(c), 2)\n-        # ... and check is doesn't get returned\n-        c.add_cookie_header(req)\n-        assert 'Cookie' not in req.headers\n-\n-    def test_secure(self):\n-        for ns in True, False:\n-            for whitespace in \" \", \"\":\n-                c = CookieJar()\n-                if ns:\n-                    pol = DefaultCookiePolicy(rfc2965=False)\n-                    int = interact_netscape\n-                    vs = \"\"\n-                else:\n-                    pol = DefaultCookiePolicy(rfc2965=True)\n-                    int = interact_2965\n-                    vs = \"; Version=1\"\n-                c.set_policy(pol)\n-                url = \"http://www.acme.com/\"\n-                int(c, url, \"foo1=bar%s%s\" % (vs, whitespace))\n-                int(c, url, \"foo2=bar%s; secure%s\" %  (vs, whitespace))\n-                self.assert_(\n-                    not c._cookies[\"www.acme.com\"][\"/\"][\"foo1\"].secure,\n-                    \"non-secure cookie registered secure\")\n-                self.assert_(\n-                    c._cookies[\"www.acme.com\"][\"/\"][\"foo2\"].secure,\n-                    \"secure cookie registered non-secure\")\n-\n-    def test_quote_cookie_value(self):\n-        c = CookieJar(policy=DefaultCookiePolicy(rfc2965=True))\n-        interact_2965(c, \"http://www.acme.com/\", r'foo=\\b\"a\"r; Version=1')\n-        h = interact_2965(c, \"http://www.acme.com/\")\n-        self.assertEquals(h, r'$Version=1; foo=\\\\b\\\"a\\\"r')\n-\n-    def test_missing_final_slash(self):\n-        # Missing slash from request URL's abs_path should be assumed present.\n-        url = \"http://www.acme.com\"\n-        c = CookieJar(DefaultCookiePolicy(rfc2965=True))\n-        interact_2965(c, url, \"foo=bar; Version=1\")\n-        req = Request(url)\n-        self.assertEquals(len(c), 1)\n-        c.add_cookie_header(req)\n-        self.assert_('Cookie' in req.headers)\n-\n-    def test_domain_mirror(self):\n-        pol = DefaultCookiePolicy(rfc2965=True)\n-\n-        c = CookieJar(pol)\n-        url = \"http://foo.bar.com/\"\n-        interact_2965(c, url, \"spam=eggs; Version=1\")\n-        h = interact_2965(c, url)\n-        self.assert_(\"Domain\" not in h,\n-                     \"absent domain returned with domain present\")\n-\n-        c = CookieJar(pol)\n-        url = \"http://foo.bar.com/\"\n-        interact_2965(c, url, 'spam=eggs; Version=1; Domain=.bar.com')\n-        h = interact_2965(c, url)\n-        self.assert_('$Domain=\".bar.com\"' in h, \"domain not returned\")\n-\n-        c = CookieJar(pol)\n-        url = \"http://foo.bar.com/\"\n-        # note missing initial dot in Domain\n-        interact_2965(c, url, 'spam=eggs; Version=1; Domain=bar.com')\n-        h = interact_2965(c, url)\n-        self.assert_('$Domain=\"bar.com\"' in h, \"domain not returned\")\n-\n-    def test_path_mirror(self):\n-        pol = DefaultCookiePolicy(rfc2965=True)\n-\n-        c = CookieJar(pol)\n-        url = \"http://foo.bar.com/\"\n-        interact_2965(c, url, \"spam=eggs; Version=1\")\n-        h = interact_2965(c, url)\n-        self.assert_(\"Path\" not in h,\n-                     \"absent path returned with path present\")\n-\n-        c = CookieJar(pol)\n-        url = \"http://foo.bar.com/\"\n-        interact_2965(c, url, 'spam=eggs; Version=1; Path=/')\n-        h = interact_2965(c, url)\n-        self.assert_('$Path=\"/\"' in h, \"path not returned\")\n-\n-    def test_port_mirror(self):\n-        pol = DefaultCookiePolicy(rfc2965=True)\n-\n-        c = CookieJar(pol)\n-        url = \"http://foo.bar.com/\"\n-        interact_2965(c, url, \"spam=eggs; Version=1\")\n-        h = interact_2965(c, url)\n-        self.assert_(\"Port\" not in h,\n-                     \"absent port returned with port present\")\n-\n-        c = CookieJar(pol)\n-        url = \"http://foo.bar.com/\"\n-        interact_2965(c, url, \"spam=eggs; Version=1; Port\")\n-        h = interact_2965(c, url)\n-        self.assert_(re.search(\"\\$Port([^=]|$)\", h),\n-                     \"port with no value not returned with no value\")\n-\n-        c = CookieJar(pol)\n-        url = \"http://foo.bar.com/\"\n-        interact_2965(c, url, 'spam=eggs; Version=1; Port=\"80\"')\n-        h = interact_2965(c, url)\n-        self.assert_('$Port=\"80\"' in h,\n-                     \"port with single value not returned with single value\")\n-\n-        c = CookieJar(pol)\n-        url = \"http://foo.bar.com/\"\n-        interact_2965(c, url, 'spam=eggs; Version=1; Port=\"80,8080\"')\n-        h = interact_2965(c, url)\n-        self.assert_('$Port=\"80,8080\"' in h,\n-                     \"port with multiple values not returned with multiple \"\n-                     \"values\")\n-\n-    def test_no_return_comment(self):\n-        c = CookieJar(DefaultCookiePolicy(rfc2965=True))\n-        url = \"http://foo.bar.com/\"\n-        interact_2965(c, url, 'spam=eggs; Version=1; '\n-                      'Comment=\"does anybody read these?\"; '\n-                      'CommentURL=\"http://foo.bar.net/comment.html\"')\n-        h = interact_2965(c, url)\n-        self.assert_(\n-            \"Comment\" not in h,\n-            \"Comment or CommentURL cookie-attributes returned to server\")\n-\n-    def test_Cookie_iterator(self):\n-        from cookielib import Cookie\n-\n-        cs = CookieJar(DefaultCookiePolicy(rfc2965=True))\n-        # add some random cookies\n-        interact_2965(cs, \"http://blah.spam.org/\", 'foo=eggs; Version=1; '\n-                      'Comment=\"does anybody read these?\"; '\n-                      'CommentURL=\"http://foo.bar.net/comment.html\"')\n-        interact_netscape(cs, \"http://www.acme.com/blah/\", \"spam=bar; secure\")\n-        interact_2965(cs, \"http://www.acme.com/blah/\",\n-                      \"foo=bar; secure; Version=1\")\n-        interact_2965(cs, \"http://www.acme.com/blah/\",\n-                      \"foo=bar; path=/; Version=1\")\n-        interact_2965(cs, \"http://www.sol.no\",\n-                      r'bang=wallop; version=1; domain=\".sol.no\"; '\n-                      r'port=\"90,100, 80,8080\"; '\n-                      r'max-age=100; Comment = \"Just kidding! (\\\"|\\\\\\\\) \"')\n-\n-        versions = [1, 1, 1, 0, 1]\n-        names = [\"bang\", \"foo\", \"foo\", \"spam\", \"foo\"]\n-        domains = [\".sol.no\", \"blah.spam.org\", \"www.acme.com\",\n-                   \"www.acme.com\", \"www.acme.com\"]\n-        paths = [\"/\", \"/\", \"/\", \"/blah\", \"/blah/\"]\n-\n-        for i in range(4):\n-            i = 0\n-            for c in cs:\n-                self.assert_(isinstance(c, Cookie))\n-                self.assertEquals(c.version, versions[i])\n-                self.assertEquals(c.name, names[i])\n-                self.assertEquals(c.domain, domains[i])\n-                self.assertEquals(c.path, paths[i])\n-                i = i + 1\n-\n-    def test_bad_cookie_header(self):\n-        def cookiejar_from_cookie_headers(headers):\n-            c = CookieJar()\n-            req = Request(\"http://www.example.com/\")\n-            r = Response(\"http://www.example.com/\", headers=headers)\n-            c.extract_cookies(r, req)\n-            return c\n-\n-        # none of these bad headers should cause an exception to be raised\n-        for headers in [\n-                {\"Set-Cookie\": \"\"},  # actually, nothing wrong with this\n-                {\"Set-Cookie2\": \"\"},  # ditto\n-            # missing domain value\n-                {\"Set-Cookie2\": \"a=foo; path=/; Version=1; domain\"},\n-            # bad max-age\n-                {\"Set-Cookie\": \"b=foo; max-age=oops\"},\n-                ]:\n-            c = cookiejar_from_cookie_headers(headers)\n-            # these bad cookies shouldn't be set\n-            self.assertEquals(len(c), 0)\n-\n-        # cookie with invalid expires is treated as session cookie\n-        headers = {\"Set-Cookie\": \"c=foo; expires=Foo Bar 12 33:22:11 2000\"}\n-        c = cookiejar_from_cookie_headers(headers)\n-        cookie = c._cookies[\"www.example.com\"][\"/\"][\"c\"]\n-        self.assert_(cookie.expires is None)\n-\n-\n-class LWPCookieTests(TestCase):\n-    # Tests taken from libwww-perl, with a few modifications and additions.\n-\n-    def test_netscape_example_1(self):\n-        #-------------------------------------------------------------------\n-        # First we check that it works for the original example at\n-        # http://www.netscape.com/newsref/std/cookie_spec.html\n-\n-        # Client requests a document, and receives in the response:\n-        #\n-        #       Set-Cookie: CUSTOMER=WILE_E_COYOTE; path=/; expires=Wednesday, 09-Nov-99 23:12:40 GMT\n-        #\n-        # When client requests a URL in path \"/\" on this server, it sends:\n-        #\n-        #       Cookie: CUSTOMER=WILE_E_COYOTE\n-        #\n-        # Client requests a document, and receives in the response:\n-        #\n-        #       Set-Cookie: PART_NUMBER=ROCKET_LAUNCHER_0001; path=/\n-        #\n-        # When client requests a URL in path \"/\" on this server, it sends:\n-        #\n-        #       Cookie: CUSTOMER=WILE_E_COYOTE; PART_NUMBER=ROCKET_LAUNCHER_0001\n-        #\n-        # Client receives:\n-        #\n-        #       Set-Cookie: SHIPPING=FEDEX; path=/fo\n-        #\n-        # When client requests a URL in path \"/\" on this server, it sends:\n-        #\n-        #       Cookie: CUSTOMER=WILE_E_COYOTE; PART_NUMBER=ROCKET_LAUNCHER_0001\n-        #\n-        # When client requests a URL in path \"/foo\" on this server, it sends:\n-        #\n-        #       Cookie: CUSTOMER=WILE_E_COYOTE; PART_NUMBER=ROCKET_LAUNCHER_0001; SHIPPING=FEDEX\n-        #\n-        # The last Cookie is buggy, because both specifications say that the\n-        # most specific cookie must be sent first.  SHIPPING=FEDEX is the\n-        # most specific and should thus be first.\n-\n-        year_plus_one = time.localtime()[0] + 1\n-\n-        c = CookieJar(DefaultCookiePolicy(rfc2965 = True))\n-\n-        #req = Request(\"http://1.1.1.1/\",\n-        #              headers={\"Host\": \"www.acme.com:80\"})\n-        req = Request(\"http://www.acme.com:80/\", headers={\"Host\": \"www.acme.com:80\"})\n-\n-        headers = Headers()\n-        headers['Set-Cookie'] = 'CUSTOMER=WILE_E_COYOTE; path=/ ; expires=Wednesday, 09-Nov-%d 23:12:40 GMT' % year_plus_one\n-        res = Response(\"http://www.acme.com/\", headers=headers)\n-        c.extract_cookies(res, req)\n-\n-        req = Request(\"http://www.acme.com/\")\n-        c.add_cookie_header(req)\n-\n-        self.assertEqual(req.headers.get(\"Cookie\"), \"CUSTOMER=WILE_E_COYOTE\")\n-        self.assertEqual(req.headers.get(\"Cookie2\"), '$Version=\"1\"')\n-\n-        headers.appendlist(\"Set-Cookie\", \"PART_NUMBER=ROCKET_LAUNCHER_0001; path=/\")\n-        res = Response(\"http://www.acme.com/\", headers=headers)\n-        c.extract_cookies(res, req)\n-\n-        req = Request(\"http://www.acme.com/foo/bar\")\n-        c.add_cookie_header(req)\n-\n-        h = req.headers.get(\"Cookie\")\n-        self.assert_(\"PART_NUMBER=ROCKET_LAUNCHER_0001\" in h and\n-                     \"CUSTOMER=WILE_E_COYOTE\" in h)\n-\n-        headers.appendlist('Set-Cookie', 'SHIPPING=FEDEX; path=/foo')\n-        res = Response(\"http://www.acme.com\", headers=headers)\n-        c.extract_cookies(res, req)\n-\n-        req = Request(\"http://www.acme.com/\")\n-        c.add_cookie_header(req)\n-\n-        h = req.headers.get(\"Cookie\")\n-        self.assert_(\"PART_NUMBER=ROCKET_LAUNCHER_0001\" in h and\n-                     \"CUSTOMER=WILE_E_COYOTE\" in h and\n-                     \"SHIPPING=FEDEX\" not in h)\n-\n-        req = Request(\"http://www.acme.com/foo/\")\n-        c.add_cookie_header(req)\n-\n-        h = req.headers.get(\"Cookie\")\n-        self.assert_((\"PART_NUMBER=ROCKET_LAUNCHER_0001\" in h and\n-                      \"CUSTOMER=WILE_E_COYOTE\" in h and\n-                      h.startswith(\"SHIPPING=FEDEX;\")))\n-\n-    def test_netscape_example_2(self):\n-        # Second Example transaction sequence:\n-        #\n-        # Assume all mappings from above have been cleared.\n-        #\n-        # Client receives:\n-        #\n-        #       Set-Cookie: PART_NUMBER=ROCKET_LAUNCHER_0001; path=/\n-        #\n-        # When client requests a URL in path \"/\" on this server, it sends:\n-        #\n-        #       Cookie: PART_NUMBER=ROCKET_LAUNCHER_0001\n-        #\n-        # Client receives:\n-        #\n-        #       Set-Cookie: PART_NUMBER=RIDING_ROCKET_0023; path=/ammo\n-        #\n-        # When client requests a URL in path \"/ammo\" on this server, it sends:\n-        #\n-        #       Cookie: PART_NUMBER=RIDING_ROCKET_0023; PART_NUMBER=ROCKET_LAUNCHER_0001\n-        #\n-        #       NOTE: There are two name/value pairs named \"PART_NUMBER\" due to\n-        #       the inheritance of the \"/\" mapping in addition to the \"/ammo\" mapping.\n-\n-        c = CookieJar()\n-        headers = Headers({'Set-Cookie': 'PART_NUMBER=ROCKET_LAUNCHER_0001; path=/'})\n-\n-        req = Request(\"http://www.acme.com/\")\n-        res = Response(\"http://www.acme.com/\", headers=headers)\n-\n-        c.extract_cookies(res, req)\n-\n-        req = Request(\"http://www.acme.com/\")\n-        c.add_cookie_header(req)\n-\n-        self.assertEquals(req.headers.get(\"Cookie\"), \"PART_NUMBER=ROCKET_LAUNCHER_0001\")\n-\n-        headers.appendlist(\"Set-Cookie\", \"PART_NUMBER=RIDING_ROCKET_0023; path=/ammo\")\n-        res = Response(\"http://www.acme.com/\", headers=headers)\n-        c.extract_cookies(res, req)\n-\n-        req = Request(\"http://www.acme.com/ammo\")\n-        c.add_cookie_header(req)\n-\n-        self.assert_(re.search(r\"PART_NUMBER=RIDING_ROCKET_0023;\\s*\"\n-                               \"PART_NUMBER=ROCKET_LAUNCHER_0001\",\n-                               req.headers.get(\"Cookie\")))\n-\n-    def test_ietf_example_1(self):\n-        #-------------------------------------------------------------------\n-        # Then we test with the examples from draft-ietf-http-state-man-mec-03.txt\n-        #\n-        # 5.  EXAMPLES\n-\n-        c = CookieJar(DefaultCookiePolicy(rfc2965=True))\n-\n-        #\n-        # 5.1  Example 1\n-        #\n-        # Most detail of request and response headers has been omitted.  Assume\n-        # the user agent has no stored cookies.\n-        #\n-        #   1.  User Agent -> Server\n-        #\n-        #       POST /acme/login HTTP/1.1\n-        #       [form data]\n-        #\n-        #       User identifies self via a form.\n-        #\n-        #   2.  Server -> User Agent\n-        #\n-        #       HTTP/1.1 200 OK\n-        #       Set-Cookie2: Customer=\"WILE_E_COYOTE\"; Version=\"1\"; Path=\"/acme\"\n-        #\n-        #       Cookie reflects user's identity.\n-\n-        cookie = interact_2965(\n-            c, 'http://www.acme.com/acme/login',\n-            'Customer=\"WILE_E_COYOTE\"; Version=\"1\"; Path=\"/acme\"')\n-        self.assert_(not cookie)\n-\n-        #\n-        #   3.  User Agent -> Server\n-        #\n-        #       POST /acme/pickitem HTTP/1.1\n-        #       Cookie: $Version=\"1\"; Customer=\"WILE_E_COYOTE\"; $Path=\"/acme\"\n-        #       [form data]\n-        #\n-        #       User selects an item for ``shopping basket.''\n-        #\n-        #   4.  Server -> User Agent\n-        #\n-        #       HTTP/1.1 200 OK\n-        #       Set-Cookie2: Part_Number=\"Rocket_Launcher_0001\"; Version=\"1\";\n-        #               Path=\"/acme\"\n-        #\n-        #       Shopping basket contains an item.\n-\n-        cookie = interact_2965(c, 'http://www.acme.com/acme/pickitem',\n-                               'Part_Number=\"Rocket_Launcher_0001\"; '\n-                               'Version=\"1\"; Path=\"/acme\"');\n-        self.assert_(re.search(\n-            r'^\\$Version=\"?1\"?; Customer=\"?WILE_E_COYOTE\"?; \\$Path=\"/acme\"$',\n-            cookie))\n-\n-        #\n-        #   5.  User Agent -> Server\n-        #\n-        #       POST /acme/shipping HTTP/1.1\n-        #       Cookie: $Version=\"1\";\n-        #               Customer=\"WILE_E_COYOTE\"; $Path=\"/acme\";\n-        #               Part_Number=\"Rocket_Launcher_0001\"; $Path=\"/acme\"\n-        #       [form data]\n-        #\n-        #       User selects shipping method from form.\n-        #\n-        #   6.  Server -> User Agent\n-        #\n-        #       HTTP/1.1 200 OK\n-        #       Set-Cookie2: Shipping=\"FedEx\"; Version=\"1\"; Path=\"/acme\"\n-        #\n-        #       New cookie reflects shipping method.\n-\n-        cookie = interact_2965(c, \"http://www.acme.com/acme/shipping\",\n-                               'Shipping=\"FedEx\"; Version=\"1\"; Path=\"/acme\"')\n-\n-        self.assert_(re.search(r'^\\$Version=\"?1\"?;', cookie))\n-        self.assert_(re.search(r'Part_Number=\"?Rocket_Launcher_0001\"?;'\n-                               '\\s*\\$Path=\"\\/acme\"', cookie))\n-        self.assert_(re.search(r'Customer=\"?WILE_E_COYOTE\"?;\\s*\\$Path=\"\\/acme\"',\n-                               cookie))\n-\n-        #\n-        #   7.  User Agent -> Server\n-        #\n-        #       POST /acme/process HTTP/1.1\n-        #       Cookie: $Version=\"1\";\n-        #               Customer=\"WILE_E_COYOTE\"; $Path=\"/acme\";\n-        #               Part_Number=\"Rocket_Launcher_0001\"; $Path=\"/acme\";\n-        #               Shipping=\"FedEx\"; $Path=\"/acme\"\n-        #       [form data]\n-        #\n-        #       User chooses to process order.\n-        #\n-        #   8.  Server -> User Agent\n-        #\n-        #       HTTP/1.1 200 OK\n-        #\n-        #       Transaction is complete.\n-\n-        cookie = interact_2965(c, \"http://www.acme.com/acme/process\")\n-        self.assert_(\n-            re.search(r'Shipping=\"?FedEx\"?;\\s*\\$Path=\"\\/acme\"', cookie) and\n-            \"WILE_E_COYOTE\" in cookie)\n-\n-        #\n-        # The user agent makes a series of requests on the origin server, after\n-        # each of which it receives a new cookie.  All the cookies have the same\n-        # Path attribute and (default) domain.  Because the request URLs all have\n-        # /acme as a prefix, and that matches the Path attribute, each request\n-        # contains all the cookies received so far.\n-\n-    def test_ietf_example_2(self):\n-        # 5.2  Example 2\n-        #\n-        # This example illustrates the effect of the Path attribute.  All detail\n-        # of request and response headers has been omitted.  Assume the user agent\n-        # has no stored cookies.\n-\n-        c = CookieJar(DefaultCookiePolicy(rfc2965=True))\n-\n-        # Imagine the user agent has received, in response to earlier requests,\n-        # the response headers\n-        #\n-        # Set-Cookie2: Part_Number=\"Rocket_Launcher_0001\"; Version=\"1\";\n-        #         Path=\"/acme\"\n-        #\n-        # and\n-        #\n-        # Set-Cookie2: Part_Number=\"Riding_Rocket_0023\"; Version=\"1\";\n-        #         Path=\"/acme/ammo\"\n-\n-        interact_2965(\n-            c, \"http://www.acme.com/acme/ammo/specific\",\n-            'Part_Number=\"Rocket_Launcher_0001\"; Version=\"1\"; Path=\"/acme\"',\n-            'Part_Number=\"Riding_Rocket_0023\"; Version=\"1\"; Path=\"/acme/ammo\"')\n-\n-        # A subsequent request by the user agent to the (same) server for URLs of\n-        # the form /acme/ammo/...  would include the following request header:\n-        #\n-        # Cookie: $Version=\"1\";\n-        #         Part_Number=\"Riding_Rocket_0023\"; $Path=\"/acme/ammo\";\n-        #         Part_Number=\"Rocket_Launcher_0001\"; $Path=\"/acme\"\n-        #\n-        # Note that the NAME=VALUE pair for the cookie with the more specific Path\n-        # attribute, /acme/ammo, comes before the one with the less specific Path\n-        # attribute, /acme.  Further note that the same cookie name appears more\n-        # than once.\n-\n-        cookie = interact_2965(c, \"http://www.acme.com/acme/ammo/...\")\n-        self.assert_(\n-            re.search(r\"Riding_Rocket_0023.*Rocket_Launcher_0001\", cookie))\n-\n-        # A subsequent request by the user agent to the (same) server for a URL of\n-        # the form /acme/parts/ would include the following request header:\n-        #\n-        # Cookie: $Version=\"1\"; Part_Number=\"Rocket_Launcher_0001\"; $Path=\"/acme\"\n-        #\n-        # Here, the second cookie's Path attribute /acme/ammo is not a prefix of\n-        # the request URL, /acme/parts/, so the cookie does not get forwarded to\n-        # the server.\n-\n-        cookie = interact_2965(c, \"http://www.acme.com/acme/parts/\")\n-        self.assert_(\"Rocket_Launcher_0001\" in cookie and\n-                     \"Riding_Rocket_0023\" not in cookie)\n-\n-    def test_url_encoding(self):\n-        # Try some URL encodings of the PATHs.\n-        # (the behaviour here has changed from libwww-perl)\n-\n-        c = CookieJar(DefaultCookiePolicy(rfc2965=True))\n-        interact_2965(c, \"http://www.acme.com/foo%2f%25/%3c%3c%0Anew%E5/%E5\",\n-                      \"foo  =   bar; version    =   1\")\n-\n-        cookie = interact_2965(\n-            c, \"http://www.acme.com/foo%2f%25/<<%0anew\\xc3\\xa5/\\xc3\\xa6\\xc3\\xb8\\xc3\\xa5\",\n-            'bar=baz; path=\"/foo/\"; version=1');\n-        version_re = re.compile(r'^\\$version=\\\"?1\\\"?', re.I)\n-        # FIXME: test disabled until fix\n-        #self.assert_(\"foo=bar\" in cookie and version_re.search(cookie))\n-\n-        cookie = interact_2965(\n-            c, \"http://www.acme.com/foo/%25/<<%0anew\\xc3\\xa5/\\xc3\\xa6\\xc3\\xb8\\xc3\\xa5\")\n-        self.assert_(not cookie)\n-\n-        # unicode URL doesn't raise exception\n-        ## NOTE: this test is commented because it doesn't really test anything\n-        ## useful any it conflicts with Scrapy management of response urls which\n-        ## are not allowed to be unicode (except for encoding-aware responses)\n-        #cookie = interact_2965(c, u\"http://www.acme.com/\\xfc\")\n-\n-    def test_netscape_misc(self):\n-        # Some additional Netscape cookies tests.\n-        c = CookieJar()\n-        headers = Headers()\n-        req = Request(\"http://foo.bar.acme.com/foo\")\n-\n-        # Netscape allows a host part that contains dots\n-        headers.appendlist(\"Set-Cookie\", \"Customer=WILE_E_COYOTE; domain=.acme.com\")\n-        res = Response(\"http://www.acme.com/foo\", headers=headers)\n-        c.extract_cookies(res, req)\n-\n-        # and that the domain is the same as the host without adding a leading\n-        # dot to the domain.  Should not quote even if strange chars are used\n-        # in the cookie value.\n-        headers.appendlist(\"Set-Cookie\", \"PART_NUMBER=3,4; domain=foo.bar.acme.com\")\n-        res = Response(\"http://www.acme.com/foo\", headers=headers)\n-        c.extract_cookies(res, req)\n-\n-        req = Request(\"http://foo.bar.acme.com/foo\")\n-        c.add_cookie_header(req)\n-        self.assert_(\n-            \"PART_NUMBER=3,4\" in req.headers.get(\"Cookie\") and\n-            \"Customer=WILE_E_COYOTE\" in req.headers.get(\"Cookie\"))\n-\n-    def test_intranet_domains_2965(self):\n-        # Test handling of local intranet hostnames without a dot.\n-        c = CookieJar(DefaultCookiePolicy(rfc2965=True))\n-        interact_2965(c, \"http://example/\",\n-                      \"foo1=bar; PORT; Discard; Version=1;\")\n-        cookie = interact_2965(c, \"http://example/\",\n-                               'foo2=bar; domain=\".local\"; Version=1')\n-        self.assert_(\"foo1=bar\" in cookie)\n-\n-        interact_2965(c, \"http://example/\", 'foo3=bar; Version=1')\n-        cookie = interact_2965(c, \"http://example/\")\n-        self.assert_(\"foo2=bar\" in cookie and len(c) == 3)\n-\n-    def test_intranet_domains_ns(self):\n-        c = CookieJar(DefaultCookiePolicy(rfc2965 = False))\n-        interact_netscape(c, \"http://example/\", \"foo1=bar\")\n-        cookie = interact_netscape(c, \"http://example/\",\n-                                   'foo2=bar; domain=.local')\n-        self.assertEquals(len(c), 2)\n-        self.assert_(\"foo1=bar\" in cookie)\n-\n-        cookie = interact_netscape(c, \"http://example/\")\n-        self.assert_(\"foo2=bar\" in cookie)\n-        self.assertEquals(len(c), 2)\n-\n-    def test_empty_path(self):\n-        # Test for empty path\n-        # Broken web-server ORION/1.3.38 returns to the client response like\n-        #\n-        #       Set-Cookie: JSESSIONID=ABCDERANDOM123; Path=\n-        #\n-        # ie. with Path set to nothing.\n-        # In this case, extract_cookies() must set cookie to / (root)\n-        c = CookieJar(DefaultCookiePolicy(rfc2965 = True))\n-        headers = Headers({'Set-Cookie': 'JSESSIONID=ABCDERANDOM123; Path='})\n-\n-        req = Request(\"http://www.ants.com/\")\n-        res = Response(\"http://www.ants.com/\", headers=headers)\n-        c.extract_cookies(res, req)\n-\n-        req = Request(\"http://www.ants.com/\")\n-        c.add_cookie_header(req)\n-\n-        self.assertEquals(req.headers.get(\"Cookie\"),\n-                          \"JSESSIONID=ABCDERANDOM123\")\n-        self.assertEquals(req.headers.get(\"Cookie2\"), '$Version=\"1\"')\n-\n-        # missing path in the request URI\n-        req = Request(\"http://www.ants.com:8080\")\n-        c.add_cookie_header(req)\n-\n-        self.assertEquals(req.headers.get(\"Cookie\"),\n-                          \"JSESSIONID=ABCDERANDOM123\")\n-        self.assertEquals(req.headers.get(\"Cookie2\"), '$Version=\"1\"')\n-\n-    def test_session_cookies(self):\n-        year_plus_one = time.localtime()[0] + 1\n-\n-        # Check session cookies are deleted properly by\n-        # CookieJar.clear_session_cookies method\n-\n-        req = Request('http://www.perlmeister.com/scripts')\n-        headers = Headers()\n-        headers.appendlist(\"Set-Cookie\", \"s1=session;Path=/scripts\")\n-        headers.appendlist(\"Set-Cookie\", \"p1=perm; Domain=.perlmeister.com;Path=/;expires=Fri, 02-Feb-%d 23:24:20 GMT\" % year_plus_one)\n-        headers.appendlist(\"Set-Cookie\", \"p2=perm;Path=/;expires=Fri, 02-Feb-%d 23:24:20 GMT\" % year_plus_one)\n-        headers.appendlist(\"Set-Cookie\", \"s2=session;Path=/scripts;\" \"Domain=.perlmeister.com\")\n-        headers.appendlist('Set-Cookie2', 's3=session;Version=1;Discard;Path=\"/\"')\n-        res = Response('http://www.perlmeister.com/scripts', headers=headers)\n-\n-        c = CookieJar()\n-        c.extract_cookies(res, req)\n-        # How many session/permanent cookies do we have?\n-        counter = {\"session_after\": 0,\n-                   \"perm_after\": 0,\n-                   \"session_before\": 0,\n-                   \"perm_before\": 0}\n-        for cookie in c:\n-            key = \"%s_before\" % cookie.value\n-            counter[key] = counter[key] + 1\n-        c.clear_session_cookies()\n-        # How many now?\n-        for cookie in c:\n-            key = \"%s_after\" % cookie.value\n-            counter[key] = counter[key] + 1\n-\n-        self.assert_(not (\n-            # a permanent cookie got lost accidently\n-            counter[\"perm_after\"] != counter[\"perm_before\"] or\n-            # a session cookie hasn't been cleared\n-            counter[\"session_after\"] != 0 or\n-            # we didn't have session cookies in the first place\n-            counter[\"session_before\"] == 0))\n-\n-    def testMalformedCookieHeaderParsing(self):\n-        headers = Headers({'Set-Cookie': [\n-            'CUSTOMER=WILE_E_COYOTE; path=/; expires=Wednesday, 09-Nov-2100 23:12:40 GMT',\n-            'PART_NUMBER=ROCKET_LAUNCHER_0001; path=/',\n-            'SHIPPING=FEDEX; path=/foo',\n-            'COUNTRY=UY; path=/foo',\n-            'GOOD_CUSTOMER;',\n-            'NO_A_BOT;']})\n-        res = Response('http://www.perlmeister.com/foo', headers=headers)\n-        req = Request('http://www.perlmeister.com/foo')\n-\n-        c = CookieJar()\n-        c.extract_cookies(res, req)\n-        c.add_cookie_header(req)\n-        self.assertEquals(req.headers.get('Cookie'),\n-                'COUNTRY=UY; SHIPPING=FEDEX; CUSTOMER=WILE_E_COYOTE; '\n-                'PART_NUMBER=ROCKET_LAUNCHER_0001; NO_A_BOT; GOOD_CUSTOMER')\n-\n-\n-class CookielibWrappersTest(TestCase):\n-\n-    def FakeRequest(self, url, data='', headers={}):\n-        tail = '?' + urllib.quote(data) if data else ''\n-        return WrappedRequest(Request('%s%s' % (url, tail), headers=headers))\n-\n-    def test_request_path(self):\n-        from cookielib import request_path\n-        # with parameters\n-        req = self.FakeRequest(\"http://www.example.com/rheum/rhaponicum;\"\n-                      \"foo=bar;sing=song?apples=pears&spam=eggs#ni\")\n-        self.assertEquals(request_path(req), \"/rheum/rhaponicum;\"\n-                     \"foo=bar;sing=song?apples=pears&spam=eggs#ni\")\n-        # without parameters\n-        req = self.FakeRequest(\"http://www.example.com/rheum/rhaponicum?\"\n-                      \"apples=pears&spam=eggs#ni\")\n-        self.assertEquals(request_path(req), \"/rheum/rhaponicum?\"\n-                     \"apples=pears&spam=eggs#ni\")\n-        # missing final slash\n-        req = self.FakeRequest(\"http://www.example.com\")\n-        self.assertEquals(request_path(req), \"/\")\n-\n-    def test_request_port(self):\n-        from cookielib import request_port, DEFAULT_HTTP_PORT\n-        req = self.FakeRequest(\"http://www.acme.com:1234/\", headers={\"Host\": \"www.acme.com:4321\"})\n-        self.assertEquals(request_port(req), \"1234\")\n-        req = self.FakeRequest(\"http://www.acme.com/\", headers={\"Host\": \"www.acme.com:4321\"})\n-        self.assertEquals(request_port(req), DEFAULT_HTTP_PORT)\n-\n-    def test_request_host(self):\n-        from cookielib import request_host\n-        # this request is illegal (RFC2616, 14.2.3)\n-        req = self.FakeRequest(\"http://1.1.1.1/\", headers={\"Host\": \"www.acme.com:80\"})\n-        # libwww-perl wants this response, but that seems wrong (RFC 2616,\n-        # section 5.2, point 1., and RFC 2965 section 1, paragraph 3)\n-        #self.assertEquals(request_host(req), \"www.acme.com\")\n-        self.assertEquals(request_host(req), \"1.1.1.1\")\n-        req = self.FakeRequest(\"http://www.acme.com/\", headers={\"Host\": \"irrelevant.com\"})\n-        self.assertEquals(request_host(req), \"www.acme.com\")\n-        # not actually sure this one is valid Request object, so maybe should\n-        # remove test for no host in url in request_host function?\n-        req = self.FakeRequest(\"/resource.html\", headers={\"Host\": \"www.acme.com\"})\n-        self.assertEquals(request_host(req), \"www.acme.com\")\n-        # port shouldn't be in request-host\n-        req = self.FakeRequest(\"http://www.acme.com:2345/resource.html\", headers={\"Host\": \"www.acme.com:5432\"})\n-        self.assertEquals(request_host(req), \"www.acme.com\")\n-\n-    def test_threadlock_override(self):\n-        try:\n-            import threading as _threading\n-        except ImportError:\n-            import dummy_threading as _threading\n-\n-        c = CookieJar()\n-        assert not isinstance(c.jar._cookies_lock, _threading._RLock)\n+    def setUp(self):\n+        self.response = Response(\"http://www.example.com/page.html\", \n+            headers={\"Content-TYpe\": \"text/html\"})\n+        self.wrapped = WrappedResponse(self.response)\n \n+    def test_info(self):\n+        self.assert_(self.wrapped.info() is self.wrapped)\n \n+    def test_getheaders(self):\n+        self.assertEqual(self.wrapped.getheaders('content-type'), ['text/html'])\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
