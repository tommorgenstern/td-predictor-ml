{"custom_id": "flask#5909e26fba86351063bd622cedf6a4c25eba2e79", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 2443 | Contributors (this commit): 24 | Commits (past 90d): 17 | Contributors (cumulative): 24 | DMM Complexity: None\n\nDIFF:\n@@ -9,7 +9,6 @@\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n \n-import pickle\n import re\n import time\n import uuid\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#a417e41d27cc14a0fe74dc49840b8921aeed70b6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 56 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 3 | Methods Changed: 10 | Complexity Δ (Sum/Max): 7/7 | Churn Δ: 59 | Churn Cumulative: 5287 | Contributors (this commit): 89 | Commits (past 90d): 30 | Contributors (cumulative): 95 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1484,8 +1484,10 @@ class Flask(_PackageBoundObject):\n         Since a request context typically also manages an application\n         context it would also be called when you pop a request context.\n \n-        When a teardown function was called because of an exception it will\n-        be passed an error object.\n+        When a teardown function was called because of an unhandled exception\n+        it will be passed an error object.  Note that if a :meth:`errorhandler`\n+        is registered, it will handle the exception and the teardown will not\n+        receive it.\n \n         The return values of teardown functions are ignored.\n \n\n@@ -81,7 +81,7 @@ def test_app_tearing_down_with_previous_exception(app):\n     assert cleanup_stuff == [None]\n \n \n-def test_app_tearing_down_with_handled_exception(app):\n+def test_app_tearing_down_with_handled_exception_by_except_block(app):\n     cleanup_stuff = []\n \n     @app.teardown_appcontext\n@@ -97,6 +97,57 @@ def test_app_tearing_down_with_handled_exception(app):\n     assert cleanup_stuff == [None]\n \n \n+def test_app_tearing_down_with_handled_exception_by_app_handler(app):\n+    cleanup_stuff = []\n+\n+    class AppConfig():\n+        PROPAGATE_EXCEPTIONS = True\n+    app.config.from_object(AppConfig())\n+\n+    @app.teardown_appcontext\n+    def cleanup(exception):\n+        cleanup_stuff.append(exception)\n+\n+    @app.route('/')\n+    def index():\n+        raise Exception('dummy')\n+\n+    @app.errorhandler(Exception)\n+    def handler(f):\n+        return flask.jsonify(str(f))\n+\n+    test_client = app.test_client()\n+    with app.app_context():\n+        test_client.get('/')\n+\n+    assert cleanup_stuff == [None]\n+\n+\n+def test_app_tearing_down_with_unhandled_exception(app):\n+    cleanup_stuff = []\n+\n+    class AppConfig():\n+        PROPAGATE_EXCEPTIONS = True\n+    app.config.from_object(AppConfig())\n+\n+    @app.teardown_appcontext\n+    def cleanup(exception):\n+        cleanup_stuff.append(exception)\n+\n+    @app.route('/')\n+    def index():\n+        raise Exception('dummy')\n+\n+    test_client = app.test_client()\n+    with pytest.raises(Exception):\n+        with app.app_context():\n+            test_client.get('/')\n+\n+    assert len(cleanup_stuff) == 1\n+    assert isinstance(cleanup_stuff[0], Exception)\n+    assert str(cleanup_stuff[0]) == 'dummy'\n+\n+\n def test_app_ctx_globals_methods(app, app_ctx):\n     # get\n     assert flask.g.get('foo') is None\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#9560f22bb65d7c06d10ea3dfe3d7a81a73f68af2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 8 | Lines Deleted: 16 | Files Changed: 2 | Hunks: 9 | Methods Changed: 5 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 24 | Churn Cumulative: 5311 | Contributors (this commit): 89 | Commits (past 90d): 32 | Contributors (cumulative): 96 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1485,8 +1485,8 @@ class Flask(_PackageBoundObject):\n         context it would also be called when you pop a request context.\n \n         When a teardown function was called because of an unhandled exception\n-        it will be passed an error object.  Note that if a :meth:`errorhandler`\n-        is registered, it will handle the exception and the teardown will not\n+        it will be passed an error object. If an :meth:`errorhandler` is\n+        registered, it will handle the exception and the teardown will not\n         receive it.\n \n         The return values of teardown functions are ignored.\n\n@@ -97,13 +97,10 @@ def test_app_tearing_down_with_handled_exception_by_except_block(app):\n     assert cleanup_stuff == [None]\n \n \n-def test_app_tearing_down_with_handled_exception_by_app_handler(app):\n+def test_app_tearing_down_with_handled_exception_by_app_handler(app, client):\n+    app.config['PROPAGATE_EXCEPTIONS'] = True\n     cleanup_stuff = []\n \n-    class AppConfig():\n-        PROPAGATE_EXCEPTIONS = True\n-    app.config.from_object(AppConfig())\n-\n     @app.teardown_appcontext\n     def cleanup(exception):\n         cleanup_stuff.append(exception)\n@@ -116,20 +113,16 @@ def test_app_tearing_down_with_handled_exception_by_app_handler(app):\n     def handler(f):\n         return flask.jsonify(str(f))\n \n-    test_client = app.test_client()\n     with app.app_context():\n-        test_client.get('/')\n+        client.get('/')\n \n     assert cleanup_stuff == [None]\n \n \n-def test_app_tearing_down_with_unhandled_exception(app):\n+def test_app_tearing_down_with_unhandled_exception(app, client):\n+    app.config['PROPAGATE_EXCEPTIONS'] = True\n     cleanup_stuff = []\n \n-    class AppConfig():\n-        PROPAGATE_EXCEPTIONS = True\n-    app.config.from_object(AppConfig())\n-\n     @app.teardown_appcontext\n     def cleanup(exception):\n         cleanup_stuff.append(exception)\n@@ -138,10 +131,9 @@ def test_app_tearing_down_with_unhandled_exception(app):\n     def index():\n         raise Exception('dummy')\n \n-    test_client = app.test_client()\n     with pytest.raises(Exception):\n         with app.app_context():\n-            test_client.get('/')\n+            client.get('/')\n \n     assert len(cleanup_stuff) == 1\n     assert isinstance(cleanup_stuff[0], Exception)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#59f7966e3192bcf478a213ba0aa9cd3bda7da4e4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 47 | Lines Deleted: 7 | Files Changed: 2 | Hunks: 6 | Methods Changed: 3 | Complexity Δ (Sum/Max): 7/5 | Churn Δ: 54 | Churn Cumulative: 830 | Contributors (this commit): 16 | Commits (past 90d): 9 | Contributors (cumulative): 21 | DMM Complexity: 0.03125\n\nDIFF:\n@@ -144,19 +144,41 @@ class FlaskClient(Client):\n             self.cookie_jar.extract_wsgi(c.request.environ, headers)\n \n     def open(self, *args, **kwargs):\n-        kwargs.setdefault('environ_overrides', {}) \\\n-            ['flask._preserve_context'] = self.preserve_context\n-        kwargs.setdefault('environ_base', self.environ_base)\n-\n         as_tuple = kwargs.pop('as_tuple', False)\n         buffered = kwargs.pop('buffered', False)\n         follow_redirects = kwargs.pop('follow_redirects', False)\n-        builder = make_test_environ_builder(self.application, *args, **kwargs)\n \n-        return Client.open(self, builder,\n+        if (\n+            not kwargs and len(args) == 1\n+            and isinstance(args[0], (EnvironBuilder, dict))\n+        ):\n+            environ = self.environ_base.copy()\n+\n+            if isinstance(args[0], EnvironBuilder):\n+                environ.update(args[0].get_environ())\n+            else:\n+                environ.update(args[0])\n+\n+            environ['flask._preserve_context'] = self.preserve_context\n+        else:\n+            kwargs.setdefault('environ_overrides', {}) \\\n+                ['flask._preserve_context'] = self.preserve_context\n+            kwargs.setdefault('environ_base', self.environ_base)\n+            builder = make_test_environ_builder(\n+                self.application, *args, **kwargs\n+            )\n+\n+            try:\n+                environ = builder.get_environ()\n+            finally:\n+                builder.close()\n+\n+        return Client.open(\n+            self, environ,\n             as_tuple=as_tuple,\n             buffered=buffered,\n-                           follow_redirects=follow_redirects)\n+            follow_redirects=follow_redirects\n+        )\n \n     def __enter__(self):\n         if self.preserve_context:\n\n@@ -15,6 +15,7 @@ import werkzeug\n \n from flask._compat import text_type\n from flask.json import jsonify\n+from flask.testing import make_test_environ_builder\n \n \n def test_environ_defaults_from_config(app, client):\n@@ -74,6 +75,23 @@ def test_environ_base_modified(app, client, app_ctx):\n     assert flask.g.user_agent == 'Bar'\n \n \n+def test_client_open_environ(app, client, request):\n+    @app.route('/index')\n+    def index():\n+        return flask.request.remote_addr\n+\n+    builder = make_test_environ_builder(app, path='/index', method='GET')\n+    request.addfinalizer(builder.close)\n+\n+    rv = client.open(builder)\n+    assert rv.data == b'127.0.0.1'\n+\n+    environ = builder.get_environ()\n+    client.environ_base['REMOTE_ADDR'] = '127.0.0.2'\n+    rv = client.open(environ)\n+    assert rv.data == b'127.0.0.2'\n+\n+\n def test_specify_url_scheme(app, client):\n     @app.route('/')\n     def index():\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#fb845b90328278f4a557f898024a53800752fd53", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 152 | Lines Deleted: 149 | Files Changed: 6 | Hunks: 42 | Methods Changed: 20 | Complexity Δ (Sum/Max): -3/2 | Churn Δ: 301 | Churn Cumulative: 2842 | Contributors (this commit): 32 | Commits (past 90d): 33 | Contributors (cumulative): 47 | DMM Complexity: 0.578125\n\nDIFF:\n@@ -130,7 +130,7 @@ def find_app_by_string(string, script_info, module):\n             if isinstance(app, Flask):\n                 return app\n             else:\n-                raise RuntimeError('Failed to find application in module '\n+                raise NoAppException('Failed to find application in module '\n                                    '\"{name}\"'.format(name=module))\n         except TypeError as e:\n             new_error = NoAppException(\n@@ -147,85 +147,61 @@ def find_app_by_string(string, script_info, module):\n             'or function expression.'.format(string=string))\n \n \n-def prepare_exec_for_file(filename):\n+def prepare_import(path):\n     \"\"\"Given a filename this will try to calculate the python path, add it\n     to the search path and return the actual module name that is expected.\n     \"\"\"\n-    module = []\n+    path = os.path.realpath(path)\n \n-    # Chop off file extensions or package markers\n-    if os.path.split(filename)[1] == '__init__.py':\n-        filename = os.path.dirname(filename)\n-    elif filename.endswith('.py'):\n-        filename = filename[:-3]\n-    else:\n-        raise NoAppException('The file provided (%s) does exist but is not a '\n-                             'valid Python file.  This means that it cannot '\n-                             'be used as application.  Please change the '\n-                             'extension to .py' % filename)\n-    filename = os.path.realpath(filename)\n+    if os.path.splitext(path)[1] == '.py':\n+        path = os.path.splitext(path)[0]\n \n-    dirpath = filename\n-    while 1:\n-        dirpath, extra = os.path.split(dirpath)\n-        module.append(extra)\n-        if not os.path.isfile(os.path.join(dirpath, '__init__.py')):\n+    if os.path.basename(path) == '__init__':\n+        path = os.path.dirname(path)\n+\n+    module_name = []\n+\n+    # move up until outside package structure (no __init__.py)\n+    while True:\n+        path, name = os.path.split(path)\n+        module_name.append(name)\n+\n+        if not os.path.exists(os.path.join(path, '__init__.py')):\n             break\n \n-    if sys.path[0] != dirpath:\n-        sys.path.insert(0, dirpath)\n+    if sys.path[0] != path:\n+        sys.path.insert(0, path)\n \n-    return '.'.join(module[::-1])\n+    return '.'.join(module_name[::-1])\n \n \n-def locate_app(script_info, app_id, raise_if_not_found=True):\n+def locate_app(script_info, module_name, app_name, raise_if_not_found=True):\n     \"\"\"Attempts to locate the application.\"\"\"\n     __traceback_hide__ = True\n \n-    if ':' in app_id:\n-        module, app_obj = app_id.split(':', 1)\n-    else:\n-        module = app_id\n-        app_obj = None\n-\n     try:\n-        __import__(module)\n+        __import__(module_name)\n     except ImportError:\n         # Reraise the ImportError if it occurred within the imported module.\n         # Determine this by checking whether the trace has a depth > 1.\n         if sys.exc_info()[-1].tb_next:\n-            stack_trace = traceback.format_exc()\n             raise NoAppException(\n-                'There was an error trying to import the app ({module}):\\n'\n-                '{stack_trace}'.format(\n-                    module=module, stack_trace=stack_trace\n-                )\n+                'While importing \"{name}\", an ImportError was raised:'\n+                '\\n\\n{tb}'.format(name=module_name, tb=traceback.format_exc())\n             )\n         elif raise_if_not_found:\n             raise NoAppException(\n-                'The file/path provided ({module}) does not appear to exist.'\n-                ' Please verify the path is correct. If app is not on'\n-                ' PYTHONPATH, ensure the extension is .py.'.format(\n-                    module=module)\n+                'Could not import \"{name}\".\"'.format(name=module_name)\n             )\n         else:\n             return\n \n-    mod = sys.modules[module]\n+    module = sys.modules[module_name]\n \n-    if app_obj is None:\n-        return find_best_app(script_info, mod)\n+    if app_name is None:\n+        return find_best_app(script_info, module)\n     else:\n-        return find_app_by_string(app_obj, script_info, mod)\n-\n-\n-def find_default_import_path():\n-    app = os.environ.get('FLASK_APP')\n-    if app is None:\n-        return\n-    if os.path.isfile(app):\n-        return prepare_exec_for_file(app)\n-    return app\n+        return find_app_by_string(app_name, script_info, module)\n \n \n def get_version(ctx, param, value):\n@@ -308,15 +284,8 @@ class ScriptInfo(object):\n     \"\"\"\n \n     def __init__(self, app_import_path=None, create_app=None):\n-        if create_app is None:\n-            if app_import_path is None:\n-                app_import_path = find_default_import_path()\n-            self.app_import_path = app_import_path\n-        else:\n-            app_import_path = None\n-\n         #: Optionally the import path for the Flask application.\n-        self.app_import_path = app_import_path\n+        self.app_import_path = app_import_path or os.environ.get('FLASK_APP')\n         #: Optionally a function that is passed the script info to create\n         #: the instance of the application.\n         self.create_app = create_app\n@@ -335,37 +304,39 @@ class ScriptInfo(object):\n         if self._loaded_app is not None:\n             return self._loaded_app\n \n+        app = None\n+\n         if self.create_app is not None:\n-            rv = call_factory(self.create_app, self)\n+            app = call_factory(self.create_app, self)\n         else:\n             if self.app_import_path:\n-                rv = locate_app(self, self.app_import_path)\n+                path, name = (self.app_import_path.split(':', 1) + [None])[:2]\n+                import_name = prepare_import(path)\n+                app = locate_app(self, import_name, name)\n             else:\n-                for module in ['wsgi.py', 'app.py']:\n-                    import_path = prepare_exec_for_file(module)\n-                    rv = locate_app(\n-                        self, import_path, raise_if_not_found=False\n+                for path in ('wsgi.py', 'app.py'):\n+                    import_name = prepare_import(path)\n+                    app = locate_app(\n+                        self, import_name, None, raise_if_not_found=False\n                     )\n \n-                    if rv:\n+                    if app:\n                         break\n \n-            if not rv:\n+        if not app:\n             raise NoAppException(\n-                    'Could not locate Flask application. You did not provide '\n-                    'the FLASK_APP environment variable, and a wsgi.py or '\n-                    'app.py module was not found in the current directory.\\n\\n'\n-                    'For more information see '\n-                    'http://flask.pocoo.org/docs/latest/quickstart/'\n+                'Could not locate a Flask application. You did not provide '\n+                'the \"FLASK_APP\" environment variable, and a \"wsgi.py\" or '\n+                '\"app.py\" module was not found in the current directory.'\n             )\n \n         debug = get_debug_flag()\n \n         if debug is not None:\n-            rv._reconfigure_for_run_debug(debug)\n+            app._reconfigure_for_run_debug(debug)\n \n-        self._loaded_app = rv\n-        return rv\n+        self._loaded_app = app\n+        return app\n \n \n pass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)\n\n@@ -4,12 +4,12 @@ from flask import Flask\n \n \n def create_app():\n-    return Flask('create_app')\n+    return Flask('app')\n \n \n def create_app2(foo, bar):\n-    return Flask(\"_\".join(['create_app2', foo, bar]))\n+    return Flask('_'.join(['app2', foo, bar]))\n \n \n-def create_app3(foo, bar, script_info):\n-    return Flask(\"_\".join(['create_app3', foo, bar]))\n+def create_app3(foo, script_info):\n+    return Flask('_'.join(['app3', foo, script_info.data['test']]))\n\n@@ -0,0 +1,3 @@\n+from flask import Flask\n+\n+application = Flask(__name__)\n\n\n@@ -0,0 +1,3 @@\n+from flask import Flask\n+\n+app = Flask(__name__)\n\n@@ -11,7 +11,8 @@\n # the Revised BSD License.\n # Copyright (C) 2015 CERN.\n #\n-from __future__ import absolute_import, print_function\n+from __future__ import absolute_import\n+\n import os\n import sys\n from functools import partial\n@@ -19,11 +20,10 @@ from functools import partial\n import click\n import pytest\n from click.testing import CliRunner\n-from flask import Flask, current_app\n \n-from flask.cli import cli, AppGroup, FlaskGroup, NoAppException, ScriptInfo, \\\n-    find_best_app, locate_app, with_appcontext, prepare_exec_for_file, \\\n-    find_default_import_path, get_version\n+from flask import Flask, current_app\n+from flask.cli import AppGroup, FlaskGroup, NoAppException, ScriptInfo, \\\n+    find_best_app, get_version, locate_app, prepare_import, with_appcontext\n \n \n @pytest.fixture\n@@ -125,78 +125,104 @@ def test_find_best_app(test_apps):\n     pytest.raises(NoAppException, find_best_app, script_info, Module)\n \n \n-def test_prepare_exec_for_file(test_apps):\n-    \"\"\"Expect the correct path to be set and the correct module name to be returned.\n+cwd = os.getcwd()\n+test_path = os.path.abspath(os.path.join(\n+    os.path.dirname(__file__), 'test_apps'\n+))\n \n-    :func:`prepare_exec_for_file` has a side effect, where\n-    the parent directory of given file is added to `sys.path`.\n+\n+@pytest.mark.parametrize('value,path,result', (\n+    ('test', cwd, 'test'),\n+    ('test.py', cwd, 'test'),\n+    ('a/test', os.path.join(cwd, 'a'), 'test'),\n+    ('test/__init__.py', cwd, 'test'),\n+    ('test/__init__', cwd, 'test'),\n+    # nested package\n+    (\n+        os.path.join(test_path, 'cliapp', 'inner1', '__init__'),\n+        test_path, 'cliapp.inner1'\n+    ),\n+    (\n+        os.path.join(test_path, 'cliapp', 'inner1', 'inner2'),\n+        test_path, 'cliapp.inner1.inner2'\n+    ),\n+    # dotted name\n+    ('test.a.b', cwd, 'test.a.b'),\n+    (os.path.join(test_path, 'cliapp.app'), test_path, 'cliapp.app'),\n+    # not a Python file, will be caught during import\n+    (\n+        os.path.join(test_path, 'cliapp', 'message.txt'),\n+        test_path, 'cliapp.message.txt'\n+    ),\n+))\n+def test_prepare_import(request, value, path, result):\n+    \"\"\"Expect the correct path to be set and the correct import and app names\n+    to be returned.\n+\n+    :func:`prepare_exec_for_file` has a side effect where the parent directory\n+    of the given import is added to :data:`sys.path`. This is reset after the\n+    test runs.\n     \"\"\"\n-    realpath = os.path.realpath('/tmp/share/test.py')\n-    dirname = os.path.dirname(realpath)\n-    assert prepare_exec_for_file('/tmp/share/test.py') == 'test'\n-    assert dirname in sys.path\n+    original_path = sys.path[:]\n \n-    realpath = os.path.realpath('/tmp/share/__init__.py')\n-    dirname = os.path.dirname(os.path.dirname(realpath))\n-    assert prepare_exec_for_file('/tmp/share/__init__.py') == 'share'\n-    assert dirname in sys.path\n+    def reset_path():\n+        sys.path[:] = original_path\n+\n+    request.addfinalizer(reset_path)\n+\n+    assert prepare_import(value) == result\n+    assert sys.path[0] == path\n+\n+\n+@pytest.mark.parametrize('iname,aname,result', (\n+    ('cliapp.app', None, 'testapp'),\n+    ('cliapp.app', 'testapp', 'testapp'),\n+    ('cliapp.factory', None, 'app'),\n+    ('cliapp.factory', 'create_app', 'app'),\n+    ('cliapp.factory', 'create_app()', 'app'),\n+    # no script_info\n+    ('cliapp.factory', 'create_app2(\"foo\", \"bar\")', 'app2_foo_bar'),\n+    # trailing comma space\n+    ('cliapp.factory', 'create_app2(\"foo\", \"bar\", )', 'app2_foo_bar'),\n+    # takes script_info\n+    ('cliapp.factory', 'create_app3(\"foo\")', 'app3_foo_spam'),\n+))\n+def test_locate_app(test_apps, iname, aname, result):\n+    info = ScriptInfo()\n+    info.data['test'] = 'spam'\n+    assert locate_app(info, iname, aname).name == result\n+\n+\n+@pytest.mark.parametrize('iname,aname', (\n+    ('notanapp.py', None),\n+    ('cliapp/app', None),\n+    ('cliapp.app', 'notanapp'),\n+    # not enough arguments\n+    ('cliapp.factory', 'create_app2(\"foo\")'),\n+    # nested import error\n+    ('cliapp.importerrorapp', None),\n+    # not a Python file\n+    ('cliapp.message.txt', None),\n+    # space before arg list\n+    ('cliapp.factory', 'create_app ()'),\n+))\n+def test_locate_app_raises(test_apps, iname, aname):\n+    info = ScriptInfo()\n \n     with pytest.raises(NoAppException):\n-        prepare_exec_for_file('/tmp/share/test.txt')\n+        locate_app(info, iname, aname)\n \n \n-def test_locate_app(test_apps):\n-    \"\"\"Test of locate_app.\"\"\"\n-    script_info = ScriptInfo()\n-    assert locate_app(script_info, \"cliapp.app\").name == \"testapp\"\n-    assert locate_app(script_info, \"cliapp.app:testapp\").name == \"testapp\"\n-    assert locate_app(script_info, \"cliapp.factory\").name == \"create_app\"\n-    assert locate_app(\n-        script_info, \"cliapp.factory\").name == \"create_app\"\n-    assert locate_app(\n-        script_info, \"cliapp.factory:create_app\").name == \"create_app\"\n-    assert locate_app(\n-        script_info, \"cliapp.factory:create_app()\").name == \"create_app\"\n-    assert locate_app(\n-        script_info, \"cliapp.factory:create_app2('foo', 'bar')\"\n-    ).name == \"create_app2_foo_bar\"\n-    assert locate_app(\n-        script_info, \"cliapp.factory:create_app2('foo', 'bar', )\"\n-    ).name == \"create_app2_foo_bar\"\n-    assert locate_app(\n-        script_info, \"cliapp.factory:create_app3('baz', 'qux')\"\n-    ).name == \"create_app3_baz_qux\"\n-    assert locate_app(script_info, \"cliapp.multiapp:app1\").name == \"app1\"\n-    pytest.raises(\n-        NoAppException, locate_app, script_info, \"notanpp.py\")\n-    pytest.raises(\n-        NoAppException, locate_app, script_info, \"cliapp/app\")\n-    pytest.raises(\n-        RuntimeError, locate_app, script_info, \"cliapp.app:notanapp\")\n-    pytest.raises(\n-        NoAppException, locate_app,\n-        script_info, \"cliapp.factory:create_app2('foo')\")\n-    pytest.raises(\n-        NoAppException, locate_app,\n-        script_info, \"cliapp.factory:create_app ()\")\n-    pytest.raises(\n-        NoAppException, locate_app, script_info, \"cliapp.importerrorapp\")\n-    assert locate_app(\n-        script_info, \"notanpp.py\", raise_if_not_found=False\n-    ) is None\n+def test_locate_app_suppress_raise():\n+    info = ScriptInfo()\n+    app = locate_app(info, 'notanapp.py', None, raise_if_not_found=False)\n+    assert app is None\n \n-\n-def test_find_default_import_path(test_apps, monkeypatch, tmpdir):\n-    \"\"\"Test of find_default_import_path.\"\"\"\n-    monkeypatch.delitem(os.environ, 'FLASK_APP', raising=False)\n-    assert find_default_import_path() == None\n-    monkeypatch.setitem(os.environ, 'FLASK_APP', 'notanapp')\n-    assert find_default_import_path() == 'notanapp'\n-    tmpfile = tmpdir.join('testapp.py')\n-    tmpfile.write('')\n-    monkeypatch.setitem(os.environ, 'FLASK_APP', str(tmpfile))\n-    expect_rv = prepare_exec_for_file(str(tmpfile))\n-    assert find_default_import_path() == expect_rv\n+    # only direct import error is suppressed\n+    with pytest.raises(NoAppException):\n+        locate_app(\n+            info, 'cliapp.importerrorapp', None, raise_if_not_found=False\n+        )\n \n \n def test_get_version(test_apps, capsys):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#491d331e6e0a7915c9e6d9b3287688ac7a3f56ca", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 179 | Lines Deleted: 37 | Files Changed: 4 | Hunks: 22 | Methods Changed: 12 | Complexity Δ (Sum/Max): 17/10 | Churn Δ: 216 | Churn Cumulative: 8452 | Contributors (this commit): 124 | Commits (past 90d): 67 | Contributors (cumulative): 151 | DMM Complexity: 0.6610169491525424\n\nDIFF:\n@@ -820,7 +820,9 @@ class Flask(_PackageBoundObject):\n         self.debug = debug\n         self.jinja_env.auto_reload = self.templates_auto_reload\n \n-    def run(self, host=None, port=None, debug=None, **options):\n+    def run(\n+        self, host=None, port=None, debug=None, load_dotenv=True, **options\n+    ):\n         \"\"\"Runs the application on a local development server.\n \n         Do not use ``run()`` in a production setting. It is not intended to\n@@ -849,30 +851,40 @@ class Flask(_PackageBoundObject):\n            won't catch any exceptions because there won't be any to\n            catch.\n \n+        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n+            have the server available externally as well. Defaults to\n+            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n+            if present.\n+        :param port: the port of the webserver. Defaults to ``5000`` or the\n+            port defined in the ``SERVER_NAME`` config variable if present.\n+        :param debug: if given, enable or disable debug mode. See\n+            :attr:`debug`.\n+        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n+            files to set environment variables. Will also change the working\n+            directory to the directory containing the first file found.\n+        :param options: the options to be forwarded to the underlying Werkzeug\n+            server. See :func:`werkzeug.serving.run_simple` for more\n+            information.\n+\n+        .. versionchanged:: 1.0\n+            If installed, python-dotenv will be used to load environment\n+            variables from :file:`.env` and :file:`.flaskenv` files.\n+\n         .. versionchanged:: 0.10\n            The default port is now picked from the ``SERVER_NAME`` variable.\n \n-        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n-                     have the server available externally as well. Defaults to\n-                     ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config\n-                     variable if present.\n-        :param port: the port of the webserver. Defaults to ``5000`` or the\n-                     port defined in the ``SERVER_NAME`` config variable if\n-                     present.\n-        :param debug: if given, enable or disable debug mode.\n-                      See :attr:`debug`.\n-        :param options: the options to be forwarded to the underlying\n-                        Werkzeug server.  See\n-                        :func:`werkzeug.serving.run_simple` for more\n-                        information.\n         \"\"\"\n         # Change this into a no-op if the server is invoked from the\n         # command line.  Have a look at cli.py for more information.\n-        if os.environ.get('FLASK_RUN_FROM_CLI_SERVER') == '1':\n+        if os.environ.get('FLASK_RUN_FROM_CLI') == 'true':\n             from .debughelpers import explain_ignored_app_run\n             explain_ignored_app_run()\n             return\n \n+        if load_dotenv:\n+            from flask.cli import load_dotenv\n+            load_dotenv()\n+\n         if debug is not None:\n             self._reconfigure_for_run_debug(bool(debug))\n \n\n@@ -8,6 +8,7 @@\n     :copyright: (c) 2015 by Armin Ronacher.\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n+from __future__ import print_function\n \n import ast\n import inspect\n@@ -22,10 +23,14 @@ from threading import Lock, Thread\n import click\n \n from . import __version__\n-from ._compat import iteritems, reraise\n+from ._compat import getargspec, iteritems, reraise\n from .globals import current_app\n from .helpers import get_debug_flag\n-from ._compat import getargspec\n+\n+try:\n+    import dotenv\n+except ImportError:\n+    dotenv = None\n \n \n class NoAppException(click.UsageError):\n@@ -396,12 +401,21 @@ class FlaskGroup(AppGroup):\n     :param add_default_commands: if this is True then the default run and\n         shell commands wil be added.\n     :param add_version_option: adds the ``--version`` option.\n-    :param create_app: an optional callback that is passed the script info\n-                       and returns the loaded app.\n+    :param create_app: an optional callback that is passed the script info and\n+        returns the loaded app.\n+    :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n+        files to set environment variables. Will also change the working\n+        directory to the directory containing the first file found.\n+\n+    .. versionchanged:: 1.0\n+        If installed, python-dotenv will be used to load environment variables\n+        from :file:`.env` and :file:`.flaskenv` files.\n     \"\"\"\n \n-    def __init__(self, add_default_commands=True, create_app=None,\n-                 add_version_option=True, **extra):\n+    def __init__(\n+        self, add_default_commands=True, create_app=None,\n+        add_version_option=True, load_dotenv=True, **extra\n+    ):\n         params = list(extra.pop('params', None) or ())\n \n         if add_version_option:\n@@ -409,6 +423,7 @@ class FlaskGroup(AppGroup):\n \n         AppGroup.__init__(self, params=params, **extra)\n         self.create_app = create_app\n+        self.load_dotenv = load_dotenv\n \n         if add_default_commands:\n             self.add_command(run_command)\n@@ -472,12 +487,75 @@ class FlaskGroup(AppGroup):\n         return sorted(rv)\n \n     def main(self, *args, **kwargs):\n+        # Set a global flag that indicates that we were invoked from the\n+        # command line interface. This is detected by Flask.run to make the\n+        # call into a no-op. This is necessary to avoid ugly errors when the\n+        # script that is loaded here also attempts to start a server.\n+        os.environ['FLASK_RUN_FROM_CLI'] = 'true'\n+\n+        if self.load_dotenv:\n+            load_dotenv()\n+\n         obj = kwargs.get('obj')\n+\n         if obj is None:\n             obj = ScriptInfo(create_app=self.create_app)\n+\n         kwargs['obj'] = obj\n         kwargs.setdefault('auto_envvar_prefix', 'FLASK')\n-        return AppGroup.main(self, *args, **kwargs)\n+        return super(FlaskGroup, self).main(*args, **kwargs)\n+\n+\n+def _path_is_ancestor(path, other):\n+    \"\"\"Take ``other`` and remove the length of ``path`` from it. Then join it\n+    to ``path``. If it is the original value, ``path`` is an ancestor of\n+    ``other``.\"\"\"\n+    return os.path.join(path, other[len(path):].lstrip(os.sep)) == other\n+\n+\n+def load_dotenv(path=None):\n+    \"\"\"Load \"dotenv\" files in order of precedence to set environment variables.\n+\n+    If an env var is already set it is not overwritten, so earlier files in the\n+    list are preferred over later files.\n+\n+    Changes the current working directory to the location of the first file\n+    found, with the assumption that it is in the top level project directory\n+    and will be where the Python path should import local packages from.\n+\n+    This is a no-op if `python-dotenv`_ is not installed.\n+\n+    .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme\n+\n+    :param path: Load the file at this location instead of searching.\n+    :return: ``True`` if a file was loaded.\n+\n+    .. versionadded:: 1.0\n+    \"\"\"\n+\n+    if dotenv is None:\n+        return\n+\n+    if path is not None:\n+        return dotenv.load_dotenv(path)\n+\n+    new_dir = None\n+\n+    for name in ('.env', '.flaskenv'):\n+        path = dotenv.find_dotenv(name, usecwd=True)\n+\n+        if not path:\n+            continue\n+\n+        if new_dir is None:\n+            new_dir = os.path.dirname(path)\n+\n+        dotenv.load_dotenv(path)\n+\n+    if new_dir and os.getcwd() != new_dir:\n+        os.chdir(new_dir)\n+\n+    return new_dir is not None  # at least one file was located and loaded\n \n \n @click.command('run', short_help='Runs a development server.')\n@@ -512,13 +590,6 @@ def run_command(info, host, port, reload, debugger, eager_loading,\n     \"\"\"\n     from werkzeug.serving import run_simple\n \n-    # Set a global flag that indicates that we were invoked from the\n-    # command line interface provided server command.  This is detected\n-    # by Flask.run to make the call into a no-op.  This is necessary to\n-    # avoid ugly errors when the script that is loaded here also attempts\n-    # to start a server.\n-    os.environ['FLASK_RUN_FROM_CLI_SERVER'] = '1'\n-\n     debug = get_debug_flag()\n     if reload is None:\n         reload = bool(debug)\n\n@@ -75,8 +75,10 @@ setup(\n         'click>=4.0',\n     ],\n     extras_require={\n+        'dotenv': ['python-dotenv'],\n         'dev': [\n             'blinker',\n+            'python-dotenv',\n             'greenlet',\n             'pytest>=3',\n             'coverage',\n\n@@ -19,11 +19,31 @@ from functools import partial\n \n import click\n import pytest\n+from _pytest.monkeypatch import notset\n from click.testing import CliRunner\n \n from flask import Flask, current_app\n-from flask.cli import AppGroup, FlaskGroup, NoAppException, ScriptInfo, \\\n-    find_best_app, get_version, locate_app, prepare_import, with_appcontext\n+from flask.cli import AppGroup, FlaskGroup, NoAppException, ScriptInfo, dotenv, \\\n+    find_best_app, get_version, load_dotenv, locate_app, prepare_import, \\\n+    with_appcontext\n+\n+cwd = os.getcwd()\n+test_path = os.path.abspath(os.path.join(\n+    os.path.dirname(__file__), 'test_apps'\n+))\n+\n+\n+@pytest.fixture(autouse=True)\n+def manage_os_environ(monkeypatch):\n+    # can't use monkeypatch.delitem since we don't want to restore a value\n+    os.environ.pop('FLASK_APP', None)\n+    os.environ.pop('FLASK_DEBUG', None)\n+    # use monkeypatch internals to force-delete environ keys\n+    monkeypatch._setitem.extend((\n+        (os.environ, 'FLASK_APP', notset),\n+        (os.environ, 'FLASK_DEBUG', notset),\n+        (os.environ, 'FLASK_RUN_FROM_CLI', notset),\n+    ))\n \n \n @pytest.fixture\n@@ -125,12 +145,6 @@ def test_find_best_app(test_apps):\n     pytest.raises(NoAppException, find_best_app, script_info, Module)\n \n \n-cwd = os.getcwd()\n-test_path = os.path.abspath(os.path.join(\n-    os.path.dirname(__file__), 'test_apps'\n-))\n-\n-\n @pytest.mark.parametrize('value,path,result', (\n     ('test', cwd, 'test'),\n     ('test.py', cwd, 'test'),\n@@ -414,3 +428,46 @@ class TestRoutes:\n         assert 'GET, HEAD, OPTIONS, POST' not in output\n         output = invoke(['routes', '--all-methods']).output\n         assert 'GET, HEAD, OPTIONS, POST' in output\n+\n+\n+need_dotenv = pytest.mark.skipif(\n+    dotenv is None, reason='dotenv is not installed'\n+)\n+\n+\n+@need_dotenv\n+def test_load_dotenv(monkeypatch):\n+    # can't use monkeypatch.delitem since the keys don't exist yet\n+    for item in ('FOO', 'BAR', 'SPAM'):\n+        monkeypatch._setitem.append((os.environ, item, notset))\n+\n+    monkeypatch.setenv('EGGS', '3')\n+    monkeypatch.chdir(os.path.join(test_path, 'cliapp', 'inner1'))\n+    load_dotenv()\n+    assert os.getcwd() == test_path\n+    # .flaskenv doesn't overwrite .env\n+    assert os.environ['FOO'] == 'env'\n+    # set only in .flaskenv\n+    assert os.environ['BAR'] == 'bar'\n+    # set only in .env\n+    assert os.environ['SPAM'] == '1'\n+    # set manually, files don't overwrite\n+    assert os.environ['EGGS'] == '3'\n+\n+\n+@need_dotenv\n+def test_dotenv_path(monkeypatch):\n+    for item in ('FOO', 'BAR', 'EGGS'):\n+        monkeypatch._setitem.append((os.environ, item, notset))\n+\n+    cwd = os.getcwd()\n+    load_dotenv(os.path.join(test_path, '.flaskenv'))\n+    assert os.getcwd() == cwd\n+    assert 'FOO' in os.environ\n+\n+\n+def test_dotenv_optional(monkeypatch):\n+    monkeypatch.setattr('flask.cli.dotenv', None)\n+    monkeypatch.chdir(test_path)\n+    load_dotenv()\n+    assert 'FOO' not in os.environ\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#241673fd153bad011c3fbbb41580450f39874cad", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 6 | Churn Cumulative: 368 | Contributors (this commit): 15 | Commits (past 90d): 5 | Contributors (cumulative): 15 | DMM Complexity: None\n\nDIFF:\n@@ -40,10 +40,10 @@ def make_test_environ_builder(\n         if subdomain:\n             http_host = '{0}.{1}'.format(subdomain, http_host)\n \n-        if url_scheme is None:\n-            url_scheme = app.config['PREFERRED_URL_SCHEME']\n-\n \turl = url_parse(path)\n+        if url_scheme is None:\n+            url_scheme = url.scheme or app.config['PREFERRED_URL_SCHEME']\n+\n         base_url = '{0}://{1}/{2}'.format(\n             url_scheme, url.netloc or http_host, app_root.lstrip('/')\n         )\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#a89bdb3395b22c963456d1fcdebbd77c5c6f618c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 14 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 4 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 18 | Churn Cumulative: 854 | Contributors (this commit): 17 | Commits (past 90d): 12 | Contributors (cumulative): 22 | DMM Complexity: 0.75\n\nDIFF:\n@@ -40,12 +40,14 @@ def make_test_environ_builder(\n         if subdomain:\n             http_host = '{0}.{1}'.format(subdomain, http_host)\n \n-\turl = url_parse(path)\n         if url_scheme is None:\n-            url_scheme = url.scheme or app.config['PREFERRED_URL_SCHEME']\n+            url_scheme = app.config['PREFERRED_URL_SCHEME']\n \n-        base_url = '{0}://{1}/{2}'.format(\n-            url_scheme, url.netloc or http_host, app_root.lstrip('/')\n+        url = url_parse(path)\n+        base_url = '{scheme}://{netloc}/{path}'.format(\n+            scheme=url.scheme or url_scheme,\n+            netloc=url.netloc or http_host,\n+            path=app_root.lstrip('/')\n         )\n         path = url.path\n \n\n@@ -104,6 +104,14 @@ def test_specify_url_scheme(app, client):\n     assert rv.data == b'https://localhost/'\n \n \n+def test_path_is_url(app):\n+    eb = make_test_environ_builder(app, 'https://example.com/')\n+    assert eb.url_scheme == 'https'\n+    assert eb.host == 'example.com'\n+    assert eb.script_root == ''\n+    assert eb.path == '/'\n+\n+\n def test_blueprint_with_subdomain(app, client):\n     app.config['SERVER_NAME'] = 'example.com:1234'\n     app.config['APPLICATION_ROOT'] = '/foo'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#66b1b752da1ccc67c1073d4a99c4141a1b2be445", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 204 | Lines Deleted: 226 | Files Changed: 8 | Hunks: 46 | Methods Changed: 46 | Complexity Δ (Sum/Max): -7/9 | Churn Δ: 430 | Churn Cumulative: 10738 | Contributors (this commit): 120 | Commits (past 90d): 72 | Contributors (cumulative): 159 | DMM Complexity: 0.05405405405405406\n\nDIFF:\n@@ -16,10 +16,9 @@ from functools import update_wrapper\n from itertools import chain\n from threading import Lock\n \n-from werkzeug.datastructures import ImmutableDict, Headers\n-from werkzeug.exceptions import BadRequest, HTTPException, \\\n-    InternalServerError, MethodNotAllowed, default_exceptions, \\\n-    BadRequestKeyError\n+from werkzeug.datastructures import Headers, ImmutableDict\n+from werkzeug.exceptions import BadRequest, BadRequestKeyError, HTTPException, \\\n+    InternalServerError, MethodNotAllowed, default_exceptions\n from werkzeug.routing import BuildError, Map, RequestRedirect, Rule\n \n from . import cli, json\n@@ -30,6 +29,7 @@ from .globals import _request_ctx_stack, g, request, session\n from .helpers import _PackageBoundObject, \\\n     _endpoint_from_view_func, find_package, get_debug_flag, \\\n     get_flashed_messages, locked_cached_property, url_for\n+from .logging import create_logger\n from .sessions import SecureCookieSessionInterface\n from .signals import appcontext_tearing_down, got_request_exception, \\\n     request_finished, request_started, request_tearing_down\n@@ -37,9 +37,6 @@ from .templating import DispatchingJinjaLoader, Environment, \\\n     _default_template_ctx_processor\n from .wrappers import Request, Response\n \n-# a lock used for logger initialization\n-_logger_lock = Lock()\n-\n # a singleton sentinel value for parameter defaults\n _sentinel = object()\n \n@@ -264,12 +261,6 @@ class Flask(_PackageBoundObject):\n     #: ``USE_X_SENDFILE`` configuration key.  Defaults to ``False``.\n     use_x_sendfile = ConfigAttribute('USE_X_SENDFILE')\n \n-    #: The name of the logger to use.  By default the logger name is the\n-    #: package name passed to the constructor.\n-    #:\n-    #: .. versionadded:: 0.4\n-    logger_name = ConfigAttribute('LOGGER_NAME')\n-\n     #: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.\n     #:\n     #: .. versionadded:: 0.10\n@@ -294,8 +285,6 @@ class Flask(_PackageBoundObject):\n         'SECRET_KEY':                           None,\n         'PERMANENT_SESSION_LIFETIME':           timedelta(days=31),\n         'USE_X_SENDFILE':                       False,\n-        'LOGGER_NAME':                          None,\n-        'LOGGER_HANDLER_POLICY':               'always',\n         'SERVER_NAME':                          None,\n         'APPLICATION_ROOT':                     '/',\n         'SESSION_COOKIE_NAME':                  'session',\n@@ -392,10 +381,6 @@ class Flask(_PackageBoundObject):\n         #: to load a config from files.\n         self.config = self.make_config(instance_relative_config)\n \n-        # Prepare the deferred setup of the logger.\n-        self._logger = None\n-        self.logger_name = self.import_name\n-\n         #: A dictionary of all view functions registered.  The keys will\n         #: be function names which are also used to generate URLs and\n         #: the values are the function objects themselves.\n@@ -613,27 +598,28 @@ class Flask(_PackageBoundObject):\n             return rv\n         return self.debug\n \n-    @property\n+    @locked_cached_property\n     def logger(self):\n-        \"\"\"A :class:`logging.Logger` object for this application.  The\n-        default configuration is to log to stderr if the application is\n-        in debug mode.  This logger can be used to (surprise) log messages.\n-        Here some examples::\n+        \"\"\"The ``'flask.app'`` logger, a standard Python\n+        :class:`~logging.Logger`.\n \n-            app.logger.debug('A value for debugging')\n-            app.logger.warning('A warning occurred (%d apples)', 42)\n-            app.logger.error('An error occurred')\n+        In debug mode, the logger's :attr:`~logging.Logger.level` will be set\n+        to :data:`~logging.DEBUG`.\n+\n+        If there are no handlers configured, a default handler will be added.\n+        See :ref:`logging` for more information.\n+\n+        .. versionchanged:: 1.0\n+            Behavior was simplified. The logger is always named\n+            ``flask.app``. The level is only set during configuration, it\n+            doesn't check ``app.debug`` each time. Only one format is used,\n+            not different ones depending on ``app.debug``. No handlers are\n+            removed, and a handler is only added if no handlers are already\n+            configured.\n \n         .. versionadded:: 0.3\n         \"\"\"\n-        if self._logger and self._logger.name == self.logger_name:\n-            return self._logger\n-        with _logger_lock:\n-            if self._logger and self._logger.name == self.logger_name:\n-                return self._logger\n-            from flask.logging import create_logger\n-            self._logger = rv = create_logger(self)\n-            return rv\n+        return create_logger(self)\n \n     @locked_cached_property\n     def jinja_env(self):\n\n@@ -1,94 +1,69 @@\n-# -*- coding: utf-8 -*-\n-\"\"\"\n-    flask.logging\n-    ~~~~~~~~~~~~~\n-\n-    Implements the logging support for Flask.\n-\n-    :copyright: (c) 2015 by Armin Ronacher.\n-    :license: BSD, see LICENSE for more details.\n-\"\"\"\n-\n from __future__ import absolute_import\n \n+import logging\n import sys\n \n from werkzeug.local import LocalProxy\n-from logging import getLogger, StreamHandler, Formatter, getLoggerClass, \\\n-     DEBUG, ERROR\n-from .globals import _request_ctx_stack\n \n-\n-PROD_LOG_FORMAT = '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n-DEBUG_LOG_FORMAT = (\n-    '-' * 80 + '\\n' +\n-    '%(levelname)s in %(module)s [%(pathname)s:%(lineno)d]:\\n' +\n-    '%(message)s\\n' +\n-    '-' * 80\n-)\n+from .globals import request\n \n \n @LocalProxy\n-def _proxy_stream():\n-    \"\"\"Finds the most appropriate error stream for the application.  If a\n-    WSGI request is in flight we log to wsgi.errors, otherwise this resolves\n-    to sys.stderr.\n+def wsgi_errors_stream():\n+    \"\"\"Find the most appropriate error stream for the application. If a request\n+    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n+\n+    If you configure your own :class:`logging.StreamHandler`, you may want to\n+    use this for the stream. If you are using file or dict configuration and\n+    can't import this directly, you can refer to it as\n+    ``ext://flask.logging.wsgi_errors_stream``.\n     \"\"\"\n-    ctx = _request_ctx_stack.top\n-    if ctx is not None:\n-        return ctx.request.environ['wsgi.errors']\n-    return sys.stderr\n+    return request.environ['wsgi.errors'] if request else sys.stderr\n \n \n-def _should_log_for(app, mode):\n-    policy = app.config['LOGGER_HANDLER_POLICY']\n-    if policy == mode or policy == 'always':\n+def has_level_handler(logger):\n+    \"\"\"Check if there is a handler in the logging chain that will handle the\n+    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n+    \"\"\"\n+    level = logger.getEffectiveLevel()\n+    current = logger\n+\n+    while current:\n+        if any(handler.level <= level for handler in current.handlers):\n             return True\n+\n+        if not current.propagate:\n+            break\n+\n+        current = current.parent\n+\n     return False\n \n \n+#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n+#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\n+default_handler = logging.StreamHandler(wsgi_errors_stream)\n+default_handler.setFormatter(logging.Formatter(\n+    '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n+))\n+\n+\n def create_logger(app):\n-    \"\"\"Creates a logger for the given application.  This logger works\n-    similar to a regular Python logger but changes the effective logging\n-    level based on the application's debug flag.  Furthermore this\n-    function also removes all attached handlers in case there was a\n-    logger with the log name before.\n+    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n+\n+    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n+    :data:`logging.DEBUG` if it is not set.\n+\n+    If there is no handler for the logger's effective level, add a\n+    :class:`~logging.StreamHandler` for\n+    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n     \"\"\"\n-    Logger = getLoggerClass()\n+    logger = logging.getLogger('flask.app')\n \n-    class DebugLogger(Logger):\n-        def getEffectiveLevel(self):\n-            if self.level == 0 and app.debug:\n-                return DEBUG\n-            return Logger.getEffectiveLevel(self)\n+    if app.debug and logger.level == logging.NOTSET:\n+        logger.setLevel(logging.DEBUG)\n \n-    class DebugHandler(StreamHandler):\n-        def emit(self, record):\n-            if app.debug and _should_log_for(app, 'debug'):\n-                StreamHandler.emit(self, record)\n-\n-    class ProductionHandler(StreamHandler):\n-        def emit(self, record):\n-            if not app.debug and _should_log_for(app, 'production'):\n-                StreamHandler.emit(self, record)\n-\n-    debug_handler = DebugHandler()\n-    debug_handler.setLevel(DEBUG)\n-    debug_handler.setFormatter(Formatter(DEBUG_LOG_FORMAT))\n-\n-    prod_handler = ProductionHandler(_proxy_stream)\n-    prod_handler.setLevel(ERROR)\n-    prod_handler.setFormatter(Formatter(PROD_LOG_FORMAT))\n-\n-    logger = getLogger(app.logger_name)\n-    # just in case that was not a new logger, get rid of all the handlers\n-    # already attached to it.\n-    del logger.handlers[:]\n-    logger.__class__ = DebugLogger\n-    logger.addHandler(debug_handler)\n-    logger.addHandler(prod_handler)\n-\n-    # Disable propagation by default\n-    logger.propagate = False\n+    if not has_level_handler(logger):\n+        logger.addHandler(default_handler)\n \n     return logger\n\n@@ -738,7 +738,6 @@ def test_teardown_request_handler_debug_mode(app, client):\n \n def test_teardown_request_handler_error(app, client):\n     called = []\n-    app.config['LOGGER_HANDLER_POLICY'] = 'never'\n     app.testing = False\n \n     @app.teardown_request\n@@ -814,7 +813,6 @@ def test_before_after_request_order(app, client):\n \n \n def test_error_handling(app, client):\n-    app.config['LOGGER_HANDLER_POLICY'] = 'never'\n     app.testing = False\n \n     @app.errorhandler(404)\n@@ -860,7 +858,6 @@ def test_error_handler_unknown_code(app):\n \n \n def test_error_handling_processing(app, client):\n-    app.config['LOGGER_HANDLER_POLICY'] = 'never'\n     app.testing = False\n \n     @app.errorhandler(500)\n@@ -882,7 +879,6 @@ def test_error_handling_processing(app, client):\n \n \n def test_baseexception_error_handling(app, client):\n-    app.config['LOGGER_HANDLER_POLICY'] = 'never'\n     app.testing = False\n \n     @app.route('/')\n@@ -1021,6 +1017,34 @@ def test_trapping_of_all_http_exceptions(app, client):\n         client.get('/fail')\n \n \n+def test_error_handler_after_processor_error(app, client):\n+    app.testing = False\n+\n+    @app.before_request\n+    def before_request():\n+        if trigger == 'before':\n+            1 // 0\n+\n+    @app.after_request\n+    def after_request(response):\n+        if trigger == 'after':\n+            1 // 0\n+        return response\n+\n+    @app.route('/')\n+    def index():\n+        return 'Foo'\n+\n+    @app.errorhandler(500)\n+    def internal_server_error(e):\n+        return 'Hello Server Error', 500\n+\n+    for trigger in 'before', 'after':\n+        rv = client.get('/')\n+        assert rv.status_code == 500\n+        assert rv.data == b'Hello Server Error'\n+\n+\n def test_enctype_debug_helper(app, client):\n     from flask.debughelpers import DebugFilesKeyError\n     app.debug = True\n@@ -1425,7 +1449,6 @@ def test_test_app_proper_environ(app, client):\n \n def test_exception_propagation(app, client):\n     def apprunner(config_key):\n-        app.config['LOGGER_HANDLER_POLICY'] = 'never'\n \n         @app.route('/')\n         def index():\n\n@@ -9,20 +9,19 @@\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n \n-import pytest\n-\n+import datetime\n import os\n import uuid\n-import datetime\n \n-import flask\n-from logging import StreamHandler\n+import pytest\n from werkzeug.datastructures import Range\n from werkzeug.exceptions import BadRequest, NotFound\n-from werkzeug.http import parse_cache_control_header, parse_options_header\n-from werkzeug.http import http_date\n+from werkzeug.http import http_date, parse_cache_control_header, \\\n+    parse_options_header\n+\n+import flask\n from flask._compat import StringIO, text_type\n-from flask.helpers import get_debug_flag, make_response\n+from flask.helpers import get_debug_flag\n \n \n def has_encoding(name):\n@@ -660,94 +659,7 @@ class TestSendfile(object):\n             flask.send_from_directory('static', 'bad\\x00')\n \n \n-class TestLogging(object):\n-    def test_logger_cache(self):\n-        app = flask.Flask(__name__)\n-        logger1 = app.logger\n-        assert app.logger is logger1\n-        assert logger1.name == __name__\n-        app.logger_name = __name__ + '/test_logger_cache'\n-        assert app.logger is not logger1\n-\n-    def test_debug_log(self, capsys, app, client):\n-        app.debug = True\n-\n-        @app.route('/')\n-        def index():\n-            app.logger.warning('the standard library is dead')\n-            app.logger.debug('this is a debug statement')\n-            return ''\n-\n-        @app.route('/exc')\n-        def exc():\n-            1 // 0\n-\n-        with client:\n-            client.get('/')\n-            out, err = capsys.readouterr()\n-            assert 'WARNING in test_helpers [' in err\n-            assert os.path.basename(__file__.rsplit('.', 1)[0] + '.py') in err\n-            assert 'the standard library is dead' in err\n-            assert 'this is a debug statement' in err\n-\n-            with pytest.raises(ZeroDivisionError):\n-                client.get('/exc')\n-\n-    def test_debug_log_override(self, app):\n-        app.debug = True\n-        app.logger_name = 'flask_tests/test_debug_log_override'\n-        app.logger.level = 10\n-        assert app.logger.level == 10\n-\n-    def test_exception_logging(self, app, client):\n-        out = StringIO()\n-        app.config['LOGGER_HANDLER_POLICY'] = 'never'\n-        app.logger_name = 'flask_tests/test_exception_logging'\n-        app.logger.addHandler(StreamHandler(out))\n-        app.testing = False\n-\n-        @app.route('/')\n-        def index():\n-            1 // 0\n-\n-        rv = client.get('/')\n-        assert rv.status_code == 500\n-        assert b'Internal Server Error' in rv.data\n-\n-        err = out.getvalue()\n-        assert 'Exception on / [GET]' in err\n-        assert 'Traceback (most recent call last):' in err\n-        assert '1 // 0' in err\n-        assert 'ZeroDivisionError:' in err\n-\n-    def test_processor_exceptions(self, app, client):\n-        app.config['LOGGER_HANDLER_POLICY'] = 'never'\n-        app.testing = False\n-\n-        @app.before_request\n-        def before_request():\n-            if trigger == 'before':\n-                1 // 0\n-\n-        @app.after_request\n-        def after_request(response):\n-            if trigger == 'after':\n-                1 // 0\n-            return response\n-\n-        @app.route('/')\n-        def index():\n-            return 'Foo'\n-\n-        @app.errorhandler(500)\n-        def internal_server_error(e):\n-            return 'Hello Server Error', 500\n-\n-        for trigger in 'before', 'after':\n-            rv = client.get('/')\n-            assert rv.status_code == 500\n-            assert rv.data == b'Hello Server Error'\n-\n+class TestUrlFor(object):\n     def test_url_for_with_anchor(self, app, req_ctx):\n \n         @app.route('/')\n\n@@ -0,0 +1,91 @@\n+import logging\n+import sys\n+\n+import pytest\n+\n+from flask._compat import StringIO\n+from flask.logging import default_handler, has_level_handler, \\\n+    wsgi_errors_stream\n+\n+\n+@pytest.fixture(autouse=True)\n+def reset_logging(monkeypatch):\n+    root_handlers = logging.root.handlers[:]\n+    root_level = logging.root.level\n+\n+    logger = logging.getLogger('flask.app')\n+    logger.handlers = []\n+    logger.setLevel(logging.NOTSET)\n+\n+    yield\n+\n+    logging.root.handlers[:] = root_handlers\n+    logging.root.setLevel(root_level)\n+\n+    logger.handlers = []\n+    logger.setLevel(logging.NOTSET)\n+\n+\n+def test_logger(app):\n+    assert app.logger.name == 'flask.app'\n+    assert app.logger.level == logging.NOTSET\n+    assert app.logger.handlers == [default_handler]\n+\n+\n+def test_logger_debug(app):\n+    app.debug = True\n+    assert app.logger.level == logging.DEBUG\n+    assert app.logger.handlers == [default_handler]\n+\n+\n+def test_existing_handler(app):\n+    logging.root.addHandler(logging.StreamHandler())\n+    assert app.logger.level == logging.NOTSET\n+    assert not app.logger.handlers\n+\n+\n+def test_wsgi_errors_stream(app, client):\n+    @app.route('/')\n+    def index():\n+        app.logger.error('test')\n+        return ''\n+\n+    stream = StringIO()\n+    client.get('/', errors_stream=stream)\n+    assert 'ERROR in test_logging: test' in stream.getvalue()\n+\n+    assert wsgi_errors_stream._get_current_object() is sys.stderr\n+\n+    with app.test_request_context(errors_stream=stream):\n+        assert wsgi_errors_stream._get_current_object() is stream\n+\n+\n+def test_has_level_handler():\n+    logger = logging.getLogger('flask.app')\n+    assert not has_level_handler(logger)\n+\n+    handler = logging.StreamHandler()\n+    logging.root.addHandler(handler)\n+    assert has_level_handler(logger)\n+\n+    logger.propagate = False\n+    assert not has_level_handler(logger)\n+    logger.propagate = True\n+\n+    handler.setLevel(logging.ERROR)\n+    assert not has_level_handler(logger)\n+\n+\n+def test_log_view_exception(app, client):\n+    @app.route('/')\n+    def index():\n+        raise Exception('test')\n+\n+    app.testing = False\n+    stream = StringIO()\n+    rv = client.get('/', errors_stream=stream)\n+    assert rv.status_code == 500\n+    assert rv.data\n+    err = stream.getvalue()\n+    assert 'Exception on / [GET]' in err\n+    assert 'Exception: test' in err\n\n@@ -9,8 +9,8 @@\n     :copyright: (c) 2015 by Armin Ronacher.\n     :license: BSD, see LICENSE for more details.\n \"\"\"\n+\n import flask\n-from logging import StreamHandler\n \n from flask._compat import StringIO\n \n@@ -22,16 +22,12 @@ def test_suppressed_exception_logging():\n \n     out = StringIO()\n     app = SuppressedFlask(__name__)\n-    app.logger_name = 'flask_tests/test_suppressed_exception_logging'\n-    app.logger.addHandler(StreamHandler(out))\n \n     @app.route('/')\n     def index():\n-        1 // 0\n+        raise Exception('test')\n \n-    rv = app.test_client().get('/')\n+    rv = app.test_client().get('/', errors_stream=out)\n     assert rv.status_code == 500\n     assert b'Internal Server Error' in rv.data\n-\n-    err = out.getvalue()\n-    assert err == ''\n+    assert not out.getvalue()\n\n@@ -399,7 +399,7 @@ def test_templates_auto_reload_debug_run(app, monkeypatch):\n     assert app.jinja_env.auto_reload == True\n \n \n-def test_template_loader_debugging(test_apps):\n+def test_template_loader_debugging(test_apps, monkeypatch):\n     from blueprintapp import app\n \n     called = []\n@@ -419,19 +419,15 @@ def test_template_loader_debugging(test_apps):\n             assert 'See http://flask.pocoo.org/docs/blueprints/#templates' in text\n \n     with app.test_client() as c:\n-        try:\n-            old_load_setting = app.config['EXPLAIN_TEMPLATE_LOADING']\n-            old_handlers = app.logger.handlers[:]\n-            app.logger.handlers = [_TestHandler()]\n-            app.config['EXPLAIN_TEMPLATE_LOADING'] = True\n+        monkeypatch.setitem(app.config, 'EXPLAIN_TEMPLATE_LOADING', True)\n+        monkeypatch.setattr(\n+            logging.getLogger('flask'), 'handlers', [_TestHandler()]\n+        )\n \n         with pytest.raises(TemplateNotFound) as excinfo:\n             c.get('/missing')\n \n         assert 'missing_template.html' in str(excinfo.value)\n-        finally:\n-            app.logger.handlers[:] = old_handlers\n-            app.config['EXPLAIN_TEMPLATE_LOADING'] = old_load_setting\n \n     assert len(called) == 1\n \n\n@@ -207,7 +207,6 @@ def test_session_transaction_needs_cookies(app):\n \n \n def test_test_client_context_binding(app, client):\n-    app.config['LOGGER_HANDLER_POLICY'] = 'never'\n     app.testing = False\n \n     @app.route('/')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
