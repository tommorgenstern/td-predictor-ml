{"custom_id": "requests#2584c48e8d744148e96a4ed5d8feda824887398d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 5 | Files Changed: 1 | Hunks: 6 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 11 | Churn Cumulative: 3726 | Contributors (this commit): 21 | Commits (past 90d): 138 | Contributors (cumulative): 21 | DMM Complexity: 0.0\n\nDIFF:\n@@ -5,12 +5,13 @@\n requests.models\n ~~~~~~~~~~~~~~~\n \n+This module contains the primary objects that power Requests.\n \"\"\"\n \n import urllib\n import zlib\n-from Cookie import SimpleCookie\n \n+from Cookie import SimpleCookie\n from urlparse import urlparse, urlunparse, urljoin\n from datetime import datetime\n \n@@ -26,8 +27,8 @@ from .packages.urllib3.filepost import encode_multipart_formdata\n from .exceptions import (\n     Timeout, URLRequired, TooManyRedirects, HTTPError, ConnectionError)\n from .utils import (\n-    dict_from_cookiejar, get_unicode_from_response,\n-    stream_decode_response_unicode, decode_gzip, stream_decode_gzip)\n+    get_unicode_from_response, stream_decode_response_unicode,\n+    decode_gzip, stream_decode_gzip)\n \n \n \n@@ -393,9 +394,9 @@ class Request(object):\n                 if 'cookie' not in self.headers:\n \n                     # Simple cookie with our dict.\n-                    # TODO: Multi-value headers.\n                     c = SimpleCookie()\n-                    c.load(self.cookies)\n+                    for (k, v) in self.cookies.items():\n+                        c[k] = v\n \n                     # Turn it into a header.\n                     cookie_header = c.output(header='').strip()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#3462d9c87b92bd6813006ee8eb31d7b8f7b4335e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 293 | Contributors (this commit): 1 | Commits (past 90d): 7 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -8,6 +8,9 @@\n from collections import deque\n from threading import RLock\n \n+try:\n+    from collections import MutableMapping\n+except ImportError:\n     from .__collections import MutableMapping\n \n __all__ = ['RecentlyUsedContainer']\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#37bbdbe8c3d041e5bb66396f735266c4dfeb5652", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 103 | Contributors (this commit): 2 | Commits (past 90d): 4 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -37,7 +37,7 @@ setup(\n     packages= [\n         'requests',\n         'requests.packages',\n-        'requests.packages.poster'\n+        'requests.packages.urllib3'\n     ],\n     install_requires=required,\n     license='ISC',\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#0086f97b6553ac323565e8653eae678e380219ae", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 5/4 | Churn Δ: 11 | Churn Cumulative: 4540 | Contributors (this commit): 22 | Commits (past 90d): 182 | Contributors (cumulative): 28 | DMM Complexity: 1.0\n\nDIFF:\n@@ -28,7 +28,7 @@ from .exceptions import (\n     Timeout, URLRequired, TooManyRedirects, HTTPError, ConnectionError)\n from .utils import (\n     get_unicode_from_response, stream_decode_response_unicode,\n-    decode_gzip, stream_decode_gzip)\n+    decode_gzip, stream_decode_gzip, guess_filename)\n \n \n \n@@ -346,7 +346,8 @@ class Request(object):\n                     fields = dict(self.data)\n \n                 for (k, v) in self.files.items():\n-                    fields.update({k: (k, v.read())})\n+                    fields.update({k: (guess_filename(k) or k, v.read())})\n+\n                 (body, content_type) = encode_multipart_formdata(fields)\n             else:\n                 pass\n\n@@ -20,6 +20,12 @@ import zlib\n from urllib2 import parse_http_list as _parse_list_header\n \n \n+def guess_filename(obj):\n+    \"\"\"Tries to guess the filename of the given object.\"\"\"\n+    name = getattr(obj, 'name', None)\n+    if name and name[0] != '<' and name[-1] != '>':\n+        return name\n+\n # From mitsuhiko/werkzeug (used with permission).\n def parse_list_header(value):\n     \"\"\"Parse lists as described by RFC 2068 Section 2.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#3458e6a905b543f499aea95e463bb653114ffb1c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 14 | Lines Deleted: 1013 | Files Changed: 11 | Hunks: 12 | Methods Changed: 103 | Complexity Δ (Sum/Max): -303/0 | Churn Δ: 1027 | Churn Cumulative: 5522 | Contributors (this commit): 1 | Commits (past 90d): 75 | Contributors (cumulative): 11 | DMM Complexity: 0.15449915110356535\n\nDIFF:\n@@ -1,991 +0,0 @@\n-from __future__ import with_statement\n-\n-\n-# Copyright 2007 Google, Inc. All Rights Reserved.\n-# Licensed to PSF under a Contributor Agreement.\n-\n-\"\"\"Abstract Base Classes (ABCs) according to PEP 3119.\"\"\"\n-\n-import types\n-\n-from _weakref import ref\n-\n-__all__ = ['WeakSet']\n-\n-\n-class _IterationGuard(object):\n-    # This context manager registers itself in the current iterators of the\n-    # weak container, such as to delay all removals until the context manager\n-    # exits.\n-    # This technique should be relatively thread-safe (since sets are).\n-\n-    def __init__(self, weakcontainer):\n-        # Don't create cycles\n-        self.weakcontainer = ref(weakcontainer)\n-\n-    def __enter__(self):\n-        w = self.weakcontainer()\n-        if w is not None:\n-            w._iterating.add(self)\n-        return self\n-\n-    def __exit__(self, e, t, b):\n-        w = self.weakcontainer()\n-        if w is not None:\n-            s = w._iterating\n-            s.remove(self)\n-            if not s:\n-                w._commit_removals()\n-\n-\n-class WeakSet(object):\n-    def __init__(self, data=None):\n-        self.data = set()\n-        def _remove(item, selfref=ref(self)):\n-            self = selfref()\n-            if self is not None:\n-                if self._iterating:\n-                    self._pending_removals.append(item)\n-                else:\n-                    self.data.discard(item)\n-        self._remove = _remove\n-        # A list of keys to be removed\n-        self._pending_removals = []\n-        self._iterating = set()\n-        if data is not None:\n-            self.update(data)\n-\n-    def _commit_removals(self):\n-        l = self._pending_removals\n-        discard = self.data.discard\n-        while l:\n-            discard(l.pop())\n-\n-    def __iter__(self):\n-        with _IterationGuard(self):\n-            for itemref in self.data:\n-                item = itemref()\n-                if item is not None:\n-                    yield item\n-\n-    def __len__(self):\n-        return sum(x() is not None for x in self.data)\n-\n-    def __contains__(self, item):\n-        try:\n-            wr = ref(item)\n-        except TypeError:\n-            return False\n-        return wr in self.data\n-\n-    def __reduce__(self):\n-        return (self.__class__, (list(self),),\n-                getattr(self, '__dict__', None))\n-\n-    __hash__ = None\n-\n-    def add(self, item):\n-        if self._pending_removals:\n-            self._commit_removals()\n-        self.data.add(ref(item, self._remove))\n-\n-    def clear(self):\n-        if self._pending_removals:\n-            self._commit_removals()\n-        self.data.clear()\n-\n-    def copy(self):\n-        return self.__class__(self)\n-\n-    def pop(self):\n-        if self._pending_removals:\n-            self._commit_removals()\n-        while True:\n-            try:\n-                itemref = self.data.pop()\n-            except KeyError:\n-                raise KeyError('pop from empty WeakSet')\n-            item = itemref()\n-            if item is not None:\n-                return item\n-\n-    def remove(self, item):\n-        if self._pending_removals:\n-            self._commit_removals()\n-        self.data.remove(ref(item))\n-\n-    def discard(self, item):\n-        if self._pending_removals:\n-            self._commit_removals()\n-        self.data.discard(ref(item))\n-\n-    def update(self, other):\n-        if self._pending_removals:\n-            self._commit_removals()\n-        if isinstance(other, self.__class__):\n-            self.data.update(other.data)\n-        else:\n-            for element in other:\n-                self.add(element)\n-\n-    def __ior__(self, other):\n-        self.update(other)\n-        return self\n-\n-    # Helper functions for simple delegating methods.\n-    def _apply(self, other, method):\n-        if not isinstance(other, self.__class__):\n-            other = self.__class__(other)\n-        newdata = method(other.data)\n-        newset = self.__class__()\n-        newset.data = newdata\n-        return newset\n-\n-    def difference(self, other):\n-        return self._apply(other, self.data.difference)\n-    __sub__ = difference\n-\n-    def difference_update(self, other):\n-        if self._pending_removals:\n-            self._commit_removals()\n-        if self is other:\n-            self.data.clear()\n-        else:\n-            self.data.difference_update(ref(item) for item in other)\n-    def __isub__(self, other):\n-        if self._pending_removals:\n-            self._commit_removals()\n-        if self is other:\n-            self.data.clear()\n-        else:\n-            self.data.difference_update(ref(item) for item in other)\n-        return self\n-\n-    def intersection(self, other):\n-        return self._apply(other, self.data.intersection)\n-    __and__ = intersection\n-\n-    def intersection_update(self, other):\n-        if self._pending_removals:\n-            self._commit_removals()\n-        self.data.intersection_update(ref(item) for item in other)\n-    def __iand__(self, other):\n-        if self._pending_removals:\n-            self._commit_removals()\n-        self.data.intersection_update(ref(item) for item in other)\n-        return self\n-\n-    def issubset(self, other):\n-        return self.data.issubset(ref(item) for item in other)\n-    __lt__ = issubset\n-\n-    def __le__(self, other):\n-        return self.data <= set(ref(item) for item in other)\n-\n-    def issuperset(self, other):\n-        return self.data.issuperset(ref(item) for item in other)\n-    __gt__ = issuperset\n-\n-    def __ge__(self, other):\n-        return self.data >= set(ref(item) for item in other)\n-\n-    def __eq__(self, other):\n-        if not isinstance(other, self.__class__):\n-            return NotImplemented\n-        return self.data == set(ref(item) for item in other)\n-\n-    def symmetric_difference(self, other):\n-        return self._apply(other, self.data.symmetric_difference)\n-    __xor__ = symmetric_difference\n-\n-    def symmetric_difference_update(self, other):\n-        if self._pending_removals:\n-            self._commit_removals()\n-        if self is other:\n-            self.data.clear()\n-        else:\n-            self.data.symmetric_difference_update(ref(item) for item in other)\n-    def __ixor__(self, other):\n-        if self._pending_removals:\n-            self._commit_removals()\n-        if self is other:\n-            self.data.clear()\n-        else:\n-            self.data.symmetric_difference_update(ref(item) for item in other)\n-        return self\n-\n-    def union(self, other):\n-        return self._apply(other, self.data.union)\n-    __or__ = union\n-\n-    def isdisjoint(self, other):\n-        return len(self.intersection(other)) == 0\n-\n-\n-# Instance of old-style class\n-class _C: pass\n-_InstanceType = type(_C())\n-\n-\n-def abstractmethod(funcobj):\n-    \"\"\"A decorator indicating abstract methods.\n-\n-    Requires that the metaclass is ABCMeta or derived from it.  A\n-    class that has a metaclass derived from ABCMeta cannot be\n-    instantiated unless all of its abstract methods are overridden.\n-    The abstract methods can be called using any of the normal\n-    'super' call mechanisms.\n-\n-    Usage:\n-\n-        class C:\n-            __metaclass__ = ABCMeta\n-            @abstractmethod\n-            def my_abstract_method(self, ...):\n-                ...\n-    \"\"\"\n-    funcobj.__isabstractmethod__ = True\n-    return funcobj\n-\n-\n-class abstractproperty(property):\n-    \"\"\"A decorator indicating abstract properties.\n-\n-    Requires that the metaclass is ABCMeta or derived from it.  A\n-    class that has a metaclass derived from ABCMeta cannot be\n-    instantiated unless all of its abstract properties are overridden.\n-    The abstract properties can be called using any of the normal\n-    'super' call mechanisms.\n-\n-    Usage:\n-\n-        class C:\n-            __metaclass__ = ABCMeta\n-            @abstractproperty\n-            def my_abstract_property(self):\n-                ...\n-\n-    This defines a read-only property; you can also define a read-write\n-    abstract property using the 'long' form of property declaration:\n-\n-        class C:\n-            __metaclass__ = ABCMeta\n-            def getx(self): ...\n-            def setx(self, value): ...\n-            x = abstractproperty(getx, setx)\n-    \"\"\"\n-    __isabstractmethod__ = True\n-\n-\n-class ABCMeta(type):\n-\n-    \"\"\"Metaclass for defining Abstract Base Classes (ABCs).\n-\n-    Use this metaclass to create an ABC.  An ABC can be subclassed\n-    directly, and then acts as a mix-in class.  You can also register\n-    unrelated concrete classes (even built-in classes) and unrelated\n-    ABCs as 'virtual subclasses' -- these and their descendants will\n-    be considered subclasses of the registering ABC by the built-in\n-    issubclass() function, but the registering ABC won't show up in\n-    their MRO (Method Resolution Order) nor will method\n-    implementations defined by the registering ABC be callable (not\n-    even via super()).\n-\n-    \"\"\"\n-\n-    # A global counter that is incremented each time a class is\n-    # registered as a virtual subclass of anything.  It forces the\n-    # negative cache to be cleared before its next use.\n-    _abc_invalidation_counter = 0\n-\n-    def __new__(mcls, name, bases, namespace):\n-        cls = super(ABCMeta, mcls).__new__(mcls, name, bases, namespace)\n-        # Compute set of abstract method names\n-        abstracts = set(name\n-                     for name, value in namespace.items()\n-                     if getattr(value, \"__isabstractmethod__\", False))\n-        for base in bases:\n-            for name in getattr(base, \"__abstractmethods__\", set()):\n-                value = getattr(cls, name, None)\n-                if getattr(value, \"__isabstractmethod__\", False):\n-                    abstracts.add(name)\n-        cls.__abstractmethods__ = frozenset(abstracts)\n-        # Set up inheritance registry\n-        cls._abc_registry = WeakSet()\n-        cls._abc_cache = WeakSet()\n-        cls._abc_negative_cache = WeakSet()\n-        cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter\n-        return cls\n-\n-    def register(cls, subclass):\n-        \"\"\"Register a virtual subclass of an ABC.\"\"\"\n-        if not isinstance(subclass, (type, types.ClassType)):\n-            raise TypeError(\"Can only register classes\")\n-        if issubclass(subclass, cls):\n-            return  # Already a subclass\n-        # Subtle: test for cycles *after* testing for \"already a subclass\";\n-        # this means we allow X.register(X) and interpret it as a no-op.\n-        if issubclass(cls, subclass):\n-            # This would create a cycle, which is bad for the algorithm below\n-            raise RuntimeError(\"Refusing to create an inheritance cycle\")\n-        cls._abc_registry.add(subclass)\n-        ABCMeta._abc_invalidation_counter += 1  # Invalidate negative cache\n-\n-    def _dump_registry(cls, file=None):\n-        \"\"\"Debug helper to print the ABC registry.\"\"\"\n-        print >> file, \"Class: %s.%s\" % (cls.__module__, cls.__name__)\n-        print >> file, \"Inv.counter: %s\" % ABCMeta._abc_invalidation_counter\n-        for name in sorted(cls.__dict__.keys()):\n-            if name.startswith(\"_abc_\"):\n-                value = getattr(cls, name)\n-                print >> file, \"%s: %r\" % (name, value)\n-\n-    def __instancecheck__(cls, instance):\n-        \"\"\"Override for isinstance(instance, cls).\"\"\"\n-        # Inline the cache checking when it's simple.\n-        subclass = getattr(instance, '__class__', None)\n-        if subclass is not None and subclass in cls._abc_cache:\n-            return True\n-        subtype = type(instance)\n-        # Old-style instances\n-        if subtype is _InstanceType:\n-            subtype = subclass\n-        if subtype is subclass or subclass is None:\n-            if (cls._abc_negative_cache_version ==\n-                ABCMeta._abc_invalidation_counter and\n-                subtype in cls._abc_negative_cache):\n-                return False\n-            # Fall back to the subclass check.\n-            return cls.__subclasscheck__(subtype)\n-        return (cls.__subclasscheck__(subclass) or\n-                cls.__subclasscheck__(subtype))\n-\n-    def __subclasscheck__(cls, subclass):\n-        \"\"\"Override for issubclass(subclass, cls).\"\"\"\n-        # Check cache\n-        if subclass in cls._abc_cache:\n-            return True\n-        # Check negative cache; may have to invalidate\n-        if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:\n-            # Invalidate the negative cache\n-            cls._abc_negative_cache = WeakSet()\n-            cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter\n-        elif subclass in cls._abc_negative_cache:\n-            return False\n-        # Check the subclass hook\n-        ok = cls.__subclasshook__(subclass)\n-        if ok is not NotImplemented:\n-            assert isinstance(ok, bool)\n-            if ok:\n-                cls._abc_cache.add(subclass)\n-            else:\n-                cls._abc_negative_cache.add(subclass)\n-            return ok\n-        # Check if it's a direct subclass\n-        if cls in getattr(subclass, '__mro__', ()):\n-            cls._abc_cache.add(subclass)\n-            return True\n-        # Check if it's a subclass of a registered class (recursive)\n-        for rcls in cls._abc_registry:\n-            if issubclass(subclass, rcls):\n-                cls._abc_cache.add(subclass)\n-                return True\n-        # Check if it's a subclass of a subclass (recursive)\n-        for scls in cls.__subclasses__():\n-            if issubclass(subclass, scls):\n-                cls._abc_cache.add(subclass)\n-                return True\n-        # No dice; update negative cache\n-        cls._abc_negative_cache.add(subclass)\n-        return False\n-\n-\n-\n-\n-\n-\n-\n-\n-import sys\n-\n-### ONE-TRICK PONIES ###\n-\n-def _hasattr(C, attr):\n-    try:\n-        return any(attr in B.__dict__ for B in C.__mro__)\n-    except AttributeError:\n-        # Old-style class\n-        return hasattr(C, attr)\n-\n-\n-class Hashable:\n-    __metaclass__ = ABCMeta\n-\n-    @abstractmethod\n-    def __hash__(self):\n-        return 0\n-\n-    @classmethod\n-    def __subclasshook__(cls, C):\n-        if cls is Hashable:\n-            try:\n-                for B in C.__mro__:\n-                    if \"__hash__\" in B.__dict__:\n-                        if B.__dict__[\"__hash__\"]:\n-                            return True\n-                        break\n-            except AttributeError:\n-                # Old-style class\n-                if getattr(C, \"__hash__\", None):\n-                    return True\n-        return NotImplemented\n-\n-\n-class Iterable:\n-    __metaclass__ = ABCMeta\n-\n-    @abstractmethod\n-    def __iter__(self):\n-        while False:\n-            yield None\n-\n-    @classmethod\n-    def __subclasshook__(cls, C):\n-        if cls is Iterable:\n-            if _hasattr(C, \"__iter__\"):\n-                return True\n-        return NotImplemented\n-\n-Iterable.register(str)\n-\n-\n-class Iterator(Iterable):\n-\n-    @abstractmethod\n-    def next(self):\n-        raise StopIteration\n-\n-    def __iter__(self):\n-        return self\n-\n-    @classmethod\n-    def __subclasshook__(cls, C):\n-        if cls is Iterator:\n-            if _hasattr(C, \"next\") and _hasattr(C, \"__iter__\"):\n-                return True\n-        return NotImplemented\n-\n-\n-class Sized:\n-    __metaclass__ = ABCMeta\n-\n-    @abstractmethod\n-    def __len__(self):\n-        return 0\n-\n-    @classmethod\n-    def __subclasshook__(cls, C):\n-        if cls is Sized:\n-            if _hasattr(C, \"__len__\"):\n-                return True\n-        return NotImplemented\n-\n-\n-class Container:\n-    __metaclass__ = ABCMeta\n-\n-    @abstractmethod\n-    def __contains__(self, x):\n-        return False\n-\n-    @classmethod\n-    def __subclasshook__(cls, C):\n-        if cls is Container:\n-            if _hasattr(C, \"__contains__\"):\n-                return True\n-        return NotImplemented\n-\n-\n-class Callable:\n-    __metaclass__ = ABCMeta\n-\n-    @abstractmethod\n-    def __call__(self, *args, **kwds):\n-        return False\n-\n-    @classmethod\n-    def __subclasshook__(cls, C):\n-        if cls is Callable:\n-            if _hasattr(C, \"__call__\"):\n-                return True\n-        return NotImplemented\n-\n-\n-### SETS ###\n-\n-\n-class Set(Sized, Iterable, Container):\n-    \"\"\"A set is a finite, iterable container.\n-\n-    This class provides concrete generic implementations of all\n-    methods except for __contains__, __iter__ and __len__.\n-\n-    To override the comparisons (presumably for speed, as the\n-    semantics are fixed), all you have to do is redefine __le__ and\n-    then the other operations will automatically follow suit.\n-    \"\"\"\n-\n-    def __le__(self, other):\n-        if not isinstance(other, Set):\n-            return NotImplemented\n-        if len(self) > len(other):\n-            return False\n-        for elem in self:\n-            if elem not in other:\n-                return False\n-        return True\n-\n-    def __lt__(self, other):\n-        if not isinstance(other, Set):\n-            return NotImplemented\n-        return len(self) < len(other) and self.__le__(other)\n-\n-    def __gt__(self, other):\n-        if not isinstance(other, Set):\n-            return NotImplemented\n-        return other < self\n-\n-    def __ge__(self, other):\n-        if not isinstance(other, Set):\n-            return NotImplemented\n-        return other <= self\n-\n-    def __eq__(self, other):\n-        if not isinstance(other, Set):\n-            return NotImplemented\n-        return len(self) == len(other) and self.__le__(other)\n-\n-    def __ne__(self, other):\n-        return not (self == other)\n-\n-    @classmethod\n-    def _from_iterable(cls, it):\n-        '''Construct an instance of the class from any iterable input.\n-\n-        Must override this method if the class constructor signature\n-        does not accept an iterable for an input.\n-        '''\n-        return cls(it)\n-\n-    def __and__(self, other):\n-        if not isinstance(other, Iterable):\n-            return NotImplemented\n-        return self._from_iterable(value for value in other if value in self)\n-\n-    def isdisjoint(self, other):\n-        for value in other:\n-            if value in self:\n-                return False\n-        return True\n-\n-    def __or__(self, other):\n-        if not isinstance(other, Iterable):\n-            return NotImplemented\n-        chain = (e for s in (self, other) for e in s)\n-        return self._from_iterable(chain)\n-\n-    def __sub__(self, other):\n-        if not isinstance(other, Set):\n-            if not isinstance(other, Iterable):\n-                return NotImplemented\n-            other = self._from_iterable(other)\n-        return self._from_iterable(value for value in self\n-                                   if value not in other)\n-\n-    def __xor__(self, other):\n-        if not isinstance(other, Set):\n-            if not isinstance(other, Iterable):\n-                return NotImplemented\n-            other = self._from_iterable(other)\n-        return (self - other) | (other - self)\n-\n-    # Sets are not hashable by default, but subclasses can change this\n-    __hash__ = None\n-\n-    def _hash(self):\n-        \"\"\"Compute the hash value of a set.\n-\n-        Note that we don't define __hash__: not all sets are hashable.\n-        But if you define a hashable set type, its __hash__ should\n-        call this function.\n-\n-        This must be compatible __eq__.\n-\n-        All sets ought to compare equal if they contain the same\n-        elements, regardless of how they are implemented, and\n-        regardless of the order of the elements; so there's not much\n-        freedom for __eq__ or __hash__.  We match the algorithm used\n-        by the built-in frozenset type.\n-        \"\"\"\n-        MAX = sys.maxint\n-        MASK = 2 * MAX + 1\n-        n = len(self)\n-        h = 1927868237 * (n + 1)\n-        h &= MASK\n-        for x in self:\n-            hx = hash(x)\n-            h ^= (hx ^ (hx << 16) ^ 89869747)  * 3644798167\n-            h &= MASK\n-        h = h * 69069 + 907133923\n-        h &= MASK\n-        if h > MAX:\n-            h -= MASK + 1\n-        if h == -1:\n-            h = 590923713\n-        return h\n-\n-Set.register(frozenset)\n-\n-\n-class MutableSet(Set):\n-\n-    @abstractmethod\n-    def add(self, value):\n-        \"\"\"Add an element.\"\"\"\n-        raise NotImplementedError\n-\n-    @abstractmethod\n-    def discard(self, value):\n-        \"\"\"Remove an element.  Do not raise an exception if absent.\"\"\"\n-        raise NotImplementedError\n-\n-    def remove(self, value):\n-        \"\"\"Remove an element. If not a member, raise a KeyError.\"\"\"\n-        if value not in self:\n-            raise KeyError(value)\n-        self.discard(value)\n-\n-    def pop(self):\n-        \"\"\"Return the popped value.  Raise KeyError if empty.\"\"\"\n-        it = iter(self)\n-        try:\n-            value = next(it)\n-        except StopIteration:\n-            raise KeyError\n-        self.discard(value)\n-        return value\n-\n-    def clear(self):\n-        \"\"\"This is slow (creates N new iterators!) but effective.\"\"\"\n-        try:\n-            while True:\n-                self.pop()\n-        except KeyError:\n-            pass\n-\n-    def __ior__(self, it):\n-        for value in it:\n-            self.add(value)\n-        return self\n-\n-    def __iand__(self, it):\n-        for value in (self - it):\n-            self.discard(value)\n-        return self\n-\n-    def __ixor__(self, it):\n-        if it is self:\n-            self.clear()\n-        else:\n-            if not isinstance(it, Set):\n-                it = self._from_iterable(it)\n-            for value in it:\n-                if value in self:\n-                    self.discard(value)\n-                else:\n-                    self.add(value)\n-        return self\n-\n-    def __isub__(self, it):\n-        if it is self:\n-            self.clear()\n-        else:\n-            for value in it:\n-                self.discard(value)\n-        return self\n-\n-MutableSet.register(set)\n-\n-\n-### MAPPINGS ###\n-\n-\n-class Mapping(Sized, Iterable, Container):\n-\n-    @abstractmethod\n-    def __getitem__(self, key):\n-        raise KeyError\n-\n-    def get(self, key, default=None):\n-        try:\n-            return self[key]\n-        except KeyError:\n-            return default\n-\n-    def __contains__(self, key):\n-        try:\n-            self[key]\n-        except KeyError:\n-            return False\n-        else:\n-            return True\n-\n-    def iterkeys(self):\n-        return iter(self)\n-\n-    def itervalues(self):\n-        for key in self:\n-            yield self[key]\n-\n-    def iteritems(self):\n-        for key in self:\n-            yield (key, self[key])\n-\n-    def keys(self):\n-        return list(self)\n-\n-    def items(self):\n-        return [(key, self[key]) for key in self]\n-\n-    def values(self):\n-        return [self[key] for key in self]\n-\n-    # Mappings are not hashable by default, but subclasses can change this\n-    __hash__ = None\n-\n-    def __eq__(self, other):\n-        if not isinstance(other, Mapping):\n-            return NotImplemented\n-        return dict(self.items()) == dict(other.items())\n-\n-    def __ne__(self, other):\n-        return not (self == other)\n-\n-class MappingView(Sized):\n-\n-    def __init__(self, mapping):\n-        self._mapping = mapping\n-\n-    def __len__(self):\n-        return len(self._mapping)\n-\n-    def __repr__(self):\n-        return '{0.__class__.__name__}({0._mapping!r})'.format(self)\n-\n-\n-class KeysView(MappingView, Set):\n-\n-    @classmethod\n-    def _from_iterable(self, it):\n-        return set(it)\n-\n-    def __contains__(self, key):\n-        return key in self._mapping\n-\n-    def __iter__(self):\n-        for key in self._mapping:\n-            yield key\n-\n-\n-class ItemsView(MappingView, Set):\n-\n-    @classmethod\n-    def _from_iterable(self, it):\n-        return set(it)\n-\n-    def __contains__(self, item):\n-        key, value = item\n-        try:\n-            v = self._mapping[key]\n-        except KeyError:\n-            return False\n-        else:\n-            return v == value\n-\n-    def __iter__(self):\n-        for key in self._mapping:\n-            yield (key, self._mapping[key])\n-\n-\n-class ValuesView(MappingView):\n-\n-    def __contains__(self, value):\n-        for key in self._mapping:\n-            if value == self._mapping[key]:\n-                return True\n-        return False\n-\n-    def __iter__(self):\n-        for key in self._mapping:\n-            yield self._mapping[key]\n-\n-\n-class MutableMapping(Mapping):\n-\n-    @abstractmethod\n-    def __setitem__(self, key, value):\n-        raise KeyError\n-\n-    @abstractmethod\n-    def __delitem__(self, key):\n-        raise KeyError\n-\n-    __marker = object()\n-\n-    def pop(self, key, default=__marker):\n-        try:\n-            value = self[key]\n-        except KeyError:\n-            if default is self.__marker:\n-                raise\n-            return default\n-        else:\n-            del self[key]\n-            return value\n-\n-    def popitem(self):\n-        try:\n-            key = next(iter(self))\n-        except StopIteration:\n-            raise KeyError\n-        value = self[key]\n-        del self[key]\n-        return key, value\n-\n-    def clear(self):\n-        try:\n-            while True:\n-                self.popitem()\n-        except KeyError:\n-            pass\n-\n-    def update(*args, **kwds):\n-        if len(args) > 2:\n-            raise TypeError(\"update() takes at most 2 positional \"\n-                            \"arguments ({} given)\".format(len(args)))\n-        elif not args:\n-            raise TypeError(\"update() takes at least 1 argument (0 given)\")\n-        self = args[0]\n-        other = args[1] if len(args) >= 2 else ()\n-\n-        if isinstance(other, Mapping):\n-            for key in other:\n-                self[key] = other[key]\n-        elif hasattr(other, \"keys\"):\n-            for key in other.keys():\n-                self[key] = other[key]\n-        else:\n-            for key, value in other:\n-                self[key] = value\n-        for key, value in kwds.items():\n-            self[key] = value\n-\n-    def setdefault(self, key, default=None):\n-        try:\n-            return self[key]\n-        except KeyError:\n-            self[key] = default\n-        return default\n-\n-MutableMapping.register(dict)\n-\n-\n-### SEQUENCES ###\n-\n-\n-class Sequence(Sized, Iterable, Container):\n-    \"\"\"All the operations on a read-only sequence.\n-\n-    Concrete subclasses must override __new__ or __init__,\n-    __getitem__, and __len__.\n-    \"\"\"\n-\n-    @abstractmethod\n-    def __getitem__(self, index):\n-        raise IndexError\n-\n-    def __iter__(self):\n-        i = 0\n-        try:\n-            while True:\n-                v = self[i]\n-                yield v\n-                i += 1\n-        except IndexError:\n-            return\n-\n-    def __contains__(self, value):\n-        for v in self:\n-            if v == value:\n-                return True\n-        return False\n-\n-    def __reversed__(self):\n-        for i in reversed(range(len(self))):\n-            yield self[i]\n-\n-    def index(self, value):\n-        for i, v in enumerate(self):\n-            if v == value:\n-                return i\n-        raise ValueError\n-\n-    def count(self, value):\n-        return sum(1 for v in self if v == value)\n-\n-Sequence.register(tuple)\n-Sequence.register(basestring)\n-Sequence.register(buffer)\n-Sequence.register(xrange)\n-\n-\n-class MutableSequence(Sequence):\n-\n-    @abstractmethod\n-    def __setitem__(self, index, value):\n-        raise IndexError\n-\n-    @abstractmethod\n-    def __delitem__(self, index):\n-        raise IndexError\n-\n-    @abstractmethod\n-    def insert(self, index, value):\n-        raise IndexError\n-\n-    def append(self, value):\n-        self.insert(len(self), value)\n-\n-    def reverse(self):\n-        n = len(self)\n-        for i in range(n//2):\n-            self[i], self[n-i-1] = self[n-i-1], self[i]\n-\n-    def extend(self, values):\n-        for v in values:\n-            self.append(v)\n-\n-    def pop(self, index=-1):\n-        v = self[index]\n-        del self[index]\n-        return v\n-\n-    def remove(self, value):\n-        del self[self.index(value)]\n-\n-    def __iadd__(self, values):\n-        self.extend(values)\n-        return self\n-\n-MutableSequence.register(list)\n-\n\n\n@@ -4,14 +4,9 @@\n # This module is part of urllib3 and is released under\n # the MIT License: http://www.opensource.org/licenses/mit-license.php\n \n-\n from collections import deque\n-from threading import RLock\n \n-try:\n-    from collections import MutableMapping\n-except ImportError:\n-    from .__collections import MutableMapping\n+from threading import RLock\n \n __all__ = ['RecentlyUsedContainer']\n \n@@ -24,7 +19,7 @@ class AccessEntry(object):\n         self.is_valid = is_valid\n \n \n-class RecentlyUsedContainer(MutableMapping):\n+class RecentlyUsedContainer(dict):\n     \"\"\"\n     Provides a dict-like that maintains up to ``maxsize`` keys while throwing\n     away the least-recently-used keys beyond ``maxsize``.\n@@ -81,7 +76,7 @@ class RecentlyUsedContainer(MutableMapping):\n             if not p.is_valid:\n                 continue # Invalidated entry, skip\n \n-            self._container.pop(p.key, None)\n+            dict.pop(self, p.key, None)\n             self.access_lookup.pop(p.key, None)\n             num -= 1\n \n@@ -100,7 +95,7 @@ class RecentlyUsedContainer(MutableMapping):\n         return r\n \n     def __getitem__(self, key):\n-        item = self._container.get(key)\n+        item = dict.get(self, key)\n \n         if not item:\n             raise KeyError(key)\n@@ -118,22 +113,19 @@ class RecentlyUsedContainer(MutableMapping):\n \n     def __setitem__(self, key, item):\n         # Add item to our container and access log\n-        self._container[key] = item\n+        dict.__setitem__(self, key, item)\n         self._push_entry(key)\n \n         # Discard invalid and excess entries\n-        self._prune_entries(len(self._container) - self._maxsize)\n+        self._prune_entries(len(self) - self._maxsize)\n \n     def __delitem__(self, key):\n         self._invalidate_entry(key)\n-        del self._container[key]\n-        del self.access_lookup[key]\n+        self.access_lookup.pop(key, None)\n+        dict.__delitem__(self, key)\n \n-    def __len__(self):\n-        return self._container.__len__()\n-\n-    def __iter__(self):\n-        return self._container.__iter__()\n-\n-    def __contains__(self, key):\n-        return self._container.__contains__(key)\n+    def get(self, key, default=None):\n+        try:\n+            return self[key]\n+        except KeyError:\n+            return default\n\n@@ -338,7 +338,7 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n \n         except (SocketTimeout, Empty), e:\n             # Timed out either by socket or queue\n-            raise TimeoutError(\"Request timed out after %s seconds\" %\n+            raise TimeoutError(\"Request timed out after %f seconds\" %\n                                self.timeout)\n \n         except (BaseSSLError), e:\n\n\n\n\n\n\n\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#bcc48a9607daf87a90bc2a70d9bfaac79b56d80c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 3734 | Contributors (this commit): 21 | Commits (past 90d): 139 | Contributors (cumulative): 21 | DMM Complexity: None\n\nDIFF:\n@@ -1,4 +1,3 @@\n-\n # -*- coding: utf-8 -*-\n \n \"\"\"\n@@ -31,8 +30,6 @@ from .utils import (\n     decode_gzip, stream_decode_gzip, guess_filename)\n \n \n-\n-\n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f0edd4a3e0207d0ce447c9f09fc7e46d5cab118b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 1 | Churn Cumulative: 3735 | Contributors (this commit): 22 | Commits (past 90d): 136 | Contributors (cumulative): 22 | DMM Complexity: 0.0\n\nDIFF:\n@@ -239,6 +239,7 @@ class Request(object):\n                     cookies=cookies,\n                     redirect=True,\n                     config=self.config,\n+                    timeout=self.timeout,\n                     _poolmanager=self._poolmanager\n                 )\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#35b0c5e16ea01a077357057fdd1b60fcfd64a73f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 3737 | Contributors (this commit): 23 | Commits (past 90d): 137 | Contributors (cumulative): 23 | DMM Complexity: None\n\nDIFF:\n@@ -377,7 +377,7 @@ class Request(object):\n         proxy = self.proxies.get(_p.scheme)\n \n         if proxy:\n-            conn = poolmanager.proxy_from_url(url)\n+            conn = poolmanager.proxy_from_url(proxy)\n         else:\n             # Check to see if keep_alive is allowed.\n             if self.config.get('keep_alive'):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#7c66e6f267016b84f9cbf55ebf10ee0219ea5562", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 3740 | Contributors (this commit): 23 | Commits (past 90d): 128 | Contributors (cumulative): 23 | DMM Complexity: 0.0\n\nDIFF:\n@@ -240,7 +240,8 @@ class Request(object):\n                     redirect=True,\n                     config=self.config,\n                     timeout=self.timeout,\n-                    _poolmanager=self._poolmanager\n+                    _poolmanager=self._poolmanager,\n+                    proxies = self.proxies,\n                 )\n \n                 request.send()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4504953212816c4de0cd8177faf1270e42cb31f9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 37 | Lines Deleted: 12 | Files Changed: 1 | Hunks: 10 | Methods Changed: 6 | Complexity Δ (Sum/Max): 4/4 | Churn Δ: 49 | Churn Cumulative: 3789 | Contributors (this commit): 23 | Commits (past 90d): 126 | Contributors (cumulative): 23 | DMM Complexity: 1.0\n\nDIFF:\n@@ -11,7 +11,7 @@ import urllib\n import zlib\n \n from Cookie import SimpleCookie\n-from urlparse import urlparse, urlunparse, urljoin\n+from urlparse import urlparse, urlunparse, urljoin, urlsplit\n from datetime import datetime\n \n from .auth import dispatch as auth_dispatch\n@@ -181,7 +181,7 @@ class Request(object):\n             if is_error:\n                 response.error = resp\n \n-            response.url = self._build_url()\n+            response.url = self.full_url\n \n             return response\n \n@@ -281,8 +281,8 @@ class Request(object):\n         else:\n             return data, data\n \n-\n-    def _build_url(self):\n+    @property\n+    def full_url(self):\n         \"\"\"Build the actual URL to use.\"\"\"\n \n         if not self.url:\n@@ -300,15 +300,41 @@ class Request(object):\n             path = path.encode('utf-8')\n \n         path = urllib.quote(urllib.unquote(path))\n-        self.url = str(urlunparse([ scheme, netloc, path, params, query, fragment ]))\n+\n+        url = str(urlunparse([ scheme, netloc, path, params, query, fragment ]))\n \n         if self._enc_params:\n-            if urlparse(self.url).query:\n-                return '%s&%s' % (self.url, self._enc_params)\n+            if urlparse(url).query:\n+                return '%s&%s' % (url, self._enc_params)\n             else:\n-                return '%s?%s' % (self.url, self._enc_params)\n+                return '%s?%s' % (url, self._enc_params)\n         else:\n-            return self.url\n+            return url\n+\n+    @property\n+    def path_url(self):\n+        \"\"\"Build the path URL to use.\"\"\"\n+\n+        url = []\n+\n+        p = urlsplit(self.full_url)\n+\n+        # Proxies use full URLs.\n+        if p.scheme in self.proxies:\n+            return self.full_url\n+\n+        path = p.path\n+        if not path:\n+            path = '/'\n+        url.append(path)\n+\n+        query = p.query\n+        if query:\n+            url.append('?')\n+            url.append(query)\n+\n+        return ''.join(url)\n+\n \n \n     def send(self, anyway=False, prefetch=False):\n@@ -329,7 +355,7 @@ class Request(object):\n             ))\n \n         # Build the URL\n-        url = self._build_url()\n+        url = self.full_url\n \n         # Nottin' on you.\n         body = None\n@@ -406,10 +432,9 @@ class Request(object):\n \n             try:\n                 # Send the request.\n-\n                 r = conn.urlopen(\n                     method=self.method,\n-                    url=url,\n+                    url=self.path_url,\n                     body=body,\n                     headers=self.headers,\n                     redirect=False,\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b79dea97fd0d24bc1dbe52366565361c08675512", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 223 | Contributors (this commit): 3 | Commits (past 90d): 21 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n@@ -15,8 +15,8 @@ requests\n \"\"\"\n \n __title__ = 'requests'\n-__version__ = '0.8.0'\n-__build__ = 0x000800\n+__version__ = '0.8.1'\n+__build__ = 0x000801\n __author__ = 'Kenneth Reitz'\n __license__ = 'ISC'\n __copyright__ = 'Copyright 2011 Kenneth Reitz'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#6b129ec0c991536b7e61e204faa6886b6f086494", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 1647 | Contributors (this commit): 1 | Commits (past 90d): 16 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -338,7 +338,7 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n \n         except (SocketTimeout, Empty), e:\n             # Timed out either by socket or queue\n-            raise TimeoutError(\"Request timed out after %f seconds\" %\n+            raise TimeoutError(\"Request timed out after %s seconds\" %\n                                self.timeout)\n \n         except (BaseSSLError), e:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#bf499a80de4a0a6f0ab6a47caa0fbc5e8d03cc03", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 8 | Churn Cumulative: 3797 | Contributors (this commit): 24 | Commits (past 90d): 126 | Contributors (cumulative): 24 | DMM Complexity: 0.0\n\nDIFF:\n@@ -371,7 +371,13 @@ class Request(object):\n                     fields = dict(self.data)\n \n                 for (k, v) in self.files.items():\n-                    fields.update({k: (guess_filename(k) or k, v.read())})\n+                    # support for explicit filename\n+                    if isinstance(v, (tuple, list)):\n+                        fn, fp = v\n+                    else:\n+                        fn = guess_filename(v) or k\n+                        fp = v\n+                    fields.update({k: (fn, fp.read())})\n \n                 (body, content_type) = encode_multipart_formdata(fields)\n             else:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#89241c525ea7bef5e3efdce2837e2b82f8754848", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 3799 | Contributors (this commit): 24 | Commits (past 90d): 127 | Contributors (cumulative): 24 | DMM Complexity: None\n\nDIFF:\n@@ -431,7 +431,7 @@ class Request(object):\n                         c[k] = v\n \n                     # Turn it into a header.\n-                    cookie_header = c.output(header='').strip()\n+                    cookie_header = c.output(header='', sep='; ').strip()\n \n                     # Attach Cookie header to request.\n                     self.headers['Cookie'] = cookie_header\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f7fdfe8b9ab1aec824c61ead321263d5c90fa599", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 5 | Methods Changed: 3 | Complexity Δ (Sum/Max): 1/2 | Churn Δ: 18 | Churn Cumulative: 4626 | Contributors (this commit): 26 | Commits (past 90d): 166 | Contributors (cumulative): 33 | DMM Complexity: 1.0\n\nDIFF:\n@@ -27,7 +27,7 @@ from .exceptions import (\n     Timeout, URLRequired, TooManyRedirects, HTTPError, ConnectionError)\n from .utils import (\n     get_unicode_from_response, stream_decode_response_unicode,\n-    decode_gzip, stream_decode_gzip, guess_filename)\n+    decode_gzip, stream_decode_gzip, guess_filename, requote_path)\n \n \n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n@@ -214,7 +214,7 @@ class Request(object):\n                 # Facilitate non-RFC2616-compliant 'location' headers\n                 # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n                 if not urlparse(url).netloc:\n-                    url = urljoin(r.url, urllib.quote(urllib.unquote(url)))\n+                    url = urljoin(r.url, requote_path(url))\n \n                 # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n                 if r.status_code is codes.see_other:\n@@ -299,7 +299,7 @@ class Request(object):\n         if isinstance(path, unicode):\n             path = path.encode('utf-8')\n \n-        path = urllib.quote(urllib.unquote(path))\n+        path = requote_path(path)\n \n         url = str(urlunparse([ scheme, netloc, path, params, query, fragment ]))\n \n\n@@ -16,6 +16,7 @@ import os\n import random\n import re\n import zlib\n+import urllib\n \n from urllib2 import parse_http_list as _parse_list_header\n \n@@ -367,3 +368,14 @@ def stream_decode_gzip(iterator):\n             yield rv\n     except zlib.error:\n         pass\n+\n+\n+def requote_path(path):\n+    \"\"\"Re-quote the given URL path component.\n+\n+    This function passes the given path through an unquote/quote cycle to\n+    ensure that it is fully and consistenty quoted.\n+    \"\"\"\n+    parts = path.split(\"/\")\n+    parts = (urllib.quote(urllib.unquote(part), safe=\"\") for part in parts)\n+    return \"/\".join(parts)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
