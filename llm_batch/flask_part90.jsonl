{"custom_id": "flask#846ee2c62e369ed06190b8791088748bd3a83557", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 12 | Churn Cumulative: 1084 | Contributors (this commit): 16 | Commits (past 90d): 16 | Contributors (cumulative): 18 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1270,7 +1270,9 @@ class Flask(_PackageBoundObject):\n         else:\n             exc_class = exc_class_or_code\n \n-        assert issubclass(exc_class, Exception)\n+        assert issubclass(\n+            exc_class, Exception\n+        ), \"Custom exceptions must be subclasses of Exception.\"\n \n         if issubclass(exc_class, HTTPException):\n             return exc_class, exc_class.code\n\n@@ -11,11 +11,19 @@ def test_error_handler_no_match(app, client):\n     class CustomException(Exception):\n         pass\n \n+    class UnacceptableCustomException(BaseException):\n+        pass\n+\n     @app.errorhandler(CustomException)\n     def custom_exception_handler(e):\n         assert isinstance(e, CustomException)\n         return \"custom\"\n \n+    with pytest.raises(\n+        AssertionError, match=\"Custom exceptions must be subclasses of Exception.\"\n+    ):\n+        app.register_error_handler(UnacceptableCustomException, None)\n+\n     @app.errorhandler(500)\n     def handle_500(e):\n         assert isinstance(e, InternalServerError)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#eea31f29a50eeb30ec3c314bb2a6de4c931095c1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 12 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 13 | Churn Cumulative: 848 | Contributors (this commit): 30 | Commits (past 90d): 4 | Contributors (cumulative): 30 | DMM Complexity: None\n\nDIFF:\n@@ -15,16 +15,5 @@ setup(\n         \"itsdangerous>=0.24\",\n         \"click>=5.1\",\n     ],\n-    extras_require={\n-        \"dotenv\": [\"python-dotenv\"],\n-        \"dev\": [\n-            \"pytest\",\n-            \"coverage\",\n-            \"tox\",\n-            \"sphinx\",\n-            \"pallets-sphinx-themes\",\n-            \"sphinxcontrib-log-cabinet\",\n-            \"sphinx-issues\",\n-        ],\n-    },\n+    extras_require={\"dotenv\": [\"python-dotenv\"]},\n )\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#84cbfc0698f429c93450cd6f1600e56b41a30247", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 8 | Files Changed: 2 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 9 | Churn Cumulative: 1847 | Contributors (this commit): 27 | Commits (past 90d): 18 | Contributors (cumulative): 29 | DMM Complexity: 1.0\n\nDIFF:\n@@ -610,10 +610,6 @@ def load_dotenv(path=None):\n     If an env var is already set it is not overwritten, so earlier files in the\n     list are preferred over later files.\n \n-    Changes the current working directory to the location of the first file\n-    found, with the assumption that it is in the top level project directory\n-    and will be where the Python path should import local packages from.\n-\n     This is a no-op if `python-dotenv`_ is not installed.\n \n     .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme\n@@ -659,9 +655,6 @@ def load_dotenv(path=None):\n \n         dotenv.load_dotenv(path)\n \n-    if new_dir and os.getcwd() != new_dir:\n-        os.chdir(new_dir)\n-\n     return new_dir is not None  # at least one file was located and loaded\n \n \n\n@@ -504,7 +504,7 @@ def test_load_dotenv(monkeypatch):\n         monkeypatch._setitem.append((os.environ, item, notset))\n \n     monkeypatch.setenv(\"EGGS\", \"3\")\n-    monkeypatch.chdir(os.path.join(test_path, \"cliapp\", \"inner1\"))\n+    monkeypatch.chdir(test_path)\n     assert load_dotenv()\n     assert os.getcwd() == test_path\n     # .flaskenv doesn't overwrite .env\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#7ba35c4d4fe99418cee9c87900bd0d3b38cf5bd0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 12 | Churn Cumulative: 4668 | Contributors (this commit): 40 | Commits (past 90d): 16 | Contributors (cumulative): 43 | DMM Complexity: 1.0\n\nDIFF:\n@@ -980,7 +980,7 @@ class _PackageBoundObject:\n     @static_folder.setter\n     def static_folder(self, value):\n         if value is not None:\n-            value = value.rstrip(\"/\\\\\")\n+            value = os.fspath(value).rstrip(r\"\\/\")\n         self._static_folder = value\n \n     @property\n\n@@ -1406,6 +1406,16 @@ def test_static_url_empty_path_default(app):\n     rv.close()\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 6), reason=\"requires Python >= 3.6\")\n+def test_static_folder_with_pathlib_path(app):\n+    from pathlib import Path\n+\n+    app = flask.Flask(__name__, static_folder=Path(\"static\"))\n+    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n+    assert rv.status_code == 200\n+    rv.close()\n+\n+\n def test_static_folder_with_ending_slash():\n     app = flask.Flask(__name__, static_folder=\"static/\")\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#b724832872ae4b4cd4b5f61c153eae39f1c3b213", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 6/4 | Churn Δ: 12 | Churn Cumulative: 4680 | Contributors (this commit): 40 | Commits (past 90d): 18 | Contributors (cumulative): 43 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1001,7 +1001,7 @@ class _PackageBoundObject(object):\n     @static_folder.setter\n     def static_folder(self, value):\n         if value is not None:\n-            value = value.rstrip(\"/\\\\\")\n+            value = os.fspath(value).rstrip(r\"\\/\")\n         self._static_folder = value\n \n     @property\n\n@@ -1425,6 +1425,16 @@ def test_static_url_empty_path_default(app):\n     rv.close()\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 6), reason=\"requires Python >= 3.6\")\n+def test_static_folder_with_pathlib_path(app):\n+    from pathlib import Path\n+\n+    app = flask.Flask(__name__, static_folder=Path(\"static\"))\n+    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n+    assert rv.status_code == 200\n+    rv.close()\n+\n+\n def test_static_folder_with_ending_slash():\n     app = flask.Flask(__name__, static_folder=\"static/\")\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#4a1acc8b5f0b5608fa8f20a1ef3afc13574cb96e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): -4/0 | Churn Δ: 3 | Churn Cumulative: 264 | Contributors (this commit): 5 | Commits (past 90d): 3 | Contributors (cumulative): 5 | DMM Complexity: 0.0\n\nDIFF:\n@@ -437,7 +437,8 @@ def get_flashed_messages(with_categories=False, category_filter=()):\n         `category_filter` parameter added.\n \n     :param with_categories: set to ``True`` to also receive categories.\n-    :param category_filter: whitelist of categories to limit return values\n+    :param category_filter: filter of categories to limit return values.  Only\n+                            categories in the list will be returned.\n     \"\"\"\n     flashes = _request_ctx_stack.top.flashes\n     if flashes is None:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#7b09a0904c32dc8784cdd68e842442057340a361", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 7 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 3 | Methods Changed: 3 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 11 | Churn Cumulative: 4913 | Contributors (this commit): 45 | Commits (past 90d): 5 | Contributors (cumulative): 48 | DMM Complexity: 1.0\n\nDIFF:\n@@ -2045,7 +2045,7 @@ class Flask(_PackageBoundObject):\n \n         # extend existing headers with provided headers\n         if headers:\n-            rv.headers.extend(headers)\n+            rv.headers.update(headers)\n \n         return rv\n \n\n@@ -1117,8 +1117,10 @@ def test_response_types(app, client):\n     @app.route(\"/response_headers\")\n     def from_response_headers():\n         return (\n-            flask.Response(\"Hello world\", 404, {\"X-Foo\": \"Baz\"}),\n-            {\"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n+            flask.Response(\n+                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n+            ),\n+            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n         )\n \n     @app.route(\"/response_status\")\n@@ -1155,7 +1157,8 @@ def test_response_types(app, client):\n \n     rv = client.get(\"/response_headers\")\n     assert rv.data == b\"Hello world\"\n-    assert rv.headers.getlist(\"X-Foo\") == [\"Baz\", \"Bar\"]\n+    assert rv.content_type == \"text/plain\"\n+    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n     assert rv.headers[\"X-Bar\"] == \"Foo\"\n     assert rv.status_code == 404\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#75a9b7465003205981b97fd4a133b07d7c330167", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 13 | Files Changed: 2 | Hunks: 8 | Methods Changed: 8 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 13 | Churn Cumulative: 4616 | Contributors (this commit): 56 | Commits (past 90d): 2 | Contributors (cumulative): 65 | DMM Complexity: None\n\nDIFF:\n@@ -44,7 +44,6 @@ def test_cli_name(test_apps):\n \n \n def test_find_best_app(test_apps):\n-    \"\"\"Test if `find_best_app` behaves as expected with different combinations of input.\"\"\"  # noqa: B950\n     script_info = ScriptInfo()\n \n     class Module:\n@@ -271,7 +270,6 @@ def test_get_version(test_apps, capsys):\n \n \n def test_scriptinfo(test_apps, monkeypatch):\n-    \"\"\"Test of ScriptInfo.\"\"\"\n     obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n     app = obj.load_app()\n     assert app.name == \"testapp\"\n@@ -321,8 +319,6 @@ def test_scriptinfo(test_apps, monkeypatch):\n \n \n def test_with_appcontext(runner):\n-    \"\"\"Test of with_appcontext.\"\"\"\n-\n     @click.command()\n     @with_appcontext\n     def testcmd():\n@@ -336,8 +332,6 @@ def test_with_appcontext(runner):\n \n \n def test_appgroup(runner):\n-    \"\"\"Test of with_appcontext.\"\"\"\n-\n     @click.group(cls=AppGroup)\n     def cli():\n         pass\n@@ -366,8 +360,6 @@ def test_appgroup(runner):\n \n \n def test_flaskgroup(runner):\n-    \"\"\"Test FlaskGroup.\"\"\"\n-\n     def create_app():\n         return Flask(\"flaskgroup\")\n \n@@ -386,8 +378,6 @@ def test_flaskgroup(runner):\n \n @pytest.mark.parametrize(\"set_debug_flag\", (True, False))\n def test_flaskgroup_debug(runner, set_debug_flag):\n-    \"\"\"Test FlaskGroup debug flag behavior.\"\"\"\n-\n     def create_app():\n         app = Flask(\"flaskgroup\")\n         app.debug = True\n\n@@ -116,8 +116,6 @@ class TestJSON:\n         \"test_value\", [0, -1, 1, 23, 3.14, \"s\", \"longer string\", True, False, None]\n     )\n     def test_jsonify_basic_types(self, test_value, app, client):\n-        \"\"\"Test jsonify with basic types.\"\"\"\n-\n         url = \"/jsonify_basic_types\"\n         app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n         rv = client.get(url)\n@@ -125,7 +123,6 @@ class TestJSON:\n         assert flask.json.loads(rv.data) == test_value\n \n     def test_jsonify_dicts(self, app, client):\n-        \"\"\"Test jsonify with dicts and kwargs unpacking.\"\"\"\n         d = {\n             \"a\": 0,\n             \"b\": 23,\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#253570784cdcc85d82142128ce33e3b9d8f8db14", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 57 | Lines Deleted: 38 | Files Changed: 3 | Hunks: 15 | Methods Changed: 12 | Complexity Δ (Sum/Max): 2/1 | Churn Δ: 95 | Churn Cumulative: 2350 | Contributors (this commit): 33 | Commits (past 90d): 4 | Contributors (cumulative): 38 | DMM Complexity: 1.0\n\nDIFF:\n@@ -536,43 +536,41 @@ class FlaskGroup(AppGroup):\n \n     def get_command(self, ctx, name):\n         self._load_plugin_commands()\n+        # Look up built-in and plugin commands, which should be\n+        # available even if the app fails to load.\n+        rv = super().get_command(ctx, name)\n \n-        # We load built-in commands first as these should always be the\n-        # same no matter what the app does.  If the app does want to\n-        # override this it needs to make a custom instance of this group\n-        # and not attach the default commands.\n-        #\n-        # This also means that the script stays functional in case the\n-        # application completely fails.\n-        rv = AppGroup.get_command(self, ctx, name)\n         if rv is not None:\n             return rv\n \n         info = ctx.ensure_object(ScriptInfo)\n+\n+        # Look up commands provided by the app, showing an error and\n+        # continuing if the app couldn't be loaded.\n         try:\n-            rv = info.load_app().cli.get_command(ctx, name)\n-            if rv is not None:\n-                return rv\n-        except NoAppException:\n-            pass\n+            return info.load_app().cli.get_command(ctx, name)\n+        except NoAppException as e:\n+            click.secho(f\"Error: {e.format_message()}\\n\", err=True, fg=\"red\")\n \n     def list_commands(self, ctx):\n         self._load_plugin_commands()\n-\n-        # The commands available is the list of both the application (if\n-        # available) plus the builtin commands.\n-        rv = set(click.Group.list_commands(self, ctx))\n+        # Start with the built-in and plugin commands.\n+        rv = set(super().list_commands(ctx))\n         info = ctx.ensure_object(ScriptInfo)\n+\n+        # Add commands provided by the app, showing an error and\n+        # continuing if the app couldn't be loaded.\n         try:\n             rv.update(info.load_app().cli.list_commands(ctx))\n+        except NoAppException as e:\n+            # When an app couldn't be loaded, show the error message\n+            # without the traceback.\n+            click.secho(f\"Error: {e.format_message()}\\n\", err=True, fg=\"red\")\n         except Exception:\n-            # Here we intentionally swallow all exceptions as we don't\n-            # want the help page to break if the app does not exist.\n-            # If someone attempts to use the command we try to create\n-            # the app again and this will give us the error.\n-            # However, we will not do so silently because that would confuse\n-            # users.\n-            traceback.print_exc()\n+            # When any other errors occurred during loading, show the\n+            # full traceback.\n+            click.secho(f\"{traceback.format_exc()}\\n\", err=True, fg=\"red\")\n+\n         return sorted(rv)\n \n     def main(self, *args, **kwargs):\n\n@@ -73,9 +73,15 @@ def client(app):\n \n @pytest.fixture\n def test_apps(monkeypatch):\n-    monkeypatch.syspath_prepend(\n-        os.path.abspath(os.path.join(os.path.dirname(__file__), \"test_apps\"))\n-    )\n+    monkeypatch.syspath_prepend(os.path.join(os.path.dirname(__file__), \"test_apps\"))\n+    original_modules = set(sys.modules.keys())\n+\n+    yield\n+\n+    # Remove any imports cached during the test. Otherwise \"import app\"\n+    # will work in the next test even though it's no longer on the path.\n+    for key in sys.modules.keys() - original_modules:\n+        sys.modules.pop(key)\n \n \n @pytest.fixture(autouse=True)\n\n@@ -239,7 +239,7 @@ def test_locate_app_raises(test_apps, iname, aname):\n         locate_app(info, iname, aname)\n \n \n-def test_locate_app_suppress_raise():\n+def test_locate_app_suppress_raise(test_apps):\n     info = ScriptInfo()\n     app = locate_app(info, \"notanapp.py\", None, raise_if_not_found=False)\n     assert app is None\n@@ -396,21 +396,36 @@ def test_flaskgroup_debug(runner, set_debug_flag):\n     assert result.output == f\"{not set_debug_flag}\\n\"\n \n \n-def test_print_exceptions(runner):\n-    \"\"\"Print the stacktrace if the CLI.\"\"\"\n+def test_no_command_echo_loading_error():\n+    from flask.cli import cli\n \n-    def create_app():\n-        raise Exception(\"oh no\")\n-        return Flask(\"flaskgroup\")\n+    runner = CliRunner(mix_stderr=False)\n+    result = runner.invoke(cli, [\"missing\"])\n+    assert result.exit_code == 2\n+    assert \"FLASK_APP\" in result.stderr\n+    assert \"Usage:\" in result.stderr\n \n-    @click.group(cls=FlaskGroup, create_app=create_app)\n-    def cli(**params):\n-        pass\n \n+def test_help_echo_loading_error():\n+    from flask.cli import cli\n+\n+    runner = CliRunner(mix_stderr=False)\n     result = runner.invoke(cli, [\"--help\"])\n     assert result.exit_code == 0\n-    assert \"Exception: oh no\" in result.output\n-    assert \"Traceback\" in result.output\n+    assert \"FLASK_APP\" in result.stderr\n+    assert \"Usage:\" in result.stdout\n+\n+\n+def test_help_echo_exception():\n+    def create_app():\n+        raise Exception(\"oh no\")\n+\n+    cli = FlaskGroup(create_app=create_app)\n+    runner = CliRunner(mix_stderr=False)\n+    result = runner.invoke(cli, [\"--help\"])\n+    assert result.exit_code == 0\n+    assert \"Exception: oh no\" in result.stderr\n+    assert \"Usage:\" in result.stdout\n \n \n class TestRoutes:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#b146a13f633b0e2e26e3b8383b3db0feb563bc83", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 468 | Lines Deleted: 495 | Files Changed: 4 | Hunks: 35 | Methods Changed: 60 | Complexity Δ (Sum/Max): -2/26 | Churn Δ: 963 | Churn Cumulative: 1736 | Contributors (this commit): 13 | Commits (past 90d): 6 | Contributors (cumulative): 18 | DMM Complexity: 0.0\n\nDIFF:\n@@ -1,7 +1,6 @@\n import os\n import sys\n from datetime import timedelta\n-from functools import update_wrapper\n from itertools import chain\n from threading import Lock\n \n@@ -9,7 +8,6 @@ from werkzeug.datastructures import Headers\n from werkzeug.datastructures import ImmutableDict\n from werkzeug.exceptions import BadRequest\n from werkzeug.exceptions import BadRequestKeyError\n-from werkzeug.exceptions import default_exceptions\n from werkzeug.exceptions import HTTPException\n from werkzeug.exceptions import InternalServerError\n from werkzeug.routing import BuildError\n@@ -30,8 +28,6 @@ from .globals import _request_ctx_stack\n from .globals import g\n from .globals import request\n from .globals import session\n-from .helpers import _endpoint_from_view_func\n-from .helpers import _PackageBoundObject\n from .helpers import find_package\n from .helpers import get_debug_flag\n from .helpers import get_env\n@@ -41,21 +37,21 @@ from .helpers import locked_cached_property\n from .helpers import url_for\n from .json import jsonify\n from .logging import create_logger\n+from .scaffold import _endpoint_from_view_func\n+from .scaffold import _sentinel\n+from .scaffold import Scaffold\n+from .scaffold import setupmethod\n from .sessions import SecureCookieSessionInterface\n from .signals import appcontext_tearing_down\n from .signals import got_request_exception\n from .signals import request_finished\n from .signals import request_started\n from .signals import request_tearing_down\n-from .templating import _default_template_ctx_processor\n from .templating import DispatchingJinjaLoader\n from .templating import Environment\n from .wrappers import Request\n from .wrappers import Response\n \n-# a singleton sentinel value for parameter defaults\n-_sentinel = object()\n-\n \n def _make_timedelta(value):\n     if not isinstance(value, timedelta):\n@@ -63,28 +59,7 @@ def _make_timedelta(value):\n     return value\n \n \n-def setupmethod(f):\n-    \"\"\"Wraps a method so that it performs a check in debug mode if the\n-    first request was already handled.\n-    \"\"\"\n-\n-    def wrapper_func(self, *args, **kwargs):\n-        if self.debug and self._got_first_request:\n-            raise AssertionError(\n-                \"A setup function was called after the \"\n-                \"first request was handled.  This usually indicates a bug \"\n-                \"in the application where a module was not imported \"\n-                \"and decorators or other functionality was called too late.\\n\"\n-                \"To fix this make sure to import all your view modules, \"\n-                \"database models and everything related at a central place \"\n-                \"before the application starts serving requests.\"\n-            )\n-        return f(self, *args, **kwargs)\n-\n-    return update_wrapper(wrapper_func, f)\n-\n-\n-class Flask(_PackageBoundObject):\n+class Flask(Scaffold):\n     \"\"\"The flask object implements a WSGI application and acts as the central\n     object.  It is passed the name of the module or package of the\n     application.  Once it is created it will act as a central registry for\n@@ -394,13 +369,14 @@ class Flask(_PackageBoundObject):\n         instance_relative_config=False,\n         root_path=None,\n     ):\n-        _PackageBoundObject.__init__(\n-            self, import_name, template_folder=template_folder, root_path=root_path\n+        super().__init__(\n+            import_name=import_name,\n+            static_folder=static_folder,\n+            static_url_path=static_url_path,\n+            template_folder=template_folder,\n+            root_path=root_path,\n         )\n \n-        self.static_url_path = static_url_path\n-        self.static_folder = static_folder\n-\n         if instance_path is None:\n             instance_path = self.auto_find_instance_path()\n         elif not os.path.isabs(instance_path):\n@@ -419,24 +395,6 @@ class Flask(_PackageBoundObject):\n         #: to load a config from files.\n         self.config = self.make_config(instance_relative_config)\n \n-        #: A dictionary of all view functions registered.  The keys will\n-        #: be function names which are also used to generate URLs and\n-        #: the values are the function objects themselves.\n-        #: To register a view function, use the :meth:`route` decorator.\n-        self.view_functions = {}\n-\n-        #: A dictionary of all registered error handlers.  The key is ``None``\n-        #: for error handlers active on the application, otherwise the key is\n-        #: the name of the blueprint.  Each key points to another dictionary\n-        #: where the key is the status code of the http exception.  The\n-        #: special key ``None`` points to a list of tuples where the first item\n-        #: is the class for the instance check and the second the error handler\n-        #: function.\n-        #:\n-        #: To register an error handler, use the :meth:`errorhandler`\n-        #: decorator.\n-        self.error_handler_spec = {}\n-\n         #: A list of functions that are called when :meth:`url_for` raises a\n         #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here\n         #: is called with `error`, `endpoint` and `values`.  If a function\n@@ -446,13 +404,6 @@ class Flask(_PackageBoundObject):\n         #: .. versionadded:: 0.9\n         self.url_build_error_handlers = []\n \n-        #: A dictionary with lists of functions that will be called at the\n-        #: beginning of each request. The key of the dictionary is the name of\n-        #: the blueprint this function is active for, or ``None`` for all\n-        #: requests. To register a function, use the :meth:`before_request`\n-        #: decorator.\n-        self.before_request_funcs = {}\n-\n         #: A list of functions that will be called at the beginning of the\n         #: first request to this instance. To register a function, use the\n         #: :meth:`before_first_request` decorator.\n@@ -460,25 +411,6 @@ class Flask(_PackageBoundObject):\n         #: .. versionadded:: 0.8\n         self.before_first_request_funcs = []\n \n-        #: A dictionary with lists of functions that should be called after\n-        #: each request.  The key of the dictionary is the name of the blueprint\n-        #: this function is active for, ``None`` for all requests.  This can for\n-        #: example be used to close database connections. To register a function\n-        #: here, use the :meth:`after_request` decorator.\n-        self.after_request_funcs = {}\n-\n-        #: A dictionary with lists of functions that are called after\n-        #: each request, even if an exception has occurred. The key of the\n-        #: dictionary is the name of the blueprint this function is active for,\n-        #: ``None`` for all requests. These functions are not allowed to modify\n-        #: the request, and their return values are ignored. If an exception\n-        #: occurred while processing the request, it gets passed to each\n-        #: teardown_request function. To register a function here, use the\n-        #: :meth:`teardown_request` decorator.\n-        #:\n-        #: .. versionadded:: 0.7\n-        self.teardown_request_funcs = {}\n-\n         #: A list of functions that are called when the application context\n         #: is destroyed.  Since the application context is also torn down\n         #: if the request ends this is the place to store code that disconnects\n@@ -487,35 +419,6 @@ class Flask(_PackageBoundObject):\n         #: .. versionadded:: 0.9\n         self.teardown_appcontext_funcs = []\n \n-        #: A dictionary with lists of functions that are called before the\n-        #: :attr:`before_request_funcs` functions. The key of the dictionary is\n-        #: the name of the blueprint this function is active for, or ``None``\n-        #: for all requests. To register a function, use\n-        #: :meth:`url_value_preprocessor`.\n-        #:\n-        #: .. versionadded:: 0.7\n-        self.url_value_preprocessors = {}\n-\n-        #: A dictionary with lists of functions that can be used as URL value\n-        #: preprocessors.  The key ``None`` here is used for application wide\n-        #: callbacks, otherwise the key is the name of the blueprint.\n-        #: Each of these functions has the chance to modify the dictionary\n-        #: of URL values before they are used as the keyword arguments of the\n-        #: view function.  For each function registered this one should also\n-        #: provide a :meth:`url_defaults` function that adds the parameters\n-        #: automatically again that were removed that way.\n-        #:\n-        #: .. versionadded:: 0.7\n-        self.url_default_functions = {}\n-\n-        #: A dictionary with list of functions that are called without argument\n-        #: to populate the template context.  The key of the dictionary is the\n-        #: name of the blueprint this function is active for, ``None`` for all\n-        #: requests.  Each returns a dictionary that the template context is\n-        #: updated with.  To register a function here, use the\n-        #: :meth:`context_processor` decorator.\n-        self.template_context_processors = {None: [_default_template_ctx_processor]}\n-\n         #: A list of shell context processor functions that should be run\n         #: when a shell context is created.\n         #:\n@@ -586,6 +489,9 @@ class Flask(_PackageBoundObject):\n         # the app's commands to another CLI tool.\n         self.cli.name = self.name\n \n+    def _is_setup_finished(self):\n+        return self.debug and self._got_first_request\n+\n     @locked_cached_property\n     def name(self):\n         \"\"\"The name of the application.  This is usually the import name\n@@ -1206,152 +1112,6 @@ class Flask(_PackageBoundObject):\n                 )\n             self.view_functions[endpoint] = view_func\n \n-    def route(self, rule, **options):\n-        \"\"\"A decorator that is used to register a view function for a\n-        given URL rule.  This does the same thing as :meth:`add_url_rule`\n-        but is intended for decorator usage::\n-\n-            @app.route('/')\n-            def index():\n-                return 'Hello World'\n-\n-        For more information refer to :ref:`url-route-registrations`.\n-\n-        :param rule: the URL rule as string\n-        :param endpoint: the endpoint for the registered URL rule.  Flask\n-                         itself assumes the name of the view function as\n-                         endpoint\n-        :param options: the options to be forwarded to the underlying\n-                        :class:`~werkzeug.routing.Rule` object.  A change\n-                        to Werkzeug is handling of method options.  methods\n-                        is a list of methods this rule should be limited\n-                        to (``GET``, ``POST`` etc.).  By default a rule\n-                        just listens for ``GET`` (and implicitly ``HEAD``).\n-                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n-                        added and handled by the standard request handling.\n-        \"\"\"\n-\n-        def decorator(f):\n-            endpoint = options.pop(\"endpoint\", None)\n-            self.add_url_rule(rule, endpoint, f, **options)\n-            return f\n-\n-        return decorator\n-\n-    @setupmethod\n-    def endpoint(self, endpoint):\n-        \"\"\"A decorator to register a function as an endpoint.\n-        Example::\n-\n-            @app.endpoint('example.endpoint')\n-            def example():\n-                return \"example\"\n-\n-        :param endpoint: the name of the endpoint\n-        \"\"\"\n-\n-        def decorator(f):\n-            self.view_functions[endpoint] = f\n-            return f\n-\n-        return decorator\n-\n-    @staticmethod\n-    def _get_exc_class_and_code(exc_class_or_code):\n-        \"\"\"Get the exception class being handled. For HTTP status codes\n-        or ``HTTPException`` subclasses, return both the exception and\n-        status code.\n-\n-        :param exc_class_or_code: Any exception class, or an HTTP status\n-            code as an integer.\n-        \"\"\"\n-        if isinstance(exc_class_or_code, int):\n-            exc_class = default_exceptions[exc_class_or_code]\n-        else:\n-            exc_class = exc_class_or_code\n-\n-        assert issubclass(\n-            exc_class, Exception\n-        ), \"Custom exceptions must be subclasses of Exception.\"\n-\n-        if issubclass(exc_class, HTTPException):\n-            return exc_class, exc_class.code\n-        else:\n-            return exc_class, None\n-\n-    @setupmethod\n-    def errorhandler(self, code_or_exception):\n-        \"\"\"Register a function to handle errors by code or exception class.\n-\n-        A decorator that is used to register a function given an\n-        error code.  Example::\n-\n-            @app.errorhandler(404)\n-            def page_not_found(error):\n-                return 'This page does not exist', 404\n-\n-        You can also register handlers for arbitrary exceptions::\n-\n-            @app.errorhandler(DatabaseError)\n-            def special_exception_handler(error):\n-                return 'Database connection failed', 500\n-\n-        .. versionadded:: 0.7\n-            Use :meth:`register_error_handler` instead of modifying\n-            :attr:`error_handler_spec` directly, for application wide error\n-            handlers.\n-\n-        .. versionadded:: 0.7\n-           One can now additionally also register custom exception types\n-           that do not necessarily have to be a subclass of the\n-           :class:`~werkzeug.exceptions.HTTPException` class.\n-\n-        :param code_or_exception: the code as integer for the handler, or\n-                                  an arbitrary exception\n-        \"\"\"\n-\n-        def decorator(f):\n-            self._register_error_handler(None, code_or_exception, f)\n-            return f\n-\n-        return decorator\n-\n-    @setupmethod\n-    def register_error_handler(self, code_or_exception, f):\n-        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n-        decorator that is more straightforward to use for non decorator\n-        usage.\n-\n-        .. versionadded:: 0.7\n-        \"\"\"\n-        self._register_error_handler(None, code_or_exception, f)\n-\n-    @setupmethod\n-    def _register_error_handler(self, key, code_or_exception, f):\n-        \"\"\"\n-        :type key: None|str\n-        :type code_or_exception: int|T<=Exception\n-        :type f: callable\n-        \"\"\"\n-        if isinstance(code_or_exception, HTTPException):  # old broken behavior\n-            raise ValueError(\n-                \"Tried to register a handler for an exception instance\"\n-                f\" {code_or_exception!r}. Handlers can only be\"\n-                \" registered for exception classes or HTTP error codes.\"\n-            )\n-\n-        try:\n-            exc_class, code = self._get_exc_class_and_code(code_or_exception)\n-        except KeyError:\n-            raise KeyError(\n-                f\"'{code_or_exception}' is not a recognized HTTP error\"\n-                \" code. Use a subclass of HTTPException with that code\"\n-                \" instead.\"\n-            )\n-\n-        handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})\n-        handlers[exc_class] = f\n-\n     @setupmethod\n     def template_filter(self, name=None):\n         \"\"\"A decorator that is used to register custom template filter.\n@@ -1455,20 +1215,6 @@ class Flask(_PackageBoundObject):\n         \"\"\"\n         self.jinja_env.globals[name or f.__name__] = f\n \n-    @setupmethod\n-    def before_request(self, f):\n-        \"\"\"Registers a function to run before each request.\n-\n-        For example, this can be used to open a database connection, or to load\n-        the logged in user from the session.\n-\n-        The function will be called without any arguments. If it returns a\n-        non-None value, the value is handled as if it was the return value from\n-        the view, and further request handling is stopped.\n-        \"\"\"\n-        self.before_request_funcs.setdefault(None, []).append(f)\n-        return f\n-\n     @setupmethod\n     def before_first_request(self, f):\n         \"\"\"Registers a function to be run before the first request to this\n@@ -1482,59 +1228,6 @@ class Flask(_PackageBoundObject):\n         self.before_first_request_funcs.append(f)\n         return f\n \n-    @setupmethod\n-    def after_request(self, f):\n-        \"\"\"Register a function to be run after each request.\n-\n-        Your function must take one parameter, an instance of\n-        :attr:`response_class` and return a new response object or the\n-        same (see :meth:`process_response`).\n-\n-        As of Flask 0.7 this function might not be executed at the end of the\n-        request in case an unhandled exception occurred.\n-        \"\"\"\n-        self.after_request_funcs.setdefault(None, []).append(f)\n-        return f\n-\n-    @setupmethod\n-    def teardown_request(self, f):\n-        \"\"\"Register a function to be run at the end of each request,\n-        regardless of whether there was an exception or not.  These functions\n-        are executed when the request context is popped, even if not an\n-        actual request was performed.\n-\n-        Example::\n-\n-            ctx = app.test_request_context()\n-            ctx.push()\n-            ...\n-            ctx.pop()\n-\n-        When ``ctx.pop()`` is executed in the above example, the teardown\n-        functions are called just before the request context moves from the\n-        stack of active contexts.  This becomes relevant if you are using\n-        such constructs in tests.\n-\n-        Generally teardown functions must take every necessary step to avoid\n-        that they will fail.  If they do execute code that might fail they\n-        will have to surround the execution of these code by try/except\n-        statements and log occurring errors.\n-\n-        When a teardown function was called because of an exception it will\n-        be passed an error object.\n-\n-        The return values of teardown functions are ignored.\n-\n-        .. admonition:: Debug Note\n-\n-           In debug mode Flask will not tear down a request on an exception\n-           immediately.  Instead it will keep it alive so that the interactive\n-           debugger can still access it.  This behavior can be controlled\n-           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n-        \"\"\"\n-        self.teardown_request_funcs.setdefault(None, []).append(f)\n-        return f\n-\n     @setupmethod\n     def teardown_appcontext(self, f):\n         \"\"\"Registers a function to be called when the application context\n@@ -1568,12 +1261,6 @@ class Flask(_PackageBoundObject):\n         self.teardown_appcontext_funcs.append(f)\n         return f\n \n-    @setupmethod\n-    def context_processor(self, f):\n-        \"\"\"Registers a template context processor function.\"\"\"\n-        self.template_context_processors[None].append(f)\n-        return f\n-\n     @setupmethod\n     def shell_context_processor(self, f):\n         \"\"\"Registers a shell context processor function.\n@@ -1583,32 +1270,6 @@ class Flask(_PackageBoundObject):\n         self.shell_context_processors.append(f)\n         return f\n \n-    @setupmethod\n-    def url_value_preprocessor(self, f):\n-        \"\"\"Register a URL value preprocessor function for all view\n-        functions in the application. These functions will be called before the\n-        :meth:`before_request` functions.\n-\n-        The function can modify the values captured from the matched url before\n-        they are passed to the view. For example, this can be used to pop a\n-        common language code value and place it in ``g`` rather than pass it to\n-        every view.\n-\n-        The function is passed the endpoint name and values dict. The return\n-        value is ignored.\n-        \"\"\"\n-        self.url_value_preprocessors.setdefault(None, []).append(f)\n-        return f\n-\n-    @setupmethod\n-    def url_defaults(self, f):\n-        \"\"\"Callback function for URL defaults for all view functions of the\n-        application.  It's called with the endpoint and values and should\n-        update the values passed in place.\n-        \"\"\"\n-        self.url_default_functions.setdefault(None, []).append(f)\n-        return f\n-\n     def _find_error_handler(self, e):\n         \"\"\"Return a registered error handler for an exception in this order:\n         blueprint handler for a specific code, app handler for a specific code,\n\n@@ -1,10 +1,8 @@\n from functools import update_wrapper\n \n-from .helpers import _endpoint_from_view_func\n-from .helpers import _PackageBoundObject\n-\n-# a singleton sentinel value for parameter defaults\n-_sentinel = object()\n+from .scaffold import _endpoint_from_view_func\n+from .scaffold import _sentinel\n+from .scaffold import Scaffold\n \n \n class BlueprintSetupState:\n@@ -76,7 +74,7 @@ class BlueprintSetupState:\n         )\n \n \n-class Blueprint(_PackageBoundObject):\n+class Blueprint(Scaffold):\n     \"\"\"Represents a blueprint, a collection of routes and other\n     app-related functions that can be registered on a real application\n     later.\n@@ -167,20 +165,25 @@ class Blueprint(_PackageBoundObject):\n         root_path=None,\n         cli_group=_sentinel,\n     ):\n-        _PackageBoundObject.__init__(\n-            self, import_name, template_folder, root_path=root_path\n+        super().__init__(\n+            import_name=import_name,\n+            static_folder=static_folder,\n+            static_url_path=static_url_path,\n+            template_folder=template_folder,\n+            root_path=root_path,\n         )\n         self.name = name\n         self.url_prefix = url_prefix\n         self.subdomain = subdomain\n-        self.static_folder = static_folder\n-        self.static_url_path = static_url_path\n         self.deferred_functions = []\n         if url_defaults is None:\n             url_defaults = {}\n         self.url_values_defaults = url_defaults\n         self.cli_group = cli_group\n \n+    def _is_setup_finished(self):\n+        return self.warn_on_modifications and self._got_registered_once\n+\n     def record(self, func):\n         \"\"\"Registers a function that is called when the blueprint is\n         registered on the application.  This function is called with the\n@@ -241,6 +244,36 @@ class Blueprint(_PackageBoundObject):\n                 endpoint=\"static\",\n             )\n \n+        # Merge app and self dictionaries.\n+        def merge_dict_lists(self_dict, app_dict):\n+            \"\"\"Merges self_dict into app_dict. Replaces None keys with self.name.\n+            Values of dict must be lists.\n+            \"\"\"\n+            for key, values in self_dict.items():\n+                key = self.name if key is None else f\"{self.name}.{key}\"\n+                app_dict.setdefault(key, []).extend(values)\n+\n+        def merge_dict_nested(self_dict, app_dict):\n+            \"\"\"Merges self_dict into app_dict. Replaces None keys with self.name.\n+            Values of dict must be dict.\n+            \"\"\"\n+            for key, value in self_dict.items():\n+                key = self.name if key is None else f\"{self.name}.{key}\"\n+                app_dict[key] = value\n+\n+        app.view_functions.update(self.view_functions)\n+\n+        merge_dict_lists(self.before_request_funcs, app.before_request_funcs)\n+        merge_dict_lists(self.after_request_funcs, app.after_request_funcs)\n+        merge_dict_lists(self.teardown_request_funcs, app.teardown_request_funcs)\n+        merge_dict_lists(self.url_default_functions, app.url_default_functions)\n+        merge_dict_lists(self.url_value_preprocessors, app.url_value_preprocessors)\n+        merge_dict_lists(\n+            self.template_context_processors, app.template_context_processors\n+        )\n+\n+        merge_dict_nested(self.error_handler_spec, app.error_handler_spec)\n+\n         for deferred in self.deferred_functions:\n             deferred(state)\n \n@@ -258,18 +291,6 @@ class Blueprint(_PackageBoundObject):\n             self.cli.name = cli_resolved_group\n             app.cli.add_command(self.cli)\n \n-    def route(self, rule, **options):\n-        \"\"\"Like :meth:`Flask.route` but for a blueprint.  The endpoint for the\n-        :func:`url_for` function is prefixed with the name of the blueprint.\n-        \"\"\"\n-\n-        def decorator(f):\n-            endpoint = options.pop(\"endpoint\", f.__name__)\n-            self.add_url_rule(rule, endpoint, f, **options)\n-            return f\n-\n-        return decorator\n-\n     def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n         \"\"\"Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for\n         the :func:`url_for` function is prefixed with the name of the blueprint.\n@@ -282,23 +303,6 @@ class Blueprint(_PackageBoundObject):\n             ), \"Blueprint view function name should not contain dots\"\n         self.record(lambda s: s.add_url_rule(rule, endpoint, view_func, **options))\n \n-    def endpoint(self, endpoint):\n-        \"\"\"Like :meth:`Flask.endpoint` but for a blueprint.  This does not\n-        prefix the endpoint with the blueprint name, this has to be done\n-        explicitly by the user of this method.  If the endpoint is prefixed\n-        with a `.` it will be registered to the current blueprint, otherwise\n-        it's an application independent endpoint.\n-        \"\"\"\n-\n-        def decorator(f):\n-            def register_endpoint(state):\n-                state.app.view_functions[endpoint] = f\n-\n-            self.record_once(register_endpoint)\n-            return f\n-\n-        return decorator\n-\n     def app_template_filter(self, name=None):\n         \"\"\"Register a custom template filter, available application wide.  Like\n         :meth:`Flask.template_filter` but for a blueprint.\n@@ -391,16 +395,6 @@ class Blueprint(_PackageBoundObject):\n \n         self.record_once(register_template)\n \n-    def before_request(self, f):\n-        \"\"\"Like :meth:`Flask.before_request` but for a blueprint.  This function\n-        is only executed before each request that is handled by a function of\n-        that blueprint.\n-        \"\"\"\n-        self.record_once(\n-            lambda s: s.app.before_request_funcs.setdefault(self.name, []).append(f)\n-        )\n-        return f\n-\n     def before_app_request(self, f):\n         \"\"\"Like :meth:`Flask.before_request`.  Such a function is executed\n         before each request, even if outside of a blueprint.\n@@ -417,16 +411,6 @@ class Blueprint(_PackageBoundObject):\n         self.record_once(lambda s: s.app.before_first_request_funcs.append(f))\n         return f\n \n-    def after_request(self, f):\n-        \"\"\"Like :meth:`Flask.after_request` but for a blueprint.  This function\n-        is only executed after each request that is handled by a function of\n-        that blueprint.\n-        \"\"\"\n-        self.record_once(\n-            lambda s: s.app.after_request_funcs.setdefault(self.name, []).append(f)\n-        )\n-        return f\n-\n     def after_app_request(self, f):\n         \"\"\"Like :meth:`Flask.after_request` but for a blueprint.  Such a function\n         is executed after each request, even if outside of the blueprint.\n@@ -436,18 +420,6 @@ class Blueprint(_PackageBoundObject):\n         )\n         return f\n \n-    def teardown_request(self, f):\n-        \"\"\"Like :meth:`Flask.teardown_request` but for a blueprint.  This\n-        function is only executed when tearing down requests handled by a\n-        function of that blueprint.  Teardown request functions are executed\n-        when the request context is popped, even when no actual request was\n-        performed.\n-        \"\"\"\n-        self.record_once(\n-            lambda s: s.app.teardown_request_funcs.setdefault(self.name, []).append(f)\n-        )\n-        return f\n-\n     def teardown_app_request(self, f):\n         \"\"\"Like :meth:`Flask.teardown_request` but for a blueprint.  Such a\n         function is executed when tearing down each request, even if outside of\n@@ -458,17 +430,6 @@ class Blueprint(_PackageBoundObject):\n         )\n         return f\n \n-    def context_processor(self, f):\n-        \"\"\"Like :meth:`Flask.context_processor` but for a blueprint.  This\n-        function is only executed for requests handled by a blueprint.\n-        \"\"\"\n-        self.record_once(\n-            lambda s: s.app.template_context_processors.setdefault(\n-                self.name, []\n-            ).append(f)\n-        )\n-        return f\n-\n     def app_context_processor(self, f):\n         \"\"\"Like :meth:`Flask.context_processor` but for a blueprint.  Such a\n         function is executed each request, even if outside of the blueprint.\n@@ -489,26 +450,6 @@ class Blueprint(_PackageBoundObject):\n \n         return decorator\n \n-    def url_value_preprocessor(self, f):\n-        \"\"\"Registers a function as URL value preprocessor for this\n-        blueprint.  It's called before the view functions are called and\n-        can modify the url values provided.\n-        \"\"\"\n-        self.record_once(\n-            lambda s: s.app.url_value_preprocessors.setdefault(self.name, []).append(f)\n-        )\n-        return f\n-\n-    def url_defaults(self, f):\n-        \"\"\"Callback function for URL defaults for this blueprint.  It's called\n-        with the endpoint and values and should update the values passed\n-        in place.\n-        \"\"\"\n-        self.record_once(\n-            lambda s: s.app.url_default_functions.setdefault(self.name, []).append(f)\n-        )\n-        return f\n-\n     def app_url_value_preprocessor(self, f):\n         \"\"\"Same as :meth:`url_value_preprocessor` but application wide.\n         \"\"\"\n@@ -524,35 +465,3 @@ class Blueprint(_PackageBoundObject):\n             lambda s: s.app.url_default_functions.setdefault(None, []).append(f)\n         )\n         return f\n-\n-    def errorhandler(self, code_or_exception):\n-        \"\"\"Registers an error handler that becomes active for this blueprint\n-        only.  Please be aware that routing does not happen local to a\n-        blueprint so an error handler for 404 usually is not handled by\n-        a blueprint unless it is caused inside a view function.  Another\n-        special case is the 500 internal server error which is always looked\n-        up from the application.\n-\n-        Otherwise works as the :meth:`~flask.Flask.errorhandler` decorator\n-        of the :class:`~flask.Flask` object.\n-        \"\"\"\n-\n-        def decorator(f):\n-            self.record_once(\n-                lambda s: s.app._register_error_handler(self.name, code_or_exception, f)\n-            )\n-            return f\n-\n-        return decorator\n-\n-    def register_error_handler(self, code_or_exception, f):\n-        \"\"\"Non-decorator version of the :meth:`errorhandler` error attach\n-        function, akin to the :meth:`~flask.Flask.register_error_handler`\n-        application-wide function of the :class:`~flask.Flask` object but\n-        for error handlers limited to this blueprint.\n-\n-        .. versionadded:: 0.11\n-        \"\"\"\n-        self.record_once(\n-            lambda s: s.app._register_error_handler(self.name, code_or_exception, f)\n-        )\n\n@@ -76,14 +76,6 @@ def get_load_dotenv(default=True):\n     return val.lower() in (\"0\", \"false\", \"no\")\n \n \n-def _endpoint_from_view_func(view_func):\n-    \"\"\"Internal helper that returns the default endpoint for a given\n-    function.  This always is the function name.\n-    \"\"\"\n-    assert view_func is not None, \"expected view func if endpoint is not provided.\"\n-    return view_func.__name__\n-\n-\n def stream_with_context(generator_or_function):\n     \"\"\"Request contexts disappear when the response is started on the server.\n     This is done for efficiency reasons and to make it less likely to encounter\n\n@@ -0,0 +1,411 @@\n+from functools import update_wrapper\n+\n+from werkzeug.exceptions import default_exceptions\n+from werkzeug.exceptions import HTTPException\n+\n+from .helpers import _PackageBoundObject\n+from .templating import _default_template_ctx_processor\n+\n+# a singleton sentinel value for parameter defaults\n+_sentinel = object()\n+\n+\n+def setupmethod(f):\n+    \"\"\"Wraps a method so that it performs a check in debug mode if the\n+    first request was already handled.\n+    \"\"\"\n+\n+    def wrapper_func(self, *args, **kwargs):\n+        if self._is_setup_finished():\n+            raise AssertionError(\n+                \"A setup function was called after the \"\n+                \"first request was handled.  This usually indicates a bug \"\n+                \"in the application where a module was not imported \"\n+                \"and decorators or other functionality was called too late.\\n\"\n+                \"To fix this make sure to import all your view modules, \"\n+                \"database models and everything related at a central place \"\n+                \"before the application starts serving requests.\"\n+            )\n+        return f(self, *args, **kwargs)\n+\n+    return update_wrapper(wrapper_func, f)\n+\n+\n+class Scaffold(_PackageBoundObject):\n+    \"\"\"A common base for class Flask and class Blueprint.\n+    \"\"\"\n+\n+    #: Skeleton local JSON decoder class to use.\n+    #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_encoder`.\n+    json_encoder = None\n+\n+    #: Skeleton local JSON decoder class to use.\n+    #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_decoder`.\n+    json_decoder = None\n+\n+    #: The name of the package or module that this app belongs to. Do not\n+    #: change this once it is set by the constructor.\n+    import_name = None\n+\n+    #: Location of the template files to be added to the template lookup.\n+    #: ``None`` if templates should not be added.\n+    template_folder = None\n+\n+    #: Absolute path to the package on the filesystem. Used to look up\n+    #: resources contained in the package.\n+    root_path = None\n+\n+    def __init__(\n+        self,\n+        import_name,\n+        static_folder=\"static\",\n+        static_url_path=None,\n+        template_folder=None,\n+        root_path=None,\n+    ):\n+        super().__init__(\n+            import_name=import_name,\n+            template_folder=template_folder,\n+            root_path=root_path,\n+        )\n+        self.static_folder = static_folder\n+        self.static_url_path = static_url_path\n+\n+        #: A dictionary of all view functions registered.  The keys will\n+        #: be function names which are also used to generate URLs and\n+        #: the values are the function objects themselves.\n+        #: To register a view function, use the :meth:`route` decorator.\n+        self.view_functions = {}\n+\n+        #: A dictionary of all registered error handlers.  The key is ``None``\n+        #: for error handlers active on the application, otherwise the key is\n+        #: the name of the blueprint.  Each key points to another dictionary\n+        #: where the key is the status code of the http exception.  The\n+        #: special key ``None`` points to a list of tuples where the first item\n+        #: is the class for the instance check and the second the error handler\n+        #: function.\n+        #:\n+        #: To register an error handler, use the :meth:`errorhandler`\n+        #: decorator.\n+        self.error_handler_spec = {}\n+\n+        #: A dictionary with lists of functions that will be called at the\n+        #: beginning of each request. The key of the dictionary is the name of\n+        #: the blueprint this function is active for, or ``None`` for all\n+        #: requests. To register a function, use the :meth:`before_request`\n+        #: decorator.\n+        self.before_request_funcs = {}\n+\n+        #: A dictionary with lists of functions that should be called after\n+        #: each request.  The key of the dictionary is the name of the blueprint\n+        #: this function is active for, ``None`` for all requests.  This can for\n+        #: example be used to close database connections. To register a function\n+        #: here, use the :meth:`after_request` decorator.\n+        self.after_request_funcs = {}\n+\n+        #: A dictionary with lists of functions that are called after\n+        #: each request, even if an exception has occurred. The key of the\n+        #: dictionary is the name of the blueprint this function is active for,\n+        #: ``None`` for all requests. These functions are not allowed to modify\n+        #: the request, and their return values are ignored. If an exception\n+        #: occurred while processing the request, it gets passed to each\n+        #: teardown_request function. To register a function here, use the\n+        #: :meth:`teardown_request` decorator.\n+        #:\n+        #: .. versionadded:: 0.7\n+        self.teardown_request_funcs = {}\n+\n+        #: A dictionary with list of functions that are called without argument\n+        #: to populate the template context.  The key of the dictionary is the\n+        #: name of the blueprint this function is active for, ``None`` for all\n+        #: requests.  Each returns a dictionary that the template context is\n+        #: updated with.  To register a function here, use the\n+        #: :meth:`context_processor` decorator.\n+        self.template_context_processors = {None: [_default_template_ctx_processor]}\n+\n+        #: A dictionary with lists of functions that are called before the\n+        #: :attr:`before_request_funcs` functions. The key of the dictionary is\n+        #: the name of the blueprint this function is active for, or ``None``\n+        #: for all requests. To register a function, use\n+        #: :meth:`url_value_preprocessor`.\n+        #:\n+        #: .. versionadded:: 0.7\n+        self.url_value_preprocessors = {}\n+\n+        #: A dictionary with lists of functions that can be used as URL value\n+        #: preprocessors.  The key ``None`` here is used for application wide\n+        #: callbacks, otherwise the key is the name of the blueprint.\n+        #: Each of these functions has the chance to modify the dictionary\n+        #: of URL values before they are used as the keyword arguments of the\n+        #: view function.  For each function registered this one should also\n+        #: provide a :meth:`url_defaults` function that adds the parameters\n+        #: automatically again that were removed that way.\n+        #:\n+        #: .. versionadded:: 0.7\n+        self.url_default_functions = {}\n+\n+    def _is_setup_finished(self):\n+        raise NotImplementedError\n+\n+    def route(self, rule, **options):\n+        \"\"\"A decorator that is used to register a view function for a\n+        given URL rule.  This does the same thing as :meth:`add_url_rule`\n+        but is intended for decorator usage::\n+\n+            @app.route('/')\n+            def index():\n+                return 'Hello World'\n+\n+        For more information refer to :ref:`url-route-registrations`.\n+\n+        :param rule: the URL rule as string\n+        :param endpoint: the endpoint for the registered URL rule.  Flask\n+                         itself assumes the name of the view function as\n+                         endpoint\n+        :param options: the options to be forwarded to the underlying\n+                        :class:`~werkzeug.routing.Rule` object.  A change\n+                        to Werkzeug is handling of method options.  methods\n+                        is a list of methods this rule should be limited\n+                        to (``GET``, ``POST`` etc.).  By default a rule\n+                        just listens for ``GET`` (and implicitly ``HEAD``).\n+                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n+                        added and handled by the standard request handling.\n+        \"\"\"\n+\n+        def decorator(f):\n+            endpoint = options.pop(\"endpoint\", None)\n+            self.add_url_rule(rule, endpoint, f, **options)\n+            return f\n+\n+        return decorator\n+\n+    @setupmethod\n+    def add_url_rule(\n+        self,\n+        rule,\n+        endpoint=None,\n+        view_func=None,\n+        provide_automatic_options=None,\n+        **options,\n+    ):\n+        raise NotImplementedError\n+\n+    def endpoint(self, endpoint):\n+        \"\"\"A decorator to register a function as an endpoint.\n+        Example::\n+\n+            @app.endpoint('example.endpoint')\n+            def example():\n+                return \"example\"\n+\n+        :param endpoint: the name of the endpoint\n+        \"\"\"\n+\n+        def decorator(f):\n+            self.view_functions[endpoint] = f\n+            return f\n+\n+        return decorator\n+\n+    @setupmethod\n+    def before_request(self, f):\n+        \"\"\"Registers a function to run before each request.\n+\n+        For example, this can be used to open a database connection, or to load\n+        the logged in user from the session.\n+\n+        The function will be called without any arguments. If it returns a\n+        non-None value, the value is handled as if it was the return value from\n+        the view, and further request handling is stopped.\n+        \"\"\"\n+        self.before_request_funcs.setdefault(None, []).append(f)\n+        return f\n+\n+    @setupmethod\n+    def after_request(self, f):\n+        \"\"\"Register a function to be run after each request.\n+\n+        Your function must take one parameter, an instance of\n+        :attr:`response_class` and return a new response object or the\n+        same (see :meth:`process_response`).\n+\n+        As of Flask 0.7 this function might not be executed at the end of the\n+        request in case an unhandled exception occurred.\n+        \"\"\"\n+        self.after_request_funcs.setdefault(None, []).append(f)\n+        return f\n+\n+    @setupmethod\n+    def teardown_request(self, f):\n+        \"\"\"Register a function to be run at the end of each request,\n+        regardless of whether there was an exception or not.  These functions\n+        are executed when the request context is popped, even if not an\n+        actual request was performed.\n+\n+        Example::\n+\n+            ctx = app.test_request_context()\n+            ctx.push()\n+            ...\n+            ctx.pop()\n+\n+        When ``ctx.pop()`` is executed in the above example, the teardown\n+        functions are called just before the request context moves from the\n+        stack of active contexts.  This becomes relevant if you are using\n+        such constructs in tests.\n+\n+        Generally teardown functions must take every necessary step to avoid\n+        that they will fail.  If they do execute code that might fail they\n+        will have to surround the execution of these code by try/except\n+        statements and log occurring errors.\n+\n+        When a teardown function was called because of an exception it will\n+        be passed an error object.\n+\n+        The return values of teardown functions are ignored.\n+\n+        .. admonition:: Debug Note\n+\n+           In debug mode Flask will not tear down a request on an exception\n+           immediately.  Instead it will keep it alive so that the interactive\n+           debugger can still access it.  This behavior can be controlled\n+           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n+        \"\"\"\n+        self.teardown_request_funcs.setdefault(None, []).append(f)\n+        return f\n+\n+    @setupmethod\n+    def context_processor(self, f):\n+        \"\"\"Registers a template context processor function.\"\"\"\n+        self.template_context_processors[None].append(f)\n+        return f\n+\n+    @setupmethod\n+    def url_value_preprocessor(self, f):\n+        \"\"\"Register a URL value preprocessor function for all view\n+        functions in the application. These functions will be called before the\n+        :meth:`before_request` functions.\n+\n+        The function can modify the values captured from the matched url before\n+        they are passed to the view. For example, this can be used to pop a\n+        common language code value and place it in ``g`` rather than pass it to\n+        every view.\n+\n+        The function is passed the endpoint name and values dict. The return\n+        value is ignored.\n+        \"\"\"\n+        self.url_value_preprocessors.setdefault(None, []).append(f)\n+        return f\n+\n+    @setupmethod\n+    def url_defaults(self, f):\n+        \"\"\"Callback function for URL defaults for all view functions of the\n+        application.  It's called with the endpoint and values and should\n+        update the values passed in place.\n+        \"\"\"\n+        self.url_default_functions.setdefault(None, []).append(f)\n+        return f\n+\n+    @setupmethod\n+    def errorhandler(self, code_or_exception):\n+        \"\"\"Register a function to handle errors by code or exception class.\n+\n+        A decorator that is used to register a function given an\n+        error code.  Example::\n+\n+            @app.errorhandler(404)\n+            def page_not_found(error):\n+                return 'This page does not exist', 404\n+\n+        You can also register handlers for arbitrary exceptions::\n+\n+            @app.errorhandler(DatabaseError)\n+            def special_exception_handler(error):\n+                return 'Database connection failed', 500\n+\n+        .. versionadded:: 0.7\n+            Use :meth:`register_error_handler` instead of modifying\n+            :attr:`error_handler_spec` directly, for application wide error\n+            handlers.\n+\n+        .. versionadded:: 0.7\n+           One can now additionally also register custom exception types\n+           that do not necessarily have to be a subclass of the\n+           :class:`~werkzeug.exceptions.HTTPException` class.\n+\n+        :param code_or_exception: the code as integer for the handler, or\n+                                  an arbitrary exception\n+        \"\"\"\n+\n+        def decorator(f):\n+            self._register_error_handler(None, code_or_exception, f)\n+            return f\n+\n+        return decorator\n+\n+    @setupmethod\n+    def register_error_handler(self, code_or_exception, f):\n+        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n+        decorator that is more straightforward to use for non decorator\n+        usage.\n+\n+        .. versionadded:: 0.7\n+        \"\"\"\n+        self._register_error_handler(None, code_or_exception, f)\n+\n+    @setupmethod\n+    def _register_error_handler(self, key, code_or_exception, f):\n+        \"\"\"\n+        :type key: None|str\n+        :type code_or_exception: int|T<=Exception\n+        :type f: callable\n+        \"\"\"\n+        if isinstance(code_or_exception, HTTPException):  # old broken behavior\n+            raise ValueError(\n+                \"Tried to register a handler for an exception instance\"\n+                f\" {code_or_exception!r}. Handlers can only be\"\n+                \" registered for exception classes or HTTP error codes.\"\n+            )\n+\n+        try:\n+            exc_class, code = self._get_exc_class_and_code(code_or_exception)\n+        except KeyError:\n+            raise KeyError(\n+                f\"'{code_or_exception}' is not a recognized HTTP error\"\n+                \" code. Use a subclass of HTTPException with that code\"\n+                \" instead.\"\n+            )\n+\n+        handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})\n+        handlers[exc_class] = f\n+\n+    @staticmethod\n+    def _get_exc_class_and_code(exc_class_or_code):\n+        \"\"\"Get the exception class being handled. For HTTP status codes\n+        or ``HTTPException`` subclasses, return both the exception and\n+        status code.\n+\n+        :param exc_class_or_code: Any exception class, or an HTTP status\n+            code as an integer.\n+        \"\"\"\n+        if isinstance(exc_class_or_code, int):\n+            exc_class = default_exceptions[exc_class_or_code]\n+        else:\n+            exc_class = exc_class_or_code\n+\n+        assert issubclass(\n+            exc_class, Exception\n+        ), \"Custom exceptions must be subclasses of Exception.\"\n+\n+        if issubclass(exc_class, HTTPException):\n+            return exc_class, exc_class.code\n+        else:\n+            return exc_class, None\n+\n+\n+def _endpoint_from_view_func(view_func):\n+    \"\"\"Internal helper that returns the default endpoint for a given\n+    function.  This always is the function name.\n+    \"\"\"\n+    assert view_func is not None, \"expected view func if endpoint is not provided.\"\n+    return view_func.__name__\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
