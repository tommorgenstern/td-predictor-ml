{"custom_id": "keras#1412598cfb6264181eb2cd588e5491f6e0d6d6b2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 3 | Methods Changed: 4 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 17 | Churn Cumulative: 235 | Contributors (this commit): 5 | Commits (past 90d): 4 | Contributors (cumulative): 8 | DMM Complexity: 1.0\n\nDIFF:\n@@ -519,7 +519,7 @@ def load_weights_from_hdf5_group_by_name(f, model, skip_mismatch=False):\n             )\n \n     if \"top_level_model_weights\" in f:\n-        symbolic_weights = model.trainable_weights + model.non_trainable_weights\n+        symbolic_weights = model._trainable_variables + model._non_trainable_variables\n         weight_values = load_subset_weights_from_hdf5_group(\n             f[\"top_level_model_weights\"]\n         )\n\n@@ -51,8 +51,21 @@ def get_subclassed_model(keras):\n             self.dense_1 = keras.layers.Dense(3, activation=\"relu\")\n             self.dense_2 = keras.layers.Dense(1, activation=\"sigmoid\")\n \n+            # top_level_model_weights\n+            self.bias = self.add_weight(\n+                name=\"bias\",\n+                shape=[1],\n+                trainable=True,\n+                initializer=keras.initializers.Zeros(),\n+            )\n+\n         def call(self, x):\n-            return self.dense_2(self.dense_1(x))\n+            x = self.dense_1(x)\n+            x = self.dense_2(x)\n+\n+            # top_level_model_weights\n+            x += ops.cast(self.bias, x.dtype)\n+\n \n     model = MyModel()\n     model(np.random.random((2, 3)))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#903f7f451c1fe313f8a2b7d5758594b0e4f0b372", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 4 | Files Changed: 3 | Hunks: 3 | Methods Changed: 5 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 9 | Churn Cumulative: 1330 | Contributors (this commit): 15 | Commits (past 90d): 20 | Contributors (cumulative): 21 | DMM Complexity: 0.3333333333333333\n\nDIFF:\n@@ -519,7 +519,9 @@ def load_weights_from_hdf5_group_by_name(f, model, skip_mismatch=False):\n             )\n \n     if \"top_level_model_weights\" in f:\n-        symbolic_weights = model._trainable_variables + model._non_trainable_variables\n+        symbolic_weights = (\n+            model._trainable_variables + model._non_trainable_variables\n+        )\n         weight_values = load_subset_weights_from_hdf5_group(\n             f[\"top_level_model_weights\"]\n         )\n\n@@ -65,7 +65,7 @@ def get_subclassed_model(keras):\n \n             # top_level_model_weights\n             x += ops.cast(self.bias, x.dtype)\n-\n+            return x\n \n     model = MyModel()\n     model(np.random.random((2, 3)))\n\n@@ -3832,8 +3832,7 @@ class NumpyOneInputOpsCorrectnessTest(testing.TestCase):\n         self.assertAllClose(knp.isfinite(x), np.isfinite(x))\n         self.assertAllClose(knp.Isfinite()(x), np.isfinite(x))\n \n-    # TODO: fix and re-enable\n-    def DISABLED_test_isinf(self):\n+    def test_isinf(self):\n         x = np.array([[1, 2, np.inf], [np.nan, np.nan, np.nan]])\n         self.assertAllClose(knp.isinf(x), np.isinf(x))\n         self.assertAllClose(knp.Isinf()(x), np.isinf(x))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "keras#78f1c71dbf33599174602f2c63190c17c587909b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2750 | Lines Deleted: 708 | Files Changed: 14 | Hunks: 144 | Methods Changed: 127 | Complexity Δ (Sum/Max): 59/52 | Churn Δ: 3458 | Churn Cumulative: 7061 | Contributors (this commit): 16 | Commits (past 90d): 69 | Contributors (cumulative): 72 | DMM Complexity: 0.9963768115942029\n\nDIFF:\n@@ -4,6 +4,7 @@ This file was autogenerated. Do not edit it by hand,\n since your modifications would be overwritten.\n \"\"\"\n \n+from keras.src.tree.tree_api import MAP_TO_NONE\n from keras.src.tree.tree_api import assert_same_paths\n from keras.src.tree.tree_api import assert_same_structure\n from keras.src.tree.tree_api import flatten\n\n@@ -4,6 +4,7 @@ This file was autogenerated. Do not edit it by hand,\n since your modifications would be overwritten.\n \"\"\"\n \n+from keras.src.tree.tree_api import MAP_TO_NONE\n from keras.src.tree.tree_api import assert_same_paths\n from keras.src.tree.tree_api import assert_same_structure\n from keras.src.tree.tree_api import flatten\n\n@@ -374,7 +374,7 @@ def _clone_functional_model(\n             )\n         try:\n             tree.assert_same_structure(input_tensors, model.input)\n-        except (ValueError, TypeError) as e:\n+        except ValueError as e:\n             raise ValueError(\n                 \"`input_tensors` must have the same structure as model.input\"\n                 f\"\\nReference structure: {model.input}\"\n\n@@ -219,7 +219,6 @@ class Functional(Function, Model):\n             tree.assert_same_structure(\n                 tree.lists_to_tuples(inputs),\n                 tree.lists_to_tuples(self._inputs_struct),\n-                check_types=False,\n             )\n         except:\n             model_inputs_struct = tree.map_structure(\n\n@@ -987,8 +987,8 @@ class ModelTest(testing.TestCase):\n \n     def get_struct_loss(self, structure):\n         def loss_fn(y_true, y_pred):\n-            tree.assert_same_structure(structure, y_true, check_types=False)\n-            tree.assert_same_structure(structure, y_pred, check_types=False)\n+            tree.assert_same_structure(structure, y_true)\n+            tree.assert_same_structure(structure, y_pred)\n             tree.map_structure(\n                 lambda spec, tensor: self.assertEqual(spec.ndim, tensor.ndim),\n                 structure,\n@@ -1044,7 +1044,7 @@ class ModelTest(testing.TestCase):\n \n         if _type is other_type:\n             with self.assertRaisesRegex(\n-                ValueError, \"don't have the same structure\"\n+                ValueError, \"[Ee]xpected.*\" + _type.__name__\n             ):\n                 model.fit(x, y, batch_size=2, epochs=1, verbose=0)\n         else:\n\n@@ -182,9 +182,7 @@ class Function(Operation):\n \n     def _assert_input_compatibility(self, inputs):\n         try:\n-            tree.assert_same_structure(\n-                inputs, self._inputs_struct, check_types=False\n-            )\n+            tree.assert_same_structure(inputs, self._inputs_struct)\n         except ValueError:\n             raise ValueError(\n                 \"Function was called with an invalid input structure. \"\n\n@@ -600,9 +600,7 @@ class CompileLoss(losses_module.Loss):\n         # pack the losses and the weights together\n         if loss_weights is not None:\n             try:\n-                tree.assert_same_structure(\n-                    loss, loss_weights, check_types=False\n-                )\n+                tree.assert_same_structure(loss, loss_weights)\n             except ValueError:\n                 flat_loss_weights = tree.flatten(loss_weights)\n                 if len(tree.flatten(loss)) != len(flat_loss_weights):\n@@ -705,7 +703,7 @@ class CompileLoss(losses_module.Loss):\n             return loss_value\n \n         try:\n-            tree.assert_same_structure(y_pred, y_true, check_types=False)\n+            tree.assert_same_structure(y_pred, y_true)\n         except ValueError:\n             # Check case where y_true is either flat or leaf\n             if (\n@@ -763,17 +761,13 @@ class CompileLoss(losses_module.Loss):\n             self.build(y_true, y_pred)\n \n         try:\n-            tree.assert_same_structure(\n-                self._y_pred_build_structure, y_pred, check_types=False\n-            )\n+            tree.assert_same_structure(self._y_pred_build_structure, y_pred)\n         except ValueError:\n             y_pred = tree.pack_sequence_as(\n                 self._y_pred_build_structure, tree.flatten(y_pred)\n             )\n         try:\n-            tree.assert_same_structure(\n-                self._y_true_build_structure, y_true, check_types=False\n-            )\n+            tree.assert_same_structure(self._y_true_build_structure, y_true)\n         except ValueError:\n             y_true = tree.pack_sequence_as(\n                 self._y_true_build_structure, tree.flatten(y_true)\n\n@@ -1,7 +1,6 @@\n from collections import namedtuple\n \n import numpy as np\n-import tree\n from absl.testing import parameterized\n \n from keras.src import backend\n@@ -9,6 +8,7 @@ from keras.src import metrics as losses_module\n from keras.src import metrics as metrics_module\n from keras.src import ops\n from keras.src import testing\n+from keras.src import tree\n from keras.src.trainers.compile_utils import CompileLoss\n from keras.src.trainers.compile_utils import CompileMetrics\n \n\n@@ -1,41 +1,316 @@\n+import collections\n+import collections.abc\n+import itertools\n+\n+from keras.src.backend.config import backend\n from keras.src.utils.module_utils import dmtree\n \n+# NOTE: There are two known discrepancies between this `dmtree` implementation\n+# of the tree API and the `optree` implementation:\n+#\n+# 1. `map_structure` with *multiple* structures and `map_structure_up_to` do not\n+#    use the object registration (they use the raw `dmtree.map_structure` and\n+#    `dmtree.map_structure_up_to`). This only has consequences with two types of\n+#    structures:\n+#    - `TrackedSet` will not explored (considered as a leaf).\n+#    - `OrderedDict` will be traversed in the order of sorted keys, not the\n+#      order of the items. This is typically inconsequential because functions\n+#      used with `map_structure` and `map_structure_up_to` are typically not\n+#      order dependent and are, in fact, stateless.\n+#\n+# 2. The handling of non-sortable keys in dictionaries in inconsistent. `optree`\n+#    uses the iteration order while `dmtree` raises an error. This is not an\n+#    issue as keys are always strings. But this is the reason why we document\n+#    non-sortable keys as unsupported (meaning behavior is undefined).\n+\n+REGISTERED_CLASSES = {}\n+\n+ClassRegistration = collections.namedtuple(\n+    \"ClassRegistration\", [\"flatten\", \"unflatten\"]\n+)\n+\n+\n+class TypeErrorRemapping:\n+    def __enter__(self):\n+        pass\n+\n+    def __exit__(self, exc_type, exc_value, traceback):\n+        if exc_type is TypeError:\n+            raise ValueError(exc_value).with_traceback(traceback)\n+        return False\n+\n+\n+def register_tree_node(\n+    cls,\n+    flatten_func=None,\n+    unflatten_func=None,\n+):\n+    if flatten_func is None:\n+        flatten_func = lambda x: x.tree_flatten()\n+    if unflatten_func is None:\n+        unflatten_func = cls.tree_unflatten\n+    REGISTERED_CLASSES[cls] = ClassRegistration(flatten_func, unflatten_func)\n+\n \n def register_tree_node_class(cls):\n+    register_tree_node(cls)\n     return cls\n \n \n+register_tree_node(\n+    collections.OrderedDict,\n+    lambda d: (d.values(), list(d.keys()), d.keys()),\n+    lambda metadata, children: collections.OrderedDict(zip(metadata, children)),\n+)\n+\n+if backend() == \"tensorflow\":\n+    from tensorflow.python.trackable.data_structures import ListWrapper\n+    from tensorflow.python.trackable.data_structures import _DictWrapper\n+\n+    register_tree_node(\n+        ListWrapper,\n+        lambda x: (x, None),\n+        lambda metadata, children: ListWrapper(list(children)),\n+    )\n+\n+    def sorted_keys_and_values(d):\n+        keys = sorted(list(d.keys()))\n+        values = [d[k] for k in keys]\n+        return values, keys, keys\n+\n+    register_tree_node(\n+        _DictWrapper,\n+        sorted_keys_and_values,\n+        lambda metadata, children: _DictWrapper(\n+            {key: child for key, child in zip(metadata, children)}\n+        ),\n+    )\n+\n+\n def is_nested(structure):\n-    return dmtree.is_nested(structure)\n+    return type(structure) in REGISTERED_CLASSES or dmtree.is_nested(structure)\n \n \n def traverse(func, structure, top_down=True):\n-    return dmtree.traverse(func, structure, top_down=top_down)\n+    if not callable(func):\n+        raise TypeError(\n+            f\"`func` must be callable, got {func} of type {type(func)}\"\n+        )\n+\n+    def remap_map_to_none(value, new_value):\n+        if isinstance(value, type) and value.__name__ == \"MAP_TO_NONE\":\n+            return new_value\n+        return value\n+\n+    def traverse_top_down(s):\n+        ret = func(s)\n+        if ret is not None:\n+            return remap_map_to_none(ret, dmtree.MAP_TO_NONE)\n+        registration = REGISTERED_CLASSES.get(type(s), None)\n+        if registration is None:\n+            return None\n+        flat_meta_s = registration.flatten(s)\n+        flat_s = [\n+            dmtree.traverse(traverse_top_down, x, top_down=True)\n+            for x in list(flat_meta_s[0])\n+        ]\n+        return registration.unflatten(flat_meta_s[1], flat_s)\n+\n+    def traverse_bottom_up(s):\n+        registration = REGISTERED_CLASSES.get(type(s), None)\n+        if registration is not None:\n+            flat_meta_s = registration.flatten(s)\n+            ret = [traverse_bottom_up(x) for x in list(flat_meta_s[0])]\n+            ret = registration.unflatten(flat_meta_s[1], ret)\n+        elif not dmtree.is_nested(s):\n+            ret = s\n+        elif isinstance(s, collections.abc.Mapping):\n+            ret = [traverse_bottom_up(s[key]) for key in sorted(s)]\n+            ret = dmtree._sequence_like(s, ret)\n+        else:\n+            ret = [traverse_bottom_up(x) for x in s]\n+            ret = dmtree._sequence_like(s, ret)\n+        func_ret = func(ret)\n+        return ret if func_ret is None else remap_map_to_none(func_ret, None)\n+\n+    if top_down:\n+        return dmtree.traverse(traverse_top_down, structure, top_down=True)\n+    else:\n+        return traverse_bottom_up(structure)\n \n \n def flatten(structure):\n-    return dmtree.flatten(structure)\n+    if not is_nested(structure):\n+        return [structure]\n+\n+    flattened = []\n+\n+    def flatten_func(s):\n+        registration = REGISTERED_CLASSES.get(type(s), None)\n+        if registration is not None:\n+            flat_s = list(registration.flatten(s)[0])\n+            return dmtree.traverse(flatten_func, flat_s, top_down=True)\n+        if not is_nested(s):\n+            flattened.append(s)\n+            return dmtree.MAP_TO_NONE if s is None else s\n+        return None\n+\n+    dmtree.traverse(flatten_func, structure, top_down=True)\n+    return flattened\n+\n+\n+def _recursive_flatten_with_path(path, structure, flattened):\n+    registration = REGISTERED_CLASSES.get(type(structure), None)\n+    if registration is not None:\n+        flat_meta_paths = registration.flatten(structure)\n+        flat = flat_meta_paths[0]\n+        paths = (\n+            flat_meta_paths[2]\n+            if len(flat_meta_paths) >= 3\n+            else itertools.count()\n+        )\n+        for key, value in zip(paths, flat):\n+            _recursive_flatten_with_path(path + (key,), value, flattened)\n+    elif not dmtree.is_nested(structure):\n+        flattened.append((path, structure))\n+    elif isinstance(structure, collections.abc.Mapping):\n+        for key in sorted(structure):\n+            _recursive_flatten_with_path(\n+                path + (key,), structure[key], flattened\n+            )\n+    else:\n+        for key, value in enumerate(structure):\n+            _recursive_flatten_with_path(path + (key,), value, flattened)\n \n \n def flatten_with_path(structure):\n-    return dmtree.flatten_with_path(structure)\n+    if not is_nested(structure):\n+        return [((), structure)]\n+\n+    # Fully reimplemented in Python to handle registered classes, OrderedDict\n+    # and namedtuples the same way as optree.\n+    flattened = []\n+    _recursive_flatten_with_path((), structure, flattened)\n+    return flattened\n \n \n def map_structure(func, *structures):\n+    if not callable(func):\n+        raise TypeError(\n+            f\"`func` must be callable, got {func} of type {type(func)}\"\n+        )\n+\n+    def func_traverse_wrapper(s):\n+        if is_nested(s):\n+            return None\n+        ret = func(s)\n+        if ret is None:\n+            return dmtree.MAP_TO_NONE\n+        return ret\n+\n+    if len(structures) == 1:\n+        return traverse(func_traverse_wrapper, structures[0])\n+\n+    with TypeErrorRemapping():\n         return dmtree.map_structure(func, *structures)\n \n \n def map_structure_up_to(shallow_structure, func, *structures):\n+    if not callable(func):\n+        raise TypeError(\n+            f\"`func` must be callable, got {func} of type {type(func)}\"\n+        )\n+\n+    with TypeErrorRemapping():\n         return dmtree.map_structure_up_to(shallow_structure, func, *structures)\n \n \n-def assert_same_structure(a, b, check_types=True):\n-    return dmtree.assert_same_structure(a, b, check_types=check_types)\n+def assert_same_structure(a, b):\n+    # Fully reimplemented in Python to handle registered classes.\n+\n+    # Don't handle OrderedDict as a registered class, use the normal dict path\n+    # so that OrderedDict is equivalent to dict per optree behavior.\n+    a_registration = REGISTERED_CLASSES.get(type(a), None)\n+    if isinstance(a, collections.OrderedDict):\n+        a_registration = None\n+\n+    b_registration = REGISTERED_CLASSES.get(type(b), None)\n+    if isinstance(b, collections.OrderedDict):\n+        b_registration = None\n+\n+    if a_registration != b_registration:\n+        raise ValueError(\n+            f\"Custom node type mismatch; \"\n+            f\"expected type: {type(a)}, got type: {type(b)} \"\n+            f\"while comparing {a} and {b}.\"\n+        )\n+    if a_registration is not None:\n+        a_flat_meta = a_registration.flatten(a)\n+        b_flat_meta = b_registration.flatten(b)\n+        a_flat = list(a_flat_meta[0])\n+        b_flat = list(b_flat_meta[0])\n+        if not a_flat_meta[1] == b_flat_meta[1]:\n+            raise ValueError(\n+                f\"Mismatch custom node data; \"\n+                f\"expected: {a_flat_meta[1]}, got: {b_flat_meta[1]} \"\n+                f\"while comparing {a} and {b}.\"\n+            )\n+        if len(a_flat) != len(b_flat):\n+            raise ValueError(\n+                f\"Arity mismatch; expected: {len(a)}, got: {len(b)} \"\n+                f\"while comparing {a} and {b}.\"\n+            )\n+        for sub_a, sub_b in zip(a_flat, b_flat):\n+            assert_same_structure(sub_a, sub_b)\n+    elif not dmtree.is_nested(a):\n+        if dmtree.is_nested(b):\n+            raise ValueError(\n+                f\"Structures don't have the same nested structure: {a}, {b}.\"\n+            )\n+    elif isinstance(\n+        a, (dict, collections.OrderedDict, collections.defaultdict)\n+    ):\n+        if not isinstance(\n+            b, (dict, collections.OrderedDict, collections.defaultdict)\n+        ):\n+            raise ValueError(\n+                f\"Expected an instance of dict, collections.OrderedDict, or \"\n+                f\"collections.defaultdict, got {type(b)} \"\n+                f\"while comparing {a} and {b}.\"\n+            )\n+        a_keys = sorted(a)\n+        b_keys = sorted(b)\n+        if not a_keys == b_keys:\n+            raise ValueError(\n+                f\"Dictionary key mismatch; \"\n+                f\"expected key(s): {a_keys}, got key(s): {b_keys} \"\n+                f\"while comparing {a} and {b}.\"\n+            )\n+        for key in a_keys:\n+            assert_same_structure(a[key], b[key])\n+    elif isinstance(a, collections.abc.Mapping):\n+        raise ValueError(\n+            f\"Encountered unregistered collections.abc.Mapping type: {type(a)} \"\n+            f\"while comparing {a} and {b}.\"\n+        )\n+    else:\n+        if type(a) is not type(b):\n+            raise ValueError(\n+                f\"Expected an instance of {type(a)}, got {type(b)} \"\n+                f\"while comparing {a} and {b}.\"\n+            )\n+        if not len(a) == len(b):\n+            raise ValueError(\n+                f\"Arity mismatch; expected: {len(a)}, got: {len(b)} \"\n+                f\"while comparing {a} and {b}.\"\n+            )\n+        for sub_a, sub_b in zip(a, b):\n+            assert_same_structure(sub_a, sub_b)\n \n \n def assert_same_paths(a, b):\n-    a_paths = set([path for path, leaf in dmtree.flatten_with_path(a)])\n-    b_paths = set([path for path, leaf in dmtree.flatten_with_path(b)])\n+    a_paths = set([path for path, _ in flatten_with_path(a)])\n+    b_paths = set([path for path, _ in flatten_with_path(b)])\n \n     if a_paths != b_paths:\n         msg = \"`a` and `b` don't have the same paths.\"\n@@ -48,126 +323,72 @@ def assert_same_paths(a, b):\n         raise ValueError(msg)\n \n \n-def pack_sequence_as(structure, flat_sequence, sequence_fn=None):\n-    is_nested_fn = dmtree.is_nested\n-    sequence_fn = sequence_fn or dmtree._sequence_like\n-\n-    def truncate(value, length):\n-        value_str = str(value)\n-        return value_str[:length] + (value_str[length:] and \"...\")\n-\n-    if not is_nested_fn(flat_sequence):\n-        raise TypeError(\n-            \"Attempted to pack value:\\n  {}\\ninto a structure, but found \"\n-            \"incompatible type `{}` instead.\".format(\n-                truncate(flat_sequence, 100), type(flat_sequence)\n-            )\n-        )\n-\n-    if not is_nested_fn(structure):\n-        if len(flat_sequence) != 1:\n-            raise ValueError(\n-                \"The target structure is of type `{}`\\n  {}\\nHowever the input \"\n-                \"is a sequence ({}) of length {}.\\n  {}\\nnest cannot \"\n-                \"guarantee that it is safe to map one to the other.\".format(\n-                    type(structure),\n-                    truncate(structure, 100),\n-                    type(flat_sequence),\n-                    len(flat_sequence),\n-                    truncate(flat_sequence, 100),\n-                )\n-            )\n+def pack_sequence_as(structure, flat_sequence):\n+    # This is not just an optimization for the case when structure is a leaf.\n+    # This is required to avoid Torch Dynamo failures.\n+    if not is_nested(structure):\n+        if len(flat_sequence) == 1:\n             return flat_sequence[0]\n-\n-    packed = []\n-    try:\n-        final_index, packed = packed_nest_with_indices(\n-            structure, flat_sequence, 0, is_nested_fn, sequence_fn\n-        )\n-        if final_index < len(flat_sequence):\n-            raise IndexError\n-    except IndexError:\n-        flat_structure = dmtree.flatten(structure)\n-        if len(flat_structure) != len(flat_sequence):\n-            # pylint: disable=raise-missing-from\n-            raise ValueError(\n-                \"Could not pack sequence. \"\n-                f\"Structure had {len(flat_structure)} atoms, but \"\n-                f\"flat_sequence had {len(flat_sequence)} items. \"\n-                f\"Structure: {structure}, flat_sequence: {flat_sequence}.\"\n-            )\n-    return sequence_fn(structure, packed)\n-\n-\n-def packed_nest_with_indices(\n-    structure, flat, index, is_nested_fn, sequence_fn=None\n-):\n-    \"\"\"Helper function for pack_sequence_as.\n-\n-    Args:\n-        structure: structure to mimic.\n-        flat: Flattened values to output substructure for.\n-        index: Index at which to start reading from flat.\n-        is_nested_fn: Function used to test if a value should\n-            be treated as a nested structure.\n-        sequence_fn: Function used to generate a new structure instance.\n-\n-    Returns:\n-        The tuple (new_index, child), where:\n-        * new_index - the updated index into `flat`\n-            having processed `structure`.\n-        * packed - the subset of `flat` corresponding to `structure`,\n-            having started at `index`, and packed into the same nested\n-            format.\n-    \"\"\"\n-    packed = []\n-    sequence_fn = sequence_fn or dmtree._sequence_like\n-    for s in yield_value(structure):\n-        if is_nested_fn(s):\n-            new_index, child = packed_nest_with_indices(\n-                s, flat, index, is_nested_fn, sequence_fn\n-            )\n-            packed.append(sequence_fn(s, child))\n-            index = new_index\n         else:\n-            packed.append(flat[index])\n-            index += 1\n-    return index, packed\n+            raise ValueError(\n+                \"Incorrect number of leaves provided by `flat_sequence` for \"\n+                f\"`structure`; expected: 1, got {len(flat_sequence)}.\"\n+            )\n \n+    flat_sequence_it = enumerate(flat_sequence)\n \n-def yield_value(iterable):\n-    for _, v in dmtree._yield_sorted_items(iterable):\n-        yield v\n+    def unflatten_func(s):\n+        registration = REGISTERED_CLASSES.get(type(s), None)\n+        if registration is not None:\n+            flat_meta_s = registration.flatten(s)\n+            flat_s = dmtree.traverse(\n+                unflatten_func, list(flat_meta_s[0]), top_down=True\n+            )\n+            return registration.unflatten(flat_meta_s[1], flat_s)\n+        elif not dmtree.is_nested(s):\n+            try:\n+                _, value = next(flat_sequence_it)\n+                return dmtree.MAP_TO_NONE if value is None else value\n+            except StopIteration:\n+                raise ValueError(\n+                    \"Too few leaves provided by `flat_sequence` for \"\n+                    f\"`structure`. Got {len(flat_sequence)}.\"\n+                )\n+        return None\n+\n+    ret = dmtree.traverse(unflatten_func, structure, top_down=True)\n+    try:\n+        index, _ = next(flat_sequence_it)\n+        raise ValueError(\n+            \"Too many leaves provided by `flat_sequence` for `structure`; \"\n+            f\"expected: {index}, got {len(flat_sequence)}.\"\n+        )\n+    except StopIteration:\n+        return ret\n \n \n def lists_to_tuples(structure):\n-    def sequence_fn(instance, args):\n-        if isinstance(instance, list):\n-            return tuple(args)\n-        return dmtree._sequence_like(instance, args)\n+    def list_to_tuple(instance):\n+        return tuple(instance) if isinstance(instance, list) else None\n \n-    return pack_sequence_as(\n-        structure,\n-        dmtree.flatten(structure),\n-        sequence_fn=sequence_fn,\n-    )\n-\n-\n-def is_shape_tuple(x):\n-    if isinstance(x, (list, tuple)):\n-        if all(isinstance(e, (int, type(None))) for e in x):\n-            return True\n-    return False\n+    return traverse(list_to_tuple, structure, top_down=False)\n \n \n def map_shape_structure(func, structure):\n-    if is_shape_tuple(structure):\n-        return func(tuple(structure))\n-    if isinstance(structure, list):\n-        return [map_shape_structure(func, e) for e in structure]\n-    if isinstance(structure, tuple):\n-        return tuple(map_shape_structure(func, e) for e in structure)\n-    if isinstance(structure, dict):\n-        return {k: map_shape_structure(func, v) for k, v in structure.items()}\n+    if not callable(func):\n+        raise TypeError(\n+            f\"`func` must be callable, got {func} of type {type(func)}\"\n+        )\n+\n+    def map_shape_func(x):\n+        if isinstance(x, (list, tuple)) and all(\n+            isinstance(e, (int, type(None))) for e in x\n+        ):\n+            ret = func(x)\n+        elif is_nested(x):\n+            return None\n         else:\n-        raise ValueError(f\"Cannot map function to unknown object {structure}\")\n+            ret = func(x)\n+        return ret if ret is not None else dmtree.MAP_TO_NONE\n+\n+    return traverse(map_shape_func, structure, top_down=True)\n\n@@ -1,7 +1,3 @@\n-import collections\n-import collections.abc\n-import types\n-\n import optree\n import optree.utils\n \n@@ -15,6 +11,7 @@ def register_tree_node_class(cls):\n # Register backend-specific node classes\n if backend() == \"tensorflow\":\n     from tensorflow.python.trackable.data_structures import ListWrapper\n+    from tensorflow.python.trackable.data_structures import _DictWrapper\n \n     optree.register_pytree_node(\n         ListWrapper,\n@@ -23,11 +20,14 @@ if backend() == \"tensorflow\":\n         namespace=\"keras\",\n     )\n \n-    from tensorflow.python.trackable.data_structures import _DictWrapper\n+    def sorted_keys_and_values(d):\n+        keys = sorted(list(d.keys()))\n+        values = [d[k] for k in keys]\n+        return values, keys, keys\n \n     optree.register_pytree_node(\n         _DictWrapper,\n-        lambda x: (list(x.values()), list(x.keys())),\n+        sorted_keys_and_values,\n         lambda metadata, children: _DictWrapper(\n             {key: child for key, child in zip(metadata, children)}\n         ),\n@@ -67,7 +67,10 @@ def traverse(func, structure, top_down=True):\n         ret = func(traversed_structure)\n         if ret is None:\n             return traversed_structure\n-    return None if ret is _MAP_TO_NONE else ret\n+    # Detect MAP_TO_NONE without tree_api import to avoid circular import.\n+    if isinstance(ret, type) and ret.__name__ == \"MAP_TO_NONE\":\n+        return None\n+    return ret\n \n \n def flatten(structure):\n@@ -84,53 +87,60 @@ def flatten_with_path(structure):\n     paths, leaves, _ = optree.tree_flatten_with_path(\n         structure, none_is_leaf=True, namespace=\"keras\"\n     )\n-    leaves_with_path = list(zip(paths, leaves))\n-    return leaves_with_path\n+    return list(zip(paths, leaves))\n \n \n def map_structure(func, *structures):\n-    if not callable(func):\n-        raise TypeError(f\"`func` must be callable. Received: func={func}\")\n     if not structures:\n         raise ValueError(\"Must provide at least one structure\")\n-    for other in structures[1:]:\n-        assert_same_structure(structures[0], other, check_types=False)\n+\n+    # Add check for same structures, otherwise optree just maps to shallowest.\n+    def func_with_check(*args):\n+        if not all(\n+            optree.tree_is_leaf(s, none_is_leaf=True, namespace=\"keras\")\n+            for s in args\n+        ):\n+            raise ValueError(\"Structures don't have the same nested structure.\")\n+        return func(*args)\n+\n+    map_func = func_with_check if len(structures) > 1 else func\n+\n     return optree.tree_map(\n-        func, *structures, none_is_leaf=True, namespace=\"keras\"\n+        map_func, *structures, none_is_leaf=True, namespace=\"keras\"\n     )\n \n \n def map_structure_up_to(shallow_structure, func, *structures):\n-    return _map_structure_with_path_up_to(\n+    if not structures:\n+        raise ValueError(\"Must provide at least one structure\")\n+\n+    # Add check that `shallow_structure` really is the shallowest.\n+    # Also only call `func` on `structures` and not `shallow_structure`.\n+    def func_with_check_without_shallow_structure(shallow, *args):\n+        if not optree.tree_is_leaf(shallow):\n+            raise ValueError(\"Structures don't have the same nested structure.\")\n+        return func(*args)\n+\n+    return optree.tree_map(\n+        func_with_check_without_shallow_structure,\n         shallow_structure,\n-        lambda _, *args: func(*args),  # Discards path.\n         *structures,\n-    )\n-\n-\n-def assert_same_structure(a, b, check_types=True):\n-    a_structure = optree.tree_structure(a, none_is_leaf=True, namespace=\"keras\")\n-    b_structure = optree.tree_structure(b, none_is_leaf=True, namespace=\"keras\")\n-    if a_structure != b_structure:\n-        raise ValueError(\n-            \"`a` and `b` don't have the same structure. \"\n-            f\"Received: structure of a={a_structure}, \"\n-            f\"structure of b={b_structure}\"\n-        )\n-    if check_types:\n-        type_structure = optree.tree_map(\n-            lambda x, y: type(x) is type(y),\n-            a,\n-            b,\n         none_is_leaf=True,\n         namespace=\"keras\",\n     )\n-        if not optree.tree_all(\n-            type_structure, none_is_leaf=True, namespace=\"keras\"\n+\n+\n+def assert_same_structure(a, b):\n+    def check(a_leaf, b_leaf):\n+        if not optree.tree_is_leaf(\n+            a_leaf, none_is_leaf=True, namespace=\"keras\"\n+        ) or not optree.tree_is_leaf(\n+            b_leaf, none_is_leaf=True, namespace=\"keras\"\n         ):\n-            raise TypeError(\n-                \"The type of the leaves of `a` and `b` doesn't match.\"\n-            )\n+            raise ValueError(\"Structures don't have the same nested structure.\")\n+        return None\n+\n+    optree.tree_map(check, a, b, none_is_leaf=True, namespace=\"keras\")\n \n \n def assert_same_paths(a, b):\n@@ -148,64 +158,18 @@ def assert_same_paths(a, b):\n         raise ValueError(msg)\n \n \n-def pack_sequence_as(structure, flat_sequence, sequence_fn=None):\n-    sequence_fn = sequence_fn or _sequence_like\n-\n-    def truncate(value, length):\n-        value_str = str(value)\n-        return value_str[:length] + (value_str[length:] and \"...\")\n-\n-    if not is_nested(flat_sequence):\n-        raise TypeError(\n-            \"Attempted to pack value:\\n  {}\\ninto a structure, but found \"\n-            \"incompatible type `{}` instead.\".format(\n-                truncate(flat_sequence, 100), type(flat_sequence)\n+def pack_sequence_as(structure, flat_sequence):\n+    _, treespec = optree.tree_flatten(\n+        structure, none_is_leaf=True, namespace=\"keras\"\n     )\n-        )\n-\n-    if not is_nested(structure):\n-        if len(flat_sequence) != 1:\n-            raise ValueError(\n-                \"The target structure is of type `{}`\\n  {}\\nHowever the input \"\n-                \"is a sequence ({}) of length {}.\\n  {}\\nnest cannot \"\n-                \"guarantee that it is safe to map one to the other.\".format(\n-                    type(structure),\n-                    truncate(structure, 100),\n-                    type(flat_sequence),\n-                    len(flat_sequence),\n-                    truncate(flat_sequence, 100),\n-                )\n-            )\n-        return flat_sequence[0]\n-\n-    try:\n-        final_index, packed = _packed_nest_with_indices(\n-            structure, flat_sequence, 0, sequence_fn\n-        )\n-        if final_index < len(flat_sequence):\n-            raise IndexError\n-    except IndexError:\n-        flat_structure = flatten(structure)\n-        if len(flat_structure) != len(flat_sequence):\n-            # pylint: disable=raise-missing-from\n-            raise ValueError(\n-                \"Could not pack sequence. \"\n-                f\"Structure had {len(flat_structure)} atoms, but \"\n-                f\"flat_sequence had {len(flat_sequence)} items. \"\n-                f\"Structure: {structure}, flat_sequence: {flat_sequence}.\"\n-            )\n-    return sequence_fn(structure, packed)\n+    return optree.tree_unflatten(treespec, flat_sequence)\n \n \n def lists_to_tuples(structure):\n-    def sequence_fn(instance, args):\n-        if isinstance(instance, list):\n-            return tuple(args)\n-        return _sequence_like(instance, args)\n+    def list_to_tuple(instance):\n+        return tuple(instance) if isinstance(instance, list) else None\n \n-    return pack_sequence_as(\n-        structure, flatten(structure), sequence_fn=sequence_fn\n-    )\n+    return traverse(list_to_tuple, structure, top_down=False)\n \n \n def map_shape_structure(func, structure):\n@@ -214,8 +178,6 @@ def map_shape_structure(func, structure):\n             isinstance(e, (int, type(None))) for e in x\n         )\n \n-    if not callable(func):\n-        raise TypeError(f\"`func` must be callable. Received: func={func}\")\n     return optree.tree_map(\n         func,\n         structure,\n@@ -223,139 +185,3 @@ def map_shape_structure(func, structure):\n         none_is_leaf=True,\n         namespace=\"keras\",\n     )\n-\n-\n-class _MapToNone:\n-    \"\"\"A special object used as a sentinel within `traverse`.\"\"\"\n-\n-    def __repr__(self):\n-        return \"keras.utils.tree._MAP_TO_NONE\"\n-\n-\n-_MAP_TO_NONE = _MapToNone()\n-\n-\n-def _yield_flat_up_to(shallow_tree, input_tree, path=()):\n-    if isinstance(shallow_tree, (str, bytes)) or not (\n-        isinstance(\n-            shallow_tree, (collections.abc.Mapping, collections.abc.Sequence)\n-        )\n-        or optree.is_namedtuple(shallow_tree)\n-    ):\n-        yield (path, input_tree)\n-    else:\n-        input_tree = dict(_yield_sorted_items(input_tree))\n-        for shallow_key, shallow_subtree in _yield_sorted_items(shallow_tree):\n-            subpath = path + (shallow_key,)\n-            input_subtree = input_tree[shallow_key]\n-            for leaf_path, leaf_value in _yield_flat_up_to(\n-                shallow_subtree, input_subtree, path=subpath\n-            ):\n-                yield (leaf_path, leaf_value)\n-\n-\n-def _multiyield_flat_up_to(shallow_tree, *input_trees):\n-    \"\"\"Same as `_yield_flat_up_to`, but takes multiple input trees.\"\"\"\n-    zipped_iterators = zip(\n-        *[\n-            _yield_flat_up_to(shallow_tree, input_tree)\n-            for input_tree in input_trees\n-        ]\n-    )\n-    try:\n-        for paths_and_values in zipped_iterators:\n-            paths, values = zip(*paths_and_values)\n-            yield paths[:1] + values\n-    except KeyError as e:\n-        paths = locals().get(\"paths\", ((),))\n-        raise ValueError(\n-            f\"Could not find key '{e.args[0]}' in some `input_trees`. \"\n-            \"Please ensure the structure of all `input_trees` are \"\n-            \"compatible with `shallow_tree`. The last valid path \"\n-            f\"yielded was {paths[0]}.\"\n-        ) from e\n-\n-\n-def _map_structure_with_path_up_to(shallow_structure, func, *structures):\n-    results = []\n-    for path_and_values in _multiyield_flat_up_to(\n-        shallow_structure, *structures\n-    ):\n-        results.append(func(*path_and_values))\n-    shallow_structure_spec = optree.tree_structure(\n-        shallow_structure, none_is_leaf=True, namespace=\"keras\"\n-    )\n-    return shallow_structure_spec.unflatten(results)\n-\n-\n-def _sequence_like(instance, args):\n-    # TODO: Support attrs library\n-    if isinstance(instance, (dict, collections.abc.Mapping)):\n-        # Pack dictionaries in a deterministic order by sorting the keys.\n-        # Notice this means that we ignore the original order of `OrderedDict`\n-        # instances. This is intentional, to avoid potential bugs caused by\n-        # mixing ordered and plain dicts (e.g., flattening a dict but using a\n-        # corresponding `OrderedDict` to pack it back).\n-        result = dict(zip(sorted(instance), args))\n-        keys_and_values = ((key, result[key]) for key in instance)\n-        if isinstance(instance, collections.defaultdict):\n-            # `defaultdict` requires a default factory as the first argument.\n-            return type(instance)(instance.default_factory, keys_and_values)\n-        elif isinstance(instance, types.MappingProxyType):\n-            # MappingProxyType requires a dict to proxy to.\n-            return type(instance)(dict(keys_and_values))\n-        else:\n-            return type(instance)(keys_and_values)\n-    elif isinstance(instance, collections.abc.MappingView):\n-        # We can't directly construct mapping views, so we create a list instead\n-        return list(args)\n-    elif optree.is_namedtuple(instance):\n-        instance_type = type(instance)\n-        try:\n-            return instance_type(*args)\n-        except Exception as e:\n-            raise TypeError(\n-                f\"Couldn't traverse {instance!r} with arguments {args}\"\n-            ) from e\n-    else:\n-        # Not a namedtuple\n-        return type(instance)(args)\n-\n-\n-def _yield_sorted_items(iterable):\n-    # TODO: Support attrs library\n-    if isinstance(iterable, collections.abc.Mapping):\n-        # Iterate through dictionaries in a deterministic order by sorting the\n-        # keys. Notice this means that we ignore the original order of\n-        # `OrderedDict` instances. This is intentional, to avoid potential bugs\n-        # caused by mixing ordered and plain dicts (e.g., flattening a dict but\n-        # using a corresponding `OrderedDict` to pack it back).\n-        for key in sorted(iterable):\n-            yield key, iterable[key]\n-    elif optree.is_namedtuple(iterable):\n-        for field in iterable._fields:\n-            yield (field, getattr(iterable, field))\n-    else:\n-        for item in enumerate(iterable):\n-            yield item\n-\n-\n-def _yield_value(iterable):\n-    for _, v in _yield_sorted_items(iterable):\n-        yield v\n-\n-\n-def _packed_nest_with_indices(structure, flat, index, sequence_fn=None):\n-    packed = []\n-    sequence_fn = sequence_fn or _sequence_like\n-    for s in _yield_value(structure):\n-        if is_nested(s):\n-            new_index, child = _packed_nest_with_indices(\n-                s, flat, index, sequence_fn\n-            )\n-            packed.append(sequence_fn(s, child))\n-            index = new_index\n-        else:\n-            packed.append(flat[index])\n-            index += 1\n-    return index, packed\n\n@@ -1,3 +1,5 @@\n+import warnings\n+\n from keras.src.api_export import keras_export\n from keras.src.utils.module_utils import dmtree\n from keras.src.utils.module_utils import optree\n@@ -17,6 +19,13 @@ def register_tree_node_class(cls):\n     return tree_impl.register_tree_node_class(cls)\n \n \n+@keras_export(\"keras.tree.MAP_TO_NONE\")\n+class MAP_TO_NONE:\n+    \"\"\"Special value for use with `traverse()`.\"\"\"\n+\n+    pass\n+\n+\n @keras_export(\"keras.tree.is_nested\")\n def is_nested(structure):\n     \"\"\"Checks if a given structure is nested.\n@@ -69,14 +78,14 @@ def traverse(func, structure, top_down=True):\n             If `func(subtree) is not None` the traversal does not continue\n             into the sub-tree. The sub-tree will be replaced by `func(subtree)`\n             in the returned structure (to replace the sub-tree with `None`, use\n-            the special value `_MAP_TO_NONE`).\n+            the special value `MAP_TO_NONE`).\n \n         When traversing bottom-up:\n             If `func(subtree) is None` the traversed sub-tree is returned\n             unaltered.\n             If `func(subtree) is not None` the sub-tree will be replaced by\n             `func(subtree)` in the returned structure (to replace the sub-tree\n-            with None, use the special value `_MAP_TO_NONE`).\n+            with None, use the special value `MAP_TO_NONE`).\n \n         structure: The structure to traverse.\n         top_down: If True, parent structures will be visited before their\n@@ -84,6 +93,9 @@ def traverse(func, structure, top_down=True):\n \n     Returns:\n         The structured output from the traversal.\n+\n+    Raises:\n+        TypeError: If `func` is not callable.\n     \"\"\"\n     return tree_impl.traverse(func, structure, top_down=top_down)\n \n@@ -93,13 +105,13 @@ def flatten(structure):\n     \"\"\"Flattens a possibly nested structure into a list.\n \n     In the case of dict instances, the sequence consists of the values,\n-    sorted by key to ensure deterministic behavior. This is true also for\n-    `collections.OrderedDict` instances: their sequence order is\n-    considered. The same convention is followed in `unflatten_as`.\n-    This correctly unflattens dicts and `OrderedDict` after they have been\n-    flattened, or vice-versa.\n+    sorted by key to ensure deterministic behavior. However, instances of\n+    `collections.OrderedDict` are handled differently: their sequence order is\n+    used instead of the sorted keys. The same convention is followed in\n+    `pack_sequence_as`. This correctly unflattens dicts and `OrderedDict` after\n+    they have been flattened, or vice-versa.\n \n-    Dictionaries with non-sortable keys cannot be flattened.\n+    Dictionaries with non-sortable keys are not supported.\n \n     Examples:\n \n@@ -129,7 +141,7 @@ def flatten_with_path(structure):\n     list of pairs: `(path, item)`. A path is a tuple of indices and/or keys\n     which uniquely identifies the position of the corresponding item.\n \n-    Dictionaries with non-sortable keys cannot be flattened.\n+    Dictionaries with non-sortable keys are not supported.\n \n     Examples:\n \n@@ -170,6 +182,12 @@ def map_structure(func, *structures):\n \n     Returns:\n         A new structure with the same layout as the given ones.\n+\n+    Raises:\n+        TypeError: If `structures` is empty or `func` is not callable.\n+        ValueError: If there is more than one items in `structures` and some of\n+            the nested structures don't match according to the rules of\n+            `assert_same_structure`.\n     \"\"\"\n     return tree_impl.map_structure(func, *structures)\n \n@@ -199,16 +217,29 @@ def map_structure_up_to(shallow_structure, func, *structures):\n \n     Returns:\n         A new structure with the same layout as `shallow_structure`.\n+\n+    Raises:\n+        TypeError: If `structures` is empty or `func` is not callable.\n+        ValueError: If one of the items in `structures` doesn't match the\n+            nested structure of `shallow_structure` according to the rules of\n+            `assert_same_structure`. Items in `structures` are allowed to be\n+            nested deeper than `shallow_structure`, but they cannot be\n+            shallower.\n     \"\"\"\n     return tree_impl.map_structure_up_to(shallow_structure, func, *structures)\n \n \n @keras_export(\"keras.tree.assert_same_structure\")\n-def assert_same_structure(a, b, check_types=True):\n+def assert_same_structure(a, b, check_types=None):\n     \"\"\"Asserts that two structures are nested in the same way.\n \n-    Note that namedtuples with identical name and fields will not be considered\n-    as same structures even `check_types=False`.\n+    This function verifies that the nested structures match. The leafs can be of\n+    any type. At each level, the structures must be of the same type and have\n+    the same number of elements. Instances of `dict`, `OrderedDict` and\n+    `defaultdict` are all considered the same as long as they have the same set\n+    of keys. However, `list`, `tuple`, `namedtuple` and `deque` are not the same\n+    structures. Two namedtuples with identical fields and even identical names\n+    are not the same structures.\n \n     Examples:\n \n@@ -220,15 +251,38 @@ def assert_same_structure(a, b, check_types=True):\n     >>> keras.tree.assert_same_structure(Foo(0, 1), AlsoFoo(2, 3))\n     Traceback (most recent call last):\n         ...\n-    ValueError: `a` and `b` don't have the same structure.\n+    ValueError: The two structures don't have the same nested structure.\n     ...\n \n     Args:\n         a: an arbitrarily nested structure.\n         b: an arbitrarily nested structure.\n-        check_types: if `True` (default) types of leaves are checked as well.\n+        check_types: Deprecated. The behavior of this flag was inconsistent, it\n+            no longer has any effect. For a looser check, use\n+            `assert_same_paths` instead, which considers `list`, `tuple`,\n+            `namedtuple` and `deque` as matching structures.\n+\n+    Raises:\n+        ValueError: If the two structures `a` and `b` don't match.\n     \"\"\"\n-    return tree_impl.assert_same_structure(a, b, check_types=check_types)\n+    if check_types is not None:\n+        if check_types:\n+            warnings.warn(\n+                \"The `check_types` argument is deprecated and no longer has \"\n+                \"any effect, please remove.\",\n+                DeprecationWarning,\n+                stacklevel=2,\n+            )\n+        else:\n+            warnings.warn(\n+                \"The `check_types` argument is deprecated and no longer has \"\n+                \"any effect. For a looser check, use \"\n+                \"`keras.tree.assert_same_paths()`, which considers `list`, \"\n+                \"`tuple`, `namedtuple` and `deque` as matching\",\n+                DeprecationWarning,\n+                stacklevel=2,\n+            )\n+    return tree_impl.assert_same_structure(a, b)\n \n \n @keras_export(\"keras.tree.assert_same_paths\")\n@@ -237,7 +291,10 @@ def assert_same_paths(a, b):\n \n     This function verifies that two nested structures have the same paths.\n     Unlike `assert_same_structure`, this function only checks the paths\n-    and ignores the nodes' types.\n+    and ignores the collection types.\n+    For Sequences, to path is the index: 0, 1, 2, etc. For Mappings, the path is\n+    the key, for instance \"a\", \"b\", \"c\". Note that namedtuples also use indices\n+    and not field names for the path.\n \n     Examples:\n     >>> keras.tree.assert_same_paths([0, 1], (2, 3))\n@@ -250,27 +307,28 @@ def assert_same_paths(a, b):\n         b: an arbitrarily nested structure.\n \n     Raises:\n-        `ValueError`: If the paths in structure `a` don't match the paths\n-        in structure `b`. The error message will include the specific\n-        paths that differ.\n+        ValueError: If the paths in structure `a` don't match the paths in\n+            structure `b`. The error message will include the specific paths\n+            that differ.\n     \"\"\"\n     return tree_impl.assert_same_paths(a, b)\n \n \n @keras_export(\"keras.tree.pack_sequence_as\")\n-def pack_sequence_as(structure, flat_sequence, sequence_fn=None):\n+def pack_sequence_as(structure, flat_sequence):\n     \"\"\"Returns a given flattened sequence packed into a given structure.\n \n     If `structure` is an atom, `flat_sequence` must be a single-item list; in\n     this case the return value is `flat_sequence[0]`.\n \n     If `structure` is or contains a dict instance, the keys will be sorted to\n-    pack the flat sequence in deterministic order. This is true also for\n-    `OrderedDict` instances: their sequence order is considered. The same\n-    convention is followed in `flatten`. This correctly repacks dicts and\n-    `OrderedDicts` after they have been flattened, or vice-versa.\n+    pack the flat sequence in deterministic order. However, instances of\n+    `collections.OrderedDict` are handled differently: their sequence order is\n+    used instead of the sorted keys. The same convention is followed in\n+    `flatten`. This correctly repacks dicts and `OrderedDicts` after they have\n+    been flattened, or vice-versa.\n \n-    Dictionaries with non-sortable keys cannot be flattened.\n+    Dictionaries with non-sortable keys are not supported.\n \n     Examples:\n \n@@ -305,23 +363,42 @@ def pack_sequence_as(structure, flat_sequence, sequence_fn=None):\n     Args:\n         structure: Arbitrarily nested structure.\n         flat_sequence: Flat sequence to pack.\n-        sequence_fn: Defaults to `_sequence_like`.\n \n     Returns:\n         `flat_sequence` converted to have the same recursive structure as\n         `structure`.\n+\n+    Raises:\n+        TypeError: If `flat_sequence` is not iterable.\n+        ValueError: If `flat_sequence` cannot be repacked as `structure`; for\n+            instance, if `flat_sequence` has too few or too many elements.\n     \"\"\"\n-    return tree_impl.pack_sequence_as(\n-        structure, flat_sequence, sequence_fn=sequence_fn\n-    )\n+    return tree_impl.pack_sequence_as(structure, flat_sequence)\n \n \n @keras_export(\"keras.tree.lists_to_tuples\")\n def lists_to_tuples(structure):\n+    \"\"\"Returns the structure with list instances changed to tuples.\n+\n+    Args:\n+        structure: Arbitrarily nested structure.\n+\n+    Returns:\n+        The same structure but with tuples instead of lists.\n+    \"\"\"\n     return tree_impl.lists_to_tuples(structure)\n \n \n @keras_export(\"keras.tree.map_shape_structure\")\n def map_shape_structure(func, structure):\n-    \"\"\"Variant of keras.tree.map_structure that operates on shape tuples.\"\"\"\n+    \"\"\"Variant of keras.tree.map_structure that operates on shape tuples.\n+\n+    Tuples containing ints and Nones are considered shapes and passed to `func`.\n+\n+    Args:\n+        structure: Arbitrarily nested structure.\n+\n+    Returns:\n+        The same structure with `func` applied.\n+    \"\"\"\n     return tree_impl.map_shape_structure(func, structure)\n\n@@ -1,17 +1,22 @@\n-import collections\n+import functools\n+from collections import OrderedDict\n+from collections import defaultdict\n+from collections import deque\n+from collections import namedtuple\n \n import numpy as np\n+import pytest\n from absl.testing import parameterized\n \n+from keras.src import backend\n from keras.src import ops\n from keras.src import testing\n+from keras.src.tree.tree_api import MAP_TO_NONE\n from keras.src.utils.module_utils import dmtree\n from keras.src.utils.module_utils import optree\n-\n-STRUCTURE1 = (((1, 2), 3), 4, (5, 6))\n-STRUCTURE2 = (((\"foo1\", \"foo2\"), \"foo3\"), \"foo4\", (\"foo5\", \"foo6\"))\n-STRUCTURE_DIFFERENT_NUM_ELEMENTS = (\"spam\", \"eggs\")\n-STRUCTURE_DIFFERENT_NESTING = (((1, 2), 3), 4, 5, (6,))\n+from keras.src.utils.tracking import TrackedDict\n+from keras.src.utils.tracking import TrackedList\n+from keras.src.utils.tracking import TrackedSet\n \n TEST_CASES = []\n if dmtree.available:\n@@ -20,8 +25,7 @@ if dmtree.available:\n     TEST_CASES += [\n         {\n             \"testcase_name\": \"dmtree\",\n-            \"tree_impl\": dmtree_impl,\n-            \"is_optree\": False,\n+            \"t\": dmtree_impl,\n         }\n     ]\n if optree.available:\n@@ -30,174 +34,1067 @@ if optree.available:\n     TEST_CASES += [\n         {\n             \"testcase_name\": \"optree\",\n-            \"tree_impl\": optree_impl,\n-            \"is_optree\": True,\n+            \"t\": optree_impl,\n         },\n     ]\n \n \n+Empty = namedtuple(\"Empty\", [])\n+Point = namedtuple(\"Point\", [\"x\", \"y\"])\n+OtherPoint = namedtuple(\"OtherPoint\", [\"x\", \"y\"])\n+\n+\n+def default_value():\n+    return None\n+\n+\n+class Visitor:\n+    def __init__(self, func):\n+        self.func = func\n+        self.visited_list = []\n+\n+    def __call__(self, x):\n+        self.visited_list.append(x)\n+        return self.func(x)\n+\n+    def visited(self):\n+        ret = self.visited_list\n+        self.visited_list = []\n+        return ret\n+\n+\n @parameterized.named_parameters(TEST_CASES)\n class TreeTest(testing.TestCase):\n-    def test_is_nested(self, tree_impl, is_optree):\n-        self.assertFalse(tree_impl.is_nested(\"1234\"))\n-        self.assertFalse(tree_impl.is_nested(b\"1234\"))\n-        self.assertFalse(tree_impl.is_nested(bytearray(\"1234\", \"ascii\")))\n-        self.assertTrue(tree_impl.is_nested([1, 3, [4, 5]]))\n-        self.assertTrue(tree_impl.is_nested(((7, 8), (5, 6))))\n-        self.assertTrue(tree_impl.is_nested([]))\n-        self.assertTrue(tree_impl.is_nested({\"a\": 1, \"b\": 2}))\n-        self.assertFalse(tree_impl.is_nested(set([1, 2])))\n-        ones = np.ones([2, 3])\n-        self.assertFalse(tree_impl.is_nested(ones))\n-        self.assertFalse(tree_impl.is_nested(np.tanh(ones)))\n-        self.assertFalse(tree_impl.is_nested(np.ones((4, 5))))\n+    def setUp(self):\n+        if dmtree.available and optree.available:\n+            # If both are available, the annotation on the Keras tracking\n+            # wrappers will have used optree. For testing purposes, we need to\n+            # also register them with dm-tree.\n+            from keras.src.tree import dmtree_impl\n \n-    def test_flatten(self, tree_impl, is_optree):\n-        structure = ((3, 4), 5, (6, 7, (9, 10), 8))\n+            dmtree_impl.register_tree_node_class(TrackedList)\n+            dmtree_impl.register_tree_node_class(TrackedSet)\n+            dmtree_impl.register_tree_node_class(TrackedDict)\n+        super().setUp()\n \n-        self.assertEqual(\n-            tree_impl.flatten(structure), [3, 4, 5, 6, 7, 9, 10, 8]\n+    def assertEqualStrict(self, a, b):\n+        self.assertEqual(a, b)\n+        self.assertEqual(type(a), type(b))\n+        if isinstance(a, OrderedDict):\n+            # Verify order.\n+            self.assertEqual(a.items(), b.items())\n+        elif isinstance(a, defaultdict):\n+            self.assertEqual(a.default_factory, b.default_factory)\n+        # Recurse\n+        if isinstance(a, (tuple, list, deque)):\n+            for sub_a, sub_b in zip(a, b):\n+                self.assertEqualStrict(sub_a, sub_b)\n+        elif isinstance(a, dict):\n+            for k in a:\n+                self.assertEqualStrict(a[k], b[k])\n+\n+    def is_dmtree(self, tree_impl):\n+        if dmtree.available:\n+            from keras.src.tree import dmtree_impl\n+\n+            return tree_impl is dmtree_impl\n+        return False\n+\n+    def test_is_nested(self, t):\n+        # Non-nested.\n+        self.assertFalse(t.is_nested(1))\n+        self.assertFalse(t.is_nested(\"1234\"))\n+        self.assertFalse(t.is_nested(b\"1234\"))\n+        self.assertFalse(t.is_nested(bytearray(\"1234\", \"ascii\")))\n+        self.assertFalse(t.is_nested(np.ones((4, 5))))\n+        self.assertFalse(t.is_nested(ops.ones((4, 5))))\n+        self.assertFalse(t.is_nested(set([1, 2])))\n+\n+        # Standard structures.\n+        self.assertTrue(t.is_nested(()))\n+        self.assertTrue(t.is_nested((1,)))\n+        self.assertTrue(t.is_nested((1, 2)))\n+        self.assertTrue(t.is_nested([]))\n+        self.assertTrue(t.is_nested([1]))\n+        self.assertTrue(t.is_nested([1, 2]))\n+        self.assertTrue(t.is_nested(deque([])))\n+        self.assertTrue(t.is_nested(deque([1])))\n+        self.assertTrue(t.is_nested(deque([1, 2])))\n+        self.assertTrue(t.is_nested(Empty()))\n+        self.assertTrue(t.is_nested(Point(x=1, y=2)))\n+        self.assertTrue(t.is_nested({}))\n+        self.assertTrue(t.is_nested({\"a\": 1}))\n+        self.assertTrue(t.is_nested({\"b\": 2, \"a\": 1}))\n+        self.assertTrue(t.is_nested(OrderedDict()))\n+        self.assertTrue(t.is_nested(OrderedDict([(\"a\", 1)])))\n+        self.assertTrue(t.is_nested(OrderedDict([(\"b\", 2), (\"a\", 1)])))\n+        self.assertTrue(t.is_nested(defaultdict(default_value)))\n+        self.assertTrue(t.is_nested(defaultdict(default_value, [(\"a\", 1)])))\n+        self.assertTrue(\n+            t.is_nested(defaultdict(default_value, [(\"b\", 2), (\"a\", 1)]))\n         )\n-        point = collections.namedtuple(\"Point\", [\"x\", \"y\"])\n-        structure = (point(x=4, y=2), ((point(x=1, y=0),),))\n-        flat = [4, 2, 1, 0]\n-        self.assertEqual(tree_impl.flatten(structure), flat)\n \n-        self.assertEqual([5], tree_impl.flatten(5))\n-        self.assertEqual([np.array([5])], tree_impl.flatten(np.array([5])))\n+        # Keras tracking wrappers.\n+        self.assertTrue(t.is_nested(TrackedList([])))\n+        self.assertTrue(t.is_nested(TrackedList([1])))\n+        self.assertTrue(t.is_nested(TrackedList([1, 2])))\n+        self.assertTrue(t.is_nested(TrackedSet([])))\n+        self.assertTrue(t.is_nested(TrackedSet([1])))\n+        self.assertTrue(t.is_nested(TrackedSet([1, 2])))\n+        self.assertTrue(t.is_nested(TrackedDict({})))\n+        self.assertTrue(t.is_nested(TrackedDict({\"a\": 1})))\n+        self.assertTrue(t.is_nested(TrackedDict({\"b\": 2, \"a\": 1})))\n \n-    def test_flatten_with_path(self, tree_impl, is_optree):\n-        structure = {\"b\": (0, 1), \"a\": [2, 3]}\n-        flat_with_path = tree_impl.flatten_with_path(structure)\n+    @pytest.mark.skipif(backend.backend() != \"tensorflow\", reason=\"tf only\")\n+    def test_is_nested_tf_wrappers(self, t):\n+        from tensorflow.python.trackable.data_structures import ListWrapper\n+        from tensorflow.python.trackable.data_structures import _DictWrapper\n \n-        self.assertEqual(\n-            tree_impl.flatten(flat_with_path),\n-            tree_impl.flatten(\n-                [((\"a\", 0), 2), ((\"a\", 1), 3), ((\"b\", 0), 0), ((\"b\", 1), 1)]\n+        self.assertTrue(t.is_nested(ListWrapper([])))\n+        self.assertTrue(t.is_nested(ListWrapper([1])))\n+        self.assertTrue(t.is_nested(ListWrapper([1, 2])))\n+        self.assertTrue(t.is_nested(_DictWrapper({})))\n+        self.assertTrue(t.is_nested(_DictWrapper({\"a\": 1})))\n+        self.assertTrue(t.is_nested(_DictWrapper({\"b\": 2, \"a\": 1})))\n+\n+    def test_flatten(self, t):\n+        # Non-nested.\n+        self.assertEqualStrict(t.flatten(1), [1])\n+\n+        # Standard structures.\n+        self.assertEqualStrict(t.flatten(()), [])\n+        self.assertEqualStrict(t.flatten((1,)), [1])\n+        self.assertEqualStrict(t.flatten((1, 2)), [1, 2])\n+        self.assertEqualStrict(t.flatten([]), [])\n+        self.assertEqualStrict(t.flatten([1]), [1])\n+        self.assertEqualStrict(t.flatten([1, 2]), [1, 2])\n+        self.assertEqualStrict(t.flatten(deque([])), [])\n+        self.assertEqualStrict(t.flatten(deque([1])), [1])\n+        self.assertEqualStrict(t.flatten(deque([1, 2])), [1, 2])\n+        self.assertEqualStrict(t.flatten(Empty()), [])\n+        self.assertEqualStrict(t.flatten(Point(y=2, x=1)), [1, 2])\n+        self.assertEqualStrict(t.flatten({}), [])\n+        self.assertEqualStrict(t.flatten({\"a\": 1}), [1])\n+        self.assertEqualStrict(t.flatten({\"b\": 2, \"a\": 1}), [1, 2])\n+        self.assertEqualStrict(\n+            t.flatten(OrderedDict()),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten(OrderedDict([(\"a\", 1)])),\n+            [1],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten(OrderedDict([(\"b\", 2), (\"a\", 1)])),\n+            [2, 1],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten(defaultdict(default_value)),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten(defaultdict(default_value, [(\"a\", 1)])),\n+            [1],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten(defaultdict(default_value, [(\"b\", 2), (\"a\", 1)])),\n+            [1, 2],\n+        )\n+\n+        # Keras tracking wrappers.\n+        self.assertEqualStrict(t.flatten(TrackedList([])), [])\n+        self.assertEqualStrict(t.flatten(TrackedList([1])), [1])\n+        self.assertEqualStrict(t.flatten(TrackedList([1, 2])), [1, 2])\n+        self.assertEqualStrict(t.flatten(TrackedSet([])), [])\n+        self.assertEqualStrict(t.flatten(TrackedSet([1])), [1])\n+        self.assertEqualStrict(sorted(t.flatten(TrackedSet([1, 2]))), [1, 2])\n+        self.assertEqualStrict(t.flatten(TrackedDict({})), [])\n+        self.assertEqualStrict(t.flatten(TrackedDict({\"a\": 1})), [1])\n+        self.assertEqualStrict(t.flatten(TrackedDict({\"b\": 2, \"a\": 1})), [1, 2])\n+\n+        # Deeper nested structures.\n+        self.assertEqualStrict(\n+            t.flatten(\n+                (\n+                    {\"b\": [2, 3], \"a\": (1,)},\n+                    TrackedDict({\"x\": 4, \"y\": TrackedList([5, 6])}),\n+                    TrackedSet([7]),\n+                    Point(y=9, x=8),\n+                    np.array([10]),\n+                )\n             ),\n+            [1, 2, 3, 4, 5, 6, 7, 8, 9, np.array([10])],\n         )\n-        point = collections.namedtuple(\"Point\", [\"x\", \"y\", \"z\"])\n-        structure = point(x=(0, 1), y=[2, 3], z={\"a\": 4})\n-        flat_with_path = tree_impl.flatten_with_path(structure)\n \n-        if is_optree:\n-            # optree doesn't return namedtuple's field name, but the index\n-            self.assertEqual(\n-                tree_impl.flatten(flat_with_path),\n-                tree_impl.flatten(\n-                    [\n-                        ((0, 0), 0),\n-                        ((0, 1), 1),\n-                        ((1, 0), 2),\n-                        ((1, 1), 3),\n-                        ((2, \"a\"), 4),\n-                    ]\n-                ),\n+    @pytest.mark.skipif(backend.backend() != \"tensorflow\", reason=\"tf only\")\n+    def test_flatten_tf_wrappers(self, t):\n+        from tensorflow.python.trackable.data_structures import ListWrapper\n+        from tensorflow.python.trackable.data_structures import _DictWrapper\n+\n+        self.assertEqualStrict(t.flatten(ListWrapper([])), [])\n+        self.assertEqualStrict(t.flatten(ListWrapper([1])), [1])\n+        self.assertEqualStrict(t.flatten(ListWrapper([1, 2])), [1, 2])\n+        self.assertEqualStrict(t.flatten(_DictWrapper({})), [])\n+        self.assertEqualStrict(t.flatten(_DictWrapper({\"a\": 1})), [1])\n+        self.assertEqualStrict(\n+            t.flatten(_DictWrapper({\"b\": 2, \"a\": 1})), [1, 2]\n         )\n+\n+    def test_flatten_with_path(self, t):\n+        # Non-nested.\n+        self.assertEqualStrict(\n+            t.flatten_with_path(1),\n+            [((), 1)],\n+        )\n+\n+        # Standard structures.\n+        self.assertEqualStrict(\n+            t.flatten_with_path(()),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path((1,)),\n+            [((0,), 1)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path((1, 2)),\n+            [((0,), 1), ((1,), 2)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path([]),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path([1]),\n+            [((0,), 1)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path([1, 2]),\n+            [((0,), 1), ((1,), 2)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(deque([])),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(deque([1])),\n+            [((0,), 1)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(deque([1, 2])),\n+            [((0,), 1), ((1,), 2)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(Empty()),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(Point(y=2, x=1)),\n+            [((0,), 1), ((1,), 2)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path({}),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path({\"a\": 1}),\n+            [((\"a\",), 1)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path({\"b\": 2, \"a\": 1}),\n+            [((\"a\",), 1), ((\"b\",), 2)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(OrderedDict()),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(OrderedDict([(\"a\", 1)])),\n+            [((\"a\",), 1)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(OrderedDict([(\"b\", 2), (\"a\", 1)])),\n+            [((\"b\",), 2), ((\"a\",), 1)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(defaultdict(default_value)),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(defaultdict(default_value, [(\"a\", 1)])),\n+            [((\"a\",), 1)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(\n+                defaultdict(default_value, [(\"b\", 2), (\"a\", 1)])\n+            ),\n+            [((\"a\",), 1), ((\"b\",), 2)],\n+        )\n+\n+        # Keras tracking wrappers.\n+        self.assertEqualStrict(\n+            t.flatten_with_path(TrackedList([])),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(TrackedList([1])),\n+            [((0,), 1)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(TrackedList([1, 2])),\n+            [((0,), 1), ((1,), 2)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(TrackedSet([])),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(TrackedSet([1])),\n+            [((0,), 1)],\n+        )\n+        flat = t.flatten_with_path(TrackedSet([1, 2]))\n+        if flat[0][1] == 1:\n+            self.assertEqualStrict(flat, [((0,), 1), ((1,), 2)])\n         else:\n-            self.assertEqual(\n-                tree_impl.flatten(flat_with_path),\n-                tree_impl.flatten(\n+            self.assertEqualStrict(flat, [((0,), 2), ((1,), 1)])\n+        self.assertEqualStrict(\n+            t.flatten_with_path(TrackedDict({})),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(TrackedDict({\"a\": 1})),\n+            [((\"a\",), 1)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(TrackedDict({\"b\": 2, \"a\": 1})),\n+            [((\"a\",), 1), ((\"b\",), 2)],\n+        )\n+\n+        # Deeper nested structures.\n+        self.assertEqualStrict(\n+            t.flatten_with_path(\n+                (\n+                    {\"b\": [2, 3], \"a\": (1,)},\n+                    TrackedDict({\"x\": 4, \"y\": TrackedList([5, 6])}),\n+                    TrackedSet([7]),\n+                    Point(y=9, x=8),\n+                    np.array([10]),\n+                )\n+            ),\n             [\n-                        ((\"x\", 0), 0),\n-                        ((\"x\", 1), 1),\n-                        ((\"y\", 0), 2),\n-                        ((\"y\", 1), 3),\n-                        ((\"z\", \"a\"), 4),\n-                    ]\n+                ((0, \"a\", 0), 1),\n+                ((0, \"b\", 0), 2),\n+                ((0, \"b\", 1), 3),\n+                ((1, \"x\"), 4),\n+                ((1, \"y\", 0), 5),\n+                ((1, \"y\", 1), 6),\n+                ((2, 0), 7),\n+                ((3, 0), 8),\n+                ((3, 1), 9),\n+                ((4,), np.array([10])),\n+            ],\n+        )\n+\n+    @pytest.mark.skipif(backend.backend() != \"tensorflow\", reason=\"tf only\")\n+    def test_flatten_with_path_tf_wrappers(self, t):\n+        from tensorflow.python.trackable.data_structures import ListWrapper\n+        from tensorflow.python.trackable.data_structures import _DictWrapper\n+\n+        self.assertEqualStrict(\n+            t.flatten_with_path(ListWrapper([])),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(ListWrapper([1])),\n+            [((0,), 1)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(ListWrapper([1, 2])),\n+            [((0,), 1), ((1,), 2)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(_DictWrapper({})),\n+            [],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(_DictWrapper({\"a\": 1})),\n+            [((\"a\",), 1)],\n+        )\n+        self.assertEqualStrict(\n+            t.flatten_with_path(_DictWrapper({\"b\": 2, \"a\": 1})),\n+            [((\"a\",), 1), ((\"b\",), 2)],\n+        )\n+\n+    def test_pack_sequence_as(self, t):\n+        # Non-nested.\n+        self.assertEqualStrict(t.pack_sequence_as(10, [1]), 1)\n+\n+        # Standard structures.\n+        self.assertEqualStrict(t.pack_sequence_as((), []), ())\n+        self.assertEqualStrict(t.pack_sequence_as((10,), [1]), (1,))\n+        self.assertEqualStrict(t.pack_sequence_as((10, 20), [1, 2]), (1, 2))\n+        self.assertEqualStrict(t.pack_sequence_as([], []), [])\n+        self.assertEqualStrict(t.pack_sequence_as([10], [1]), [1])\n+        self.assertEqualStrict(t.pack_sequence_as([10, 20], [1, 2]), [1, 2])\n+        self.assertEqualStrict(t.pack_sequence_as(deque([]), []), deque([]))\n+        self.assertEqualStrict(t.pack_sequence_as(deque([10]), [1]), deque([1]))\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(deque([10, 20]), [1, 2]), deque([1, 2])\n+        )\n+        self.assertEqualStrict(t.pack_sequence_as(Empty(), []), Empty())\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(Point(y=20, x=10), [1, 2]), Point(x=1, y=2)\n+        )\n+        self.assertEqualStrict(t.pack_sequence_as({}, []), {})\n+        self.assertEqualStrict(t.pack_sequence_as({\"a\": 10}, [1]), {\"a\": 1})\n+        self.assertEqualStrict(\n+            t.pack_sequence_as({\"b\": 20, \"a\": 10}, [1, 2]), {\"a\": 1, \"b\": 2}\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(OrderedDict(), []), OrderedDict()\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(OrderedDict([(\"a\", 10)]), [1]),\n+            OrderedDict([(\"a\", 1)]),\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(OrderedDict([(\"b\", 20), (\"a\", 10)]), [2, 1]),\n+            OrderedDict([(\"b\", 2), (\"a\", 1)]),\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(defaultdict(default_value), []),\n+            defaultdict(default_value),\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(defaultdict(default_value, [(\"a\", 10)]), [1]),\n+            defaultdict(default_value, [(\"a\", 1)]),\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(\n+                defaultdict(default_value, [(\"b\", 20), (\"a\", 10)]), [1, 2]\n+            ),\n+            defaultdict(default_value, [(\"a\", 1), (\"b\", 2)]),\n+        )\n+\n+        # Keras tracking wrappers.\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(TrackedList([]), []), TrackedList([])\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(TrackedList([10]), [1]), TrackedList([1])\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(TrackedList([10, 20]), [1, 2]),\n+            TrackedList([1, 2]),\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(TrackedSet([]), []), TrackedSet([])\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(TrackedSet([10]), [1]), TrackedSet([1])\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(TrackedSet([10, 20]), [1, 2]), TrackedSet([1, 2])\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(TrackedDict({}), []), TrackedDict({})\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(TrackedDict({\"a\": 10}), [1]),\n+            TrackedDict({\"a\": 1}),\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(TrackedDict({\"b\": 20, \"a\": 10}), [1, 2]),\n+            TrackedDict({\"a\": 1, \"b\": 2}),\n+        )\n+\n+        # Deeper nested structures.\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(\n+                (\n+                    {\"b\": [20, 30], \"a\": (10,)},\n+                    TrackedDict({\"x\": 40, \"y\": TrackedList([50, 60])}),\n+                    TrackedSet([70]),\n+                    Point(y=90, x=80),\n+                    100,\n+                ),\n+                [1, 2, 3, 4, 5, 6, 7, 8, 9, np.array([10])],\n+            ),\n+            (\n+                {\"b\": [2, 3], \"a\": (1,)},\n+                TrackedDict({\"x\": 4, \"y\": TrackedList([5, 6])}),\n+                TrackedSet([7]),\n+                Point(x=8, y=9),\n+                np.array([10]),\n             ),\n         )\n \n-    def test_flatten_dict_order(self, tree_impl, is_optree):\n-        ordered = collections.OrderedDict(\n-            [(\"d\", 3), (\"b\", 1), (\"a\", 0), (\"c\", 2)]\n-        )\n-        plain = {\"d\": 3, \"b\": 1, \"a\": 0, \"c\": 2}\n-        ordered_flat = tree_impl.flatten(ordered)\n-        plain_flat = tree_impl.flatten(plain)\n-        # dmtree does not respect the ordered dict.\n-        if is_optree:\n-            self.assertEqual([3, 1, 0, 2], ordered_flat)\n-        else:\n-            self.assertEqual([0, 1, 2, 3], ordered_flat)\n-        self.assertEqual([0, 1, 2, 3], plain_flat)\n+        # Error cases.\n+        with self.assertRaisesRegex(TypeError, \"[Ii]terable\"):\n+            t.pack_sequence_as([10, 20], 1)\n+        with self.assertRaisesRegex(ValueError, \"leaves.*expected: 1\"):\n+            t.pack_sequence_as(10, [])\n+        with self.assertRaisesRegex(ValueError, \"leaves.*expected: 1\"):\n+            t.pack_sequence_as(10, [1, 2])\n+        with self.assertRaisesRegex(ValueError, \"Too few leaves\"):\n+            t.pack_sequence_as([10, 20], [1])\n+        with self.assertRaisesRegex(ValueError, \"Too many leaves\"):\n+            t.pack_sequence_as([10, 20], [1, 2, 3])\n \n-    def test_map_structure(self, tree_impl, is_optree):\n-        assertion_message = (\n-            \"have the same structure\"\n-            if is_optree\n-            else \"have the same nested structure\"\n+    @pytest.mark.skipif(backend.backend() != \"tensorflow\", reason=\"tf only\")\n+    def test_pack_sequence_as_tf_wrappers(self, t):\n+        from tensorflow.python.trackable.data_structures import ListWrapper\n+        from tensorflow.python.trackable.data_structures import _DictWrapper\n+\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(ListWrapper([]), []), ListWrapper([])\n         )\n-        assertion_type_error = ValueError if is_optree else TypeError\n-        structure2 = (((7, 8), 9), 10, (11, 12))\n-        structure1_plus1 = tree_impl.map_structure(lambda x: x + 1, STRUCTURE1)\n-        tree_impl.assert_same_structure(STRUCTURE1, structure1_plus1)\n-        self.assertAllEqual(\n-            [2, 3, 4, 5, 6, 7], tree_impl.flatten(structure1_plus1)\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(ListWrapper([10]), [1]), ListWrapper([1])\n         )\n-        structure1_plus_structure2 = tree_impl.map_structure(\n-            lambda x, y: x + y, STRUCTURE1, structure2\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(ListWrapper([10, 20]), [1, 2]),\n+            ListWrapper([1, 2]),\n         )\n-        self.assertEqual(\n-            (((1 + 7, 2 + 8), 3 + 9), 4 + 10, (5 + 11, 6 + 12)),\n-            structure1_plus_structure2,\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(_DictWrapper({}), []), _DictWrapper({})\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(_DictWrapper({\"a\": 10}), [1]),\n+            _DictWrapper({\"a\": 1}),\n+        )\n+        self.assertEqualStrict(\n+            t.pack_sequence_as(_DictWrapper({\"b\": 20, \"a\": 10}), [1, 2]),\n+            _DictWrapper({\"b\": 2, \"a\": 1}),\n         )\n \n-        self.assertEqual(3, tree_impl.map_structure(lambda x: x - 1, 4))\n+    def test_map_structure_with_one_structure(self, t):\n+        def f1(x):\n+            return x + 10 if isinstance(x, int) else None\n \n-        self.assertEqual(7, tree_impl.map_structure(lambda x, y: x + y, 3, 4))\n+        # Non-nested.\n+        self.assertEqualStrict(t.map_structure(f1, 1), 11)\n \n-        # Empty structures\n-        self.assertEqual((), tree_impl.map_structure(lambda x: x + 1, ()))\n-        self.assertEqual([], tree_impl.map_structure(lambda x: x + 1, []))\n-        self.assertEqual({}, tree_impl.map_structure(lambda x: x + 1, {}))\n-        empty_nt = collections.namedtuple(\"empty_nt\", \"\")\n-        self.assertEqual(\n-            empty_nt(),\n-            tree_impl.map_structure(lambda x: x + 1, empty_nt()),\n+        # Standard structures.\n+        self.assertEqualStrict(t.map_structure(f1, ()), ())\n+        self.assertEqualStrict(t.map_structure(f1, (1,)), (11,))\n+        self.assertEqualStrict(t.map_structure(f1, (1, 2)), (11, 12))\n+        self.assertEqualStrict(t.map_structure(f1, []), [])\n+        self.assertEqualStrict(t.map_structure(f1, [1]), [11])\n+        self.assertEqualStrict(t.map_structure(f1, [1, 2]), [11, 12])\n+        self.assertEqualStrict(t.map_structure(f1, deque([])), deque([]))\n+        self.assertEqualStrict(t.map_structure(f1, deque([1])), deque([11]))\n+        self.assertEqualStrict(\n+            t.map_structure(f1, deque([1, 2])), deque([11, 12])\n+        )\n+        self.assertEqualStrict(t.map_structure(f1, Empty()), Empty())\n+        self.assertEqualStrict(\n+            t.map_structure(f1, Point(y=2, x=1)), Point(x=11, y=12)\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, {}),\n+            {},\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, {\"a\": 1}),\n+            {\"a\": 11},\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, {\"b\": 2, \"a\": 1}),\n+            {\"a\": 11, \"b\": 12},\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, OrderedDict()),\n+            OrderedDict(),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, OrderedDict([(\"a\", 1)])),\n+            OrderedDict([(\"a\", 11)]),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, OrderedDict([(\"b\", 2), (\"a\", 1)])),\n+            OrderedDict([(\"b\", 12), (\"a\", 11)]),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, defaultdict(default_value)),\n+            defaultdict(default_value),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, defaultdict(default_value, [(\"a\", 1)])),\n+            defaultdict(default_value, [(\"a\", 11)]),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f1, defaultdict(default_value, [(\"b\", 2), (\"a\", 1)])\n+            ),\n+            defaultdict(default_value, [(\"a\", 11), (\"b\", 12)]),\n         )\n \n-        # This is checking actual equality of types, empty list != empty tuple\n-        self.assertNotEqual((), tree_impl.map_structure(lambda x: x + 1, []))\n+        # Keras tracking wrappers.\n+        self.assertEqualStrict(\n+            t.map_structure(f1, TrackedList([])), TrackedList([])\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, TrackedList([1])), TrackedList([11])\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, TrackedList([1, 2])), TrackedList([11, 12])\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, TrackedSet([])), TrackedSet([])\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, TrackedSet([1])), TrackedSet([11])\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, TrackedSet([1, 2])), TrackedSet([11, 12])\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, TrackedDict()),\n+            TrackedDict(),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, TrackedDict({\"a\": 1})),\n+            TrackedDict({\"a\": 11}),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, TrackedDict({\"b\": 2, \"a\": 1})),\n+            TrackedDict({\"a\": 11, \"b\": 12}),\n+        )\n \n+        # Deeper nested structures.\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f1,\n+                (\n+                    {\"b\": [2, 3], \"a\": (1,)},\n+                    TrackedDict({\"x\": 4, \"y\": TrackedList([5, 6])}),\n+                    TrackedSet([7]),\n+                    Point(y=9, x=8),\n+                    np.array([10]),\n+                ),\n+            ),\n+            (\n+                {\"b\": [12, 13], \"a\": (11,)},\n+                TrackedDict({\"x\": 14, \"y\": TrackedList([15, 16])}),\n+                TrackedSet([17]),\n+                Point(y=19, x=18),\n+                None,\n+            ),\n+        )\n+\n+        # Error cases.\n         with self.assertRaisesRegex(TypeError, \"callable\"):\n-            tree_impl.map_structure(\"bad\", structure1_plus1)\n+            t.map_structure(\"bad\", [1, 2])\n         with self.assertRaisesRegex(ValueError, \"at least one structure\"):\n-            tree_impl.map_structure(lambda x: x)\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.map_structure(lambda x, y: None, (3, 4), (3, 4, 5))\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.map_structure(lambda x, y: None, 3, (3,))\n-        with self.assertRaisesRegex(assertion_type_error, assertion_message):\n-            tree_impl.map_structure(lambda x, y: None, ((3, 4), 5), [(3, 4), 5])\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.map_structure(lambda x, y: None, ((3, 4), 5), (3, (4, 5)))\n+            t.map_structure(f1)\n \n-        structure1_list = [[[1, 2], 3], 4, [5, 6]]\n-        with self.assertRaisesRegex(assertion_type_error, assertion_message):\n-            tree_impl.map_structure(\n-                lambda x, y: None, STRUCTURE1, structure1_list\n+    @pytest.mark.skipif(backend.backend() != \"tensorflow\", reason=\"tf only\")\n+    def test_map_structure_with_one_structure_tf_wrappers(self, t):\n+        from tensorflow.python.trackable.data_structures import ListWrapper\n+        from tensorflow.python.trackable.data_structures import _DictWrapper\n+\n+        def f1(x):\n+            return x + 10\n+\n+        self.assertEqualStrict(\n+            t.map_structure(f1, ListWrapper([])), ListWrapper([])\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, ListWrapper([1])), ListWrapper([11])\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, ListWrapper([1, 2])), ListWrapper([11, 12])\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, _DictWrapper()),\n+            _DictWrapper(),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, _DictWrapper({\"a\": 1})),\n+            _DictWrapper({\"a\": 11}),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f1, _DictWrapper({\"b\": 2, \"a\": 1})),\n+            _DictWrapper({\"a\": 11, \"b\": 12}),\n         )\n \n-    def test_map_structure_up_to(self, tree_impl, is_optree):\n+    def test_map_structure_with_multiple_structures(self, t):\n+        def f2(x, y):\n+            return x + y if isinstance(x, int) and isinstance(y, int) else None\n+\n+        # Non-nested.\n+        self.assertEqualStrict(t.map_structure(f2, 1, 10), 11)\n+\n+        # Standard structures.\n+        self.assertEqualStrict(t.map_structure(f2, ()), ())\n+        self.assertEqualStrict(t.map_structure(f2, (1,), (10,)), (11,))\n+        self.assertEqualStrict(t.map_structure(f2, (1, 2), (10, 20)), (11, 22))\n+        self.assertEqualStrict(t.map_structure(f2, []), [])\n+        self.assertEqualStrict(t.map_structure(f2, [1], [10]), [11])\n+        self.assertEqualStrict(t.map_structure(f2, [1, 2], [10, 20]), [11, 22])\n+        self.assertEqualStrict(t.map_structure(f2, deque([])), deque([]))\n+        self.assertEqualStrict(\n+            t.map_structure(f2, deque([1]), deque([10])), deque([11])\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f2, deque([1, 2]), deque([10, 20])), deque([11, 22])\n+        )\n+        self.assertEqualStrict(t.map_structure(f2, Empty()), Empty())\n+        self.assertEqualStrict(\n+            t.map_structure(f2, Point(y=2, x=1), Point(x=10, y=20)),\n+            Point(x=11, y=22),\n+        )\n+        self.assertEqualStrict(t.map_structure(f2, {}), {})\n+        self.assertEqualStrict(\n+            t.map_structure(f2, {\"a\": 1}, {\"a\": 10}), {\"a\": 11}\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f2, {\"b\": 2, \"a\": 1}, {\"a\": 10, \"b\": 20}),\n+            {\"a\": 11, \"b\": 22},\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(f2, OrderedDict()),\n+            OrderedDict(),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2, OrderedDict([(\"a\", 1)]), OrderedDict([(\"a\", 10)])\n+            ),\n+            OrderedDict([(\"a\", 11)]),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                OrderedDict([(\"b\", 2), (\"a\", 1)]),\n+                OrderedDict([(\"b\", 20), (\"a\", 10)]),\n+            ),\n+            OrderedDict([(\"b\", 22), (\"a\", 11)]),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2, defaultdict(default_value), defaultdict(default_value)\n+            ),\n+            defaultdict(default_value),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                defaultdict(default_value, [(\"a\", 1)]),\n+                defaultdict(default_value, [(\"a\", 10)]),\n+            ),\n+            defaultdict(default_value, [(\"a\", 11)]),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                defaultdict(default_value, [(\"b\", 2), (\"a\", 1)]),\n+                defaultdict(default_value, [(\"a\", 10), (\"b\", 20)]),\n+            ),\n+            defaultdict(default_value, [(\"a\", 11), (\"b\", 22)]),\n+        )\n+\n+        # Keras tracking wrappers.\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                TrackedList([]),\n+                TrackedList([]),\n+            ),\n+            TrackedList([]),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                TrackedList([1]),\n+                TrackedList([10]),\n+            ),\n+            TrackedList([11]),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                TrackedList([1, 2]),\n+                TrackedList([10, 20]),\n+            ),\n+            TrackedList([11, 22]),\n+        )\n+\n+        # Known limitation of the dm-tree implementation:\n+        # Registered classes are not handled when mapping multiple\n+        # structures at once. TrackedSet is the only problematic one.\n+        if not self.is_dmtree(t):\n+            self.assertEqualStrict(\n+                t.map_structure(\n+                    f2,\n+                    TrackedSet([]),\n+                    TrackedSet([]),\n+                ),\n+                TrackedSet([]),\n+            )\n+            self.assertEqualStrict(\n+                t.map_structure(\n+                    f2,\n+                    TrackedSet([1]),\n+                    TrackedSet([10]),\n+                ),\n+                TrackedSet([11]),\n+            )\n+            self.assertEqualStrict(\n+                t.map_structure(\n+                    f2,\n+                    TrackedSet([1, 2]),\n+                    TrackedSet([10, 20]),\n+                ),\n+                TrackedSet([11, 22]),\n+            )\n+\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                TrackedDict({}),\n+                TrackedDict({}),\n+            ),\n+            TrackedDict({}),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                TrackedDict({\"a\": 1}),\n+                TrackedDict({\"a\": 10}),\n+            ),\n+            TrackedDict({\"a\": 11}),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                TrackedDict({\"b\": 2, \"a\": 1}),\n+                TrackedDict({\"a\": 10, \"b\": 20}),\n+            ),\n+            TrackedDict({\"a\": 11, \"b\": 22}),\n+        )\n+\n+        # Deeper nested structures.\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                (\n+                    {\"b\": [2, 3], \"a\": (1,)},\n+                    TrackedDict({\"x\": 4, \"y\": TrackedList([5, 6])}),\n+                    TrackedSet([7]),\n+                    Point(y=9, x=8),\n+                    np.array([10]),\n+                ),\n+                (\n+                    {\"b\": [20, 30], \"a\": (10,)},\n+                    TrackedDict({\"x\": 40, \"y\": TrackedList([50, 60])}),\n+                    TrackedSet([70]),\n+                    Point(y=90, x=80),\n+                    np.array([100]),\n+                ),\n+            ),\n+            (\n+                {\"b\": [22, 33], \"a\": (11,)},\n+                TrackedDict({\"x\": 44, \"y\": TrackedList([55, 66])}),\n+                # Known limitation of the dm-tree implementation:\n+                # Registered classes are not handled when mapping multiple\n+                # structures at once. TrackedSet is the only problematic one.\n+                None if self.is_dmtree(t) else TrackedSet([77]),\n+                Point(y=99, x=88),\n+                None,\n+            ),\n+        )\n+\n+        # Error cases.\n+\n+        # list, tuple, deque and namedtuple are not considered equivalent.\n+        # Test all 6 combinations:\n+        # tuple, list.\n+        with self.assertRaisesRegex(ValueError, \"tuple\"):\n+            t.map_structure(f2, (), [])\n+        # tuple, deque.\n+        with self.assertRaisesRegex(ValueError, \"tuple\"):\n+            t.map_structure(f2, (), deque())\n+        # tuple, namedtuple.\n+        with self.assertRaisesRegex(ValueError, \"tuple\"):\n+            t.map_structure(f2, (), Empty())\n+        # list, deque.\n+        with self.assertRaisesRegex(ValueError, \"list\"):\n+            t.map_structure(f2, [], deque())\n+        # list, namedtuple.\n+        with self.assertRaisesRegex(ValueError, \"list\"):\n+            t.map_structure(f2, [], Empty())\n+        # deque, namedtuple.\n+        with self.assertRaisesRegex(ValueError, \"deque\"):\n+            t.map_structure(f2, deque(), Empty())\n+\n+        # Equivalent namedtuples don't match.\n+        with self.assertRaisesRegex(ValueError, \"namedtuple\"):\n+            t.map_structure(f2, Point(x=1, y=2), OtherPoint(x=10, y=20))\n+\n+        # Mismatched counts.\n+        with self.assertRaisesRegex(ValueError, \"(number|[Aa]rity)\"):\n+            t.map_structure(f2, (1, 2), (1,))\n+        with self.assertRaisesRegex(ValueError, \"(number|[Aa]rity)\"):\n+            t.map_structure(f2, [1, 2], [1])\n+        with self.assertRaisesRegex(ValueError, \"(number|[Aa]rity)\"):\n+            t.map_structure(f2, deque([1, 2]), deque([1]))\n+\n+        # dict, OrderedDict, defaultdict are considered equivalent, but the\n+        # returned type is the first one. Test all 6 combinations (3 type\n+        # combinations plus the order).\n+        # dict, OrderedDict yields dict.\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2, {\"a\": 1, \"b\": 2}, OrderedDict([(\"b\", 20), (\"a\", 10)])\n+            ),\n+            {\"a\": 11, \"b\": 22},\n+        )\n+        # OrderedDict, dict yields OrderedDict with same order.\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                OrderedDict([(\"b\", 2), (\"a\", 1)]),\n+                {\"a\": 10, \"b\": 20},\n+            ),\n+            OrderedDict([(\"b\", 22), (\"a\", 11)]),\n+        )\n+        # dict, defaultdict yields dict.\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                {\"a\": 1, \"b\": 2},\n+                defaultdict(default_value, [(\"b\", 20), (\"a\", 10)]),\n+            ),\n+            {\"a\": 11, \"b\": 22},\n+        )\n+        # defaultdict, dict yields defaultdict.\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                defaultdict(default_value, [(\"b\", 2), (\"a\", 1)]),\n+                {\"a\": 10, \"b\": 20},\n+            ),\n+            defaultdict(default_value, [(\"a\", 11), (\"b\", 22)]),\n+        )\n+        # defaultdict, OrderedDict yields defaultdict.\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                defaultdict(default_value, [(\"a\", 1), (\"b\", 2)]),\n+                OrderedDict([(\"b\", 20), (\"a\", 10)]),\n+            ),\n+            defaultdict(default_value, [(\"a\", 11), (\"b\", 22)]),\n+        )\n+        # OrderedDict, defaultdict yields OrderedDict with same order.\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                OrderedDict([(\"b\", 2), (\"a\", 1)]),\n+                defaultdict(default_value, [(\"a\", 10), (\"b\", 20)]),\n+            ),\n+            OrderedDict([(\"b\", 22), (\"a\", 11)]),\n+        )\n+\n+        # Multiple OrderedDicts with same keys but different orders, the order\n+        # of the first one prevails.\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                OrderedDict([(\"b\", 2), (\"a\", 1)]),\n+                OrderedDict([(\"a\", 10), (\"b\", 20)]),\n+            ),\n+            OrderedDict([(\"b\", 22), (\"a\", 11)]),\n+        )\n+\n+        # Mismatched keys\n+        with self.assertRaisesRegex(ValueError, \"key\"):\n+            t.map_structure(f2, {\"a\": 1, \"b\": 2}, {\"a\": 1})\n+        with self.assertRaisesRegex(ValueError, \"key\"):\n+            t.map_structure(\n+                f2,\n+                defaultdict(default_value, [(\"a\", 1), (\"b\", 2)]),\n+                defaultdict(default_value, [(\"a\", 10)]),\n+            )\n+        with self.assertRaisesRegex(ValueError, \"key\"):\n+            t.map_structure(\n+                f2, OrderedDict([(\"a\", 1), (\"b\", 2)]), OrderedDict([(\"a\", 10)])\n+            )\n+\n+    @pytest.mark.skipif(backend.backend() != \"tensorflow\", reason=\"tf only\")\n+    def test_map_structure_with_multiple_structures_tf_wrappers(self, t):\n+        from tensorflow.python.trackable.data_structures import ListWrapper\n+        from tensorflow.python.trackable.data_structures import _DictWrapper\n+\n+        def f2(x, y):\n+            return x + y\n+\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                ListWrapper([]),\n+                ListWrapper([]),\n+            ),\n+            ListWrapper([]),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                ListWrapper([1]),\n+                ListWrapper([10]),\n+            ),\n+            ListWrapper([11]),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                ListWrapper([1, 2]),\n+                ListWrapper([10, 20]),\n+            ),\n+            ListWrapper([11, 22]),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                _DictWrapper({}),\n+                _DictWrapper({}),\n+            ),\n+            _DictWrapper({}),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                _DictWrapper({\"a\": 1}),\n+                _DictWrapper({\"a\": 10}),\n+            ),\n+            _DictWrapper({\"a\": 11}),\n+        )\n+        self.assertEqualStrict(\n+            t.map_structure(\n+                f2,\n+                _DictWrapper({\"b\": 2, \"a\": 1}),\n+                _DictWrapper({\"a\": 10, \"b\": 20}),\n+            ),\n+            _DictWrapper({\"a\": 11, \"b\": 22}),\n+        )\n+\n+    def test_map_structure_up_to(self, t):\n         # Named tuples.\n-        ab_tuple = collections.namedtuple(\"ab_tuple\", \"a, b\")\n-        op_tuple = collections.namedtuple(\"op_tuple\", \"add, mul\")\n-        inp_val = ab_tuple(a=2, b=3)\n-        inp_ops = ab_tuple(a=op_tuple(add=1, mul=2), b=op_tuple(add=2, mul=3))\n-        out = tree_impl.map_structure_up_to(\n-            inp_val,\n-            lambda val, ops: (val + ops.add) * ops.mul,\n-            inp_val,\n-            inp_ops,\n+        shallow = OtherPoint(x=2, y=3)\n+        deep = OtherPoint(x=Point(x=1, y=2), y=Point(x=2, y=3))\n+        out = t.map_structure_up_to(\n+            shallow,\n+            lambda a, b: (a + b.x) * b.y,\n+            shallow,\n+            deep,\n         )\n-        self.assertEqual(out.a, 6)\n-        self.assertEqual(out.b, 15)\n+        self.assertEqual(out.x, 6)\n+        self.assertEqual(out.y, 15)\n \n         # Lists.\n         data_list = [[2, 4, 6, 8], [[1, 3, 5, 7, 9], [3, 5, 7]]]\n         name_list = [\"evens\", [\"odds\", \"primes\"]]\n-        out = tree_impl.map_structure_up_to(\n+        out = t.map_structure_up_to(\n             name_list,\n             lambda name, sec: \"first_{}_{}\".format(len(sec), name),\n             name_list,\n@@ -207,178 +1104,1204 @@ class TreeTest(testing.TestCase):\n             out, [\"first_4_evens\", [\"first_5_odds\", \"first_3_primes\"]]\n         )\n \n-    def test_assert_same_structure(self, tree_impl, is_optree):\n-        assertion_message = (\n-            \"have the same structure\"\n-            if is_optree\n-            else \"have the same nested structure\"\n+    def test_assert_same_structure(self, t):\n+        # Non-nested.\n+        t.assert_same_structure(1, 10)\n+\n+        # Standard structures.\n+        t.assert_same_structure((), ())\n+        t.assert_same_structure((1,), (10,))\n+        t.assert_same_structure((1, 2), (10, 20))\n+        t.assert_same_structure([], [])\n+        t.assert_same_structure([1], [10])\n+        t.assert_same_structure([1, 2], [10, 20])\n+        t.assert_same_structure(deque([]), deque([]))\n+        t.assert_same_structure(deque([1]), deque([1]))\n+        t.assert_same_structure(deque([1, 2]), deque([10, 20]))\n+        t.assert_same_structure(Empty(), Empty())\n+        t.assert_same_structure(Point(y=1, x=2), Point(x=10, y=20))\n+        t.assert_same_structure({}, {})\n+        t.assert_same_structure({\"a\": 1}, {\"a\": 10})\n+        t.assert_same_structure({\"b\": 2, \"a\": 1}, {\"a\": 10, \"b\": 20})\n+        t.assert_same_structure(OrderedDict(), OrderedDict())\n+        t.assert_same_structure(\n+            OrderedDict([(\"a\", 1)]), OrderedDict([(\"a\", 10)])\n         )\n-        assertion_type_error = ValueError if is_optree else TypeError\n-        tree_impl.assert_same_structure(\n-            STRUCTURE1, STRUCTURE2, check_types=False\n+        t.assert_same_structure(\n+            OrderedDict([(\"b\", 1), (\"a\", 2)]),\n+            OrderedDict([(\"b\", 10), (\"a\", 20)]),\n         )\n-        tree_impl.assert_same_structure(\"abc\", 1.0, check_types=False)\n-        tree_impl.assert_same_structure(b\"abc\", 1.0, check_types=False)\n-        tree_impl.assert_same_structure(\"abc\", 1.0, check_types=False)\n-        tree_impl.assert_same_structure(\n-            bytearray(\"abc\", \"ascii\"), 1.0, check_types=False\n+        t.assert_same_structure(\n+            defaultdict(default_value), defaultdict(default_value)\n         )\n-        tree_impl.assert_same_structure(\n-            \"abc\", np.array([0, 1]), check_types=False\n+        t.assert_same_paths(\n+            defaultdict(default_value, [(\"a\", 1)]),\n+            defaultdict(default_value, [(\"a\", 10)]),\n+        )\n+        t.assert_same_paths(\n+            defaultdict(default_value, [(\"b\", 1), (\"a\", 2)]),\n+            defaultdict(default_value, [(\"a\", 10), (\"b\", 20)]),\n         )\n \n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.assert_same_structure(\n-                STRUCTURE1, STRUCTURE_DIFFERENT_NUM_ELEMENTS\n+        # Keras tracking wrappers.\n+        t.assert_same_structure(\n+            TrackedList([]),\n+            TrackedList([]),\n         )\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.assert_same_structure([0, 1], np.array([0, 1]))\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.assert_same_structure(0, [0, 1])\n-        with self.assertRaisesRegex(assertion_type_error, assertion_message):\n-            tree_impl.assert_same_structure((0, 1), [0, 1])\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.assert_same_structure(\n-                STRUCTURE1, STRUCTURE_DIFFERENT_NESTING\n+        t.assert_same_structure(\n+            TrackedList([1]),\n+            TrackedList([10]),\n         )\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.assert_same_structure([[3], 4], [3, [4]])\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.assert_same_structure({\"a\": 1}, {\"b\": 1})\n-        structure1_list = [[[1, 2], 3], 4, [5, 6]]\n-        with self.assertRaisesRegex(assertion_type_error, assertion_message):\n-            tree_impl.assert_same_structure(STRUCTURE1, structure1_list)\n-        tree_impl.assert_same_structure(\n-            STRUCTURE1, STRUCTURE2, check_types=False\n+        t.assert_same_structure(\n+            TrackedList([1, 2]),\n+            TrackedList([10, 20]),\n         )\n-        # dm-tree treat list and tuple only on type mismatch, but optree treat\n-        # them as structure mismatch.\n-        if is_optree:\n-            with self.assertRaisesRegex(\n-                assertion_type_error, assertion_message\n-            ):\n-                tree_impl.assert_same_structure(\n-                    STRUCTURE1, structure1_list, check_types=False\n+        t.assert_same_structure(\n+            TrackedSet([]),\n+            TrackedSet([]),\n         )\n-        else:\n-            tree_impl.assert_same_structure(\n-                STRUCTURE1, structure1_list, check_types=False\n+        t.assert_same_structure(\n+            TrackedSet([1]),\n+            TrackedSet([10]),\n+        )\n+        t.assert_same_structure(\n+            TrackedSet([1, 2]),\n+            TrackedSet([10, 20]),\n+        )\n+        t.assert_same_structure(\n+            TrackedDict({}),\n+            TrackedDict({}),\n+        )\n+        t.assert_same_structure(\n+            TrackedDict({\"a\": 1}),\n+            TrackedDict({\"a\": 10}),\n+        )\n+        t.assert_same_structure(\n+            TrackedDict({\"b\": 2, \"a\": 1}),\n+            TrackedDict({\"a\": 10, \"b\": 20}),\n         )\n \n-    def test_assert_same_paths(self, tree_impl, is_optree):\n-        assertion_message = \"don't have the same paths\"\n-\n-        tree_impl.assert_same_paths([0, 1], (0, 1))\n-        Point1 = collections.namedtuple(\"Point1\", [\"x\", \"y\"])\n-        Point2 = collections.namedtuple(\"Point2\", [\"x\", \"y\"])\n-        tree_impl.assert_same_paths(Point1(0, 1), Point2(0, 1))\n-\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.assert_same_paths(\n-                STRUCTURE1, STRUCTURE_DIFFERENT_NUM_ELEMENTS\n-            )\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.assert_same_paths([0, 1], np.array([0, 1]))\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.assert_same_paths(0, [0, 1])\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.assert_same_paths(STRUCTURE1, STRUCTURE_DIFFERENT_NESTING)\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.assert_same_paths([[3], 4], [3, [4]])\n-        with self.assertRaisesRegex(ValueError, assertion_message):\n-            tree_impl.assert_same_paths({\"a\": 1}, {\"b\": 1})\n-        structure1_list = [[[1, 2], 3], 4, [5, 6]]\n-        tree_impl.assert_same_paths(STRUCTURE1, structure1_list)\n-        tree_impl.assert_same_paths(STRUCTURE1, STRUCTURE2)\n-\n-    def test_pack_sequence_as(self, tree_impl, is_optree):\n-        structure = {\"key3\": \"\", \"key1\": \"\", \"key2\": \"\"}\n-        flat_sequence = [\"value1\", \"value2\", \"value3\"]\n-        self.assertEqual(\n-            tree_impl.pack_sequence_as(structure, flat_sequence),\n-            {\"key3\": \"value3\", \"key1\": \"value1\", \"key2\": \"value2\"},\n-        )\n-        structure = ((\"a\", \"b\"), (\"c\", \"d\", \"e\"), \"f\")\n-        flat_sequence = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n-        self.assertEqual(\n-            tree_impl.pack_sequence_as(structure, flat_sequence),\n-            ((1.0, 2.0), (3.0, 4.0, 5.0), 6.0),\n-        )\n-        structure = {\n-            \"key3\": {\"c\": (\"alpha\", \"beta\"), \"a\": (\"gamma\")},\n-            \"key1\": {\"e\": \"val1\", \"d\": \"val2\"},\n-        }\n-        flat_sequence = [\"val2\", \"val1\", 3.0, 1.0, 2.0]\n-        self.assertEqual(\n-            tree_impl.pack_sequence_as(structure, flat_sequence),\n-            {\n-                \"key3\": {\"c\": (1.0, 2.0), \"a\": 3.0},\n-                \"key1\": {\"e\": \"val1\", \"d\": \"val2\"},\n-            },\n-        )\n-        structure = [\"a\"]\n-        flat_sequence = [np.array([[1, 2], [3, 4]])]\n-        self.assertAllClose(\n-            tree_impl.pack_sequence_as(structure, flat_sequence),\n-            [np.array([[1, 2], [3, 4]])],\n-        )\n-        structure = [\"a\"]\n-        flat_sequence = [ops.ones([2, 2])]\n-        self.assertAllClose(\n-            tree_impl.pack_sequence_as(structure, flat_sequence),\n-            [ops.ones([2, 2])],\n-        )\n-\n-        with self.assertRaisesRegex(TypeError, \"Attempted to pack value:\"):\n-            structure = [\"a\"]\n-            flat_sequence = 1\n-            tree_impl.pack_sequence_as(structure, flat_sequence)\n-        with self.assertRaisesRegex(ValueError, \"The target structure is of\"):\n-            structure = \"a\"\n-            flat_sequence = [1, 2]\n-            tree_impl.pack_sequence_as(structure, flat_sequence)\n-\n-    def test_lists_to_tuples(self, tree_impl, is_optree):\n-        structure = [1, 2, 3]\n-        self.assertEqual(tree_impl.lists_to_tuples(structure), (1, 2, 3))\n-        structure = [[1], [2, 3]]\n-        self.assertEqual(tree_impl.lists_to_tuples(structure), ((1,), (2, 3)))\n-        structure = [[1], [2, [3]]]\n-        self.assertEqual(\n-            tree_impl.lists_to_tuples(structure), ((1,), (2, (3,)))\n-        )\n-\n-    def test_traverse(self, tree_impl, is_optree):\n-        # Lists to tuples\n-        structure = [(1, 2), [3], {\"a\": [4]}]\n-        self.assertEqual(\n-            ((1, 2), (3,), {\"a\": (4,)}),\n-            tree_impl.traverse(\n-                lambda x: tuple(x) if isinstance(x, list) else x,\n-                structure,\n-                top_down=False,\n+        # Deeper nested structures.\n+        t.assert_same_structure(\n+            (\n+                {\"b\": [2, 3], \"a\": (1,)},\n+                TrackedDict({\"x\": 4, \"y\": TrackedList([5, 6])}),\n+                TrackedSet([7]),\n+                Point(y=9, x=8),\n+                np.array([10]),\n+            ),\n+            (\n+                {\"b\": [20, 30], \"a\": (10,)},\n+                TrackedDict({\"x\": 40, \"y\": TrackedList([50, 60])}),\n+                TrackedSet([70]),\n+                Point(y=90, x=80),\n+                np.array([100]),\n             ),\n         )\n-        # EarlyTermination\n-        structure = [(1, [2]), [3, (4, 5, 6)]]\n-        visited = []\n \n-        def visit(x):\n-            visited.append(x)\n-            return \"X\" if isinstance(x, tuple) and len(x) > 2 else None\n+        # Error cases.\n \n-        output = tree_impl.traverse(visit, structure)\n-        self.assertEqual([(1, [2]), [3, \"X\"]], output)\n-        self.assertEqual(\n+        # Non-nested vs. nested.\n+        with self.assertRaisesRegex(ValueError, \"don't have the same nested\"):\n+            t.assert_same_structure(1, ())\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*tuple\"):\n+            t.assert_same_structure((), 1)\n+        with self.assertRaisesRegex(ValueError, \"don't have the same nested\"):\n+            t.assert_same_structure(1, [])\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*list\"):\n+            t.assert_same_structure([], 1)\n+        with self.assertRaisesRegex(ValueError, \"don't have the same nested\"):\n+            t.assert_same_structure(1, deque([]))\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*deque\"):\n+            t.assert_same_structure(deque([]), 1)\n+        with self.assertRaisesRegex(ValueError, \"don't have the same nested\"):\n+            t.assert_same_structure(1, Empty())\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*(Empty|tuple)\"):\n+            t.assert_same_structure(Empty(), 1)\n+        with self.assertRaisesRegex(ValueError, \"don't have the same nested\"):\n+            t.assert_same_structure(1, Point(x=1, y=2))\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*(Point|tuple)\"):\n+            t.assert_same_structure(Point(x=1, y=2), 1)\n+        with self.assertRaisesRegex(ValueError, \"don't have the same nested\"):\n+            t.assert_same_structure(1, {})\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*dict\"):\n+            t.assert_same_structure({}, 1)\n+        with self.assertRaisesRegex(ValueError, \"don't have the same nested\"):\n+            t.assert_same_structure(1, OrderedDict())\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*OrderedDict\"):\n+            t.assert_same_structure(OrderedDict(), 1)\n+        with self.assertRaisesRegex(ValueError, \"don't have the same nested\"):\n+            t.assert_same_structure(1, defaultdict(default_value))\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*defaultdict\"):\n+            t.assert_same_structure(defaultdict(default_value), 1)\n+\n+        # Non-nested vs. Keras tracking wrappers.\n+        with self.assertRaisesRegex(ValueError, \"(nested|TrackedList)\"):\n+            t.assert_same_structure(1, TrackedList([]))\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*TrackedList\"):\n+            t.assert_same_structure(TrackedList([]), 1)\n+        with self.assertRaisesRegex(ValueError, \"(nested|TrackedSet)\"):\n+            t.assert_same_structure(1, TrackedSet([]))\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*TrackedSet\"):\n+            t.assert_same_structure(TrackedSet([]), 1)\n+        with self.assertRaisesRegex(ValueError, \"(nested|TrackedDict)\"):\n+            t.assert_same_structure(1, TrackedDict([]))\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*TrackedDict\"):\n+            t.assert_same_structure(TrackedDict([]), 1)\n+\n+        # list, tuple, deque and namedtuple are not considered equivalent.\n+        # Test all 6 combinations:\n+        # tuple, list.\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*tuple\"):\n+            t.assert_same_structure((), [])\n+        # tuple, deque.\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*tuple\"):\n+            t.assert_same_structure((), deque())\n+        # tuple, namedtuple.\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*tuple\"):\n+            t.assert_same_structure((), Empty())\n+        # list, deque.\n+        with self.assertRaisesRegex(ValueError, \"list\"):\n+            t.assert_same_structure([], deque())\n+        # list, namedtuple.\n+        with self.assertRaisesRegex(ValueError, \"list\"):\n+            t.assert_same_structure([], Empty())\n+        # deque, namedtuple.\n+        with self.assertRaisesRegex(ValueError, \"deque\"):\n+            t.assert_same_structure(deque(), Empty())\n+\n+        # Equivalent namedtuples don't match.\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*[. ]Point\"):\n+            t.assert_same_structure(Point(x=1, y=2), OtherPoint(x=10, y=20))\n+\n+        # Mismatched counts.\n+        with self.assertRaisesRegex(ValueError, \"[Aa]rity mismatch\"):\n+            t.assert_same_structure((1, 2), (1,))\n+        with self.assertRaisesRegex(ValueError, \"[Aa]rity mismatch\"):\n+            t.assert_same_structure([1, 2], [1])\n+        with self.assertRaisesRegex(ValueError, \"[Aa]rity mismatch\"):\n+            t.assert_same_structure(deque([1, 2]), deque([1]))\n+\n+        # Mismatched counts with Keras tracking wrappers.\n+        with self.assertRaisesRegex(ValueError, \"[Aa]rity mismatch\"):\n+            t.assert_same_structure(TrackedList([1, 2]), TrackedList([1]))\n+        with self.assertRaisesRegex(ValueError, \"[Aa]rity mismatch\"):\n+            t.assert_same_structure(TrackedSet([1, 2]), TrackedSet([1]))\n+\n+        # dict, OrderedDict, defaultdict are considered equivalent.\n+        # Test all 6 combinations (3 type combinations plus the order).\n+        # dict, OrderedDict.\n+        t.assert_same_structure(\n+            {\"a\": 1, \"b\": 2}, OrderedDict([(\"b\", 20), (\"a\", 10)])\n+        )\n+        # OrderedDict, dict.\n+        t.assert_same_structure(\n+            OrderedDict([(\"b\", 20), (\"a\", 10)]), {\"a\": 1, \"b\": 2}\n+        )\n+        # dict, defaultdict.\n+        t.assert_same_structure(\n+            {\"a\": 1, \"b\": 2},\n+            defaultdict(default_value, [(\"b\", 20), (\"a\", 10)]),\n+        )\n+        # defaultdict, dict.\n+        t.assert_same_structure(\n+            defaultdict(default_value, [(\"b\", 20), (\"a\", 10)]),\n+            {\"a\": 1, \"b\": 2},\n+        )\n+        # defaultdict, OrderedDict.\n+        t.assert_same_structure(\n+            defaultdict(default_value, [(\"a\", 1), (\"b\", 2)]),\n+            OrderedDict([(\"b\", 20), (\"a\", 10)]),\n+        )\n+        # OrderedDict, defaultdict.\n+        t.assert_same_structure(\n+            OrderedDict([(\"b\", 2), (\"a\", 1)]),\n+            defaultdict(default_value, [(\"a\", 10), (\"b\", 20)]),\n+        )\n+\n+        # Two OrderedDicts with same keys but different orders.\n+        t.assert_same_structure(\n+            OrderedDict([(\"b\", 2), (\"a\", 1)]),\n+            OrderedDict([(\"a\", 10), (\"b\", 20)]),\n+        )\n+\n+        # Keras tracking wrappers are not equivalent to the raw structures.\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*TrackedList\"):\n+            t.assert_same_structure(TrackedList([1, 2]), list([10, 20]))\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*list\"):\n+            t.assert_same_structure(list([1, 2]), TrackedList([10, 20]))\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*TrackedSet\"):\n+            t.assert_same_structure(TrackedSet([1, 2]), list([10, 20]))\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*list\"):\n+            t.assert_same_structure(list([1, 2]), TrackedSet([10, 20]))\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*TrackedDict\"):\n+            t.assert_same_structure(\n+                TrackedDict({\"b\": 2, \"a\": 1}), {\"a\": 10, \"b\": 20}\n+            )\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*dict\"):\n+            t.assert_same_structure(\n+                {\"b\": 2, \"a\": 1}, TrackedDict({\"a\": 10, \"b\": 20})\n+            )\n+\n+        # Mismatched key count.\n+        with self.assertRaisesRegex(ValueError, \"[Dd]ictionary key mismatch\"):\n+            t.assert_same_structure(\n+                {\"a\": 1, \"b\": 2},\n+                {\"a\": 1},\n+            )\n+        with self.assertRaisesRegex(ValueError, \"[Dd]ictionary key mismatch\"):\n+            t.assert_same_structure(\n+                defaultdict(default_value, [(\"a\", 1), (\"b\", 2)]),\n+                defaultdict(default_value, [(\"a\", 10)]),\n+            )\n+        with self.assertRaisesRegex(ValueError, \"[Dd]ictionary key mismatch\"):\n+            t.assert_same_structure(\n+                OrderedDict([(\"a\", 1), (\"b\", 2)]),\n+                OrderedDict([(\"a\", 10)]),\n+            )\n+\n+        # Mismatched keys.\n+        with self.assertRaisesRegex(ValueError, \"[Dd]ictionary key mismatch\"):\n+            t.assert_same_structure(\n+                {\"a\": 1},\n+                {\"b\": 2},\n+            )\n+        with self.assertRaisesRegex(ValueError, \"[Dd]ictionary key mismatch\"):\n+            t.assert_same_structure(\n+                defaultdict(default_value, [(\"a\", 1)]),\n+                defaultdict(default_value, [(\"b\", 2)]),\n+            )\n+        with self.assertRaisesRegex(ValueError, \"[Dd]ictionary key mismatch\"):\n+            t.assert_same_structure(\n+                OrderedDict([(\"a\", 1)]),\n+                OrderedDict([(\"b\", 2)]),\n+            )\n+\n+        # Mismatched key count and keys with TrackedDict.\n+        with self.assertRaisesRegex(ValueError, \"Mismatch custom node data\"):\n+            t.assert_same_structure(\n+                TrackedDict({\"a\": 1, \"b\": 2}),\n+                TrackedDict({\"a\": 1}),\n+            )\n+        with self.assertRaisesRegex(ValueError, \"Mismatch custom node data\"):\n+            t.assert_same_structure(\n+                TrackedDict({\"a\": 1}),\n+                TrackedDict({\"b\": 2}),\n+            )\n+\n+    @pytest.mark.skipif(backend.backend() != \"tensorflow\", reason=\"tf only\")\n+    def test_assert_same_structure_tf_wrappers(self, t):\n+        from tensorflow.python.trackable.data_structures import ListWrapper\n+        from tensorflow.python.trackable.data_structures import _DictWrapper\n+\n+        t.assert_same_structure(ListWrapper([]), ListWrapper([]))\n+        t.assert_same_structure(ListWrapper([1]), ListWrapper([10]))\n+        t.assert_same_structure(ListWrapper([1, 2]), ListWrapper([10, 20]))\n+        t.assert_same_structure(_DictWrapper(), _DictWrapper())\n+        t.assert_same_structure(_DictWrapper({\"a\": 1}), _DictWrapper({\"a\": 11}))\n+        t.assert_same_structure(\n+            _DictWrapper({\"b\": 2, \"a\": 1}), _DictWrapper({\"a\": 11, \"b\": 12})\n+        )\n+\n+        # Count and key mismatch\n+        with self.assertRaisesRegex(ValueError, \"[Aa]rity mismatch\"):\n+            t.assert_same_structure(ListWrapper([1, 2]), ListWrapper([1]))\n+        with self.assertRaisesRegex(ValueError, \"Mismatch custom node data\"):\n+            t.assert_same_structure(\n+                _DictWrapper({\"a\": 1, \"b\": 2}),\n+                _DictWrapper({\"a\": 1}),\n+            )\n+        with self.assertRaisesRegex(ValueError, \"Mismatch custom node data\"):\n+            t.assert_same_structure(\n+                _DictWrapper({\"a\": 1}),\n+                _DictWrapper({\"b\": 2}),\n+            )\n+\n+        # Tensorflow wrappers are not equivalent to the raw structures.\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*ListWrapper\"):\n+            t.assert_same_structure(ListWrapper([1, 2]), list([10, 20]))\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*list\"):\n+            t.assert_same_structure(list([1, 2]), ListWrapper([10, 20]))\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*_DictWrapper\"):\n+            t.assert_same_structure(\n+                _DictWrapper({\"b\": 2, \"a\": 1}), {\"a\": 10, \"b\": 20}\n+            )\n+        with self.assertRaisesRegex(ValueError, \"[Ee]xpected.*dict\"):\n+            t.assert_same_structure(\n+                {\"b\": 2, \"a\": 1}, _DictWrapper({\"a\": 10, \"b\": 20})\n+            )\n+\n+    def test_assert_same_paths(self, t):\n+        # Non-nested.\n+        t.assert_same_paths(1, 10)\n+\n+        # Standard structures.\n+        t.assert_same_paths((), ())\n+        t.assert_same_paths((1,), (10,))\n+        t.assert_same_paths((1, 2), (10, 20))\n+        t.assert_same_paths([], [])\n+        t.assert_same_paths([1], [10])\n+        t.assert_same_paths([1, 2], [10, 20])\n+        t.assert_same_paths(deque([]), deque([]))\n+        t.assert_same_paths(deque([1]), deque([10]))\n+        t.assert_same_paths(deque([1, 2]), deque([10, 20]))\n+        t.assert_same_paths(Empty(), Empty())\n+        t.assert_same_paths(Point(y=2, x=1), Point(x=10, y=20))\n+        t.assert_same_paths({}, {})\n+        t.assert_same_paths({\"a\": 1}, {\"a\": 10})\n+        t.assert_same_paths({\"b\": None, \"a\": None}, {\"a\": 10, \"b\": 20})\n+        t.assert_same_paths(OrderedDict(), OrderedDict())\n+        t.assert_same_paths(OrderedDict([(\"a\", 1)]), OrderedDict([(\"a\", 10)]))\n+        t.assert_same_paths(\n+            OrderedDict([(\"b\", 2), (\"a\", 1)]),\n+            OrderedDict([(\"a\", 10), (\"b\", 20)]),\n+        )\n+        t.assert_same_paths(\n+            defaultdict(default_value), defaultdict(default_value)\n+        )\n+        t.assert_same_paths(\n+            defaultdict(default_value, [(\"a\", 1)]),\n+            defaultdict(default_value, [(\"a\", 10)]),\n+        )\n+        t.assert_same_paths(\n+            defaultdict(default_value, [(\"b\", 2), (\"a\", 1)]),\n+            defaultdict(default_value, [(\"a\", 1), (\"b\", 2)]),\n+        )\n+\n+        # Keras tracking wrappers.\n+        t.assert_same_paths(\n+            TrackedList([]),\n+            TrackedList([]),\n+        )\n+        t.assert_same_paths(\n+            TrackedList([1]),\n+            TrackedList([10]),\n+        )\n+        t.assert_same_paths(\n+            TrackedList([1, 2]),\n+            TrackedList([10, 20]),\n+        )\n+        t.assert_same_paths(\n+            TrackedSet([]),\n+            TrackedSet([]),\n+        )\n+        t.assert_same_paths(\n+            TrackedSet([1]),\n+            TrackedSet([10]),\n+        )\n+        t.assert_same_paths(\n+            TrackedSet([1, 2]),\n+            TrackedSet([10, 20]),\n+        )\n+        t.assert_same_paths(\n+            TrackedDict({}),\n+            TrackedDict({}),\n+        )\n+        t.assert_same_paths(\n+            TrackedDict({\"a\": 1}),\n+            TrackedDict({\"a\": 10}),\n+        )\n+        t.assert_same_paths(\n+            TrackedDict({\"b\": 2, \"a\": 1}),\n+            TrackedDict({\"a\": 10, \"b\": 20}),\n+        )\n+\n+        # Deeper nested structures.\n+        t.assert_same_paths(\n+            (\n+                {\"b\": [2, 3], \"a\": (1,)},\n+                TrackedDict({\"x\": 4, \"y\": TrackedList([5, 6])}),\n+                TrackedSet([7]),\n+                Point(y=9, x=8),\n+                np.array([10]),\n+            ),\n+            (\n+                {\"b\": [20, 30], \"a\": (10,)},\n+                TrackedDict({\"x\": 40, \"y\": TrackedList([50, 60])}),\n+                TrackedSet([70]),\n+                Point(y=90, x=80),\n+                np.array([100]),\n+            ),\n+        )\n+\n+        # list, tuple, deque and namedtuple have the same paths.\n+        # Test all 6 combinations:\n+        # tuple, list.\n+        t.assert_same_paths((), [])\n+        t.assert_same_paths([1, 2], (10, 20))\n+        # tuple, deque.\n+        t.assert_same_paths((), deque())\n+        t.assert_same_paths(deque([1, 2]), (10, 20))\n+        # tuple, namedtuple.\n+        t.assert_same_paths((), Empty())\n+        t.assert_same_paths(Point(x=1, y=2), (10, 20))\n+        # list, deque.\n+        t.assert_same_paths([], deque())\n+        t.assert_same_paths(deque([1, 2]), [10, 20])\n+        # list, namedtuple.\n+        t.assert_same_paths([], Empty())\n+        t.assert_same_paths(Point(x=None, y=20), [1, 2])\n+        # deque, namedtuple.\n+        t.assert_same_paths(deque(), Empty())\n+        t.assert_same_paths(Point(x=None, y=20), deque([1, 2]))\n+\n+        # Equivalent namedtuples.\n+        t.assert_same_paths(Point(x=1, y=2), OtherPoint(x=None, y=20))\n+\n+        # Mismatched counts.\n+        with self.assertRaisesRegex(ValueError, \"don't have the same paths\"):\n+            t.assert_same_paths((1, 2), (1,))\n+        with self.assertRaisesRegex(ValueError, \"don't have the same paths\"):\n+            t.assert_same_paths([1, 2], [1])\n+        with self.assertRaisesRegex(ValueError, \"don't have the same paths\"):\n+            t.assert_same_paths(deque([1, 2]), deque([1]))\n+\n+        # dict, OrderedDict, defaultdict are considered equivalent. Test all 6\n+        # combinations (3 type combinations plus the order).\n+        # dict, OrderedDict.\n+        t.assert_same_paths(\n+            {\"a\": 1, \"b\": 2}, OrderedDict([(\"b\", 20), (\"a\", 10)])\n+        )\n+        # OrderedDict, dict.\n+        t.assert_same_paths(\n+            OrderedDict([(\"b\", 20), (\"a\", 10)]), {\"a\": 1, \"b\": 2}\n+        )\n+        # dict, defaultdict.\n+        t.assert_same_paths(\n+            {\"a\": 1, \"b\": 2},\n+            defaultdict(default_value, [(\"b\", 20), (\"a\", 10)]),\n+        )\n+        # defaultdict, dict.\n+        t.assert_same_paths(\n+            defaultdict(default_value, [(\"b\", 20), (\"a\", 10)]),\n+            {\"a\": 1, \"b\": 2},\n+        )\n+        # defaultdict, OrderedDict.\n+        t.assert_same_paths(\n+            defaultdict(default_value, [(\"a\", 1), (\"b\", 2)]),\n+            OrderedDict([(\"b\", 20), (\"a\", 10)]),\n+        )\n+        # OrderedDict, defaultdict.\n+        t.assert_same_paths(\n+            OrderedDict([(\"b\", 2), (\"a\", 1)]),\n+            defaultdict(default_value, [(\"a\", 10), (\"b\", 20)]),\n+        )\n+\n+        # Two OrderedDicts with same keys but different orders.\n+        t.assert_same_paths(\n+            OrderedDict([(\"b\", 2), (\"a\", 1)]),\n+            OrderedDict([(\"a\", 10), (\"b\", 20)]),\n+        )\n+\n+        # Keras tracking wrappers are equivalent to the raw structures.\n+        t.assert_same_paths(TrackedList([1, 2]), list([10, 20]))\n+        t.assert_same_paths(list([1, 2]), TrackedList([10, 20]))\n+        t.assert_same_paths(TrackedSet([1, 2]), list([10, 20]))\n+        t.assert_same_paths(list([1, 2]), TrackedSet([10, 20]))\n+        t.assert_same_paths(TrackedDict({\"b\": 2, \"a\": 1}), {\"a\": 10, \"b\": 20})\n+        t.assert_same_paths({\"b\": 2, \"a\": 1}, TrackedDict({\"a\": 10, \"b\": 20}))\n+\n+        # Mismatched keys\n+        with self.assertRaisesRegex(ValueError, \"don't have the same paths\"):\n+            t.assert_same_paths({\"a\": 1, \"b\": 2}, {\"a\": 1})\n+        with self.assertRaisesRegex(ValueError, \"don't have the same paths\"):\n+            t.assert_same_paths(\n+                defaultdict(default_value, [(\"a\", 1), (\"b\", 2)]),\n+                defaultdict(default_value, [(\"a\", 10)]),\n+            )\n+        with self.assertRaisesRegex(ValueError, \"don't have the same paths\"):\n+            t.assert_same_paths(\n+                OrderedDict([(\"a\", 1), (\"b\", 2)]), OrderedDict([(\"a\", 10)])\n+            )\n+\n+    @pytest.mark.skipif(backend.backend() != \"tensorflow\", reason=\"tf only\")\n+    def test_assert_same_paths_tf_wrappers(self, t):\n+        from tensorflow.python.trackable.data_structures import ListWrapper\n+        from tensorflow.python.trackable.data_structures import _DictWrapper\n+\n+        t.assert_same_paths(ListWrapper([]), ListWrapper([]))\n+        t.assert_same_paths(ListWrapper([1]), ListWrapper([10]))\n+        t.assert_same_paths(ListWrapper([1, 2]), ListWrapper([10, 20]))\n+        t.assert_same_paths(_DictWrapper(), _DictWrapper())\n+        t.assert_same_paths(_DictWrapper({\"a\": 1}), _DictWrapper({\"a\": 11}))\n+        t.assert_same_paths(\n+            _DictWrapper({\"b\": 2, \"a\": 1}), _DictWrapper({\"a\": 11, \"b\": 12})\n+        )\n+\n+        # Tensorflow wrappers are equivalent to the raw structures.\n+        t.assert_same_paths(ListWrapper([1, 2]), list([10, 20]))\n+        t.assert_same_paths(list([1, 2]), ListWrapper([10, 20]))\n+        t.assert_same_paths(_DictWrapper({\"b\": 2, \"a\": 1}), {\"a\": 10, \"b\": 20})\n+        t.assert_same_paths({\"b\": 2, \"a\": 1}, _DictWrapper({\"a\": 10, \"b\": 20}))\n+\n+    def test_traverse_top_down(self, t):\n+        v = Visitor(lambda x: None if t.is_nested(x) else x + 10)\n+\n+        # Non-nested.\n+        self.assertEqualStrict(t.traverse(v, 1), 11)\n+        self.assertEqualStrict(v.visited(), [1])\n+\n+        # Standard structures.\n+        self.assertEqualStrict(t.traverse(v, ()), ())\n+        self.assertEqualStrict(v.visited(), [()])\n+\n+        self.assertEqualStrict(t.traverse(v, (1,)), (11,))\n+        self.assertEqualStrict(v.visited(), [(1,), 1])\n+\n+        self.assertEqualStrict(t.traverse(v, (1, 2)), (11, 12))\n+        self.assertEqualStrict(v.visited(), [(1, 2), 1, 2])\n+\n+        self.assertEqualStrict(t.traverse(v, []), [])\n+        self.assertEqualStrict(v.visited(), [[]])\n+\n+        self.assertEqualStrict(t.traverse(v, [1]), [11])\n+        self.assertEqualStrict(v.visited(), [[1], 1])\n+\n+        self.assertEqualStrict(t.traverse(v, [1, 2]), [11, 12])\n+        self.assertEqualStrict(v.visited(), [[1, 2], 1, 2])\n+\n+        self.assertEqualStrict(t.traverse(v, deque([])), deque([]))\n+        self.assertEqualStrict(v.visited(), [deque([])])\n+\n+        self.assertEqualStrict(t.traverse(v, deque([1])), deque([11]))\n+        self.assertEqualStrict(v.visited(), [deque([1]), 1])\n+\n+        self.assertEqualStrict(t.traverse(v, deque([1, 2])), deque([11, 12]))\n+        self.assertEqualStrict(v.visited(), [deque([1, 2]), 1, 2])\n+\n+        self.assertEqualStrict(t.traverse(v, Empty()), Empty())\n+        self.assertEqualStrict(v.visited(), [Empty()])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, Point(y=2, x=1)), Point(x=11, y=12)\n+        )\n+        self.assertEqualStrict(v.visited(), [Point(x=1, y=2), 1, 2])\n+\n+        self.assertEqualStrict(t.traverse(v, {}), {})\n+        self.assertEqualStrict(v.visited(), [{}])\n+\n+        self.assertEqualStrict(t.traverse(v, {\"a\": 1}), {\"a\": 11})\n+        self.assertEqualStrict(v.visited(), [{\"a\": 1}, 1])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, {\"b\": 2, \"a\": 1}), {\"a\": 11, \"b\": 12}\n+        )\n+        self.assertEqualStrict(v.visited(), [{\"a\": 1, \"b\": 2}, 1, 2])\n+\n+        self.assertEqualStrict(t.traverse(v, OrderedDict()), OrderedDict())\n+        self.assertEqualStrict(v.visited(), [OrderedDict()])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, OrderedDict([(\"a\", 1)])), OrderedDict([(\"a\", 11)])\n+        )\n+        self.assertEqualStrict(v.visited(), [OrderedDict([(\"a\", 1)]), 1])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, OrderedDict([(\"b\", 2), (\"a\", 1)])),\n+            OrderedDict([(\"b\", 12), (\"a\", 11)]),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(), [OrderedDict([(\"b\", 2), (\"a\", 1)]), 2, 1]\n+        )\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, defaultdict(default_value)),\n+            defaultdict(default_value),\n+        )\n+        self.assertEqualStrict(v.visited(), [defaultdict(default_value)])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, defaultdict(default_value, [(\"a\", 1)])),\n+            defaultdict(default_value, [(\"a\", 11)]),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(), [defaultdict(default_value, [(\"a\", 1)]), 1]\n+        )\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, defaultdict(default_value, [(\"b\", 2), (\"a\", 1)])),\n+            defaultdict(default_value, [(\"a\", 11), (\"b\", 12)]),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(),\n+            [defaultdict(default_value, [(\"a\", 1), (\"b\", 2)]), 1, 2],\n+        )\n+\n+        # Keras tracking wrappers.\n+        self.assertEqualStrict(t.traverse(v, TrackedList([])), TrackedList([]))\n+        self.assertEqualStrict(v.visited(), [TrackedList([])])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, TrackedList([1])), TrackedList([11])\n+        )\n+        self.assertEqualStrict(v.visited(), [TrackedList([1]), 1])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, TrackedList([1, 2])), TrackedList([11, 12])\n+        )\n+        self.assertEqualStrict(v.visited(), [TrackedList([1, 2]), 1, 2])\n+\n+        self.assertEqualStrict(t.traverse(v, TrackedSet([])), TrackedSet([]))\n+        self.assertEqualStrict(v.visited(), [TrackedSet([])])\n+\n+        self.assertEqualStrict(t.traverse(v, TrackedSet([1])), TrackedSet([11]))\n+        self.assertEqualStrict(v.visited(), [TrackedSet([1]), 1])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, TrackedSet([1, 2])), TrackedSet([11, 12])\n+        )\n+        visited = v.visited()\n+        self.assertEqualStrict(visited[0], TrackedSet([1, 2]))\n+        self.assertEqualStrict(sorted(visited[1:]), [1, 2])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, TrackedDict()),\n+            TrackedDict(),\n+        )\n+        self.assertEqualStrict(v.visited(), [TrackedDict()])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, TrackedDict({\"a\": 1})),\n+            TrackedDict({\"a\": 11}),\n+        )\n+        self.assertEqualStrict(v.visited(), [TrackedDict({\"a\": 1}), 1])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, TrackedDict({\"b\": 2, \"a\": 1})),\n+            TrackedDict({\"a\": 11, \"b\": 12}),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(), [TrackedDict({\"a\": 1, \"b\": 2}), 1, 2]\n+        )\n+\n+        # Deeper nested structures.\n+        self.assertEqualStrict(\n+            t.traverse(\n+                v,\n+                (\n+                    {\"b\": [2, 3], \"a\": (1,)},\n+                    TrackedDict({\"x\": 4, \"y\": TrackedList([5, 6])}),\n+                    TrackedSet([7]),\n+                    Point(y=9, x=8),\n+                    np.array([10]),\n+                ),\n+            ),\n+            (\n+                {\"b\": [12, 13], \"a\": (11,)},\n+                TrackedDict({\"x\": 14, \"y\": TrackedList([15, 16])}),\n+                TrackedSet([17]),\n+                Point(y=19, x=18),\n+                np.array([20]),\n+            ),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(),\n+            [\n+                (\n+                    {\"b\": [2, 3], \"a\": (1,)},\n+                    TrackedDict({\"x\": 4, \"y\": TrackedList([5, 6])}),\n+                    TrackedSet([7]),\n+                    Point(y=9, x=8),\n+                    np.array([10]),\n+                ),\n+                {\"b\": [2, 3], \"a\": (1,)},\n+                (1,),\n+                1,\n+                [2, 3],\n+                2,\n+                3,\n+                TrackedDict({\"x\": 4, \"y\": TrackedList([5, 6])}),\n+                4,\n+                TrackedList([5, 6]),\n+                5,\n+                6,\n+                TrackedSet([7]),\n+                7,\n+                Point(x=8, y=9),\n+                8,\n+                9,\n+                np.array([10]),\n+            ],\n+        )\n+\n+        # Error cases.\n+        with self.assertRaisesRegex(TypeError, \"callable\"):\n+            t.traverse(\"bad\", [1, 2])\n+\n+        # Children are not explored if structure is replaced with a leaf.\n+        v = Visitor(lambda x: \"X\" if isinstance(x, tuple) else None)\n+        self.assertEqualStrict(\n+            t.traverse(v, [(1, [2]), [3, (4, 5, 6)]]),\n+            [\"X\", [3, \"X\"]],\n+        )\n+        self.assertEqualStrict(\n+            v.visited(),\n             [\n                 [(1, [2]), [3, (4, 5, 6)]],\n                 (1, [2]),\n-                1,\n-                [2],\n-                2,\n                 [3, (4, 5, 6)],\n                 3,\n                 (4, 5, 6),\n             ],\n-            visited,\n+        )\n+\n+        # Children are not explored if structure is replaced with structure.\n+        v = Visitor(lambda x: (\"a\", \"b\") if isinstance(x, tuple) else None)\n+        self.assertEqualStrict(\n+            t.traverse(v, [(1, [2]), [3, (4, 5, 6)]]),\n+            [(\"a\", \"b\"), [3, (\"a\", \"b\")]],\n+        )\n+        self.assertEqualStrict(\n+            v.visited(),\n+            [\n+                [(1, [2]), [3, (4, 5, 6)]],\n+                (1, [2]),\n+                [3, (4, 5, 6)],\n+                3,\n+                (4, 5, 6),\n+            ],\n+        )\n+\n+        # MAP_TO_NONE.\n+        v = Visitor(lambda x: MAP_TO_NONE if isinstance(x, tuple) else None)\n+        self.assertEqualStrict(\n+            t.traverse(v, [(1, [2]), [3, (4, 5, 6)]]),\n+            [None, [3, None]],\n+        )\n+        self.assertEqualStrict(\n+            v.visited(),\n+            [\n+                [(1, [2]), [3, (4, 5, 6)]],\n+                (1, [2]),\n+                [3, (4, 5, 6)],\n+                3,\n+                (4, 5, 6),\n+            ],\n+        )\n+\n+    @pytest.mark.skipif(backend.backend() != \"tensorflow\", reason=\"tf only\")\n+    def test_traverse_top_down_tf_wrappers(self, t):\n+        from tensorflow.python.trackable.data_structures import ListWrapper\n+        from tensorflow.python.trackable.data_structures import _DictWrapper\n+\n+        v = Visitor(lambda x: None if t.is_nested(x) else x + 10)\n+\n+        self.assertEqualStrict(t.traverse(v, ListWrapper([])), ListWrapper([]))\n+        self.assertEqualStrict(v.visited(), [ListWrapper([])])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, ListWrapper([1])), ListWrapper([11])\n+        )\n+        self.assertEqualStrict(v.visited(), [ListWrapper([1]), 1])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, ListWrapper([1, 2])), ListWrapper([11, 12])\n+        )\n+        self.assertEqualStrict(v.visited(), [ListWrapper([1, 2]), 1, 2])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, _DictWrapper()),\n+            _DictWrapper(),\n+        )\n+        self.assertEqualStrict(v.visited(), [_DictWrapper()])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, _DictWrapper({\"a\": 1})),\n+            _DictWrapper({\"a\": 11}),\n+        )\n+        self.assertEqualStrict(v.visited(), [_DictWrapper({\"a\": 1}), 1])\n+\n+        self.assertEqualStrict(\n+            t.traverse(v, _DictWrapper({\"b\": 2, \"a\": 1})),\n+            _DictWrapper({\"a\": 11, \"b\": 12}),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(), [_DictWrapper({\"a\": 1, \"b\": 2}), 1, 2]\n+        )\n+\n+    def test_traverse_bottom_up(self, t):\n+        v = Visitor(lambda x: None if t.is_nested(x) else x + 10)\n+        traverse_u = functools.partial(t.traverse, top_down=False)\n+\n+        # Non-nested.\n+        self.assertEqualStrict(traverse_u(v, 1), 11)\n+        self.assertEqualStrict(v.visited(), [1])\n+\n+        # Standard structures.\n+        self.assertEqualStrict(traverse_u(v, ()), ())\n+        self.assertEqualStrict(v.visited(), [()])\n+\n+        self.assertEqualStrict(traverse_u(v, (1,)), (11,))\n+        self.assertEqualStrict(v.visited(), [1, (11,)])\n+\n+        self.assertEqualStrict(traverse_u(v, (1, 2)), (11, 12))\n+        self.assertEqualStrict(v.visited(), [1, 2, (11, 12)])\n+\n+        self.assertEqualStrict(traverse_u(v, []), [])\n+        self.assertEqualStrict(v.visited(), [[]])\n+\n+        self.assertEqualStrict(traverse_u(v, [1]), [11])\n+        self.assertEqualStrict(v.visited(), [1, [11]])\n+\n+        self.assertEqualStrict(traverse_u(v, [1, 2]), [11, 12])\n+        self.assertEqualStrict(v.visited(), [1, 2, [11, 12]])\n+\n+        self.assertEqualStrict(traverse_u(v, deque([])), deque([]))\n+        self.assertEqualStrict(v.visited(), [deque([])])\n+\n+        self.assertEqualStrict(traverse_u(v, deque([1])), deque([11]))\n+        self.assertEqualStrict(v.visited(), [1, deque([11])])\n+\n+        self.assertEqualStrict(traverse_u(v, deque([1, 2])), deque([11, 12]))\n+        self.assertEqualStrict(v.visited(), [1, 2, deque([11, 12])])\n+\n+        self.assertEqualStrict(traverse_u(v, Empty()), Empty())\n+        self.assertEqualStrict(v.visited(), [Empty()])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, Point(y=2, x=1)), Point(x=11, y=12)\n+        )\n+        self.assertEqualStrict(v.visited(), [1, 2, Point(x=11, y=12)])\n+\n+        self.assertEqualStrict(traverse_u(v, {}), {})\n+        self.assertEqualStrict(v.visited(), [{}])\n+\n+        self.assertEqualStrict(traverse_u(v, {\"a\": 1}), {\"a\": 11})\n+        self.assertEqualStrict(v.visited(), [1, {\"a\": 11}])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, {\"b\": 2, \"a\": 1}), {\"a\": 11, \"b\": 12}\n+        )\n+        self.assertEqualStrict(v.visited(), [1, 2, {\"a\": 11, \"b\": 12}])\n+\n+        self.assertEqualStrict(traverse_u(v, OrderedDict()), OrderedDict())\n+        self.assertEqualStrict(v.visited(), [OrderedDict()])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, OrderedDict([(\"a\", 1)])), OrderedDict([(\"a\", 11)])\n+        )\n+        self.assertEqualStrict(v.visited(), [1, OrderedDict([(\"a\", 11)])])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, OrderedDict([(\"b\", 2), (\"a\", 1)])),\n+            OrderedDict([(\"b\", 12), (\"a\", 11)]),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(), [2, 1, OrderedDict([(\"b\", 12), (\"a\", 11)])]\n+        )\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, defaultdict(default_value)),\n+            defaultdict(default_value),\n+        )\n+        self.assertEqualStrict(v.visited(), [defaultdict(default_value)])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, defaultdict(default_value, [(\"a\", 1)])),\n+            defaultdict(default_value, [(\"a\", 11)]),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(), [1, defaultdict(default_value, [(\"a\", 11)])]\n+        )\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, defaultdict(default_value, [(\"b\", 2), (\"a\", 1)])),\n+            defaultdict(default_value, [(\"a\", 11), (\"b\", 12)]),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(),\n+            [1, 2, defaultdict(default_value, [(\"a\", 11), (\"b\", 12)])],\n+        )\n+\n+        # Keras tracking wrappers.\n+        self.assertEqualStrict(traverse_u(v, TrackedList([])), TrackedList([]))\n+        self.assertEqualStrict(v.visited(), [TrackedList([])])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, TrackedList([1])), TrackedList([11])\n+        )\n+        self.assertEqualStrict(v.visited(), [1, TrackedList([11])])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, TrackedList([1, 2])), TrackedList([11, 12])\n+        )\n+        self.assertEqualStrict(v.visited(), [1, 2, TrackedList([11, 12])])\n+\n+        self.assertEqualStrict(traverse_u(v, TrackedSet([])), TrackedSet([]))\n+        self.assertEqualStrict(v.visited(), [TrackedSet([])])\n+\n+        self.assertEqualStrict(traverse_u(v, TrackedSet([1])), TrackedSet([11]))\n+        self.assertEqualStrict(v.visited(), [1, TrackedSet([11])])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, TrackedSet([1, 2])), TrackedSet([11, 12])\n+        )\n+        visited = v.visited()\n+        self.assertEqualStrict(visited[-1], TrackedSet([11, 12]))\n+        self.assertEqualStrict(sorted(visited[:-1]), [1, 2])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, TrackedDict()),\n+            TrackedDict(),\n+        )\n+        self.assertEqualStrict(v.visited(), [TrackedDict()])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, TrackedDict({\"a\": 1})),\n+            TrackedDict({\"a\": 11}),\n+        )\n+        self.assertEqualStrict(v.visited(), [1, TrackedDict({\"a\": 11})])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, TrackedDict({\"b\": 2, \"a\": 1})),\n+            TrackedDict({\"a\": 11, \"b\": 12}),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(), [1, 2, TrackedDict({\"a\": 11, \"b\": 12})]\n+        )\n+\n+        # Deeper nested structures.\n+        self.assertEqualStrict(\n+            traverse_u(\n+                v,\n+                (\n+                    {\"b\": [2, 3], \"a\": (1,)},\n+                    TrackedDict({\"x\": 4, \"y\": TrackedList([5, 6])}),\n+                    TrackedSet([7]),\n+                    Point(y=9, x=8),\n+                    np.array([10]),\n+                ),\n+            ),\n+            (\n+                {\"b\": [12, 13], \"a\": (11,)},\n+                TrackedDict({\"x\": 14, \"y\": TrackedList([15, 16])}),\n+                TrackedSet([17]),\n+                Point(y=19, x=18),\n+                np.array([20]),\n+            ),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(),\n+            [\n+                1,\n+                (11,),\n+                2,\n+                3,\n+                [12, 13],\n+                {\"b\": [12, 13], \"a\": (11,)},\n+                4,\n+                5,\n+                6,\n+                TrackedList([15, 16]),\n+                TrackedDict({\"x\": 14, \"y\": TrackedList([15, 16])}),\n+                7,\n+                TrackedSet([17]),\n+                8,\n+                9,\n+                Point(x=18, y=19),\n+                np.array([10]),\n+                (\n+                    {\"b\": [12, 13], \"a\": (11,)},\n+                    TrackedDict({\"x\": 14, \"y\": TrackedList([15, 16])}),\n+                    TrackedSet([17]),\n+                    Point(y=19, x=18),\n+                    np.array([20]),\n+                ),\n+            ],\n+        )\n+\n+        # Error cases.\n+        with self.assertRaisesRegex(TypeError, \"callable\"):\n+            traverse_u(\"bad\", [1, 2])\n+\n+        # Children are not explored if structure is replaced with a leaf.\n+        v = Visitor(lambda x: \"X\" if isinstance(x, tuple) else None)\n+        self.assertEqualStrict(\n+            traverse_u(v, [(1, [2]), [3, (4, 5, 6)]]),\n+            [\"X\", [3, \"X\"]],\n+        )\n+        self.assertEqualStrict(\n+            v.visited(),\n+            [\n+                1,\n+                2,\n+                [2],\n+                (1, [2]),\n+                3,\n+                4,\n+                5,\n+                6,\n+                (4, 5, 6),\n+                [3, \"X\"],\n+                [\"X\", [3, \"X\"]],\n+            ],\n+        )\n+\n+        # Children are not explored if structure is replaced with structure.\n+        v = Visitor(lambda x: (\"a\", \"b\") if isinstance(x, tuple) else None)\n+        self.assertEqualStrict(\n+            traverse_u(v, [(1, [2]), [3, (4, 5, 6)]]),\n+            [(\"a\", \"b\"), [3, (\"a\", \"b\")]],\n+        )\n+        self.assertEqualStrict(\n+            v.visited(),\n+            [\n+                1,\n+                2,\n+                [2],\n+                (1, [2]),\n+                3,\n+                4,\n+                5,\n+                6,\n+                (4, 5, 6),\n+                [3, (\"a\", \"b\")],\n+                [(\"a\", \"b\"), [3, (\"a\", \"b\")]],\n+            ],\n+        )\n+\n+        # MAP_TO_NONE.\n+        v = Visitor(lambda x: MAP_TO_NONE if isinstance(x, tuple) else None)\n+        self.assertEqualStrict(\n+            traverse_u(v, [(1, [2]), [3, (4, 5, 6)]]),\n+            [None, [3, None]],\n+        )\n+        self.assertEqualStrict(\n+            v.visited(),\n+            [\n+                1,\n+                2,\n+                [2],\n+                (1, [2]),\n+                3,\n+                4,\n+                5,\n+                6,\n+                (4, 5, 6),\n+                [3, None],\n+                [None, [3, None]],\n+            ],\n+        )\n+\n+    @pytest.mark.skipif(backend.backend() != \"tensorflow\", reason=\"tf only\")\n+    def test_traverse_bottom_up_tf_wrappers(self, t):\n+        from tensorflow.python.trackable.data_structures import ListWrapper\n+        from tensorflow.python.trackable.data_structures import _DictWrapper\n+\n+        v = Visitor(lambda x: None if t.is_nested(x) else x + 10)\n+        traverse_u = functools.partial(t.traverse, top_down=False)\n+\n+        self.assertEqualStrict(traverse_u(v, ListWrapper([])), ListWrapper([]))\n+        self.assertEqualStrict(v.visited(), [ListWrapper([])])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, ListWrapper([1])), ListWrapper([11])\n+        )\n+        self.assertEqualStrict(v.visited(), [1, ListWrapper([11])])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, ListWrapper([1, 2])), ListWrapper([11, 12])\n+        )\n+        self.assertEqualStrict(v.visited(), [1, 2, ListWrapper([11, 12])])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, _DictWrapper()),\n+            _DictWrapper(),\n+        )\n+        self.assertEqualStrict(v.visited(), [_DictWrapper()])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, _DictWrapper({\"a\": 1})),\n+            _DictWrapper({\"a\": 11}),\n+        )\n+        self.assertEqualStrict(v.visited(), [1, _DictWrapper({\"a\": 11})])\n+\n+        self.assertEqualStrict(\n+            traverse_u(v, _DictWrapper({\"b\": 2, \"a\": 1})),\n+            _DictWrapper({\"a\": 11, \"b\": 12}),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(), [1, 2, _DictWrapper({\"a\": 11, \"b\": 12})]\n+        )\n+\n+    def test_lists_to_tuples(self, t):\n+        self.assertEqualStrict(\n+            t.lists_to_tuples([1, 2, 3]),\n+            (1, 2, 3),\n+        )\n+        self.assertEqualStrict(\n+            t.lists_to_tuples([[1], [2, 3]]),\n+            ((1,), (2, 3)),\n+        )\n+\n+        # Deeper nested structures.\n+        self.assertEqualStrict(\n+            t.lists_to_tuples(\n+                (\n+                    {\"b\": [2, 3], \"a\": (1,)},\n+                    TrackedDict({\"x\": 4, \"y\": TrackedList([5, 6])}),\n+                    TrackedSet([(7, 8, 9)]),\n+                ),\n+            ),\n+            (\n+                {\"b\": (2, 3), \"a\": (1,)},\n+                TrackedDict({\"x\": 4, \"y\": (5, 6)}),\n+                TrackedSet([(7, 8, 9)]),\n+            ),\n+        )\n+\n+    def test_map_shape_structure(self, t):\n+        v = Visitor(\n+            lambda x: tuple(x) + (10,) if isinstance(x, (tuple, list)) else None\n+        )\n+\n+        self.assertEqualStrict(\n+            t.map_shape_structure(v, (1, 2, 3)),\n+            (1, 2, 3, 10),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(),\n+            [\n+                (1, 2, 3),\n+            ],\n+        )\n+\n+        self.assertEqualStrict(\n+            t.map_shape_structure(v, {\"a\": [1, 2, None], \"b\": (5,), \"c\": \"hi\"}),\n+            {\"a\": (1, 2, None, 10), \"b\": (5, 10), \"c\": None},\n+        )\n+        self.assertEqualStrict(\n+            v.visited(),\n+            [\n+                [1, 2, None],\n+                (5,),\n+                \"hi\",\n+            ],\n+        )\n+\n+        # Deeper nested structures.\n+        self.assertEqualStrict(\n+            t.map_shape_structure(\n+                v,\n+                (\n+                    {\"b\": [2, 3], \"a\": (None,)},\n+                    TrackedDict({\"x\": 4, \"y\": TrackedList([5, 6])}),\n+                    TrackedSet([(7, None, 9)]),\n+                ),\n+            ),\n+            (\n+                {\"b\": (2, 3, 10), \"a\": (None, 10)},\n+                TrackedDict({\"x\": None, \"y\": (5, 6, 10)}),\n+                TrackedSet([(7, None, 9, 10)]),\n+            ),\n+        )\n+        self.assertEqualStrict(\n+            v.visited(),\n+            [\n+                (None,),\n+                [2, 3],\n+                4,\n+                TrackedList([5, 6]),\n+                (7, None, 9),\n+            ],\n         )\n\n@@ -1,3 +1,4 @@\n+import collections\n import itertools\n \n import numpy as np\n@@ -57,7 +58,7 @@ class DatasetUtilsTest(test_case.TestCase):\n             self.assertEqual(sample[1].shape, (1,))\n \n     @parameterized.named_parameters(\n-        named_product(structure_type=[\"dict\", \"tuple\"])\n+        named_product(structure_type=[\"tuple\", \"dict\", \"OrderedDict\"])\n     )\n     def test_split_dataset_nested_structures(self, structure_type):\n         n_sample, left_size, right_size = 100, 0.2, 0.8\n@@ -65,14 +66,20 @@ class DatasetUtilsTest(test_case.TestCase):\n         features2 = np.random.sample((n_sample, 10, 2))\n         labels = np.random.sample((n_sample, 1))\n \n-        if structure_type == \"dict\":\n-            dataset = tf.data.Dataset.from_tensor_slices(\n-                {\"x1\": features1, \"x2\": features2, \"labels\": labels}\n-            )\n-        elif structure_type == \"tuple\":\n+        if structure_type == \"tuple\":\n             dataset = tf.data.Dataset.from_tensor_slices(\n                 ((features1, features2), labels)\n             )\n+        if structure_type == \"dict\":\n+            dataset = tf.data.Dataset.from_tensor_slices(\n+                {\"y\": features2, \"x\": features1, \"labels\": labels}\n+            )\n+        if structure_type == \"OrderedDict\":\n+            dataset = tf.data.Dataset.from_tensor_slices(\n+                collections.OrderedDict(\n+                    [(\"y\", features2), (\"x\", features1), (\"labels\", labels)]\n+                )\n+            )\n \n         dataset_left, dataset_right = split_dataset(\n             dataset, left_size=left_size, right_size=right_size\n@@ -84,10 +91,10 @@ class DatasetUtilsTest(test_case.TestCase):\n             int(dataset_right.cardinality()), int(n_sample * right_size)\n         )\n         for sample in itertools.chain(dataset_left, dataset_right):\n-            if structure_type == \"dict\":\n-                x1, x2, labels = sample[\"x1\"], sample[\"x2\"], sample[\"labels\"]\n+            if structure_type in (\"dict\", \"OrderedDict\"):\n+                x, y, labels = sample[\"x\"], sample[\"y\"], sample[\"labels\"]\n             elif structure_type == \"tuple\":\n-                (x1, x2), labels = sample\n-            self.assertEqual(x1.shape, (2,))\n-            self.assertEqual(x2.shape, (10, 2))\n+                (x, y), labels = sample\n+            self.assertEqual(x.shape, (2,))\n+            self.assertEqual(y.shape, (10, 2))\n             self.assertEqual(labels.shape, (1,))\n\n@@ -185,12 +185,12 @@ class TrackedList(list):\n             self.tracker.untrack(value)\n \n     def tree_flatten(self):\n-        # For optree\n+        # For optree / dmtree\n         return (self, None)\n \n     @classmethod\n     def tree_unflatten(cls, metadata, children):\n-        # For optree\n+        # For optree / dmtree\n         return cls(children)\n \n \n@@ -234,20 +234,15 @@ class TrackedDict(dict):\n         super().clear()\n \n     def tree_flatten(self):\n-        from keras.src.utils.module_utils import optree\n-\n-        # For optree\n-        keys, values = optree.utils.unzip2(\n-            optree.utils.total_order_sorted(self.items(), key=lambda kv: kv[0])\n-        )\n-        return values, list(keys), keys\n+        # For optree / dmtree\n+        keys = sorted(list(self.keys()))\n+        values = [self[k] for k in keys]\n+        return values, keys, keys\n \n     @classmethod\n     def tree_unflatten(cls, keys, values):\n-        from keras.src.utils.module_utils import optree\n-\n-        # For optree\n-        return cls(optree.utils.safe_zip(keys, values))\n+        # For optree / dmtree\n+        return cls(zip(keys, values))\n \n \n @tree.register_tree_node_class\n@@ -286,10 +281,10 @@ class TrackedSet(set):\n         super().clear()\n \n     def tree_flatten(self):\n-        # For optree\n+        # For optree / dmtree\n         return (self, None)\n \n     @classmethod\n     def tree_unflatten(cls, metadata, children):\n-        # For optree\n+        # For optree / dmtree\n         return cls(children)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
