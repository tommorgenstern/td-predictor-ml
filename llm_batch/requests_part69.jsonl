{"custom_id": "requests#9edba838b3c7891c955b49d680c49b4ee8e64dd4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 4 | Methods Changed: 3 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 10 | Churn Cumulative: 2436 | Contributors (this commit): 46 | Commits (past 90d): 12 | Contributors (cumulative): 46 | DMM Complexity: 1.0\n\nDIFF:\n@@ -231,6 +231,8 @@ class Session(SessionRedirectMixin):\n     def update_request(self, request):\n         \"\"\"Destructively updates/merges the settings of a :class:`Request`\n         object from those of the :class:`Session`.\n+\n+        :param request: mutable :class:`Request` instance.\n         \"\"\"\n         cookies = request.cookies or {}\n \n@@ -257,10 +259,9 @@ class Session(SessionRedirectMixin):\n         request.hooks = merge_setting(request.hooks, self.hooks)\n         request.method = request.method.upper()\n \n-        return request\n-\n     def prepare_request(self, request):\n-        req = self.update_request(request.copy())\n+        req = request.copy()\n+        self.update_request(req)\n         return req.prepare()\n \n     def request(self, method, url,\n@@ -318,7 +319,8 @@ class Session(SessionRedirectMixin):\n             cookies = cookies,\n             hooks = hooks,\n         )\n-        prep = self.prepare_request(req)\n+        self.update_request(req)\n+        prep = req.prepare()\n \n         proxies = proxies or {}\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#ee90f0af608a58761e5f1e08ea5ea6a6365651a2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 12 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 18 | Churn Cumulative: 8812 | Contributors (this commit): 115 | Commits (past 90d): 16 | Contributors (cumulative): 115 | DMM Complexity: None\n\nDIFF:\n@@ -28,6 +28,8 @@ from .compat import (\n     cookielib, urlunparse, urlsplit, urlencode, str, bytes, StringIO,\n     is_py2, chardet, json, builtin_str, basestring)\n \n+from copy import copy as shallowcopy\n+\n CONTENT_CHUNK_SIZE = 10 * 1024\n ITER_CHUNK_SIZE = 512\n \n@@ -218,13 +220,17 @@ class Request(RequestHooksMixin):\n         return Request(\n             method = self.method,\n             url = self.url,\n-            headers = self.headers,\n-            files = self.files,\n-            data = self.data,\n-            params = self.params,\n             auth = self.auth,\n-            cookies = self.cookies,\n-            hooks = self.hooks,\n+\n+            # Copy mutable dict/list parameters so that altering one request\n+            # does not alter the copy.\n+            headers = shallowcopy(self.headers),\n+            params = shallowcopy(self.params),\n+            cookies = shallowcopy(self.cookies),\n+            hooks = shallowcopy(self.hooks),\n+\n+            files = shallowcopy(self.files),\n+            data = shallowcopy(self.data),\n         )\n \n     def prepare(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#d4385f6fc84854d78f838f4eb3a93dd3985242c5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 31 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 31 | Churn Cumulative: 3425 | Contributors (this commit): 58 | Commits (past 90d): 24 | Contributors (cumulative): 58 | DMM Complexity: 1.0\n\nDIFF:\n@@ -458,6 +458,37 @@ class RequestsTestCase(unittest.TestCase):\n \n         self.assertTrue(hasattr(resp, 'hook_working'))\n \n+    def test_request_copy(self):\n+        a = requests.Request('POST', httpbin('post'),\n+                headers={'oh': 'gee'},\n+                files={'some': 'thing'},\n+                data={'baz':'qux'},\n+                params={'foo': 'bar'},\n+                auth=object(),\n+                cookies={'Some-Cookie':'Some Value'},\n+                hooks={'response': lambda r: r })\n+        b = a.copy()\n+\n+        self.assertNotEqual(a, b)\n+        self.assertEqual(a.method, b.method)\n+        self.assertEqual(a.url, b.url)\n+        self.assertEqual(a.headers, b.headers)\n+        self.assertEqual(a.files, b.files)\n+        self.assertEqual(a.data, b.data)\n+        self.assertEqual(a.params, b.params)\n+        self.assertEqual(a.auth, b.auth)\n+        self.assertEqual(a.cookies, b.cookies)\n+        self.assertEqual(a.hooks, b.hooks)\n+\n+        a.headers['Foo'] = 'Bar'\n+        self.assertNotEqual(a.headers, b.headers)\n+\n+        a.data['x'] = 'y'\n+        self.assertNotEqual(a.data, b.data)\n+\n+        a.params['_'] = '?'\n+        self.assertNotEqual(a.params, b.params)\n+\n     def test_links(self):\n         r = requests.Response()\n         r.headers = {\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#0eccb547a29eda9c04d5e1cef586557846b19e92", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 17 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 2 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 17 | Churn Cumulative: 3442 | Contributors (this commit): 58 | Commits (past 90d): 25 | Contributors (cumulative): 58 | DMM Complexity: 1.0\n\nDIFF:\n@@ -489,6 +489,23 @@ class RequestsTestCase(unittest.TestCase):\n         a.params['_'] = '?'\n         self.assertNotEqual(a.params, b.params)\n \n+    def test_prepared_from_session(self):\n+        class DummyAuth(requests.auth.AuthBase):\n+            def __call__(self, r):\n+                r.headers['Dummy-Auth-Test'] = 'dummy-auth-test-ok'\n+                return r\n+\n+        req = requests.Request('GET', httpbin('headers'))\n+        self.assertEqual(req.auth, None)\n+\n+        s = requests.Session()\n+        s.auth = DummyAuth()\n+\n+        prep = s.prepare_request(req)\n+        resp = s.send(prep)\n+\n+        self.assertTrue(resp.json()['headers']['Dummy-Auth-Test'], 'dummy-auth-test-ok')\n+\n     def test_links(self):\n         r = requests.Response()\n         r.headers = {\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#852de116ddf7fa2d82a6c3453916acecc2da926d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 3 | Churn Cumulative: 8815 | Contributors (this commit): 116 | Commits (past 90d): 17 | Contributors (cumulative): 116 | DMM Complexity: None\n\nDIFF:\n@@ -384,9 +384,6 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n                 self.headers['Content-Length'] = str(length)\n             else:\n                 self.headers['Transfer-Encoding'] = 'chunked'\n-        # Check if file, fo, generator, iterator.\n-        # If not, run through normal process.\n-\n         else:\n             # Multi-part file uploads.\n             if files:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#0ab7a52f7c04998ae68ed7da442fce32293e0fb5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 53 | Lines Deleted: 86 | Files Changed: 3 | Hunks: 13 | Methods Changed: 8 | Complexity Δ (Sum/Max): -1/1 | Churn Δ: 139 | Churn Cumulative: 14832 | Contributors (this commit): 155 | Commits (past 90d): 55 | Contributors (cumulative): 220 | DMM Complexity: 0.0\n\nDIFF:\n@@ -28,8 +28,6 @@ from .compat import (\n     cookielib, urlunparse, urlsplit, urlencode, str, bytes, StringIO,\n     is_py2, chardet, json, builtin_str, basestring)\n \n-from copy import copy as shallowcopy\n-\n CONTENT_CHUNK_SIZE = 10 * 1024\n ITER_CHUNK_SIZE = 512\n \n@@ -216,39 +214,20 @@ class Request(RequestHooksMixin):\n     def __repr__(self):\n         return '<Request [%s]>' % (self.method)\n \n-    def copy(self):\n-        return Request(\n-            method = self.method,\n-            url = self.url,\n-            auth = self.auth,\n-\n-            # Copy mutable dict/list parameters so that altering one request\n-            # does not alter the copy.\n-            headers = shallowcopy(self.headers),\n-            params = shallowcopy(self.params),\n-            cookies = shallowcopy(self.cookies),\n-            hooks = shallowcopy(self.hooks),\n-\n-            files = shallowcopy(self.files),\n-            data = shallowcopy(self.data),\n-        )\n-\n     def prepare(self):\n         \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it.\"\"\"\n         p = PreparedRequest()\n-\n-        p.prepare_method(self.method)\n-        p.prepare_url(self.url, self.params)\n-        p.prepare_headers(self.headers)\n-        p.prepare_cookies(self.cookies)\n-        p.prepare_body(self.data, self.files)\n-        p.prepare_auth(self.auth, self.url)\n-        # Note that prepare_auth must be last to enable authentication schemes\n-        # such as OAuth to work on a fully prepared request.\n-\n-        # This MUST go after prepare_auth. Authenticators could add a hook\n-        p.prepare_hooks(self.hooks)\n-\n+        p.prepare(\n+            method=self.method,\n+            url=self.url,\n+            headers=self.headers,\n+            files=self.files,\n+            data=self.data,\n+            params=self.params,\n+            auth=self.auth,\n+            cookies=self.cookies,\n+            hooks=self.hooks,\n+        )\n         return p\n \n \n@@ -283,6 +262,22 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         #: dictionary of callback hooks, for internal usage.\n         self.hooks = default_hooks()\n \n+    def prepare(self, method=None, url=None, headers=None, files=None,\n+                data=None, params=None, auth=None, cookies=None, hooks=None):\n+        \"\"\"Prepares the the entire request with the given parameters.\"\"\"\n+\n+        self.prepare_method(method)\n+        self.prepare_url(url, params)\n+        self.prepare_headers(headers)\n+        self.prepare_cookies(cookies)\n+        self.prepare_body(data, files)\n+        self.prepare_auth(auth, url)\n+        # Note that prepare_auth must be last to enable authentication schemes\n+        # such as OAuth to work on a fully prepared request.\n+\n+        # This MUST go after prepare_auth. Authenticators could add a hook\n+        self.prepare_hooks(hooks)\n+\n     def __repr__(self):\n         return '<PreparedRequest [%s]>' % (self.method)\n \n\n@@ -228,11 +228,14 @@ class Session(SessionRedirectMixin):\n     def __exit__(self, *args):\n         self.close()\n \n-    def update_request(self, request):\n-        \"\"\"Destructively updates/merges the settings of a :class:`Request`\n-        object from those of the :class:`Session`.\n+    def prepare_request(self, request):\n+        \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for\n+        transmission and returns it. The :class:`PreparedRequest` has settings\n+        merged from the :class:`Request <Request>` instance and those of the\n+        :class:`Session`.\n \n-        :param request: mutable :class:`Request` instance.\n+        :param request: :class:`Request` instance to prepare with this\n+        session's settings.\n         \"\"\"\n         cookies = request.cookies or {}\n \n@@ -244,25 +247,26 @@ class Session(SessionRedirectMixin):\n         merged_cookies = RequestsCookieJar()\n         merged_cookies.update(self.cookies)\n         merged_cookies.update(cookies)\n-        request.cookies = merged_cookies\n \n-        # Gather clues from the surrounding environment.\n-        if self.trust_env:\n+\n         # Set environment's basic authentication if not explicitly set.\n-            if not request.auth and not self.auth:\n-                request.auth = get_netrc_auth(request.url)\n+        auth = request.auth\n+        if self.trust_env and not auth and not self.auth:\n+            auth = get_netrc_auth(request.url)\n \n-        # Merge settings from the request and the session.\n-        request.params = merge_setting(request.params, self.params)\n-        request.headers = merge_setting(request.headers, self.headers, dict_class=CaseInsensitiveDict)\n-        request.auth = merge_setting(request.auth, self.auth)\n-        request.hooks = merge_setting(request.hooks, self.hooks)\n-        request.method = request.method.upper()\n-\n-    def prepare_request(self, request):\n-        req = request.copy()\n-        self.update_request(req)\n-        return req.prepare()\n+        p = PreparedRequest()\n+        p.prepare(\n+            method=request.method.upper(),\n+            url=request.url,\n+            files=request.files,\n+            data=request.data,\n+            headers=merge_setting(request.headers, self.headers, dict_class=CaseInsensitiveDict),\n+            params=merge_setting(request.params, self.params),\n+            auth=merge_setting(auth, self.auth),\n+            cookies=merged_cookies,\n+            hooks=merge_setting(request.hooks, self.hooks),\n+        )\n+        return p\n \n     def request(self, method, url,\n         params=None,\n@@ -319,8 +323,7 @@ class Session(SessionRedirectMixin):\n             cookies = cookies,\n             hooks = hooks,\n         )\n-        self.update_request(req)\n-        prep = req.prepare()\n+        prep = self.prepare_request(req)\n \n         proxies = proxies or {}\n \n@@ -438,7 +441,7 @@ class Session(SessionRedirectMixin):\n \n         # It's possible that users might accidentally send a Request object.\n         # Guard against that specific failure case.\n-        if getattr(request, 'prepare', None):\n+        if not isinstance(request, PreparedRequest):\n             raise ValueError('You can only send PreparedRequests.')\n \n         # Set up variables needed for resolve_redirects and dispatching of\n\n@@ -458,37 +458,6 @@ class RequestsTestCase(unittest.TestCase):\n \n         self.assertTrue(hasattr(resp, 'hook_working'))\n \n-    def test_request_copy(self):\n-        a = requests.Request('POST', httpbin('post'),\n-                headers={'oh': 'gee'},\n-                files={'some': 'thing'},\n-                data={'baz':'qux'},\n-                params={'foo': 'bar'},\n-                auth=object(),\n-                cookies={'Some-Cookie':'Some Value'},\n-                hooks={'response': lambda r: r })\n-        b = a.copy()\n-\n-        self.assertNotEqual(a, b)\n-        self.assertEqual(a.method, b.method)\n-        self.assertEqual(a.url, b.url)\n-        self.assertEqual(a.headers, b.headers)\n-        self.assertEqual(a.files, b.files)\n-        self.assertEqual(a.data, b.data)\n-        self.assertEqual(a.params, b.params)\n-        self.assertEqual(a.auth, b.auth)\n-        self.assertEqual(a.cookies, b.cookies)\n-        self.assertEqual(a.hooks, b.hooks)\n-\n-        a.headers['Foo'] = 'Bar'\n-        self.assertNotEqual(a.headers, b.headers)\n-\n-        a.data['x'] = 'y'\n-        self.assertNotEqual(a.data, b.data)\n-\n-        a.params['_'] = '?'\n-        self.assertNotEqual(a.params, b.params)\n-\n     def test_prepared_from_session(self):\n         class DummyAuth(requests.auth.AuthBase):\n             def __call__(self, r):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#5a26241287162ff592c81dbfbbd013e309c85c05", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 6 | Churn Cumulative: 1909 | Contributors (this commit): 43 | Commits (past 90d): 4 | Contributors (cumulative): 43 | DMM Complexity: 0.0\n\nDIFF:\n@@ -25,7 +25,7 @@ from .compat import (quote, urlparse, bytes, str, OrderedDict, urlunparse,\n                      is_py2, is_py3, builtin_str, getproxies, proxy_bypass)\n from .cookies import RequestsCookieJar, cookiejar_from_dict\n from .structures import CaseInsensitiveDict\n-from .exceptions import MissingSchema\n+from .exceptions import MissingSchema, InvalidURL\n \n _hush_pyflakes = (RequestsCookieJar,)\n \n@@ -363,7 +363,11 @@ def unquote_unreserved(uri):\n     for i in range(1, len(parts)):\n         h = parts[i][0:2]\n         if len(h) == 2 and h.isalnum():\n+            try:\n                 c = chr(int(h, 16))\n+            except ValueError:\n+                raise InvalidURL(\"Invalid percent-escape sequence: '%s'\" % h)\n+\n             if c in UNRESERVED_SET:\n                 parts[i] = c + parts[i][2:]\n             else:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#d06dabab59b1b9f07289d8a8cd533a3adedbfaba", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 134 | Lines Deleted: 33 | Files Changed: 3 | Hunks: 25 | Methods Changed: 16 | Complexity Δ (Sum/Max): 16/8 | Churn Δ: 167 | Churn Cumulative: 3626 | Contributors (this commit): 10 | Commits (past 90d): 23 | Contributors (cumulative): 21 | DMM Complexity: 0.16666666666666666\n\nDIFF:\n@@ -101,6 +101,12 @@ class VerifiedHTTPSConnection(HTTPSConnection):\n         resolved_cert_reqs = resolve_cert_reqs(self.cert_reqs)\n         resolved_ssl_version = resolve_ssl_version(self.ssl_version)\n \n+        if self._tunnel_host:\n+            self.sock = sock\n+            # Calls self._set_hostport(), so self.host is\n+            # self._tunnel_host below.\n+            self._tunnel()\n+\n         # Wrap socket using verification with the root certs in\n         # trusted_root_certs\n         self.sock = ssl_wrap_socket(sock, self.key_file, self.cert_file,\n@@ -174,12 +180,20 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n     :param headers:\n         Headers to include with all requests, unless other headers are given\n         explicitly.\n+\n+    :param _proxy:\n+        Parsed proxy URL, should not be used directly, instead, see\n+        :class:`urllib3.connectionpool.ProxyManager`\"\n+\n+    :param _proxy_headers:\n+        A dictionary with proxy headers, should not be used directly,\n+        instead, see :class:`urllib3.connectionpool.ProxyManager`\"\n     \"\"\"\n \n     scheme = 'http'\n \n     def __init__(self, host, port=None, strict=False, timeout=None, maxsize=1,\n-                 block=False, headers=None):\n+                 block=False, headers=None, _proxy=None, _proxy_headers=None):\n         ConnectionPool.__init__(self, host, port)\n         RequestMethods.__init__(self, headers)\n \n@@ -188,6 +202,9 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n         self.pool = self.QueueCls(maxsize)\n         self.block = block\n \n+        self.proxy = _proxy\n+        self.proxy_headers = _proxy_headers or {}\n+\n         # Fill the queue up so that doing get() on it will block properly\n         for _ in xrange(maxsize):\n             self.pool.put(None)\n@@ -526,13 +543,14 @@ class HTTPSConnectionPool(HTTPConnectionPool):\n     def __init__(self, host, port=None,\n                  strict=False, timeout=None, maxsize=1,\n                  block=False, headers=None,\n+                 _proxy=None, _proxy_headers=None,\n                  key_file=None, cert_file=None, cert_reqs=None,\n                  ca_certs=None, ssl_version=None,\n                  assert_hostname=None, assert_fingerprint=None):\n \n         HTTPConnectionPool.__init__(self, host, port,\n                                     strict, timeout, maxsize,\n-                                    block, headers)\n+                                    block, headers, _proxy, _proxy_headers)\n         self.key_file = key_file\n         self.cert_file = cert_file\n         self.cert_reqs = cert_reqs\n@@ -541,6 +559,34 @@ class HTTPSConnectionPool(HTTPConnectionPool):\n         self.assert_hostname = assert_hostname\n         self.assert_fingerprint = assert_fingerprint\n \n+    def _prepare_conn(self, connection):\n+        \"\"\"\n+        Prepare the ``connection`` for :meth:`urllib3.util.ssl_wrap_socket`\n+        and establish the tunnel if proxy is used.\n+        \"\"\"\n+\n+        if isinstance(connection, VerifiedHTTPSConnection):\n+            connection.set_cert(key_file=self.key_file,\n+                                cert_file=self.cert_file,\n+                                cert_reqs=self.cert_reqs,\n+                                ca_certs=self.ca_certs,\n+                                assert_hostname=self.assert_hostname,\n+                                assert_fingerprint=self.assert_fingerprint)\n+            connection.ssl_version = self.ssl_version\n+\n+        if self.proxy is not None:\n+            # Python 2.7+\n+            try:\n+                set_tunnel = connection.set_tunnel\n+            except AttributeError:  # Platform-specific: Python 2.6\n+                set_tunnel = connection._set_tunnel\n+            set_tunnel(self.host, self.port, self.proxy_headers)\n+            # Establish tunnel connection early, because otherwise httplib\n+            # would improperly set Host: header to proxy's IP:port.\n+            connection.connect()\n+\n+        return connection\n+\n     def _new_conn(self):\n         \"\"\"\n         Return a fresh :class:`httplib.HTTPSConnection`.\n@@ -549,26 +595,24 @@ class HTTPSConnectionPool(HTTPConnectionPool):\n         log.info(\"Starting new HTTPS connection (%d): %s\"\n                  % (self.num_connections, self.host))\n \n+        actual_host = self.host\n+        actual_port = self.port\n+        if self.proxy is not None:\n+            actual_host = self.proxy.host\n+            actual_port = self.proxy.port\n+\n         if not ssl:  # Platform-specific: Python compiled without +ssl\n             if not HTTPSConnection or HTTPSConnection is object:\n                 raise SSLError(\"Can't connect to HTTPS URL because the SSL \"\n                                \"module is not available.\")\n+            connection_class = HTTPSConnection\n+        else:\n+            connection_class = VerifiedHTTPSConnection\n \n-            return HTTPSConnection(host=self.host,\n-                                   port=self.port,\n+        connection = connection_class(host=actual_host, port=actual_port,\n                                       strict=self.strict)\n \n-        connection = VerifiedHTTPSConnection(host=self.host,\n-                                             port=self.port,\n-                                             strict=self.strict)\n-        connection.set_cert(key_file=self.key_file, cert_file=self.cert_file,\n-                            cert_reqs=self.cert_reqs, ca_certs=self.ca_certs,\n-                            assert_hostname=self.assert_hostname,\n-                            assert_fingerprint=self.assert_fingerprint)\n-\n-        connection.ssl_version = self.ssl_version\n-\n-        return connection\n+        return self._prepare_conn(connection)\n \n \n def connection_from_url(url, **kw):\n\n@@ -13,7 +13,7 @@ except ImportError:\n \n from ._collections import RecentlyUsedContainer\n from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool\n-from .connectionpool import connection_from_url, port_by_scheme\n+from .connectionpool import port_by_scheme\n from .request import RequestMethods\n from .util import parse_url\n \n@@ -60,6 +60,8 @@ class PoolManager(RequestMethods):\n \n     \"\"\"\n \n+    proxy = None\n+\n     def __init__(self, num_pools=10, headers=None, **connection_pool_kw):\n         RequestMethods.__init__(self, headers)\n         self.connection_pool_kw = connection_pool_kw\n@@ -99,14 +101,16 @@ class PoolManager(RequestMethods):\n         If ``port`` isn't given, it will be derived from the ``scheme`` using\n         ``urllib3.connectionpool.port_by_scheme``.\n         \"\"\"\n+\n         scheme = scheme or 'http'\n+\n         port = port or port_by_scheme.get(scheme, 80)\n \n         pool_key = (scheme, host, port)\n \n         with self.pools.lock:\n-          # If the scheme, host, or port doesn't match existing open connections,\n-          # open a new ConnectionPool.\n+            # If the scheme, host, or port doesn't match existing open\n+            # connections, open a new ConnectionPool.\n             pool = self.pools.get(pool_key)\n             if pool:\n                 return pool\n@@ -145,6 +149,9 @@ class PoolManager(RequestMethods):\n         if 'headers' not in kw:\n             kw['headers'] = self.headers\n \n+        if self.proxy is not None and u.scheme == \"http\":\n+            response = conn.urlopen(method, url, **kw)\n+        else:\n             response = conn.urlopen(method, u.request_uri, **kw)\n \n         redirect_location = redirect and response.get_redirect_location()\n@@ -164,15 +171,59 @@ class PoolManager(RequestMethods):\n         return self.urlopen(method, redirect_location, **kw)\n \n \n-class ProxyManager(RequestMethods):\n+class ProxyManager(PoolManager):\n     \"\"\"\n-    Given a ConnectionPool to a proxy, the ProxyManager's ``urlopen`` method\n-    will make requests to any url through the defined proxy. The ProxyManager\n-    class will automatically set the 'Host' header if it is not provided.\n+    Behaves just like :class:`PoolManager`, but sends all requests through\n+    the defined proxy, using the CONNECT method for HTTPS URLs.\n+\n+    :param poxy_url:\n+        The URL of the proxy to be used.\n+\n+    :param proxy_headers:\n+        A dictionary contaning headers that will be sent to the proxy. In case\n+        of HTTP they are being sent with each request, while in the\n+        HTTPS/CONNECT case they are sent only once. Could be used for proxy\n+        authentication.\n+\n+    Example:\n+        >>> proxy = urllib3.ProxyManager('http://localhost:3128/')\n+        >>> r1 = proxy.request('GET', 'http://google.com/')\n+        >>> r2 = proxy.request('GET', 'http://httpbin.org/')\n+        >>> len(proxy.pools)\n+        1\n+        >>> r3 = proxy.request('GET', 'https://httpbin.org/')\n+        >>> r4 = proxy.request('GET', 'https://twitter.com/')\n+        >>> len(proxy.pools)\n+        3\n+\n     \"\"\"\n \n-    def __init__(self, proxy_pool):\n-        self.proxy_pool = proxy_pool\n+    def __init__(self, proxy_url, num_pools=10, headers=None,\n+                 proxy_headers=None, **connection_pool_kw):\n+\n+        if isinstance(proxy_url, HTTPConnectionPool):\n+            proxy_url = '%s://%s:%i' % (proxy_url.scheme, proxy_url.host,\n+                                        proxy_url.port)\n+        proxy = parse_url(proxy_url)\n+        if not proxy.port:\n+            port = port_by_scheme.get(proxy.scheme, 80)\n+            proxy = proxy._replace(port=port)\n+        self.proxy = proxy\n+        self.proxy_headers = proxy_headers or {}\n+        assert self.proxy.scheme in (\"http\", \"https\"), \\\n+            'Not supported proxy scheme %s' % self.proxy.scheme\n+        connection_pool_kw['_proxy'] = self.proxy\n+        connection_pool_kw['_proxy_headers'] = self.proxy_headers\n+        super(ProxyManager, self).__init__(\n+            num_pools, headers, **connection_pool_kw)\n+\n+    def connection_from_host(self, host, port=None, scheme='http'):\n+        if scheme == \"https\":\n+            return super(ProxyManager, self).connection_from_host(\n+                host, port, scheme)\n+\n+        return super(ProxyManager, self).connection_from_host(\n+            self.proxy.host, self.proxy.port, self.proxy.scheme)\n \n     def _set_proxy_headers(self, url, headers=None):\n         \"\"\"\n@@ -187,16 +238,22 @@ class ProxyManager(RequestMethods):\n \n         if headers:\n             headers_.update(headers)\n-\n         return headers_\n \n-    def urlopen(self, method, url, **kw):\n+    def urlopen(self, method, url, redirect=True, **kw):\n         \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n-        kw['assert_same_host'] = False\n-        kw['headers'] = self._set_proxy_headers(url, headers=kw.get('headers'))\n-        return self.proxy_pool.urlopen(method, url, **kw)\n+        u = parse_url(url)\n+\n+        if u.scheme == \"http\":\n+            # It's too late to set proxy headers on per-request basis for\n+            # tunnelled HTTPS connections, should use\n+            # constructor's proxy_headers instead.\n+            kw['headers'] = self._set_proxy_headers(url, kw.get('headers',\n+                                                                self.headers))\n+            kw['headers'].update(self.proxy_headers)\n+\n+        return super(ProxyManager, self).urlopen(method, url, redirect, **kw)\n \n \n-def proxy_from_url(url, **pool_kw):\n-    proxy_pool = connection_from_url(url, **pool_kw)\n-    return ProxyManager(proxy_pool)\n+def proxy_from_url(url, **kw):\n+    return ProxyManager(proxy_url=url, **kw)\n\n@@ -191,7 +191,7 @@ class HTTPResponse(io.IOBase):\n                     \"failed to decode it.\" % content_encoding,\n                     e)\n \n-            if flush_decoder and self._decoder:\n+            if flush_decoder and decode_content and self._decoder:\n                 buf = self._decoder.decompress(binary_type())\n                 data += buf + self._decoder.flush()\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#134699faf9c7cb2d8fcbe505d0385b68b7d7a819", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 600 | Contributors (this commit): 13 | Commits (past 90d): 55 | Contributors (cumulative): 13 | DMM Complexity: None\n\nDIFF:\n@@ -11,7 +11,7 @@ and maintain connections.\n import socket\n \n from .models import Response\n-from .packages.urllib3.poolmanager import PoolManager, ProxyManager\n+from .packages.urllib3.poolmanager import PoolManager, proxy_from_url\n from .packages.urllib3.response import HTTPResponse\n from .compat import urlparse, basestring, urldefrag, unquote\n from .utils import (DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers,\n@@ -194,7 +194,7 @@ class HTTPAdapter(BaseAdapter):\n \n         if proxy:\n             except_on_missing_scheme(proxy)\n-            conn = ProxyManager(self.poolmanager.connection_from_url(proxy))\n+            conn = proxy_from_url(proxy).connection_from_url(url)\n         else:\n             conn = self.poolmanager.connection_from_url(url.lower())\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c951f0543c86ad7a3f90ead98f581c0af1865abd", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 6 | Churn Cumulative: 606 | Contributors (this commit): 13 | Commits (past 90d): 56 | Contributors (cumulative): 13 | DMM Complexity: 1.0\n\nDIFF:\n@@ -71,6 +71,7 @@ class HTTPAdapter(BaseAdapter):\n                  pool_block=DEFAULT_POOLBLOCK):\n         self.max_retries = max_retries\n         self.config = {}\n+        self.proxy_manager = {}\n \n         super(HTTPAdapter, self).__init__()\n \n@@ -194,7 +195,10 @@ class HTTPAdapter(BaseAdapter):\n \n         if proxy:\n             except_on_missing_scheme(proxy)\n-            conn = proxy_from_url(proxy).connection_from_url(url)\n+            if not proxy in self.proxy_manager:\n+                self.proxy_manager[proxy] = proxy_from_url(proxy)\n+\n+            conn = self.proxy_manager[proxy].connection_from_url(url)\n         else:\n             conn = self.poolmanager.connection_from_url(url.lower())\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#a5e5a51fb4e7202910172624bcc732700422a738", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 4 | Churn Cumulative: 8878 | Contributors (this commit): 116 | Commits (past 90d): 19 | Contributors (cumulative): 116 | DMM Complexity: None\n\nDIFF:\n@@ -11,7 +11,7 @@ import collections\n import logging\n import datetime\n \n-from io import BytesIO\n+from io import BytesIO, UnsupportedOperation\n from .hooks import default_hooks\n from .structures import CaseInsensitiveDict\n \n@@ -385,7 +385,7 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n \n         try:\n             length = super_len(data)\n-        except (TypeError, AttributeError):\n+        except (TypeError, AttributeError, UnsupportedOperation):\n             length = None\n \n         if is_stream:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#9dd823c289faca0d496ef71f25d36216d2259ca3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): -3/0 | Churn Δ: 12 | Churn Cumulative: 12363 | Contributors (this commit): 138 | Commits (past 90d): 46 | Contributors (cumulative): 175 | DMM Complexity: 0.7142857142857143\n\nDIFF:\n@@ -92,8 +92,10 @@ class RequestEncodingMixin(object):\n         if parameters are supplied as a dict.\n \n         \"\"\"\n-        if (not files) or isinstance(data, basestring):\n-            return None\n+        if (not files):\n+            raise ValueError(\"Files must be provided.\")\n+        elif isinstance(data, basestring):\n+            raise ValueError(\"Data must not be a string.\")\n \n         new_fields = []\n         fields = to_key_val_list(data or {})\n\n@@ -357,6 +357,12 @@ class RequestsTestCase(unittest.TestCase):\n         except ValueError:\n             pass\n \n+        with open('requirements.txt') as f:\n+            try:\n+                requests.post(url, data='[{\"some\": \"data\"}]', files={'some': f})\n+            except ValueError:\n+                pass\n+\n     def test_request_ok_set(self):\n         r = requests.get(httpbin('status', '404'))\n         self.assertEqual(r.ok, False)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b676bf3214fa917f20542b9d3d31577b47a73cc1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 9 | Churn Cumulative: 3488 | Contributors (this commit): 59 | Commits (past 90d): 27 | Contributors (cumulative): 59 | DMM Complexity: None\n\nDIFF:\n@@ -10,6 +10,7 @@ import unittest\n import pickle\n \n import requests\n+import pytest\n from requests.auth import HTTPDigestAuth\n from requests.adapters import HTTPAdapter\n from requests.compat import str, cookielib, getproxies, urljoin\n@@ -357,11 +358,11 @@ class RequestsTestCase(unittest.TestCase):\n         except ValueError:\n             pass\n \n+    def test_conflicting_post_params(self):\n+        url = httpbin('post')\n         with open('requirements.txt') as f:\n-            try:\n-                requests.post(url, data='[{\"some\": \"data\"}]', files={'some': f})\n-            except ValueError:\n-                pass\n+            pytest.raises(ValueError, \"requests.post(url, data='[{\\\"some\\\": \\\"data\\\"}]', files={'some': f})\")\n+            pytest.raises(ValueError, \"requests.post(url, data=u'[{\\\"some\\\": \\\"data\\\"}]', files={'some': f})\")\n \n     def test_request_ok_set(self):\n         r = requests.get(httpbin('status', '404'))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#61617e74ed23d82393509c61aac07bfc5a5ea2e4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 3/3 | Churn Δ: 3 | Churn Cumulative: 8887 | Contributors (this commit): 117 | Commits (past 90d): 20 | Contributors (cumulative): 117 | DMM Complexity: 0.0\n\nDIFF:\n@@ -141,6 +141,9 @@ class RequestHooksMixin(object):\n     def register_hook(self, event, hook):\n         \"\"\"Properly register a hook.\"\"\"\n \n+        if event not in self.hooks:\n+            raise ValueError('Unsupported event specified, with event name \"%s\"' % (event))\n+\n         if isinstance(hook, collections.Callable):\n             self.hooks[event].append(hook)\n         elif hasattr(hook, '__iter__'):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#2e5a6746019140bf2ef3a497c30c17992de36426", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 26 | Lines Deleted: 9 | Files Changed: 1 | Hunks: 9 | Methods Changed: 4 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 35 | Churn Cumulative: 641 | Contributors (this commit): 13 | Commits (past 90d): 6 | Contributors (cumulative): 13 | DMM Complexity: 1.0\n\nDIFF:\n@@ -195,8 +195,12 @@ class HTTPAdapter(BaseAdapter):\n \n         if proxy:\n             except_on_missing_scheme(proxy)\n+            proxy_headers = self.proxy_headers(proxy)\n+\n             if not proxy in self.proxy_manager:\n-                self.proxy_manager[proxy] = proxy_from_url(proxy)\n+                self.proxy_manager[proxy] = proxy_from_url(\n+                                                proxy,\n+                                                proxy_headers=proxy_headers)\n \n             conn = self.proxy_manager[proxy].connection_from_url(url)\n         else:\n@@ -236,8 +240,9 @@ class HTTPAdapter(BaseAdapter):\n         return url\n \n     def add_headers(self, request, **kwargs):\n-        \"\"\"Add any headers needed by the connection. Currently this adds a\n-        Proxy-Authorization header.\n+        \"\"\"Add any headers needed by the connection. As of v2.0 this does\n+        nothing by default, but is left for overriding by users that subclass\n+        the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n \n         This should not be called from user code, and is only exposed for use\n         when subclassing the\n@@ -246,12 +251,22 @@ class HTTPAdapter(BaseAdapter):\n         :param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.\n         :param kwargs: The keyword arguments from the call to send().\n         \"\"\"\n-        proxies = kwargs.get('proxies', {})\n+        pass\n \n-        if proxies is None:\n-            proxies = {}\n+    def proxy_headers(self, proxy):\n+        \"\"\"Returns a dictionary of the headers to add to any request sent\n+        through a proxy. This works with urllib3 magic to ensure that they are\n+        correctly sent to the proxy, rather than in a tunnelled request if\n+        CONNECT is being used.\n \n-        proxy = proxies.get(urlparse(request.url).scheme)\n+        This should not be called from user code, and is only exposed for use\n+        when subclassing the\n+        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n+\n+        :param proxies: The url of the proxy being used for this request.\n+        :param kwargs: Optional additional keyword arguments.\n+        \"\"\"\n+        headers = {}\n         username, password = get_auth_from_url(proxy)\n \n         if username and password:\n@@ -259,9 +274,11 @@ class HTTPAdapter(BaseAdapter):\n             # to decode them.\n             username = unquote(username)\n             password = unquote(password)\n-            request.headers['Proxy-Authorization'] = _basic_auth_str(username,\n+            headers['Proxy-Authorization'] = _basic_auth_str(username,\n                                                              password)\n \n+        return headers\n+\n     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n         \"\"\"Sends PreparedRequest object. Returns Response object.\n \n@@ -277,7 +294,7 @@ class HTTPAdapter(BaseAdapter):\n \n         self.cert_verify(conn, request.url, verify, cert)\n         url = self.request_url(request, proxies)\n-        self.add_headers(request, proxies=proxies)\n+        self.add_headers(request)\n \n         chunked = not (request.body is None or 'Content-Length' in request.headers)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#98680b64f4ec679b788071d1811a2bdcbdd26ac9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 2/2 | Churn Δ: 3 | Churn Cumulative: 600 | Contributors (this commit): 14 | Commits (past 90d): 7 | Contributors (cumulative): 14 | DMM Complexity: 1.0\n\nDIFF:\n@@ -107,6 +107,9 @@ def extract_cookies_to_jar(jar, request, response):\n     :param request: our own requests.Request object\n     :param response: urllib3.HTTPResponse object\n     \"\"\"\n+    if not (hasattr(response, '_original_response') and\n+            response._original_response):\n+        return\n     # the _original_response field is the wrapped httplib.HTTPResponse object,\n     req = MockRequest(request)\n     # pull out the HTTPMessage with the headers and put it in the mock:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#3bc01eed6f8a112e40ba6fdb79fafef5376c1d4c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 103 | Contributors (this commit): 11 | Commits (past 90d): 2 | Contributors (cumulative): 11 | DMM Complexity: None\n\nDIFF:\n@@ -9,7 +9,7 @@ This module contains the set of Requests' exceptions.\n \"\"\"\n \n \n-class RequestException(RuntimeError):\n+class RequestException(IOError):\n     \"\"\"There was an ambiguous exception that occurred while handling your\n     request.\"\"\"\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f44b86e03962b08ebf3b77d980ebeb8f11f6f704", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 12 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 5/5 | Churn Δ: 12 | Churn Cumulative: 12387 | Contributors (this commit): 139 | Commits (past 90d): 46 | Contributors (cumulative): 176 | DMM Complexity: 0.75\n\nDIFF:\n@@ -106,6 +106,10 @@ class RequestEncodingMixin(object):\n                 val = [val]\n             for v in val:\n                 if v is not None:\n+                    # Don't call str() on bytestrings: in Py3 it all goes wrong.\n+                    if not isinstance(v, bytes):\n+                        v = str(v)\n+\n                     new_fields.append(\n                         (field.decode('utf-8') if isinstance(field, bytes) else field,\n                          v.encode('utf-8') if isinstance(v, str) else v))\n\n@@ -663,6 +663,14 @@ class RequestsTestCase(unittest.TestCase):\n         self.assertTrue('unicode' in p.headers.keys())\n         self.assertTrue('byte' in p.headers.keys())\n \n+    def test_can_send_nonstring_objects_with_files(self):\n+        data = {'a': 0.0}\n+        files = {'b': 'foo'}\n+        r = requests.Request('POST', httpbin('post'), data=data, files=files)\n+        p = r.prepare()\n+\n+        self.assertTrue('multipart/form-data' in p.headers['Content-Type'])\n+\n \n class TestCaseInsensitiveDict(unittest.TestCase):\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f040b2aa5d5e278ce8a474a7dac3cf5533b36071", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 1911 | Contributors (this commit): 43 | Commits (past 90d): 5 | Contributors (cumulative): 43 | DMM Complexity: None\n\nDIFF:\n@@ -402,7 +402,7 @@ def get_environ_proxies(url):\n     if no_proxy:\n         # We need to check whether we match here. We need to see if we match\n         # the end of the netloc, both with and without the port.\n-        no_proxy = no_proxy.split(',')\n+        no_proxy = no_proxy.replace(' ', '').split(',')\n \n         for host in no_proxy:\n             if netloc.endswith(host) or netloc.split(':')[0].endswith(host):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#1aa765825619be338678ec746abd5d312e6eb377", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 503 | Contributors (this commit): 7 | Commits (past 90d): 1 | Contributors (cumulative): 7 | DMM Complexity: None\n\nDIFF:\n@@ -50,7 +50,7 @@ __copyright__ = 'Copyright 2013 Kenneth Reitz'\n \n # Attempt to enable urllib3's SNI support, if possible\n try:\n-    from requests.packages.urllib3.contrib import pyopenssl\n+    from .packages.urllib3.contrib import pyopenssl\n     pyopenssl.inject_into_urllib3()\n except ImportError:\n     pass\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b9b5be7c4c78e02f83464d8e332a1bf819853b60", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 49 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 3 | Methods Changed: 7 | Complexity Δ (Sum/Max): -2/2 | Churn Δ: 50 | Churn Cumulative: 5457 | Contributors (this commit): 90 | Commits (past 90d): 26 | Contributors (cumulative): 104 | DMM Complexity: 1.0\n\nDIFF:\n@@ -265,8 +265,12 @@ def get_encodings_from_content(content):\n     \"\"\"\n \n     charset_re = re.compile(r'<meta.*?charset=[\"\\']*(.+?)[\"\\'>]', flags=re.I)\n+    pragma_re = re.compile(r'<meta.*?content=[\"\\']*;?charset=(.+?)[\"\\'>]', flags=re.I)\n+    xml_re = re.compile(r'^<\\?xml.*?encoding=[\"\\']*(.+?)[\"\\'>]')\n \n-    return charset_re.findall(content)\n+    return (charset_re.findall(content) +\n+            pragma_re.findall(content) +\n+            xml_re.findall(content))\n \n \n def get_encoding_from_headers(headers):\n\n@@ -639,6 +639,50 @@ class RequestsTestCase(unittest.TestCase):\n         self.assertEqual(r.url, url)\n \n \n+class TestContentEncodingDetection(unittest.TestCase):\n+\n+    def test_none(self):\n+        encodings = requests.utils.get_encodings_from_content('')\n+        self.assertEqual(len(encodings), 0)\n+\n+    def test_html_charset(self):\n+        \"\"\"HTML5 meta charset attribute\"\"\"\n+        content = '<meta charset=\"UTF-8\">'\n+        encodings = requests.utils.get_encodings_from_content(content)\n+        self.assertEqual(len(encodings), 1)\n+        self.assertEqual(encodings[0], 'UTF-8')\n+\n+    def test_html4_pragma(self):\n+        \"\"\"HTML4 pragma directive\"\"\"\n+        content = '<meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\">'\n+        encodings = requests.utils.get_encodings_from_content(content)\n+        self.assertEqual(len(encodings), 1)\n+        self.assertEqual(encodings[0], 'UTF-8')\n+\n+    def test_xhtml_pragma(self):\n+        \"\"\"XHTML 1.x served with text/html MIME type\"\"\"\n+        content = '<meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\" />'\n+        encodings = requests.utils.get_encodings_from_content(content)\n+        self.assertEqual(len(encodings), 1)\n+        self.assertEqual(encodings[0], 'UTF-8')\n+\n+    def test_xml(self):\n+        \"\"\"XHTML 1.x served as XML\"\"\"\n+        content = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n+        encodings = requests.utils.get_encodings_from_content(content)\n+        self.assertEqual(len(encodings), 1)\n+        self.assertEqual(encodings[0], 'UTF-8')\n+\n+    def test_precedence(self):\n+        content = '''\n+        <?xml version=\"1.0\" encoding=\"XML\"?>\n+        <meta charset=\"HTML5\">\n+        <meta http-equiv=\"Content-type\" content=\"text/html;charset=HTML4\" />\n+        '''.strip()\n+        encodings = requests.utils.get_encodings_from_content(content)\n+        self.assertEqual(encodings, ['HTML5', 'HTML4', 'XML'])\n+\n+\n class TestCaseInsensitiveDict(unittest.TestCase):\n \n     def test_mapping_init(self):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
