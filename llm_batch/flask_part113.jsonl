{"custom_id": "flask#c49ce2e1eb8b598e724388bead0943837bab8027", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 4 | Methods Changed: 4 | Complexity Δ (Sum/Max): -15/0 | Churn Δ: 8 | Churn Cumulative: 4985 | Contributors (this commit): 46 | Commits (past 90d): 1 | Contributors (cumulative): 46 | DMM Complexity: None\n\nDIFF:\n@@ -431,9 +431,9 @@ def test_session_special_types(app, client):\n         client.get(\"/\")\n         s = flask.session\n         assert s[\"t\"] == (1, 2, 3)\n-        assert type(s[\"b\"]) == bytes\n+        assert type(s[\"b\"]) is bytes\n         assert s[\"b\"] == b\"\\xff\"\n-        assert type(s[\"m\"]) == Markup\n+        assert type(s[\"m\"]) is Markup\n         assert s[\"m\"] == Markup(\"<html>\")\n         assert s[\"u\"] == the_uuid\n         assert s[\"d\"] == now\n@@ -760,7 +760,7 @@ def test_teardown_request_handler_error(app, client):\n \n     @app.teardown_request\n     def teardown_request1(exc):\n-        assert type(exc) == ZeroDivisionError\n+        assert type(exc) is ZeroDivisionError\n         called.append(True)\n         # This raises a new error and blows away sys.exc_info(), so we can\n         # test that all teardown_requests get passed the same original\n@@ -772,7 +772,7 @@ def test_teardown_request_handler_error(app, client):\n \n     @app.teardown_request\n     def teardown_request2(exc):\n-        assert type(exc) == ZeroDivisionError\n+        assert type(exc) is ZeroDivisionError\n         called.append(True)\n         # This raises a new error and blows away sys.exc_info(), so we can\n         # test that all teardown_requests get passed the same original\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#826514b8eb18f6c314cf566630253d35c89e42c3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 4 | Methods Changed: 4 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 8 | Churn Cumulative: 4993 | Contributors (this commit): 46 | Commits (past 90d): 2 | Contributors (cumulative): 46 | DMM Complexity: None\n\nDIFF:\n@@ -431,9 +431,9 @@ def test_session_special_types(app, client):\n         client.get(\"/\")\n         s = flask.session\n         assert s[\"t\"] == (1, 2, 3)\n-        assert type(s[\"b\"]) == bytes\n+        assert type(s[\"b\"]) is bytes\n         assert s[\"b\"] == b\"\\xff\"\n-        assert type(s[\"m\"]) == Markup\n+        assert type(s[\"m\"]) is Markup\n         assert s[\"m\"] == Markup(\"<html>\")\n         assert s[\"u\"] == the_uuid\n         assert s[\"d\"] == now\n@@ -760,7 +760,7 @@ def test_teardown_request_handler_error(app, client):\n \n     @app.teardown_request\n     def teardown_request1(exc):\n-        assert type(exc) == ZeroDivisionError\n+        assert type(exc) is ZeroDivisionError\n         called.append(True)\n         # This raises a new error and blows away sys.exc_info(), so we can\n         # test that all teardown_requests get passed the same original\n@@ -772,7 +772,7 @@ def test_teardown_request_handler_error(app, client):\n \n     @app.teardown_request\n     def teardown_request2(exc):\n-        assert type(exc) == ZeroDivisionError\n+        assert type(exc) is ZeroDivisionError\n         called.append(True)\n         # This raises a new error and blows away sys.exc_info(), so we can\n         # test that all teardown_requests get passed the same original\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#6a12b191f7058a179237b4b3dfc146e559777d9b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 370 | Contributors (this commit): 7 | Commits (past 90d): 2 | Contributors (cumulative): 7 | DMM Complexity: None\n\nDIFF:\n@@ -38,7 +38,7 @@ from .templating import render_template_string as render_template_string\n from .templating import stream_template as stream_template\n from .templating import stream_template_string as stream_template_string\n \n-__version__ = \"2.3.3.dev\"\n+__version__ = \"3.0.0.dev\"\n \n \n def __getattr__(name):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#04994df59f2f642e52ba46ca656088bcdb931262", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 220 | Files Changed: 5 | Hunks: 13 | Methods Changed: 12 | Complexity Δ (Sum/Max): -22/0 | Churn Δ: 221 | Churn Cumulative: 6249 | Contributors (this commit): 37 | Commits (past 90d): 9 | Contributors (cumulative): 56 | DMM Complexity: 0.31210191082802546\n\nDIFF:\n@@ -39,64 +39,3 @@ from .templating import stream_template as stream_template\n from .templating import stream_template_string as stream_template_string\n \n __version__ = \"3.0.0.dev\"\n-\n-\n-def __getattr__(name):\n-    if name == \"_app_ctx_stack\":\n-        import warnings\n-        from .globals import __app_ctx_stack\n-\n-        warnings.warn(\n-            \"'_app_ctx_stack' is deprecated and will be removed in Flask 2.4.\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        return __app_ctx_stack\n-\n-    if name == \"_request_ctx_stack\":\n-        import warnings\n-        from .globals import __request_ctx_stack\n-\n-        warnings.warn(\n-            \"'_request_ctx_stack' is deprecated and will be removed in Flask 2.4.\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        return __request_ctx_stack\n-\n-    if name == \"escape\":\n-        import warnings\n-        from markupsafe import escape\n-\n-        warnings.warn(\n-            \"'flask.escape' is deprecated and will be removed in Flask 2.4. Import\"\n-            \" 'markupsafe.escape' instead.\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        return escape\n-\n-    if name == \"Markup\":\n-        import warnings\n-        from markupsafe import Markup\n-\n-        warnings.warn(\n-            \"'flask.Markup' is deprecated and will be removed in Flask 2.4. Import\"\n-            \" 'markupsafe.Markup' instead.\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        return Markup\n-\n-    if name == \"signals_available\":\n-        import warnings\n-\n-        warnings.warn(\n-            \"'signals_available' is deprecated and will be removed in Flask 2.4.\"\n-            \" Signals are always available\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        return True\n-\n-    raise AttributeError(name)\n\n@@ -572,25 +572,6 @@ class Flask(Scaffold):\n         \"\"\"\n         return self.create_jinja_environment()\n \n-    @property\n-    def got_first_request(self) -> bool:\n-        \"\"\"This attribute is set to ``True`` if the application started\n-        handling the first request.\n-\n-        .. deprecated:: 2.3\n-            Will be removed in Flask 2.4.\n-\n-        .. versionadded:: 0.8\n-        \"\"\"\n-        import warnings\n-\n-        warnings.warn(\n-            \"'got_first_request' is deprecated and will be removed in Flask 2.4.\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        return self._got_first_request\n-\n     def make_config(self, instance_relative: bool = False) -> Config:\n         \"\"\"Used to create the config attribute by the Flask constructor.\n         The `instance_relative` parameter is passed in from the constructor\n\n@@ -14,25 +14,6 @@ if t.TYPE_CHECKING:  # pragma: no cover\n     from .wrappers import Request\n \n \n-class _FakeStack:\n-    def __init__(self, name: str, cv: ContextVar[t.Any]) -> None:\n-        self.name = name\n-        self.cv = cv\n-\n-    @property\n-    def top(self) -> t.Any | None:\n-        import warnings\n-\n-        warnings.warn(\n-            f\"'_{self.name}_ctx_stack' is deprecated and will be removed in Flask 2.4.\"\n-            f\" Use 'g' to store data, or '{self.name}_ctx' to access the current\"\n-            \" context.\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        return self.cv.get(None)\n-\n-\n _no_app_msg = \"\"\"\\\n Working outside of application context.\n \n@@ -41,7 +22,6 @@ the current application. To solve this, set up an application context\n with app.app_context(). See the documentation for more information.\\\n \"\"\"\n _cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\n-__app_ctx_stack = _FakeStack(\"app\", _cv_app)\n app_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n     _cv_app, unbound_message=_no_app_msg\n )\n@@ -60,7 +40,6 @@ an active HTTP request. Consult the documentation on testing for\n information about how to avoid this problem.\\\n \"\"\"\n _cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\n-__request_ctx_stack = _FakeStack(\"request\", _cv_request)\n request_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n     _cv_request, unbound_message=_no_req_msg\n )\n@@ -70,27 +49,3 @@ request: Request = LocalProxy(  # type: ignore[assignment]\n session: SessionMixin = LocalProxy(  # type: ignore[assignment]\n     _cv_request, \"session\", unbound_message=_no_req_msg\n )\n-\n-\n-def __getattr__(name: str) -> t.Any:\n-    if name == \"_app_ctx_stack\":\n-        import warnings\n-\n-        warnings.warn(\n-            \"'_app_ctx_stack' is deprecated and will be removed in Flask 2.4.\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        return __app_ctx_stack\n-\n-    if name == \"_request_ctx_stack\":\n-        import warnings\n-\n-        warnings.warn(\n-            \"'_request_ctx_stack' is deprecated and will be removed in Flask 2.4.\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        return __request_ctx_stack\n-\n-    raise AttributeError(name)\n\n@@ -2,14 +2,11 @@ from __future__ import annotations\n \n import importlib.util\n import os\n-import socket\n import sys\n import typing as t\n-import warnings\n from datetime import datetime\n from functools import lru_cache\n from functools import update_wrapper\n-from threading import RLock\n \n import werkzeug.utils\n from werkzeug.exceptions import abort as _wz_abort\n@@ -492,7 +489,7 @@ def send_file(\n \n     .. versionchanged:: 0.7\n         MIME guessing and etag support for file-like objects was\n-        deprecated because it was unreliable. Pass a filename if you are\n+        removed because it was unreliable. Pass a filename if you are\n         able to, otherwise attach an etag yourself.\n \n     .. versionchanged:: 0.5\n@@ -616,81 +613,6 @@ def get_root_path(import_name: str) -> str:\n     return os.path.dirname(os.path.abspath(filepath))\n \n \n-class locked_cached_property(werkzeug.utils.cached_property):\n-    \"\"\"A :func:`property` that is only evaluated once. Like\n-    :class:`werkzeug.utils.cached_property` except access uses a lock\n-    for thread safety.\n-\n-    .. deprecated:: 2.3\n-        Will be removed in Flask 2.4. Use a lock inside the decorated function if\n-        locking is needed.\n-\n-    .. versionchanged:: 2.0\n-        Inherits from Werkzeug's ``cached_property`` (and ``property``).\n-    \"\"\"\n-\n-    def __init__(\n-        self,\n-        fget: t.Callable[[t.Any], t.Any],\n-        name: str | None = None,\n-        doc: str | None = None,\n-    ) -> None:\n-        import warnings\n-\n-        warnings.warn(\n-            \"'locked_cached_property' is deprecated and will be removed in Flask 2.4.\"\n-            \" Use a lock inside the decorated function if locking is needed.\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        super().__init__(fget, name=name, doc=doc)\n-        self.lock = RLock()\n-\n-    def __get__(self, obj: object, type: type = None) -> t.Any:  # type: ignore\n-        if obj is None:\n-            return self\n-\n-        with self.lock:\n-            return super().__get__(obj, type=type)\n-\n-    def __set__(self, obj: object, value: t.Any) -> None:\n-        with self.lock:\n-            super().__set__(obj, value)\n-\n-    def __delete__(self, obj: object) -> None:\n-        with self.lock:\n-            super().__delete__(obj)\n-\n-\n-def is_ip(value: str) -> bool:\n-    \"\"\"Determine if the given string is an IP address.\n-\n-    :param value: value to check\n-    :type value: str\n-\n-    :return: True if string is an IP address\n-    :rtype: bool\n-\n-    .. deprecated:: 2.3\n-        Will be removed in Flask 2.4.\n-    \"\"\"\n-    warnings.warn(\n-        \"The 'is_ip' function is deprecated and will be removed in Flask 2.4.\",\n-        DeprecationWarning,\n-        stacklevel=2,\n-    )\n-\n-    for family in (socket.AF_INET, socket.AF_INET6):\n-        try:\n-            socket.inet_pton(family, value)\n-        except OSError:\n-            pass\n-        else:\n-            return True\n-\n-    return False\n-\n-\n @lru_cache(maxsize=None)\n def _split_blueprint_path(name: str) -> list[str]:\n     out: list[str] = [name]\n\n@@ -1,8 +1,5 @@\n from __future__ import annotations\n \n-import typing as t\n-import warnings\n-\n from blinker import Namespace\n \n # This namespace is only for signals provided by Flask itself.\n@@ -18,16 +15,3 @@ appcontext_tearing_down = _signals.signal(\"appcontext-tearing-down\")\n appcontext_pushed = _signals.signal(\"appcontext-pushed\")\n appcontext_popped = _signals.signal(\"appcontext-popped\")\n message_flashed = _signals.signal(\"message-flashed\")\n-\n-\n-def __getattr__(name: str) -> t.Any:\n-    if name == \"signals_available\":\n-        warnings.warn(\n-            \"The 'signals_available' attribute is deprecated and will be removed in\"\n-            \" Flask 2.4. Signals are always available.\",\n-            DeprecationWarning,\n-            stacklevel=2,\n-        )\n-        return True\n-\n-    raise AttributeError(name)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#a64588f87a2bd7ba557814ec039e3b2af2ce842d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 0 | Files Changed: 3 | Hunks: 0 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 0 | Churn Cumulative: 0 | Contributors (this commit): 1 | Commits (past 90d): 3 | Contributors (cumulative): 3 | DMM Complexity: None\n\nDIFF:\n\n\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#0ec7f713d679ceed2c605e62ac5d38d579f29fa0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1620 | Lines Deleted: 1351 | Files Changed: 10 | Hunks: 57 | Methods Changed: 91 | Complexity Δ (Sum/Max): 81/81 | Churn Δ: 2971 | Churn Cumulative: 9012 | Contributors (this commit): 37 | Commits (past 90d): 38 | Contributors (cumulative): 66 | DMM Complexity: 0.9821428571428571\n\nDIFF:\n@@ -1,7 +1,5 @@\n from . import json as json\n from .app import Flask as Flask\n-from .app import Request as Request\n-from .app import Response as Response\n from .blueprints import Blueprint as Blueprint\n from .config import Config as Config\n from .ctx import after_this_request as after_this_request\n@@ -37,5 +35,7 @@ from .templating import render_template as render_template\n from .templating import render_template_string as render_template_string\n from .templating import stream_template as stream_template\n from .templating import stream_template_string as stream_template_string\n+from .wrappers import Request as Request\n+from .wrappers import Response as Response\n \n __version__ = \"3.0.0.dev\"\n\n@@ -0,0 +1,1478 @@\n+from __future__ import annotations\n+\n+import os\n+import sys\n+import typing as t\n+import weakref\n+from collections.abc import Iterator as _abc_Iterator\n+from datetime import timedelta\n+from inspect import iscoroutinefunction\n+from itertools import chain\n+from types import TracebackType\n+from urllib.parse import quote as _url_quote\n+\n+import click\n+from werkzeug.datastructures import Headers\n+from werkzeug.datastructures import ImmutableDict\n+from werkzeug.exceptions import BadRequestKeyError\n+from werkzeug.exceptions import HTTPException\n+from werkzeug.exceptions import InternalServerError\n+from werkzeug.routing import BuildError\n+from werkzeug.routing import MapAdapter\n+from werkzeug.routing import RequestRedirect\n+from werkzeug.routing import RoutingException\n+from werkzeug.routing import Rule\n+from werkzeug.serving import is_running_from_reloader\n+from werkzeug.wrappers import Response as BaseResponse\n+\n+from . import cli\n+from . import typing as ft\n+from .ctx import AppContext\n+from .ctx import RequestContext\n+from .globals import _cv_app\n+from .globals import _cv_request\n+from .globals import current_app\n+from .globals import g\n+from .globals import request\n+from .globals import request_ctx\n+from .globals import session\n+from .helpers import get_debug_flag\n+from .helpers import get_flashed_messages\n+from .helpers import get_load_dotenv\n+from .helpers import send_from_directory\n+from .sansio.app import App\n+from .sansio.scaffold import _sentinel\n+from .sessions import SecureCookieSessionInterface\n+from .sessions import SessionInterface\n+from .signals import appcontext_tearing_down\n+from .signals import got_request_exception\n+from .signals import request_finished\n+from .signals import request_started\n+from .signals import request_tearing_down\n+from .templating import Environment\n+from .wrappers import Request\n+from .wrappers import Response\n+\n+if t.TYPE_CHECKING:  # pragma: no cover\n+    from .testing import FlaskClient\n+    from .testing import FlaskCliRunner\n+\n+T_shell_context_processor = t.TypeVar(\n+    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n+)\n+T_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\n+T_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\n+T_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\n+T_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n+\n+\n+def _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n+    if value is None or isinstance(value, timedelta):\n+        return value\n+\n+    return timedelta(seconds=value)\n+\n+\n+class Flask(App):\n+    \"\"\"The flask object implements a WSGI application and acts as the central\n+    object.  It is passed the name of the module or package of the\n+    application.  Once it is created it will act as a central registry for\n+    the view functions, the URL rules, template configuration and much more.\n+\n+    The name of the package is used to resolve resources from inside the\n+    package or the folder the module is contained in depending on if the\n+    package parameter resolves to an actual python package (a folder with\n+    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n+\n+    For more information about resource loading, see :func:`open_resource`.\n+\n+    Usually you create a :class:`Flask` instance in your main module or\n+    in the :file:`__init__.py` file of your package like this::\n+\n+        from flask import Flask\n+        app = Flask(__name__)\n+\n+    .. admonition:: About the First Parameter\n+\n+        The idea of the first parameter is to give Flask an idea of what\n+        belongs to your application.  This name is used to find resources\n+        on the filesystem, can be used by extensions to improve debugging\n+        information and a lot more.\n+\n+        So it's important what you provide there.  If you are using a single\n+        module, `__name__` is always the correct value.  If you however are\n+        using a package, it's usually recommended to hardcode the name of\n+        your package there.\n+\n+        For example if your application is defined in :file:`yourapplication/app.py`\n+        you should create it with one of the two versions below::\n+\n+            app = Flask('yourapplication')\n+            app = Flask(__name__.split('.')[0])\n+\n+        Why is that?  The application will work even with `__name__`, thanks\n+        to how resources are looked up.  However it will make debugging more\n+        painful.  Certain extensions can make assumptions based on the\n+        import name of your application.  For example the Flask-SQLAlchemy\n+        extension will look for the code in your application that triggered\n+        an SQL query in debug mode.  If the import name is not properly set\n+        up, that debugging information is lost.  (For example it would only\n+        pick up SQL queries in `yourapplication.app` and not\n+        `yourapplication.views.frontend`)\n+\n+    .. versionadded:: 0.7\n+       The `static_url_path`, `static_folder`, and `template_folder`\n+       parameters were added.\n+\n+    .. versionadded:: 0.8\n+       The `instance_path` and `instance_relative_config` parameters were\n+       added.\n+\n+    .. versionadded:: 0.11\n+       The `root_path` parameter was added.\n+\n+    .. versionadded:: 1.0\n+       The ``host_matching`` and ``static_host`` parameters were added.\n+\n+    .. versionadded:: 1.0\n+       The ``subdomain_matching`` parameter was added. Subdomain\n+       matching needs to be enabled manually now. Setting\n+       :data:`SERVER_NAME` does not implicitly enable it.\n+\n+    :param import_name: the name of the application package\n+    :param static_url_path: can be used to specify a different path for the\n+                            static files on the web.  Defaults to the name\n+                            of the `static_folder` folder.\n+    :param static_folder: The folder with static files that is served at\n+        ``static_url_path``. Relative to the application ``root_path``\n+        or an absolute path. Defaults to ``'static'``.\n+    :param static_host: the host to use when adding the static route.\n+        Defaults to None. Required when using ``host_matching=True``\n+        with a ``static_folder`` configured.\n+    :param host_matching: set ``url_map.host_matching`` attribute.\n+        Defaults to False.\n+    :param subdomain_matching: consider the subdomain relative to\n+        :data:`SERVER_NAME` when matching routes. Defaults to False.\n+    :param template_folder: the folder that contains the templates that should\n+                            be used by the application.  Defaults to\n+                            ``'templates'`` folder in the root path of the\n+                            application.\n+    :param instance_path: An alternative instance path for the application.\n+                          By default the folder ``'instance'`` next to the\n+                          package or module is assumed to be the instance\n+                          path.\n+    :param instance_relative_config: if set to ``True`` relative filenames\n+                                     for loading the config are assumed to\n+                                     be relative to the instance path instead\n+                                     of the application root.\n+    :param root_path: The path to the root of the application files.\n+        This should only be set manually when it can't be detected\n+        automatically, such as for namespace packages.\n+    \"\"\"\n+\n+    default_config = ImmutableDict(\n+        {\n+            \"DEBUG\": None,\n+            \"TESTING\": False,\n+            \"PROPAGATE_EXCEPTIONS\": None,\n+            \"SECRET_KEY\": None,\n+            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n+            \"USE_X_SENDFILE\": False,\n+            \"SERVER_NAME\": None,\n+            \"APPLICATION_ROOT\": \"/\",\n+            \"SESSION_COOKIE_NAME\": \"session\",\n+            \"SESSION_COOKIE_DOMAIN\": None,\n+            \"SESSION_COOKIE_PATH\": None,\n+            \"SESSION_COOKIE_HTTPONLY\": True,\n+            \"SESSION_COOKIE_SECURE\": False,\n+            \"SESSION_COOKIE_SAMESITE\": None,\n+            \"SESSION_REFRESH_EACH_REQUEST\": True,\n+            \"MAX_CONTENT_LENGTH\": None,\n+            \"SEND_FILE_MAX_AGE_DEFAULT\": None,\n+            \"TRAP_BAD_REQUEST_ERRORS\": None,\n+            \"TRAP_HTTP_EXCEPTIONS\": False,\n+            \"EXPLAIN_TEMPLATE_LOADING\": False,\n+            \"PREFERRED_URL_SCHEME\": \"http\",\n+            \"TEMPLATES_AUTO_RELOAD\": None,\n+            \"MAX_COOKIE_SIZE\": 4093,\n+        }\n+    )\n+\n+    #: The class that is used for request objects.  See :class:`~flask.Request`\n+    #: for more information.\n+    request_class = Request\n+\n+    #: The class that is used for response objects.  See\n+    #: :class:`~flask.Response` for more information.\n+    response_class = Response\n+\n+    #: the session interface to use.  By default an instance of\n+    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n+    #:\n+    #: .. versionadded:: 0.8\n+    session_interface: SessionInterface = SecureCookieSessionInterface()\n+\n+    def __init__(\n+        self,\n+        import_name: str,\n+        static_url_path: str | None = None,\n+        static_folder: str | os.PathLike | None = \"static\",\n+        static_host: str | None = None,\n+        host_matching: bool = False,\n+        subdomain_matching: bool = False,\n+        template_folder: str | os.PathLike | None = \"templates\",\n+        instance_path: str | None = None,\n+        instance_relative_config: bool = False,\n+        root_path: str | None = None,\n+    ):\n+        super().__init__(\n+            import_name=import_name,\n+            static_url_path=static_url_path,\n+            static_folder=static_folder,\n+            static_host=static_host,\n+            host_matching=host_matching,\n+            subdomain_matching=subdomain_matching,\n+            template_folder=template_folder,\n+            instance_path=instance_path,\n+            instance_relative_config=instance_relative_config,\n+            root_path=root_path,\n+        )\n+\n+        # Add a static route using the provided static_url_path, static_host,\n+        # and static_folder if there is a configured static_folder.\n+        # Note we do this without checking if static_folder exists.\n+        # For one, it might be created while the server is running (e.g. during\n+        # development). Also, Google App Engine stores static files somewhere\n+        if self.has_static_folder:\n+            assert (\n+                bool(static_host) == host_matching\n+            ), \"Invalid static_host/host_matching combination\"\n+            # Use a weakref to avoid creating a reference cycle between the app\n+            # and the view function (see #3761).\n+            self_ref = weakref.ref(self)\n+            self.add_url_rule(\n+                f\"{self.static_url_path}/<path:filename>\",\n+                endpoint=\"static\",\n+                host=static_host,\n+                view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n+            )\n+\n+    def get_send_file_max_age(self, filename: str | None) -> int | None:\n+        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n+        value for a given file path if it wasn't passed.\n+\n+        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n+        the configuration of :data:`~flask.current_app`. This defaults\n+        to ``None``, which tells the browser to use conditional requests\n+        instead of a timed cache, which is usually preferable.\n+\n+        Note this is a duplicate of the same method in the Flask\n+        class.\n+\n+        .. versionchanged:: 2.0\n+            The default configuration is ``None`` instead of 12 hours.\n+\n+        .. versionadded:: 0.9\n+        \"\"\"\n+        value = current_app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n+\n+        if value is None:\n+            return None\n+\n+        if isinstance(value, timedelta):\n+            return int(value.total_seconds())\n+\n+        return value\n+\n+    def send_static_file(self, filename: str) -> Response:\n+        \"\"\"The view function used to serve files from\n+        :attr:`static_folder`. A route is automatically registered for\n+        this view at :attr:`static_url_path` if :attr:`static_folder` is\n+        set.\n+\n+        Note this is a duplicate of the same method in the Flask\n+        class.\n+\n+        .. versionadded:: 0.5\n+\n+        \"\"\"\n+        if not self.has_static_folder:\n+            raise RuntimeError(\"'static_folder' must be set to serve static_files.\")\n+\n+        # send_file only knows to call get_send_file_max_age on the app,\n+        # call it here so it works for blueprints too.\n+        max_age = self.get_send_file_max_age(filename)\n+        return send_from_directory(\n+            t.cast(str, self.static_folder), filename, max_age=max_age\n+        )\n+\n+    def open_resource(self, resource: str, mode: str = \"rb\") -> t.IO[t.AnyStr]:\n+        \"\"\"Open a resource file relative to :attr:`root_path` for\n+        reading.\n+\n+        For example, if the file ``schema.sql`` is next to the file\n+        ``app.py`` where the ``Flask`` app is defined, it can be opened\n+        with:\n+\n+        .. code-block:: python\n+\n+            with app.open_resource(\"schema.sql\") as f:\n+                conn.executescript(f.read())\n+\n+        :param resource: Path to the resource relative to\n+            :attr:`root_path`.\n+        :param mode: Open the file in this mode. Only reading is\n+            supported, valid values are \"r\" (or \"rt\") and \"rb\".\n+\n+        Note this is a duplicate of the same method in the Flask\n+        class.\n+\n+        \"\"\"\n+        if mode not in {\"r\", \"rt\", \"rb\"}:\n+            raise ValueError(\"Resources can only be opened for reading.\")\n+\n+        return open(os.path.join(self.root_path, resource), mode)\n+\n+    def open_instance_resource(self, resource: str, mode: str = \"rb\") -> t.IO[t.AnyStr]:\n+        \"\"\"Opens a resource from the application's instance folder\n+        (:attr:`instance_path`).  Otherwise works like\n+        :meth:`open_resource`.  Instance resources can also be opened for\n+        writing.\n+\n+        :param resource: the name of the resource.  To access resources within\n+                         subfolders use forward slashes as separator.\n+        :param mode: resource file opening mode, default is 'rb'.\n+        \"\"\"\n+        return open(os.path.join(self.instance_path, resource), mode)\n+\n+    def create_jinja_environment(self) -> Environment:\n+        \"\"\"Create the Jinja environment based on :attr:`jinja_options`\n+        and the various Jinja-related methods of the app. Changing\n+        :attr:`jinja_options` after this will have no effect. Also adds\n+        Flask-related globals and filters to the environment.\n+\n+        .. versionchanged:: 0.11\n+           ``Environment.auto_reload`` set in accordance with\n+           ``TEMPLATES_AUTO_RELOAD`` configuration option.\n+\n+        .. versionadded:: 0.5\n+        \"\"\"\n+        options = dict(self.jinja_options)\n+\n+        if \"autoescape\" not in options:\n+            options[\"autoescape\"] = self.select_jinja_autoescape\n+\n+        if \"auto_reload\" not in options:\n+            auto_reload = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n+\n+            if auto_reload is None:\n+                auto_reload = self.debug\n+\n+            options[\"auto_reload\"] = auto_reload\n+\n+        rv = self.jinja_environment(self, **options)\n+        rv.globals.update(\n+            url_for=self.url_for,\n+            get_flashed_messages=get_flashed_messages,\n+            config=self.config,\n+            # request, session and g are normally added with the\n+            # context processor for efficiency reasons but for imported\n+            # templates we also want the proxies in there.\n+            request=request,\n+            session=session,\n+            g=g,\n+        )\n+        rv.policies[\"json.dumps_function\"] = self.json.dumps\n+        return rv\n+\n+    def create_url_adapter(self, request: Request | None) -> MapAdapter | None:\n+        \"\"\"Creates a URL adapter for the given request. The URL adapter\n+        is created at a point where the request context is not yet set\n+        up so the request is passed explicitly.\n+\n+        .. versionadded:: 0.6\n+\n+        .. versionchanged:: 0.9\n+           This can now also be called without a request object when the\n+           URL adapter is created for the application context.\n+\n+        .. versionchanged:: 1.0\n+            :data:`SERVER_NAME` no longer implicitly enables subdomain\n+            matching. Use :attr:`subdomain_matching` instead.\n+        \"\"\"\n+        if request is not None:\n+            # If subdomain matching is disabled (the default), use the\n+            # default subdomain in all cases. This should be the default\n+            # in Werkzeug but it currently does not have that feature.\n+            if not self.subdomain_matching:\n+                subdomain = self.url_map.default_subdomain or None\n+            else:\n+                subdomain = None\n+\n+            print(self.config[\"SERVER_NAME\"], subdomain)\n+            return self.url_map.bind_to_environ(\n+                request.environ,\n+                server_name=self.config[\"SERVER_NAME\"],\n+                subdomain=subdomain,\n+            )\n+        # We need at the very least the server name to be set for this\n+        # to work.\n+        if self.config[\"SERVER_NAME\"] is not None:\n+            return self.url_map.bind(\n+                self.config[\"SERVER_NAME\"],\n+                script_name=self.config[\"APPLICATION_ROOT\"],\n+                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n+            )\n+\n+        return None\n+\n+    def raise_routing_exception(self, request: Request) -> t.NoReturn:\n+        \"\"\"Intercept routing exceptions and possibly do something else.\n+\n+        In debug mode, intercept a routing redirect and replace it with\n+        an error if the body will be discarded.\n+\n+        With modern Werkzeug this shouldn't occur, since it now uses a\n+        308 status which tells the browser to resend the method and\n+        body.\n+\n+        .. versionchanged:: 2.1\n+            Don't intercept 307 and 308 redirects.\n+\n+        :meta private:\n+        :internal:\n+        \"\"\"\n+        if (\n+            not self.debug\n+            or not isinstance(request.routing_exception, RequestRedirect)\n+            or request.routing_exception.code in {307, 308}\n+            or request.method in {\"GET\", \"HEAD\", \"OPTIONS\"}\n+        ):\n+            raise request.routing_exception  # type: ignore\n+\n+        from .debughelpers import FormDataRoutingRedirect\n+\n+        raise FormDataRoutingRedirect(request)\n+\n+    def update_template_context(self, context: dict) -> None:\n+        \"\"\"Update the template context with some commonly used variables.\n+        This injects request, session, config and g into the template\n+        context as well as everything template context processors want\n+        to inject.  Note that the as of Flask 0.6, the original values\n+        in the context will not be overridden if a context processor\n+        decides to return a value with the same key.\n+\n+        :param context: the context as a dictionary that is updated in place\n+                        to add extra variables.\n+        \"\"\"\n+        names: t.Iterable[str | None] = (None,)\n+\n+        # A template may be rendered outside a request context.\n+        if request:\n+            names = chain(names, reversed(request.blueprints))\n+\n+        # The values passed to render_template take precedence. Keep a\n+        # copy to re-apply after all context functions.\n+        orig_ctx = context.copy()\n+\n+        for name in names:\n+            if name in self.template_context_processors:\n+                for func in self.template_context_processors[name]:\n+                    context.update(func())\n+\n+        context.update(orig_ctx)\n+\n+    def make_shell_context(self) -> dict:\n+        \"\"\"Returns the shell context for an interactive shell for this\n+        application.  This runs all the registered shell context\n+        processors.\n+\n+        .. versionadded:: 0.11\n+        \"\"\"\n+        rv = {\"app\": self, \"g\": g}\n+        for processor in self.shell_context_processors:\n+            rv.update(processor())\n+        return rv\n+\n+    def run(\n+        self,\n+        host: str | None = None,\n+        port: int | None = None,\n+        debug: bool | None = None,\n+        load_dotenv: bool = True,\n+        **options: t.Any,\n+    ) -> None:\n+        \"\"\"Runs the application on a local development server.\n+\n+        Do not use ``run()`` in a production setting. It is not intended to\n+        meet security and performance requirements for a production server.\n+        Instead, see :doc:`/deploying/index` for WSGI server recommendations.\n+\n+        If the :attr:`debug` flag is set the server will automatically reload\n+        for code changes and show a debugger in case an exception happened.\n+\n+        If you want to run the application in debug mode, but disable the\n+        code execution on the interactive debugger, you can pass\n+        ``use_evalex=False`` as parameter.  This will keep the debugger's\n+        traceback screen active, but disable code execution.\n+\n+        It is not recommended to use this function for development with\n+        automatic reloading as this is badly supported.  Instead you should\n+        be using the :command:`flask` command line script's ``run`` support.\n+\n+        .. admonition:: Keep in Mind\n+\n+           Flask will suppress any server error with a generic error page\n+           unless it is in debug mode.  As such to enable just the\n+           interactive debugger without the code reloading, you have to\n+           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n+           Setting ``use_debugger`` to ``True`` without being in debug mode\n+           won't catch any exceptions because there won't be any to\n+           catch.\n+\n+        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n+            have the server available externally as well. Defaults to\n+            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n+            if present.\n+        :param port: the port of the webserver. Defaults to ``5000`` or the\n+            port defined in the ``SERVER_NAME`` config variable if present.\n+        :param debug: if given, enable or disable debug mode. See\n+            :attr:`debug`.\n+        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n+            files to set environment variables. Will also change the working\n+            directory to the directory containing the first file found.\n+        :param options: the options to be forwarded to the underlying Werkzeug\n+            server. See :func:`werkzeug.serving.run_simple` for more\n+            information.\n+\n+        .. versionchanged:: 1.0\n+            If installed, python-dotenv will be used to load environment\n+            variables from :file:`.env` and :file:`.flaskenv` files.\n+\n+            The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.\n+\n+            Threaded mode is enabled by default.\n+\n+        .. versionchanged:: 0.10\n+            The default port is now picked from the ``SERVER_NAME``\n+            variable.\n+        \"\"\"\n+        # Ignore this call so that it doesn't start another server if\n+        # the 'flask run' command is used.\n+        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n+            if not is_running_from_reloader():\n+                click.secho(\n+                    \" * Ignoring a call to 'app.run()' that would block\"\n+                    \" the current 'flask' CLI command.\\n\"\n+                    \"   Only call 'app.run()' in an 'if __name__ ==\"\n+                    ' \"__main__\"\\' guard.',\n+                    fg=\"red\",\n+                )\n+\n+            return\n+\n+        if get_load_dotenv(load_dotenv):\n+            cli.load_dotenv()\n+\n+            # if set, env var overrides existing value\n+            if \"FLASK_DEBUG\" in os.environ:\n+                self.debug = get_debug_flag()\n+\n+        # debug passed to method overrides all other sources\n+        if debug is not None:\n+            self.debug = bool(debug)\n+\n+        server_name = self.config.get(\"SERVER_NAME\")\n+        sn_host = sn_port = None\n+\n+        if server_name:\n+            sn_host, _, sn_port = server_name.partition(\":\")\n+\n+        if not host:\n+            if sn_host:\n+                host = sn_host\n+            else:\n+                host = \"127.0.0.1\"\n+\n+        if port or port == 0:\n+            port = int(port)\n+        elif sn_port:\n+            port = int(sn_port)\n+        else:\n+            port = 5000\n+\n+        options.setdefault(\"use_reloader\", self.debug)\n+        options.setdefault(\"use_debugger\", self.debug)\n+        options.setdefault(\"threaded\", True)\n+\n+        cli.show_server_banner(self.debug, self.name)\n+\n+        from werkzeug.serving import run_simple\n+\n+        try:\n+            run_simple(t.cast(str, host), port, self, **options)\n+        finally:\n+            # reset the first request information if the development server\n+            # reset normally.  This makes it possible to restart the server\n+            # without reloader and that stuff from an interactive shell.\n+            self._got_first_request = False\n+\n+    def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> FlaskClient:\n+        \"\"\"Creates a test client for this application.  For information\n+        about unit testing head over to :doc:`/testing`.\n+\n+        Note that if you are testing for assertions or exceptions in your\n+        application code, you must set ``app.testing = True`` in order for the\n+        exceptions to propagate to the test client.  Otherwise, the exception\n+        will be handled by the application (not visible to the test client) and\n+        the only indication of an AssertionError or other exception will be a\n+        500 status code response to the test client.  See the :attr:`testing`\n+        attribute.  For example::\n+\n+            app.testing = True\n+            client = app.test_client()\n+\n+        The test client can be used in a ``with`` block to defer the closing down\n+        of the context until the end of the ``with`` block.  This is useful if\n+        you want to access the context locals for testing::\n+\n+            with app.test_client() as c:\n+                rv = c.get('/?vodka=42')\n+                assert request.args['vodka'] == '42'\n+\n+        Additionally, you may pass optional keyword arguments that will then\n+        be passed to the application's :attr:`test_client_class` constructor.\n+        For example::\n+\n+            from flask.testing import FlaskClient\n+\n+            class CustomClient(FlaskClient):\n+                def __init__(self, *args, **kwargs):\n+                    self._authentication = kwargs.pop(\"authentication\")\n+                    super(CustomClient,self).__init__( *args, **kwargs)\n+\n+            app.test_client_class = CustomClient\n+            client = app.test_client(authentication='Basic ....')\n+\n+        See :class:`~flask.testing.FlaskClient` for more information.\n+\n+        .. versionchanged:: 0.4\n+           added support for ``with`` block usage for the client.\n+\n+        .. versionadded:: 0.7\n+           The `use_cookies` parameter was added as well as the ability\n+           to override the client to be used by setting the\n+           :attr:`test_client_class` attribute.\n+\n+        .. versionchanged:: 0.11\n+           Added `**kwargs` to support passing additional keyword arguments to\n+           the constructor of :attr:`test_client_class`.\n+        \"\"\"\n+        cls = self.test_client_class\n+        if cls is None:\n+            from .testing import FlaskClient as cls\n+        return cls(  # type: ignore\n+            self, self.response_class, use_cookies=use_cookies, **kwargs\n+        )\n+\n+    def test_cli_runner(self, **kwargs: t.Any) -> FlaskCliRunner:\n+        \"\"\"Create a CLI runner for testing CLI commands.\n+        See :ref:`testing-cli`.\n+\n+        Returns an instance of :attr:`test_cli_runner_class`, by default\n+        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is\n+        passed as the first argument.\n+\n+        .. versionadded:: 1.0\n+        \"\"\"\n+        cls = self.test_cli_runner_class\n+\n+        if cls is None:\n+            from .testing import FlaskCliRunner as cls\n+\n+        return cls(self, **kwargs)  # type: ignore\n+\n+    def handle_http_exception(\n+        self, e: HTTPException\n+    ) -> HTTPException | ft.ResponseReturnValue:\n+        \"\"\"Handles an HTTP exception.  By default this will invoke the\n+        registered error handlers and fall back to returning the\n+        exception as response.\n+\n+        .. versionchanged:: 1.0.3\n+            ``RoutingException``, used internally for actions such as\n+             slash redirects during routing, is not passed to error\n+             handlers.\n+\n+        .. versionchanged:: 1.0\n+            Exceptions are looked up by code *and* by MRO, so\n+            ``HTTPException`` subclasses can be handled with a catch-all\n+            handler for the base ``HTTPException``.\n+\n+        .. versionadded:: 0.3\n+        \"\"\"\n+        # Proxy exceptions don't have error codes.  We want to always return\n+        # those unchanged as errors\n+        if e.code is None:\n+            return e\n+\n+        # RoutingExceptions are used internally to trigger routing\n+        # actions, such as slash redirects raising RequestRedirect. They\n+        # are not raised or handled in user code.\n+        if isinstance(e, RoutingException):\n+            return e\n+\n+        handler = self._find_error_handler(e, request.blueprints)\n+        if handler is None:\n+            return e\n+        return self.ensure_sync(handler)(e)\n+\n+    def handle_user_exception(\n+        self, e: Exception\n+    ) -> HTTPException | ft.ResponseReturnValue:\n+        \"\"\"This method is called whenever an exception occurs that\n+        should be handled. A special case is :class:`~werkzeug\n+        .exceptions.HTTPException` which is forwarded to the\n+        :meth:`handle_http_exception` method. This function will either\n+        return a response value or reraise the exception with the same\n+        traceback.\n+\n+        .. versionchanged:: 1.0\n+            Key errors raised from request data like ``form`` show the\n+            bad key in debug mode rather than a generic bad request\n+            message.\n+\n+        .. versionadded:: 0.7\n+        \"\"\"\n+        if isinstance(e, BadRequestKeyError) and (\n+            self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n+        ):\n+            e.show_exception = True\n+\n+        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n+            return self.handle_http_exception(e)\n+\n+        handler = self._find_error_handler(e, request.blueprints)\n+\n+        if handler is None:\n+            raise\n+\n+        return self.ensure_sync(handler)(e)\n+\n+    def handle_exception(self, e: Exception) -> Response:\n+        \"\"\"Handle an exception that did not have an error handler\n+        associated with it, or that was raised from an error handler.\n+        This always causes a 500 ``InternalServerError``.\n+\n+        Always sends the :data:`got_request_exception` signal.\n+\n+        If :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug\n+        mode, the error will be re-raised so that the debugger can\n+        display it. Otherwise, the original exception is logged, and\n+        an :exc:`~werkzeug.exceptions.InternalServerError` is returned.\n+\n+        If an error handler is registered for ``InternalServerError`` or\n+        ``500``, it will be used. For consistency, the handler will\n+        always receive the ``InternalServerError``. The original\n+        unhandled exception is available as ``e.original_exception``.\n+\n+        .. versionchanged:: 1.1.0\n+            Always passes the ``InternalServerError`` instance to the\n+            handler, setting ``original_exception`` to the unhandled\n+            error.\n+\n+        .. versionchanged:: 1.1.0\n+            ``after_request`` functions and other finalization is done\n+            even for the default 500 response when there is no handler.\n+\n+        .. versionadded:: 0.3\n+        \"\"\"\n+        exc_info = sys.exc_info()\n+        got_request_exception.send(self, _async_wrapper=self.ensure_sync, exception=e)\n+        propagate = self.config[\"PROPAGATE_EXCEPTIONS\"]\n+\n+        if propagate is None:\n+            propagate = self.testing or self.debug\n+\n+        if propagate:\n+            # Re-raise if called with an active exception, otherwise\n+            # raise the passed in exception.\n+            if exc_info[1] is e:\n+                raise\n+\n+            raise e\n+\n+        self.log_exception(exc_info)\n+        server_error: InternalServerError | ft.ResponseReturnValue\n+        server_error = InternalServerError(original_exception=e)\n+        handler = self._find_error_handler(server_error, request.blueprints)\n+\n+        if handler is not None:\n+            server_error = self.ensure_sync(handler)(server_error)\n+\n+        return self.finalize_request(server_error, from_error_handler=True)\n+\n+    def log_exception(\n+        self,\n+        exc_info: (tuple[type, BaseException, TracebackType] | tuple[None, None, None]),\n+    ) -> None:\n+        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n+        if debugging is disabled and right before the handler is called.\n+        The default implementation logs the exception as error on the\n+        :attr:`logger`.\n+\n+        .. versionadded:: 0.8\n+        \"\"\"\n+        self.logger.error(\n+            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n+        )\n+\n+    def dispatch_request(self) -> ft.ResponseReturnValue:\n+        \"\"\"Does the request dispatching.  Matches the URL and returns the\n+        return value of the view or error handler.  This does not have to\n+        be a response object.  In order to convert the return value to a\n+        proper response object, call :func:`make_response`.\n+\n+        .. versionchanged:: 0.7\n+           This no longer does the exception handling, this code was\n+           moved to the new :meth:`full_dispatch_request`.\n+        \"\"\"\n+        req = request_ctx.request\n+        if req.routing_exception is not None:\n+            self.raise_routing_exception(req)\n+        rule: Rule = req.url_rule  # type: ignore[assignment]\n+        # if we provide automatic options for this URL and the\n+        # request came with the OPTIONS method, reply automatically\n+        if (\n+            getattr(rule, \"provide_automatic_options\", False)\n+            and req.method == \"OPTIONS\"\n+        ):\n+            return self.make_default_options_response()\n+        # otherwise dispatch to the handler for that endpoint\n+        view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]\n+        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)\n+\n+    def full_dispatch_request(self) -> Response:\n+        \"\"\"Dispatches the request and on top of that performs request\n+        pre and postprocessing as well as HTTP exception catching and\n+        error handling.\n+\n+        .. versionadded:: 0.7\n+        \"\"\"\n+        self._got_first_request = True\n+\n+        try:\n+            request_started.send(self, _async_wrapper=self.ensure_sync)\n+            rv = self.preprocess_request()\n+            if rv is None:\n+                rv = self.dispatch_request()\n+        except Exception as e:\n+            rv = self.handle_user_exception(e)\n+        return self.finalize_request(rv)\n+\n+    def finalize_request(\n+        self,\n+        rv: ft.ResponseReturnValue | HTTPException,\n+        from_error_handler: bool = False,\n+    ) -> Response:\n+        \"\"\"Given the return value from a view function this finalizes\n+        the request by converting it into a response and invoking the\n+        postprocessing functions.  This is invoked for both normal\n+        request dispatching as well as error handlers.\n+\n+        Because this means that it might be called as a result of a\n+        failure a special safe mode is available which can be enabled\n+        with the `from_error_handler` flag.  If enabled, failures in\n+        response processing will be logged and otherwise ignored.\n+\n+        :internal:\n+        \"\"\"\n+        response = self.make_response(rv)\n+        try:\n+            response = self.process_response(response)\n+            request_finished.send(\n+                self, _async_wrapper=self.ensure_sync, response=response\n+            )\n+        except Exception:\n+            if not from_error_handler:\n+                raise\n+            self.logger.exception(\n+                \"Request finalizing failed with an error while handling an error\"\n+            )\n+        return response\n+\n+    def make_default_options_response(self) -> Response:\n+        \"\"\"This method is called to create the default ``OPTIONS`` response.\n+        This can be changed through subclassing to change the default\n+        behavior of ``OPTIONS`` responses.\n+\n+        .. versionadded:: 0.7\n+        \"\"\"\n+        adapter = request_ctx.url_adapter\n+        methods = adapter.allowed_methods()  # type: ignore[union-attr]\n+        rv = self.response_class()\n+        rv.allow.update(methods)\n+        return rv\n+\n+    def ensure_sync(self, func: t.Callable) -> t.Callable:\n+        \"\"\"Ensure that the function is synchronous for WSGI workers.\n+        Plain ``def`` functions are returned as-is. ``async def``\n+        functions are wrapped to run and wait for the response.\n+\n+        Override this method to change how the app runs async views.\n+\n+        .. versionadded:: 2.0\n+        \"\"\"\n+        if iscoroutinefunction(func):\n+            return self.async_to_sync(func)\n+\n+        return func\n+\n+    def async_to_sync(\n+        self, func: t.Callable[..., t.Coroutine]\n+    ) -> t.Callable[..., t.Any]:\n+        \"\"\"Return a sync function that will run the coroutine function.\n+\n+        .. code-block:: python\n+\n+            result = app.async_to_sync(func)(*args, **kwargs)\n+\n+        Override this method to change how the app converts async code\n+        to be synchronously callable.\n+\n+        .. versionadded:: 2.0\n+        \"\"\"\n+        try:\n+            from asgiref.sync import async_to_sync as asgiref_async_to_sync\n+        except ImportError:\n+            raise RuntimeError(\n+                \"Install Flask with the 'async' extra in order to use async views.\"\n+            ) from None\n+\n+        return asgiref_async_to_sync(func)\n+\n+    def url_for(\n+        self,\n+        endpoint: str,\n+        *,\n+        _anchor: str | None = None,\n+        _method: str | None = None,\n+        _scheme: str | None = None,\n+        _external: bool | None = None,\n+        **values: t.Any,\n+    ) -> str:\n+        \"\"\"Generate a URL to the given endpoint with the given values.\n+\n+        This is called by :func:`flask.url_for`, and can be called\n+        directly as well.\n+\n+        An *endpoint* is the name of a URL rule, usually added with\n+        :meth:`@app.route() <route>`, and usually the same name as the\n+        view function. A route defined in a :class:`~flask.Blueprint`\n+        will prepend the blueprint's name separated by a ``.`` to the\n+        endpoint.\n+\n+        In some cases, such as email messages, you want URLs to include\n+        the scheme and domain, like ``https://example.com/hello``. When\n+        not in an active request, URLs will be external by default, but\n+        this requires setting :data:`SERVER_NAME` so Flask knows what\n+        domain to use. :data:`APPLICATION_ROOT` and\n+        :data:`PREFERRED_URL_SCHEME` should also be configured as\n+        needed. This config is only used when not in an active request.\n+\n+        Functions can be decorated with :meth:`url_defaults` to modify\n+        keyword arguments before the URL is built.\n+\n+        If building fails for some reason, such as an unknown endpoint\n+        or incorrect values, the app's :meth:`handle_url_build_error`\n+        method is called. If that returns a string, that is returned,\n+        otherwise a :exc:`~werkzeug.routing.BuildError` is raised.\n+\n+        :param endpoint: The endpoint name associated with the URL to\n+            generate. If this starts with a ``.``, the current blueprint\n+            name (if any) will be used.\n+        :param _anchor: If given, append this as ``#anchor`` to the URL.\n+        :param _method: If given, generate the URL associated with this\n+            method for the endpoint.\n+        :param _scheme: If given, the URL will have this scheme if it\n+            is external.\n+        :param _external: If given, prefer the URL to be internal\n+            (False) or require it to be external (True). External URLs\n+            include the scheme and domain. When not in an active\n+            request, URLs are external by default.\n+        :param values: Values to use for the variable parts of the URL\n+            rule. Unknown keys are appended as query string arguments,\n+            like ``?a=b&c=d``.\n+\n+        .. versionadded:: 2.2\n+            Moved from ``flask.url_for``, which calls this method.\n+        \"\"\"\n+        req_ctx = _cv_request.get(None)\n+\n+        if req_ctx is not None:\n+            url_adapter = req_ctx.url_adapter\n+            blueprint_name = req_ctx.request.blueprint\n+\n+            # If the endpoint starts with \".\" and the request matches a\n+            # blueprint, the endpoint is relative to the blueprint.\n+            if endpoint[:1] == \".\":\n+                if blueprint_name is not None:\n+                    endpoint = f\"{blueprint_name}{endpoint}\"\n+                else:\n+                    endpoint = endpoint[1:]\n+\n+            # When in a request, generate a URL without scheme and\n+            # domain by default, unless a scheme is given.\n+            if _external is None:\n+                _external = _scheme is not None\n+        else:\n+            app_ctx = _cv_app.get(None)\n+\n+            # If called by helpers.url_for, an app context is active,\n+            # use its url_adapter. Otherwise, app.url_for was called\n+            # directly, build an adapter.\n+            if app_ctx is not None:\n+                url_adapter = app_ctx.url_adapter\n+            else:\n+                url_adapter = self.create_url_adapter(None)\n+\n+            if url_adapter is None:\n+                raise RuntimeError(\n+                    \"Unable to build URLs outside an active request\"\n+                    \" without 'SERVER_NAME' configured. Also configure\"\n+                    \" 'APPLICATION_ROOT' and 'PREFERRED_URL_SCHEME' as\"\n+                    \" needed.\"\n+                )\n+\n+            # When outside a request, generate a URL with scheme and\n+            # domain by default.\n+            if _external is None:\n+                _external = True\n+\n+        # It is an error to set _scheme when _external=False, in order\n+        # to avoid accidental insecure URLs.\n+        if _scheme is not None and not _external:\n+            raise ValueError(\"When specifying '_scheme', '_external' must be True.\")\n+\n+        self.inject_url_defaults(endpoint, values)\n+\n+        try:\n+            rv = url_adapter.build(  # type: ignore[union-attr]\n+                endpoint,\n+                values,\n+                method=_method,\n+                url_scheme=_scheme,\n+                force_external=_external,\n+            )\n+        except BuildError as error:\n+            values.update(\n+                _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external\n+            )\n+            return self.handle_url_build_error(error, endpoint, values)\n+\n+        if _anchor is not None:\n+            _anchor = _url_quote(_anchor, safe=\"%!#$&'()*+,/:;=?@\")\n+            rv = f\"{rv}#{_anchor}\"\n+\n+        return rv\n+\n+    def make_response(self, rv: ft.ResponseReturnValue) -> Response:\n+        \"\"\"Convert the return value from a view function to an instance of\n+        :attr:`response_class`.\n+\n+        :param rv: the return value from the view function. The view function\n+            must return a response. Returning ``None``, or the view ending\n+            without returning, is not allowed. The following types are allowed\n+            for ``view_rv``:\n+\n+            ``str``\n+                A response object is created with the string encoded to UTF-8\n+                as the body.\n+\n+            ``bytes``\n+                A response object is created with the bytes as the body.\n+\n+            ``dict``\n+                A dictionary that will be jsonify'd before being returned.\n+\n+            ``list``\n+                A list that will be jsonify'd before being returned.\n+\n+            ``generator`` or ``iterator``\n+                A generator that returns ``str`` or ``bytes`` to be\n+                streamed as the response.\n+\n+            ``tuple``\n+                Either ``(body, status, headers)``, ``(body, status)``, or\n+                ``(body, headers)``, where ``body`` is any of the other types\n+                allowed here, ``status`` is a string or an integer, and\n+                ``headers`` is a dictionary or a list of ``(key, value)``\n+                tuples. If ``body`` is a :attr:`response_class` instance,\n+                ``status`` overwrites the exiting value and ``headers`` are\n+                extended.\n+\n+            :attr:`response_class`\n+                The object is returned unchanged.\n+\n+            other :class:`~werkzeug.wrappers.Response` class\n+                The object is coerced to :attr:`response_class`.\n+\n+            :func:`callable`\n+                The function is called as a WSGI application. The result is\n+                used to create a response object.\n+\n+        .. versionchanged:: 2.2\n+            A generator will be converted to a streaming response.\n+            A list will be converted to a JSON response.\n+\n+        .. versionchanged:: 1.1\n+            A dict will be converted to a JSON response.\n+\n+        .. versionchanged:: 0.9\n+           Previously a tuple was interpreted as the arguments for the\n+           response object.\n+        \"\"\"\n+\n+        status = headers = None\n+\n+        # unpack tuple returns\n+        if isinstance(rv, tuple):\n+            len_rv = len(rv)\n+\n+            # a 3-tuple is unpacked directly\n+            if len_rv == 3:\n+                rv, status, headers = rv  # type: ignore[misc]\n+            # decide if a 2-tuple has status or headers\n+            elif len_rv == 2:\n+                if isinstance(rv[1], (Headers, dict, tuple, list)):\n+                    rv, headers = rv\n+                else:\n+                    rv, status = rv  # type: ignore[assignment,misc]\n+            # other sized tuples are not allowed\n+            else:\n+                raise TypeError(\n+                    \"The view function did not return a valid response tuple.\"\n+                    \" The tuple must have the form (body, status, headers),\"\n+                    \" (body, status), or (body, headers).\"\n+                )\n+\n+        # the body must not be None\n+        if rv is None:\n+            raise TypeError(\n+                f\"The view function for {request.endpoint!r} did not\"\n+                \" return a valid response. The function either returned\"\n+                \" None or ended without a return statement.\"\n+            )\n+\n+        # make sure the body is an instance of the response class\n+        if not isinstance(rv, self.response_class):\n+            if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, _abc_Iterator):\n+                # let the response class set the status and headers instead of\n+                # waiting to do it manually, so that the class can handle any\n+                # special logic\n+                rv = self.response_class(\n+                    rv,\n+                    status=status,\n+                    headers=headers,  # type: ignore[arg-type]\n+                )\n+                status = headers = None\n+            elif isinstance(rv, (dict, list)):\n+                rv = self.json.response(rv)\n+            elif isinstance(rv, BaseResponse) or callable(rv):\n+                # evaluate a WSGI callable, or coerce a different response\n+                # class to the correct type\n+                try:\n+                    rv = self.response_class.force_type(\n+                        rv, request.environ  # type: ignore[arg-type]\n+                    )\n+                except TypeError as e:\n+                    raise TypeError(\n+                        f\"{e}\\nThe view function did not return a valid\"\n+                        \" response. The return type must be a string,\"\n+                        \" dict, list, tuple with headers or status,\"\n+                        \" Response instance, or WSGI callable, but it\"\n+                        f\" was a {type(rv).__name__}.\"\n+                    ).with_traceback(sys.exc_info()[2]) from None\n+            else:\n+                raise TypeError(\n+                    \"The view function did not return a valid\"\n+                    \" response. The return type must be a string,\"\n+                    \" dict, list, tuple with headers or status,\"\n+                    \" Response instance, or WSGI callable, but it was a\"\n+                    f\" {type(rv).__name__}.\"\n+                )\n+\n+        rv = t.cast(Response, rv)\n+        # prefer the status if it was provided\n+        if status is not None:\n+            if isinstance(status, (str, bytes, bytearray)):\n+                rv.status = status\n+            else:\n+                rv.status_code = status\n+\n+        # extend existing headers with provided headers\n+        if headers:\n+            rv.headers.update(headers)  # type: ignore[arg-type]\n+\n+        return rv\n+\n+    def preprocess_request(self) -> ft.ResponseReturnValue | None:\n+        \"\"\"Called before the request is dispatched. Calls\n+        :attr:`url_value_preprocessors` registered with the app and the\n+        current blueprint (if any). Then calls :attr:`before_request_funcs`\n+        registered with the app and the blueprint.\n+\n+        If any :meth:`before_request` handler returns a non-None value, the\n+        value is handled as if it was the return value from the view, and\n+        further request handling is stopped.\n+        \"\"\"\n+        names = (None, *reversed(request.blueprints))\n+\n+        for name in names:\n+            if name in self.url_value_preprocessors:\n+                for url_func in self.url_value_preprocessors[name]:\n+                    url_func(request.endpoint, request.view_args)\n+\n+        for name in names:\n+            if name in self.before_request_funcs:\n+                for before_func in self.before_request_funcs[name]:\n+                    rv = self.ensure_sync(before_func)()\n+\n+                    if rv is not None:\n+                        return rv\n+\n+        return None\n+\n+    def process_response(self, response: Response) -> Response:\n+        \"\"\"Can be overridden in order to modify the response object\n+        before it's sent to the WSGI server.  By default this will\n+        call all the :meth:`after_request` decorated functions.\n+\n+        .. versionchanged:: 0.5\n+           As of Flask 0.5 the functions registered for after request\n+           execution are called in reverse order of registration.\n+\n+        :param response: a :attr:`response_class` object.\n+        :return: a new response object or the same, has to be an\n+                 instance of :attr:`response_class`.\n+        \"\"\"\n+        ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]\n+\n+        for func in ctx._after_request_functions:\n+            response = self.ensure_sync(func)(response)\n+\n+        for name in chain(request.blueprints, (None,)):\n+            if name in self.after_request_funcs:\n+                for func in reversed(self.after_request_funcs[name]):\n+                    response = self.ensure_sync(func)(response)\n+\n+        if not self.session_interface.is_null_session(ctx.session):\n+            self.session_interface.save_session(self, ctx.session, response)\n+\n+        return response\n+\n+    def do_teardown_request(\n+        self, exc: BaseException | None = _sentinel  # type: ignore\n+    ) -> None:\n+        \"\"\"Called after the request is dispatched and the response is\n+        returned, right before the request context is popped.\n+\n+        This calls all functions decorated with\n+        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`\n+        if a blueprint handled the request. Finally, the\n+        :data:`request_tearing_down` signal is sent.\n+\n+        This is called by\n+        :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,\n+        which may be delayed during testing to maintain access to\n+        resources.\n+\n+        :param exc: An unhandled exception raised while dispatching the\n+            request. Detected from the current exception information if\n+            not passed. Passed to each teardown function.\n+\n+        .. versionchanged:: 0.9\n+            Added the ``exc`` argument.\n+        \"\"\"\n+        if exc is _sentinel:\n+            exc = sys.exc_info()[1]\n+\n+        for name in chain(request.blueprints, (None,)):\n+            if name in self.teardown_request_funcs:\n+                for func in reversed(self.teardown_request_funcs[name]):\n+                    self.ensure_sync(func)(exc)\n+\n+        request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\n+\n+    def do_teardown_appcontext(\n+        self, exc: BaseException | None = _sentinel  # type: ignore\n+    ) -> None:\n+        \"\"\"Called right before the application context is popped.\n+\n+        When handling a request, the application context is popped\n+        after the request context. See :meth:`do_teardown_request`.\n+\n+        This calls all functions decorated with\n+        :meth:`teardown_appcontext`. Then the\n+        :data:`appcontext_tearing_down` signal is sent.\n+\n+        This is called by\n+        :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.\n+\n+        .. versionadded:: 0.9\n+        \"\"\"\n+        if exc is _sentinel:\n+            exc = sys.exc_info()[1]\n+\n+        for func in reversed(self.teardown_appcontext_funcs):\n+            self.ensure_sync(func)(exc)\n+\n+        appcontext_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\n+\n+    def app_context(self) -> AppContext:\n+        \"\"\"Create an :class:`~flask.ctx.AppContext`. Use as a ``with``\n+        block to push the context, which will make :data:`current_app`\n+        point at this application.\n+\n+        An application context is automatically pushed by\n+        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n+        when handling a request, and when running a CLI command. Use\n+        this to manually create a context outside of these situations.\n+\n+        ::\n+\n+            with app.app_context():\n+                init_db()\n+\n+        See :doc:`/appcontext`.\n+\n+        .. versionadded:: 0.9\n+        \"\"\"\n+        return AppContext(self)\n+\n+    def request_context(self, environ: dict) -> RequestContext:\n+        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n+        WSGI environment. Use a ``with`` block to push the context,\n+        which will make :data:`request` point at this request.\n+\n+        See :doc:`/reqcontext`.\n+\n+        Typically you should not call this from your own code. A request\n+        context is automatically pushed by the :meth:`wsgi_app` when\n+        handling a request. Use :meth:`test_request_context` to create\n+        an environment and context instead of this method.\n+\n+        :param environ: a WSGI environment\n+        \"\"\"\n+        return RequestContext(self, environ)\n+\n+    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n+        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n+        environment created from the given values. This is mostly useful\n+        during testing, where you may want to run a function that uses\n+        request data without dispatching a full request.\n+\n+        See :doc:`/reqcontext`.\n+\n+        Use a ``with`` block to push the context, which will make\n+        :data:`request` point at the request for the created\n+        environment. ::\n+\n+            with app.test_request_context(...):\n+                generate_report()\n+\n+        When using the shell, it may be easier to push and pop the\n+        context manually to avoid indentation. ::\n+\n+            ctx = app.test_request_context(...)\n+            ctx.push()\n+            ...\n+            ctx.pop()\n+\n+        Takes the same arguments as Werkzeug's\n+        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from\n+        the application. See the linked Werkzeug docs for most of the\n+        available arguments. Flask-specific behavior is listed here.\n+\n+        :param path: URL path being requested.\n+        :param base_url: Base URL where the app is being served, which\n+            ``path`` is relative to. If not given, built from\n+            :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n+            :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n+        :param subdomain: Subdomain name to append to\n+            :data:`SERVER_NAME`.\n+        :param url_scheme: Scheme to use instead of\n+            :data:`PREFERRED_URL_SCHEME`.\n+        :param data: The request body, either as a string or a dict of\n+            form keys and values.\n+        :param json: If given, this is serialized as JSON and passed as\n+            ``data``. Also defaults ``content_type`` to\n+            ``application/json``.\n+        :param args: other positional arguments passed to\n+            :class:`~werkzeug.test.EnvironBuilder`.\n+        :param kwargs: other keyword arguments passed to\n+            :class:`~werkzeug.test.EnvironBuilder`.\n+        \"\"\"\n+        from .testing import EnvironBuilder\n+\n+        builder = EnvironBuilder(self, *args, **kwargs)\n+\n+        try:\n+            return self.request_context(builder.get_environ())\n+        finally:\n+            builder.close()\n+\n+    def wsgi_app(self, environ: dict, start_response: t.Callable) -> t.Any:\n+        \"\"\"The actual WSGI application. This is not implemented in\n+        :meth:`__call__` so that middlewares can be applied without\n+        losing a reference to the app object. Instead of doing this::\n+\n+            app = MyMiddleware(app)\n+\n+        It's a better idea to do this instead::\n+\n+            app.wsgi_app = MyMiddleware(app.wsgi_app)\n+\n+        Then you still have the original application object around and\n+        can continue to call methods on it.\n+\n+        .. versionchanged:: 0.7\n+            Teardown events for the request and app contexts are called\n+            even if an unhandled error occurs. Other events may not be\n+            called depending on when an error occurs during dispatch.\n+            See :ref:`callbacks-and-errors`.\n+\n+        :param environ: A WSGI environment.\n+        :param start_response: A callable accepting a status code,\n+            a list of headers, and an optional exception context to\n+            start the response.\n+        \"\"\"\n+        ctx = self.request_context(environ)\n+        error: BaseException | None = None\n+        try:\n+            try:\n+                ctx.push()\n+                response = self.full_dispatch_request()\n+            except Exception as e:\n+                error = e\n+                response = self.handle_exception(e)\n+            except:  # noqa: B001\n+                error = sys.exc_info()[1]\n+                raise\n+            return response(environ, start_response)\n+        finally:\n+            if \"werkzeug.debug.preserve_context\" in environ:\n+                environ[\"werkzeug.debug.preserve_context\"](_cv_app.get())\n+                environ[\"werkzeug.debug.preserve_context\"](_cv_request.get())\n+\n+            if error is not None and self.should_ignore_error(error):\n+                error = None\n+\n+            ctx.pop(error)\n+\n+    def __call__(self, environ: dict, start_response: t.Callable) -> t.Any:\n+        \"\"\"The WSGI server calls the Flask application object as the\n+        WSGI application. This calls :meth:`wsgi_app`, which can be\n+        wrapped to apply middleware.\n+        \"\"\"\n+        return self.wsgi_app(environ, start_response)\n\n@@ -0,0 +1,91 @@\n+from __future__ import annotations\n+\n+import os\n+import typing as t\n+from datetime import timedelta\n+\n+from .globals import current_app\n+from .helpers import send_from_directory\n+from .sansio.blueprints import Blueprint as SansioBlueprint\n+from .sansio.blueprints import BlueprintSetupState as BlueprintSetupState  # noqa\n+\n+if t.TYPE_CHECKING:  # pragma: no cover\n+    from .wrappers import Response\n+\n+\n+class Blueprint(SansioBlueprint):\n+    def get_send_file_max_age(self, filename: str | None) -> int | None:\n+        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n+        value for a given file path if it wasn't passed.\n+\n+        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n+        the configuration of :data:`~flask.current_app`. This defaults\n+        to ``None``, which tells the browser to use conditional requests\n+        instead of a timed cache, which is usually preferable.\n+\n+        Note this is a duplicate of the same method in the Flask\n+        class.\n+\n+        .. versionchanged:: 2.0\n+            The default configuration is ``None`` instead of 12 hours.\n+\n+        .. versionadded:: 0.9\n+        \"\"\"\n+        value = current_app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n+\n+        if value is None:\n+            return None\n+\n+        if isinstance(value, timedelta):\n+            return int(value.total_seconds())\n+\n+        return value\n+\n+    def send_static_file(self, filename: str) -> Response:\n+        \"\"\"The view function used to serve files from\n+        :attr:`static_folder`. A route is automatically registered for\n+        this view at :attr:`static_url_path` if :attr:`static_folder` is\n+        set.\n+\n+        Note this is a duplicate of the same method in the Flask\n+        class.\n+\n+        .. versionadded:: 0.5\n+\n+        \"\"\"\n+        if not self.has_static_folder:\n+            raise RuntimeError(\"'static_folder' must be set to serve static_files.\")\n+\n+        # send_file only knows to call get_send_file_max_age on the app,\n+        # call it here so it works for blueprints too.\n+        max_age = self.get_send_file_max_age(filename)\n+        return send_from_directory(\n+            t.cast(str, self.static_folder), filename, max_age=max_age\n+        )\n+\n+    def open_resource(self, resource: str, mode: str = \"rb\") -> t.IO[t.AnyStr]:\n+        \"\"\"Open a resource file relative to :attr:`root_path` for\n+        reading.\n+\n+        For example, if the file ``schema.sql`` is next to the file\n+        ``app.py`` where the ``Flask`` app is defined, it can be opened\n+        with:\n+\n+        .. code-block:: python\n+\n+            with app.open_resource(\"schema.sql\") as f:\n+                conn.executescript(f.read())\n+\n+        :param resource: Path to the resource relative to\n+            :attr:`root_path`.\n+        :param mode: Open the file in this mode. Only reading is\n+            supported, valid values are \"r\" (or \"rt\") and \"rb\".\n+\n+        Note this is a duplicate of the same method in the Flask\n+        class.\n+\n+        \"\"\"\n+        if mode not in {\"r\", \"rt\", \"rb\"}:\n+            raise ValueError(\"Resources can only be opened for reading.\")\n+\n+        return open(os.path.join(self.root_path, resource), mode)\n\n@@ -2,9 +2,9 @@ from __future__ import annotations\n \n import typing as t\n \n-from .app import Flask\n from .blueprints import Blueprint\n from .globals import request_ctx\n+from .sansio.app import App\n \n \n class UnexpectedUnicodeError(AssertionError, UnicodeError):\n@@ -113,7 +113,7 @@ def _dump_loader_info(loader) -> t.Generator:\n         yield f\"{key}: {value!r}\"\n \n \n-def explain_template_loading_attempts(app: Flask, template, attempts) -> None:\n+def explain_template_loading_attempts(app: App, template, attempts) -> None:\n     \"\"\"This should help developers understand what failed\"\"\"\n     info = [f\"Locating template {template!r}:\"]\n     total_found = 0\n@@ -122,7 +122,7 @@ def explain_template_loading_attempts(app: Flask, template, attempts) -> None:\n         blueprint = request_ctx.request.blueprint\n \n     for idx, (loader, srcobj, triple) in enumerate(attempts):\n-        if isinstance(srcobj, Flask):\n+        if isinstance(srcobj, App):\n             src_info = f\"application {srcobj.import_name!r}\"\n         elif isinstance(srcobj, Blueprint):\n             src_info = f\"blueprint {srcobj.name!r} ({srcobj.import_name})\"\n\n@@ -11,7 +11,7 @@ from datetime import date\n from werkzeug.http import http_date\n \n if t.TYPE_CHECKING:  # pragma: no cover\n-    from ..app import Flask\n+    from ..sansio.app import App\n     from ..wrappers import Response\n \n \n@@ -34,7 +34,7 @@ class JSONProvider:\n     .. versionadded:: 2.2\n     \"\"\"\n \n-    def __init__(self, app: Flask) -> None:\n+    def __init__(self, app: App) -> None:\n         self._app = weakref.proxy(app)\n \n     def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n\n@@ -9,7 +9,7 @@ from werkzeug.local import LocalProxy\n from .globals import request\n \n if t.TYPE_CHECKING:  # pragma: no cover\n-    from .app import Flask\n+    from .sansio.app import App\n \n \n @LocalProxy\n@@ -52,7 +52,7 @@ default_handler.setFormatter(\n )\n \n \n-def create_logger(app: Flask) -> logging.Logger:\n+def create_logger(app: App) -> logging.Logger:\n     \"\"\"Get the Flask app's logger and configure it if needed.\n \n     The logger name will be the same as\n\n@@ -4,74 +4,40 @@ import logging\n import os\n import sys\n import typing as t\n-import weakref\n-from collections.abc import Iterator as _abc_Iterator\n from datetime import timedelta\n-from inspect import iscoroutinefunction\n from itertools import chain\n-from types import TracebackType\n-from urllib.parse import quote as _url_quote\n \n-import click\n-from werkzeug.datastructures import Headers\n-from werkzeug.datastructures import ImmutableDict\n from werkzeug.exceptions import Aborter\n from werkzeug.exceptions import BadRequest\n from werkzeug.exceptions import BadRequestKeyError\n-from werkzeug.exceptions import HTTPException\n-from werkzeug.exceptions import InternalServerError\n from werkzeug.routing import BuildError\n from werkzeug.routing import Map\n-from werkzeug.routing import MapAdapter\n-from werkzeug.routing import RequestRedirect\n-from werkzeug.routing import RoutingException\n from werkzeug.routing import Rule\n-from werkzeug.serving import is_running_from_reloader\n+from werkzeug.sansio.response import Response\n from werkzeug.utils import cached_property\n from werkzeug.utils import redirect as _wz_redirect\n-from werkzeug.wrappers import Response as BaseResponse\n \n-from . import cli\n-from . import typing as ft\n-from .config import Config\n-from .config import ConfigAttribute\n-from .ctx import _AppCtxGlobals\n-from .ctx import AppContext\n-from .ctx import RequestContext\n-from .globals import _cv_app\n-from .globals import _cv_request\n-from .globals import g\n-from .globals import request\n-from .globals import request_ctx\n-from .globals import session\n-from .helpers import _split_blueprint_path\n-from .helpers import get_debug_flag\n-from .helpers import get_flashed_messages\n-from .helpers import get_load_dotenv\n-from .json.provider import DefaultJSONProvider\n-from .json.provider import JSONProvider\n-from .logging import create_logger\n+from .. import typing as ft\n+from ..config import Config\n+from ..config import ConfigAttribute\n+from ..ctx import _AppCtxGlobals\n+from ..helpers import _split_blueprint_path\n+from ..helpers import get_debug_flag\n+from ..json.provider import DefaultJSONProvider\n+from ..json.provider import JSONProvider\n+from ..logging import create_logger\n+from ..templating import DispatchingJinjaLoader\n+from ..templating import Environment\n from .scaffold import _endpoint_from_view_func\n-from .scaffold import _sentinel\n from .scaffold import find_package\n from .scaffold import Scaffold\n from .scaffold import setupmethod\n-from .sessions import SecureCookieSessionInterface\n-from .sessions import SessionInterface\n-from .signals import appcontext_tearing_down\n-from .signals import got_request_exception\n-from .signals import request_finished\n-from .signals import request_started\n-from .signals import request_tearing_down\n-from .templating import DispatchingJinjaLoader\n-from .templating import Environment\n-from .wrappers import Request\n-from .wrappers import Response\n \n if t.TYPE_CHECKING:  # pragma: no cover\n+    from werkzeug.wrappers import Response as BaseResponse\n     from .blueprints import Blueprint\n-    from .testing import FlaskClient\n-    from .testing import FlaskCliRunner\n+    from ..testing import FlaskClient\n+    from ..testing import FlaskCliRunner\n \n T_shell_context_processor = t.TypeVar(\n     \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n@@ -89,7 +55,7 @@ def _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n     return timedelta(seconds=value)\n \n \n-class Flask(Scaffold):\n+class App(Scaffold):\n     \"\"\"The flask object implements a WSGI application and acts as the central\n     object.  It is passed the name of the module or package of the\n     application.  Once it is created it will act as a central registry for\n@@ -186,14 +152,6 @@ class Flask(Scaffold):\n         automatically, such as for namespace packages.\n     \"\"\"\n \n-    #: The class that is used for request objects.  See :class:`~flask.Request`\n-    #: for more information.\n-    request_class = Request\n-\n-    #: The class that is used for response objects.  See\n-    #: :class:`~flask.Response` for more information.\n-    response_class = Response\n-\n     #: The class of the object assigned to :attr:`aborter`, created by\n     #: :meth:`create_aborter`. That object is called by\n     #: :func:`flask.abort` to raise HTTP errors, and can be\n@@ -290,35 +248,6 @@ class Flask(Scaffold):\n     #:\n     jinja_options: dict = {}\n \n-    #: Default configuration parameters.\n-    default_config = ImmutableDict(\n-        {\n-            \"DEBUG\": None,\n-            \"TESTING\": False,\n-            \"PROPAGATE_EXCEPTIONS\": None,\n-            \"SECRET_KEY\": None,\n-            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n-            \"USE_X_SENDFILE\": False,\n-            \"SERVER_NAME\": None,\n-            \"APPLICATION_ROOT\": \"/\",\n-            \"SESSION_COOKIE_NAME\": \"session\",\n-            \"SESSION_COOKIE_DOMAIN\": None,\n-            \"SESSION_COOKIE_PATH\": None,\n-            \"SESSION_COOKIE_HTTPONLY\": True,\n-            \"SESSION_COOKIE_SECURE\": False,\n-            \"SESSION_COOKIE_SAMESITE\": None,\n-            \"SESSION_REFRESH_EACH_REQUEST\": True,\n-            \"MAX_CONTENT_LENGTH\": None,\n-            \"SEND_FILE_MAX_AGE_DEFAULT\": None,\n-            \"TRAP_BAD_REQUEST_ERRORS\": None,\n-            \"TRAP_HTTP_EXCEPTIONS\": False,\n-            \"EXPLAIN_TEMPLATE_LOADING\": False,\n-            \"PREFERRED_URL_SCHEME\": \"http\",\n-            \"TEMPLATES_AUTO_RELOAD\": None,\n-            \"MAX_COOKIE_SIZE\": 4093,\n-        }\n-    )\n-\n     #: The rule object to use for URL rules created.  This is used by\n     #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n     #:\n@@ -345,11 +274,8 @@ class Flask(Scaffold):\n     #: .. versionadded:: 1.0\n     test_cli_runner_class: type[FlaskCliRunner] | None = None\n \n-    #: the session interface to use.  By default an instance of\n-    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n-    #:\n-    #: .. versionadded:: 0.8\n-    session_interface: SessionInterface = SecureCookieSessionInterface()\n+    default_config: dict\n+    response_class: type[Response]\n \n     def __init__(\n         self,\n@@ -474,34 +400,14 @@ class Flask(Scaffold):\n         #:\n         #:    app = Flask(__name__)\n         #:    app.url_map.converters['list'] = ListConverter\n-        self.url_map = self.url_map_class()\n+        self.url_map = self.url_map_class(host_matching=host_matching)\n \n-        self.url_map.host_matching = host_matching\n         self.subdomain_matching = subdomain_matching\n \n         # tracks internally if the application already handled at least one\n         # request.\n         self._got_first_request = False\n \n-        # Add a static route using the provided static_url_path, static_host,\n-        # and static_folder if there is a configured static_folder.\n-        # Note we do this without checking if static_folder exists.\n-        # For one, it might be created while the server is running (e.g. during\n-        # development). Also, Google App Engine stores static files somewhere\n-        if self.has_static_folder:\n-            assert (\n-                bool(static_host) == host_matching\n-            ), \"Invalid static_host/host_matching combination\"\n-            # Use a weakref to avoid creating a reference cycle between the app\n-            # and the view function (see #3761).\n-            self_ref = weakref.ref(self)\n-            self.add_url_rule(\n-                f\"{self.static_url_path}/<path:filename>\",\n-                endpoint=\"static\",\n-                host=static_host,\n-                view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n-            )\n-\n         # Set the name of the Click group in case someone wants to add\n         # the app's commands to another CLI tool.\n         self.cli.name = self.name\n@@ -572,6 +478,9 @@ class Flask(Scaffold):\n         \"\"\"\n         return self.create_jinja_environment()\n \n+    def create_jinja_environment(self) -> Environment:\n+        raise NotImplementedError()\n+\n     def make_config(self, instance_relative: bool = False) -> Config:\n         \"\"\"Used to create the config attribute by the Flask constructor.\n         The `instance_relative` parameter is passed in from the constructor\n@@ -613,58 +522,6 @@ class Flask(Scaffold):\n             return os.path.join(package_path, \"instance\")\n         return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n \n-    def open_instance_resource(self, resource: str, mode: str = \"rb\") -> t.IO[t.AnyStr]:\n-        \"\"\"Opens a resource from the application's instance folder\n-        (:attr:`instance_path`).  Otherwise works like\n-        :meth:`open_resource`.  Instance resources can also be opened for\n-        writing.\n-\n-        :param resource: the name of the resource.  To access resources within\n-                         subfolders use forward slashes as separator.\n-        :param mode: resource file opening mode, default is 'rb'.\n-        \"\"\"\n-        return open(os.path.join(self.instance_path, resource), mode)\n-\n-    def create_jinja_environment(self) -> Environment:\n-        \"\"\"Create the Jinja environment based on :attr:`jinja_options`\n-        and the various Jinja-related methods of the app. Changing\n-        :attr:`jinja_options` after this will have no effect. Also adds\n-        Flask-related globals and filters to the environment.\n-\n-        .. versionchanged:: 0.11\n-           ``Environment.auto_reload`` set in accordance with\n-           ``TEMPLATES_AUTO_RELOAD`` configuration option.\n-\n-        .. versionadded:: 0.5\n-        \"\"\"\n-        options = dict(self.jinja_options)\n-\n-        if \"autoescape\" not in options:\n-            options[\"autoescape\"] = self.select_jinja_autoescape\n-\n-        if \"auto_reload\" not in options:\n-            auto_reload = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n-\n-            if auto_reload is None:\n-                auto_reload = self.debug\n-\n-            options[\"auto_reload\"] = auto_reload\n-\n-        rv = self.jinja_environment(self, **options)\n-        rv.globals.update(\n-            url_for=self.url_for,\n-            get_flashed_messages=get_flashed_messages,\n-            config=self.config,\n-            # request, session and g are normally added with the\n-            # context processor for efficiency reasons but for imported\n-            # templates we also want the proxies in there.\n-            request=request,\n-            session=session,\n-            g=g,\n-        )\n-        rv.policies[\"json.dumps_function\"] = self.json.dumps\n-        return rv\n-\n     def create_global_jinja_loader(self) -> DispatchingJinjaLoader:\n         \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n         override just the loader and keeping the rest unchanged.  It's\n@@ -691,46 +548,6 @@ class Flask(Scaffold):\n             return True\n         return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\", \".svg\"))\n \n-    def update_template_context(self, context: dict) -> None:\n-        \"\"\"Update the template context with some commonly used variables.\n-        This injects request, session, config and g into the template\n-        context as well as everything template context processors want\n-        to inject.  Note that the as of Flask 0.6, the original values\n-        in the context will not be overridden if a context processor\n-        decides to return a value with the same key.\n-\n-        :param context: the context as a dictionary that is updated in place\n-                        to add extra variables.\n-        \"\"\"\n-        names: t.Iterable[str | None] = (None,)\n-\n-        # A template may be rendered outside a request context.\n-        if request:\n-            names = chain(names, reversed(request.blueprints))\n-\n-        # The values passed to render_template take precedence. Keep a\n-        # copy to re-apply after all context functions.\n-        orig_ctx = context.copy()\n-\n-        for name in names:\n-            if name in self.template_context_processors:\n-                for func in self.template_context_processors[name]:\n-                    context.update(func())\n-\n-        context.update(orig_ctx)\n-\n-    def make_shell_context(self) -> dict:\n-        \"\"\"Returns the shell context for an interactive shell for this\n-        application.  This runs all the registered shell context\n-        processors.\n-\n-        .. versionadded:: 0.11\n-        \"\"\"\n-        rv = {\"app\": self, \"g\": g}\n-        for processor in self.shell_context_processors:\n-            rv.update(processor())\n-        return rv\n-\n     @property\n     def debug(self) -> bool:\n         \"\"\"Whether debug mode is enabled. When using ``flask run`` to start the\n@@ -751,204 +568,6 @@ class Flask(Scaffold):\n         if self.config[\"TEMPLATES_AUTO_RELOAD\"] is None:\n             self.jinja_env.auto_reload = value\n \n-    def run(\n-        self,\n-        host: str | None = None,\n-        port: int | None = None,\n-        debug: bool | None = None,\n-        load_dotenv: bool = True,\n-        **options: t.Any,\n-    ) -> None:\n-        \"\"\"Runs the application on a local development server.\n-\n-        Do not use ``run()`` in a production setting. It is not intended to\n-        meet security and performance requirements for a production server.\n-        Instead, see :doc:`/deploying/index` for WSGI server recommendations.\n-\n-        If the :attr:`debug` flag is set the server will automatically reload\n-        for code changes and show a debugger in case an exception happened.\n-\n-        If you want to run the application in debug mode, but disable the\n-        code execution on the interactive debugger, you can pass\n-        ``use_evalex=False`` as parameter.  This will keep the debugger's\n-        traceback screen active, but disable code execution.\n-\n-        It is not recommended to use this function for development with\n-        automatic reloading as this is badly supported.  Instead you should\n-        be using the :command:`flask` command line script's ``run`` support.\n-\n-        .. admonition:: Keep in Mind\n-\n-           Flask will suppress any server error with a generic error page\n-           unless it is in debug mode.  As such to enable just the\n-           interactive debugger without the code reloading, you have to\n-           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n-           Setting ``use_debugger`` to ``True`` without being in debug mode\n-           won't catch any exceptions because there won't be any to\n-           catch.\n-\n-        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n-            have the server available externally as well. Defaults to\n-            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n-            if present.\n-        :param port: the port of the webserver. Defaults to ``5000`` or the\n-            port defined in the ``SERVER_NAME`` config variable if present.\n-        :param debug: if given, enable or disable debug mode. See\n-            :attr:`debug`.\n-        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n-            files to set environment variables. Will also change the working\n-            directory to the directory containing the first file found.\n-        :param options: the options to be forwarded to the underlying Werkzeug\n-            server. See :func:`werkzeug.serving.run_simple` for more\n-            information.\n-\n-        .. versionchanged:: 1.0\n-            If installed, python-dotenv will be used to load environment\n-            variables from :file:`.env` and :file:`.flaskenv` files.\n-\n-            The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.\n-\n-            Threaded mode is enabled by default.\n-\n-        .. versionchanged:: 0.10\n-            The default port is now picked from the ``SERVER_NAME``\n-            variable.\n-        \"\"\"\n-        # Ignore this call so that it doesn't start another server if\n-        # the 'flask run' command is used.\n-        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n-            if not is_running_from_reloader():\n-                click.secho(\n-                    \" * Ignoring a call to 'app.run()' that would block\"\n-                    \" the current 'flask' CLI command.\\n\"\n-                    \"   Only call 'app.run()' in an 'if __name__ ==\"\n-                    ' \"__main__\"\\' guard.',\n-                    fg=\"red\",\n-                )\n-\n-            return\n-\n-        if get_load_dotenv(load_dotenv):\n-            cli.load_dotenv()\n-\n-            # if set, env var overrides existing value\n-            if \"FLASK_DEBUG\" in os.environ:\n-                self.debug = get_debug_flag()\n-\n-        # debug passed to method overrides all other sources\n-        if debug is not None:\n-            self.debug = bool(debug)\n-\n-        server_name = self.config.get(\"SERVER_NAME\")\n-        sn_host = sn_port = None\n-\n-        if server_name:\n-            sn_host, _, sn_port = server_name.partition(\":\")\n-\n-        if not host:\n-            if sn_host:\n-                host = sn_host\n-            else:\n-                host = \"127.0.0.1\"\n-\n-        if port or port == 0:\n-            port = int(port)\n-        elif sn_port:\n-            port = int(sn_port)\n-        else:\n-            port = 5000\n-\n-        options.setdefault(\"use_reloader\", self.debug)\n-        options.setdefault(\"use_debugger\", self.debug)\n-        options.setdefault(\"threaded\", True)\n-\n-        cli.show_server_banner(self.debug, self.name)\n-\n-        from werkzeug.serving import run_simple\n-\n-        try:\n-            run_simple(t.cast(str, host), port, self, **options)\n-        finally:\n-            # reset the first request information if the development server\n-            # reset normally.  This makes it possible to restart the server\n-            # without reloader and that stuff from an interactive shell.\n-            self._got_first_request = False\n-\n-    def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> FlaskClient:\n-        \"\"\"Creates a test client for this application.  For information\n-        about unit testing head over to :doc:`/testing`.\n-\n-        Note that if you are testing for assertions or exceptions in your\n-        application code, you must set ``app.testing = True`` in order for the\n-        exceptions to propagate to the test client.  Otherwise, the exception\n-        will be handled by the application (not visible to the test client) and\n-        the only indication of an AssertionError or other exception will be a\n-        500 status code response to the test client.  See the :attr:`testing`\n-        attribute.  For example::\n-\n-            app.testing = True\n-            client = app.test_client()\n-\n-        The test client can be used in a ``with`` block to defer the closing down\n-        of the context until the end of the ``with`` block.  This is useful if\n-        you want to access the context locals for testing::\n-\n-            with app.test_client() as c:\n-                rv = c.get('/?vodka=42')\n-                assert request.args['vodka'] == '42'\n-\n-        Additionally, you may pass optional keyword arguments that will then\n-        be passed to the application's :attr:`test_client_class` constructor.\n-        For example::\n-\n-            from flask.testing import FlaskClient\n-\n-            class CustomClient(FlaskClient):\n-                def __init__(self, *args, **kwargs):\n-                    self._authentication = kwargs.pop(\"authentication\")\n-                    super(CustomClient,self).__init__( *args, **kwargs)\n-\n-            app.test_client_class = CustomClient\n-            client = app.test_client(authentication='Basic ....')\n-\n-        See :class:`~flask.testing.FlaskClient` for more information.\n-\n-        .. versionchanged:: 0.4\n-           added support for ``with`` block usage for the client.\n-\n-        .. versionadded:: 0.7\n-           The `use_cookies` parameter was added as well as the ability\n-           to override the client to be used by setting the\n-           :attr:`test_client_class` attribute.\n-\n-        .. versionchanged:: 0.11\n-           Added `**kwargs` to support passing additional keyword arguments to\n-           the constructor of :attr:`test_client_class`.\n-        \"\"\"\n-        cls = self.test_client_class\n-        if cls is None:\n-            from .testing import FlaskClient as cls\n-        return cls(  # type: ignore\n-            self, self.response_class, use_cookies=use_cookies, **kwargs\n-        )\n-\n-    def test_cli_runner(self, **kwargs: t.Any) -> FlaskCliRunner:\n-        \"\"\"Create a CLI runner for testing CLI commands.\n-        See :ref:`testing-cli`.\n-\n-        Returns an instance of :attr:`test_cli_runner_class`, by default\n-        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is\n-        passed as the first argument.\n-\n-        .. versionadded:: 1.0\n-        \"\"\"\n-        cls = self.test_cli_runner_class\n-\n-        if cls is None:\n-            from .testing import FlaskCliRunner as cls\n-\n-        return cls(self, **kwargs)  # type: ignore\n-\n     @setupmethod\n     def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:\n         \"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n@@ -1203,14 +822,16 @@ class Flask(Scaffold):\n         self.shell_context_processors.append(f)\n         return f\n \n-    def _find_error_handler(self, e: Exception) -> ft.ErrorHandlerCallable | None:\n+    def _find_error_handler(\n+        self, e: Exception, blueprints: list[str]\n+    ) -> ft.ErrorHandlerCallable | None:\n         \"\"\"Return a registered error handler for an exception in this order:\n         blueprint handler for a specific code, app handler for a specific code,\n         blueprint handler for an exception class, app handler for an exception\n         class, or ``None`` if a suitable handler is not found.\n         \"\"\"\n         exc_class, code = self._get_exc_class_and_code(type(e))\n-        names = (*request.blueprints, None)\n+        names = (*blueprints, None)\n \n         for c in (code, None) if code is not None else (None,):\n             for name in names:\n@@ -1226,41 +847,6 @@ class Flask(Scaffold):\n                         return handler\n         return None\n \n-    def handle_http_exception(\n-        self, e: HTTPException\n-    ) -> HTTPException | ft.ResponseReturnValue:\n-        \"\"\"Handles an HTTP exception.  By default this will invoke the\n-        registered error handlers and fall back to returning the\n-        exception as response.\n-\n-        .. versionchanged:: 1.0.3\n-            ``RoutingException``, used internally for actions such as\n-             slash redirects during routing, is not passed to error\n-             handlers.\n-\n-        .. versionchanged:: 1.0\n-            Exceptions are looked up by code *and* by MRO, so\n-            ``HTTPException`` subclasses can be handled with a catch-all\n-            handler for the base ``HTTPException``.\n-\n-        .. versionadded:: 0.3\n-        \"\"\"\n-        # Proxy exceptions don't have error codes.  We want to always return\n-        # those unchanged as errors\n-        if e.code is None:\n-            return e\n-\n-        # RoutingExceptions are used internally to trigger routing\n-        # actions, such as slash redirects raising RequestRedirect. They\n-        # are not raised or handled in user code.\n-        if isinstance(e, RoutingException):\n-            return e\n-\n-        handler = self._find_error_handler(e)\n-        if handler is None:\n-            return e\n-        return self.ensure_sync(handler)(e)\n-\n     def trap_http_exception(self, e: Exception) -> bool:\n         \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n         this will return ``False`` for all exceptions except for a bad request\n@@ -1296,221 +882,6 @@ class Flask(Scaffold):\n \n         return False\n \n-    def handle_user_exception(\n-        self, e: Exception\n-    ) -> HTTPException | ft.ResponseReturnValue:\n-        \"\"\"This method is called whenever an exception occurs that\n-        should be handled. A special case is :class:`~werkzeug\n-        .exceptions.HTTPException` which is forwarded to the\n-        :meth:`handle_http_exception` method. This function will either\n-        return a response value or reraise the exception with the same\n-        traceback.\n-\n-        .. versionchanged:: 1.0\n-            Key errors raised from request data like ``form`` show the\n-            bad key in debug mode rather than a generic bad request\n-            message.\n-\n-        .. versionadded:: 0.7\n-        \"\"\"\n-        if isinstance(e, BadRequestKeyError) and (\n-            self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n-        ):\n-            e.show_exception = True\n-\n-        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n-            return self.handle_http_exception(e)\n-\n-        handler = self._find_error_handler(e)\n-\n-        if handler is None:\n-            raise\n-\n-        return self.ensure_sync(handler)(e)\n-\n-    def handle_exception(self, e: Exception) -> Response:\n-        \"\"\"Handle an exception that did not have an error handler\n-        associated with it, or that was raised from an error handler.\n-        This always causes a 500 ``InternalServerError``.\n-\n-        Always sends the :data:`got_request_exception` signal.\n-\n-        If :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug\n-        mode, the error will be re-raised so that the debugger can\n-        display it. Otherwise, the original exception is logged, and\n-        an :exc:`~werkzeug.exceptions.InternalServerError` is returned.\n-\n-        If an error handler is registered for ``InternalServerError`` or\n-        ``500``, it will be used. For consistency, the handler will\n-        always receive the ``InternalServerError``. The original\n-        unhandled exception is available as ``e.original_exception``.\n-\n-        .. versionchanged:: 1.1.0\n-            Always passes the ``InternalServerError`` instance to the\n-            handler, setting ``original_exception`` to the unhandled\n-            error.\n-\n-        .. versionchanged:: 1.1.0\n-            ``after_request`` functions and other finalization is done\n-            even for the default 500 response when there is no handler.\n-\n-        .. versionadded:: 0.3\n-        \"\"\"\n-        exc_info = sys.exc_info()\n-        got_request_exception.send(self, _async_wrapper=self.ensure_sync, exception=e)\n-        propagate = self.config[\"PROPAGATE_EXCEPTIONS\"]\n-\n-        if propagate is None:\n-            propagate = self.testing or self.debug\n-\n-        if propagate:\n-            # Re-raise if called with an active exception, otherwise\n-            # raise the passed in exception.\n-            if exc_info[1] is e:\n-                raise\n-\n-            raise e\n-\n-        self.log_exception(exc_info)\n-        server_error: InternalServerError | ft.ResponseReturnValue\n-        server_error = InternalServerError(original_exception=e)\n-        handler = self._find_error_handler(server_error)\n-\n-        if handler is not None:\n-            server_error = self.ensure_sync(handler)(server_error)\n-\n-        return self.finalize_request(server_error, from_error_handler=True)\n-\n-    def log_exception(\n-        self,\n-        exc_info: (tuple[type, BaseException, TracebackType] | tuple[None, None, None]),\n-    ) -> None:\n-        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n-        if debugging is disabled and right before the handler is called.\n-        The default implementation logs the exception as error on the\n-        :attr:`logger`.\n-\n-        .. versionadded:: 0.8\n-        \"\"\"\n-        self.logger.error(\n-            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n-        )\n-\n-    def raise_routing_exception(self, request: Request) -> t.NoReturn:\n-        \"\"\"Intercept routing exceptions and possibly do something else.\n-\n-        In debug mode, intercept a routing redirect and replace it with\n-        an error if the body will be discarded.\n-\n-        With modern Werkzeug this shouldn't occur, since it now uses a\n-        308 status which tells the browser to resend the method and\n-        body.\n-\n-        .. versionchanged:: 2.1\n-            Don't intercept 307 and 308 redirects.\n-\n-        :meta private:\n-        :internal:\n-        \"\"\"\n-        if (\n-            not self.debug\n-            or not isinstance(request.routing_exception, RequestRedirect)\n-            or request.routing_exception.code in {307, 308}\n-            or request.method in {\"GET\", \"HEAD\", \"OPTIONS\"}\n-        ):\n-            raise request.routing_exception  # type: ignore\n-\n-        from .debughelpers import FormDataRoutingRedirect\n-\n-        raise FormDataRoutingRedirect(request)\n-\n-    def dispatch_request(self) -> ft.ResponseReturnValue:\n-        \"\"\"Does the request dispatching.  Matches the URL and returns the\n-        return value of the view or error handler.  This does not have to\n-        be a response object.  In order to convert the return value to a\n-        proper response object, call :func:`make_response`.\n-\n-        .. versionchanged:: 0.7\n-           This no longer does the exception handling, this code was\n-           moved to the new :meth:`full_dispatch_request`.\n-        \"\"\"\n-        req = request_ctx.request\n-        if req.routing_exception is not None:\n-            self.raise_routing_exception(req)\n-        rule: Rule = req.url_rule  # type: ignore[assignment]\n-        # if we provide automatic options for this URL and the\n-        # request came with the OPTIONS method, reply automatically\n-        if (\n-            getattr(rule, \"provide_automatic_options\", False)\n-            and req.method == \"OPTIONS\"\n-        ):\n-            return self.make_default_options_response()\n-        # otherwise dispatch to the handler for that endpoint\n-        view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]\n-        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)\n-\n-    def full_dispatch_request(self) -> Response:\n-        \"\"\"Dispatches the request and on top of that performs request\n-        pre and postprocessing as well as HTTP exception catching and\n-        error handling.\n-\n-        .. versionadded:: 0.7\n-        \"\"\"\n-        self._got_first_request = True\n-\n-        try:\n-            request_started.send(self, _async_wrapper=self.ensure_sync)\n-            rv = self.preprocess_request()\n-            if rv is None:\n-                rv = self.dispatch_request()\n-        except Exception as e:\n-            rv = self.handle_user_exception(e)\n-        return self.finalize_request(rv)\n-\n-    def finalize_request(\n-        self,\n-        rv: ft.ResponseReturnValue | HTTPException,\n-        from_error_handler: bool = False,\n-    ) -> Response:\n-        \"\"\"Given the return value from a view function this finalizes\n-        the request by converting it into a response and invoking the\n-        postprocessing functions.  This is invoked for both normal\n-        request dispatching as well as error handlers.\n-\n-        Because this means that it might be called as a result of a\n-        failure a special safe mode is available which can be enabled\n-        with the `from_error_handler` flag.  If enabled, failures in\n-        response processing will be logged and otherwise ignored.\n-\n-        :internal:\n-        \"\"\"\n-        response = self.make_response(rv)\n-        try:\n-            response = self.process_response(response)\n-            request_finished.send(\n-                self, _async_wrapper=self.ensure_sync, response=response\n-            )\n-        except Exception:\n-            if not from_error_handler:\n-                raise\n-            self.logger.exception(\n-                \"Request finalizing failed with an error while handling an error\"\n-            )\n-        return response\n-\n-    def make_default_options_response(self) -> Response:\n-        \"\"\"This method is called to create the default ``OPTIONS`` response.\n-        This can be changed through subclassing to change the default\n-        behavior of ``OPTIONS`` responses.\n-\n-        .. versionadded:: 0.7\n-        \"\"\"\n-        adapter = request_ctx.url_adapter\n-        methods = adapter.allowed_methods()  # type: ignore[union-attr]\n-        rv = self.response_class()\n-        rv.allow.update(methods)\n-        return rv\n-\n     def should_ignore_error(self, error: BaseException | None) -> bool:\n         \"\"\"This is called to figure out if an error should be ignored\n         or not as far as the teardown system is concerned.  If this\n@@ -1521,168 +892,6 @@ class Flask(Scaffold):\n         \"\"\"\n         return False\n \n-    def ensure_sync(self, func: t.Callable) -> t.Callable:\n-        \"\"\"Ensure that the function is synchronous for WSGI workers.\n-        Plain ``def`` functions are returned as-is. ``async def``\n-        functions are wrapped to run and wait for the response.\n-\n-        Override this method to change how the app runs async views.\n-\n-        .. versionadded:: 2.0\n-        \"\"\"\n-        if iscoroutinefunction(func):\n-            return self.async_to_sync(func)\n-\n-        return func\n-\n-    def async_to_sync(\n-        self, func: t.Callable[..., t.Coroutine]\n-    ) -> t.Callable[..., t.Any]:\n-        \"\"\"Return a sync function that will run the coroutine function.\n-\n-        .. code-block:: python\n-\n-            result = app.async_to_sync(func)(*args, **kwargs)\n-\n-        Override this method to change how the app converts async code\n-        to be synchronously callable.\n-\n-        .. versionadded:: 2.0\n-        \"\"\"\n-        try:\n-            from asgiref.sync import async_to_sync as asgiref_async_to_sync\n-        except ImportError:\n-            raise RuntimeError(\n-                \"Install Flask with the 'async' extra in order to use async views.\"\n-            ) from None\n-\n-        return asgiref_async_to_sync(func)\n-\n-    def url_for(\n-        self,\n-        endpoint: str,\n-        *,\n-        _anchor: str | None = None,\n-        _method: str | None = None,\n-        _scheme: str | None = None,\n-        _external: bool | None = None,\n-        **values: t.Any,\n-    ) -> str:\n-        \"\"\"Generate a URL to the given endpoint with the given values.\n-\n-        This is called by :func:`flask.url_for`, and can be called\n-        directly as well.\n-\n-        An *endpoint* is the name of a URL rule, usually added with\n-        :meth:`@app.route() <route>`, and usually the same name as the\n-        view function. A route defined in a :class:`~flask.Blueprint`\n-        will prepend the blueprint's name separated by a ``.`` to the\n-        endpoint.\n-\n-        In some cases, such as email messages, you want URLs to include\n-        the scheme and domain, like ``https://example.com/hello``. When\n-        not in an active request, URLs will be external by default, but\n-        this requires setting :data:`SERVER_NAME` so Flask knows what\n-        domain to use. :data:`APPLICATION_ROOT` and\n-        :data:`PREFERRED_URL_SCHEME` should also be configured as\n-        needed. This config is only used when not in an active request.\n-\n-        Functions can be decorated with :meth:`url_defaults` to modify\n-        keyword arguments before the URL is built.\n-\n-        If building fails for some reason, such as an unknown endpoint\n-        or incorrect values, the app's :meth:`handle_url_build_error`\n-        method is called. If that returns a string, that is returned,\n-        otherwise a :exc:`~werkzeug.routing.BuildError` is raised.\n-\n-        :param endpoint: The endpoint name associated with the URL to\n-            generate. If this starts with a ``.``, the current blueprint\n-            name (if any) will be used.\n-        :param _anchor: If given, append this as ``#anchor`` to the URL.\n-        :param _method: If given, generate the URL associated with this\n-            method for the endpoint.\n-        :param _scheme: If given, the URL will have this scheme if it\n-            is external.\n-        :param _external: If given, prefer the URL to be internal\n-            (False) or require it to be external (True). External URLs\n-            include the scheme and domain. When not in an active\n-            request, URLs are external by default.\n-        :param values: Values to use for the variable parts of the URL\n-            rule. Unknown keys are appended as query string arguments,\n-            like ``?a=b&c=d``.\n-\n-        .. versionadded:: 2.2\n-            Moved from ``flask.url_for``, which calls this method.\n-        \"\"\"\n-        req_ctx = _cv_request.get(None)\n-\n-        if req_ctx is not None:\n-            url_adapter = req_ctx.url_adapter\n-            blueprint_name = req_ctx.request.blueprint\n-\n-            # If the endpoint starts with \".\" and the request matches a\n-            # blueprint, the endpoint is relative to the blueprint.\n-            if endpoint[:1] == \".\":\n-                if blueprint_name is not None:\n-                    endpoint = f\"{blueprint_name}{endpoint}\"\n-                else:\n-                    endpoint = endpoint[1:]\n-\n-            # When in a request, generate a URL without scheme and\n-            # domain by default, unless a scheme is given.\n-            if _external is None:\n-                _external = _scheme is not None\n-        else:\n-            app_ctx = _cv_app.get(None)\n-\n-            # If called by helpers.url_for, an app context is active,\n-            # use its url_adapter. Otherwise, app.url_for was called\n-            # directly, build an adapter.\n-            if app_ctx is not None:\n-                url_adapter = app_ctx.url_adapter\n-            else:\n-                url_adapter = self.create_url_adapter(None)\n-\n-            if url_adapter is None:\n-                raise RuntimeError(\n-                    \"Unable to build URLs outside an active request\"\n-                    \" without 'SERVER_NAME' configured. Also configure\"\n-                    \" 'APPLICATION_ROOT' and 'PREFERRED_URL_SCHEME' as\"\n-                    \" needed.\"\n-                )\n-\n-            # When outside a request, generate a URL with scheme and\n-            # domain by default.\n-            if _external is None:\n-                _external = True\n-\n-        # It is an error to set _scheme when _external=False, in order\n-        # to avoid accidental insecure URLs.\n-        if _scheme is not None and not _external:\n-            raise ValueError(\"When specifying '_scheme', '_external' must be True.\")\n-\n-        self.inject_url_defaults(endpoint, values)\n-\n-        try:\n-            rv = url_adapter.build(  # type: ignore[union-attr]\n-                endpoint,\n-                values,\n-                method=_method,\n-                url_scheme=_scheme,\n-                force_external=_external,\n-            )\n-        except BuildError as error:\n-            values.update(\n-                _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external\n-            )\n-            return self.handle_url_build_error(error, endpoint, values)\n-\n-        if _anchor is not None:\n-            _anchor = _url_quote(_anchor, safe=\"%!#$&'()*+,/:;=?@\")\n-            rv = f\"{rv}#{_anchor}\"\n-\n-        return rv\n-\n     def redirect(self, location: str, code: int = 302) -> BaseResponse:\n         \"\"\"Create a redirect response object.\n \n@@ -1695,188 +904,10 @@ class Flask(Scaffold):\n         .. versionadded:: 2.2\n             Moved from ``flask.redirect``, which calls this method.\n         \"\"\"\n-        return _wz_redirect(location, code=code, Response=self.response_class)\n-\n-    def make_response(self, rv: ft.ResponseReturnValue) -> Response:\n-        \"\"\"Convert the return value from a view function to an instance of\n-        :attr:`response_class`.\n-\n-        :param rv: the return value from the view function. The view function\n-            must return a response. Returning ``None``, or the view ending\n-            without returning, is not allowed. The following types are allowed\n-            for ``view_rv``:\n-\n-            ``str``\n-                A response object is created with the string encoded to UTF-8\n-                as the body.\n-\n-            ``bytes``\n-                A response object is created with the bytes as the body.\n-\n-            ``dict``\n-                A dictionary that will be jsonify'd before being returned.\n-\n-            ``list``\n-                A list that will be jsonify'd before being returned.\n-\n-            ``generator`` or ``iterator``\n-                A generator that returns ``str`` or ``bytes`` to be\n-                streamed as the response.\n-\n-            ``tuple``\n-                Either ``(body, status, headers)``, ``(body, status)``, or\n-                ``(body, headers)``, where ``body`` is any of the other types\n-                allowed here, ``status`` is a string or an integer, and\n-                ``headers`` is a dictionary or a list of ``(key, value)``\n-                tuples. If ``body`` is a :attr:`response_class` instance,\n-                ``status`` overwrites the exiting value and ``headers`` are\n-                extended.\n-\n-            :attr:`response_class`\n-                The object is returned unchanged.\n-\n-            other :class:`~werkzeug.wrappers.Response` class\n-                The object is coerced to :attr:`response_class`.\n-\n-            :func:`callable`\n-                The function is called as a WSGI application. The result is\n-                used to create a response object.\n-\n-        .. versionchanged:: 2.2\n-            A generator will be converted to a streaming response.\n-            A list will be converted to a JSON response.\n-\n-        .. versionchanged:: 1.1\n-            A dict will be converted to a JSON response.\n-\n-        .. versionchanged:: 0.9\n-           Previously a tuple was interpreted as the arguments for the\n-           response object.\n-        \"\"\"\n-\n-        status = headers = None\n-\n-        # unpack tuple returns\n-        if isinstance(rv, tuple):\n-            len_rv = len(rv)\n-\n-            # a 3-tuple is unpacked directly\n-            if len_rv == 3:\n-                rv, status, headers = rv  # type: ignore[misc]\n-            # decide if a 2-tuple has status or headers\n-            elif len_rv == 2:\n-                if isinstance(rv[1], (Headers, dict, tuple, list)):\n-                    rv, headers = rv\n-                else:\n-                    rv, status = rv  # type: ignore[assignment,misc]\n-            # other sized tuples are not allowed\n-            else:\n-                raise TypeError(\n-                    \"The view function did not return a valid response tuple.\"\n-                    \" The tuple must have the form (body, status, headers),\"\n-                    \" (body, status), or (body, headers).\"\n+        return _wz_redirect(\n+            location, code=code, Response=self.response_class  # type: ignore[arg-type]\n         )\n \n-        # the body must not be None\n-        if rv is None:\n-            raise TypeError(\n-                f\"The view function for {request.endpoint!r} did not\"\n-                \" return a valid response. The function either returned\"\n-                \" None or ended without a return statement.\"\n-            )\n-\n-        # make sure the body is an instance of the response class\n-        if not isinstance(rv, self.response_class):\n-            if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, _abc_Iterator):\n-                # let the response class set the status and headers instead of\n-                # waiting to do it manually, so that the class can handle any\n-                # special logic\n-                rv = self.response_class(\n-                    rv,\n-                    status=status,\n-                    headers=headers,  # type: ignore[arg-type]\n-                )\n-                status = headers = None\n-            elif isinstance(rv, (dict, list)):\n-                rv = self.json.response(rv)\n-            elif isinstance(rv, BaseResponse) or callable(rv):\n-                # evaluate a WSGI callable, or coerce a different response\n-                # class to the correct type\n-                try:\n-                    rv = self.response_class.force_type(\n-                        rv, request.environ  # type: ignore[arg-type]\n-                    )\n-                except TypeError as e:\n-                    raise TypeError(\n-                        f\"{e}\\nThe view function did not return a valid\"\n-                        \" response. The return type must be a string,\"\n-                        \" dict, list, tuple with headers or status,\"\n-                        \" Response instance, or WSGI callable, but it\"\n-                        f\" was a {type(rv).__name__}.\"\n-                    ).with_traceback(sys.exc_info()[2]) from None\n-            else:\n-                raise TypeError(\n-                    \"The view function did not return a valid\"\n-                    \" response. The return type must be a string,\"\n-                    \" dict, list, tuple with headers or status,\"\n-                    \" Response instance, or WSGI callable, but it was a\"\n-                    f\" {type(rv).__name__}.\"\n-                )\n-\n-        rv = t.cast(Response, rv)\n-        # prefer the status if it was provided\n-        if status is not None:\n-            if isinstance(status, (str, bytes, bytearray)):\n-                rv.status = status\n-            else:\n-                rv.status_code = status\n-\n-        # extend existing headers with provided headers\n-        if headers:\n-            rv.headers.update(headers)  # type: ignore[arg-type]\n-\n-        return rv\n-\n-    def create_url_adapter(self, request: Request | None) -> MapAdapter | None:\n-        \"\"\"Creates a URL adapter for the given request. The URL adapter\n-        is created at a point where the request context is not yet set\n-        up so the request is passed explicitly.\n-\n-        .. versionadded:: 0.6\n-\n-        .. versionchanged:: 0.9\n-           This can now also be called without a request object when the\n-           URL adapter is created for the application context.\n-\n-        .. versionchanged:: 1.0\n-            :data:`SERVER_NAME` no longer implicitly enables subdomain\n-            matching. Use :attr:`subdomain_matching` instead.\n-        \"\"\"\n-        if request is not None:\n-            # If subdomain matching is disabled (the default), use the\n-            # default subdomain in all cases. This should be the default\n-            # in Werkzeug but it currently does not have that feature.\n-            if not self.subdomain_matching:\n-                subdomain = self.url_map.default_subdomain or None\n-            else:\n-                subdomain = None\n-\n-            return self.url_map.bind_to_environ(\n-                request.environ,\n-                server_name=self.config[\"SERVER_NAME\"],\n-                subdomain=subdomain,\n-            )\n-        # We need at the very least the server name to be set for this\n-        # to work.\n-        if self.config[\"SERVER_NAME\"] is not None:\n-            return self.url_map.bind(\n-                self.config[\"SERVER_NAME\"],\n-                script_name=self.config[\"APPLICATION_ROOT\"],\n-                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n-            )\n-\n-        return None\n-\n     def inject_url_defaults(self, endpoint: str, values: dict) -> None:\n         \"\"\"Injects the URL defaults for the given endpoint directly into\n         the values dictionary passed.  This is used internally and\n@@ -1931,264 +962,3 @@ class Flask(Scaffold):\n             raise\n \n         raise error\n-\n-    def preprocess_request(self) -> ft.ResponseReturnValue | None:\n-        \"\"\"Called before the request is dispatched. Calls\n-        :attr:`url_value_preprocessors` registered with the app and the\n-        current blueprint (if any). Then calls :attr:`before_request_funcs`\n-        registered with the app and the blueprint.\n-\n-        If any :meth:`before_request` handler returns a non-None value, the\n-        value is handled as if it was the return value from the view, and\n-        further request handling is stopped.\n-        \"\"\"\n-        names = (None, *reversed(request.blueprints))\n-\n-        for name in names:\n-            if name in self.url_value_preprocessors:\n-                for url_func in self.url_value_preprocessors[name]:\n-                    url_func(request.endpoint, request.view_args)\n-\n-        for name in names:\n-            if name in self.before_request_funcs:\n-                for before_func in self.before_request_funcs[name]:\n-                    rv = self.ensure_sync(before_func)()\n-\n-                    if rv is not None:\n-                        return rv\n-\n-        return None\n-\n-    def process_response(self, response: Response) -> Response:\n-        \"\"\"Can be overridden in order to modify the response object\n-        before it's sent to the WSGI server.  By default this will\n-        call all the :meth:`after_request` decorated functions.\n-\n-        .. versionchanged:: 0.5\n-           As of Flask 0.5 the functions registered for after request\n-           execution are called in reverse order of registration.\n-\n-        :param response: a :attr:`response_class` object.\n-        :return: a new response object or the same, has to be an\n-                 instance of :attr:`response_class`.\n-        \"\"\"\n-        ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]\n-\n-        for func in ctx._after_request_functions:\n-            response = self.ensure_sync(func)(response)\n-\n-        for name in chain(request.blueprints, (None,)):\n-            if name in self.after_request_funcs:\n-                for func in reversed(self.after_request_funcs[name]):\n-                    response = self.ensure_sync(func)(response)\n-\n-        if not self.session_interface.is_null_session(ctx.session):\n-            self.session_interface.save_session(self, ctx.session, response)\n-\n-        return response\n-\n-    def do_teardown_request(\n-        self, exc: BaseException | None = _sentinel  # type: ignore\n-    ) -> None:\n-        \"\"\"Called after the request is dispatched and the response is\n-        returned, right before the request context is popped.\n-\n-        This calls all functions decorated with\n-        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`\n-        if a blueprint handled the request. Finally, the\n-        :data:`request_tearing_down` signal is sent.\n-\n-        This is called by\n-        :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,\n-        which may be delayed during testing to maintain access to\n-        resources.\n-\n-        :param exc: An unhandled exception raised while dispatching the\n-            request. Detected from the current exception information if\n-            not passed. Passed to each teardown function.\n-\n-        .. versionchanged:: 0.9\n-            Added the ``exc`` argument.\n-        \"\"\"\n-        if exc is _sentinel:\n-            exc = sys.exc_info()[1]\n-\n-        for name in chain(request.blueprints, (None,)):\n-            if name in self.teardown_request_funcs:\n-                for func in reversed(self.teardown_request_funcs[name]):\n-                    self.ensure_sync(func)(exc)\n-\n-        request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\n-\n-    def do_teardown_appcontext(\n-        self, exc: BaseException | None = _sentinel  # type: ignore\n-    ) -> None:\n-        \"\"\"Called right before the application context is popped.\n-\n-        When handling a request, the application context is popped\n-        after the request context. See :meth:`do_teardown_request`.\n-\n-        This calls all functions decorated with\n-        :meth:`teardown_appcontext`. Then the\n-        :data:`appcontext_tearing_down` signal is sent.\n-\n-        This is called by\n-        :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.\n-\n-        .. versionadded:: 0.9\n-        \"\"\"\n-        if exc is _sentinel:\n-            exc = sys.exc_info()[1]\n-\n-        for func in reversed(self.teardown_appcontext_funcs):\n-            self.ensure_sync(func)(exc)\n-\n-        appcontext_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)\n-\n-    def app_context(self) -> AppContext:\n-        \"\"\"Create an :class:`~flask.ctx.AppContext`. Use as a ``with``\n-        block to push the context, which will make :data:`current_app`\n-        point at this application.\n-\n-        An application context is automatically pushed by\n-        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n-        when handling a request, and when running a CLI command. Use\n-        this to manually create a context outside of these situations.\n-\n-        ::\n-\n-            with app.app_context():\n-                init_db()\n-\n-        See :doc:`/appcontext`.\n-\n-        .. versionadded:: 0.9\n-        \"\"\"\n-        return AppContext(self)\n-\n-    def request_context(self, environ: dict) -> RequestContext:\n-        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n-        WSGI environment. Use a ``with`` block to push the context,\n-        which will make :data:`request` point at this request.\n-\n-        See :doc:`/reqcontext`.\n-\n-        Typically you should not call this from your own code. A request\n-        context is automatically pushed by the :meth:`wsgi_app` when\n-        handling a request. Use :meth:`test_request_context` to create\n-        an environment and context instead of this method.\n-\n-        :param environ: a WSGI environment\n-        \"\"\"\n-        return RequestContext(self, environ)\n-\n-    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n-        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n-        environment created from the given values. This is mostly useful\n-        during testing, where you may want to run a function that uses\n-        request data without dispatching a full request.\n-\n-        See :doc:`/reqcontext`.\n-\n-        Use a ``with`` block to push the context, which will make\n-        :data:`request` point at the request for the created\n-        environment. ::\n-\n-            with app.test_request_context(...):\n-                generate_report()\n-\n-        When using the shell, it may be easier to push and pop the\n-        context manually to avoid indentation. ::\n-\n-            ctx = app.test_request_context(...)\n-            ctx.push()\n-            ...\n-            ctx.pop()\n-\n-        Takes the same arguments as Werkzeug's\n-        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from\n-        the application. See the linked Werkzeug docs for most of the\n-        available arguments. Flask-specific behavior is listed here.\n-\n-        :param path: URL path being requested.\n-        :param base_url: Base URL where the app is being served, which\n-            ``path`` is relative to. If not given, built from\n-            :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n-            :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n-        :param subdomain: Subdomain name to append to\n-            :data:`SERVER_NAME`.\n-        :param url_scheme: Scheme to use instead of\n-            :data:`PREFERRED_URL_SCHEME`.\n-        :param data: The request body, either as a string or a dict of\n-            form keys and values.\n-        :param json: If given, this is serialized as JSON and passed as\n-            ``data``. Also defaults ``content_type`` to\n-            ``application/json``.\n-        :param args: other positional arguments passed to\n-            :class:`~werkzeug.test.EnvironBuilder`.\n-        :param kwargs: other keyword arguments passed to\n-            :class:`~werkzeug.test.EnvironBuilder`.\n-        \"\"\"\n-        from .testing import EnvironBuilder\n-\n-        builder = EnvironBuilder(self, *args, **kwargs)\n-\n-        try:\n-            return self.request_context(builder.get_environ())\n-        finally:\n-            builder.close()\n-\n-    def wsgi_app(self, environ: dict, start_response: t.Callable) -> t.Any:\n-        \"\"\"The actual WSGI application. This is not implemented in\n-        :meth:`__call__` so that middlewares can be applied without\n-        losing a reference to the app object. Instead of doing this::\n-\n-            app = MyMiddleware(app)\n-\n-        It's a better idea to do this instead::\n-\n-            app.wsgi_app = MyMiddleware(app.wsgi_app)\n-\n-        Then you still have the original application object around and\n-        can continue to call methods on it.\n-\n-        .. versionchanged:: 0.7\n-            Teardown events for the request and app contexts are called\n-            even if an unhandled error occurs. Other events may not be\n-            called depending on when an error occurs during dispatch.\n-            See :ref:`callbacks-and-errors`.\n-\n-        :param environ: A WSGI environment.\n-        :param start_response: A callable accepting a status code,\n-            a list of headers, and an optional exception context to\n-            start the response.\n-        \"\"\"\n-        ctx = self.request_context(environ)\n-        error: BaseException | None = None\n-        try:\n-            try:\n-                ctx.push()\n-                response = self.full_dispatch_request()\n-            except Exception as e:\n-                error = e\n-                response = self.handle_exception(e)\n-            except:  # noqa: B001\n-                error = sys.exc_info()[1]\n-                raise\n-            return response(environ, start_response)\n-        finally:\n-            if \"werkzeug.debug.preserve_context\" in environ:\n-                environ[\"werkzeug.debug.preserve_context\"](_cv_app.get())\n-                environ[\"werkzeug.debug.preserve_context\"](_cv_request.get())\n-\n-            if error is not None and self.should_ignore_error(error):\n-                error = None\n-\n-            ctx.pop(error)\n-\n-    def __call__(self, environ: dict, start_response: t.Callable) -> t.Any:\n-        \"\"\"The WSGI server calls the Flask application object as the\n-        WSGI application. This calls :meth:`wsgi_app`, which can be\n-        wrapped to apply middleware.\n-        \"\"\"\n-        return self.wsgi_app(environ, start_response)\n\n@@ -5,14 +5,14 @@ import typing as t\n from collections import defaultdict\n from functools import update_wrapper\n \n-from . import typing as ft\n+from .. import typing as ft\n from .scaffold import _endpoint_from_view_func\n from .scaffold import _sentinel\n from .scaffold import Scaffold\n from .scaffold import setupmethod\n \n if t.TYPE_CHECKING:  # pragma: no cover\n-    from .app import Flask\n+    from .app import App\n \n DeferredSetupFunction = t.Callable[[\"BlueprintSetupState\"], t.Callable]\n T_after_request = t.TypeVar(\"T_after_request\", bound=ft.AfterRequestCallable)\n@@ -41,7 +41,7 @@ class BlueprintSetupState:\n     def __init__(\n         self,\n         blueprint: Blueprint,\n-        app: Flask,\n+        app: App,\n         options: t.Any,\n         first_registration: bool,\n     ) -> None:\n@@ -244,7 +244,7 @@ class Blueprint(Scaffold):\n         self.record(update_wrapper(wrapper, func))\n \n     def make_setup_state(\n-        self, app: Flask, options: dict, first_registration: bool = False\n+        self, app: App, options: dict, first_registration: bool = False\n     ) -> BlueprintSetupState:\n         \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n         object that is later passed to the register callback functions.\n@@ -270,7 +270,7 @@ class Blueprint(Scaffold):\n             raise ValueError(\"Cannot register a blueprint on itself\")\n         self._blueprints.append((blueprint, options))\n \n-    def register(self, app: Flask, options: dict) -> None:\n+    def register(self, app: App, options: dict) -> None:\n         \"\"\"Called by :meth:`Flask.register_blueprint` to register all\n         views and callbacks registered on the blueprint with the\n         application. Creates a :class:`.BlueprintSetupState` and calls\n@@ -323,7 +323,7 @@ class Blueprint(Scaffold):\n         if self.has_static_folder:\n             state.add_url_rule(\n                 f\"{self.static_url_path}/<path:filename>\",\n-                view_func=self.send_static_file,\n+                view_func=self.send_static_file,  # type: ignore[attr-defined]\n                 endpoint=\"static\",\n             )\n \n\n@@ -6,7 +6,6 @@ import pathlib\n import sys\n import typing as t\n from collections import defaultdict\n-from datetime import timedelta\n from functools import update_wrapper\n \n from jinja2 import FileSystemLoader\n@@ -14,15 +13,10 @@ from werkzeug.exceptions import default_exceptions\n from werkzeug.exceptions import HTTPException\n from werkzeug.utils import cached_property\n \n-from . import typing as ft\n-from .cli import AppGroup\n-from .globals import current_app\n-from .helpers import get_root_path\n-from .helpers import send_from_directory\n-from .templating import _default_template_ctx_processor\n-\n-if t.TYPE_CHECKING:  # pragma: no cover\n-    from .wrappers import Response\n+from .. import typing as ft\n+from ..cli import AppGroup\n+from ..helpers import get_root_path\n+from ..templating import _default_template_ctx_processor\n \n # a singleton sentinel value for parameter defaults\n _sentinel = object()\n@@ -276,48 +270,6 @@ class Scaffold:\n \n         self._static_url_path = value\n \n-    def get_send_file_max_age(self, filename: str | None) -> int | None:\n-        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n-        value for a given file path if it wasn't passed.\n-\n-        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n-        the configuration of :data:`~flask.current_app`. This defaults\n-        to ``None``, which tells the browser to use conditional requests\n-        instead of a timed cache, which is usually preferable.\n-\n-        .. versionchanged:: 2.0\n-            The default configuration is ``None`` instead of 12 hours.\n-\n-        .. versionadded:: 0.9\n-        \"\"\"\n-        value = current_app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n-\n-        if value is None:\n-            return None\n-\n-        if isinstance(value, timedelta):\n-            return int(value.total_seconds())\n-\n-        return value\n-\n-    def send_static_file(self, filename: str) -> Response:\n-        \"\"\"The view function used to serve files from\n-        :attr:`static_folder`. A route is automatically registered for\n-        this view at :attr:`static_url_path` if :attr:`static_folder` is\n-        set.\n-\n-        .. versionadded:: 0.5\n-        \"\"\"\n-        if not self.has_static_folder:\n-            raise RuntimeError(\"'static_folder' must be set to serve static_files.\")\n-\n-        # send_file only knows to call get_send_file_max_age on the app,\n-        # call it here so it works for blueprints too.\n-        max_age = self.get_send_file_max_age(filename)\n-        return send_from_directory(\n-            t.cast(str, self.static_folder), filename, max_age=max_age\n-        )\n-\n     @cached_property\n     def jinja_loader(self) -> FileSystemLoader | None:\n         \"\"\"The Jinja loader for this object's templates. By default this\n@@ -331,29 +283,6 @@ class Scaffold:\n         else:\n             return None\n \n-    def open_resource(self, resource: str, mode: str = \"rb\") -> t.IO[t.AnyStr]:\n-        \"\"\"Open a resource file relative to :attr:`root_path` for\n-        reading.\n-\n-        For example, if the file ``schema.sql`` is next to the file\n-        ``app.py`` where the ``Flask`` app is defined, it can be opened\n-        with:\n-\n-        .. code-block:: python\n-\n-            with app.open_resource(\"schema.sql\") as f:\n-                conn.executescript(f.read())\n-\n-        :param resource: Path to the resource relative to\n-            :attr:`root_path`.\n-        :param mode: Open the file in this mode. Only reading is\n-            supported, valid values are \"r\" (or \"rt\") and \"rb\".\n-        \"\"\"\n-        if mode not in {\"r\", \"rt\", \"rb\"}:\n-            raise ValueError(\"Resources can only be opened for reading.\")\n-\n-        return open(os.path.join(self.root_path, resource), mode)\n-\n     def _method_route(\n         self,\n         method: str,\n\n@@ -17,7 +17,8 @@ from .signals import template_rendered\n \n if t.TYPE_CHECKING:  # pragma: no cover\n     from .app import Flask\n-    from .scaffold import Scaffold\n+    from .sansio.app import App\n+    from .sansio.scaffold import Scaffold\n \n \n def _default_template_ctx_processor() -> dict[str, t.Any]:\n@@ -41,7 +42,7 @@ class Environment(BaseEnvironment):\n     name of the blueprint to referenced templates if necessary.\n     \"\"\"\n \n-    def __init__(self, app: Flask, **options: t.Any) -> None:\n+    def __init__(self, app: App, **options: t.Any) -> None:\n         if \"loader\" not in options:\n             options[\"loader\"] = app.create_global_jinja_loader()\n         BaseEnvironment.__init__(self, **options)\n@@ -53,7 +54,7 @@ class DispatchingJinjaLoader(BaseLoader):\n     the blueprint folders.\n     \"\"\"\n \n-    def __init__(self, app: Flask) -> None:\n+    def __init__(self, app: App) -> None:\n         self.app = app\n \n     def get_source(  # type: ignore\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
