{"custom_id": "requests#2b5aed78d02a3bd3090e8926bfd20d4d7edc1e88", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 1448 | Contributors (this commit): 23 | Commits (past 90d): 13 | Contributors (cumulative): 23 | DMM Complexity: 0.0\n\nDIFF:\n@@ -243,7 +243,7 @@ class Session(SessionMixin):\n         req.auth = auth\n         req.cookies = cookies\n         # TODO: move to attached\n-        req.allow_redirects = allow_redirects\n+        # req.allow_redirects = allow_redirects\n         req.proxies = proxies\n         req.hooks = hooks\n \n@@ -251,7 +251,7 @@ class Session(SessionMixin):\n \n         # TODO: prepare cookies.\n \n-        resp = self.send(prep)\n+        resp = self.send(prep, prefetch, timeout, verify, cert)\n \n         # Redirect resolving generator.\n         gen = self.resolve_redirects(resp, req, prefetch, timeout, verify, cert)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#cc4b0b110f60b495f0f159150a9e99553d43aa4c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 18 | Lines Deleted: 27 | Files Changed: 4 | Hunks: 8 | Methods Changed: 3 | Complexity Δ (Sum/Max): 5/5 | Churn Δ: 45 | Churn Cumulative: 3581 | Contributors (this commit): 54 | Commits (past 90d): 38 | Contributors (cumulative): 68 | DMM Complexity: 0.8888888888888888\n\nDIFF:\n@@ -34,8 +34,8 @@ class BaseAdapter(object):\n     def __init__(self):\n         super(BaseAdapter, self).__init__()\n \n-    # def send(self):\n-    #     raise NotImplementedError\n+    def send(self):\n+        raise NotImplementedError\n \n     def close(self):\n         raise NotImplementedError\n\n@@ -19,18 +19,3 @@ Configurations:\n \"\"\"\n \n SCHEMAS = ['http', 'https']\n-\n-from .utils import default_user_agent\n-\n-defaults = dict()\n-\n-defaults['base_headers'] = {\n-    'User-Agent': default_user_agent(),\n-    'Accept-Encoding': ', '.join(('gzip', 'deflate', 'compress')),\n-    'Accept': '*/*'\n-}\n-\n-# Consumed at the session level, not connection.\n-defaults['max_redirects'] = 30\n-defaults['trust_env'] = True\n-# defaults['support_http0.9'] = True\n\n@@ -12,10 +12,9 @@ requests (cookies, auth, proxies).\n from copy import deepcopy\n from .compat import cookielib\n from .cookies import cookiejar_from_dict, remove_cookie_by_name\n-from .defaults import defaults\n from .models import Request\n from .hooks import dispatch_hook\n-from .utils import header_expand, from_key_val_list\n+from .utils import header_expand, from_key_val_list, default_headers\n from .packages.urllib3.poolmanager import PoolManager\n \n from .compat import urlparse, urljoin\n@@ -25,7 +24,7 @@ from .utils import requote_uri\n \n from .status_codes import codes\n REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)\n-\n+DEFAULT_REDIRECT_LIMIT = 30\n \n \n def merge_kwargs(local_kwarg, default_kwarg):\n@@ -135,11 +134,6 @@ class SessionMixin(object):\n \n \n \n-\n-\n-\n-\n-\n class Session(SessionMixin):\n     \"\"\"A Requests session.\"\"\"\n \n@@ -198,8 +192,13 @@ class Session(SessionMixin):\n         #: SSL certificate.\n         self.cert = cert\n \n-        for (k, v) in list(defaults.items()):\n-            self.config.setdefault(k, deepcopy(v))\n+        #: Maximum number of redirects to follow.\n+        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n+\n+        #: Should we trust the environment\n+        self.trust_env = True\n+\n+        self.default_headers = default_headers()\n \n         # Set up a CookieJar to be used by default\n         if isinstance(cookies, cookielib.CookieJar):\n\n@@ -570,6 +570,13 @@ def default_user_agent():\n             '%s/%s' % (p_system, p_release),\n         ])\n \n+def default_headers():\n+    return {\n+        'User-Agent': default_user_agent(),\n+        'Accept-Encoding': ', '.join(('gzip', 'deflate', 'compress')),\n+        'Accept': '*/*'\n+    }\n+\n \n def parse_header_links(value):\n     \"\"\"Return a dict of parsed link headers proxies.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#94e82e9cc2e7eb9934ed086a69d3b49ddf3ce3eb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 25 | Files Changed: 2 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): -1/0 | Churn Δ: 26 | Churn Cumulative: 8461 | Contributors (this commit): 93 | Commits (past 90d): 53 | Contributors (cumulative): 97 | DMM Complexity: 1.0\n\nDIFF:\n@@ -1,21 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-requests.defaults\n-~~~~~~~~~~~~~~~~~\n-\n-This module provides the Requests configuration defaults.\n-\n-Configurations:\n-\n-:base_headers: Default HTTP headers.\n-:max_redirects: Maximum number of redirects allowed within a request.s\n-:keep_alive: Reuse HTTP Connections?\n-:max_retries: The number of times a request should be retried in the event of a connection failure.\n-:pool_maxsize: The maximium size of an HTTP connection pool.\n-:pool_connections: The number of active HTTP connection pools to use.\n-:encode_uri: If true, URIs will automatically be percent-encoded.\n-:trust_env: If true, the surrouding environment will be trusted (environ, netrc).\n-\"\"\"\n-\n-SCHEMAS = ['http', 'https']\n\n@@ -27,7 +27,7 @@ from .packages.urllib3.exceptions import SSLError as _SSLError\n from .packages.urllib3.exceptions import HTTPError as _HTTPError\n from .packages.urllib3 import connectionpool, poolmanager\n from .packages.urllib3.filepost import encode_multipart_formdata\n-from .defaults import SCHEMAS\n+\n from .exceptions import (\n     ConnectionError, HTTPError, RequestException, Timeout, TooManyRedirects,\n     URLRequired, SSLError, MissingSchema, InvalidSchema, InvalidURL)\n@@ -235,9 +235,6 @@ class PreparedRequest(RequestMixin):\n         if not scheme:\n             raise MissingSchema(\"Invalid URL %r: No schema supplied\" % url)\n \n-        if not scheme in SCHEMAS:\n-            raise InvalidSchema(\"Invalid scheme %r\" % scheme)\n-\n         try:\n             netloc = netloc.encode('idna').decode('utf-8')\n         except UnicodeError:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b1bcaecc66c5bbead66b74c565771fa4fa5cf6cc", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 8 | Lines Deleted: 11 | Files Changed: 1 | Hunks: 9 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 19 | Churn Cumulative: 1486 | Contributors (this commit): 23 | Commits (past 90d): 15 | Contributors (cumulative): 23 | DMM Complexity: 0.0\n\nDIFF:\n@@ -16,6 +16,7 @@ from .models import Request\n from .hooks import dispatch_hook\n from .utils import header_expand, from_key_val_list, default_headers\n from .packages.urllib3.poolmanager import PoolManager\n+from .exceptions import TooManyRedirects\n \n from .compat import urlparse, urljoin\n from .adapters import HTTPAdapter\n@@ -61,27 +62,26 @@ def merge_kwargs(local_kwarg, default_kwarg):\n     return kwargs\n \n \n-\n class SessionMixin(object):\n \n     def resolve_redirects(self, resp, req, prefetch=True, timeout=None, verify=True, cert=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+        i = 0\n \n         # ((resp.status_code is codes.see_other))\n         while (('location' in resp.headers and resp.status_code in REDIRECT_STATI)):\n \n             resp.content  # Consume socket so it can be released\n \n-            # if not len(history) < self.config.get('max_redirects'):\n-                # raise TooManyRedirects()\n+            if i > self.max_redirects:\n+                raise TooManyRedirects()\n \n             # Release the connection back into the pool.\n             resp.close()\n \n-            # history.append(r)\n-\n             url = resp.headers['location']\n+            method = req.method\n \n             # Handle redirection without scheme (see: RFC 1808 Section 4)\n             if url.startswith('//'):\n@@ -91,16 +91,12 @@ class SessionMixin(object):\n             # Facilitate non-RFC2616-compliant 'location' headers\n             # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n             if not urlparse(url).netloc:\n-                url = urljoin(resp.url,\n-                              # Compliant with RFC3986, we percent\n-                              # encode the url.\n-                              requote_uri(url))\n+                # Compliant with RFC3986, we percent encode the url.\n+                url = urljoin(resp.url, requote_uri(url))\n \n             # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n             if resp.status_code is codes.see_other:\n                 method = 'GET'\n-            else:\n-                method = req.method\n \n             # Do what the browsers do, despite standards...\n             if resp.status_code in (codes.moved, codes.found) and req.method == 'POST':\n@@ -130,6 +126,7 @@ class SessionMixin(object):\n                 )\n \n             yield resp\n+            i += 1\n \n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#f44bb31bec2d36d113f642640f384832114ab7fb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 1490 | Contributors (this commit): 23 | Commits (past 90d): 16 | Contributors (cumulative): 23 | DMM Complexity: None\n\nDIFF:\n@@ -125,10 +125,8 @@ class SessionMixin(object):\n                     cert=cert\n                 )\n \n-            yield resp\n             i += 1\n-\n-\n+            yield resp\n \n \n class Session(SessionMixin):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e766f0b67caa6facf4a9173f1dc3eb931dd16e24", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 5 | Files Changed: 1 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 8 | Churn Cumulative: 216 | Contributors (this commit): 1 | Commits (past 90d): 5 | Contributors (cumulative): 1 | DMM Complexity: 0.0\n\nDIFF:\n@@ -10,7 +10,7 @@ and maintain connections.\n import os\n from .models import Response\n from .packages.urllib3.poolmanager import PoolManager\n-from .utils import DEFAULT_CA_BUNDLE_PATH\n+from .utils import DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers\n \n import socket\n from .structures import CaseInsensitiveDict\n@@ -43,9 +43,7 @@ class BaseAdapter(object):\n \n class HTTPAdapter(BaseAdapter):\n     \"\"\"Built-In HTTP Adapter for Urllib3.\"\"\"\n-    def __init__(self,\n-        pool_connections=DEFAULT_POOLSIZE,\n-        pool_maxsize=DEFAULT_POOLSIZE):\n+    def __init__(self, pool_connections=DEFAULT_POOLSIZE, pool_maxsize=DEFAULT_POOLSIZE):\n         self.max_retries = DEFAULT_RETRIES\n         self.config = {}\n \n@@ -103,7 +101,7 @@ class HTTPAdapter(BaseAdapter):\n         response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))\n \n         # Set encoding.\n-        # response.encoding = get_encoding_from_headers(response.headers)\n+        response.encoding = get_encoding_from_headers(response.headers)\n         response.raw = resp\n \n         if isinstance(req.url, bytes):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e4b56049ad1908365615ed53e4d36b4f916ca695", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 6 | Files Changed: 2 | Hunks: 5 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 10 | Churn Cumulative: 8395 | Contributors (this commit): 90 | Commits (past 90d): 51 | Contributors (cumulative): 91 | DMM Complexity: None\n\nDIFF:\n@@ -20,6 +20,7 @@ from .packages.urllib3.exceptions import SSLError as _SSLError\n from .packages.urllib3.exceptions import HTTPError as _HTTPError\n from .packages.urllib3 import connectionpool, poolmanager\n from .packages.urllib3.filepost import encode_multipart_formdata\n+from .cookies import extract_cookies_to_jar\n from .exceptions import (\n ConnectionError, HTTPError, RequestException, Timeout, TooManyRedirects,\n URLRequired, SSLError, MissingSchema, InvalidSchema, InvalidURL)\n@@ -109,10 +110,10 @@ class HTTPAdapter(BaseAdapter):\n         else:\n             response.url = req.url\n \n-        return response\n         # Add new cookies from the server.\n-        # extract_cookies_to_jar(self.cookies, self, resp)\n+        extract_cookies_to_jar(response.cookies, req, resp)\n \n+        return response\n \n \n     def close(self):\n\n@@ -385,10 +385,7 @@ class Response(object):\n         self.reason = None\n \n         #: A CookieJar of Cookies the server sent back.\n-        self.cookies = None\n-\n-        #: Dictionary of configurations for this request.\n-        self.config = {}\n+        self.cookies = cookiejar_from_dict({})\n \n     def __repr__(self):\n         return '<Response [%s]>' % (self.status_code)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#8cf6a3593d08e62c635010d66ca9794f3be539ea", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 2 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 226 | Contributors (this commit): 1 | Commits (past 90d): 7 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -14,12 +14,11 @@ from .utils import DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers\n \n import socket\n from .structures import CaseInsensitiveDict\n-from .packages.urllib3.exceptions import MaxRetryError, LocationParseError\n+from .packages.urllib3.exceptions import MaxRetryError\n from .packages.urllib3.exceptions import TimeoutError\n from .packages.urllib3.exceptions import SSLError as _SSLError\n from .packages.urllib3.exceptions import HTTPError as _HTTPError\n-from .packages.urllib3 import connectionpool, poolmanager\n-from .packages.urllib3.filepost import encode_multipart_formdata\n+from .packages.urllib3 import poolmanager\n from .cookies import extract_cookies_to_jar\n from .exceptions import (\n ConnectionError, HTTPError, RequestException, Timeout, TooManyRedirects,\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4e5c4a6ab7bb0195dececdd19bb8505b872fe120", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 28 | Files Changed: 3 | Hunks: 10 | Methods Changed: 4 | Complexity Δ (Sum/Max): -2/0 | Churn Δ: 30 | Churn Cumulative: 2793 | Contributors (this commit): 34 | Commits (past 90d): 31 | Contributors (cumulative): 48 | DMM Complexity: 0.25\n\nDIFF:\n@@ -164,9 +164,3 @@ class HTTPAdapter(BaseAdapter):\n             r.content\n \n         return r\n-\n-\n-\n-\n-\n-\n\n@@ -30,23 +30,12 @@ def request(method, url, **kwargs):\n     :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n     :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n     :param return_response: (optional) If False, an un-sent Request object will returned.\n-    :param session: (optional) A :class:`Session` object to be used for the request.\n-    :param config: (optional) A configuration dictionary. See ``request.defaults`` for allowed keys and their default values.\n     :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n     :param prefetch: (optional) if ``True``, the response content will be immediately downloaded.\n     :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n     \"\"\"\n \n-    # if this session was passed in, leave it open (and retain pooled connections);\n-    # if we're making it just for this call, then close it when we're done.\n-    adhoc_session = False\n-    session = kwargs.pop('session', None)\n-    if session is None:\n-        session = sessions.session(config=kwargs.get('config', None))\n-        adhoc_session = True\n-        # Todo, close sessions after?\n-\n-\n+    session = sessions.Session()\n     return session.request(method=method, url=url, **kwargs)\n \n \n@@ -79,7 +68,6 @@ def head(url, **kwargs):\n     :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n     \"\"\"\n \n-    kwargs.setdefault('allow_redirects', False)\n     return request('head', url, **kwargs)\n \n \n\n@@ -9,13 +9,11 @@ requests (cookies, auth, proxies).\n \n \"\"\"\n \n-from copy import deepcopy\n from .compat import cookielib\n from .cookies import cookiejar_from_dict, remove_cookie_by_name\n from .models import Request\n from .hooks import dispatch_hook\n from .utils import header_expand, from_key_val_list, default_headers\n-from .packages.urllib3.poolmanager import PoolManager\n from .exceptions import TooManyRedirects\n \n from .compat import urlparse, urljoin\n@@ -134,7 +132,7 @@ class Session(SessionMixin):\n \n     __attrs__ = [\n         'headers', 'cookies', 'auth', 'timeout', 'proxies', 'hooks',\n-        'params', 'config', 'verify', 'cert', 'prefetch']\n+        'params', 'verify', 'cert', 'prefetch']\n \n     def __init__(self,\n         headers=None,\n@@ -144,7 +142,6 @@ class Session(SessionMixin):\n         proxies=None,\n         hooks=None,\n         params=None,\n-        config=None,\n         prefetch=True,\n         verify=True,\n         cert=None):\n@@ -174,10 +171,6 @@ class Session(SessionMixin):\n         #: representing multivalued query parameters.\n         self.params = from_key_val_list(params or [])\n \n-        #: Dictionary of configuration parameters for this\n-        #: :class:`Session <Session>`.\n-        self.config = from_key_val_list(config or {})\n-\n         #: Prefetch response content.\n         self.prefetch = prefetch\n \n@@ -222,7 +215,6 @@ class Session(SessionMixin):\n         proxies=None,\n         hooks=None,\n         return_response=True,\n-        config=None,\n         prefetch=None,\n         verify=None,\n         cert=None):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#98a7585fbdc3a9231aad314b7985b170ca3feb42", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 9 | Churn Cumulative: 8183 | Contributors (this commit): 90 | Commits (past 90d): 46 | Contributors (cumulative): 90 | DMM Complexity: 1.0\n\nDIFF:\n@@ -240,6 +240,7 @@ class PreparedRequest(RequestMixin):\n         except UnicodeError:\n             raise InvalidURL('URL has an invalid label.')\n \n+        # Bare domains aren't valid URLs.\n         if not path:\n             path = '/'\n \n@@ -264,13 +265,7 @@ class PreparedRequest(RequestMixin):\n             else:\n                 query = enc_params\n \n-        url = (urlunparse([scheme, netloc, path, params, query, fragment]))\n-\n-        # if self.config.get('encode_uri', True):\n-            # url = requote_uri(url)\n-        # TODO: re-evaluate quote param (perhaps not, people can create this themselves now)\n-        url = requote_uri(url)\n-\n+        url = requote_uri(urlunparse([scheme, netloc, path, params, query, fragment]))\n         self.url = url\n \n     def prepare_headers(self, headers):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#2b4ca0b0dc0af38110b69396cbb0e422c25b5271", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 6 | Files Changed: 1 | Hunks: 5 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 10 | Churn Cumulative: 242 | Contributors (this commit): 1 | Commits (past 90d): 9 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -7,22 +7,20 @@ requests.adapters\n This module contains the transport adapters that Requests uses to define\n and maintain connections.\n \"\"\"\n+\n import os\n+import socket\n+\n from .models import Response\n from .packages.urllib3.poolmanager import PoolManager\n from .utils import DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers\n-\n-import socket\n from .structures import CaseInsensitiveDict\n from .packages.urllib3.exceptions import MaxRetryError\n from .packages.urllib3.exceptions import TimeoutError\n from .packages.urllib3.exceptions import SSLError as _SSLError\n from .packages.urllib3.exceptions import HTTPError as _HTTPError\n-from .packages.urllib3 import poolmanager\n from .cookies import extract_cookies_to_jar\n-from .exceptions import (\n-ConnectionError, HTTPError, RequestException, Timeout, TooManyRedirects,\n-URLRequired, SSLError, MissingSchema, InvalidSchema, InvalidURL)\n+from .exceptions import ConnectionError, Timeout, SSLError\n \n DEFAULT_POOLSIZE = 10\n DEFAULT_RETRIES = 0\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#03c8e23dbbc6690220141bb685fac08ac9494177", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 10 | Files Changed: 2 | Hunks: 3 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 14 | Churn Cumulative: 1976 | Contributors (this commit): 30 | Commits (past 90d): 21 | Contributors (cumulative): 33 | DMM Complexity: 1.0\n\nDIFF:\n@@ -8,22 +8,13 @@ This module provides the capabilities for the Requests hooks system.\n \n Available hooks:\n \n-``pre_request``:\n-    The Request object, directly after being created.\n-\n-``pre_send``:\n-    The Request object, directly before being sent.\n-\n-``post_request``:\n-    The Request object, directly after being sent.\n-\n ``response``:\n     The response generated from a Request.\n \n \"\"\"\n \n \n-HOOKS = ('pre_prepare', 'post_prepare', 'pre_request', 'pre_send', 'post_request', 'response')\n+HOOKS = ('response')\n # TODO: response is the only one\n \n def dispatch_hook(key, hooks, hook_data):\n\n@@ -251,6 +251,9 @@ class Session(SessionMixin):\n             resp = history.pop()\n             resp.history = tuple(history)\n \n+        # Response manipulation hook.\n+        self.response = dispatch_hook('response', hooks, resp)\n+\n         return resp\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e7598e006c051330ef9eb5b33b6c046484af5c2b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 3 | Churn Cumulative: 33 | Contributors (this commit): 1 | Commits (past 90d): 3 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -15,7 +15,8 @@\n # 02110-1301  USA\r\n ######################### END LICENSE BLOCK #########################\r\n \r\n-__version__ = \"1.0.0\"\r\n+__version__ = \"1.0.1\"\r\n+\r\n \r\n def detect(aBuf):\r\n     from . import universaldetector\r\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#377078b0f5cc5944756635f6e506d208b421b1e1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 55 | Lines Deleted: 138 | Files Changed: 3 | Hunks: 12 | Methods Changed: 16 | Complexity Δ (Sum/Max): -6/13 | Churn Δ: 193 | Churn Cumulative: 9674 | Contributors (this commit): 100 | Commits (past 90d): 57 | Contributors (cumulative): 116 | DMM Complexity: 0.0\n\nDIFF:\n@@ -270,126 +270,3 @@ class HTTPDigestAuth(AuthBase):\n             r.headers['Authorization'] = self.build_digest_header(r.method, r.url)\n         r.register_hook('response', self.handle_401)\n         return r\n\\ No newline at end of file\n-\n-\n-def _negotiate_value(r):\n-    \"\"\"Extracts the gssapi authentication token from the appropriate header\"\"\"\n-\n-    authreq = r.headers.get('www-authenticate', None)\n-\n-    if authreq:\n-        rx = re.compile('(?:.*,)*\\s*Negotiate\\s*([^,]*),?', re.I)\n-        mo = rx.search(authreq)\n-        if mo:\n-            return mo.group(1)\n-\n-    return None\n-\n-\n-class HTTPKerberosAuth(AuthBase):\n-    \"\"\"Attaches HTTP GSSAPI/Kerberos Authentication to the given Request object.\"\"\"\n-    def __init__(self, require_mutual_auth=True):\n-        if k is None:\n-            raise Exception(\"Kerberos libraries unavailable\")\n-        self.context = None\n-        self.require_mutual_auth = require_mutual_auth\n-\n-    def generate_request_header(self, r):\n-        \"\"\"Generates the gssapi authentication token with kerberos\"\"\"\n-\n-        host = urlparse(r.url).netloc\n-        tail, _, head = host.rpartition(':')\n-        domain = tail if tail else head\n-\n-        result, self.context = k.authGSSClientInit(\"HTTP@%s\" % domain)\n-\n-        if result < 1:\n-            raise Exception(\"authGSSClientInit failed\")\n-\n-        result = k.authGSSClientStep(self.context, _negotiate_value(r))\n-\n-        if result < 0:\n-            raise Exception(\"authGSSClientStep failed\")\n-\n-        response = k.authGSSClientResponse(self.context)\n-\n-        return \"Negotiate %s\" % response\n-\n-    def authenticate_user(self, r):\n-        \"\"\"Handles user authentication with gssapi/kerberos\"\"\"\n-\n-        auth_header = self.generate_request_header(r)\n-        log.debug(\"authenticate_user(): Authorization header: %s\" % auth_header)\n-        r.request.headers['Authorization'] = auth_header\n-        r.request.send(anyway=True)\n-        _r = r.request.response\n-        _r.history.append(r)\n-        log.debug(\"authenticate_user(): returning %s\" % _r)\n-        return _r\n-\n-    def handle_401(self, r):\n-        \"\"\"Handles 401's, attempts to use gssapi/kerberos authentication\"\"\"\n-\n-        log.debug(\"handle_401(): Handling: 401\")\n-        if _negotiate_value(r) is not None:\n-            _r = self.authenticate_user(r)\n-            log.debug(\"handle_401(): returning %s\" % _r)\n-            return _r\n-        else:\n-            log.debug(\"handle_401(): Kerberos is not supported\")\n-            log.debug(\"handle_401(): returning %s\" % r)\n-            return r\n-\n-    def handle_other(self, r):\n-        \"\"\"Handles all responses with the exception of 401s.\n-\n-        This is necessary so that we can authenticate responses if requested\"\"\"\n-\n-        log.debug(\"handle_other(): Handling: %d\" % r.status_code)\n-        self.deregister(r)\n-        if self.require_mutual_auth:\n-            if _negotiate_value(r) is not None:\n-                log.debug(\"handle_other(): Authenticating the server\")\n-                _r = self.authenticate_server(r)\n-                log.debug(\"handle_other(): returning %s\" % _r)\n-                return _r\n-            else:\n-                log.error(\"handle_other(): Mutual authentication failed\")\n-                raise Exception(\"Mutual authentication failed\")\n-        else:\n-            log.debug(\"handle_other(): returning %s\" % r)\n-            return r\n-\n-    def authenticate_server(self, r):\n-        \"\"\"Uses GSSAPI to authenticate the server\"\"\"\n-\n-        log.debug(\"authenticate_server(): Authenticate header: %s\" % _negotiate_value(r))\n-        result = k.authGSSClientStep(self.context, _negotiate_value(r))\n-        if  result < 1:\n-            raise Exception(\"authGSSClientStep failed\")\n-        _r = r.request.response\n-        log.debug(\"authenticate_server(): returning %s\" % _r)\n-        return _r\n-\n-    def handle_response(self, r):\n-        \"\"\"Takes the given response and tries kerberos-auth, as needed.\"\"\"\n-\n-        if r.status_code == 401:\n-            _r = self.handle_401(r)\n-            log.debug(\"handle_response returning %s\" % _r)\n-            return _r\n-        else:\n-            _r = self.handle_other(r)\n-            log.debug(\"handle_response returning %s\" % _r)\n-            return _r\n-\n-        log.debug(\"handle_response returning %s\" % r)\n-        return r\n-\n-    def deregister(self, r):\n-        \"\"\"Deregisters the response handler\"\"\"\n-        r.request.deregister_hook('response', self.handle_response)\n-\n-    def __call__(self, r):\n-        r.register_hook('response', self.handle_response)\n-        return r\n\n@@ -14,7 +14,14 @@ Available hooks:\n \"\"\"\n \n \n-HOOKS = ('response')\n+HOOKS = ['response']\n+\n+def default_hooks():\n+    hooks = {}\n+    for event in HOOKS:\n+        hooks[event] = []\n+    return hooks\n+\n # TODO: response is the only one\n \n def dispatch_hook(key, hooks, hook_data):\n\n@@ -9,13 +9,13 @@ This module contains the primary objects that power Requests.\n \n # import os\n # import socket\n-# import collections\n+import collections\n import logging\n \n # from datetime import datetime\n from io import BytesIO\n \n-from .hooks import dispatch_hook, HOOKS\n+from .hooks import dispatch_hook, default_hooks\n from .structures import CaseInsensitiveDict\n from .status_codes import codes\n \n@@ -46,7 +46,7 @@ CONTENT_CHUNK_SIZE = 10 * 1024\n log = logging.getLogger(__name__)\n \n \n-class RequestMixin(object):\n+class RequestEncodingMixin(object):\n \n     @property\n     def path_url(self):\n@@ -143,7 +143,30 @@ class RequestMixin(object):\n         return body, content_type\n \n \n-class Request(object):\n+class RequestHooksMixin(object):\n+    def register_hook(self, event, hook):\n+        \"\"\"Properly register a hook.\"\"\"\n+        print self\n+        print event\n+        print hook\n+        if isinstance(hook, collections.Callable):\n+            self.hooks[event].append(hook)\n+        elif hasattr(hook, '__iter__'):\n+            self.hooks[event].extend(h for h in hook if isinstance(h, collections.Callable))\n+\n+    def deregister_hook(self, event, hook):\n+        \"\"\"Deregister a previously registered hook.\n+        Returns True if the hook existed, False if not.\n+        \"\"\"\n+\n+        try:\n+            self.hooks[event].remove(hook)\n+            return True\n+        except ValueError:\n+            return False\n+\n+\n+class Request(RequestHooksMixin):\n     \"\"\"A user-created :class:`Request <Request>` object.\"\"\"\n     def __init__(self,\n         method=None,\n@@ -155,12 +178,18 @@ class Request(object):\n         auth=None,\n         cookies=None,\n         timeout=None,\n-        allow_redirects=False,\n-        proxies=None,\n-        hooks=None,\n-        prefetch=True,\n-        verify=None,\n-        cert=None):\n+        hooks=None):\n+\n+        # Default empty dicts for dict params.\n+        data = [] if data is None else data\n+        files = [] if files is None else files\n+        headers = {} if headers is None else headers\n+        params = {} if params is None else params\n+        hooks = {} if hooks is None else hooks\n+\n+        self.hooks = default_hooks()\n+        for (k, v) in list(hooks.items()):\n+            self.register_hook(event=k, hook=v)\n \n         self.method = method\n         self.url = url\n@@ -170,8 +199,8 @@ class Request(object):\n         self.params = params\n         self.auth = auth\n         self.cookies = cookies\n-        self.allow_redirects = allow_redirects\n-        self.proxies = proxies\n+        # self.allow_redirects = allow_redirects\n+        # self.proxies = proxies\n         self.hooks = hooks\n \n     def __repr__(self):\n@@ -191,7 +220,7 @@ class Request(object):\n         return p\n \n \n-class PreparedRequest(RequestMixin):\n+class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n     \"\"\"The :class:`PreparedRequest <PreparedRequest>` object.\"\"\"\n \n     def __init__(self):\n@@ -203,7 +232,7 @@ class PreparedRequest(RequestMixin):\n         self.auth = None\n         self.allow_redirects = None\n         self.proxies = None\n-        self.hooks = None\n+        self.hooks = default_hooks()\n \n     def __repr__(self):\n         return '<PreparedRequest [%s]>' % (self.method)\n@@ -313,12 +342,16 @@ class PreparedRequest(RequestMixin):\n     def prepare_auth(self, auth):\n         \"\"\"Prepares the given HTTP auth data.\"\"\"\n         if auth:\n+            # print auth\n             if isinstance(auth, tuple) and len(auth) == 2:\n                 # special-case basic HTTP auth\n                 auth = HTTPBasicAuth(*auth)\n \n             # Allow auth to make its changes.\n             r = auth(self)\n+            # print r\n+            # print r.__dict__\n+            # print self.__dict__\n \n             # Update self to reflect the auth changes.\n             self.__dict__.update(r.__dict__)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#1c30ef453b2087cee5a300481ac092af9edf6509", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 102 | Files Changed: 1 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): -9/0 | Churn Δ: 102 | Churn Cumulative: 1032 | Contributors (this commit): 16 | Commits (past 90d): 6 | Contributors (cumulative): 16 | DMM Complexity: 0.6511627906976745\n\nDIFF:\n@@ -8,7 +8,6 @@ This module contains the authentication handlers for Requests.\n \"\"\"\n \n import os\n-import re\n import time\n import hashlib\n import logging\n@@ -18,18 +17,6 @@ from base64 import b64encode\n from .compat import urlparse, str\n from .utils import parse_dict_header\n \n-try:\n-    from oauthlib.common import extract_params\n-    from oauthlib.oauth1.rfc5849 import (Client, SIGNATURE_HMAC, SIGNATURE_TYPE_AUTH_HEADER)\n-\n-except (ImportError, SyntaxError):\n-    SIGNATURE_HMAC = None\n-    SIGNATURE_TYPE_AUTH_HEADER = None\n-\n-try:\n-    import kerberos as k\n-except ImportError as exc:\n-    k = None\n \n log = logging.getLogger(__name__)\n \n@@ -49,95 +36,6 @@ class AuthBase(object):\n     def __call__(self, r):\n         raise NotImplementedError('Auth hooks must be callable.')\n \n-\n-class OAuth1(AuthBase):\n-    \"\"\"Signs the request using OAuth 1 (RFC5849)\"\"\"\n-    def __init__(self, client_key,\n-            client_secret=None,\n-            resource_owner_key=None,\n-            resource_owner_secret=None,\n-            callback_uri=None,\n-            signature_method=SIGNATURE_HMAC,\n-            signature_type=SIGNATURE_TYPE_AUTH_HEADER,\n-            rsa_key=None, verifier=None):\n-\n-        try:\n-            signature_type = signature_type.upper()\n-        except AttributeError:\n-            pass\n-\n-        self.client = Client(client_key, client_secret, resource_owner_key,\n-            resource_owner_secret, callback_uri, signature_method,\n-            signature_type, rsa_key, verifier)\n-\n-    def __call__(self, r):\n-        \"\"\"Add OAuth parameters to the request.\n-\n-        Parameters may be included from the body if the content-type is\n-        urlencoded, if no content type is set an educated guess is made.\n-        \"\"\"\n-        # split(\";\") because Content-Type may be \"multipart/form-data; boundary=xxxxx\"\n-        contenttype = r.headers.get('Content-Type', '').split(\";\")[0].lower()\n-        # extract_params will not give params unless the body is a properly\n-        # formatted string, a dictionary or a list of 2-tuples.\n-        decoded_body = extract_params(r.data)\n-\n-        # extract_params can only check the present r.data and does not know\n-        # of r.files, thus an extra check is performed. We know that\n-        # if files are present the request will not have\n-        # Content-type: x-www-form-urlencoded. We guess it will have\n-        # a mimetype of multipart/form-data and if this is not the case\n-        # we assume the correct header will be set later.\n-        _oauth_signed = True\n-        if r.files and contenttype == CONTENT_TYPE_MULTI_PART:\n-            # Omit body data in the signing and since it will always\n-            # be empty (cant add paras to body if multipart) and we wish\n-            # to preserve body.\n-            r.url, r.headers, _ = self.client.sign(unicode(r.full_url),\n-                                                   unicode(r.method),\n-                                                   None,\n-                                                   r.headers)\n-        elif (decoded_body is not None and\n-                                  contenttype == CONTENT_TYPE_FORM_URLENCODED):\n-            # If the Content-Type header is urlencoded and there are no\n-            # illegal characters in the body, assume that the content actually\n-            # is urlencoded, and so should be part of the signature.\n-            r.url, r.headers, r.data = self.client.sign(unicode(r.full_url),\n-                                                        unicode(r.method),\n-                                                        r.data,\n-                                                        r.headers)\n-        else:\n-            # The data we passed was either definitely not urlencoded\n-            # (because extract_params returned nothing) or doesn't have a\n-            # content header that assures us that it is. Assume then that the\n-            # data shouldn't be part of the signature.\n-            r.url, r.headers, _ = self.client.sign(unicode(r.full_url),\n-                                                   unicode(r.method),\n-                                                   None,\n-                                                   r.headers)\n-        if _oauth_signed:\n-            # Both flows add params to the URL by using r.full_url,\n-            # so this prevents adding it again later\n-            r.params = {}\n-\n-            # Having the authorization header, key or value, in unicode will\n-            # result in UnicodeDecodeErrors when the request is concatenated\n-            # by httplib. This can easily be seen when attaching files.\n-            # Note that simply encoding the value is not enough since Python\n-            # saves the type of first key set. Thus we remove and re-add.\n-            # >>> d = {u'a':u'foo'}\n-            # >>> d['a'] = 'foo'\n-            # >>> d\n-            # { u'a' : 'foo' }\n-            u_header = unicode('Authorization')\n-            if u_header in r.headers:\n-                auth_header = r.headers[u_header].encode('utf-8')\n-                del r.headers[u_header]\n-                r.headers['Authorization'] = auth_header\n-\n-        return r\n-\n-\n class HTTPBasicAuth(AuthBase):\n     \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n     def __init__(self, username, password):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#483790083238d327c5969007a9677ea57cb11880", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 12 | Lines Deleted: 13 | Files Changed: 4 | Hunks: 9 | Methods Changed: 5 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 25 | Churn Cumulative: 11064 | Contributors (this commit): 106 | Commits (past 90d): 85 | Contributors (cumulative): 130 | DMM Complexity: 0.0\n\nDIFF:\n@@ -13,6 +13,7 @@ import socket\n \n from .models import Response\n from .packages.urllib3.poolmanager import PoolManager\n+from .hooks import dispatch_hook\n from .utils import DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers\n from .structures import CaseInsensitiveDict\n from .packages.urllib3.exceptions import MaxRetryError\n@@ -88,8 +89,8 @@ class HTTPAdapter(BaseAdapter):\n             else:\n                 conn.cert_file = cert\n \n-    @staticmethod\n-    def build_response(req, resp):\n+    # @staticmethod\n+    def build_response(self, req, resp):\n         response = Response()\n \n         # Fallback to None if there's no status_code, for whatever reason.\n@@ -110,6 +111,12 @@ class HTTPAdapter(BaseAdapter):\n         # Add new cookies from the server.\n         extract_cookies_to_jar(response.cookies, req, resp)\n \n+        # Give the Response some context.\n+        response.request = req\n+        response.connection = self\n+\n+        # Run the Response hook.\n+        response = dispatch_hook('response', req.hooks, response)\n         return response\n \n \n\n@@ -141,7 +141,6 @@ class HTTPDigestAuth(AuthBase):\n         \"\"\"Takes the given response and tries digest-auth, if needed.\"\"\"\n \n         num_401_calls = r.request.hooks['response'].count(self.handle_401)\n-\n         s_auth = r.headers.get('www-authenticate', '')\n \n         if 'digest' in s_auth.lower() and num_401_calls < 2:\n@@ -154,8 +153,7 @@ class HTTPDigestAuth(AuthBase):\n             r.raw.release_conn()\n \n             r.request.headers['Authorization'] = self.build_digest_header(r.request.method, r.request.url)\n-            r.request.send(anyway=True)\n-            _r = r.request.response\n+            _r = r.connection.send(r.request)\n             _r.history.append(r)\n \n             return _r\n\n@@ -146,9 +146,7 @@ class RequestEncodingMixin(object):\n class RequestHooksMixin(object):\n     def register_hook(self, event, hook):\n         \"\"\"Properly register a hook.\"\"\"\n-        print self\n-        print event\n-        print hook\n+\n         if isinstance(hook, collections.Callable):\n             self.hooks[event].append(hook)\n         elif hasattr(hook, '__iter__'):\n@@ -342,16 +340,12 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n     def prepare_auth(self, auth):\n         \"\"\"Prepares the given HTTP auth data.\"\"\"\n         if auth:\n-            # print auth\n             if isinstance(auth, tuple) and len(auth) == 2:\n                 # special-case basic HTTP auth\n                 auth = HTTPBasicAuth(*auth)\n \n             # Allow auth to make its changes.\n             r = auth(self)\n-            # print r\n-            # print r.__dict__\n-            # print self.__dict__\n \n             # Update self to reflect the auth changes.\n             self.__dict__.update(r.__dict__)\n\n@@ -12,7 +12,7 @@ requests (cookies, auth, proxies).\n from .compat import cookielib\n from .cookies import cookiejar_from_dict, remove_cookie_by_name\n from .models import Request\n-from .hooks import dispatch_hook\n+from .hooks import dispatch_hook, HOOKS\n from .utils import header_expand, from_key_val_list, default_headers\n from .exceptions import TooManyRedirects\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#42ee255c80374d974e696b73fa0c6685afb34cff", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 255 | Contributors (this commit): 1 | Commits (past 90d): 11 | Contributors (cumulative): 1 | DMM Complexity: None\n\nDIFF:\n@@ -89,7 +89,7 @@ class HTTPAdapter(BaseAdapter):\n             else:\n                 conn.cert_file = cert\n \n-    # @staticmethod\n+\n     def build_response(self, req, resp):\n         response = Response()\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#92355ada54a3a19341f7fbc65a8bc50816858c63", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 15 | Lines Deleted: 33 | Files Changed: 1 | Hunks: 16 | Methods Changed: 3 | Complexity Δ (Sum/Max): -5/0 | Churn Δ: 48 | Churn Cumulative: 1553 | Contributors (this commit): 23 | Commits (past 90d): 20 | Contributors (cumulative): 23 | DMM Complexity: 1.0\n\nDIFF:\n@@ -12,7 +12,7 @@ requests (cookies, auth, proxies).\n from .compat import cookielib\n from .cookies import cookiejar_from_dict, remove_cookie_by_name\n from .models import Request\n-from .hooks import dispatch_hook, HOOKS\n+from .hooks import dispatch_hook, default_hooks\n from .utils import header_expand, from_key_val_list, default_headers\n from .exceptions import TooManyRedirects\n \n@@ -60,7 +60,7 @@ def merge_kwargs(local_kwarg, default_kwarg):\n     return kwargs\n \n \n-class SessionMixin(object):\n+class SessionRedirectMixin(object):\n \n     def resolve_redirects(self, resp, req, prefetch=True, timeout=None, verify=True, cert=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n@@ -127,58 +127,45 @@ class SessionMixin(object):\n             yield resp\n \n \n-class Session(SessionMixin):\n+class Session(SessionRedirectMixin):\n     \"\"\"A Requests session.\"\"\"\n \n     __attrs__ = [\n         'headers', 'cookies', 'auth', 'timeout', 'proxies', 'hooks',\n         'params', 'verify', 'cert', 'prefetch']\n \n-    def __init__(self,\n-        headers=None,\n-        cookies=None,\n-        auth=None,\n-        timeout=None,\n-        proxies=None,\n-        hooks=None,\n-        params=None,\n-        prefetch=True,\n-        verify=True,\n-        cert=None):\n+    def __init__(self):\n \n         #: A case-insensitive dictionary of headers to be sent on each\n         #: :class:`Request <Request>` sent from this\n         #: :class:`Session <Session>`.\n-        self.headers = from_key_val_list(headers or [])\n+        self.headers = default_headers()\n \n         #: Authentication tuple or object to attach to\n         #: :class:`Request <Request>`.\n-        self.auth = auth\n-\n-        #: Float describing the timeout of the each :class:`Request <Request>`.\n-        self.timeout = timeout\n+        self.auth = None\n \n         #: Dictionary mapping protocol to the URL of the proxy (e.g.\n         #: {'http': 'foo.bar:3128'}) to be used on each\n         #: :class:`Request <Request>`.\n-        self.proxies = from_key_val_list(proxies or [])\n+        self.proxies = {}\n \n         #: Event-handling hooks.\n-        self.hooks = from_key_val_list(hooks or {})\n+        self.hooks = default_hooks()\n \n         #: Dictionary of querystring data to attach to each\n         #: :class:`Request <Request>`. The dictionary values may be lists for\n         #: representing multivalued query parameters.\n-        self.params = from_key_val_list(params or [])\n+        self.params = {}\n \n         #: Prefetch response content.\n-        self.prefetch = prefetch\n+        self.prefetch = True\n \n         #: SSL Verification.\n-        self.verify = verify\n+        self.verify = True\n \n         #: SSL certificate.\n-        self.cert = cert\n+        self.cert = None\n \n         #: Maximum number of redirects to follow.\n         self.max_redirects = DEFAULT_REDIRECT_LIMIT\n@@ -186,13 +173,8 @@ class Session(SessionMixin):\n         #: Should we trust the environment\n         self.trust_env = True\n \n-        self.default_headers = default_headers()\n-\n         # Set up a CookieJar to be used by default\n-        if isinstance(cookies, cookielib.CookieJar):\n-            self.cookies = cookies\n-        else:\n-            self.cookies = cookiejar_from_dict(cookies)\n+        self.cookies = cookiejar_from_dict({})\n \n     def __enter__(self):\n         return self\n@@ -230,14 +212,14 @@ class Session(SessionMixin):\n         req.cookies = cookies\n         # TODO: move to attached\n         # req.allow_redirects = allow_redirects\n-        req.proxies = proxies\n+        # req.proxies = proxies\n         req.hooks = hooks\n \n         prep = req.prepare()\n \n         # TODO: prepare cookies.\n \n-        resp = self.send(prep, prefetch, timeout, verify, cert)\n+        resp = self.send(prep, prefetch=prefetch, timeout=timeout, verify=verify, cert=cert)\n \n         # Redirect resolving generator.\n         gen = self.resolve_redirects(resp, req, prefetch, timeout, verify, cert)\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
