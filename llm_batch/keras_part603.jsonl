{"custom_id": "keras#a426717f1011df09df12d23c4c79bcb3f685fecb", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1270 | Lines Deleted: 1 | Files Changed: 7 | Hunks: 8 | Methods Changed: 23 | Complexity Δ (Sum/Max): 54/25 | Churn Δ: 1271 | Churn Cumulative: 2879 | Contributors (this commit): 9 | Commits (past 90d): 58 | Contributors (cumulative): 25 | DMM Complexity: 0.9268774703557312\n\nDIFF:\n@@ -156,4 +156,4 @@ def vectorized_map(function, elements):\n def scatter(indices, values, shape):\n     zeros = jnp.zeros(shape, values.dtype)\n     key = tuple(jnp.moveaxis(indices, -1, 0))\n-    return zeros.at[key].set(values)\n+    return zeros.at[key].add(values)\n\n@@ -21,6 +21,11 @@ from keras_core.metrics.f_score_metrics import FBetaScore\n from keras_core.metrics.hinge_metrics import CategoricalHinge\n from keras_core.metrics.hinge_metrics import Hinge\n from keras_core.metrics.hinge_metrics import SquaredHinge\n+from keras_core.metrics.iou_metrics import BinaryIoU\n+from keras_core.metrics.iou_metrics import IoU\n+from keras_core.metrics.iou_metrics import MeanIoU\n+from keras_core.metrics.iou_metrics import OneHotIoU\n+from keras_core.metrics.iou_metrics import OneHotMeanIoU\n from keras_core.metrics.metric import Metric\n from keras_core.metrics.probabilistic_metrics import BinaryCrossentropy\n from keras_core.metrics.probabilistic_metrics import CategoricalCrossentropy\n@@ -89,6 +94,12 @@ ALL_OBJECTS = {\n     # F-Score\n     F1Score,\n     FBetaScore,\n+    # IoU\n+    IoU,\n+    BinaryIoU,\n+    MeanIoU,\n+    OneHotIoU,\n+    OneHotMeanIoU,\n }\n ALL_OBJECTS_DICT = {cls.__name__: cls for cls in ALL_OBJECTS}\n ALL_OBJECTS_DICT.update(\n\n@@ -0,0 +1,748 @@\n+from keras_core import backend\n+from keras_core import initializers\n+from keras_core import operations as ops\n+from keras_core.api_export import keras_core_export\n+from keras_core.metrics.metric import Metric\n+from keras_core.metrics.metrics_utils import confusion_matrix\n+\n+\n+class _IoUBase(Metric):\n+    \"\"\"Computes the confusion matrix for Intersection-Over-Union metrics.\n+\n+    Formula:\n+\n+    ```python\n+    iou = true_positives / (true_positives + false_positives + false_negatives)\n+    ```\n+    Intersection-Over-Union is a common evaluation metric for semantic image\n+    segmentation.\n+\n+    From IoUs of individual classes, the MeanIoU can be computed as the mean of\n+    the individual IoUs.\n+\n+    To compute IoUs, the predictions are accumulated in a confusion matrix,\n+    weighted by `sample_weight` and the metric is then calculated from it.\n+\n+    If `sample_weight` is `None`, weights default to 1.\n+    Use `sample_weight` of 0 to mask values.\n+\n+    Args:\n+        num_classes: The possible number of labels the prediction task can have.\n+        name: (Optional) string name of the metric instance.\n+        dtype: (Optional) data type of the metric result.\n+        ignore_class: Optional integer. The ID of a class to be ignored during\n+            metric computation. This is useful, for example, in segmentation\n+            problems featuring a \"void\" class (commonly -1 or 255) in\n+            segmentation maps. By default (`ignore_class=None`), all classes are\n+            considered.\n+        sparse_y_true: Whether labels are encoded using integers or\n+            dense floating point vectors. If `False`, the `argmax` function\n+            is used to determine each sample's most likely associated label.\n+        sparse_y_pred: Whether predictions are encoded using integers or\n+            dense floating point vectors. If `False`, the `argmax` function\n+            is used to determine each sample's most likely associated label.\n+        axis: (Optional) -1 is the dimension containing the logits.\n+            Defaults to `-1`.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        num_classes,\n+        name=None,\n+        dtype=None,\n+        ignore_class=None,\n+        sparse_y_true=True,\n+        sparse_y_pred=True,\n+        axis=-1,\n+    ):\n+        # defaulting to float32 to avoid issues with confusion matrix\n+        super().__init__(name=name, dtype=dtype or \"float32\")\n+        self.num_classes = num_classes\n+        self.ignore_class = ignore_class\n+        self.sparse_y_true = sparse_y_true\n+        self.sparse_y_pred = sparse_y_pred\n+        self.axis = axis\n+\n+        self.total_cm = self.add_variable(\n+            name=\"total_confusion_matrix\",\n+            shape=(num_classes, num_classes),\n+            initializer=initializers.Zeros(),\n+        )\n+\n+    def update_state(self, y_true, y_pred, sample_weight=None):\n+        \"\"\"Accumulates the confusion matrix statistics.\n+\n+        Args:\n+            y_true: The ground truth values.\n+            y_pred: The predicted values.\n+            sample_weight: Optional weighting of each example. Can\n+                be a `Tensor` whose rank is either 0, or the same as `y_true`,\n+                and must be broadcastable to `y_true`. Defaults to `1`.\n+\n+        Returns:\n+            Update op.\n+        \"\"\"\n+\n+        if not self.sparse_y_true:\n+            y_true = ops.argmax(y_true, axis=self.axis)\n+        if not self.sparse_y_pred:\n+            y_pred = ops.argmax(y_pred, axis=self.axis)\n+\n+        y_true = ops.convert_to_tensor(y_true, dtype=self.dtype)\n+        y_pred = ops.convert_to_tensor(y_pred, dtype=self.dtype)\n+\n+        # Flatten the input if its rank > 1.\n+        if len(y_pred.shape) > 1:\n+            y_pred = ops.reshape(y_pred, [-1])\n+\n+        if len(y_true.shape) > 1:\n+            y_true = ops.reshape(y_true, [-1])\n+\n+        if sample_weight is None:\n+            sample_weight = 1\n+\n+        sample_weight = ops.convert_to_tensor(sample_weight, dtype=self.dtype)\n+\n+        if len(sample_weight.shape) > 1:\n+            sample_weight = ops.reshape(sample_weight, [-1])\n+\n+        sample_weight = ops.broadcast_to(sample_weight, y_true.shape)\n+\n+        if self.ignore_class is not None:\n+            ignore_class = ops.convert_to_tensor(\n+                self.ignore_class, y_true.dtype\n+            )\n+            valid_mask = ops.not_equal(y_true, ignore_class)\n+            y_true = y_true[valid_mask]\n+            y_pred = y_pred[valid_mask]\n+            if sample_weight is not None:\n+                sample_weight = sample_weight[valid_mask]\n+\n+        y_pred = ops.cast(y_pred, dtype=self.dtype)\n+        y_true = ops.cast(y_true, dtype=self.dtype)\n+        sample_weight = ops.cast(sample_weight, dtype=self.dtype)\n+\n+        current_cm = confusion_matrix(\n+            y_true,\n+            y_pred,\n+            self.num_classes,\n+            weights=sample_weight,\n+            dtype=\"float32\",\n+        )\n+\n+        return self.total_cm.assign(self.total_cm + current_cm)\n+\n+    def reset_state(self):\n+        self.total_cm.assign(\n+            ops.zeros(self.total_cm.shape, dtype=self.total_cm.dtype)\n+        )\n+\n+\n+@keras_core_export(\"keras_core.metrics.IoU\")\n+class IoU(_IoUBase):\n+    \"\"\"Computes the Intersection-Over-Union metric for specific target classes.\n+\n+    Formula:\n+\n+    ```python\n+    iou = true_positives / (true_positives + false_positives + false_negatives)\n+    ```\n+    Intersection-Over-Union is a common evaluation metric for semantic image\n+    segmentation.\n+\n+    To compute IoUs, the predictions are accumulated in a confusion matrix,\n+    weighted by `sample_weight` and the metric is then calculated from it.\n+\n+    If `sample_weight` is `None`, weights default to 1.\n+    Use `sample_weight` of 0 to mask values.\n+\n+    Note, this class first computes IoUs for all individual classes, then\n+    returns the mean of IoUs for the classes that are specified by\n+    `target_class_ids`. If `target_class_ids` has only one id value, the IoU of\n+    that specific class is returned.\n+\n+    Args:\n+        num_classes: The possible number of labels the prediction task can have.\n+        target_class_ids: A tuple or list of target class ids for which the\n+            metric is returned. To compute IoU for a specific class, a list\n+            (or tuple) of a single id value should be provided.\n+        name: (Optional) string name of the metric instance.\n+        dtype: (Optional) data type of the metric result.\n+        ignore_class: Optional integer. The ID of a class to be ignored during\n+            metric computation. This is useful, for example, in segmentation\n+            problems featuring a \"void\" class (commonly -1 or 255) in\n+            segmentation maps. By default (`ignore_class=None`), all classes are\n+              considered.\n+        sparse_y_true: Whether labels are encoded using integers or\n+            dense floating point vectors. If `False`, the `argmax` function\n+            is used to determine each sample's most likely associated label.\n+        sparse_y_pred: Whether predictions are encoded using integers or\n+            dense floating point vectors. If `False`, the `argmax` function\n+            is used to determine each sample's most likely associated label.\n+        axis: (Optional) -1 is the dimension containing the logits.\n+            Defaults to `-1`.\n+\n+    Examples:\n+\n+    Standalone usage:\n+\n+    >>> # cm = [[1, 1],\n+    >>> #        [1, 1]]\n+    >>> # sum_row = [2, 2], sum_col = [2, 2], true_positives = [1, 1]\n+    >>> # iou = true_positives / (sum_row + sum_col - true_positives))\n+    >>> # iou = [0.33, 0.33]\n+    >>> m = keras_core.metrics.IoU(num_classes=2, target_class_ids=[0])\n+    >>> m.update_state([0, 0, 1, 1], [0, 1, 0, 1])\n+    >>> m.result()\n+    0.33333334\n+\n+    >>> m.reset_state()\n+    >>> m.update_state([0, 0, 1, 1], [0, 1, 0, 1],\n+    ...                sample_weight=[0.3, 0.3, 0.3, 0.1])\n+    >>> # cm = [[0.3, 0.3],\n+    >>> #        [0.3, 0.1]]\n+    >>> # sum_row = [0.6, 0.4], sum_col = [0.6, 0.4],\n+    >>> # true_positives = [0.3, 0.1]\n+    >>> # iou = [0.33, 0.14]\n+    >>> m.result()\n+    0.33333334\n+\n+    Usage with `compile()` API:\n+\n+    ```python\n+    model.compile(\n+        optimizer='sgd',\n+        loss='mse',\n+        metrics=[keras_core.metrics.IoU(num_classes=2, target_class_ids=[0])])\n+    ```\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        num_classes,\n+        target_class_ids,\n+        name=None,\n+        dtype=None,\n+        ignore_class=None,\n+        sparse_y_true=True,\n+        sparse_y_pred=True,\n+        axis=-1,\n+    ):\n+        super().__init__(\n+            name=name,\n+            num_classes=num_classes,\n+            ignore_class=ignore_class,\n+            sparse_y_true=sparse_y_true,\n+            sparse_y_pred=sparse_y_pred,\n+            axis=axis,\n+            dtype=dtype,\n+        )\n+        if max(target_class_ids) >= num_classes:\n+            raise ValueError(\n+                f\"Target class id {max(target_class_ids)} \"\n+                \"is out of range, which is \"\n+                f\"[{0}, {num_classes}).\"\n+            )\n+        self.target_class_ids = list(target_class_ids)\n+\n+    def result(self):\n+        \"\"\"Compute the intersection-over-union via the confusion matrix.\"\"\"\n+        sum_over_row = ops.cast(\n+            ops.sum(self.total_cm, axis=0), dtype=self.dtype\n+        )\n+        sum_over_col = ops.cast(\n+            ops.sum(self.total_cm, axis=1), dtype=self.dtype\n+        )\n+        true_positives = ops.cast(ops.diag(self.total_cm), dtype=self.dtype)\n+\n+        # sum_over_row + sum_over_col =\n+        #     2 * true_positives + false_positives + false_negatives.\n+        denominator = sum_over_row + sum_over_col - true_positives\n+\n+        target_class_ids = ops.convert_to_tensor(\n+            self.target_class_ids, dtype=\"int32\"\n+        )\n+\n+        # Only keep the target classes\n+        true_positives = ops.take_along_axis(\n+            true_positives, target_class_ids, axis=-1\n+        )\n+        denominator = ops.take_along_axis(\n+            denominator, target_class_ids, axis=-1\n+        )\n+\n+        # If the denominator is 0, we need to ignore the class.\n+        num_valid_entries = ops.sum(\n+            ops.cast(ops.greater(denominator, 1e-9), dtype=self.dtype)\n+        )\n+\n+        iou = ops.divide(true_positives, denominator + backend.epsilon())\n+\n+        return ops.divide(\n+            ops.sum(iou, axis=self.axis), num_valid_entries + backend.epsilon()\n+        )\n+\n+    def get_config(self):\n+        config = {\n+            \"num_classes\": self.num_classes,\n+            \"target_class_ids\": self.target_class_ids,\n+            \"ignore_class\": self.ignore_class,\n+            \"sparse_y_true\": self.sparse_y_true,\n+            \"sparse_y_pred\": self.sparse_y_pred,\n+            \"axis\": self.axis,\n+        }\n+        base_config = super().get_config()\n+        return dict(list(base_config.items()) + list(config.items()))\n+\n+\n+@keras_core_export(\"keras_core.metrics.BinaryIoU\")\n+class BinaryIoU(IoU):\n+    \"\"\"Computes the Intersection-Over-Union metric for class 0 and/or 1.\n+\n+    Formula:\n+\n+    ```python\n+    iou = true_positives / (true_positives + false_positives + false_negatives)\n+    ```\n+    Intersection-Over-Union is a common evaluation metric for semantic image\n+    segmentation.\n+\n+    To compute IoUs, the predictions are accumulated in a confusion matrix,\n+    weighted by `sample_weight` and the metric is then calculated from it.\n+\n+    If `sample_weight` is `None`, weights default to 1.\n+    Use `sample_weight` of 0 to mask values.\n+\n+    This class can be used to compute IoUs for a binary classification task\n+    where the predictions are provided as logits. First a `threshold` is applied\n+    to the predicted values such that those that are below the `threshold` are\n+    converted to class 0 and those that are above the `threshold` are converted\n+    to class 1.\n+\n+    IoUs for classes 0 and 1 are then computed, the mean of IoUs for the classes\n+    that are specified by `target_class_ids` is returned.\n+\n+    Note: with `threshold=0`, this metric has the same behavior as `IoU`.\n+\n+    Args:\n+        target_class_ids: A tuple or list of target class ids for which the\n+            metric is returned. Options are `[0]`, `[1]`, or `[0, 1]`. With\n+            `[0]` (or `[1]`), the IoU metric for class 0 (or class 1,\n+            respectively) is returned. With `[0, 1]`, the mean of IoUs for the\n+            two classes is returned.\n+        threshold: A threshold that applies to the prediction logits to convert\n+            them to either predicted class 0 if the logit is below `threshold`\n+            or predicted class 1 if the logit is above `threshold`.\n+        name: (Optional) string name of the metric instance.\n+        dtype: (Optional) data type of the metric result.\n+\n+    Examples:\n+\n+    Standalone usage:\n+\n+    >>> m = keras_core.metrics.BinaryIoU(target_class_ids=[0, 1], threshold=0.3)\n+    >>> m.update_state([0, 1, 0, 1], [0.1, 0.2, 0.4, 0.7])\n+    >>> m.result()\n+    0.33333334\n+\n+    >>> m.reset_state()\n+    >>> m.update_state([0, 1, 0, 1], [0.1, 0.2, 0.4, 0.7],\n+    ...                sample_weight=[0.2, 0.3, 0.4, 0.1])\n+    >>> # cm = [[0.2, 0.4],\n+    >>> #        [0.3, 0.1]]\n+    >>> # sum_row = [0.6, 0.4], sum_col = [0.5, 0.5],\n+    >>> # true_positives = [0.2, 0.1]\n+    >>> # iou = [0.222, 0.125]\n+    >>> m.result()\n+    0.17361112\n+\n+    Usage with `compile()` API:\n+\n+    ```python\n+    model.compile(\n+        optimizer='sgd',\n+        loss='mse',\n+        metrics=[keras_core.metrics.BinaryIoU(\n+            target_class_ids=[0],\n+            threshold=0.5\n+        )]\n+    )\n+    ```\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        target_class_ids=(0, 1),\n+        threshold=0.5,\n+        name=None,\n+        dtype=None,\n+    ):\n+\n+        super().__init__(\n+            num_classes=2,\n+            target_class_ids=target_class_ids,\n+            name=name,\n+            dtype=dtype,\n+        )\n+        self.threshold = threshold\n+\n+    def update_state(self, y_true, y_pred, sample_weight=None):\n+        \"\"\"Accumulates the confusion matrix statistics.\n+\n+        Before the confusion matrix is updated, the predicted values are\n+        thresholded to be:\n+            0 for values that are smaller than the `threshold`\n+            1 for values that are larger or equal to the `threshold`\n+\n+        Args:\n+            y_true: The ground truth values.\n+            y_pred: The predicted values.\n+            sample_weight: Optional weighting of each example. Can\n+                be a `Tensor` whose rank is either 0, or the same as `y_true`,\n+                and must be broadcastable to `y_true`. Defaults to `1`.\n+\n+        Returns:\n+            Update op.\n+        \"\"\"\n+        y_true = ops.convert_to_tensor(y_true, dtype=self.dtype)\n+        y_pred = ops.convert_to_tensor(y_pred, dtype=self.dtype)\n+        y_pred = ops.cast(y_pred >= self.threshold, self.dtype)\n+        return super().update_state(y_true, y_pred, sample_weight)\n+\n+    def get_config(self):\n+        return {\n+            \"target_class_ids\": self.target_class_ids,\n+            \"threshold\": self.threshold,\n+            \"name\": self.name,\n+            \"dtype\": self._dtype,\n+        }\n+\n+\n+@keras_core_export(\"keras_core.metrics.MeanIoU\")\n+class MeanIoU(IoU):\n+    \"\"\"Computes the mean Intersection-Over-Union metric.\n+\n+    Formula:\n+\n+    ```python\n+    iou = true_positives / (true_positives + false_positives + false_negatives)\n+    ```\n+    Intersection-Over-Union is a common evaluation metric for semantic image\n+    segmentation.\n+\n+    To compute IoUs, the predictions are accumulated in a confusion matrix,\n+    weighted by `sample_weight` and the metric is then calculated from it.\n+\n+    If `sample_weight` is `None`, weights default to 1.\n+    Use `sample_weight` of 0 to mask values.\n+\n+    Note that this class first computes IoUs for all individual classes, then\n+    returns the mean of these values.\n+\n+    Args:\n+        num_classes: The possible number of labels the prediction task can have.\n+            This value must be provided, since a confusion matrix of dimension =\n+            [num_classes, num_classes] will be allocated.\n+        name: (Optional) string name of the metric instance.\n+        dtype: (Optional) data type of the metric result.\n+        ignore_class: Optional integer. The ID of a class to be ignored during\n+            metric computation. This is useful, for example, in segmentation\n+            problems featuring a \"void\" class (commonly -1 or 255) in\n+            segmentation maps. By default (`ignore_class=None`), all classes are\n+            considered.\n+        sparse_y_true: Whether labels are encoded using integers or\n+            dense floating point vectors. If `False`, the `argmax` function\n+            is used to determine each sample's most likely associated label.\n+        sparse_y_pred: Whether predictions are encoded using integers or\n+            dense floating point vectors. If `False`, the `argmax` function\n+            is used to determine each sample's most likely associated label.\n+        axis: (Optional) The dimension containing the logits. Defaults to `-1`.\n+\n+    Examples:\n+\n+    Standalone usage:\n+\n+    >>> # cm = [[1, 1],\n+    >>> #        [1, 1]]\n+    >>> # sum_row = [2, 2], sum_col = [2, 2], true_positives = [1, 1]\n+    >>> # iou = true_positives / (sum_row + sum_col - true_positives))\n+    >>> # result = (1 / (2 + 2 - 1) + 1 / (2 + 2 - 1)) / 2 = 0.33\n+    >>> m = keras_core.metrics.MeanIoU(num_classes=2)\n+    >>> m.update_state([0, 0, 1, 1], [0, 1, 0, 1])\n+    >>> m.result()\n+    0.33333334\n+\n+    >>> m.reset_state()\n+    >>> m.update_state([0, 0, 1, 1], [0, 1, 0, 1],\n+    ...                sample_weight=[0.3, 0.3, 0.3, 0.1])\n+    >>> m.result().numpy()\n+    0.23809525\n+\n+    Usage with `compile()` API:\n+\n+    ```python\n+    model.compile(\n+        optimizer='sgd',\n+        loss='mse',\n+        metrics=[keras_core.metrics.MeanIoU(num_classes=2)])\n+    ```\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        num_classes,\n+        name=None,\n+        dtype=None,\n+        ignore_class=None,\n+        sparse_y_true=True,\n+        sparse_y_pred=True,\n+        axis=-1,\n+    ):\n+        target_class_ids = list(range(num_classes))\n+        super().__init__(\n+            name=name,\n+            num_classes=num_classes,\n+            target_class_ids=target_class_ids,\n+            axis=axis,\n+            dtype=dtype,\n+            ignore_class=ignore_class,\n+            sparse_y_true=sparse_y_true,\n+            sparse_y_pred=sparse_y_pred,\n+        )\n+\n+    def get_config(self):\n+        return {\n+            \"num_classes\": self.num_classes,\n+            \"name\": self.name,\n+            \"dtype\": self._dtype,\n+            \"ignore_class\": self.ignore_class,\n+            \"sparse_y_true\": self.sparse_y_true,\n+            \"sparse_y_pred\": self.sparse_y_pred,\n+            \"axis\": self.axis,\n+        }\n+\n+\n+@keras_core_export(\"keras_core.metrics.OneHotIoU\")\n+class OneHotIoU(IoU):\n+    \"\"\"Computes the Intersection-Over-Union metric for one-hot encoded labels.\n+\n+    Formula:\n+\n+    ```python\n+    iou = true_positives / (true_positives + false_positives + false_negatives)\n+    ```\n+    Intersection-Over-Union is a common evaluation metric for semantic image\n+    segmentation.\n+\n+    To compute IoUs, the predictions are accumulated in a confusion matrix,\n+    weighted by `sample_weight` and the metric is then calculated from it.\n+\n+    If `sample_weight` is `None`, weights default to 1.\n+    Use `sample_weight` of 0 to mask values.\n+\n+    This class can be used to compute IoU for multi-class classification tasks\n+    where the labels are one-hot encoded (the last axis should have one\n+    dimension per class). Note that the predictions should also have the same\n+    shape. To compute the IoU, first the labels and predictions are converted\n+    back into integer format by taking the argmax over the class axis. Then the\n+    same computation steps as for the base `IoU` class apply.\n+\n+    Note, if there is only one channel in the labels and predictions, this class\n+    is the same as class `IoU`. In this case, use `IoU` instead.\n+\n+    Also, make sure that `num_classes` is equal to the number of classes in the\n+    data, to avoid a \"labels out of bound\" error when the confusion matrix is\n+    computed.\n+\n+    Args:\n+        num_classes: The possible number of labels the prediction task can have.\n+        target_class_ids: A tuple or list of target class ids for which the\n+            metric is returned. To compute IoU for a specific class, a list\n+            (or tuple) of a single id value should be provided.\n+        name: (Optional) string name of the metric instance.\n+        dtype: (Optional) data type of the metric result.\n+        ignore_class: Optional integer. The ID of a class to be ignored during\n+            metric computation. This is useful, for example, in segmentation\n+            problems featuring a \"void\" class (commonly -1 or 255) in\n+            segmentation maps. By default (`ignore_class=None`), all classes are\n+            considered.\n+        sparse_y_pred: Whether predictions are encoded using integers or\n+            dense floating point vectors. If `False`, the `argmax` function\n+            is used to determine each sample's most likely associated label.\n+        axis: (Optional) The dimension containing the logits. Defaults to `-1`.\n+\n+    Examples:\n+\n+    Standalone usage:\n+\n+    >>> y_true = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0], [1, 0, 0]])\n+    >>> y_pred = np.array([[0.2, 0.3, 0.5], [0.1, 0.2, 0.7], [0.5, 0.3, 0.1],\n+    ...                       [0.1, 0.4, 0.5]])\n+    >>> sample_weight = [0.1, 0.2, 0.3, 0.4]\n+    >>> m = keras_core.metrics.OneHotIoU(num_classes=3, target_class_ids=[0, 2])\n+    >>> m.update_state(\n+    ...     y_true=y_true, y_pred=y_pred, sample_weight=sample_weight)\n+    >>> # cm = [[0, 0, 0.2+0.4],\n+    >>> #       [0.3, 0, 0],\n+    >>> #       [0, 0, 0.1]]\n+    >>> # sum_row = [0.3, 0, 0.7], sum_col = [0.6, 0.3, 0.1]\n+    >>> # true_positives = [0, 0, 0.1]\n+    >>> # single_iou = true_positives / (sum_row + sum_col - true_positives))\n+    >>> # mean_iou = (0 / (0.3 + 0.6 - 0) + 0.1 / (0.7 + 0.1 - 0.1)) / 2\n+    >>> m.result()\n+    0.071\n+\n+    Usage with `compile()` API:\n+\n+    ```python\n+    model.compile(\n+        optimizer='sgd',\n+        loss='mse',\n+        metrics=[keras_core.metrics.OneHotIoU(\n+            num_classes=3,\n+            target_class_id=[1]\n+        )]\n+    )\n+    ```\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        num_classes,\n+        target_class_ids,\n+        name=None,\n+        dtype=None,\n+        ignore_class=None,\n+        sparse_y_pred=False,\n+        axis=-1,\n+    ):\n+        super().__init__(\n+            num_classes=num_classes,\n+            target_class_ids=target_class_ids,\n+            name=name,\n+            dtype=dtype,\n+            ignore_class=ignore_class,\n+            sparse_y_true=False,\n+            sparse_y_pred=sparse_y_pred,\n+            axis=axis,\n+        )\n+\n+    def get_config(self):\n+        return {\n+            \"num_classes\": self.num_classes,\n+            \"target_class_ids\": self.target_class_ids,\n+            \"name\": self.name,\n+            \"dtype\": self._dtype,\n+            \"ignore_class\": self.ignore_class,\n+            \"sparse_y_pred\": self.sparse_y_pred,\n+            \"axis\": self.axis,\n+        }\n+\n+\n+@keras_core_export(\"keras_core.metrics.OneHotMeanIoU\")\n+class OneHotMeanIoU(MeanIoU):\n+    \"\"\"Computes mean Intersection-Over-Union metric for one-hot encoded labels.\n+\n+    Formula:\n+\n+    ```python\n+    iou = true_positives / (true_positives + false_positives + false_negatives)\n+    ```\n+    Intersection-Over-Union is a common evaluation metric for semantic image\n+    segmentation.\n+\n+    To compute IoUs, the predictions are accumulated in a confusion matrix,\n+    weighted by `sample_weight` and the metric is then calculated from it.\n+\n+    If `sample_weight` is `None`, weights default to 1.\n+    Use `sample_weight` of 0 to mask values.\n+\n+    This class can be used to compute the mean IoU for multi-class\n+    classification tasks where the labels are one-hot encoded (the last axis\n+    should have one dimension per class). Note that the predictions should also\n+    have the same shape. To compute the mean IoU, first the labels and\n+    predictions are converted back into integer format by taking the argmax over\n+    the class axis. Then the same computation steps as for the base `MeanIoU`\n+    class apply.\n+\n+    Note, if there is only one channel in the labels and predictions, this class\n+    is the same as class `MeanIoU`. In this case, use `MeanIoU` instead.\n+\n+    Also, make sure that `num_classes` is equal to the number of classes in the\n+    data, to avoid a \"labels out of bound\" error when the confusion matrix is\n+    computed.\n+\n+    Args:\n+        num_classes: The possible number of labels the prediction task can have.\n+        name: (Optional) string name of the metric instance.\n+        dtype: (Optional) data type of the metric result.\n+        ignore_class: Optional integer. The ID of a class to be ignored during\n+            metric computation. This is useful, for example, in segmentation\n+            problems featuring a \"void\" class (commonly -1 or 255) in\n+            segmentation maps. By default (`ignore_class=None`), all classes are\n+            considered.\n+        sparse_y_pred: Whether predictions are encoded using natural numbers or\n+            probability distribution vectors. If `False`, the `argmax`\n+            function will be used to determine each sample's most likely\n+            associated label.\n+        axis: (Optional) The dimension containing the logits. Defaults to `-1`.\n+\n+    Examples:\n+\n+    Standalone usage:\n+\n+    >>> y_true = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0], [1, 0, 0]])\n+    >>> y_pred = np.array([[0.2, 0.3, 0.5], [0.1, 0.2, 0.7], [0.5, 0.3, 0.1],\n+    ...                       [0.1, 0.4, 0.5]])\n+    >>> sample_weight = [0.1, 0.2, 0.3, 0.4]\n+    >>> m = keras_core.metrics.OneHotMeanIoU(num_classes=3)\n+    >>> m.update_state(\n+    ...     y_true=y_true, y_pred=y_pred, sample_weight=sample_weight)\n+    >>> # cm = [[0, 0, 0.2+0.4],\n+    >>> #       [0.3, 0, 0],\n+    >>> #       [0, 0, 0.1]]\n+    >>> # sum_row = [0.3, 0, 0.7], sum_col = [0.6, 0.3, 0.1]\n+    >>> # true_positives = [0, 0, 0.1]\n+    >>> # single_iou = true_positives / (sum_row + sum_col - true_positives))\n+    >>> # mean_iou = (0 + 0 + 0.1 / (0.7 + 0.1 - 0.1)) / 3\n+    >>> m.result()\n+    0.048\n+\n+    Usage with `compile()` API:\n+\n+    ```python\n+    model.compile(\n+        optimizer='sgd',\n+        loss='mse',\n+        metrics=[keras_core.metrics.OneHotMeanIoU(num_classes=3)])\n+    ```\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        num_classes,\n+        name=None,\n+        dtype=None,\n+        ignore_class=None,\n+        sparse_y_pred=False,\n+        axis=-1,\n+    ):\n+        super().__init__(\n+            num_classes=num_classes,\n+            axis=axis,\n+            name=name,\n+            dtype=dtype,\n+            ignore_class=ignore_class,\n+            sparse_y_true=False,\n+            sparse_y_pred=sparse_y_pred,\n+        )\n+\n+    def get_config(self):\n+        return {\n+            \"num_classes\": self.num_classes,\n+            \"name\": self.name,\n+            \"dtype\": self._dtype,\n+            \"ignore_class\": self.ignore_class,\n+            \"sparse_y_pred\": self.sparse_y_pred,\n+            \"axis\": self.axis,\n+        }\n\n@@ -0,0 +1,430 @@\n+import numpy as np\n+\n+from keras_core import testing\n+from keras_core.metrics import iou_metrics as metrics\n+\n+\n+class IoUTest(testing.TestCase):\n+    def test_config(self):\n+        obj = metrics.IoU(\n+            num_classes=2, target_class_ids=[1, 0], name=\"iou_class_1_0\"\n+        )\n+        self.assertEqual(obj.name, \"iou_class_1_0\")\n+        self.assertEqual(obj.num_classes, 2)\n+        self.assertEqual(obj.target_class_ids, [1, 0])\n+\n+        obj2 = metrics.IoU.from_config(obj.get_config())\n+        self.assertEqual(obj2.name, \"iou_class_1_0\")\n+        self.assertEqual(obj2.num_classes, 2)\n+        self.assertEqual(obj2.target_class_ids, [1, 0])\n+\n+    def test_unweighted(self):\n+        y_pred = [0, 1, 0, 1]\n+        y_true = [0, 0, 1, 1]\n+\n+        obj = metrics.IoU(\n+            num_classes=2, target_class_ids=[0, 1], dtype=\"float32\"\n+        )\n+\n+        result = obj(y_true, y_pred)\n+\n+        # cm = [[1, 1],\n+        #       [1, 1]]\n+        # sum_row = [2, 2], sum_col = [2, 2], true_positives = [1, 1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (1 / (2 + 2 - 1) + 1 / (2 + 2 - 1)) / 2\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_weighted(self):\n+        y_pred = np.array([0, 1, 0, 1], dtype=np.float32)\n+        y_true = np.array([0, 0, 1, 1])\n+        sample_weight = np.array([0.2, 0.3, 0.4, 0.1])\n+\n+        obj = metrics.IoU(\n+            num_classes=2, target_class_ids=[1, 0], dtype=\"float32\"\n+        )\n+\n+        result = obj(y_true, y_pred, sample_weight=sample_weight)\n+\n+        # cm = [[0.2, 0.3],\n+        #       [0.4, 0.1]]\n+        # sum_row = [0.6, 0.4], sum_col = [0.5, 0.5], true_positives = [0.2,\n+        # 0.1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (\n+            0.1 / (0.4 + 0.5 - 0.1) + 0.2 / (0.6 + 0.5 - 0.2)\n+        ) / 2\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_multi_dim_input(self):\n+        y_pred = np.array([[0, 1], [0, 1]], dtype=np.float32)\n+        y_true = np.array([[0, 0], [1, 1]])\n+        sample_weight = np.array([[0.2, 0.3], [0.4, 0.1]])\n+\n+        obj = metrics.IoU(num_classes=2, target_class_ids=[0, 1])\n+\n+        result = obj(y_true, y_pred, sample_weight=sample_weight)\n+\n+        # cm = [[0.2, 0.3],\n+        #       [0.4, 0.1]]\n+        # sum_row = [0.6, 0.4], sum_col = [0.5, 0.5], true_positives = [0.2,\n+        # 0.1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (\n+            0.2 / (0.6 + 0.5 - 0.2) + 0.1 / (0.4 + 0.5 - 0.1)\n+        ) / 2\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_zero_valid_entries(self):\n+        obj = metrics.IoU(num_classes=2, target_class_ids=[0, 1])\n+        self.assertAllClose(obj.result(), 0, atol=1e-3)\n+\n+    def test_zero_and_non_zero_entries(self):\n+        y_pred = np.array([1], dtype=np.float32)\n+        y_true = np.array([1])\n+\n+        obj = metrics.IoU(num_classes=2, target_class_ids=[0, 1])\n+        result = obj(y_true, y_pred)\n+\n+        # cm = [[0, 0],\n+        #       [0, 1]]\n+        # sum_row = [0, 1], sum_col = [0, 1], true_positives = [0, 1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (1 / (1 + 1 - 1)) / 1\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+\n+class BinaryIoUTest(testing.TestCase):\n+    def test_config(self):\n+        obj = metrics.BinaryIoU(\n+            target_class_ids=[1, 0], threshold=0.1, name=\"iou_class_1_0\"\n+        )\n+        self.assertEqual(obj.name, \"iou_class_1_0\")\n+        self.assertAlmostEqual(obj.threshold, 0.1)\n+        self.assertEqual(obj.target_class_ids, [1, 0])\n+\n+        obj2 = metrics.BinaryIoU.from_config(obj.get_config())\n+        self.assertEqual(obj.name, \"iou_class_1_0\")\n+        self.assertAlmostEqual(obj2.threshold, 0.1)\n+        self.assertEqual(obj.target_class_ids, [1, 0])\n+\n+    def test_different_thresholds_weighted(self):\n+        y_true = [0, 1, 0, 1]\n+        y_pred = [0.1, 0.2, 0.4, 0.7]\n+\n+        sample_weight = np.array([0.2, 0.3, 0.4, 0.1])\n+        # with threshold = 0.3, y_pred will be converted to [0, 0, 1, 1]\n+        # cm = [[0.2, 0.4],\n+        #       [0.3, 0.1]]\n+        # sum_row = [0.6, 0.4], sum_col = [0.5, 0.5], true_positives = [0.2,\n+        # 0.1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (\n+            0.2 / (0.6 + 0.5 - 0.2) + 0.1 / (0.4 + 0.5 - 0.1)\n+        ) / 2\n+        obj = metrics.BinaryIoU(target_class_ids=[0, 1], threshold=0.3)\n+        result = obj(y_true, y_pred, sample_weight=sample_weight)\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+        sample_weight = np.array([0.1, 0.2, 0.4, 0.3])\n+        # with threshold = 0.5, y_pred will be converted to [0, 0, 0, 1]\n+        # cm = [[0.1+0.4, 0],\n+        #       [0.2, 0.3]]\n+        # sum_row = [0.5, 0.5], sum_col = [0.7, 0.3], true_positives = [0.5,\n+        # 0.3]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (\n+            0.5 / (0.5 + 0.7 - 0.5) + 0.3 / (0.5 + 0.3 - 0.3)\n+        ) / 2\n+        obj = metrics.BinaryIoU(target_class_ids=[0, 1], threshold=0.5)\n+        result = obj(y_true, y_pred, sample_weight=sample_weight)\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_different_thresholds_unweighted(self):\n+        y_true = [0, 1, 0, 1]\n+        y_pred = [0.1, 0.2, 0.4, 0.7]\n+\n+        # with threshold = 0.3, y_pred will be converted to [0, 0, 1, 1]\n+        # cm = [[1, 1],\n+        #       [1, 1]]\n+        # sum_row = [2, 2], sum_col = [2, 2], true_positives = [1, 1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (1 / (2 + 2 - 1) + 1 / (2 + 2 - 1)) / 2\n+        obj = metrics.BinaryIoU(target_class_ids=[0, 1], threshold=0.3)\n+        result = obj(y_true, y_pred)\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+        # with threshold = 0.5, y_pred will be converted to [0, 0, 0, 1]\n+        # cm = [[2, 0],\n+        #       [1, 1]]\n+        # sum_row = [2, 2], sum_col = [3, 1], true_positives = [2, 1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (2 / (2 + 3 - 2) + 1 / (2 + 1 - 1)) / 2\n+        obj = metrics.BinaryIoU(target_class_ids=[0, 1], threshold=0.5)\n+        result = obj(y_true, y_pred)\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_multi_dim_input(self):\n+        y_true = np.array([[0, 1], [0, 1]], dtype=np.float32)\n+        y_pred = np.array([[0.1, 0.7], [0.9, 0.3]])\n+        threshold = 0.4  # y_pred will become [[0, 1], [1, 0]]\n+        sample_weight = np.array([[0.2, 0.3], [0.4, 0.1]])\n+        # cm = [[0.2, 0.4],\n+        #       [0.1, 0.3]]\n+        # sum_row = [0.6, 0.4], sum_col = [0.3, 0.7], true_positives = [0.2,\n+        # 0.3]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (\n+            0.2 / (0.6 + 0.3 - 0.2) + 0.3 / (0.4 + 0.7 - 0.3)\n+        ) / 2\n+        obj = metrics.BinaryIoU(target_class_ids=[0, 1], threshold=threshold)\n+        result = obj(y_true, y_pred, sample_weight=sample_weight)\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_zero_valid_entries(self):\n+        obj = metrics.BinaryIoU(target_class_ids=[0, 1])\n+        self.assertAllClose(obj.result(), 0, atol=1e-3)\n+\n+    def test_zero_and_non_zero_entries(self):\n+        y_pred = np.array([0.6], dtype=np.float32)\n+        threshold = 0.5\n+        y_true = np.array([1])\n+\n+        obj = metrics.BinaryIoU(target_class_ids=[0, 1], threshold=threshold)\n+        result = obj(y_true, y_pred)\n+\n+        # cm = [[0, 0],\n+        #       [0, 1]]\n+        # sum_row = [0, 1], sum_col = [0, 1], true_positives = [0, 1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = 1 / (1 + 1 - 1)\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+\n+class MeanIoUTest(testing.TestCase):\n+    def test_config(self):\n+        m_obj = metrics.MeanIoU(num_classes=2, name=\"mean_iou\")\n+        self.assertEqual(m_obj.name, \"mean_iou\")\n+        self.assertEqual(m_obj.num_classes, 2)\n+\n+        m_obj2 = metrics.MeanIoU.from_config(m_obj.get_config())\n+        self.assertEqual(m_obj2.name, \"mean_iou\")\n+        self.assertEqual(m_obj2.num_classes, 2)\n+\n+    def test_unweighted(self):\n+        y_pred = [0, 1, 0, 1]\n+        y_true = [0, 0, 1, 1]\n+\n+        m_obj = metrics.MeanIoU(num_classes=2)\n+\n+        result = m_obj(y_true, y_pred)\n+\n+        # cm = [[1, 1],\n+        #       [1, 1]]\n+        # sum_row = [2, 2], sum_col = [2, 2], true_positives = [1, 1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (1 / (2 + 2 - 1) + 1 / (2 + 2 - 1)) / 2\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_unweighted_ignore_class_255(self):\n+        y_pred = [0, 1, 1, 1]\n+        y_true = [0, 1, 2, 255]\n+\n+        m_obj = metrics.MeanIoU(num_classes=3, ignore_class=255)\n+\n+        result = m_obj(y_true, y_pred)\n+\n+        # cm = [[1, 0, 0],\n+        #       [0, 1, 0],\n+        #       [0, 1, 0]]\n+        # sum_row = [1, 1, 1], sum_col = [1, 2, 0], true_positives = [1, 1, 0]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (\n+            1 / (1 + 1 - 1) + 1 / (2 + 1 - 1) + 0 / (0 + 1 - 0)\n+        ) / 3\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_unweighted_ignore_class_1(self):\n+        y_pred = [0, 1, 1, 1]\n+        y_true = [0, 1, 2, -1]\n+\n+        m_obj = metrics.MeanIoU(num_classes=3, ignore_class=-1)\n+\n+        result = m_obj(y_true, y_pred)\n+\n+        # cm = [[1, 0, 0],\n+        #       [0, 1, 0],\n+        #       [0, 1, 0]]\n+        # sum_row = [1, 1, 1], sum_col = [1, 2, 0], true_positives = [1, 1, 0]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (\n+            1 / (1 + 1 - 1) + 1 / (2 + 1 - 1) + 0 / (0 + 1 - 0)\n+        ) / 3\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_weighted(self):\n+        y_pred = np.array([0, 1, 0, 1], dtype=np.float32)\n+        y_true = np.array([0, 0, 1, 1])\n+        sample_weight = np.array([0.2, 0.3, 0.4, 0.1])\n+\n+        m_obj = metrics.MeanIoU(num_classes=2)\n+\n+        result = m_obj(y_true, y_pred, sample_weight=sample_weight)\n+\n+        # cm = [[0.2, 0.3],\n+        #       [0.4, 0.1]]\n+        # sum_row = [0.6, 0.4], sum_col = [0.5, 0.5], true_positives = [0.2,\n+        # 0.1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (\n+            0.2 / (0.6 + 0.5 - 0.2) + 0.1 / (0.4 + 0.5 - 0.1)\n+        ) / 2\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_weighted_ignore_class_1(self):\n+        y_pred = np.array([0, 1, 0, 1], dtype=np.float32)\n+        y_true = np.array([0, 0, 1, -1])\n+        sample_weight = np.array([0.2, 0.3, 0.4, 0.1])\n+\n+        m_obj = metrics.MeanIoU(num_classes=2, ignore_class=-1)\n+\n+        result = m_obj(y_true, y_pred, sample_weight=sample_weight)\n+\n+        # cm = [[0.2, 0.3],\n+        #       [0.4, 0.0]]\n+        # sum_row = [0.6, 0.3], sum_col = [0.5, 0.4], true_positives = [0.2,\n+        # 0.0]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (\n+            0.2 / (0.6 + 0.5 - 0.2) + 0.0 / (0.3 + 0.4 - 0.0)\n+        ) / 2\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_multi_dim_input(self):\n+        y_pred = np.array([[0, 1], [0, 1]], dtype=np.float32)\n+        y_true = np.array([[0, 0], [1, 1]])\n+        sample_weight = np.array([[0.2, 0.3], [0.4, 0.1]])\n+\n+        m_obj = metrics.MeanIoU(num_classes=2)\n+\n+        result = m_obj(y_true, y_pred, sample_weight=sample_weight)\n+\n+        # cm = [[0.2, 0.3],\n+        #       [0.4, 0.1]]\n+        # sum_row = [0.6, 0.4], sum_col = [0.5, 0.5], true_positives = [0.2,\n+        # 0.1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (\n+            0.2 / (0.6 + 0.5 - 0.2) + 0.1 / (0.4 + 0.5 - 0.1)\n+        ) / 2\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_zero_valid_entries(self):\n+        m_obj = metrics.MeanIoU(num_classes=2)\n+        self.assertAllClose(m_obj.result(), 0, atol=1e-3)\n+\n+    def test_zero_and_non_zero_entries(self):\n+        y_pred = np.array([1], dtype=np.float32)\n+        y_true = np.array([1])\n+\n+        m_obj = metrics.MeanIoU(num_classes=2)\n+        result = m_obj(y_true, y_pred)\n+\n+        # cm = [[0, 0],\n+        #       [0, 1]]\n+        # sum_row = [0, 1], sum_col = [0, 1], true_positives = [0, 1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (0 + 1 / (1 + 1 - 1)) / 1\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+\n+class OneHotIoUTest(testing.TestCase):\n+    def test_unweighted(self):\n+        y_true = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0], [1, 0, 0]])\n+        # y_true will be converted to [2, 0, 1, 0]\n+        y_pred = np.array(\n+            [[0.2, 0.3, 0.5], [0.1, 0.2, 0.7], [0.5, 0.3, 0.1], [0.1, 0.4, 0.5]]\n+        )\n+        # y_pred will be converted to [2, 2, 0, 2]\n+        # cm = [[0, 0, 2],\n+        #       [1, 0, 0],\n+        #       [0, 0, 1]\n+        # sum_row = [1, 0, 3], sum_col = [2, 1, 1], true_positives = [0, 0, 1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (0 / (1 + 2 - 0) + 1 / (3 + 1 - 1)) / 2\n+        obj = metrics.OneHotIoU(num_classes=3, target_class_ids=[0, 2])\n+        result = obj(y_true, y_pred)\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_weighted(self):\n+        y_true = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0], [1, 0, 0]])\n+        # y_true will be converted to [2, 0, 1, 0]\n+        y_pred = np.array(\n+            [[0.2, 0.3, 0.5], [0.1, 0.2, 0.7], [0.5, 0.3, 0.1], [0.1, 0.4, 0.5]]\n+        )\n+        # y_pred will be converted to [2, 2, 0, 2]\n+        sample_weight = [0.1, 0.2, 0.3, 0.4]\n+        # cm = [[0, 0, 0.2+0.4],\n+        #       [0.3, 0, 0],\n+        #       [0, 0, 0.1]]\n+        # sum_row = [0.3, 0, 0.7], sum_col = [0.6, 0.3, 0.1]\n+        # true_positives = [0, 0, 0.1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (0 / (0.3 + 0.6 - 0) + 0.1 / (0.7 + 0.1 - 0.1)) / 2\n+        obj = metrics.OneHotIoU(num_classes=3, target_class_ids=[0, 2])\n+        result = obj(y_true, y_pred, sample_weight=sample_weight)\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+\n+class OneHotMeanIoUTest(testing.TestCase):\n+    def test_unweighted(self):\n+        y_true = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0], [1, 0, 0]])\n+        # y_true will be converted to [2, 0, 1, 0]\n+        y_pred = np.array(\n+            [[0.2, 0.3, 0.5], [0.1, 0.2, 0.7], [0.5, 0.3, 0.1], [0.1, 0.4, 0.5]]\n+        )\n+        # y_pred will be converted to [2, 2, 0, 2]\n+        # cm = [[0, 0, 2],\n+        #       [1, 0, 0],\n+        #       [0, 0, 1]\n+        # sum_row = [1, 0, 3], sum_col = [2, 1, 1], true_positives = [0, 0, 1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (0 + 0 + 1 / (3 + 1 - 1)) / 3\n+        obj = metrics.OneHotMeanIoU(num_classes=3)\n+        result = obj(y_true, y_pred)\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n+\n+    def test_weighted(self):\n+        y_true = np.array(\n+            [\n+                [0, 0, 1],\n+                [1, 0, 0],\n+                [0, 1, 0],\n+                [1, 0, 0],\n+                [1, 0, 0],\n+            ]\n+        )\n+        # y_true will be converted to [2, 0, 1, 0, 0]\n+        y_pred = np.array(\n+            [\n+                [0.2, 0.3, 0.5],\n+                [0.1, 0.2, 0.7],\n+                [0.5, 0.3, 0.1],\n+                [0.1, 0.4, 0.5],\n+                [0.6, 0.2, 0.2],\n+            ]\n+        )\n+        # y_pred will be converted to [2, 2, 0, 2, 0]\n+        sample_weight = [0.1, 0.2, 0.3, 0.3, 0.1]\n+        # cm = [[0.1, 0, 0.2+0.3],\n+        #       [0.3, 0, 0],\n+        #       [0, 0, 0.1]]\n+        # sum_row = [0.4, 0, 0.6], sum_col = [0.6, 0.3, 0.1]\n+        # true_positives = [0.1, 0, 0.1]\n+        # iou = true_positives / (sum_row + sum_col - true_positives))\n+        expected_result = (\n+            0.1 / (0.4 + 0.6 - 0.1) + 0 + 0.1 / (0.6 + 0.1 - 0.1)\n+        ) / 3\n+        obj = metrics.OneHotMeanIoU(num_classes=3)\n+        result = obj(y_true, y_pred, sample_weight=sample_weight)\n+        self.assertAllClose(result, expected_result, atol=1e-3)\n\n@@ -590,3 +590,78 @@ def _filter_top_k(x, k):\n         ops.one_hot(top_k_idx, ops.shape(x)[-1], axis=-1), axis=-2\n     )\n     return x * top_k_mask + NEG_INF * (1 - top_k_mask)\n+\n+\n+def confusion_matrix(\n+    labels,\n+    predictions,\n+    num_classes=None,\n+    weights=None,\n+    dtype=\"int32\",\n+):\n+    \"\"\"Computes the confusion matrix from predictions and labels.\n+\n+    The matrix columns represent the prediction labels and the rows represent\n+    the real labels. The confusion matrix is always a 2-D array of shape\n+    `(n, n)`, where `n` is the number of valid labels for a given classification\n+    task. Both prediction and labels must be 1-D arrays of the same shape in\n+    order for this function to work.\n+\n+    If `num_classes` is `None`, then `num_classes` will be set to one plus the\n+    maximum value in either predictions or labels. Class labels are expected to\n+    start at 0. For example, if `num_classes` is 3, then the possible labels\n+    would be `[0, 1, 2]`.\n+\n+    If `weights` is not `None`, then each prediction contributes its\n+    corresponding weight to the total value of the confusion matrix cell.\n+\n+    For example:\n+\n+    ```python\n+    keras_core.metrics.metrics_utils.confusion_matrix([1, 2, 4], [2, 2, 4]) ==>\n+        [[0 0 0 0 0]\n+        [0 0 1 0 0]\n+        [0 0 1 0 0]\n+        [0 0 0 0 0]\n+        [0 0 0 0 1]]\n+    ```\n+\n+    Note that the possible labels are assumed to be `[0, 1, 2, 3, 4]`,\n+    resulting in a 5x5 confusion matrix.\n+\n+    Args:\n+        labels: 1-D tensor of real labels for the classification task.\n+        predictions: 1-D tensor of predictions for a given classification.\n+        num_classes: The possible number of labels the classification task can\n+                    have. If this value is not provided, it will be calculated\n+                    using both predictions and labels array.\n+        weights: An optional tensor whose shape matches `predictions`.\n+        dtype: Data type of the confusion matrix.\n+\n+    Returns:\n+        A tensor of type `dtype` with shape `(n, n)` representing the confusion\n+        matrix, where `n` is the number of possible labels in the classification\n+        task.\n+    \"\"\"\n+    labels = ops.convert_to_tensor(labels, dtype)\n+    predictions = ops.convert_to_tensor(predictions, dtype)\n+    labels, predictions = squeeze_to_same_rank(labels, predictions)\n+\n+    predictions = ops.cast(predictions, dtype)\n+    labels = ops.cast(labels, dtype)\n+\n+    if num_classes is None:\n+        num_classes = ops.maximum(ops.max(predictions), ops.max(labels)) + 1\n+    else:\n+        num_classes = ops.cast(num_classes, dtype)\n+\n+    if weights is not None:\n+        weights = ops.convert_to_tensor(weights, dtype)\n+\n+    indices = ops.stack([labels, predictions], axis=1)\n+    values = ops.ones_like(predictions, dtype) if weights is None else weights\n+    indices = ops.cast(indices, dtype=\"int64\")\n+    values = ops.cast(values, dtype=dtype)\n+    num_classes = ops.cast(num_classes, \"int64\")\n+    confusion_matrix = ops.scatter(indices, values, (num_classes, num_classes))\n+    return confusion_matrix\n\n@@ -11,6 +11,7 @@ from keras_core.backend import random\n from keras_core.backend import shape\n from keras_core.operations import image\n from keras_core.operations import operation_utils\n+from keras_core.operations.core import *  # noqa: F403\n from keras_core.operations.math import *  # noqa: F403\n from keras_core.operations.nn import *  # noqa: F403\n from keras_core.operations.numpy import *  # noqa: F403\n\n@@ -62,3 +62,7 @@ class CoreOpsCorrectnessTest(testing.TestCase):\n             core.scatter(indices, values, (6, 3)),\n             [[0, 0, 0], [0, 0, 0], [1, 2, 3], [0, 0, 0], [4, 5, 6], [0, 0, 0]],\n         )\n+        # Duplicate indices\n+        indices = np.array([[0], [0]])\n+        values = np.array([1, 1])\n+        self.assertAllClose(core.scatter(indices, values, (1,)), [2])\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
