{"custom_id": "requests#2361a6fc79f3af84550478cd43e0f9ab26e714f4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 3 | Methods Changed: 4 | Complexity Δ (Sum/Max): 9/11 | Churn Δ: 6 | Churn Cumulative: 3457 | Contributors (this commit): 18 | Commits (past 90d): 145 | Contributors (cumulative): 23 | DMM Complexity: None\n\nDIFF:\n@@ -199,7 +199,7 @@ class Request(object):\n                 # Add the old request to the history collector.\n                 history.append(r)\n \n-                url = get_clean_url(r.headers['location'], parent_url=self.url)\n+                url = cleanup_url(r.headers['location'], parent_url=self.url)\n \n                 # If 303, convert to idempotent GET.\n                 # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n\n@@ -44,7 +44,7 @@ def encode_params(params):\n     else:\n         return params\n \n-def get_clean_url(url, parent_url=None):\n+def cleanup_url(url, parent_url=None):\n     # Handle redirection without scheme (see: RFC 1808 Section 4)\n     if url.startswith('//'):\n         parsed_rurl = urlparse(parent_url)\n@@ -73,7 +73,7 @@ def get_clean_url(url, parent_url=None):\n def build_url(url, query_params):\n     \"\"\"Build the actual URL to use.\"\"\"\n \n-    url = get_clean_url(url)\n+    url = cleanup_url(url)\n \n     query_params = encode_params(query_params)\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#04bcb74970c49ea6bda3881cb02beed2e3359b7b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 1/1 | Churn Δ: 4 | Churn Cumulative: 688 | Contributors (this commit): 6 | Commits (past 90d): 40 | Contributors (cumulative): 6 | DMM Complexity: 0.0\n\nDIFF:\n@@ -54,6 +54,10 @@ def cleanup_url(url, parent_url=None):\n     if netloc:\n         netloc = netloc.encode('idna')\n \n+    # Add a trailing slash to root domain reqests.\n+    if not len(path):\n+        path = '/'\n+\n     if isinstance(path, unicode):\n         path = path.encode('utf-8')\n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#aa04cc9b427432358398aac713c2574193ecc691", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 23 | Lines Deleted: 3 | Files Changed: 3 | Hunks: 6 | Methods Changed: 5 | Complexity Δ (Sum/Max): 42/52 | Churn Δ: 26 | Churn Cumulative: 4493 | Contributors (this commit): 24 | Commits (past 90d): 154 | Contributors (cumulative): 41 | DMM Complexity: 1.0\n\nDIFF:\n@@ -90,9 +90,11 @@ def get(url, **kwargs):\n     :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n     :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n     :param timeout: (optional) Float describing the timeout of the request.\n+    :param allow_redirects: (optional) Boolean. Set to False to disable redirect following.\n     :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n     \"\"\"\n \n+    kwargs.setdefault('allow_redirects', True)\n     return request('GET', url, **kwargs)\n \n \n@@ -106,9 +108,11 @@ def head(url, **kwargs):\n     :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n     :param auth: (optional) AuthObject to enable Basic HTTP Auth.\n     :param timeout: (optional) Float describing the timeout of the request.\n+    :param allow_redirects: (optional) Boolean. Set to False to disable redirect following.\n     :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n     \"\"\"\n \n+    kwargs.setdefault('allow_redirects', True)\n     return request('HEAD', url, **kwargs)\n \n \n\n@@ -203,9 +203,7 @@ class Request(object):\n \n             while (\n                 ('location' in r.headers) and\n-                ((self.method in ('GET', 'HEAD')) or\n-                (r.status_code is codes.see_other) or\n-                (self.allow_redirects))\n+                ((r.status_code is codes.see_other) or (self.allow_redirects))\n             ):\n \n                 r.close()\n\n@@ -422,6 +422,24 @@ class RequestsTestSuite(unittest.TestCase):\n             self.assertEquals(rbody.get('data'), '')\n \n \n+    def test_GET_no_redirect(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.get(service('redirect', '3'), allow_redirects=False)\n+            self.assertEquals(r.status_code, 302)\n+            self.assertEquals(len(r.history), 0)\n+\n+\n+    def test_HEAD_no_redirect(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.head(service('redirect', '3'), allow_redirects=False)\n+            self.assertEquals(r.status_code, 302)\n+            self.assertEquals(len(r.history), 0)\n+\n+\n     def test_redirect_history(self):\n \n         for service in SERVICES:\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#b970d468d1251c51d28b0ec142a12f817cf19925", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 103 | Contributors (this commit): 1 | Commits (past 90d): 6 | Contributors (cumulative): 1 | DMM Complexity: 0.0\n\nDIFF:\n@@ -72,7 +72,7 @@ class PoolManager(object):\n         port = port or port_by_scheme.get(scheme, 80)\n \n         r = self.connection_from_host(host, port=port, scheme=scheme)\n-        print r.__dict__\n+\n         return r\n \n     def urlopen(self, method, url, **kw):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#a8695ecd32f18135ae5f34f466382993a4cb7d3d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 2672 | Contributors (this commit): 8 | Commits (past 90d): 14 | Contributors (cumulative): 8 | DMM Complexity: None\n\nDIFF:\n@@ -12,8 +12,8 @@ This module implements the main Requests system.\n \"\"\"\n \n __title__ = 'requests'\n-__version__ = '0.6.1'\n-__build__ = 0x000601\n+__version__ = '0.6.2'\n+__build__ = 0x000602\n __author__ = 'Kenneth Reitz'\n __license__ = 'ISC'\n __copyright__ = 'Copyright 2011 Kenneth Reitz'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#78b5d9ed45d3f969e38e6772501da446db1efd59", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 5 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): -52/0 | Churn Δ: 6 | Churn Cumulative: 2783 | Contributors (this commit): 18 | Commits (past 90d): 108 | Contributors (cumulative): 18 | DMM Complexity: None\n\nDIFF:\n@@ -4,6 +4,7 @@\n requests.models\n ~~~~~~~~~~~~~~~\n \n+This module contains the primary classes that power Requests.\n \"\"\"\n \n import urllib\n@@ -243,7 +244,10 @@ class Request(object):\n \n \n     def send(self, anyway=False):\n-        \"\"\"Sends the shit.\"\"\"\n+        \"\"\"Sends the HTTP Request. Populates `Request.response`.\n+\n+        Returns True if everything went according to plan.\n+        \"\"\"\n \n         # Safety check.\n         self._checks()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#03babafc7b16bd84b13f405fd66ccb1751f4aaee", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 2 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 2787 | Contributors (this commit): 18 | Commits (past 90d): 109 | Contributors (cumulative): 18 | DMM Complexity: 0.0\n\nDIFF:\n@@ -11,6 +11,7 @@ import urllib\n import zlib\n from Cookie import SimpleCookie\n from urlparse import urlparse, urlunparse, urljoin\n+from weakref import ref\n \n from .packages import urllib3\n from .packages.urllib3.filepost import encode_multipart_formdata\n@@ -240,7 +241,8 @@ class Request(object):\n         self.response = r\n \n         # Give Response some context.\n-        self.response.request = self\n+        self.response.request = ref(self)()\n+        self.response.request.response = ref(self.response)()\n \n \n     def send(self, anyway=False):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e9f94e698d3cb1e84d383dbc5a7393e55140b542", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 737 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 2 | Methods Changed: 67 | Complexity Δ (Sum/Max): 88/73 | Churn Δ: 737 | Churn Cumulative: 737 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 2 | DMM Complexity: 1.0\n\nDIFF:\n@@ -0,0 +1,209 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+import unittest\n+import mock\n+import sys\n+import os\n+sys.path.append(os.getcwd())\n+\n+try:\n+    import omnijson as json\n+except ImportError:\n+    import json\n+\n+import requests\n+from requests.models import Response\n+\n+class RequestsAPIUnitTests(unittest.TestCase):\n+    \"\"\"Requests API unit test cases.\"\"\"\n+\n+    def setUp(self):\n+        pass\n+\n+\n+    def tearDown(self):\n+        \"\"\"Teardown.\"\"\"\n+        pass\n+\n+\n+    @mock.patch('requests.api.dispatch_hook')\n+    @mock.patch('requests.api.Request')\n+    @mock.patch('requests.api.cookiejar_from_dict')\n+    def test_request(self, mock_cjar, mock_request, mock_hook):\n+        args = dict(\n+                    method = None,\n+                    url = None,\n+                    data = None,\n+                    params = None,\n+                    headers = None,\n+                    cookiejar = None,\n+                    files = None,\n+                    auth = None,\n+                    timeout = 1,\n+                    allow_redirects = None,\n+                    proxies = None,\n+                   )\n+        hooks = {'args': args, 'pre_request': mock_request,\n+                 'post_request': mock_request, 'response': 'response'}\n+        sideeffect = lambda x,y,z: hooks[x]\n+        mock_cjar.return_value = None\n+        mock_request.send = mock.Mock(return_value={})\n+        mock_request.response = \"response\"\n+        mock_hook.side_effect = sideeffect\n+\n+        r = requests.request('get','http://google.com')\n+\n+\n+        mock_cjar.assert_called_once_with({})\n+        mock_hook.assert_called__with('args', None, args)\n+        mock_request.assert_called_once_with(**args)\n+        mock_hook.assert_called__with('pre_request', None, mock_request)\n+        mock_request.send.assert_called_once_with()\n+        mock_hook.assert_called__with('post_request', None, mock_request)\n+        mock_hook.assert_called__with('response', None, mock_request)\n+        self.assertEqual(r, \"response\")\n+\n+\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_get(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.get('http://google.com')\n+        mock_request.assert_called_once_with('get', 'http://google.com',\n+                                             allow_redirects= True)\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_get_with_kwargs(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.get('http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+        mock_request.assert_called_once_with('get', 'http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_head(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.head('http://google.com')\n+        mock_request.assert_called_once_with('head', 'http://google.com',\n+                                             allow_redirects= True)\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_head_with_kwargs(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.head('http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+        mock_request.assert_called_once_with('head', 'http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_post(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.post('http://google.com', {})\n+        mock_request.assert_called_once_with('post', 'http://google.com',\n+                                              data= {})\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_post_with_kwargs(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.post('http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+        mock_request.assert_called_once_with('post', 'http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_put(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.put('http://google.com', {})\n+        mock_request.assert_called_once_with('put', 'http://google.com',\n+                                             data= {})\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_put_with_kwargs(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.put('http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+        mock_request.assert_called_once_with('put', 'http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_patch(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.patch('http://google.com', {})\n+        mock_request.assert_called_once_with('patch', 'http://google.com',\n+                                             data= {})\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_patch_with_kwargs(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.patch('http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+        mock_request.assert_called_once_with('patch', 'http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_delete(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.delete('http://google.com')\n+        mock_request.assert_called_once_with('delete', 'http://google.com')\n+\n+    @mock.patch('requests.api.request')\n+    def test_http_delete_with_kwargs(self, mock_request):\n+        mock_request.return_value = Response()\n+        requests.delete('http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+        mock_request.assert_called_once_with('delete', 'http://google.com',\n+                     params=\"params\", data=\"data\", headers=\"headers\",\n+                     cookies=\"cookies\",\n+                     files=\"files\", auth=\"auth\", timeout=\"timeout\",\n+                     allow_redirects=False,\n+                     proxies=\"proxies\", hooks=\"hooks\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\n@@ -0,0 +1,528 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\n+from __future__ import with_statement\n+\n+import unittest\n+import cookielib\n+\n+try:\n+    import omnijson as json\n+except ImportError:\n+    import json\n+\n+import requests\n+\n+from requests.sessions import Session\n+from requests.utils import curl_from_request\n+\n+\n+HTTPBIN_URL = 'http://httpbin.org/'\n+HTTPSBIN_URL = 'https://httpbin.herokuapp.com/'\n+\n+# HTTPBIN_URL = 'http://staging.httpbin.org/'\n+# HTTPSBIN_URL = 'https://httpbin-staging.ep.io/'\n+\n+\n+def httpbin(*suffix):\n+    \"\"\"Returns url for HTTPBIN resource.\"\"\"\n+\n+    return HTTPBIN_URL + '/'.join(suffix)\n+\n+\n+def httpsbin(*suffix):\n+    \"\"\"Returns url for HTTPSBIN resource.\"\"\"\n+\n+    return HTTPSBIN_URL + '/'.join(suffix)\n+\n+\n+SERVICES = (httpbin, httpsbin)\n+\n+\n+\n+class RequestsTestSuite(unittest.TestCase):\n+    \"\"\"Requests test cases.\"\"\"\n+\n+    # It goes to eleven.\n+    _multiprocess_can_split_ = True\n+\n+    def setUp(self):\n+        pass\n+\n+    def tearDown(self):\n+        pass\n+\n+    def test_invalid_url(self):\n+        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')\n+\n+    def test_HTTP_200_OK_GET(self):\n+        r = requests.get(httpbin('/'))\n+        self.assertEqual(r.status_code, 200)\n+\n+    def test_HTTP_302_ALLOW_REDIRECT_GET(self):\n+\tr = requests.get(httpbin('redirect', '1'))\n+\tself.assertEqual(r.status_code, 200)\n+\n+    def test_HTTP_302_GET(self):\n+\tr = requests.get(httpbin('redirect', '1'), allow_redirects=False)\n+\tself.assertEqual(r.status_code, 302)\n+\n+    def test_HTTPS_200_OK_GET(self):\n+        r = requests.get(httpsbin('/'))\n+        self.assertEqual(r.status_code, 200)\n+\n+\n+    def test_HTTP_200_OK_GET_WITH_PARAMS(self):\n+        heads = {'User-agent': 'Mozilla/5.0'}\n+\n+        r = requests.get(httpbin('user-agent'), headers=heads)\n+\n+        assert heads['User-agent'] in r.content\n+        self.assertEqual(r.status_code, 200)\n+\n+\n+    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):\n+        heads = {'User-agent': 'Mozilla/5.0'}\n+\n+        r = requests.get(httpbin('get') + '?test=true', params={'q': 'test'}, headers=heads)\n+        self.assertEqual(r.status_code, 200)\n+\n+\n+    def test_user_agent_transfers(self):\n+        \"\"\"Issue XX\"\"\"\n+\n+        heads = {\n+            'User-agent':\n+                'Mozilla/5.0 (github.com/kennethreitz/requests)'\n+        }\n+\n+        r = requests.get(httpbin('user-agent'), headers=heads);\n+        self.assertTrue(heads['User-agent'] in r.content)\n+\n+        heads = {\n+            'user-agent':\n+                'Mozilla/5.0 (github.com/kennethreitz/requests)'\n+        }\n+\n+        r = requests.get(httpbin('user-agent'), headers=heads);\n+        self.assertTrue(heads['user-agent'] in r.content)\n+\n+\n+    def test_HTTP_200_OK_HEAD(self):\n+        r = requests.head(httpbin('/'))\n+        self.assertEqual(r.status_code, 200)\n+\n+\n+    def test_HTTPS_200_OK_HEAD(self):\n+        r = requests.head(httpsbin('/'))\n+        self.assertEqual(r.status_code, 200)\n+\n+\n+    def test_HTTP_200_OK_PUT(self):\n+        r = requests.put(httpbin('put'))\n+        self.assertEqual(r.status_code, 200)\n+\n+\n+    def test_HTTPS_200_OK_PUT(self):\n+        r = requests.put(httpsbin('put'))\n+        self.assertEqual(r.status_code, 200)\n+\n+\n+    def test_HTTP_200_OK_PATCH(self):\n+        r = requests.patch(httpbin('patch'))\n+        self.assertEqual(r.status_code, 200)\n+\n+\n+    def test_HTTPS_200_OK_PATCH(self):\n+        r = requests.patch(httpsbin('patch'))\n+        self.assertEqual(r.status_code, 200)\n+\n+\n+    def test_AUTH_HTTP_200_OK_GET(self):\n+\n+        for service in SERVICES:\n+\n+            auth = ('user', 'pass')\n+            url = service('basic-auth', 'user', 'pass')\n+\n+            r = requests.get(url, auth=auth)\n+            # print r.__dict__\n+            self.assertEqual(r.status_code, 200)\n+\n+\n+            r = requests.get(url)\n+            self.assertEqual(r.status_code, 200)\n+\n+\n+    def test_POSTBIN_GET_POST_FILES(self):\n+\n+        for service in SERVICES:\n+\n+            url = service('post')\n+            post = requests.post(url).raise_for_status()\n+\n+            post = requests.post(url, data={'some': 'data'})\n+            self.assertEqual(post.status_code, 200)\n+\n+            post2 = requests.post(url, files={'some': open('test_requests.py')})\n+            self.assertEqual(post2.status_code, 200)\n+\n+            post3 = requests.post(url, data='[{\"some\": \"json\"}]')\n+            self.assertEqual(post3.status_code, 200)\n+\n+\n+    def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):\n+\n+        for service in SERVICES:\n+\n+            url = service('post')\n+            post = requests.post(url,\n+                files={'some': open('test_requests.py')},\n+                data={'some': 'data'})\n+\n+            self.assertEqual(post.status_code, 200)\n+\n+\n+    def test_POSTBIN_GET_POST_FILES_WITH_HEADERS(self):\n+\n+        for service in SERVICES:\n+\n+            url = service('post')\n+\n+            post2 = requests.post(url,\n+                files={'some': open('test_requests.py')},\n+                headers = {'User-Agent': 'requests-tests'})\n+\n+            self.assertEqual(post2.status_code, 200)\n+\n+\n+    def test_nonzero_evaluation(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.get(service('status', '500'))\n+            self.assertEqual(bool(r), False)\n+\n+            r = requests.get(service('/'))\n+            self.assertEqual(bool(r), True)\n+\n+\n+    def test_request_ok_set(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.get(service('status', '404'))\n+            self.assertEqual(r.ok, False)\n+\n+\n+    def test_status_raising(self):\n+        r = requests.get(httpbin('status', '404'))\n+        self.assertRaises(requests.HTTPError, r.raise_for_status)\n+\n+        r = requests.get(httpbin('status', '200'))\n+        self.assertFalse(r.error)\n+        r.raise_for_status()\n+\n+\n+    def test_cookie_jar(self):\n+\n+        jar = cookielib.CookieJar()\n+        self.assertFalse(jar)\n+\n+        url = httpbin('cookies', 'set', 'requests_cookie', 'awesome')\n+        r = requests.get(url, cookies=jar)\n+        self.assertTrue(jar)\n+\n+        cookie_found = False\n+        for cookie in jar:\n+            if cookie.name == 'requests_cookie':\n+                self.assertEquals(cookie.value, 'awesome')\n+                cookie_found = True\n+        self.assertTrue(cookie_found)\n+\n+        r = requests.get(httpbin('cookies'), cookies=jar)\n+        self.assertTrue('awesome' in r.content)\n+\n+\n+    def test_decompress_gzip(self):\n+\n+        r = requests.get(httpbin('gzip'))\n+        r.content.decode('ascii')\n+\n+\n+    def test_unicode_get(self):\n+\n+        for service in SERVICES:\n+\n+            url = service('/')\n+\n+            requests.get(url, params={'foo': u'føø'})\n+            requests.get(url, params={u'føø': u'føø'})\n+            requests.get(url, params={'føø': 'føø'})\n+            requests.get(url, params={'foo': u'foo'})\n+            requests.get(service('ø'), params={'foo': u'foo'})\n+\n+\n+    def test_httpauth_recursion(self):\n+\n+        http_auth = ('user', 'BADpass')\n+\n+        for service in SERVICES:\n+            r = requests.get(service('basic-auth', 'user', 'pass'), auth=http_auth)\n+            self.assertEquals(r.status_code, 401)\n+\n+\n+    def test_settings(self):\n+\n+        def test():\n+            r = requests.get(httpbin(''))\n+            r.raise_for_status()\n+\n+        with requests.settings(timeout=0.0000001):\n+            self.assertRaises(requests.Timeout, test)\n+\n+        with requests.settings(timeout=100):\n+            requests.get(httpbin(''))\n+\n+\n+    def test_urlencoded_post_data(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.post(service('post'), data=dict(test='fooaowpeuf'))\n+\n+            self.assertEquals(r.status_code, 200)\n+            self.assertEquals(r.headers['content-type'], 'application/json')\n+            self.assertEquals(r.url, service('post'))\n+\n+            rbody = json.loads(r.content)\n+\n+            self.assertEquals(rbody.get('form'), dict(test='fooaowpeuf'))\n+            self.assertEquals(rbody.get('data'), '')\n+\n+\n+    def test_nonurlencoded_post_data(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.post(service('post'), data='fooaowpeuf')\n+\n+            self.assertEquals(r.status_code, 200)\n+            self.assertEquals(r.headers['content-type'], 'application/json')\n+            self.assertEquals(r.url, service('post'))\n+\n+            rbody = json.loads(r.content)\n+            # Body wasn't valid url encoded data, so the server returns None as\n+            # \"form\" and the raw body as \"data\".\n+            self.assertEquals(rbody.get('form'), None)\n+            self.assertEquals(rbody.get('data'), 'fooaowpeuf')\n+\n+\n+    def test_urlencoded_post_querystring(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.post(service('post'), params=dict(test='fooaowpeuf'))\n+\n+            self.assertEquals(r.status_code, 200)\n+            self.assertEquals(r.headers['content-type'], 'application/json')\n+            self.assertEquals(r.url, service('post?test=fooaowpeuf'))\n+\n+            rbody = json.loads(r.content)\n+            self.assertEquals(rbody.get('form'), {}) # No form supplied\n+            self.assertEquals(rbody.get('data'), '')\n+\n+\n+    def test_nonurlencoded_post_querystring(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.post(service('post'), params='fooaowpeuf')\n+\n+            self.assertEquals(r.status_code, 200)\n+            self.assertEquals(r.headers['content-type'], 'application/json')\n+            self.assertEquals(r.url, service('post?fooaowpeuf'))\n+\n+            rbody = json.loads(r.content)\n+            self.assertEquals(rbody.get('form'), {}) # No form supplied\n+            self.assertEquals(rbody.get('data'), '')\n+\n+\n+    def test_urlencoded_post_query_and_data(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.post(\n+                service('post'),\n+                params=dict(test='fooaowpeuf'),\n+                data=dict(test2=\"foobar\"))\n+\n+            self.assertEquals(r.status_code, 200)\n+            self.assertEquals(r.headers['content-type'], 'application/json')\n+            self.assertEquals(r.url, service('post?test=fooaowpeuf'))\n+\n+            rbody = json.loads(r.content)\n+            self.assertEquals(rbody.get('form'), dict(test2='foobar'))\n+            self.assertEquals(rbody.get('data'), '')\n+\n+\n+    def test_nonurlencoded_post_query_and_data(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.post(service('post'),\n+                params='fooaowpeuf', data=\"foobar\")\n+\n+            self.assertEquals(r.status_code, 200)\n+            self.assertEquals(r.headers['content-type'], 'application/json')\n+            self.assertEquals(r.url, service('post?fooaowpeuf'))\n+\n+            rbody = json.loads(r.content)\n+\n+            self.assertEquals(rbody.get('form'), None)\n+            self.assertEquals(rbody.get('data'), 'foobar')\n+\n+\n+    def test_idna(self):\n+        r = requests.get(u'http://➡.ws/httpbin')\n+        assert 'httpbin' in r.url\n+\n+\n+    def test_urlencoded_get_query_multivalued_param(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.get(service('get'), params=dict(test=['foo','baz']))\n+            self.assertEquals(r.status_code, 200)\n+            self.assertEquals(r.url, service('get?test=foo&test=baz'))\n+\n+\n+    def test_urlencoded_post_querystring_multivalued(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.post(service('post'), params=dict(test=['foo','baz']))\n+            self.assertEquals(r.status_code, 200)\n+            self.assertEquals(r.headers['content-type'], 'application/json')\n+            self.assertEquals(r.url, service('post?test=foo&test=baz'))\n+\n+            rbody = json.loads(r.content)\n+            self.assertEquals(rbody.get('form'), {}) # No form supplied\n+            self.assertEquals(rbody.get('data'), '')\n+\n+\n+    def test_urlencoded_post_query_multivalued_and_data(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.post(\n+                service('post'),\n+                params=dict(test=['foo','baz']),\n+                data=dict(test2=\"foobar\",test3=['foo','baz']))\n+\n+            self.assertEquals(r.status_code, 200)\n+            self.assertEquals(r.headers['content-type'], 'application/json')\n+            self.assertEquals(r.url, service('post?test=foo&test=baz'))\n+            rbody = json.loads(r.content)\n+            self.assertEquals(rbody.get('form'), dict(test2='foobar',test3='foo'))\n+            self.assertEquals(rbody.get('data'), '')\n+\n+\n+    def test_redirect_history(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.get(service('redirect', '3'))\n+            self.assertEquals(r.status_code, 200)\n+            self.assertEquals(len(r.history), 3)\n+\n+\n+    def test_relative_redirect_history(self):\n+\n+        for service in SERVICES:\n+\n+            r = requests.get(service('relative-redirect', '3'))\n+            self.assertEquals(r.status_code, 200)\n+            self.assertEquals(len(r.history), 3)\n+\n+\n+    def test_session_HTTP_200_OK_GET(self):\n+\n+        s = Session()\n+        r = s.get(httpbin('/'))\n+        self.assertEqual(r.status_code, 200)\n+\n+\n+    def test_session_HTTPS_200_OK_GET(self):\n+\n+        s = Session()\n+        r = s.get(httpsbin('/'))\n+        self.assertEqual(r.status_code, 200)\n+\n+\n+    def test_session_persistent_headers(self):\n+\n+        heads = {'User-agent': 'Mozilla/5.0'}\n+\n+        s = Session()\n+        s.headers = heads\n+        # Make 2 requests from Session object, should send header both times\n+        r1 = s.get(httpbin('user-agent'))\n+\n+        assert heads['User-agent'] in r1.content\n+        r2 = s.get(httpbin('user-agent'))\n+\n+        assert heads['User-agent'] in r2.content\n+        self.assertEqual(r2.status_code, 200)\n+\n+\n+\n+    def test_curl_HTTP_OK_GET(self):\n+        curl_str = 'curl -L -X GET -H \"Accept-Encoding:gzip\" -H \"User-Agent:python-requests.org\" \"http://httpbin.org//\"'\n+        r = requests.get(httpbin('/'))\n+        self.assertEqual(curl_from_request(r.request), curl_str)\n+\n+\n+    def test_curl_HTTP_OK_GET_WITH_PARAMS(self):\n+        curl_str = 'curl -L -X GET -H \"Accept-Encoding:gzip\" -H \"User-agent:Mozilla/5.0\" \"http://httpbin.org/user-agent\"'\n+\n+        heads = {'User-agent': 'Mozilla/5.0'}\n+        r = requests.get(httpbin('user-agent'), headers=heads)\n+        self.assertEqual(curl_from_request(r.request), curl_str)\n+\n+\n+    def test_curl_HTTP_OK_HEAD(self):\n+        curl_str ='curl -L -I -H \"Accept-Encoding:gzip\" -H \"User-Agent:python-requests.org\" \"http://httpbin.org//\"'\n+        r = requests.head(httpbin('/'))\n+        self.assertEqual(curl_from_request(r.request), curl_str)\n+\n+\n+    def test_curl_HTTP_OK_PATCH(self):\n+        curl_str = 'curl -L -X PATCH -H \"Accept-Encoding:gzip\" -H \"User-Agent:python-requests.org\" \"http://httpbin.org/patch\"'\n+        r = requests.patch(httpbin('patch'))\n+        self.assertEqual(curl_from_request(r.request), curl_str)\n+\n+\n+    def test_curl_AUTH_HTTPS_OK_GET(self):\n+        curl_str = 'curl -L -u \"user:pass\" -X GET -H \"Accept-Encoding:gzip\" -H \"User-Agent:python-requests.org\" \"https://httpbin.ep.io/basic-auth/user/pass\"'\n+        auth = ('user', 'pass')\n+        r = requests.get(httpsbin('basic-auth', 'user', 'pass'), auth=auth)\n+        self.assertEqual(curl_from_request(r.request), curl_str)\n+\n+\n+    def test_curl_POSTBIN_GET_POST_FILES(self):\n+       curl_str = 'curl -L -X POST -H \"Accept-Encoding:gzip\" -H \"User-Agent:python-requests.org\" -d \"some=data\" \"http://httpbin.org/post\"'\n+       post = requests.post(httpbin('post'), data={'some': 'data'})\n+       self.assertEqual(curl_from_request(post.request), curl_str)\n+\n+       curl_str = 'curl -L -X POST -H \"Accept-Encoding:gzip\" -H \"User-Agent:python-requests.org\" -F \"some=@test_requests.py\" \"https://httpbin.ep.io/post\"'\n+       post2 = requests.post(httpsbin('post'), files={'some': open('test_requests.py')})\n+       self.assertEqual(curl_from_request(post2.request), curl_str)\n+\n+       curl_str = 'curl -L -X POST -H \"Accept-Encoding:gzip\" -H \"User-Agent:python-requests.org\" -d \\'[{\"some\": \"json\"}]\\' \"http://httpbin.org/post\"'\n+       post3 = requests.post(httpbin('post'), data='[{\"some\": \"json\"}]')\n+       self.assertEqual(curl_from_request(post3.request), curl_str)\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#e7b31af784c25b1cbc390bad60ea19f24a0c7905", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 9 | Lines Deleted: 7 | Files Changed: 1 | Hunks: 4 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 16 | Churn Cumulative: 1116 | Contributors (this commit): 1 | Commits (past 90d): 11 | Contributors (cumulative): 1 | DMM Complexity: 1.0\n\nDIFF:\n@@ -258,8 +258,7 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n             these headers completely replace any pool-specific headers.\n \n         :param retries:\n-            Number of retries to allow before raising\n-            a MaxRetryError exception.\n+            Number of retries to allow before raising a MaxRetryError exception.\n \n         :param redirect:\n             Automatically handle redirects (status codes 301, 302, 303, 307),\n@@ -320,16 +319,19 @@ class HTTPConnectionPool(ConnectionPool, RequestMethods):\n                                                   timeout=timeout,\n                                                   body=body, headers=headers)\n \n+            # If we're going to release the connection in ``finally:``, then\n+            # the request doesn't need to know about the connection. Otherwise\n+            # it will also try to release it and we'll have a double-release\n+            # mess.\n+            response_conn = not release_conn and conn\n+\n+\n             # Import httplib's response into our own wrapper object\n             response = HTTPResponse.from_httplib(httplib_response,\n                                                  pool=self,\n-                                                 connection=conn,\n+                                                 connection=response_conn,\n                                                  **response_kw)\n \n-            if release_conn:\n-                # The connection will be released manually in the ``finally:``\n-                response.connection = None\n-\n             # else:\n             #     The connection will be put back into the pool when\n             #     ``response.release_conn()`` is called (implicitly by\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#c8f2b3a722d95be95036da13dd9a2a363ed2cd10", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 3 | Files Changed: 1 | Hunks: 2 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 2792 | Contributors (this commit): 18 | Commits (past 90d): 110 | Contributors (cumulative): 18 | DMM Complexity: 1.0\n\nDIFF:\n@@ -241,8 +241,7 @@ class Request(object):\n         self.response = r\n \n         # Give Response some context.\n-        self.response.request = ref(self)()\n-        self.response.request.response = ref(self.response)()\n+        self.response.request = self\n \n \n     def send(self, anyway=False):\n@@ -310,7 +309,7 @@ class Request(object):\n                     pools = self._pools\n \n                     # Part of a connection pool, so no fancy stuff. Sorry!\n-                    do_block = True\n+                    do_block = False\n \n                 if self.cookies:\n                     # Skip if 'cookie' header is explicitly set.\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#4dc48aea6320ab23de1b2f3adecfc68c4013e407", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 2 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 2674 | Contributors (this commit): 8 | Commits (past 90d): 15 | Contributors (cumulative): 8 | DMM Complexity: None\n\nDIFF:\n@@ -24,8 +24,6 @@ __author__ = 'Kenneth Reitz'\n __license__ = 'ISC'\n __copyright__ = 'Copyright 2011 Kenneth Reitz'\n \n-import logging\n-logging.basicConfig()\n \n from api import *\n from exceptions import *\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#fedbafc79b73175b5ec4b75dccf189da426ef134", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 1 | Files Changed: 1 | Hunks: 1 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 2 | Churn Cumulative: 2676 | Contributors (this commit): 8 | Commits (past 90d): 16 | Contributors (cumulative): 8 | DMM Complexity: None\n\nDIFF:\n@@ -18,7 +18,7 @@ This module implements the main Requests system.\n \n \n __title__ = 'requests'\n-__version__ = '0.6.2 (dev)'\n+__version__ = '0.7.0 (dev)'\n __build__ = 0x000602\n __author__ = 'Kenneth Reitz'\n __license__ = 'ISC'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "requests#20c930e48e31916481d6d45bcbb079f7c4670b18", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 18 | Lines Deleted: 261 | Files Changed: 4 | Hunks: 21 | Methods Changed: 12 | Complexity Δ (Sum/Max): -16/0 | Churn Δ: 279 | Churn Cumulative: 4310 | Contributors (this commit): 20 | Commits (past 90d): 169 | Contributors (cumulative): 37 | DMM Complexity: 0.23333333333333334\n\nDIFF:\n@@ -14,7 +14,7 @@ This module implements the Requests API.\n from ._config import get_config\n from .models import Request, Response\n from .status_codes import codes\n-from hooks import setup_hooks, dispatch_hooks\n+from .hooks import dispatch_hooks\n from .utils import cookiejar_from_dict, header_expand\n \n \n@@ -46,7 +46,9 @@ def request(method, url,\n     method = str(method).upper()\n     config = get_config(config)\n \n-    # cookies = cookiejar_from_dict(cookies if cookies is not None else dict())\n+    if cookies is None:\n+        cookies = {}\n+\n     # cookies = cookiejar_from_dict(cookies)\n \n     # Expand header values\n@@ -70,16 +72,14 @@ def request(method, url,\n         _pools=_pools\n     )\n \n-    hooks = setup_hooks(hooks if hooks is not None else dict())\n-\n     # Arguments manipulation hook.\n-    args = dispatch_hooks(hooks['args'], args)\n+    args = dispatch_hooks('args', hooks, args)\n \n     # Create Request object.\n     r = Request(**args)\n \n     # Pre-request hook.\n-    r = dispatch_hooks(hooks['pre_request'], r)\n+    r = dispatch_hooks('pre_request', hooks, r)\n \n     # Only construct the request (for async)\n     if _return_request:\n@@ -90,10 +90,10 @@ def request(method, url,\n \n     # TODO: Add these hooks inline.\n     # Post-request hook.\n-    r = dispatch_hooks(hooks['post_request'], r)\n+    r = dispatch_hooks('post_request', hooks, r)\n \n     # Response manipulation hook.\n-    r.response = dispatch_hooks(hooks['response'], r.response)\n+    r.response = dispatch_hooks('response', hooks, r.response)\n \n     return r.response\n \n\n@@ -1,80 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-requests.config\n-~~~~~~~~~~~~~~~\n-\n-This module provides the Requests settings feature set.\n-\n-\"\"\"\n-\n-class Settings(object):\n-    _singleton = {}\n-\n-    # attributes with defaults\n-    __attrs__ = []\n-\n-    def __init__(self, **kwargs):\n-        super(Settings, self).__init__()\n-\n-        self.__dict__ = self._singleton\n-\n-\n-    def __call__(self, *args, **kwargs):\n-        # new instance of class to call\n-        r = self.__class__()\n-\n-        # cache previous settings for __exit__\n-        r.__cache = self.__dict__.copy()\n-        map(self.__cache.setdefault, self.__attrs__)\n-\n-        # set new settings\n-        self.__dict__.update(*args, **kwargs)\n-\n-        return r\n-\n-\n-    def __enter__(self):\n-        pass\n-\n-\n-    def __exit__(self, *args):\n-\n-        # restore cached copy\n-        self.__dict__.update(self.__cache.copy())\n-        del self.__cache\n-\n-\n-    def __getattribute__(self, key):\n-        if key in object.__getattribute__(self, '__attrs__'):\n-            try:\n-                return object.__getattribute__(self, key)\n-            except AttributeError:\n-                return None\n-        return object.__getattribute__(self, key)\n-\n-\n-settings = Settings()\n-\n-settings.base_headers = {\n-    'User-Agent': 'python-requests.org',\n-    'Accept-Encoding': ', '.join([ 'identity', 'deflate', 'compress', 'gzip' ]),\n-}\n-settings.accept_gzip = True\n-settings.proxies = None\n-settings.verbose = None\n-settings.timeout = None\n-settings.max_redirects = 30\n-settings.decode_unicode = False\n-settings.gracefull_hooks = True\n-\n-#: A dictionary of default hooks to be applied, based on settings.\n-settings.default_hooks = {\n-    'args': list(),\n-    'pre_request': list(),\n-    'post_request': list(),\n-    'response': list()\n-}\n-\n-#: Use socket.setdefaulttimeout() as fallback?\n-settings.timeout_fallback = True\n\n@@ -23,162 +23,19 @@ Available hooks:\n \"\"\"\n \n import warnings\n-from collections import Iterable\n-import config\n-import zlib\n-import bz2\n-from cgi import parse_header\n+import collections\n \n-def setup_hooks(supplied):\n-    \"\"\"Setup a hooks mapping, based on the supplied argument. Eache mapping\n-    value will be list of hooks that will extend the **default_hooks**.\n \n-    :param supplied: a dictionary of hooks. Each value can either be a callable\n-                     or a list of callables.\n-    :type supplied: dict\n-    :returns: a dictionary of hooks that extends the **default_hooks** dictionary.\n-    :rtype: dict\n-    \"\"\"\n+def dispatch_hooks(key, hooks, hook_data):\n+    \"\"\"Dipatches a hook dictionary on a given peice of data.\"\"\"\n \n-    # Copy the default hooks settings.\n-    default = config.settings.default_hooks\n-    dispatching = dict([(k, v[:]) for k, v in default.items()])\n+    hooks = (hooks or {}).get(key, [])\n+    hooks = hooks if isinstance(hooks, collections.Iterable) else [hooks]\n \n-    # I abandoned the idea of a dictionary of sets because sets may not keep\n-    # insertion order, while it may be important. Also, there is no real reason\n-    # to force hooks to run once.\n-    for hooks, values in supplied.items():\n-        hook_list = values if isinstance(values, Iterable) else [values]\n-        dispatching[hooks].extend(hook_list)\n-\n-    # If header is set by config, maybe response is encoded.\n-    if config.settings.base_headers.get('Accept-Encoding', ''):\n-        if not decode_encoding in dispatching['response']:\n-            # It's safer to put decoding as first hook.\n-            dispatching['response'].insert(0, decode_encoding)\n-\n-    if config.settings.decode_unicode:\n-        try:\n-            # Try unicode encoding just after content decoding...\n-            index = dispatching['response'].index(decode_encoding) + 1\n-        except ValueError:\n-            # ... Or as first hook\n-            index = 0\n-        dispatching['response'].insert(index, decode_unicode)\n-\n-    return dispatching\n-\n-def dispatch_hooks(hooks, data):\n-    \"\"\"Dispatches multiple hooks on a given piece of data.\n-\n-    :param key: the hooks group to lookup\n-    :type key: str\n-    :param hooks: the hooks dictionary. The value of each key can be a callable\n-                  object, or a list of callable objects.\n-    :type hooks: dict\n-    :param data: the object on witch the hooks should be applied\n-    :type data: object\n-    \"\"\"\n     for hook in hooks:\n         try:\n-            # hook must be a callable.\n-            data = hook(data)\n-\n+            hook_data = hook(hook_data) or hook_data\n         except Exception, why:\n-\n-            # Letting users to choose a policy may be an idea. It can be as\n-            # simple as \"be gracefull, or not\":\n-            #\n-            # config.settings.gracefull_hooks = True | False\n-            if not config.settings.gracefull_hooks: raise\n-\n             warnings.warn(str(why))\n \n-    return data\n-\n-#: Example response hook that turns a JSON formatted\n-#: :py:class:`requests.models.Response.content` into a dumped data structure::\n-#:\n-#:    try:\n-#:        import json\n-#:    except ImportError:\n-#:        try:\n-#:            import simplejson as json\n-#:        except ImportError:\n-#:            json = False\n-#:\n-#:    if json:\n-#:        def json_content(r):\n-#:            \"\"\"Turns content into a dumped JSON structure.\"\"\"\n-#:            r._content = json.dumps(r.content)\n-#:            return r\n-#:\n-#: Example response hook that turns an XML formatted\n-#: :py:class:`requests.models.Response.content` into an ElementTree::\n-#:\n-#:    try:\n-#:        from lxml import etree\n-#:    except ImportError:\n-#:        try:\n-#:            import xml.etree.cElementTree as etree\n-#:        except ImportError:\n-#:            try:\n-#:                import xml.etree.ElementTree as etree\n-#:            except ImportError:\n-#:                try:\n-#:                    import cElementTree as etree\n-#:                except ImportError:\n-#:                    try:\n-#:                        import elementtree.ElementTree as etree\n-#:                    except ImportError:\n-#:                        etree = False\n-#:\n-#:    if etree:\n-#:        def etree_content(r):\n-#:            \"\"\"Turns content into an ElementTree structure.\"\"\"\n-#:            r._content = etree.fromstring(r.content)\n-#:            return r\n-\n-def decode_unicode(r):\n-    \"\"\"Encode content into unicode string.\n-\n-       :param r: response object\n-       :type r: :py:class:`requests.models.Response`\n-       :returns: the same input object.\n-       :rtype: :py:class:`requests.models.Response`\n-    \"\"\"\n-    content_type, params = parse_header(r.headers['content-type'])\n-    charset = params.get('charset', '').strip(\"'\\\"\")\n-    r._content = unicode(r.content, charset) if charset else unicode(r.content)\n-    return r\n-\n-def decode_encoding(r):\n-    \"\"\"Decode content using Contetn-Encoding header.\n-\n-       :param r: response object\n-       :type r: :py:class:`requests.models.Response`\n-       :returns: the same input object.\n-       :rtype: :py:class:`requests.models.Response`\n-    \"\"\"\n-\n-    # Dictionary of content decoders.\n-    decode = {\n-        # No decoding applied.\n-        'identity': lambda content: content,\n-        # Decode Response content compressed with deflate.\n-        'deflate': lambda content: zlib.decompress(content),\n-        # Decode Response content compressed with gzip.\n-        'gzip': lambda content: zlib.decompress(content, 16+zlib.MAX_WBITS),\n-        # Decode Response content compressed with bz2.\n-        # Not a standard Content-Encoding value, but..\n-        'bzip2': lambda content: bz2.decompress(content),\n-    }\n-    # Decode Response content compressed with compress.\n-    # If I understood zlib...\n-    decode['compress'] = decode['deflate']\n-\n-    # Apply decoding only if the header is set.\n-    encoding = r.headers['content-encoding']\n-    if encoding:\n-        r._content = decode[encoding](r.content)\n-    return r\n+    return hook_data\n\n@@ -453,21 +453,14 @@ class Response(object):\n         (if available).\n         \"\"\"\n \n-        if self._content is None:\n-            # Read the contents.\n-            self._content = self.fo.read()\n+        if self._content is not None:\n+            return self._content\n \n         if self._content_consumed:\n             raise RuntimeError(\n                 'The content for this response was already consumed')\n-        # # Decode GZip'd content.\n-        # if 'gzip' in self.headers.get('content-encoding', ''):\n-        #     try:\n-        #         self._content = decode_gzip(self._content)\n-        #     except zlib.error:\n-        #         pass\n \n-        self._content = self.fo.read()\n+        # Read the contents.\n         self._content = self.raw.read() or self.raw.data\n \n         # Decode GZip'd content.\n@@ -477,22 +470,9 @@ class Response(object):\n             except zlib.error:\n                 pass\n \n-        # Decode unicode content.\n-        if settings.decode_unicode:\n-            self._content = get_unicode_from_response(self)\n-        # Decode GZip'd content.\n-        if 'gzip' in self.headers.get('content-encoding', ''):\n-            try:\n-                self._content = decode_gzip(self._content)\n-            except zlib.error:\n-                pass\n-\n         # Decode unicode content.\n         if self.config.get('decode_unicode'):\n             self._content = get_unicode_from_response(self)\n-        # # Decode unicode content.\n-        # if settings.decode_unicode:\n-        #     self._content = get_unicode_from_response(self)\n \n         self._content_consumed = True\n         return self._content\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
