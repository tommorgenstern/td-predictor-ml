{"custom_id": "flask#3ac4ec670c881668aaedb2c3937bae5e10984988", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 11 | Lines Deleted: 19 | Files Changed: 1 | Hunks: 4 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 30 | Churn Cumulative: 295 | Contributors (this commit): 2 | Commits (past 90d): 6 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -172,35 +172,27 @@ htmlhelp_basename = 'Flaskdoc'\n \n # -- Options for LaTeX output --------------------------------------------------\n \n-# The paper size ('letter' or 'a4').\n-#latex_paper_size = 'letter'\n-\n-# The font size ('10pt', '11pt' or '12pt').\n-#latex_font_size = '10pt'\n-\n # Grouping the document tree into LaTeX files. List of tuples\n # (source start file, target name, title, author, documentclass [howto/manual]).\n latex_documents = [\n-  ('index', 'Flask.tex', u'Flask Documentation',\n+  ('latexindex', 'Flask.tex', u'Flask Documentation',\n    u'Armin Ronacher', 'manual'),\n ]\n \n-# The name of an image file (relative to this directory) to place at the top of\n-# the title page.\n-#latex_logo = None\n-\n-# For \"manual\" documents, if this is true, then toplevel headings are parts,\n-# not chapters.\n-#latex_use_parts = False\n-\n-# Additional stuff for the LaTeX preamble.\n-#latex_preamble = ''\n-\n # Documents to append as an appendix to all manuals.\n #latex_appendices = []\n \n # If false, no module index is generated.\n-#latex_use_modindex = True\n+latex_use_modindex = False\n+\n+latex_elements = {\n+    'fontpkg':      r'\\usepackage{mathpazo}',\n+    'papersize':    'a4paper',\n+    'pointsize':    '12pt',\n+    'preamble':     r'\\usepackage{flaskstyle}'\n+}\n+\n+latex_additional_files = ['flaskstyle.sty', 'logo.pdf']\n \n \n # -- Options for Epub output ---------------------------------------------------\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#36717b02731ad7d86ba8effbe27e70405e48cd9b", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 53 | Lines Deleted: 3 | Files Changed: 2 | Hunks: 8 | Methods Changed: 6 | Complexity Δ (Sum/Max): 5/3 | Churn Δ: 56 | Churn Cumulative: 2109 | Contributors (this commit): 6 | Commits (past 90d): 73 | Contributors (cumulative): 10 | DMM Complexity: 1.0\n\nDIFF:\n@@ -13,6 +13,7 @@ from __future__ import with_statement\n import os\n import sys\n import types\n+from datetime import datetime, timedelta\n \n from jinja2 import Environment, PackageLoader, FileSystemLoader\n from werkzeug import Request as RequestBase, Response as ResponseBase, \\\n@@ -86,7 +87,20 @@ class _RequestGlobals(object):\n     pass\n \n \n-class _NullSession(SecureCookie):\n+class Session(SecureCookie):\n+    \"\"\"Expands the session for support for switching between permanent\n+    and non-permanent sessions.\n+    \"\"\"\n+\n+    def _get_permanent(self):\n+        return self.get('_permanent', False)\n+    def _set_permanent(self, value):\n+        self['_permanent'] = bool(value)\n+    permanent = property(_get_permanent, _set_permanent)\n+    del _get_permanent, _set_permanent\n+\n+\n+class _NullSession(Session):\n     \"\"\"Class used to generate nicer error messages if sessions are not\n     available.  Will still allow read-only access to the empty session\n     but fail on setting.\n@@ -317,6 +331,11 @@ class Flask(object):\n     #: The secure cookie uses this for the name of the session cookie\n     session_cookie_name = 'session'\n \n+    #: A :class:`~datetime.timedelta` which is used to set the expiration\n+    #: date of a permanent session.  The default is 31 days which makes a\n+    #: permanent session survive for roughly one month.\n+    permanent_session_lifetime = timedelta(days=31)\n+\n     #: options that are passed directly to the Jinja2 environment\n     jinja_options = ImmutableDict(\n         autoescape=True,\n@@ -493,7 +512,7 @@ class Flask(object):\n         \"\"\"\n         key = self.secret_key\n         if key is not None:\n-            return SecureCookie.load_cookie(request, self.session_cookie_name,\n+            return Session.load_cookie(request, self.session_cookie_name,\n                                        secret_key=key)\n \n     def save_session(self, session, response):\n@@ -505,7 +524,11 @@ class Flask(object):\n                         object)\n         :param response: an instance of :attr:`response_class`\n         \"\"\"\n-        session.save_cookie(response, self.session_cookie_name)\n+        expires = None\n+        if session.permanent:\n+            expires = datetime.utcnow() + self.permanent_session_lifetime\n+        session.save_cookie(response, self.session_cookie_name,\n+                            expires=expires, httponly=True)\n \n     def add_url_rule(self, rule, endpoint, view_func=None, **options):\n         \"\"\"Connects a URL rule.  Works exactly like the :meth:`route`\n\n@@ -11,11 +11,14 @@\n \"\"\"\n from __future__ import with_statement\n import os\n+import re\n import sys\n import flask\n import unittest\n import tempfile\n import warnings\n+from datetime import datetime\n+from werkzeug import parse_date\n \n \n example_path = os.path.join(os.path.dirname(__file__), '..', 'examples')\n@@ -118,6 +121,30 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n             expect_exception(flask.session.__setitem__, 'foo', 42)\n             expect_exception(flask.session.pop, 'foo')\n \n+    def test_session_expiration(self):\n+        permanent = True\n+        app = flask.Flask(__name__)\n+        app.secret_key = 'testkey'\n+        @app.route('/')\n+        def index():\n+            flask.session['test'] = 42\n+            flask.session.permanent = permanent\n+            return ''\n+        rv = app.test_client().get('/')\n+        assert 'set-cookie' in rv.headers\n+        match = re.search(r'\\bexpires=([^;]+)', rv.headers['set-cookie'])\n+        expires = parse_date(match.group())\n+        expected = datetime.utcnow() + app.permanent_session_lifetime\n+        assert expires.year == expected.year\n+        assert expires.month == expected.month\n+        assert expires.day == expected.day\n+\n+        permanent = False\n+        rv = app.test_client().get('/')\n+        assert 'set-cookie' in rv.headers\n+        match = re.search(r'\\bexpires=([^;]+)', rv.headers['set-cookie'])\n+        assert match is None\n+\n     def test_flashes(self):\n         app = flask.Flask(__name__)\n         app.secret_key = 'testkey'\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#f1603d33f266ab24eda604f76632fa604b91e3f9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 4 | Lines Deleted: 0 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 4 | Churn Cumulative: 1607 | Contributors (this commit): 6 | Commits (past 90d): 53 | Contributors (cumulative): 6 | DMM Complexity: None\n\nDIFF:\n@@ -145,6 +145,10 @@ class _RequestContext(object):\n \n def url_for(endpoint, **values):\n     \"\"\"Generates a URL to the given endpoint with the method provided.\n+    Variable arguments that are unknown to the target endpoint are appended\n+    to the generated URL as query arguments.\n+\n+    For more information, head over to the :ref:`Quickstart <url-building>`.\n \n     :param endpoint: the endpoint of the URL (name of the function)\n     :param values: the variable arguments of the URL rule\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#75461c1467bbb2d83ee787bb13f4a338a4b8ad3e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 6 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 3 | Methods Changed: 2 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 7 | Churn Cumulative: 2120 | Contributors (this commit): 6 | Commits (past 90d): 76 | Contributors (cumulative): 10 | DMM Complexity: 1.0\n\nDIFF:\n@@ -152,8 +152,11 @@ def url_for(endpoint, **values):\n \n     :param endpoint: the endpoint of the URL (name of the function)\n     :param values: the variable arguments of the URL rule\n+    :param _external: if set to `True`, an absolute URL is generated.\n     \"\"\"\n-    return _request_ctx_stack.top.url_adapter.build(endpoint, values)\n+    external = values.pop('_external', False)\n+    return _request_ctx_stack.top.url_adapter.build(endpoint, values,\n+                                                    force_external=external)\n \n \n def get_template_attribute(template_name, attribute):\n\n@@ -227,6 +227,8 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n             pass\n         with app.test_request_context():\n             assert flask.url_for('hello', name='test x') == '/hello/test%20x'\n+            assert flask.url_for('hello', name='test x', _external=True) \\\n+                == 'http://localhost/hello/test%20x'\n \n     def test_custom_converters(self):\n         from werkzeug.routing import BaseConverter\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#9248a7baca5bc616a60f9b63b525e872fbfddef2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 1 | Lines Deleted: 4 | Files Changed: 1 | Hunks: 1 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 5 | Churn Cumulative: 1617 | Contributors (this commit): 6 | Commits (past 90d): 55 | Contributors (cumulative): 6 | DMM Complexity: 0.0\n\nDIFF:\n@@ -752,10 +752,7 @@ class Flask(object):\n         :param rv: the return value from the view function\n         \"\"\"\n         if rv is None:\n-            from warnings import warn\n-            warn(Warning('View function did not return a response'),\n-                 stacklevel=2)\n-            return u''\n+            raise ValueError('View function did not return a response')\n         if isinstance(rv, self.response_class):\n             return rv\n         if isinstance(rv, basestring):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#dffb3d091c0e42b7254fe88218811c24c0054f7e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 3 | Lines Deleted: 4 | Files Changed: 2 | Hunks: 4 | Methods Changed: 1 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 7 | Churn Cumulative: 2132 | Contributors (this commit): 6 | Commits (past 90d): 79 | Contributors (cumulative): 10 | DMM Complexity: None\n\nDIFF:\n@@ -12,7 +12,6 @@\n from __future__ import with_statement\n import os\n import sys\n-import types\n from datetime import datetime, timedelta\n \n from jinja2 import Environment, PackageLoader, FileSystemLoader\n\n@@ -255,17 +255,17 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n                 == '/static/index.html'\n \n     def test_none_response(self):\n-        warnings.filterwarnings('error', 'View function did not return')\n         app = flask.Flask(__name__)\n         @app.route('/')\n         def test():\n             return None\n         try:\n             app.test_client().get('/')\n-        except Warning:\n+        except ValueError, e:\n+            assert str(e) == 'View function did not return a response'\n             pass\n         else:\n-            assert \"Expected warning\"\n+            assert \"Expected ValueError\"\n \n \n class JSONTestCase(unittest.TestCase):\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#67fc46526234653b0a519e9f1e8a05a2c40c80f8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 7 | Files Changed: 2 | Hunks: 10 | Methods Changed: 6 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 17 | Churn Cumulative: 2149 | Contributors (this commit): 6 | Commits (past 90d): 81 | Contributors (cumulative): 10 | DMM Complexity: 1.0\n\nDIFF:\n@@ -87,14 +87,16 @@ class _RequestGlobals(object):\n \n \n class Session(SecureCookie):\n-    \"\"\"Expands the session for support for switching between permanent\n+    \"\"\"Expands the session with support for switching between permanent\n     and non-permanent sessions.\n     \"\"\"\n \n     def _get_permanent(self):\n         return self.get('_permanent', False)\n+\n     def _set_permanent(self, value):\n         self['_permanent'] = bool(value)\n+\n     permanent = property(_get_permanent, _set_permanent)\n     del _get_permanent, _set_permanent\n \n@@ -391,7 +393,7 @@ class Flask(object):\n         #: decorator.\n         self.after_request_funcs = []\n \n-        #: a list of functions that are called without arguments\n+        #: a list of functions that are called without argument\n         #: to populate the template context.  Each returns a dictionary\n         #: that the template context is updated with.\n         #: To register a function here, use the :meth:`context_processor`\n\n@@ -16,7 +16,6 @@ import sys\n import flask\n import unittest\n import tempfile\n-import warnings\n from datetime import datetime\n from werkzeug import parse_date\n \n@@ -191,7 +190,7 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n             flask.abort(404)\n         @app.route('/error')\n         def error():\n-            1/0\n+            1 // 0\n         c = app.test_client()\n         rv = c.get('/')\n         assert rv.status_code == 404\n@@ -236,7 +235,8 @@ class BasicFunctionalityTestCase(unittest.TestCase):\n             def to_python(self, value):\n                 return value.split(',')\n             def to_url(self, value):\n-                return ','.join(super(ListConverter, self).to_url(x) for x in value)\n+                base_to_url = super(ListConverter, self).to_url\n+                return ','.join(base_to_url(x) for x in value)\n         app = flask.Flask(__name__)\n         app.url_map.converters['list'] = ListConverter\n         @app.route('/<list:args>')\n@@ -297,10 +297,11 @@ class JSONTestCase(unittest.TestCase):\n \n     def test_template_escaping(self):\n         app = flask.Flask(__name__)\n+        render = flask.render_template_string\n         with app.test_request_context():\n-            rv = flask.render_template_string('{{ \"</script>\"|tojson|safe }}')\n+            rv = render('{{ \"</script>\"|tojson|safe }}')\n             assert rv == '\"<\\\\/script>\"'\n-            rv = flask.render_template_string('{{ \"<\\0/script>\"|tojson|safe }}')\n+            rv = render('{{ \"<\\0/script>\"|tojson|safe }}')\n             assert rv == '\"<\\\\u0000\\\\/script>\"'\n \n \n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#bc0c0559e384dc88441775a3907487f4a2b515b4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 273 | Lines Deleted: 0 | Files Changed: 2 | Hunks: 2 | Methods Changed: 20 | Complexity Δ (Sum/Max): 41/24 | Churn Δ: 273 | Churn Cumulative: 273 | Contributors (this commit): 1 | Commits (past 90d): 2 | Contributors (cumulative): 2 | DMM Complexity: 0.6694214876033058\n\nDIFF:\n@@ -0,0 +1,165 @@\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+    OpenID Example\n+    ~~~~~~~~~~~~~~\n+\n+    This simple application shows how OpenID can be used in an application.\n+\n+    Dependencies:\n+\n+    -   python-openid\n+    -   SQLAlchemy\n+\n+    :copyright: (c) 2010 by Armin Ronacher.\n+    :license: BSD, see LICENSE for more details.\n+\"\"\"\n+from flask import Flask, render_template, request, g, session, flash, \\\n+     redirect, url_for, abort\n+from simpleopenid import SimpleOpenID\n+\n+from sqlalchemy import create_engine, Column, Integer, String\n+from sqlalchemy.orm import scoped_session, sessionmaker\n+from sqlalchemy.ext.declarative import declarative_base\n+\n+# configuration\n+DATABASE_URI = 'sqlite:////tmp/openidexample.db'\n+OPENID_FS_PATH = '/tmp/openidexample-store'\n+SECRET_KEY = 'development key'\n+DEBUG = True\n+\n+# setup flask\n+app = Flask(__name__)\n+app.debug = DEBUG\n+app.secret_key = SECRET_KEY\n+\n+# setup simpleopenid\n+oid = SimpleOpenID(OPENID_FS_PATH)\n+\n+# setup sqlalchemy\n+engine = create_engine(DATABASE_URI)\n+db_session = scoped_session(sessionmaker(autocommit=False,\n+                                         autoflush=False,\n+                                         bind=engine))\n+Base = declarative_base()\n+Base.query = db_session.query_property()\n+\n+def init_db():\n+    Base.metadata.create_all(bind=engine)\n+\n+\n+class User(Base):\n+    __tablename__ = 'users'\n+    id = Column(Integer, primary_key=True)\n+    name = Column(String(60))\n+    email = Column(String(200))\n+    openid = Column(String(200))\n+\n+    def __init__(self, name, email, openid):\n+        self.name = name\n+        self.email = email\n+        self.openid = openid\n+\n+\n+@app.before_request\n+def before_request():\n+    g.user = None\n+    if 'openid' in session:\n+        g.user = User.query.filter_by(openid=session['openid']).first()\n+\n+\n+@app.route('/')\n+def index():\n+    return render_template('index.html')\n+\n+\n+@app.route('/login', methods=['GET', 'POST'])\n+@oid.loginhandler\n+def login():\n+    \"\"\"Does the login via OpenID.  Has to call into `oid.try_login`\n+    to start the OpenID machinery.\n+    \"\"\"\n+    # if we are already logged in, go back to were we came from\n+    if g.user is not None:\n+        return redirect(oid.get_next_url())\n+    if request.method == 'POST':\n+        openid = request.form.get('openid')\n+        if openid:\n+            return oid.try_login(openid)\n+    return render_template('login.html', next_url=oid.get_next_url())\n+\n+\n+@oid.after_login\n+def create_or_login(identity_url):\n+    \"\"\"This is called when login with OpenID succeeded and it's not\n+    necessary to figure out if this is the users's first login or not.\n+    This function has to redirect otherwise the user will be presented\n+    with a terrible URL which we certainly don't want.\n+    \"\"\"\n+    session['openid'] = identity_url\n+    user = User.query.filter_by(openid=identity_url).first()\n+    if user is not None:\n+        flash(u'Successfully signed in')\n+        g.user = user\n+        return redirect(oid.get_next_url())\n+    return redirect(url_for('create_profile', next=oid.get_next_url()))\n+\n+\n+@app.route('/create-profile', methods=['GET', 'POST'])\n+def create_profile():\n+    \"\"\"If this is the user's first login, the create_or_login function\n+    will redirect here so that the user can set up his profile.\n+    \"\"\"\n+    if g.user is not None or 'openid' not in session:\n+        return redirect(url_for('index'))\n+    if request.method == 'POST':\n+        name = request.form['name']\n+        email = request.form['email']\n+        if not name:\n+            flash(u'Error: you have to provide a name')\n+        elif '@' not in email:\n+            flash(u'Error: you have to enter a valid email address')\n+        else:\n+            flash(u'Profile successfully created')\n+            db_session.add(User(name, email, session['openid']))\n+            db_session.commit()\n+            return redirect(oid.get_next_url())\n+    return render_template('create_profile.html', next_url=oid.get_next_url())\n+\n+\n+@app.route('/profile', methods=['GET', 'POST'])\n+def edit_profile():\n+    \"\"\"Updates a profile\"\"\"\n+    if g.user is None:\n+        abort(401)\n+    form = dict(name=g.user.name, email=g.user.email)\n+    if request.method == 'POST':\n+        if 'delete' in request.form:\n+            db_session.delete(g.user)\n+            db_session.commit()\n+            session['openid'] = None\n+            flash(u'Profile deleted')\n+            return redirect(url_for('index'))\n+        form['name'] = request.form['name']\n+        form['email'] = request.form['email']\n+        if not form['name']:\n+            flash(u'Error: you have to provide a name')\n+        elif '@' not in form['email']:\n+            flash(u'Error: you have to enter a valid email address')\n+        else:\n+            flash(u'Profile successfully created')\n+            g.user.name = form['name']\n+            g.user.email = form['email']\n+            db_session.commit()\n+            return redirect(url_for('edit_profile'))\n+    return render_template('edit_profile.html', form=form)\n+\n+\n+@app.route('/logout')\n+def logout():\n+    session.pop('openid', None)\n+    flash(u'You were signed out')\n+    return redirect(oid.get_next_url())\n+\n+\n+if __name__ == '__main__':\n+    app.run()\n\n@@ -0,0 +1,108 @@\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+    simpleopenid\n+    ~~~~~~~~~~~~\n+\n+    Tiny wrapper around python-openid to make working with the basic\n+    API in a flask application easier.  Adapt this code for your own\n+    project if necessary.\n+\n+    :copyright: (c) 2010 by Armin Ronacher.\n+    :license: BSD, see LICENSE for more details.\n+\"\"\"\n+from functools import wraps\n+\n+from flask import request, session, flash, redirect\n+from werkzeug import url_quote\n+\n+from openid.association import Association\n+from openid.store.interface import OpenIDStore\n+from openid.store.filestore import FileOpenIDStore\n+from openid.consumer.consumer import Consumer, SUCCESS, CANCEL\n+from openid.consumer import discover\n+from openid.store import nonce\n+\n+# python-openid is a really stupid library in that regard, we have\n+# to disable logging by monkey patching\n+from openid import oidutil\n+oidutil.log = lambda *a, **kw: None\n+\n+\n+class SimpleOpenID(object):\n+    \"\"\"Simple helper class for OpenID auth.\"\"\"\n+\n+    def __init__(self, store_path):\n+        self.store_path = store_path\n+        self.after_login_func = None\n+\n+    def create_store(self):\n+        \"\"\"Creates the filesystem store\"\"\"\n+        return FileOpenIDStore(self.store_path)\n+\n+    def signal_error(self, msg):\n+        \"\"\"Signals an error.  It does this by flashing a message\"\"\"\n+        flash(u'Error: ' + msg)\n+\n+    def get_next_url(self):\n+        \"\"\"Return the URL where we want to redirect to.\"\"\"\n+        return request.values.get('next') or \\\n+               request.referrer or \\\n+               request.url_root\n+\n+    def get_current_url(self):\n+        \"\"\"the current URL + next\"\"\"\n+        return request.base_url + '?next=' + url_quote(self.get_next_url())\n+\n+    def get_success_url(self):\n+        \"\"\"Return the success URL\"\"\"\n+        return self.get_current_url() + '&openid_complete=yes'\n+\n+    def errorhandler(f):\n+        \"\"\"Called if an error occours with the message.  By default\n+        ``'Error: message'`` is flashed.\n+        \"\"\"\n+        self.signal_error = f\n+        return f\n+\n+    def after_login(self, f):\n+        \"\"\"This function will be called after login.  It must redirect to\n+        a different place and remember the user somewhere.  The session\n+        is not modified by SimpleOpenID.\n+        \"\"\"\n+        self.after_login_func = f\n+        return f\n+\n+    def loginhandler(self, f):\n+        \"\"\"Marks a function as login handler.  This decorator injects some\n+        more OpenID required logic.\n+        \"\"\"\n+        self.login_endpoint = f.__name__\n+        @wraps(f)\n+        def decorated(*args, **kwargs):\n+            if request.args.get('openid_complete') != u'yes':\n+                return f(*args, **kwargs)\n+            consumer = Consumer(session, self.create_store())\n+            openid_response = consumer.complete(request.args.to_dict(),\n+                                                self.get_current_url())\n+            if openid_response.status == SUCCESS:\n+                return self.after_login_func(openid_response.identity_url)\n+            elif openid_response.status == CANCEL:\n+                self.signal_error(u'The request was cancelled')\n+                return redirect(self.get_current_url())\n+            self.signal_error(u'OpenID authentication error')\n+            return redirect(self.get_current_url())\n+        return decorated\n+\n+    def try_login(self, identity_url):\n+        \"\"\"This tries to login with the given identity URL.  This function\n+        must be called from the login_handler.\n+        \"\"\"\n+        try:\n+            consumer = Consumer(session, self.create_store())\n+            auth_request = consumer.begin(identity_url)\n+        except discover.DiscoveryFailure:\n+            self.signal_error(u'The OpenID was invalid')\n+            return redirect(self.get_current_url())\n+        trust_root = request.host_url\n+        return redirect(auth_request.redirectURL(request.host_url,\n+                                                 self.get_success_url()))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#a921aef6c47cecbacef5173f03c07c52e6bc8fea", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 10 | Lines Deleted: 1 | Files Changed: 2 | Hunks: 2 | Methods Changed: 4 | Complexity Δ (Sum/Max): 45/31 | Churn Δ: 11 | Churn Cumulative: 2160 | Contributors (this commit): 6 | Commits (past 90d): 83 | Contributors (cumulative): 10 | DMM Complexity: 1.0\n\nDIFF:\n@@ -448,7 +448,7 @@ class Module(_PackageBoundObject):\n         \"\"\"\n         def register_rule(state):\n             the_rule = rule\n-            if self.url_prefix:\n+            if state.url_prefix:\n                 the_rule = state.url_prefix + rule\n             state.app.add_url_rule(the_rule, '%s.%s' % (self.name, endpoint),\n                                    view_func, **options)\n\n@@ -441,6 +441,15 @@ class ModuleTestCase(unittest.TestCase):\n         assert catched == ['before-app', 'before-admin',\n                            'after-admin', 'after-app']\n \n+    def test_late_binding(self):\n+        app = flask.Flask(__name__)\n+        admin = flask.Module(__name__, 'admin')\n+        @admin.route('/')\n+        def index():\n+            return '42'\n+        app.register_module(admin, url_prefix='/admin')\n+        assert app.test_client().get('/admin/').data == '42'\n+\n \n def suite():\n     from minitwit_tests import MiniTwitTestCase\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#745638e774063de206aae930df71789de13e7c73", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 41 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 4 | Methods Changed: 9 | Complexity Δ (Sum/Max): 8/6 | Churn Δ: 43 | Churn Cumulative: 2203 | Contributors (this commit): 6 | Commits (past 90d): 85 | Contributors (cumulative): 10 | DMM Complexity: 1.0\n\nDIFF:\n@@ -465,7 +465,7 @@ class Module(_PackageBoundObject):\n \n     def before_app_request(self, f):\n         \"\"\"Like :meth:`Flask.before_request`.  Such a function is executed\n-        before each request.\n+        before each request, even if outside of a module.\n         \"\"\"\n         self._record(lambda s: s.app.before_request_funcs\n             .setdefault(None, []).append(f))\n@@ -482,12 +482,28 @@ class Module(_PackageBoundObject):\n \n     def after_app_request(self, f):\n         \"\"\"Like :meth:`Flask.after_request` but for a module.  Such a function\n-        is executed after each request.\n+        is executed after each request, even if outside of the module.\n         \"\"\"\n         self._record(lambda s: s.app.after_request_funcs\n             .setdefault(None, []).append(f))\n         return f\n \n+    def context_processor(self, f):\n+        \"\"\"Like :meth:`Flask.context_processor` but for a modul.  This\n+        function is only executed for requests handled by a module.\n+        \"\"\"\n+        self._record(lambda s: s.app.template_context_processors\n+            .setdefault(self.name, []).append(f))\n+        return f\n+\n+    def app_context_processor(self, f):\n+        \"\"\"Like :meth:`Flask.context_processor` but for a module.  Such a\n+        function is executed each request, even if outside of the module.\n+        \"\"\"\n+        self._record(lambda s: s.app.template_context_processors\n+            .setdefault(None, []).append(f))\n+        return f\n+\n     def _record(self, func):\n         self._register_events.append(func)\n \n\n@@ -441,6 +441,29 @@ class ModuleTestCase(unittest.TestCase):\n         assert catched == ['before-app', 'before-admin',\n                            'after-admin', 'after-app']\n \n+    def test_context_processors(self):\n+        app = flask.Flask(__name__)\n+        admin = flask.Module(__name__, 'admin', url_prefix='/admin')\n+        @app.context_processor\n+        def inject_all_regualr():\n+            return {'a': 1}\n+        @admin.context_processor\n+        def inject_admin():\n+            return {'b': 2}\n+        @admin.app_context_processor\n+        def inject_all_module():\n+            return {'c': 3}\n+        @app.route('/')\n+        def index():\n+            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n+        @admin.route('/')\n+        def index():\n+            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')\n+        app.register_module(admin)\n+        c = app.test_client()\n+        assert c.get('/').data == '13'\n+        assert c.get('/admin/').data == '123'\n+\n     def test_late_binding(self):\n         app = flask.Flask(__name__)\n         admin = flask.Module(__name__, 'admin')\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#da8f88a22eab8195e48fa4ef63c6a3195c860eb0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 0 | Lines Deleted: 273 | Files Changed: 2 | Hunks: 2 | Methods Changed: 20 | Complexity Δ (Sum/Max): -41/0 | Churn Δ: 273 | Churn Cumulative: 546 | Contributors (this commit): 1 | Commits (past 90d): 4 | Contributors (cumulative): 2 | DMM Complexity: 0.3305785123966942\n\nDIFF:\n@@ -1,165 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\"\"\"\n-    OpenID Example\n-    ~~~~~~~~~~~~~~\n-\n-    This simple application shows how OpenID can be used in an application.\n-\n-    Dependencies:\n-\n-    -   python-openid\n-    -   SQLAlchemy\n-\n-    :copyright: (c) 2010 by Armin Ronacher.\n-    :license: BSD, see LICENSE for more details.\n-\"\"\"\n-from flask import Flask, render_template, request, g, session, flash, \\\n-     redirect, url_for, abort\n-from simpleopenid import SimpleOpenID\n-\n-from sqlalchemy import create_engine, Column, Integer, String\n-from sqlalchemy.orm import scoped_session, sessionmaker\n-from sqlalchemy.ext.declarative import declarative_base\n-\n-# configuration\n-DATABASE_URI = 'sqlite:////tmp/openidexample.db'\n-OPENID_FS_PATH = '/tmp/openidexample-store'\n-SECRET_KEY = 'development key'\n-DEBUG = True\n-\n-# setup flask\n-app = Flask(__name__)\n-app.debug = DEBUG\n-app.secret_key = SECRET_KEY\n-\n-# setup simpleopenid\n-oid = SimpleOpenID(OPENID_FS_PATH)\n-\n-# setup sqlalchemy\n-engine = create_engine(DATABASE_URI)\n-db_session = scoped_session(sessionmaker(autocommit=False,\n-                                         autoflush=False,\n-                                         bind=engine))\n-Base = declarative_base()\n-Base.query = db_session.query_property()\n-\n-def init_db():\n-    Base.metadata.create_all(bind=engine)\n-\n-\n-class User(Base):\n-    __tablename__ = 'users'\n-    id = Column(Integer, primary_key=True)\n-    name = Column(String(60))\n-    email = Column(String(200))\n-    openid = Column(String(200))\n-\n-    def __init__(self, name, email, openid):\n-        self.name = name\n-        self.email = email\n-        self.openid = openid\n-\n-\n-@app.before_request\n-def before_request():\n-    g.user = None\n-    if 'openid' in session:\n-        g.user = User.query.filter_by(openid=session['openid']).first()\n-\n-\n-@app.route('/')\n-def index():\n-    return render_template('index.html')\n-\n-\n-@app.route('/login', methods=['GET', 'POST'])\n-@oid.loginhandler\n-def login():\n-    \"\"\"Does the login via OpenID.  Has to call into `oid.try_login`\n-    to start the OpenID machinery.\n-    \"\"\"\n-    # if we are already logged in, go back to were we came from\n-    if g.user is not None:\n-        return redirect(oid.get_next_url())\n-    if request.method == 'POST':\n-        openid = request.form.get('openid')\n-        if openid:\n-            return oid.try_login(openid)\n-    return render_template('login.html', next_url=oid.get_next_url())\n-\n-\n-@oid.after_login\n-def create_or_login(identity_url):\n-    \"\"\"This is called when login with OpenID succeeded and it's not\n-    necessary to figure out if this is the users's first login or not.\n-    This function has to redirect otherwise the user will be presented\n-    with a terrible URL which we certainly don't want.\n-    \"\"\"\n-    session['openid'] = identity_url\n-    user = User.query.filter_by(openid=identity_url).first()\n-    if user is not None:\n-        flash(u'Successfully signed in')\n-        g.user = user\n-        return redirect(oid.get_next_url())\n-    return redirect(url_for('create_profile', next=oid.get_next_url()))\n-\n-\n-@app.route('/create-profile', methods=['GET', 'POST'])\n-def create_profile():\n-    \"\"\"If this is the user's first login, the create_or_login function\n-    will redirect here so that the user can set up his profile.\n-    \"\"\"\n-    if g.user is not None or 'openid' not in session:\n-        return redirect(url_for('index'))\n-    if request.method == 'POST':\n-        name = request.form['name']\n-        email = request.form['email']\n-        if not name:\n-            flash(u'Error: you have to provide a name')\n-        elif '@' not in email:\n-            flash(u'Error: you have to enter a valid email address')\n-        else:\n-            flash(u'Profile successfully created')\n-            db_session.add(User(name, email, session['openid']))\n-            db_session.commit()\n-            return redirect(oid.get_next_url())\n-    return render_template('create_profile.html', next_url=oid.get_next_url())\n-\n-\n-@app.route('/profile', methods=['GET', 'POST'])\n-def edit_profile():\n-    \"\"\"Updates a profile\"\"\"\n-    if g.user is None:\n-        abort(401)\n-    form = dict(name=g.user.name, email=g.user.email)\n-    if request.method == 'POST':\n-        if 'delete' in request.form:\n-            db_session.delete(g.user)\n-            db_session.commit()\n-            session['openid'] = None\n-            flash(u'Profile deleted')\n-            return redirect(url_for('index'))\n-        form['name'] = request.form['name']\n-        form['email'] = request.form['email']\n-        if not form['name']:\n-            flash(u'Error: you have to provide a name')\n-        elif '@' not in form['email']:\n-            flash(u'Error: you have to enter a valid email address')\n-        else:\n-            flash(u'Profile successfully created')\n-            g.user.name = form['name']\n-            g.user.email = form['email']\n-            db_session.commit()\n-            return redirect(url_for('edit_profile'))\n-    return render_template('edit_profile.html', form=form)\n-\n-\n-@app.route('/logout')\n-def logout():\n-    session.pop('openid', None)\n-    flash(u'You were signed out')\n-    return redirect(oid.get_next_url())\n-\n-\n-if __name__ == '__main__':\n-    app.run()\n\n@@ -1,108 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\"\"\"\n-    simpleopenid\n-    ~~~~~~~~~~~~\n-\n-    Tiny wrapper around python-openid to make working with the basic\n-    API in a flask application easier.  Adapt this code for your own\n-    project if necessary.\n-\n-    :copyright: (c) 2010 by Armin Ronacher.\n-    :license: BSD, see LICENSE for more details.\n-\"\"\"\n-from functools import wraps\n-\n-from flask import request, session, flash, redirect\n-from werkzeug import url_quote\n-\n-from openid.association import Association\n-from openid.store.interface import OpenIDStore\n-from openid.store.filestore import FileOpenIDStore\n-from openid.consumer.consumer import Consumer, SUCCESS, CANCEL\n-from openid.consumer import discover\n-from openid.store import nonce\n-\n-# python-openid is a really stupid library in that regard, we have\n-# to disable logging by monkey patching\n-from openid import oidutil\n-oidutil.log = lambda *a, **kw: None\n-\n-\n-class SimpleOpenID(object):\n-    \"\"\"Simple helper class for OpenID auth.\"\"\"\n-\n-    def __init__(self, store_path):\n-        self.store_path = store_path\n-        self.after_login_func = None\n-\n-    def create_store(self):\n-        \"\"\"Creates the filesystem store\"\"\"\n-        return FileOpenIDStore(self.store_path)\n-\n-    def signal_error(self, msg):\n-        \"\"\"Signals an error.  It does this by flashing a message\"\"\"\n-        flash(u'Error: ' + msg)\n-\n-    def get_next_url(self):\n-        \"\"\"Return the URL where we want to redirect to.\"\"\"\n-        return request.values.get('next') or \\\n-               request.referrer or \\\n-               request.url_root\n-\n-    def get_current_url(self):\n-        \"\"\"the current URL + next\"\"\"\n-        return request.base_url + '?next=' + url_quote(self.get_next_url())\n-\n-    def get_success_url(self):\n-        \"\"\"Return the success URL\"\"\"\n-        return self.get_current_url() + '&openid_complete=yes'\n-\n-    def errorhandler(f):\n-        \"\"\"Called if an error occours with the message.  By default\n-        ``'Error: message'`` is flashed.\n-        \"\"\"\n-        self.signal_error = f\n-        return f\n-\n-    def after_login(self, f):\n-        \"\"\"This function will be called after login.  It must redirect to\n-        a different place and remember the user somewhere.  The session\n-        is not modified by SimpleOpenID.\n-        \"\"\"\n-        self.after_login_func = f\n-        return f\n-\n-    def loginhandler(self, f):\n-        \"\"\"Marks a function as login handler.  This decorator injects some\n-        more OpenID required logic.\n-        \"\"\"\n-        self.login_endpoint = f.__name__\n-        @wraps(f)\n-        def decorated(*args, **kwargs):\n-            if request.args.get('openid_complete') != u'yes':\n-                return f(*args, **kwargs)\n-            consumer = Consumer(session, self.create_store())\n-            openid_response = consumer.complete(request.args.to_dict(),\n-                                                self.get_current_url())\n-            if openid_response.status == SUCCESS:\n-                return self.after_login_func(openid_response.identity_url)\n-            elif openid_response.status == CANCEL:\n-                self.signal_error(u'The request was cancelled')\n-                return redirect(self.get_current_url())\n-            self.signal_error(u'OpenID authentication error')\n-            return redirect(self.get_current_url())\n-        return decorated\n-\n-    def try_login(self, identity_url):\n-        \"\"\"This tries to login with the given identity URL.  This function\n-        must be called from the login_handler.\n-        \"\"\"\n-        try:\n-            consumer = Consumer(session, self.create_store())\n-            auth_request = consumer.begin(identity_url)\n-        except discover.DiscoveryFailure:\n-            self.signal_error(u'The OpenID was invalid')\n-            return redirect(self.get_current_url())\n-        trust_root = request.host_url\n-        return redirect(auth_request.redirectURL(request.host_url,\n-                                                 self.get_success_url()))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#34e3d64892f2281aa1b6f6357c345b0a357ee51a", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 2 | Lines Deleted: 5 | Files Changed: 1 | Hunks: 3 | Methods Changed: 0 | Complexity Δ (Sum/Max): 0/0 | Churn Δ: 7 | Churn Cumulative: 302 | Contributors (this commit): 2 | Commits (past 90d): 7 | Contributors (cumulative): 2 | DMM Complexity: None\n\nDIFF:\n@@ -16,7 +16,7 @@ import sys, os\n # If extensions (or modules to document with autodoc) are in another directory,\n # add these directories to sys.path here. If the directory is relative to the\n # documentation root, use os.path.abspath to make it absolute, like shown here.\n-sys.path.append(os.path.abspath('.'))\n+sys.path.append(os.path.abspath('_themes'))\n \n # -- General configuration -----------------------------------------------------\n \n@@ -79,9 +79,6 @@ exclude_patterns = ['_build']\n # output. They are ignored by default.\n #show_authors = False\n \n-# The name of the Pygments (syntax highlighting) style to use.\n-pygments_style = 'flaskext.FlaskyStyle'\n-\n # A list of ignored prefixes for module index sorting.\n #modindex_common_prefix = []\n \n@@ -90,7 +87,7 @@ pygments_style = 'flaskext.FlaskyStyle'\n \n # The theme to use for HTML and HTML Help pages.  Major themes that come with\n # Sphinx are currently 'default' and 'sphinxdoc'.\n-html_theme = 'flasky'\n+html_theme = 'flask'\n \n # Theme options are theme-specific and customize the look and feel of a theme\n # further.  For a list of options available for each theme, see the\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
{"custom_id": "flask#2d87e9bc37ef1ce8f9068fac92783a4fe3d3d382", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o", "messages": [{"role": "user", "content": "You are a senior reviewer.\n\nCommit Summary:\nLines Added: 158 | Lines Deleted: 2 | Files Changed: 2 | Hunks: 7 | Methods Changed: 6 | Complexity Δ (Sum/Max): -34/0 | Churn Δ: 160 | Churn Cumulative: 2363 | Contributors (this commit): 6 | Commits (past 90d): 87 | Contributors (cumulative): 10 | DMM Complexity: 0.6730769230769231\n\nDIFF:\n@@ -12,12 +12,13 @@\n from __future__ import with_statement\n import os\n import sys\n+import mimetypes\n from datetime import datetime, timedelta\n \n from jinja2 import Environment, PackageLoader, FileSystemLoader\n from werkzeug import Request as RequestBase, Response as ResponseBase, \\\n      LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \\\n-     ImmutableDict, cached_property\n+     ImmutableDict, cached_property, wrap_file, Headers\n from werkzeug.routing import Map, Rule\n from werkzeug.exceptions import HTTPException\n from werkzeug.contrib.securecookie import SecureCookie\n@@ -235,6 +236,71 @@ def jsonify(*args, **kwargs):\n         indent=None if request.is_xhr else 2), mimetype='application/json')\n \n \n+def send_file(filename_or_fp, mimetype=None, as_attachment=False,\n+              attachment_filename=None):\n+    \"\"\"Sends the contents of a file to the client.  This will use the\n+    most efficient method available and configured.  By default it will\n+    try to use the WSGI server's file_wrapper support.  Alternatively\n+    you can set the application's :attr:`~Flask.use_x_sendfile` attribute\n+    to ``True`` to directly emit an `X-Sendfile` header.  This however\n+    requires support of the underlying webserver for `X-Sendfile`.\n+\n+    By default it will try to guess the mimetype for you, but you can\n+    also explicitly provide one.  For extra security you probably want\n+    to sent certain files as attachment (HTML for instance).\n+\n+    .. versionadded:: 0.2\n+\n+    :param filename_or_fp: the filename of the file to send.  This is\n+                           relative to the :attr:`~Flask.root_path` if a\n+                           relative path is specified.\n+                           Alternatively a file object might be provided\n+                           in which case `X-Sendfile` might not work and\n+                           fall back to the traditional method.\n+    :param mimetype: the mimetype of the file if provided, otherwise\n+                     auto detection happens.\n+    :param as_attachment: set to `True` if you want to send this file with\n+                          a ``Content-Disposition: attachment`` header.\n+    :param attachment_filename: the filename for the attachment if it\n+                                differs from the file's filename.\n+    \"\"\"\n+    if isinstance(filename_or_fp, basestring):\n+        filename = filename_or_fp\n+        file = None\n+    else:\n+        file = filename_or_fp\n+        filename = getattr(file, 'name', None)\n+    if filename is not None:\n+        filename = os.path.join(current_app.root_path, filename)\n+    if mimetype is None and (filename or attachment_filename):\n+        mimetype = mimetypes.guess_type(filename or attachment_filename)[0]\n+    if mimetype is None:\n+        mimetype = 'application/octet-stream'\n+\n+    headers = Headers()\n+    if as_attachment:\n+        if attachment_filename is None:\n+            if filename is None:\n+                raise TypeError('filename unavailable, required for '\n+                                'sending as attachment')\n+            attachment_filename = os.path.basename(filename)\n+        headers.add('Content-Disposition', 'attachment',\n+                    filename=attachment_filename)\n+\n+    if current_app.use_x_sendfile and filename:\n+        if file is not None:\n+            file.close()\n+        headers['X-Sendfile'] = filename\n+        data = None\n+    else:\n+        if file is None:\n+            file = open(filename, 'rb')\n+        data = wrap_file(request.environ, file)\n+\n+    return Response(data, mimetype=mimetype, headers=headers,\n+                    direct_passthrough=True)\n+\n+\n def render_template(template_name, **context):\n     \"\"\"Renders a template from the template folder with the given\n     context.\n@@ -344,6 +410,13 @@ class Flask(object):\n     #: permanent session survive for roughly one month.\n     permanent_session_lifetime = timedelta(days=31)\n \n+    #: Enable this if you want to use the X-Sendfile feature.  Keep in\n+    #: mind that the server has to support this.  This only affects files\n+    #: sent with the :func:`send_file` method.\n+    #:\n+    #: .. versionadded:: 0.2\n+    use_x_sendfile = False\n+\n     #: options that are passed directly to the Jinja2 environment\n     jinja_options = ImmutableDict(\n         autoescape=True,\n\n@@ -17,7 +17,8 @@ import flask\n import unittest\n import tempfile\n from datetime import datetime\n-from werkzeug import parse_date\n+from werkzeug import parse_date, parse_options_header\n+from cStringIO import StringIO\n \n \n example_path = os.path.join(os.path.dirname(__file__), '..', 'examples')\n@@ -382,6 +383,87 @@ class TemplatingTestCase(unittest.TestCase):\n         assert rv.data == 'dcba'\n \n \n+class SendfileTestCase(unittest.TestCase):\n+\n+    def test_send_file_regular(self):\n+        app = flask.Flask(__name__)\n+        with app.test_request_context():\n+            rv = flask.send_file('static/index.html')\n+            assert rv.direct_passthrough\n+            assert rv.mimetype == 'text/html'\n+            with app.open_resource('static/index.html') as f:\n+                assert rv.data == f.read()\n+\n+    def test_send_file_xsendfile(self):\n+        app = flask.Flask(__name__)\n+        app.use_x_sendfile = True\n+        with app.test_request_context():\n+            rv = flask.send_file('static/index.html')\n+            assert rv.direct_passthrough\n+            assert 'x-sendfile' in rv.headers\n+            assert rv.headers['x-sendfile'] == \\\n+                os.path.join(app.root_path, 'static/index.html')\n+            assert rv.mimetype == 'text/html'\n+\n+    def test_send_file_object(self):\n+        app = flask.Flask(__name__)\n+        with app.test_request_context():\n+            f = open(os.path.join(app.root_path, 'static/index.html'))\n+            rv = flask.send_file(f)\n+            with app.open_resource('static/index.html') as f:\n+                assert rv.data == f.read()\n+            assert rv.mimetype == 'text/html'\n+\n+        app.use_x_sendfile = True\n+        with app.test_request_context():\n+            f = open(os.path.join(app.root_path, 'static/index.html'))\n+            rv = flask.send_file(f)\n+            assert rv.mimetype == 'text/html'\n+            assert 'x-sendfile' in rv.headers\n+            assert rv.headers['x-sendfile'] == \\\n+                os.path.join(app.root_path, 'static/index.html')\n+\n+        app.use_x_sendfile = False\n+        with app.test_request_context():\n+            f = StringIO('Test')\n+            rv = flask.send_file(f)\n+            assert rv.data == 'Test'\n+            assert rv.mimetype == 'application/octet-stream'\n+            f = StringIO('Test')\n+            rv = flask.send_file(f, mimetype='text/plain')\n+            assert rv.data == 'Test'\n+            assert rv.mimetype == 'text/plain'\n+\n+        app.use_x_sendfile = True\n+        with app.test_request_context():\n+            f = StringIO('Test')\n+            rv = flask.send_file(f)\n+            assert 'x-sendfile' not in rv.headers\n+\n+    def test_attachment(self):\n+        app = flask.Flask(__name__)\n+        with app.test_request_context():\n+            f = open(os.path.join(app.root_path, 'static/index.html'))\n+            rv = flask.send_file(f, as_attachment=True)\n+            value, options = parse_options_header(rv.headers['Content-Disposition'])\n+            assert value == 'attachment'\n+\n+        with app.test_request_context():\n+            assert options['filename'] == 'index.html'\n+            rv = flask.send_file('static/index.html', as_attachment=True)\n+            value, options = parse_options_header(rv.headers['Content-Disposition'])\n+            assert value == 'attachment'\n+            assert options['filename'] == 'index.html'\n+\n+        with app.test_request_context():\n+            rv = flask.send_file(StringIO('Test'), as_attachment=True,\n+                                 attachment_filename='index.txt')\n+            assert rv.mimetype == 'text/plain'\n+            value, options = parse_options_header(rv.headers['Content-Disposition'])\n+            assert value == 'attachment'\n+            assert options['filename'] == 'index.txt'\n+\n+\n def suite():\n     from minitwit_tests import MiniTwitTestCase\n     from flaskr_tests import FlaskrTestCase\n@@ -389,6 +471,7 @@ def suite():\n     suite.addTest(unittest.makeSuite(ContextTestCase))\n     suite.addTest(unittest.makeSuite(BasicFunctionalityTestCase))\n     suite.addTest(unittest.makeSuite(TemplatingTestCase))\n+    suite.addTest(unittest.makeSuite(SendfileTestCase))\n     if flask.json_available:\n         suite.addTest(unittest.makeSuite(JSONTestCase))\n     suite.addTest(unittest.makeSuite(MiniTwitTestCase))\n\n\nQuestion: Does this commit introduce technical debt? Answer yes or no."}], "max_tokens": 1, "temperature": 0}}
